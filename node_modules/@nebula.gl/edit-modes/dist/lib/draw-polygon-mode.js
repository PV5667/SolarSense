"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPolygonMode = void 0;

var _lineIntersect = _interopRequireDefault(require("@turf/line-intersect"));

var _helpers = require("@turf/helpers");

var _utils = require("../utils");

var _geojsonEditMode = require("./geojson-edit-mode");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DrawPolygonMode = /*#__PURE__*/function (_GeoJsonEditMode) {
  _inherits(DrawPolygonMode, _GeoJsonEditMode);

  var _super = _createSuper(DrawPolygonMode);

  function DrawPolygonMode() {
    _classCallCheck(this, DrawPolygonMode);

    return _super.apply(this, arguments);
  }

  _createClass(DrawPolygonMode, [{
    key: "createTentativeFeature",
    value: function createTentativeFeature(props) {
      var lastPointerMoveEvent = props.lastPointerMoveEvent;
      var clickSequence = this.getClickSequence();
      var lastCoords = lastPointerMoveEvent ? [lastPointerMoveEvent.mapCoords] : [];
      var tentativeFeature;

      if (clickSequence.length === 1 || clickSequence.length === 2) {
        tentativeFeature = {
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'LineString',
            coordinates: [].concat(_toConsumableArray(clickSequence), lastCoords)
          }
        };
      } else if (clickSequence.length > 2) {
        tentativeFeature = {
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'Polygon',
            coordinates: [[].concat(_toConsumableArray(clickSequence), lastCoords, [clickSequence[0]])]
          }
        };
      }

      return tentativeFeature;
    }
  }, {
    key: "getGuides",
    value: function getGuides(props) {
      var _guides$features;

      var clickSequence = this.getClickSequence();
      var guides = {
        type: 'FeatureCollection',
        features: []
      };
      var tentativeFeature = this.createTentativeFeature(props);

      if (tentativeFeature) {
        guides.features.push(tentativeFeature);
      }

      var editHandles = clickSequence.map(function (clickedCoord, index) {
        return {
          type: 'Feature',
          properties: {
            guideType: 'editHandle',
            editHandleType: 'existing',
            featureIndex: -1,
            positionIndexes: [index]
          },
          geometry: {
            type: 'Point',
            coordinates: clickedCoord
          }
        };
      });

      (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(editHandles)); // @ts-ignore


      return guides;
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {
      var picks = event.picks;
      var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);
      var clickSequence = this.getClickSequence();
      var overlappingLines = false;

      if (clickSequence.length > 2 && props.modeConfig && props.modeConfig.preventOverlappingLines) {
        var currentLine = (0, _helpers.lineString)([clickSequence[clickSequence.length - 1], event.mapCoords]);
        var otherLines = (0, _helpers.lineString)(_toConsumableArray(clickSequence.slice(0, clickSequence.length - 1)));
        var intersectingPoints = (0, _lineIntersect["default"])(currentLine, otherLines);

        if (intersectingPoints.features.length > 0) {
          overlappingLines = true;
        }
      }

      var positionAdded = false;

      if (!clickedEditHandle && !overlappingLines) {
        // Don't add another point right next to an existing one
        this.addClickSequence(event);
        positionAdded = true;
      }

      if (clickSequence.length > 2 && clickedEditHandle && Array.isArray(clickedEditHandle.properties.positionIndexes) && (clickedEditHandle.properties.positionIndexes[0] === 0 || clickedEditHandle.properties.positionIndexes[0] === clickSequence.length - 1)) {
        // They clicked the first or last point (or double-clicked), so complete the polygon
        // Remove the hovered position
        var polygonToAdd = {
          type: 'Polygon',
          coordinates: [[].concat(_toConsumableArray(clickSequence), [clickSequence[0]])]
        };
        this.resetClickSequence();
        var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);

        if (editAction) {
          props.onEdit(editAction);
        }
      } else if (positionAdded) {
        // new tentative point
        props.onEdit({
          // data is the same
          updatedData: props.data,
          editType: 'addTentativePosition',
          editContext: {
            position: event.mapCoords
          }
        });
      }
    }
  }, {
    key: "handleKeyUp",
    value: function handleKeyUp(event, props) {
      if (event.key === 'Enter') {
        var clickSequence = this.getClickSequence();

        if (clickSequence.length > 2) {
          var polygonToAdd = {
            type: 'Polygon',
            coordinates: [[].concat(_toConsumableArray(clickSequence), [clickSequence[0]])]
          };
          this.resetClickSequence();
          var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);

          if (editAction) {
            props.onEdit(editAction);
          }
        }
      }
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      props.onUpdateCursor('cell');

      _get(_getPrototypeOf(DrawPolygonMode.prototype), "handlePointerMove", this).call(this, event, props);
    }
  }]);

  return DrawPolygonMode;
}(_geojsonEditMode.GeoJsonEditMode);

exports.DrawPolygonMode = DrawPolygonMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1wb2x5Z29uLW1vZGUudHMiXSwibmFtZXMiOlsiRHJhd1BvbHlnb25Nb2RlIiwicHJvcHMiLCJsYXN0UG9pbnRlck1vdmVFdmVudCIsImNsaWNrU2VxdWVuY2UiLCJnZXRDbGlja1NlcXVlbmNlIiwibGFzdENvb3JkcyIsIm1hcENvb3JkcyIsInRlbnRhdGl2ZUZlYXR1cmUiLCJsZW5ndGgiLCJ0eXBlIiwicHJvcGVydGllcyIsImd1aWRlVHlwZSIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJndWlkZXMiLCJmZWF0dXJlcyIsImNyZWF0ZVRlbnRhdGl2ZUZlYXR1cmUiLCJwdXNoIiwiZWRpdEhhbmRsZXMiLCJtYXAiLCJjbGlja2VkQ29vcmQiLCJpbmRleCIsImVkaXRIYW5kbGVUeXBlIiwiZmVhdHVyZUluZGV4IiwicG9zaXRpb25JbmRleGVzIiwiZXZlbnQiLCJwaWNrcyIsImNsaWNrZWRFZGl0SGFuZGxlIiwib3ZlcmxhcHBpbmdMaW5lcyIsIm1vZGVDb25maWciLCJwcmV2ZW50T3ZlcmxhcHBpbmdMaW5lcyIsImN1cnJlbnRMaW5lIiwib3RoZXJMaW5lcyIsInNsaWNlIiwiaW50ZXJzZWN0aW5nUG9pbnRzIiwicG9zaXRpb25BZGRlZCIsImFkZENsaWNrU2VxdWVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJwb2x5Z29uVG9BZGQiLCJyZXNldENsaWNrU2VxdWVuY2UiLCJlZGl0QWN0aW9uIiwiZ2V0QWRkRmVhdHVyZU9yQm9vbGVhblBvbHlnb25BY3Rpb24iLCJvbkVkaXQiLCJ1cGRhdGVkRGF0YSIsImRhdGEiLCJlZGl0VHlwZSIsImVkaXRDb250ZXh0IiwicG9zaXRpb24iLCJrZXkiLCJvblVwZGF0ZUN1cnNvciIsIkdlb0pzb25FZGl0TW9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQVNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFYUEsZTs7Ozs7Ozs7Ozs7OzsyQ0FDWUMsSyxFQUF1RDtBQUFBLFVBQ3BFQyxvQkFEb0UsR0FDM0NELEtBRDJDLENBQ3BFQyxvQkFEb0U7QUFFNUUsVUFBTUMsYUFBYSxHQUFHLEtBQUtDLGdCQUFMLEVBQXRCO0FBRUEsVUFBTUMsVUFBVSxHQUFHSCxvQkFBb0IsR0FBRyxDQUFDQSxvQkFBb0IsQ0FBQ0ksU0FBdEIsQ0FBSCxHQUFzQyxFQUE3RTtBQUVBLFVBQUlDLGdCQUFKOztBQUNBLFVBQUlKLGFBQWEsQ0FBQ0ssTUFBZCxLQUF5QixDQUF6QixJQUE4QkwsYUFBYSxDQUFDSyxNQUFkLEtBQXlCLENBQTNELEVBQThEO0FBQzVERCxRQUFBQSxnQkFBZ0IsR0FBRztBQUNqQkUsVUFBQUEsSUFBSSxFQUFFLFNBRFc7QUFFakJDLFVBQUFBLFVBQVUsRUFBRTtBQUNWQyxZQUFBQSxTQUFTLEVBQUU7QUFERCxXQUZLO0FBS2pCQyxVQUFBQSxRQUFRLEVBQUU7QUFDUkgsWUFBQUEsSUFBSSxFQUFFLFlBREU7QUFFUkksWUFBQUEsV0FBVywrQkFBTVYsYUFBTixHQUF3QkUsVUFBeEI7QUFGSDtBQUxPLFNBQW5CO0FBVUQsT0FYRCxNQVdPLElBQUlGLGFBQWEsQ0FBQ0ssTUFBZCxHQUF1QixDQUEzQixFQUE4QjtBQUNuQ0QsUUFBQUEsZ0JBQWdCLEdBQUc7QUFDakJFLFVBQUFBLElBQUksRUFBRSxTQURXO0FBRWpCQyxVQUFBQSxVQUFVLEVBQUU7QUFDVkMsWUFBQUEsU0FBUyxFQUFFO0FBREQsV0FGSztBQUtqQkMsVUFBQUEsUUFBUSxFQUFFO0FBQ1JILFlBQUFBLElBQUksRUFBRSxTQURFO0FBRVJJLFlBQUFBLFdBQVcsRUFBRSw4QkFBS1YsYUFBTCxHQUF1QkUsVUFBdkIsR0FBbUNGLGFBQWEsQ0FBQyxDQUFELENBQWhEO0FBRkw7QUFMTyxTQUFuQjtBQVVEOztBQUVELGFBQU9JLGdCQUFQO0FBQ0Q7Ozs4QkFFU04sSyxFQUE2RDtBQUFBOztBQUNyRSxVQUFNRSxhQUFhLEdBQUcsS0FBS0MsZ0JBQUwsRUFBdEI7QUFFQSxVQUFNVSxNQUFNLEdBQUc7QUFDYkwsUUFBQUEsSUFBSSxFQUFFLG1CQURPO0FBRWJNLFFBQUFBLFFBQVEsRUFBRTtBQUZHLE9BQWY7QUFLQSxVQUFNUixnQkFBZ0IsR0FBRyxLQUFLUyxzQkFBTCxDQUE0QmYsS0FBNUIsQ0FBekI7O0FBQ0EsVUFBSU0sZ0JBQUosRUFBc0I7QUFDcEJPLFFBQUFBLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkUsSUFBaEIsQ0FBcUJWLGdCQUFyQjtBQUNEOztBQUVELFVBQU1XLFdBQVcsR0FBR2YsYUFBYSxDQUFDZ0IsR0FBZCxDQUFrQixVQUFDQyxZQUFELEVBQWVDLEtBQWY7QUFBQSxlQUEwQjtBQUM5RFosVUFBQUEsSUFBSSxFQUFFLFNBRHdEO0FBRTlEQyxVQUFBQSxVQUFVLEVBQUU7QUFDVkMsWUFBQUEsU0FBUyxFQUFFLFlBREQ7QUFFVlcsWUFBQUEsY0FBYyxFQUFFLFVBRk47QUFHVkMsWUFBQUEsWUFBWSxFQUFFLENBQUMsQ0FITDtBQUlWQyxZQUFBQSxlQUFlLEVBQUUsQ0FBQ0gsS0FBRDtBQUpQLFdBRmtEO0FBUTlEVCxVQUFBQSxRQUFRLEVBQUU7QUFDUkgsWUFBQUEsSUFBSSxFQUFFLE9BREU7QUFFUkksWUFBQUEsV0FBVyxFQUFFTztBQUZMO0FBUm9ELFNBQTFCO0FBQUEsT0FBbEIsQ0FBcEI7O0FBY0EsMEJBQUFOLE1BQU0sQ0FBQ0MsUUFBUCxFQUFnQkUsSUFBaEIsNENBQXdCQyxXQUF4QixHQTNCcUUsQ0E0QnJFOzs7QUFDQSxhQUFPSixNQUFQO0FBQ0Q7OztnQ0FFV1csSyxFQUFtQnhCLEssRUFBcUM7QUFBQSxVQUMxRHlCLEtBRDBELEdBQ2hERCxLQURnRCxDQUMxREMsS0FEMEQ7QUFFbEUsVUFBTUMsaUJBQWlCLEdBQUcsZ0NBQW9CRCxLQUFwQixDQUExQjtBQUNBLFVBQU12QixhQUFhLEdBQUcsS0FBS0MsZ0JBQUwsRUFBdEI7QUFFQSxVQUFJd0IsZ0JBQWdCLEdBQUcsS0FBdkI7O0FBQ0EsVUFBSXpCLGFBQWEsQ0FBQ0ssTUFBZCxHQUF1QixDQUF2QixJQUE0QlAsS0FBSyxDQUFDNEIsVUFBbEMsSUFBZ0Q1QixLQUFLLENBQUM0QixVQUFOLENBQWlCQyx1QkFBckUsRUFBOEY7QUFDNUYsWUFBTUMsV0FBVyxHQUFHLHlCQUFlLENBQ2pDNUIsYUFBYSxDQUFDQSxhQUFhLENBQUNLLE1BQWQsR0FBdUIsQ0FBeEIsQ0FEb0IsRUFFakNpQixLQUFLLENBQUNuQixTQUYyQixDQUFmLENBQXBCO0FBSUEsWUFBTTBCLFVBQVUsR0FBRyw0Q0FBbUI3QixhQUFhLENBQUM4QixLQUFkLENBQW9CLENBQXBCLEVBQXVCOUIsYUFBYSxDQUFDSyxNQUFkLEdBQXVCLENBQTlDLENBQW5CLEVBQW5CO0FBQ0EsWUFBTTBCLGtCQUFrQixHQUFHLCtCQUFjSCxXQUFkLEVBQTJCQyxVQUEzQixDQUEzQjs7QUFDQSxZQUFJRSxrQkFBa0IsQ0FBQ25CLFFBQW5CLENBQTRCUCxNQUE1QixHQUFxQyxDQUF6QyxFQUE0QztBQUMxQ29CLFVBQUFBLGdCQUFnQixHQUFHLElBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJTyxhQUFhLEdBQUcsS0FBcEI7O0FBQ0EsVUFBSSxDQUFDUixpQkFBRCxJQUFzQixDQUFDQyxnQkFBM0IsRUFBNkM7QUFDM0M7QUFDQSxhQUFLUSxnQkFBTCxDQUFzQlgsS0FBdEI7QUFDQVUsUUFBQUEsYUFBYSxHQUFHLElBQWhCO0FBQ0Q7O0FBRUQsVUFDRWhDLGFBQWEsQ0FBQ0ssTUFBZCxHQUF1QixDQUF2QixJQUNBbUIsaUJBREEsSUFFQVUsS0FBSyxDQUFDQyxPQUFOLENBQWNYLGlCQUFpQixDQUFDakIsVUFBbEIsQ0FBNkJjLGVBQTNDLENBRkEsS0FHQ0csaUJBQWlCLENBQUNqQixVQUFsQixDQUE2QmMsZUFBN0IsQ0FBNkMsQ0FBN0MsTUFBb0QsQ0FBcEQsSUFDQ0csaUJBQWlCLENBQUNqQixVQUFsQixDQUE2QmMsZUFBN0IsQ0FBNkMsQ0FBN0MsTUFBb0RyQixhQUFhLENBQUNLLE1BQWQsR0FBdUIsQ0FKN0UsQ0FERixFQU1FO0FBQ0E7QUFFQTtBQUNBLFlBQU0rQixZQUFxQixHQUFHO0FBQzVCOUIsVUFBQUEsSUFBSSxFQUFFLFNBRHNCO0FBRTVCSSxVQUFBQSxXQUFXLEVBQUUsOEJBQUtWLGFBQUwsSUFBb0JBLGFBQWEsQ0FBQyxDQUFELENBQWpDO0FBRmUsU0FBOUI7QUFLQSxhQUFLcUMsa0JBQUw7QUFFQSxZQUFNQyxVQUFVLEdBQUcsS0FBS0MsbUNBQUwsQ0FBeUNILFlBQXpDLEVBQXVEdEMsS0FBdkQsQ0FBbkI7O0FBQ0EsWUFBSXdDLFVBQUosRUFBZ0I7QUFDZHhDLFVBQUFBLEtBQUssQ0FBQzBDLE1BQU4sQ0FBYUYsVUFBYjtBQUNEO0FBQ0YsT0FyQkQsTUFxQk8sSUFBSU4sYUFBSixFQUFtQjtBQUN4QjtBQUNBbEMsUUFBQUEsS0FBSyxDQUFDMEMsTUFBTixDQUFhO0FBQ1g7QUFDQUMsVUFBQUEsV0FBVyxFQUFFM0MsS0FBSyxDQUFDNEMsSUFGUjtBQUdYQyxVQUFBQSxRQUFRLEVBQUUsc0JBSEM7QUFJWEMsVUFBQUEsV0FBVyxFQUFFO0FBQ1hDLFlBQUFBLFFBQVEsRUFBRXZCLEtBQUssQ0FBQ25CO0FBREw7QUFKRixTQUFiO0FBUUQ7QUFDRjs7O2dDQUVXbUIsSyxFQUFzQnhCLEssRUFBcUM7QUFDckUsVUFBSXdCLEtBQUssQ0FBQ3dCLEdBQU4sS0FBYyxPQUFsQixFQUEyQjtBQUN6QixZQUFNOUMsYUFBYSxHQUFHLEtBQUtDLGdCQUFMLEVBQXRCOztBQUNBLFlBQUlELGFBQWEsQ0FBQ0ssTUFBZCxHQUF1QixDQUEzQixFQUE4QjtBQUM1QixjQUFNK0IsWUFBcUIsR0FBRztBQUM1QjlCLFlBQUFBLElBQUksRUFBRSxTQURzQjtBQUU1QkksWUFBQUEsV0FBVyxFQUFFLDhCQUFLVixhQUFMLElBQW9CQSxhQUFhLENBQUMsQ0FBRCxDQUFqQztBQUZlLFdBQTlCO0FBSUEsZUFBS3FDLGtCQUFMO0FBRUEsY0FBTUMsVUFBVSxHQUFHLEtBQUtDLG1DQUFMLENBQXlDSCxZQUF6QyxFQUF1RHRDLEtBQXZELENBQW5COztBQUNBLGNBQUl3QyxVQUFKLEVBQWdCO0FBQ2R4QyxZQUFBQSxLQUFLLENBQUMwQyxNQUFOLENBQWFGLFVBQWI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7O3NDQUVpQmhCLEssRUFBeUJ4QixLLEVBQXFDO0FBQzlFQSxNQUFBQSxLQUFLLENBQUNpRCxjQUFOLENBQXFCLE1BQXJCOztBQUNBLDZGQUF3QnpCLEtBQXhCLEVBQStCeEIsS0FBL0I7QUFDRDs7OztFQW5Ka0NrRCxnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsaW5lSW50ZXJzZWN0IGZyb20gJ0B0dXJmL2xpbmUtaW50ZXJzZWN0JztcbmltcG9ydCB7IGxpbmVTdHJpbmcgYXMgdHVyZkxpbmVTdHJpbmcgfSBmcm9tICdAdHVyZi9oZWxwZXJzJztcbmltcG9ydCB7XG4gIENsaWNrRXZlbnQsXG4gIFBvaW50ZXJNb3ZlRXZlbnQsXG4gIE1vZGVQcm9wcyxcbiAgR3VpZGVGZWF0dXJlQ29sbGVjdGlvbixcbiAgVGVudGF0aXZlRmVhdHVyZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgUG9seWdvbiwgRmVhdHVyZUNvbGxlY3Rpb24gfSBmcm9tICcuLi9nZW9qc29uLXR5cGVzJztcbmltcG9ydCB7IGdldFBpY2tlZEVkaXRIYW5kbGUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBHZW9Kc29uRWRpdE1vZGUgfSBmcm9tICcuL2dlb2pzb24tZWRpdC1tb2RlJztcblxuZXhwb3J0IGNsYXNzIERyYXdQb2x5Z29uTW9kZSBleHRlbmRzIEdlb0pzb25FZGl0TW9kZSB7XG4gIGNyZWF0ZVRlbnRhdGl2ZUZlYXR1cmUocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBUZW50YXRpdmVGZWF0dXJlIHtcbiAgICBjb25zdCB7IGxhc3RQb2ludGVyTW92ZUV2ZW50IH0gPSBwcm9wcztcbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG5cbiAgICBjb25zdCBsYXN0Q29vcmRzID0gbGFzdFBvaW50ZXJNb3ZlRXZlbnQgPyBbbGFzdFBvaW50ZXJNb3ZlRXZlbnQubWFwQ29vcmRzXSA6IFtdO1xuXG4gICAgbGV0IHRlbnRhdGl2ZUZlYXR1cmU7XG4gICAgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID09PSAxIHx8IGNsaWNrU2VxdWVuY2UubGVuZ3RoID09PSAyKSB7XG4gICAgICB0ZW50YXRpdmVGZWF0dXJlID0ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBndWlkZVR5cGU6ICd0ZW50YXRpdmUnLFxuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICBjb29yZGluYXRlczogWy4uLmNsaWNrU2VxdWVuY2UsIC4uLmxhc3RDb29yZHNdLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID4gMikge1xuICAgICAgdGVudGF0aXZlRmVhdHVyZSA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZ3VpZGVUeXBlOiAndGVudGF0aXZlJyxcbiAgICAgICAgfSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFtbLi4uY2xpY2tTZXF1ZW5jZSwgLi4ubGFzdENvb3JkcywgY2xpY2tTZXF1ZW5jZVswXV1dLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVudGF0aXZlRmVhdHVyZTtcbiAgfVxuXG4gIGdldEd1aWRlcyhwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IEd1aWRlRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAgIGNvbnN0IGNsaWNrU2VxdWVuY2UgPSB0aGlzLmdldENsaWNrU2VxdWVuY2UoKTtcblxuICAgIGNvbnN0IGd1aWRlcyA9IHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICBmZWF0dXJlczogW10sXG4gICAgfTtcblxuICAgIGNvbnN0IHRlbnRhdGl2ZUZlYXR1cmUgPSB0aGlzLmNyZWF0ZVRlbnRhdGl2ZUZlYXR1cmUocHJvcHMpO1xuICAgIGlmICh0ZW50YXRpdmVGZWF0dXJlKSB7XG4gICAgICBndWlkZXMuZmVhdHVyZXMucHVzaCh0ZW50YXRpdmVGZWF0dXJlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlZGl0SGFuZGxlcyA9IGNsaWNrU2VxdWVuY2UubWFwKChjbGlja2VkQ29vcmQsIGluZGV4KSA9PiAoe1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBndWlkZVR5cGU6ICdlZGl0SGFuZGxlJyxcbiAgICAgICAgZWRpdEhhbmRsZVR5cGU6ICdleGlzdGluZycsXG4gICAgICAgIGZlYXR1cmVJbmRleDogLTEsXG4gICAgICAgIHBvc2l0aW9uSW5kZXhlczogW2luZGV4XSxcbiAgICAgIH0sXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY2xpY2tlZENvb3JkLFxuICAgICAgfSxcbiAgICB9KSk7XG5cbiAgICBndWlkZXMuZmVhdHVyZXMucHVzaCguLi5lZGl0SGFuZGxlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBndWlkZXM7XG4gIH1cblxuICBoYW5kbGVDbGljayhldmVudDogQ2xpY2tFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBjb25zdCB7IHBpY2tzIH0gPSBldmVudDtcbiAgICBjb25zdCBjbGlja2VkRWRpdEhhbmRsZSA9IGdldFBpY2tlZEVkaXRIYW5kbGUocGlja3MpO1xuICAgIGNvbnN0IGNsaWNrU2VxdWVuY2UgPSB0aGlzLmdldENsaWNrU2VxdWVuY2UoKTtcblxuICAgIGxldCBvdmVybGFwcGluZ0xpbmVzID0gZmFsc2U7XG4gICAgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID4gMiAmJiBwcm9wcy5tb2RlQ29uZmlnICYmIHByb3BzLm1vZGVDb25maWcucHJldmVudE92ZXJsYXBwaW5nTGluZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gdHVyZkxpbmVTdHJpbmcoW1xuICAgICAgICBjbGlja1NlcXVlbmNlW2NsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMV0sXG4gICAgICAgIGV2ZW50Lm1hcENvb3JkcyxcbiAgICAgIF0pO1xuICAgICAgY29uc3Qgb3RoZXJMaW5lcyA9IHR1cmZMaW5lU3RyaW5nKFsuLi5jbGlja1NlcXVlbmNlLnNsaWNlKDAsIGNsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMSldKTtcbiAgICAgIGNvbnN0IGludGVyc2VjdGluZ1BvaW50cyA9IGxpbmVJbnRlcnNlY3QoY3VycmVudExpbmUsIG90aGVyTGluZXMpO1xuICAgICAgaWYgKGludGVyc2VjdGluZ1BvaW50cy5mZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG92ZXJsYXBwaW5nTGluZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwb3NpdGlvbkFkZGVkID0gZmFsc2U7XG4gICAgaWYgKCFjbGlja2VkRWRpdEhhbmRsZSAmJiAhb3ZlcmxhcHBpbmdMaW5lcykge1xuICAgICAgLy8gRG9uJ3QgYWRkIGFub3RoZXIgcG9pbnQgcmlnaHQgbmV4dCB0byBhbiBleGlzdGluZyBvbmVcbiAgICAgIHRoaXMuYWRkQ2xpY2tTZXF1ZW5jZShldmVudCk7XG4gICAgICBwb3NpdGlvbkFkZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBjbGlja1NlcXVlbmNlLmxlbmd0aCA+IDIgJiZcbiAgICAgIGNsaWNrZWRFZGl0SGFuZGxlICYmXG4gICAgICBBcnJheS5pc0FycmF5KGNsaWNrZWRFZGl0SGFuZGxlLnByb3BlcnRpZXMucG9zaXRpb25JbmRleGVzKSAmJlxuICAgICAgKGNsaWNrZWRFZGl0SGFuZGxlLnByb3BlcnRpZXMucG9zaXRpb25JbmRleGVzWzBdID09PSAwIHx8XG4gICAgICAgIGNsaWNrZWRFZGl0SGFuZGxlLnByb3BlcnRpZXMucG9zaXRpb25JbmRleGVzWzBdID09PSBjbGlja1NlcXVlbmNlLmxlbmd0aCAtIDEpXG4gICAgKSB7XG4gICAgICAvLyBUaGV5IGNsaWNrZWQgdGhlIGZpcnN0IG9yIGxhc3QgcG9pbnQgKG9yIGRvdWJsZS1jbGlja2VkKSwgc28gY29tcGxldGUgdGhlIHBvbHlnb25cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBob3ZlcmVkIHBvc2l0aW9uXG4gICAgICBjb25zdCBwb2x5Z29uVG9BZGQ6IFBvbHlnb24gPSB7XG4gICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IFtbLi4uY2xpY2tTZXF1ZW5jZSwgY2xpY2tTZXF1ZW5jZVswXV1dLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5yZXNldENsaWNrU2VxdWVuY2UoKTtcblxuICAgICAgY29uc3QgZWRpdEFjdGlvbiA9IHRoaXMuZ2V0QWRkRmVhdHVyZU9yQm9vbGVhblBvbHlnb25BY3Rpb24ocG9seWdvblRvQWRkLCBwcm9wcyk7XG4gICAgICBpZiAoZWRpdEFjdGlvbikge1xuICAgICAgICBwcm9wcy5vbkVkaXQoZWRpdEFjdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbkFkZGVkKSB7XG4gICAgICAvLyBuZXcgdGVudGF0aXZlIHBvaW50XG4gICAgICBwcm9wcy5vbkVkaXQoe1xuICAgICAgICAvLyBkYXRhIGlzIHRoZSBzYW1lXG4gICAgICAgIHVwZGF0ZWREYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgICBlZGl0VHlwZTogJ2FkZFRlbnRhdGl2ZVBvc2l0aW9uJyxcbiAgICAgICAgZWRpdENvbnRleHQ6IHtcbiAgICAgICAgICBwb3NpdGlvbjogZXZlbnQubWFwQ29vcmRzLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KSB7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgY29uc3QgY2xpY2tTZXF1ZW5jZSA9IHRoaXMuZ2V0Q2xpY2tTZXF1ZW5jZSgpO1xuICAgICAgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID4gMikge1xuICAgICAgICBjb25zdCBwb2x5Z29uVG9BZGQ6IFBvbHlnb24gPSB7XG4gICAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbWy4uLmNsaWNrU2VxdWVuY2UsIGNsaWNrU2VxdWVuY2VbMF1dXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNldENsaWNrU2VxdWVuY2UoKTtcblxuICAgICAgICBjb25zdCBlZGl0QWN0aW9uID0gdGhpcy5nZXRBZGRGZWF0dXJlT3JCb29sZWFuUG9seWdvbkFjdGlvbihwb2x5Z29uVG9BZGQsIHByb3BzKTtcbiAgICAgICAgaWYgKGVkaXRBY3Rpb24pIHtcbiAgICAgICAgICBwcm9wcy5vbkVkaXQoZWRpdEFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVQb2ludGVyTW92ZShldmVudDogUG9pbnRlck1vdmVFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBwcm9wcy5vblVwZGF0ZUN1cnNvcignY2VsbCcpO1xuICAgIHN1cGVyLmhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50LCBwcm9wcyk7XG4gIH1cbn1cbiJdfQ==