"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toDeckColor = toDeckColor;
exports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;
exports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;
exports.distance2d = distance2d;
exports.mix = mix;
exports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;
exports.nearestPointOnLine = nearestPointOnLine;
exports.getPickedEditHandle = getPickedEditHandle;
exports.getPickedSnapSourceEditHandle = getPickedSnapSourceEditHandle;
exports.getNonGuidePicks = getNonGuidePicks;
exports.getPickedExistingEditHandle = getPickedExistingEditHandle;
exports.getPickedIntermediateEditHandle = getPickedIntermediateEditHandle;
exports.getPickedEditHandles = getPickedEditHandles;
exports.getEditHandlesForGeometry = getEditHandlesForGeometry;
exports.updateRectanglePosition = updateRectanglePosition;
exports.mapCoords = mapCoords;

var _destination = _interopRequireDefault(require("@turf/destination"));

var _bearing = _interopRequireDefault(require("@turf/bearing"));

var _pointToLineDistance = _interopRequireDefault(require("@turf/point-to-line-distance"));

var _meta = require("@turf/meta");

var _helpers = require("@turf/helpers");

var _invariant = require("@turf/invariant");

var _viewportMercatorProject = _interopRequireDefault(require("viewport-mercator-project"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function toDeckColor(color) {
  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];

  if (!Array.isArray(color)) {
    return defaultColor;
  }

  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];
} //
// a GeoJSON helper function that calls the provided function with
// an argument that is the most deeply-nested array having elements
// that are arrays of primitives as an argument, e.g.
//
// {
//   "type": "MultiPolygon",
//   "coordinates": [
//       [
//           [[30, 20], [45, 40], [10, 40], [30, 20]]
//       ],
//       [
//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]
//       ]
//   ]
// }
//
// the function would be called on:
//
// [[30, 20], [45, 40], [10, 40], [30, 20]]
//
// and
//
// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]
//


function recursivelyTraverseNestedArrays(array, prefix, fn) {
  if (!Array.isArray(array[0])) {
    return true;
  }

  for (var i = 0; i < array.length; i++) {
    if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {
      fn(array, prefix);
      break;
    }
  }

  return false;
}

function generatePointsParallelToLinePoints(p1, p2, mapCoords) {
  var lineString = {
    type: 'LineString',
    coordinates: [p1, p2]
  };
  var pt = (0, _helpers.point)(mapCoords);
  var ddistance = (0, _pointToLineDistance["default"])(pt, lineString);
  var lineBearing = (0, _bearing["default"])(p1, p2); // Check if current point is to the left or right of line
  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)
  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)

  var isPointToLeftOfLine = (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string

  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString
  // Add the distance as the current position moves away from the lineString

  var p3 = (0, _destination["default"])(p2, ddistance, orthogonalBearing);
  var p4 = (0, _destination["default"])(p1, ddistance, orthogonalBearing);
  return [p3.geometry.coordinates, p4.geometry.coordinates];
}

function distance2d(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

function mix(a, b, ratio) {
  return b * ratio + a * (1 - ratio);
}

function nearestPointOnProjectedLine(line, inPoint, viewport) {
  var wmViewport = new _viewportMercatorProject["default"](viewport); // Project the line to viewport, then find the nearest point

  var coordinates = line.geometry.coordinates;
  var projectedCoords = coordinates.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        x = _ref2[0],
        y = _ref2[1],
        _ref2$ = _ref2[2],
        z = _ref2$ === void 0 ? 0 : _ref2$;

    return wmViewport.project([x, y, z]);
  }); // @ts-ignore

  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),
      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),
      x = _wmViewport$project2[0],
      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));


  var minDistance = Infinity;
  var minPointInfo = {};
  projectedCoords.forEach(function (_ref3, index) {
    var _ref4 = _slicedToArray(_ref3, 2),
        x2 = _ref4[0],
        y2 = _ref4[1];

    if (index === 0) {
      return;
    }

    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),
        x1 = _projectedCoords[0],
        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]
    // convert to Ax + By + C = 0


    var A = y1 - y2;
    var B = x2 - x1;
    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

    var div = A * A + B * B;
    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds

    if (distance < minDistance) {
      minDistance = distance;
      minPointInfo = {
        index: index,
        x0: (B * (B * x - A * y) - A * C) / div,
        y0: (A * (-B * x + A * y) - B * C) / div
      };
    }
  }); // @ts-ignore

  var _minPointInfo = minPointInfo,
      index = _minPointInfo.index,
      x0 = _minPointInfo.x0,
      y0 = _minPointInfo.y0;

  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),
      x1 = _projectedCoords2[0],
      y1 = _projectedCoords2[1],
      _projectedCoords2$ = _projectedCoords2[2],
      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;

  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),
      x2 = _projectedCoords$inde[0],
      y2 = _projectedCoords$inde[1],
      _projectedCoords$inde2 = _projectedCoords$inde[2],
      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z


  var lineLength = distance2d(x1, y1, x2, y2);
  var startToPointLength = distance2d(x1, y1, x0, y0);
  var ratio = startToPointLength / lineLength;
  var z0 = mix(z1, z2, ratio);
  return {
    type: 'Feature',
    geometry: {
      type: 'Point',
      coordinates: wmViewport.unproject([x0, y0, z0])
    },
    properties: {
      // TODO: calculate the distance in proper units
      dist: minDistance,
      index: index - 1
    }
  };
}

function nearestPointOnLine(lines, inPoint, viewport) {
  var _lines$geometry, _lines$geometry2;

  var mercator;

  if (viewport) {
    mercator = new _viewportMercatorProject["default"](viewport);
  }

  var closestPoint = (0, _helpers.point)([Infinity, Infinity], {
    dist: Infinity
  });

  if (!((_lines$geometry = lines.geometry) === null || _lines$geometry === void 0 ? void 0 : _lines$geometry.coordinates.length) || ((_lines$geometry2 = lines.geometry) === null || _lines$geometry2 === void 0 ? void 0 : _lines$geometry2.coordinates.length) < 2) {
    return closestPoint;
  } // @ts-ignore


  (0, _meta.flattenEach)(lines, function (line) {
    var coords = (0, _invariant.getCoords)(line); // @ts-ignore

    var pointCoords = (0, _invariant.getCoords)(inPoint);
    var minDist;
    var to;
    var from;
    var x;
    var y;
    var segmentIdx;
    var dist;

    if (coords.length > 1 && pointCoords.length) {
      var lineCoordinates;
      var pointCoordinate; // If viewport is given, then translate these coordinates to pixels to increase precision

      if (mercator) {
        lineCoordinates = coords.map(function (lineCoordinate) {
          return mercator.project(lineCoordinate);
        });
        pointCoordinate = mercator.project(pointCoords);
      } else {
        lineCoordinates = coords;
        pointCoordinate = pointCoords;
      }

      for (var n = 1; n < lineCoordinates.length; n++) {
        if (lineCoordinates[n][0] !== lineCoordinates[n - 1][0]) {
          var slope = (lineCoordinates[n][1] - lineCoordinates[n - 1][1]) / (lineCoordinates[n][0] - lineCoordinates[n - 1][0]);
          var inverseSlope = lineCoordinates[n][1] - slope * lineCoordinates[n][0];
          dist = Math.abs(slope * pointCoordinate[0] + inverseSlope - pointCoordinate[1]) / Math.sqrt(slope * slope + 1);
        } else dist = Math.abs(pointCoordinate[0] - lineCoordinates[n][0]); // length^2 of line segment


        var rl2 = Math.pow(lineCoordinates[n][1] - lineCoordinates[n - 1][1], 2) + Math.pow(lineCoordinates[n][0] - lineCoordinates[n - 1][0], 2); // distance^2 of pt to end line segment

        var ln2 = Math.pow(lineCoordinates[n][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n][0] - pointCoordinate[0], 2); // distance^2 of pt to begin line segment

        var lnm12 = Math.pow(lineCoordinates[n - 1][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n - 1][0] - pointCoordinate[0], 2); // minimum distance^2 of pt to infinite line

        var dist2 = Math.pow(dist, 2); // calculated length^2 of line segment

        var calcrl2 = ln2 - dist2 + lnm12 - dist2; // redefine minimum distance to line segment (not infinite line) if necessary

        if (calcrl2 > rl2) {
          dist = Math.sqrt(Math.min(ln2, lnm12));
        }

        if (minDist === null || minDist === undefined || minDist > dist) {
          // eslint-disable-next-line max-depth
          if (calcrl2 > rl2) {
            // eslint-disable-next-line max-depth
            if (lnm12 < ln2) {
              to = 0; // nearer to previous point

              from = 1;
            } else {
              from = 0; // nearer to current point

              to = 1;
            }
          } else {
            // perpendicular from point intersects line segment
            to = Math.sqrt(lnm12 - dist2) / Math.sqrt(rl2);
            from = Math.sqrt(ln2 - dist2) / Math.sqrt(rl2);
          }

          minDist = dist;
          segmentIdx = n;
        }
      }

      var dx = lineCoordinates[segmentIdx - 1][0] - lineCoordinates[segmentIdx][0];
      var dy = lineCoordinates[segmentIdx - 1][1] - lineCoordinates[segmentIdx][1];
      x = lineCoordinates[segmentIdx - 1][0] - dx * to;
      y = lineCoordinates[segmentIdx - 1][1] - dy * to;
    } // index needs to be -1 because we have to account for the shift from initial backscan


    var snapPoint = {
      x: x,
      y: y,
      idx: segmentIdx - 1,
      to: to,
      from: from
    };

    if (mercator) {
      var pixelToLatLong = mercator.unproject([snapPoint.x, snapPoint.y]);
      snapPoint = {
        x: pixelToLatLong[0],
        y: pixelToLatLong[1],
        idx: segmentIdx - 1,
        to: to,
        from: from
      };
    }

    closestPoint = (0, _helpers.point)([snapPoint.x, snapPoint.y], {
      dist: Math.abs(snapPoint.from - snapPoint.to),
      index: snapPoint.idx
    });
  });
  return closestPoint;
}

function getPickedEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.length ? handles[0] : null;
}

function getPickedSnapSourceEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (handle) {
    return handle.properties.editHandleType === 'snap-source';
  });
}

function getNonGuidePicks(picks) {
  return picks && picks.filter(function (pick) {
    return !pick.isGuide;
  });
}

function getPickedExistingEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (_ref5) {
    var properties = _ref5.properties;
    return properties.featureIndex >= 0 && properties.editHandleType === 'existing';
  });
}

function getPickedIntermediateEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (_ref6) {
    var properties = _ref6.properties;
    return properties.featureIndex >= 0 && properties.editHandleType === 'intermediate';
  });
}

function getPickedEditHandles(picks) {
  var handles = picks && picks.filter(function (pick) {
    return pick.isGuide && pick.object.properties.guideType === 'editHandle';
  }).map(function (pick) {
    return pick.object;
  }) || [];
  return handles;
}

function getEditHandlesForGeometry(geometry, featureIndex) {
  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';
  var handles = [];

  switch (geometry.type) {
    case 'Point':
      // positions are not nested
      handles = [{
        type: 'Feature',
        properties: {
          guideType: 'editHandle',
          editHandleType: editHandleType,
          positionIndexes: [],
          featureIndex: featureIndex
        },
        geometry: {
          type: 'Point',
          coordinates: geometry.coordinates
        }
      }];
      break;

    case 'MultiPoint':
    case 'LineString':
      // positions are nested 1 level
      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));
      break;

    case 'Polygon':
    case 'MultiLineString':
      // positions are nested 2 levels
      for (var a = 0; a < geometry.coordinates.length; a++) {
        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));

        if (geometry.type === 'Polygon') {
          // Don't repeat the first/last handle for Polygons
          handles = handles.slice(0, -1);
        }
      }

      break;

    case 'MultiPolygon':
      // positions are nested 3 levels
      for (var _a = 0; _a < geometry.coordinates.length; _a++) {
        for (var b = 0; b < geometry.coordinates[_a].length; b++) {
          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons

          handles = handles.slice(0, -1);
        }
      }

      break;

    default:
      // @ts-ignore
      throw Error("Unhandled geometry type: ".concat(geometry.type));
  }

  return handles;
}

function getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {
  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';
  var editHandles = [];

  for (var i = 0; i < coordinates.length; i++) {
    var position = coordinates[i];
    editHandles.push({
      type: 'Feature',
      properties: {
        guideType: 'editHandle',
        positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [i]),
        featureIndex: featureIndex,
        editHandleType: editHandleType
      },
      geometry: {
        type: 'Point',
        coordinates: position
      }
    });
  }

  return editHandles;
}
/**
 * Calculates coordinates for a feature preserving rectangular shape.
 * @param feature Feature before modification.
 * @param editHandleIndex Index of the point to modify.
 * @param mapCoords New position for the point.
 * @returns Updated coordinates.
 */


function updateRectanglePosition(feature, editHandleIndex, mapCoords) {
  var coordinates = feature.geometry.coordinates;

  if (!coordinates) {
    return null;
  }

  var points = coordinates[0].slice(0, 4);
  points[editHandleIndex % 4] = mapCoords;
  var p0 = points[(editHandleIndex + 2) % 4];
  var p2 = points[editHandleIndex % 4];
  points[(editHandleIndex + 1) % 4] = [p2[0], p0[1]];
  points[(editHandleIndex + 3) % 4] = [p0[0], p2[1]];
  return [[].concat(_toConsumableArray(points), [points[0]])];
}
/** Creates a copy of feature's coordinates.
 * Each position in coordinates is transformed by calling the provided function.
 * @param coords Coordinates of a feature.
 * @param callback A function to transform each coordinate.
 * @retuns Transformed coordinates.
 */


function mapCoords(coords, callback) {
  if (typeof coords[0] === 'number') {
    if (!isNaN(coords[0]) && isFinite(coords[0])) {
      return callback(coords);
    }

    return coords;
  }

  return coords.map(function (coord) {
    return mapCoords(coord, callback);
  }).filter(Boolean);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy50cyJdLCJuYW1lcyI6WyJ0b0RlY2tDb2xvciIsImNvbG9yIiwiZGVmYXVsdENvbG9yIiwiQXJyYXkiLCJpc0FycmF5IiwicmVjdXJzaXZlbHlUcmF2ZXJzZU5lc3RlZEFycmF5cyIsImFycmF5IiwicHJlZml4IiwiZm4iLCJpIiwibGVuZ3RoIiwiZ2VuZXJhdGVQb2ludHNQYXJhbGxlbFRvTGluZVBvaW50cyIsInAxIiwicDIiLCJtYXBDb29yZHMiLCJsaW5lU3RyaW5nIiwidHlwZSIsImNvb3JkaW5hdGVzIiwicHQiLCJkZGlzdGFuY2UiLCJsaW5lQmVhcmluZyIsImlzUG9pbnRUb0xlZnRPZkxpbmUiLCJvcnRob2dvbmFsQmVhcmluZyIsInAzIiwicDQiLCJnZW9tZXRyeSIsImRpc3RhbmNlMmQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImR4IiwiZHkiLCJNYXRoIiwic3FydCIsIm1peCIsImEiLCJiIiwicmF0aW8iLCJuZWFyZXN0UG9pbnRPblByb2plY3RlZExpbmUiLCJsaW5lIiwiaW5Qb2ludCIsInZpZXdwb3J0Iiwid21WaWV3cG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJwcm9qZWN0ZWRDb29yZHMiLCJtYXAiLCJ4IiwieSIsInoiLCJwcm9qZWN0IiwibWluRGlzdGFuY2UiLCJJbmZpbml0eSIsIm1pblBvaW50SW5mbyIsImZvckVhY2giLCJpbmRleCIsIkEiLCJCIiwiQyIsImRpdiIsImRpc3RhbmNlIiwiYWJzIiwieDAiLCJ5MCIsInoxIiwiejIiLCJsaW5lTGVuZ3RoIiwic3RhcnRUb1BvaW50TGVuZ3RoIiwiejAiLCJ1bnByb2plY3QiLCJwcm9wZXJ0aWVzIiwiZGlzdCIsIm5lYXJlc3RQb2ludE9uTGluZSIsImxpbmVzIiwibWVyY2F0b3IiLCJjbG9zZXN0UG9pbnQiLCJjb29yZHMiLCJwb2ludENvb3JkcyIsIm1pbkRpc3QiLCJ0byIsImZyb20iLCJzZWdtZW50SWR4IiwibGluZUNvb3JkaW5hdGVzIiwicG9pbnRDb29yZGluYXRlIiwibGluZUNvb3JkaW5hdGUiLCJuIiwic2xvcGUiLCJpbnZlcnNlU2xvcGUiLCJybDIiLCJwb3ciLCJsbjIiLCJsbm0xMiIsImRpc3QyIiwiY2FsY3JsMiIsIm1pbiIsInVuZGVmaW5lZCIsInNuYXBQb2ludCIsImlkeCIsInBpeGVsVG9MYXRMb25nIiwiZ2V0UGlja2VkRWRpdEhhbmRsZSIsInBpY2tzIiwiaGFuZGxlcyIsImdldFBpY2tlZEVkaXRIYW5kbGVzIiwiZ2V0UGlja2VkU25hcFNvdXJjZUVkaXRIYW5kbGUiLCJmaW5kIiwiaGFuZGxlIiwiZWRpdEhhbmRsZVR5cGUiLCJnZXROb25HdWlkZVBpY2tzIiwiZmlsdGVyIiwicGljayIsImlzR3VpZGUiLCJnZXRQaWNrZWRFeGlzdGluZ0VkaXRIYW5kbGUiLCJmZWF0dXJlSW5kZXgiLCJnZXRQaWNrZWRJbnRlcm1lZGlhdGVFZGl0SGFuZGxlIiwib2JqZWN0IiwiZ3VpZGVUeXBlIiwiZ2V0RWRpdEhhbmRsZXNGb3JHZW9tZXRyeSIsInBvc2l0aW9uSW5kZXhlcyIsImNvbmNhdCIsImdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMiLCJzbGljZSIsIkVycm9yIiwicG9zaXRpb25JbmRleFByZWZpeCIsImVkaXRIYW5kbGVzIiwicG9zaXRpb24iLCJwdXNoIiwidXBkYXRlUmVjdGFuZ2xlUG9zaXRpb24iLCJmZWF0dXJlIiwiZWRpdEhhbmRsZUluZGV4IiwicG9pbnRzIiwicDAiLCJjYWxsYmFjayIsImlzTmFOIiwiaXNGaW5pdGUiLCJjb29yZCIsIkJvb2xlYW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZU8sU0FBU0EsV0FBVCxDQUNMQyxLQURLLEVBRzZCO0FBQUEsTUFEbENDLFlBQ2tDLHVFQURlLENBQUMsR0FBRCxFQUFNLENBQU4sRUFBUyxDQUFULEVBQVksR0FBWixDQUNmOztBQUNsQyxNQUFJLENBQUNDLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxLQUFkLENBQUwsRUFBMkI7QUFDekIsV0FBT0MsWUFBUDtBQUNEOztBQUNELFNBQU8sQ0FBQ0QsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLEdBQVosRUFBaUJBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVyxHQUE1QixFQUFpQ0EsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLEdBQTVDLEVBQWlEQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVcsR0FBNUQsQ0FBUDtBQUNELEMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0ksK0JBQVQsQ0FDTEMsS0FESyxFQUVMQyxNQUZLLEVBR0xDLEVBSEssRUFJTDtBQUNBLE1BQUksQ0FBQ0wsS0FBSyxDQUFDQyxPQUFOLENBQWNFLEtBQUssQ0FBQyxDQUFELENBQW5CLENBQUwsRUFBOEI7QUFDNUIsV0FBTyxJQUFQO0FBQ0Q7O0FBQ0QsT0FBSyxJQUFJRyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSCxLQUFLLENBQUNJLE1BQTFCLEVBQWtDRCxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFFBQUlKLCtCQUErQixDQUFDQyxLQUFLLENBQUNHLENBQUQsQ0FBTiwrQkFBZUYsTUFBZixJQUF1QkUsQ0FBdkIsSUFBMkJELEVBQTNCLENBQW5DLEVBQW1FO0FBQ2pFQSxNQUFBQSxFQUFFLENBQUNGLEtBQUQsRUFBUUMsTUFBUixDQUFGO0FBQ0E7QUFDRDtBQUNGOztBQUNELFNBQU8sS0FBUDtBQUNEOztBQUVNLFNBQVNJLGtDQUFULENBQ0xDLEVBREssRUFFTEMsRUFGSyxFQUdMQyxTQUhLLEVBSU87QUFDWixNQUFNQyxVQUFzQixHQUFHO0FBQzdCQyxJQUFBQSxJQUFJLEVBQUUsWUFEdUI7QUFFN0JDLElBQUFBLFdBQVcsRUFBRSxDQUFDTCxFQUFELEVBQUtDLEVBQUw7QUFGZ0IsR0FBL0I7QUFJQSxNQUFNSyxFQUFFLEdBQUcsb0JBQU1KLFNBQU4sQ0FBWDtBQUNBLE1BQU1LLFNBQVMsR0FBRyxxQ0FBb0JELEVBQXBCLEVBQXdCSCxVQUF4QixDQUFsQjtBQUNBLE1BQU1LLFdBQVcsR0FBRyx5QkFBUVIsRUFBUixFQUFZQyxFQUFaLENBQXBCLENBUFksQ0FTWjtBQUNBO0FBQ0E7O0FBQ0EsTUFBTVEsbUJBQW1CLEdBQ3ZCLENBQUNQLFNBQVMsQ0FBQyxDQUFELENBQVQsR0FBZUYsRUFBRSxDQUFDLENBQUQsQ0FBbEIsS0FBMEJDLEVBQUUsQ0FBQyxDQUFELENBQUYsR0FBUUQsRUFBRSxDQUFDLENBQUQsQ0FBcEMsSUFBMkMsQ0FBQ0UsU0FBUyxDQUFDLENBQUQsQ0FBVCxHQUFlRixFQUFFLENBQUMsQ0FBRCxDQUFsQixLQUEwQkMsRUFBRSxDQUFDLENBQUQsQ0FBRixHQUFRRCxFQUFFLENBQUMsQ0FBRCxDQUFwQyxDQUQ3QyxDQVpZLENBZVo7O0FBQ0EsTUFBTVUsaUJBQWlCLEdBQUdELG1CQUFtQixHQUFHLENBQXRCLEdBQTBCRCxXQUFXLEdBQUcsRUFBeEMsR0FBNkNBLFdBQVcsR0FBRyxHQUFyRixDQWhCWSxDQWtCWjtBQUNBOztBQUNBLE1BQU1HLEVBQUUsR0FBRyw2QkFBWVYsRUFBWixFQUFnQk0sU0FBaEIsRUFBMkJHLGlCQUEzQixDQUFYO0FBQ0EsTUFBTUUsRUFBRSxHQUFHLDZCQUFZWixFQUFaLEVBQWdCTyxTQUFoQixFQUEyQkcsaUJBQTNCLENBQVg7QUFFQSxTQUFPLENBQUNDLEVBQUUsQ0FBQ0UsUUFBSCxDQUFZUixXQUFiLEVBQTBCTyxFQUFFLENBQUNDLFFBQUgsQ0FBWVIsV0FBdEMsQ0FBUDtBQUNEOztBQUVNLFNBQVNTLFVBQVQsQ0FBb0JDLEVBQXBCLEVBQWdDQyxFQUFoQyxFQUE0Q0MsRUFBNUMsRUFBd0RDLEVBQXhELEVBQTRFO0FBQ2pGLE1BQU1DLEVBQUUsR0FBR0osRUFBRSxHQUFHRSxFQUFoQjtBQUNBLE1BQU1HLEVBQUUsR0FBR0osRUFBRSxHQUFHRSxFQUFoQjtBQUNBLFNBQU9HLElBQUksQ0FBQ0MsSUFBTCxDQUFVSCxFQUFFLEdBQUdBLEVBQUwsR0FBVUMsRUFBRSxHQUFHQSxFQUF6QixDQUFQO0FBQ0Q7O0FBRU0sU0FBU0csR0FBVCxDQUFhQyxDQUFiLEVBQXdCQyxDQUF4QixFQUFtQ0MsS0FBbkMsRUFBMEQ7QUFDL0QsU0FBT0QsQ0FBQyxHQUFHQyxLQUFKLEdBQVlGLENBQUMsSUFBSSxJQUFJRSxLQUFSLENBQXBCO0FBQ0Q7O0FBRU0sU0FBU0MsMkJBQVQsQ0FDTEMsSUFESyxFQUVMQyxPQUZLLEVBR0xDLFFBSEssRUFJYTtBQUNsQixNQUFNQyxVQUFVLEdBQUcsSUFBSUMsbUNBQUosQ0FBd0JGLFFBQXhCLENBQW5CLENBRGtCLENBRWxCOztBQUNBLE1BQU16QixXQUFpQyxHQUFHdUIsSUFBSSxDQUFDZixRQUFMLENBQWNSLFdBQXhEO0FBQ0EsTUFBTTRCLGVBQWUsR0FBRzVCLFdBQVcsQ0FBQzZCLEdBQVosQ0FBZ0I7QUFBQTtBQUFBLFFBQUVDLENBQUY7QUFBQSxRQUFLQyxDQUFMO0FBQUE7QUFBQSxRQUFRQyxDQUFSLHVCQUFZLENBQVo7O0FBQUEsV0FBbUJOLFVBQVUsQ0FBQ08sT0FBWCxDQUFtQixDQUFDSCxDQUFELEVBQUlDLENBQUosRUFBT0MsQ0FBUCxDQUFuQixDQUFuQjtBQUFBLEdBQWhCLENBQXhCLENBSmtCLENBS2xCOztBQUxrQiw0QkFNSE4sVUFBVSxDQUFDTyxPQUFYLENBQW1CVCxPQUFPLENBQUNoQixRQUFSLENBQWlCUixXQUFwQyxDQU5HO0FBQUE7QUFBQSxNQU1YOEIsQ0FOVztBQUFBLE1BTVJDLENBTlEsNEJBT2xCOzs7QUFFQSxNQUFJRyxXQUFXLEdBQUdDLFFBQWxCO0FBQ0EsTUFBSUMsWUFBWSxHQUFHLEVBQW5CO0FBRUFSLEVBQUFBLGVBQWUsQ0FBQ1MsT0FBaEIsQ0FBd0IsaUJBQVdDLEtBQVgsRUFBcUI7QUFBQTtBQUFBLFFBQW5CMUIsRUFBbUI7QUFBQSxRQUFmQyxFQUFlOztBQUMzQyxRQUFJeUIsS0FBSyxLQUFLLENBQWQsRUFBaUI7QUFDZjtBQUNEOztBQUgwQywwQ0FLMUJWLGVBQWUsQ0FBQ1UsS0FBSyxHQUFHLENBQVQsQ0FMVztBQUFBLFFBS3BDNUIsRUFMb0M7QUFBQSxRQUtoQ0MsRUFMZ0Msd0JBTzNDO0FBQ0E7OztBQUNBLFFBQU00QixDQUFDLEdBQUc1QixFQUFFLEdBQUdFLEVBQWY7QUFDQSxRQUFNMkIsQ0FBQyxHQUFHNUIsRUFBRSxHQUFHRixFQUFmO0FBQ0EsUUFBTStCLENBQUMsR0FBRy9CLEVBQUUsR0FBR0csRUFBTCxHQUFVRCxFQUFFLEdBQUdELEVBQXpCLENBWDJDLENBYTNDOztBQUNBLFFBQU0rQixHQUFHLEdBQUdILENBQUMsR0FBR0EsQ0FBSixHQUFRQyxDQUFDLEdBQUdBLENBQXhCO0FBQ0EsUUFBTUcsUUFBUSxHQUFHM0IsSUFBSSxDQUFDNEIsR0FBTCxDQUFTTCxDQUFDLEdBQUdULENBQUosR0FBUVUsQ0FBQyxHQUFHVCxDQUFaLEdBQWdCVSxDQUF6QixJQUE4QnpCLElBQUksQ0FBQ0MsSUFBTCxDQUFVeUIsR0FBVixDQUEvQyxDQWYyQyxDQWlCM0M7O0FBRUEsUUFBSUMsUUFBUSxHQUFHVCxXQUFmLEVBQTRCO0FBQzFCQSxNQUFBQSxXQUFXLEdBQUdTLFFBQWQ7QUFDQVAsTUFBQUEsWUFBWSxHQUFHO0FBQ2JFLFFBQUFBLEtBQUssRUFBTEEsS0FEYTtBQUViTyxRQUFBQSxFQUFFLEVBQUUsQ0FBQ0wsQ0FBQyxJQUFJQSxDQUFDLEdBQUdWLENBQUosR0FBUVMsQ0FBQyxHQUFHUixDQUFoQixDQUFELEdBQXNCUSxDQUFDLEdBQUdFLENBQTNCLElBQWdDQyxHQUZ2QjtBQUdiSSxRQUFBQSxFQUFFLEVBQUUsQ0FBQ1AsQ0FBQyxJQUFJLENBQUNDLENBQUQsR0FBS1YsQ0FBTCxHQUFTUyxDQUFDLEdBQUdSLENBQWpCLENBQUQsR0FBdUJTLENBQUMsR0FBR0MsQ0FBNUIsSUFBaUNDO0FBSHhCLE9BQWY7QUFLRDtBQUNGLEdBM0JELEVBWmtCLENBd0NsQjs7QUF4Q2tCLHNCQXlDUU4sWUF6Q1I7QUFBQSxNQXlDVkUsS0F6Q1UsaUJBeUNWQSxLQXpDVTtBQUFBLE1BeUNITyxFQXpDRyxpQkF5Q0hBLEVBekNHO0FBQUEsTUF5Q0NDLEVBekNELGlCQXlDQ0EsRUF6Q0Q7O0FBQUEseUNBMENPbEIsZUFBZSxDQUFDVSxLQUFLLEdBQUcsQ0FBVCxDQTFDdEI7QUFBQSxNQTBDWDVCLEVBMUNXO0FBQUEsTUEwQ1BDLEVBMUNPO0FBQUE7QUFBQSxNQTBDSG9DLEVBMUNHLG1DQTBDRSxDQTFDRjs7QUFBQSw2Q0EyQ09uQixlQUFlLENBQUNVLEtBQUQsQ0EzQ3RCO0FBQUEsTUEyQ1gxQixFQTNDVztBQUFBLE1BMkNQQyxFQTNDTztBQUFBO0FBQUEsTUEyQ0htQyxFQTNDRyx1Q0EyQ0UsQ0EzQ0YsMkJBNkNsQjs7O0FBQ0EsTUFBTUMsVUFBVSxHQUFHeEMsVUFBVSxDQUFDQyxFQUFELEVBQUtDLEVBQUwsRUFBU0MsRUFBVCxFQUFhQyxFQUFiLENBQTdCO0FBQ0EsTUFBTXFDLGtCQUFrQixHQUFHekMsVUFBVSxDQUFDQyxFQUFELEVBQUtDLEVBQUwsRUFBU2tDLEVBQVQsRUFBYUMsRUFBYixDQUFyQztBQUNBLE1BQU16QixLQUFLLEdBQUc2QixrQkFBa0IsR0FBR0QsVUFBbkM7QUFDQSxNQUFNRSxFQUFFLEdBQUdqQyxHQUFHLENBQUM2QixFQUFELEVBQUtDLEVBQUwsRUFBUzNCLEtBQVQsQ0FBZDtBQUVBLFNBQU87QUFDTHRCLElBQUFBLElBQUksRUFBRSxTQUREO0FBRUxTLElBQUFBLFFBQVEsRUFBRTtBQUNSVCxNQUFBQSxJQUFJLEVBQUUsT0FERTtBQUVSQyxNQUFBQSxXQUFXLEVBQUUwQixVQUFVLENBQUMwQixTQUFYLENBQXFCLENBQUNQLEVBQUQsRUFBS0MsRUFBTCxFQUFTSyxFQUFULENBQXJCO0FBRkwsS0FGTDtBQU1MRSxJQUFBQSxVQUFVLEVBQUU7QUFDVjtBQUNBQyxNQUFBQSxJQUFJLEVBQUVwQixXQUZJO0FBR1ZJLE1BQUFBLEtBQUssRUFBRUEsS0FBSyxHQUFHO0FBSEw7QUFOUCxHQUFQO0FBWUQ7O0FBRU0sU0FBU2lCLGtCQUFULENBQ0xDLEtBREssRUFFTGhDLE9BRkssRUFHTEMsUUFISyxFQUlhO0FBQUE7O0FBQ2xCLE1BQUlnQyxRQUFKOztBQUVBLE1BQUloQyxRQUFKLEVBQWM7QUFDWmdDLElBQUFBLFFBQVEsR0FBRyxJQUFJOUIsbUNBQUosQ0FBd0JGLFFBQXhCLENBQVg7QUFDRDs7QUFDRCxNQUFJaUMsWUFBaUIsR0FBRyxvQkFBTSxDQUFDdkIsUUFBRCxFQUFXQSxRQUFYLENBQU4sRUFBNEI7QUFDbERtQixJQUFBQSxJQUFJLEVBQUVuQjtBQUQ0QyxHQUE1QixDQUF4Qjs7QUFJQSxNQUFJLHFCQUFDcUIsS0FBSyxDQUFDaEQsUUFBUCxvREFBQyxnQkFBZ0JSLFdBQWhCLENBQTRCUCxNQUE3QixLQUF1QyxxQkFBQStELEtBQUssQ0FBQ2hELFFBQU4sc0VBQWdCUixXQUFoQixDQUE0QlAsTUFBNUIsSUFBcUMsQ0FBaEYsRUFBbUY7QUFDakYsV0FBT2lFLFlBQVA7QUFDRCxHQVppQixDQWNsQjs7O0FBQ0EseUJBQVlGLEtBQVosRUFBbUIsVUFBQ2pDLElBQUQsRUFBZTtBQUNoQyxRQUFNb0MsTUFBVyxHQUFHLDBCQUFVcEMsSUFBVixDQUFwQixDQURnQyxDQUVoQzs7QUFDQSxRQUFNcUMsV0FBZ0IsR0FBRywwQkFBVXBDLE9BQVYsQ0FBekI7QUFFQSxRQUFJcUMsT0FBSjtBQUNBLFFBQUlDLEVBQUo7QUFDQSxRQUFJQyxJQUFKO0FBQ0EsUUFBSWpDLENBQUo7QUFDQSxRQUFJQyxDQUFKO0FBQ0EsUUFBSWlDLFVBQUo7QUFDQSxRQUFJVixJQUFKOztBQUVBLFFBQUlLLE1BQU0sQ0FBQ2xFLE1BQVAsR0FBZ0IsQ0FBaEIsSUFBcUJtRSxXQUFXLENBQUNuRSxNQUFyQyxFQUE2QztBQUMzQyxVQUFJd0UsZUFBSjtBQUNBLFVBQUlDLGVBQUosQ0FGMkMsQ0FJM0M7O0FBQ0EsVUFBSVQsUUFBSixFQUFjO0FBQ1pRLFFBQUFBLGVBQWUsR0FBR04sTUFBTSxDQUFDOUIsR0FBUCxDQUFXLFVBQUNzQyxjQUFEO0FBQUEsaUJBQW9CVixRQUFRLENBQUN4QixPQUFULENBQWlCa0MsY0FBakIsQ0FBcEI7QUFBQSxTQUFYLENBQWxCO0FBQ0FELFFBQUFBLGVBQWUsR0FBR1QsUUFBUSxDQUFDeEIsT0FBVCxDQUFpQjJCLFdBQWpCLENBQWxCO0FBQ0QsT0FIRCxNQUdPO0FBQ0xLLFFBQUFBLGVBQWUsR0FBR04sTUFBbEI7QUFDQU8sUUFBQUEsZUFBZSxHQUFHTixXQUFsQjtBQUNEOztBQUVELFdBQUssSUFBSVEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0gsZUFBZSxDQUFDeEUsTUFBcEMsRUFBNEMyRSxDQUFDLEVBQTdDLEVBQWlEO0FBQy9DLFlBQUlILGVBQWUsQ0FBQ0csQ0FBRCxDQUFmLENBQW1CLENBQW5CLE1BQTBCSCxlQUFlLENBQUNHLENBQUMsR0FBRyxDQUFMLENBQWYsQ0FBdUIsQ0FBdkIsQ0FBOUIsRUFBeUQ7QUFDdkQsY0FBTUMsS0FBSyxHQUNULENBQUNKLGVBQWUsQ0FBQ0csQ0FBRCxDQUFmLENBQW1CLENBQW5CLElBQXdCSCxlQUFlLENBQUNHLENBQUMsR0FBRyxDQUFMLENBQWYsQ0FBdUIsQ0FBdkIsQ0FBekIsS0FDQ0gsZUFBZSxDQUFDRyxDQUFELENBQWYsQ0FBbUIsQ0FBbkIsSUFBd0JILGVBQWUsQ0FBQ0csQ0FBQyxHQUFHLENBQUwsQ0FBZixDQUF1QixDQUF2QixDQUR6QixDQURGO0FBR0EsY0FBTUUsWUFBWSxHQUFHTCxlQUFlLENBQUNHLENBQUQsQ0FBZixDQUFtQixDQUFuQixJQUF3QkMsS0FBSyxHQUFHSixlQUFlLENBQUNHLENBQUQsQ0FBZixDQUFtQixDQUFuQixDQUFyRDtBQUVBZCxVQUFBQSxJQUFJLEdBQ0Z0QyxJQUFJLENBQUM0QixHQUFMLENBQVN5QixLQUFLLEdBQUdILGVBQWUsQ0FBQyxDQUFELENBQXZCLEdBQTZCSSxZQUE3QixHQUE0Q0osZUFBZSxDQUFDLENBQUQsQ0FBcEUsSUFDQWxELElBQUksQ0FBQ0MsSUFBTCxDQUFVb0QsS0FBSyxHQUFHQSxLQUFSLEdBQWdCLENBQTFCLENBRkY7QUFHRCxTQVRELE1BU09mLElBQUksR0FBR3RDLElBQUksQ0FBQzRCLEdBQUwsQ0FBU3NCLGVBQWUsQ0FBQyxDQUFELENBQWYsR0FBcUJELGVBQWUsQ0FBQ0csQ0FBRCxDQUFmLENBQW1CLENBQW5CLENBQTlCLENBQVAsQ0FWd0MsQ0FZL0M7OztBQUNBLFlBQU1HLEdBQUcsR0FDUHZELElBQUksQ0FBQ3dELEdBQUwsQ0FBU1AsZUFBZSxDQUFDRyxDQUFELENBQWYsQ0FBbUIsQ0FBbkIsSUFBd0JILGVBQWUsQ0FBQ0csQ0FBQyxHQUFHLENBQUwsQ0FBZixDQUF1QixDQUF2QixDQUFqQyxFQUE0RCxDQUE1RCxJQUNBcEQsSUFBSSxDQUFDd0QsR0FBTCxDQUFTUCxlQUFlLENBQUNHLENBQUQsQ0FBZixDQUFtQixDQUFuQixJQUF3QkgsZUFBZSxDQUFDRyxDQUFDLEdBQUcsQ0FBTCxDQUFmLENBQXVCLENBQXZCLENBQWpDLEVBQTRELENBQTVELENBRkYsQ0FiK0MsQ0FpQi9DOztBQUNBLFlBQU1LLEdBQUcsR0FDUHpELElBQUksQ0FBQ3dELEdBQUwsQ0FBU1AsZUFBZSxDQUFDRyxDQUFELENBQWYsQ0FBbUIsQ0FBbkIsSUFBd0JGLGVBQWUsQ0FBQyxDQUFELENBQWhELEVBQXFELENBQXJELElBQ0FsRCxJQUFJLENBQUN3RCxHQUFMLENBQVNQLGVBQWUsQ0FBQ0csQ0FBRCxDQUFmLENBQW1CLENBQW5CLElBQXdCRixlQUFlLENBQUMsQ0FBRCxDQUFoRCxFQUFxRCxDQUFyRCxDQUZGLENBbEIrQyxDQXNCL0M7O0FBQ0EsWUFBTVEsS0FBSyxHQUNUMUQsSUFBSSxDQUFDd0QsR0FBTCxDQUFTUCxlQUFlLENBQUNHLENBQUMsR0FBRyxDQUFMLENBQWYsQ0FBdUIsQ0FBdkIsSUFBNEJGLGVBQWUsQ0FBQyxDQUFELENBQXBELEVBQXlELENBQXpELElBQ0FsRCxJQUFJLENBQUN3RCxHQUFMLENBQVNQLGVBQWUsQ0FBQ0csQ0FBQyxHQUFHLENBQUwsQ0FBZixDQUF1QixDQUF2QixJQUE0QkYsZUFBZSxDQUFDLENBQUQsQ0FBcEQsRUFBeUQsQ0FBekQsQ0FGRixDQXZCK0MsQ0EyQi9DOztBQUNBLFlBQU1TLEtBQUssR0FBRzNELElBQUksQ0FBQ3dELEdBQUwsQ0FBU2xCLElBQVQsRUFBZSxDQUFmLENBQWQsQ0E1QitDLENBOEIvQzs7QUFDQSxZQUFNc0IsT0FBTyxHQUFHSCxHQUFHLEdBQUdFLEtBQU4sR0FBY0QsS0FBZCxHQUFzQkMsS0FBdEMsQ0EvQitDLENBaUMvQzs7QUFDQSxZQUFJQyxPQUFPLEdBQUdMLEdBQWQsRUFBbUI7QUFDakJqQixVQUFBQSxJQUFJLEdBQUd0QyxJQUFJLENBQUNDLElBQUwsQ0FBVUQsSUFBSSxDQUFDNkQsR0FBTCxDQUFTSixHQUFULEVBQWNDLEtBQWQsQ0FBVixDQUFQO0FBQ0Q7O0FBRUQsWUFBSWIsT0FBTyxLQUFLLElBQVosSUFBb0JBLE9BQU8sS0FBS2lCLFNBQWhDLElBQTZDakIsT0FBTyxHQUFHUCxJQUEzRCxFQUFpRTtBQUMvRDtBQUNBLGNBQUlzQixPQUFPLEdBQUdMLEdBQWQsRUFBbUI7QUFDakI7QUFDQSxnQkFBSUcsS0FBSyxHQUFHRCxHQUFaLEVBQWlCO0FBQ2ZYLGNBQUFBLEVBQUUsR0FBRyxDQUFMLENBRGUsQ0FDUDs7QUFDUkMsY0FBQUEsSUFBSSxHQUFHLENBQVA7QUFDRCxhQUhELE1BR087QUFDTEEsY0FBQUEsSUFBSSxHQUFHLENBQVAsQ0FESyxDQUNLOztBQUNWRCxjQUFBQSxFQUFFLEdBQUcsQ0FBTDtBQUNEO0FBQ0YsV0FURCxNQVNPO0FBQ0w7QUFDQUEsWUFBQUEsRUFBRSxHQUFHOUMsSUFBSSxDQUFDQyxJQUFMLENBQVV5RCxLQUFLLEdBQUdDLEtBQWxCLElBQTJCM0QsSUFBSSxDQUFDQyxJQUFMLENBQVVzRCxHQUFWLENBQWhDO0FBQ0FSLFlBQUFBLElBQUksR0FBRy9DLElBQUksQ0FBQ0MsSUFBTCxDQUFVd0QsR0FBRyxHQUFHRSxLQUFoQixJQUF5QjNELElBQUksQ0FBQ0MsSUFBTCxDQUFVc0QsR0FBVixDQUFoQztBQUNEOztBQUNEVixVQUFBQSxPQUFPLEdBQUdQLElBQVY7QUFDQVUsVUFBQUEsVUFBVSxHQUFHSSxDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxVQUFNdEQsRUFBRSxHQUFHbUQsZUFBZSxDQUFDRCxVQUFVLEdBQUcsQ0FBZCxDQUFmLENBQWdDLENBQWhDLElBQXFDQyxlQUFlLENBQUNELFVBQUQsQ0FBZixDQUE0QixDQUE1QixDQUFoRDtBQUNBLFVBQU1qRCxFQUFFLEdBQUdrRCxlQUFlLENBQUNELFVBQVUsR0FBRyxDQUFkLENBQWYsQ0FBZ0MsQ0FBaEMsSUFBcUNDLGVBQWUsQ0FBQ0QsVUFBRCxDQUFmLENBQTRCLENBQTVCLENBQWhEO0FBRUFsQyxNQUFBQSxDQUFDLEdBQUdtQyxlQUFlLENBQUNELFVBQVUsR0FBRyxDQUFkLENBQWYsQ0FBZ0MsQ0FBaEMsSUFBcUNsRCxFQUFFLEdBQUdnRCxFQUE5QztBQUNBL0IsTUFBQUEsQ0FBQyxHQUFHa0MsZUFBZSxDQUFDRCxVQUFVLEdBQUcsQ0FBZCxDQUFmLENBQWdDLENBQWhDLElBQXFDakQsRUFBRSxHQUFHK0MsRUFBOUM7QUFDRCxLQTFGK0IsQ0E0RmhDOzs7QUFDQSxRQUFJaUIsU0FBUyxHQUFHO0FBQUVqRCxNQUFBQSxDQUFDLEVBQURBLENBQUY7QUFBS0MsTUFBQUEsQ0FBQyxFQUFEQSxDQUFMO0FBQVFpRCxNQUFBQSxHQUFHLEVBQUVoQixVQUFVLEdBQUcsQ0FBMUI7QUFBNkJGLE1BQUFBLEVBQUUsRUFBRkEsRUFBN0I7QUFBaUNDLE1BQUFBLElBQUksRUFBSkE7QUFBakMsS0FBaEI7O0FBRUEsUUFBSU4sUUFBSixFQUFjO0FBQ1osVUFBTXdCLGNBQWMsR0FBR3hCLFFBQVEsQ0FBQ0wsU0FBVCxDQUFtQixDQUFDMkIsU0FBUyxDQUFDakQsQ0FBWCxFQUFjaUQsU0FBUyxDQUFDaEQsQ0FBeEIsQ0FBbkIsQ0FBdkI7QUFDQWdELE1BQUFBLFNBQVMsR0FBRztBQUNWakQsUUFBQUEsQ0FBQyxFQUFFbUQsY0FBYyxDQUFDLENBQUQsQ0FEUDtBQUVWbEQsUUFBQUEsQ0FBQyxFQUFFa0QsY0FBYyxDQUFDLENBQUQsQ0FGUDtBQUdWRCxRQUFBQSxHQUFHLEVBQUVoQixVQUFVLEdBQUcsQ0FIUjtBQUlWRixRQUFBQSxFQUFFLEVBQUZBLEVBSlU7QUFLVkMsUUFBQUEsSUFBSSxFQUFKQTtBQUxVLE9BQVo7QUFPRDs7QUFFREwsSUFBQUEsWUFBWSxHQUFHLG9CQUFNLENBQUNxQixTQUFTLENBQUNqRCxDQUFYLEVBQWNpRCxTQUFTLENBQUNoRCxDQUF4QixDQUFOLEVBQWtDO0FBQy9DdUIsTUFBQUEsSUFBSSxFQUFFdEMsSUFBSSxDQUFDNEIsR0FBTCxDQUFTbUMsU0FBUyxDQUFDaEIsSUFBVixHQUFpQmdCLFNBQVMsQ0FBQ2pCLEVBQXBDLENBRHlDO0FBRS9DeEIsTUFBQUEsS0FBSyxFQUFFeUMsU0FBUyxDQUFDQztBQUY4QixLQUFsQyxDQUFmO0FBSUQsR0E5R0Q7QUFnSEEsU0FBT3RCLFlBQVA7QUFDRDs7QUFFTSxTQUFTd0IsbUJBQVQsQ0FDTEMsS0FESyxFQUVpQztBQUN0QyxNQUFNQyxPQUFPLEdBQUdDLG9CQUFvQixDQUFDRixLQUFELENBQXBDO0FBQ0EsU0FBT0MsT0FBTyxDQUFDM0YsTUFBUixHQUFpQjJGLE9BQU8sQ0FBQyxDQUFELENBQXhCLEdBQThCLElBQXJDO0FBQ0Q7O0FBRU0sU0FBU0UsNkJBQVQsQ0FDTEgsS0FESyxFQUVpQztBQUN0QyxNQUFNQyxPQUFPLEdBQUdDLG9CQUFvQixDQUFDRixLQUFELENBQXBDO0FBQ0EsU0FBT0MsT0FBTyxDQUFDRyxJQUFSLENBQWEsVUFBQ0MsTUFBRDtBQUFBLFdBQVlBLE1BQU0sQ0FBQ25DLFVBQVAsQ0FBa0JvQyxjQUFsQixLQUFxQyxhQUFqRDtBQUFBLEdBQWIsQ0FBUDtBQUNEOztBQUVNLFNBQVNDLGdCQUFULENBQTBCUCxLQUExQixFQUFpRDtBQUN0RCxTQUFPQSxLQUFLLElBQUlBLEtBQUssQ0FBQ1EsTUFBTixDQUFhLFVBQUNDLElBQUQ7QUFBQSxXQUFVLENBQUNBLElBQUksQ0FBQ0MsT0FBaEI7QUFBQSxHQUFiLENBQWhCO0FBQ0Q7O0FBRU0sU0FBU0MsMkJBQVQsQ0FDTFgsS0FESyxFQUVpQztBQUN0QyxNQUFNQyxPQUFPLEdBQUdDLG9CQUFvQixDQUFDRixLQUFELENBQXBDO0FBQ0EsU0FBT0MsT0FBTyxDQUFDRyxJQUFSLENBQ0w7QUFBQSxRQUFHbEMsVUFBSCxTQUFHQSxVQUFIO0FBQUEsV0FBb0JBLFVBQVUsQ0FBQzBDLFlBQVgsSUFBMkIsQ0FBM0IsSUFBZ0MxQyxVQUFVLENBQUNvQyxjQUFYLEtBQThCLFVBQWxGO0FBQUEsR0FESyxDQUFQO0FBR0Q7O0FBRU0sU0FBU08sK0JBQVQsQ0FDTGIsS0FESyxFQUVpQztBQUN0QyxNQUFNQyxPQUFPLEdBQUdDLG9CQUFvQixDQUFDRixLQUFELENBQXBDO0FBQ0EsU0FBT0MsT0FBTyxDQUFDRyxJQUFSLENBQ0w7QUFBQSxRQUFHbEMsVUFBSCxTQUFHQSxVQUFIO0FBQUEsV0FBb0JBLFVBQVUsQ0FBQzBDLFlBQVgsSUFBMkIsQ0FBM0IsSUFBZ0MxQyxVQUFVLENBQUNvQyxjQUFYLEtBQThCLGNBQWxGO0FBQUEsR0FESyxDQUFQO0FBR0Q7O0FBRU0sU0FBU0osb0JBQVQsQ0FBOEJGLEtBQTlCLEVBQXFGO0FBQzFGLE1BQU1DLE9BQU8sR0FDVkQsS0FBSyxJQUNKQSxLQUFLLENBQ0ZRLE1BREgsQ0FDVSxVQUFDQyxJQUFEO0FBQUEsV0FBVUEsSUFBSSxDQUFDQyxPQUFMLElBQWdCRCxJQUFJLENBQUNLLE1BQUwsQ0FBWTVDLFVBQVosQ0FBdUI2QyxTQUF2QixLQUFxQyxZQUEvRDtBQUFBLEdBRFYsRUFFR3JFLEdBRkgsQ0FFTyxVQUFDK0QsSUFBRDtBQUFBLFdBQVVBLElBQUksQ0FBQ0ssTUFBZjtBQUFBLEdBRlAsQ0FERixJQUlBLEVBTEY7QUFPQSxTQUFPYixPQUFQO0FBQ0Q7O0FBRU0sU0FBU2UseUJBQVQsQ0FDTDNGLFFBREssRUFFTHVGLFlBRkssRUFJZ0I7QUFBQSxNQURyQk4sY0FDcUIsdUVBRFksVUFDWjtBQUNyQixNQUFJTCxPQUE0QixHQUFHLEVBQW5DOztBQUVBLFVBQVE1RSxRQUFRLENBQUNULElBQWpCO0FBQ0UsU0FBSyxPQUFMO0FBQ0U7QUFDQXFGLE1BQUFBLE9BQU8sR0FBRyxDQUNSO0FBQ0VyRixRQUFBQSxJQUFJLEVBQUUsU0FEUjtBQUVFc0QsUUFBQUEsVUFBVSxFQUFFO0FBQ1Y2QyxVQUFBQSxTQUFTLEVBQUUsWUFERDtBQUVWVCxVQUFBQSxjQUFjLEVBQWRBLGNBRlU7QUFHVlcsVUFBQUEsZUFBZSxFQUFFLEVBSFA7QUFJVkwsVUFBQUEsWUFBWSxFQUFaQTtBQUpVLFNBRmQ7QUFRRXZGLFFBQUFBLFFBQVEsRUFBRTtBQUNSVCxVQUFBQSxJQUFJLEVBQUUsT0FERTtBQUVSQyxVQUFBQSxXQUFXLEVBQUVRLFFBQVEsQ0FBQ1I7QUFGZDtBQVJaLE9BRFEsQ0FBVjtBQWVBOztBQUNGLFNBQUssWUFBTDtBQUNBLFNBQUssWUFBTDtBQUNFO0FBQ0FvRixNQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ2lCLE1BQVIsQ0FDUkMsNEJBQTRCLENBQUM5RixRQUFRLENBQUNSLFdBQVYsRUFBdUIsRUFBdkIsRUFBMkIrRixZQUEzQixFQUF5Q04sY0FBekMsQ0FEcEIsQ0FBVjtBQUdBOztBQUNGLFNBQUssU0FBTDtBQUNBLFNBQUssaUJBQUw7QUFDRTtBQUNBLFdBQUssSUFBSXRFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdYLFFBQVEsQ0FBQ1IsV0FBVCxDQUFxQlAsTUFBekMsRUFBaUQwQixDQUFDLEVBQWxELEVBQXNEO0FBQ3BEaUUsUUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNpQixNQUFSLENBQ1JDLDRCQUE0QixDQUFDOUYsUUFBUSxDQUFDUixXQUFULENBQXFCbUIsQ0FBckIsQ0FBRCxFQUEwQixDQUFDQSxDQUFELENBQTFCLEVBQStCNEUsWUFBL0IsRUFBNkNOLGNBQTdDLENBRHBCLENBQVY7O0FBR0EsWUFBSWpGLFFBQVEsQ0FBQ1QsSUFBVCxLQUFrQixTQUF0QixFQUFpQztBQUMvQjtBQUNBcUYsVUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNtQixLQUFSLENBQWMsQ0FBZCxFQUFpQixDQUFDLENBQWxCLENBQVY7QUFDRDtBQUNGOztBQUVEOztBQUNGLFNBQUssY0FBTDtBQUNFO0FBQ0EsV0FBSyxJQUFJcEYsRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBR1gsUUFBUSxDQUFDUixXQUFULENBQXFCUCxNQUF6QyxFQUFpRDBCLEVBQUMsRUFBbEQsRUFBc0Q7QUFDcEQsYUFBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHWixRQUFRLENBQUNSLFdBQVQsQ0FBcUJtQixFQUFyQixFQUF3QjFCLE1BQTVDLEVBQW9EMkIsQ0FBQyxFQUFyRCxFQUF5RDtBQUN2RGdFLFVBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDaUIsTUFBUixDQUNSQyw0QkFBNEIsQ0FDMUI5RixRQUFRLENBQUNSLFdBQVQsQ0FBcUJtQixFQUFyQixFQUF3QkMsQ0FBeEIsQ0FEMEIsRUFFMUIsQ0FBQ0QsRUFBRCxFQUFJQyxDQUFKLENBRjBCLEVBRzFCMkUsWUFIMEIsRUFJMUJOLGNBSjBCLENBRHBCLENBQVYsQ0FEdUQsQ0FTdkQ7O0FBQ0FMLFVBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDbUIsS0FBUixDQUFjLENBQWQsRUFBaUIsQ0FBQyxDQUFsQixDQUFWO0FBQ0Q7QUFDRjs7QUFFRDs7QUFDRjtBQUNFO0FBQ0EsWUFBTUMsS0FBSyxvQ0FBNkJoRyxRQUFRLENBQUNULElBQXRDLEVBQVg7QUE1REo7O0FBK0RBLFNBQU9xRixPQUFQO0FBQ0Q7O0FBRUQsU0FBU2tCLDRCQUFULENBQ0V0RyxXQURGLEVBRUV5RyxtQkFGRixFQUdFVixZQUhGLEVBS3VCO0FBQUEsTUFEckJOLGNBQ3FCLHVFQURZLFVBQ1o7QUFDckIsTUFBTWlCLFdBQVcsR0FBRyxFQUFwQjs7QUFDQSxPQUFLLElBQUlsSCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHUSxXQUFXLENBQUNQLE1BQWhDLEVBQXdDRCxDQUFDLEVBQXpDLEVBQTZDO0FBQzNDLFFBQU1tSCxRQUFRLEdBQUczRyxXQUFXLENBQUNSLENBQUQsQ0FBNUI7QUFDQWtILElBQUFBLFdBQVcsQ0FBQ0UsSUFBWixDQUFpQjtBQUNmN0csTUFBQUEsSUFBSSxFQUFFLFNBRFM7QUFFZnNELE1BQUFBLFVBQVUsRUFBRTtBQUNWNkMsUUFBQUEsU0FBUyxFQUFFLFlBREQ7QUFFVkUsUUFBQUEsZUFBZSwrQkFBTUssbUJBQU4sSUFBMkJqSCxDQUEzQixFQUZMO0FBR1Z1RyxRQUFBQSxZQUFZLEVBQVpBLFlBSFU7QUFJVk4sUUFBQUEsY0FBYyxFQUFkQTtBQUpVLE9BRkc7QUFRZmpGLE1BQUFBLFFBQVEsRUFBRTtBQUNSVCxRQUFBQSxJQUFJLEVBQUUsT0FERTtBQUVSQyxRQUFBQSxXQUFXLEVBQUUyRztBQUZMO0FBUkssS0FBakI7QUFhRDs7QUFDRCxTQUFPRCxXQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7O0FBT08sU0FBU0csdUJBQVQsQ0FDTEMsT0FESyxFQUVMQyxlQUZLLEVBR0xsSCxTQUhLLEVBSVM7QUFDZCxNQUFNRyxXQUFXLEdBQUc4RyxPQUFPLENBQUN0RyxRQUFSLENBQWlCUixXQUFyQzs7QUFDQSxNQUFJLENBQUNBLFdBQUwsRUFBa0I7QUFDaEIsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBTWdILE1BQU0sR0FBR2hILFdBQVcsQ0FBQyxDQUFELENBQVgsQ0FBZXVHLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsQ0FBZjtBQUNBUyxFQUFBQSxNQUFNLENBQUNELGVBQWUsR0FBRyxDQUFuQixDQUFOLEdBQThCbEgsU0FBOUI7QUFFQSxNQUFNb0gsRUFBRSxHQUFHRCxNQUFNLENBQUMsQ0FBQ0QsZUFBZSxHQUFHLENBQW5CLElBQXdCLENBQXpCLENBQWpCO0FBQ0EsTUFBTW5ILEVBQUUsR0FBR29ILE1BQU0sQ0FBQ0QsZUFBZSxHQUFHLENBQW5CLENBQWpCO0FBQ0FDLEVBQUFBLE1BQU0sQ0FBQyxDQUFDRCxlQUFlLEdBQUcsQ0FBbkIsSUFBd0IsQ0FBekIsQ0FBTixHQUFvQyxDQUFDbkgsRUFBRSxDQUFDLENBQUQsQ0FBSCxFQUFRcUgsRUFBRSxDQUFDLENBQUQsQ0FBVixDQUFwQztBQUNBRCxFQUFBQSxNQUFNLENBQUMsQ0FBQ0QsZUFBZSxHQUFHLENBQW5CLElBQXdCLENBQXpCLENBQU4sR0FBb0MsQ0FBQ0UsRUFBRSxDQUFDLENBQUQsQ0FBSCxFQUFRckgsRUFBRSxDQUFDLENBQUQsQ0FBVixDQUFwQztBQUVBLFNBQU8sOEJBQUtvSCxNQUFMLElBQWFBLE1BQU0sQ0FBQyxDQUFELENBQW5CLEdBQVA7QUFDRDtBQUVEOzs7Ozs7OztBQU1PLFNBQVNuSCxTQUFULENBQ0w4RCxNQURLLEVBRUx1RCxRQUZLLEVBR1c7QUFDaEIsTUFBSSxPQUFPdkQsTUFBTSxDQUFDLENBQUQsQ0FBYixLQUFxQixRQUF6QixFQUFtQztBQUNqQyxRQUFJLENBQUN3RCxLQUFLLENBQUN4RCxNQUFNLENBQUMsQ0FBRCxDQUFQLENBQU4sSUFBcUJ5RCxRQUFRLENBQUN6RCxNQUFNLENBQUMsQ0FBRCxDQUFQLENBQWpDLEVBQThDO0FBQzVDLGFBQU91RCxRQUFRLENBQUN2RCxNQUFELENBQWY7QUFDRDs7QUFDRCxXQUFPQSxNQUFQO0FBQ0Q7O0FBRUQsU0FBUUEsTUFBRCxDQUNKOUIsR0FESSxDQUNBLFVBQUN3RixLQUFELEVBQVc7QUFDZCxXQUFPeEgsU0FBUyxDQUFDd0gsS0FBRCxFQUFRSCxRQUFSLENBQWhCO0FBQ0QsR0FISSxFQUlKdkIsTUFKSSxDQUlHMkIsT0FKSCxDQUFQO0FBS0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVzdGluYXRpb24gZnJvbSAnQHR1cmYvZGVzdGluYXRpb24nO1xuaW1wb3J0IGJlYXJpbmcgZnJvbSAnQHR1cmYvYmVhcmluZyc7XG5pbXBvcnQgcG9pbnRUb0xpbmVEaXN0YW5jZSBmcm9tICdAdHVyZi9wb2ludC10by1saW5lLWRpc3RhbmNlJztcbmltcG9ydCB7IGZsYXR0ZW5FYWNoIH0gZnJvbSAnQHR1cmYvbWV0YSc7XG5pbXBvcnQgeyBwb2ludCwgTXVsdGlMaW5lU3RyaW5nIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgeyBnZXRDb29yZHMgfSBmcm9tICdAdHVyZi9pbnZhcmlhbnQnO1xuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgeyBWaWV3cG9ydCwgUGljaywgRWRpdEhhbmRsZUZlYXR1cmUsIEVkaXRIYW5kbGVUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBHZW9tZXRyeSxcbiAgUG9zaXRpb24sXG4gIFBvaW50LFxuICBMaW5lU3RyaW5nLFxuICBQb2x5Z29uLFxuICBGZWF0dXJlT2YsXG4gIEZlYXR1cmVXaXRoUHJvcHMsXG4gIEFueUNvb3JkaW5hdGVzLFxufSBmcm9tICcuL2dlb2pzb24tdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBOZWFyZXN0UG9pbnRUeXBlID0gRmVhdHVyZVdpdGhQcm9wczxQb2ludCwgeyBkaXN0OiBudW1iZXI7IGluZGV4OiBudW1iZXIgfT47XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0RlY2tDb2xvcihcbiAgY29sb3I/OiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IG51bWJlcixcbiAgZGVmYXVsdENvbG9yOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFsyNTUsIDAsIDAsIDI1NV1cbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIHJldHVybiBkZWZhdWx0Q29sb3I7XG4gIH1cbiAgcmV0dXJuIFtjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1LCBjb2xvclszXSAqIDI1NV07XG59XG5cbi8vXG4vLyBhIEdlb0pTT04gaGVscGVyIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpdGhcbi8vIGFuIGFyZ3VtZW50IHRoYXQgaXMgdGhlIG1vc3QgZGVlcGx5LW5lc3RlZCBhcnJheSBoYXZpbmcgZWxlbWVudHNcbi8vIHRoYXQgYXJlIGFycmF5cyBvZiBwcmltaXRpdmVzIGFzIGFuIGFyZ3VtZW50LCBlLmcuXG4vL1xuLy8ge1xuLy8gICBcInR5cGVcIjogXCJNdWx0aVBvbHlnb25cIixcbi8vICAgXCJjb29yZGluYXRlc1wiOiBbXG4vLyAgICAgICBbXG4vLyAgICAgICAgICAgW1szMCwgMjBdLCBbNDUsIDQwXSwgWzEwLCA0MF0sIFszMCwgMjBdXVxuLy8gICAgICAgXSxcbi8vICAgICAgIFtcbi8vICAgICAgICAgICBbWzE1LCA1XSwgWzQwLCAxMF0sIFsxMCwgMjBdLCBbNSwgMTBdLCBbMTUsIDVdXVxuLy8gICAgICAgXVxuLy8gICBdXG4vLyB9XG4vL1xuLy8gdGhlIGZ1bmN0aW9uIHdvdWxkIGJlIGNhbGxlZCBvbjpcbi8vXG4vLyBbWzMwLCAyMF0sIFs0NSwgNDBdLCBbMTAsIDQwXSwgWzMwLCAyMF1dXG4vL1xuLy8gYW5kXG4vL1xuLy8gW1sxNSwgNV0sIFs0MCwgMTBdLCBbMTAsIDIwXSwgWzUsIDEwXSwgWzE1LCA1XV1cbi8vXG5leHBvcnQgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU5lc3RlZEFycmF5cyhcbiAgYXJyYXk6IEFycmF5PGFueT4sXG4gIHByZWZpeDogQXJyYXk8bnVtYmVyPixcbiAgZm46IEZ1bmN0aW9uXG4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5WzBdKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVjdXJzaXZlbHlUcmF2ZXJzZU5lc3RlZEFycmF5cyhhcnJheVtpXSwgWy4uLnByZWZpeCwgaV0sIGZuKSkge1xuICAgICAgZm4oYXJyYXksIHByZWZpeCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQb2ludHNQYXJhbGxlbFRvTGluZVBvaW50cyhcbiAgcDE6IFBvc2l0aW9uLFxuICBwMjogUG9zaXRpb24sXG4gIG1hcENvb3JkczogUG9zaXRpb25cbik6IFBvc2l0aW9uW10ge1xuICBjb25zdCBsaW5lU3RyaW5nOiBMaW5lU3RyaW5nID0ge1xuICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICBjb29yZGluYXRlczogW3AxLCBwMl0sXG4gIH07XG4gIGNvbnN0IHB0ID0gcG9pbnQobWFwQ29vcmRzKTtcbiAgY29uc3QgZGRpc3RhbmNlID0gcG9pbnRUb0xpbmVEaXN0YW5jZShwdCwgbGluZVN0cmluZyk7XG4gIGNvbnN0IGxpbmVCZWFyaW5nID0gYmVhcmluZyhwMSwgcDIpO1xuXG4gIC8vIENoZWNrIGlmIGN1cnJlbnQgcG9pbnQgaXMgdG8gdGhlIGxlZnQgb3IgcmlnaHQgb2YgbGluZVxuICAvLyBMaW5lIGZyb20gQT0oeDEseTEpIHRvIEI9KHgyLHkyKSBhIHBvaW50IFA9KHgseSlcbiAgLy8gdGhlbiAoeOKIkngxKSh5MuKIknkxKeKIkih54oiSeTEpKHgy4oiSeDEpXG4gIGNvbnN0IGlzUG9pbnRUb0xlZnRPZkxpbmUgPVxuICAgIChtYXBDb29yZHNbMF0gLSBwMVswXSkgKiAocDJbMV0gLSBwMVsxXSkgLSAobWFwQ29vcmRzWzFdIC0gcDFbMV0pICogKHAyWzBdIC0gcDFbMF0pO1xuXG4gIC8vIEJlYXJpbmcgdG8gZHJhdyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lIHN0cmluZ1xuICBjb25zdCBvcnRob2dvbmFsQmVhcmluZyA9IGlzUG9pbnRUb0xlZnRPZkxpbmUgPCAwID8gbGluZUJlYXJpbmcgLSA5MCA6IGxpbmVCZWFyaW5nIC0gMjcwO1xuXG4gIC8vIEdldCBjb29yZGluYXRlcyBmb3IgdGhlIHBvaW50IHAzIGFuZCBwNCB3aGljaCBhcmUgcGVycGVuZGljdWxhciB0byB0aGUgbGluZVN0cmluZ1xuICAvLyBBZGQgdGhlIGRpc3RhbmNlIGFzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG1vdmVzIGF3YXkgZnJvbSB0aGUgbGluZVN0cmluZ1xuICBjb25zdCBwMyA9IGRlc3RpbmF0aW9uKHAyLCBkZGlzdGFuY2UsIG9ydGhvZ29uYWxCZWFyaW5nKTtcbiAgY29uc3QgcDQgPSBkZXN0aW5hdGlvbihwMSwgZGRpc3RhbmNlLCBvcnRob2dvbmFsQmVhcmluZyk7XG5cbiAgcmV0dXJuIFtwMy5nZW9tZXRyeS5jb29yZGluYXRlcywgcDQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNdIGFzIFBvc2l0aW9uW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZTJkKHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBkeCA9IHgxIC0geDI7XG4gIGNvbnN0IGR5ID0geTEgLSB5MjtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaXgoYTogbnVtYmVyLCBiOiBudW1iZXIsIHJhdGlvOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gYiAqIHJhdGlvICsgYSAqICgxIC0gcmF0aW8pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmVhcmVzdFBvaW50T25Qcm9qZWN0ZWRMaW5lKFxuICBsaW5lOiBGZWF0dXJlT2Y8TGluZVN0cmluZz4sXG4gIGluUG9pbnQ6IEZlYXR1cmVPZjxQb2ludD4sXG4gIHZpZXdwb3J0OiBWaWV3cG9ydFxuKTogTmVhcmVzdFBvaW50VHlwZSB7XG4gIGNvbnN0IHdtVmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh2aWV3cG9ydCk7XG4gIC8vIFByb2plY3QgdGhlIGxpbmUgdG8gdmlld3BvcnQsIHRoZW4gZmluZCB0aGUgbmVhcmVzdCBwb2ludFxuICBjb25zdCBjb29yZGluYXRlczogQXJyYXk8QXJyYXk8bnVtYmVyPj4gPSBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIGFueTtcbiAgY29uc3QgcHJvamVjdGVkQ29vcmRzID0gY29vcmRpbmF0ZXMubWFwKChbeCwgeSwgeiA9IDBdKSA9PiB3bVZpZXdwb3J0LnByb2plY3QoW3gsIHksIHpdKSk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgW3gsIHldID0gd21WaWV3cG9ydC5wcm9qZWN0KGluUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAvLyBjb25zb2xlLmxvZygncHJvamVjdGVkQ29vcmRzJywgSlNPTi5zdHJpbmdpZnkocHJvamVjdGVkQ29vcmRzKSk7XG5cbiAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gIGxldCBtaW5Qb2ludEluZm8gPSB7fTtcblxuICBwcm9qZWN0ZWRDb29yZHMuZm9yRWFjaCgoW3gyLCB5Ml0sIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgW3gxLCB5MV0gPSBwcm9qZWN0ZWRDb29yZHNbaW5kZXggLSAxXTtcblxuICAgIC8vIGxpbmUgZnJvbSBwcm9qZWN0ZWRDb29yZHNbaW5kZXggLSAxXSB0byBwcm9qZWN0ZWRDb29yZHNbaW5kZXhdXG4gICAgLy8gY29udmVydCB0byBBeCArIEJ5ICsgQyA9IDBcbiAgICBjb25zdCBBID0geTEgLSB5MjtcbiAgICBjb25zdCBCID0geDIgLSB4MTtcbiAgICBjb25zdCBDID0geDEgKiB5MiAtIHgyICogeTE7XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXG4gICAgY29uc3QgZGl2ID0gQSAqIEEgKyBCICogQjtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguYWJzKEEgKiB4ICsgQiAqIHkgKyBDKSAvIE1hdGguc3FydChkaXYpO1xuXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgaW5zaWRlIGJvdW5kc1xuXG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICBtaW5Qb2ludEluZm8gPSB7XG4gICAgICAgIGluZGV4LFxuICAgICAgICB4MDogKEIgKiAoQiAqIHggLSBBICogeSkgLSBBICogQykgLyBkaXYsXG4gICAgICAgIHkwOiAoQSAqICgtQiAqIHggKyBBICogeSkgLSBCICogQykgLyBkaXYsXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgeyBpbmRleCwgeDAsIHkwIH0gPSBtaW5Qb2ludEluZm87XG4gIGNvbnN0IFt4MSwgeTEsIHoxID0gMF0gPSBwcm9qZWN0ZWRDb29yZHNbaW5kZXggLSAxXTtcbiAgY29uc3QgW3gyLCB5MiwgejIgPSAwXSA9IHByb2plY3RlZENvb3Jkc1tpbmRleF07XG5cbiAgLy8gY2FsY3VsYXRlIHdoYXQgcmF0aW8gb2YgdGhlIGxpbmUgd2UgYXJlIG9uIHRvIGZpbmQgdGhlIHByb3BlciB6XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBkaXN0YW5jZTJkKHgxLCB5MSwgeDIsIHkyKTtcbiAgY29uc3Qgc3RhcnRUb1BvaW50TGVuZ3RoID0gZGlzdGFuY2UyZCh4MSwgeTEsIHgwLCB5MCk7XG4gIGNvbnN0IHJhdGlvID0gc3RhcnRUb1BvaW50TGVuZ3RoIC8gbGluZUxlbmd0aDtcbiAgY29uc3QgejAgPSBtaXgoejEsIHoyLCByYXRpbyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICBjb29yZGluYXRlczogd21WaWV3cG9ydC51bnByb2plY3QoW3gwLCB5MCwgejBdKSxcbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIC8vIFRPRE86IGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgaW4gcHJvcGVyIHVuaXRzXG4gICAgICBkaXN0OiBtaW5EaXN0YW5jZSxcbiAgICAgIGluZGV4OiBpbmRleCAtIDEsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lYXJlc3RQb2ludE9uTGluZTxHIGV4dGVuZHMgTGluZVN0cmluZyB8IE11bHRpTGluZVN0cmluZz4oXG4gIGxpbmVzOiBGZWF0dXJlT2Y8TGluZVN0cmluZz4sXG4gIGluUG9pbnQ6IEZlYXR1cmVPZjxQb2ludD4sXG4gIHZpZXdwb3J0PzogVmlld3BvcnRcbik6IE5lYXJlc3RQb2ludFR5cGUge1xuICBsZXQgbWVyY2F0b3I7XG5cbiAgaWYgKHZpZXdwb3J0KSB7XG4gICAgbWVyY2F0b3IgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh2aWV3cG9ydCk7XG4gIH1cbiAgbGV0IGNsb3Nlc3RQb2ludDogYW55ID0gcG9pbnQoW0luZmluaXR5LCBJbmZpbml0eV0sIHtcbiAgICBkaXN0OiBJbmZpbml0eSxcbiAgfSk7XG5cbiAgaWYgKCFsaW5lcy5nZW9tZXRyeT8uY29vcmRpbmF0ZXMubGVuZ3RoIHx8IGxpbmVzLmdlb21ldHJ5Py5jb29yZGluYXRlcy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbiAgfVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgZmxhdHRlbkVhY2gobGluZXMsIChsaW5lOiBhbnkpID0+IHtcbiAgICBjb25zdCBjb29yZHM6IGFueSA9IGdldENvb3JkcyhsaW5lKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgcG9pbnRDb29yZHM6IGFueSA9IGdldENvb3JkcyhpblBvaW50KTtcblxuICAgIGxldCBtaW5EaXN0O1xuICAgIGxldCB0bztcbiAgICBsZXQgZnJvbTtcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICBsZXQgc2VnbWVudElkeDtcbiAgICBsZXQgZGlzdDtcblxuICAgIGlmIChjb29yZHMubGVuZ3RoID4gMSAmJiBwb2ludENvb3Jkcy5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lQ29vcmRpbmF0ZXM7XG4gICAgICBsZXQgcG9pbnRDb29yZGluYXRlO1xuXG4gICAgICAvLyBJZiB2aWV3cG9ydCBpcyBnaXZlbiwgdGhlbiB0cmFuc2xhdGUgdGhlc2UgY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIHRvIGluY3JlYXNlIHByZWNpc2lvblxuICAgICAgaWYgKG1lcmNhdG9yKSB7XG4gICAgICAgIGxpbmVDb29yZGluYXRlcyA9IGNvb3Jkcy5tYXAoKGxpbmVDb29yZGluYXRlKSA9PiBtZXJjYXRvci5wcm9qZWN0KGxpbmVDb29yZGluYXRlKSk7XG4gICAgICAgIHBvaW50Q29vcmRpbmF0ZSA9IG1lcmNhdG9yLnByb2plY3QocG9pbnRDb29yZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZUNvb3JkaW5hdGVzID0gY29vcmRzO1xuICAgICAgICBwb2ludENvb3JkaW5hdGUgPSBwb2ludENvb3JkcztcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgbiA9IDE7IG4gPCBsaW5lQ29vcmRpbmF0ZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgaWYgKGxpbmVDb29yZGluYXRlc1tuXVswXSAhPT0gbGluZUNvb3JkaW5hdGVzW24gLSAxXVswXSkge1xuICAgICAgICAgIGNvbnN0IHNsb3BlID1cbiAgICAgICAgICAgIChsaW5lQ29vcmRpbmF0ZXNbbl1bMV0gLSBsaW5lQ29vcmRpbmF0ZXNbbiAtIDFdWzFdKSAvXG4gICAgICAgICAgICAobGluZUNvb3JkaW5hdGVzW25dWzBdIC0gbGluZUNvb3JkaW5hdGVzW24gLSAxXVswXSk7XG4gICAgICAgICAgY29uc3QgaW52ZXJzZVNsb3BlID0gbGluZUNvb3JkaW5hdGVzW25dWzFdIC0gc2xvcGUgKiBsaW5lQ29vcmRpbmF0ZXNbbl1bMF07XG5cbiAgICAgICAgICBkaXN0ID1cbiAgICAgICAgICAgIE1hdGguYWJzKHNsb3BlICogcG9pbnRDb29yZGluYXRlWzBdICsgaW52ZXJzZVNsb3BlIC0gcG9pbnRDb29yZGluYXRlWzFdKSAvXG4gICAgICAgICAgICBNYXRoLnNxcnQoc2xvcGUgKiBzbG9wZSArIDEpO1xuICAgICAgICB9IGVsc2UgZGlzdCA9IE1hdGguYWJzKHBvaW50Q29vcmRpbmF0ZVswXSAtIGxpbmVDb29yZGluYXRlc1tuXVswXSk7XG5cbiAgICAgICAgLy8gbGVuZ3RoXjIgb2YgbGluZSBzZWdtZW50XG4gICAgICAgIGNvbnN0IHJsMiA9XG4gICAgICAgICAgTWF0aC5wb3cobGluZUNvb3JkaW5hdGVzW25dWzFdIC0gbGluZUNvb3JkaW5hdGVzW24gLSAxXVsxXSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KGxpbmVDb29yZGluYXRlc1tuXVswXSAtIGxpbmVDb29yZGluYXRlc1tuIC0gMV1bMF0sIDIpO1xuXG4gICAgICAgIC8vIGRpc3RhbmNlXjIgb2YgcHQgdG8gZW5kIGxpbmUgc2VnbWVudFxuICAgICAgICBjb25zdCBsbjIgPVxuICAgICAgICAgIE1hdGgucG93KGxpbmVDb29yZGluYXRlc1tuXVsxXSAtIHBvaW50Q29vcmRpbmF0ZVsxXSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KGxpbmVDb29yZGluYXRlc1tuXVswXSAtIHBvaW50Q29vcmRpbmF0ZVswXSwgMik7XG5cbiAgICAgICAgLy8gZGlzdGFuY2VeMiBvZiBwdCB0byBiZWdpbiBsaW5lIHNlZ21lbnRcbiAgICAgICAgY29uc3QgbG5tMTIgPVxuICAgICAgICAgIE1hdGgucG93KGxpbmVDb29yZGluYXRlc1tuIC0gMV1bMV0gLSBwb2ludENvb3JkaW5hdGVbMV0sIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhsaW5lQ29vcmRpbmF0ZXNbbiAtIDFdWzBdIC0gcG9pbnRDb29yZGluYXRlWzBdLCAyKTtcblxuICAgICAgICAvLyBtaW5pbXVtIGRpc3RhbmNlXjIgb2YgcHQgdG8gaW5maW5pdGUgbGluZVxuICAgICAgICBjb25zdCBkaXN0MiA9IE1hdGgucG93KGRpc3QsIDIpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZWQgbGVuZ3RoXjIgb2YgbGluZSBzZWdtZW50XG4gICAgICAgIGNvbnN0IGNhbGNybDIgPSBsbjIgLSBkaXN0MiArIGxubTEyIC0gZGlzdDI7XG5cbiAgICAgICAgLy8gcmVkZWZpbmUgbWluaW11bSBkaXN0YW5jZSB0byBsaW5lIHNlZ21lbnQgKG5vdCBpbmZpbml0ZSBsaW5lKSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKGNhbGNybDIgPiBybDIpIHtcbiAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KE1hdGgubWluKGxuMiwgbG5tMTIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW5EaXN0ID09PSBudWxsIHx8IG1pbkRpc3QgPT09IHVuZGVmaW5lZCB8fCBtaW5EaXN0ID4gZGlzdCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICBpZiAoY2FsY3JsMiA+IHJsMikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgaWYgKGxubTEyIDwgbG4yKSB7XG4gICAgICAgICAgICAgIHRvID0gMDsgLy8gbmVhcmVyIHRvIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICAgIGZyb20gPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIG5lYXJlciB0byBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIHRvID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGVycGVuZGljdWxhciBmcm9tIHBvaW50IGludGVyc2VjdHMgbGluZSBzZWdtZW50XG4gICAgICAgICAgICB0byA9IE1hdGguc3FydChsbm0xMiAtIGRpc3QyKSAvIE1hdGguc3FydChybDIpO1xuICAgICAgICAgICAgZnJvbSA9IE1hdGguc3FydChsbjIgLSBkaXN0MikgLyBNYXRoLnNxcnQocmwyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgc2VnbWVudElkeCA9IG47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZHggPSBsaW5lQ29vcmRpbmF0ZXNbc2VnbWVudElkeCAtIDFdWzBdIC0gbGluZUNvb3JkaW5hdGVzW3NlZ21lbnRJZHhdWzBdO1xuICAgICAgY29uc3QgZHkgPSBsaW5lQ29vcmRpbmF0ZXNbc2VnbWVudElkeCAtIDFdWzFdIC0gbGluZUNvb3JkaW5hdGVzW3NlZ21lbnRJZHhdWzFdO1xuXG4gICAgICB4ID0gbGluZUNvb3JkaW5hdGVzW3NlZ21lbnRJZHggLSAxXVswXSAtIGR4ICogdG87XG4gICAgICB5ID0gbGluZUNvb3JkaW5hdGVzW3NlZ21lbnRJZHggLSAxXVsxXSAtIGR5ICogdG87XG4gICAgfVxuXG4gICAgLy8gaW5kZXggbmVlZHMgdG8gYmUgLTEgYmVjYXVzZSB3ZSBoYXZlIHRvIGFjY291bnQgZm9yIHRoZSBzaGlmdCBmcm9tIGluaXRpYWwgYmFja3NjYW5cbiAgICBsZXQgc25hcFBvaW50ID0geyB4LCB5LCBpZHg6IHNlZ21lbnRJZHggLSAxLCB0bywgZnJvbSB9O1xuXG4gICAgaWYgKG1lcmNhdG9yKSB7XG4gICAgICBjb25zdCBwaXhlbFRvTGF0TG9uZyA9IG1lcmNhdG9yLnVucHJvamVjdChbc25hcFBvaW50LngsIHNuYXBQb2ludC55XSk7XG4gICAgICBzbmFwUG9pbnQgPSB7XG4gICAgICAgIHg6IHBpeGVsVG9MYXRMb25nWzBdLFxuICAgICAgICB5OiBwaXhlbFRvTGF0TG9uZ1sxXSxcbiAgICAgICAgaWR4OiBzZWdtZW50SWR4IC0gMSxcbiAgICAgICAgdG8sXG4gICAgICAgIGZyb20sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNsb3Nlc3RQb2ludCA9IHBvaW50KFtzbmFwUG9pbnQueCwgc25hcFBvaW50LnldLCB7XG4gICAgICBkaXN0OiBNYXRoLmFicyhzbmFwUG9pbnQuZnJvbSAtIHNuYXBQb2ludC50byksXG4gICAgICBpbmRleDogc25hcFBvaW50LmlkeCxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpY2tlZEVkaXRIYW5kbGUoXG4gIHBpY2tzOiBQaWNrW10gfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBFZGl0SGFuZGxlRmVhdHVyZSB8IG51bGwgfCB1bmRlZmluZWQge1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UGlja2VkRWRpdEhhbmRsZXMocGlja3MpO1xuICByZXR1cm4gaGFuZGxlcy5sZW5ndGggPyBoYW5kbGVzWzBdIDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpY2tlZFNuYXBTb3VyY2VFZGl0SGFuZGxlKFxuICBwaWNrczogUGlja1tdIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogRWRpdEhhbmRsZUZlYXR1cmUgfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFBpY2tlZEVkaXRIYW5kbGVzKHBpY2tzKTtcbiAgcmV0dXJuIGhhbmRsZXMuZmluZCgoaGFuZGxlKSA9PiBoYW5kbGUucHJvcGVydGllcy5lZGl0SGFuZGxlVHlwZSA9PT0gJ3NuYXAtc291cmNlJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb25HdWlkZVBpY2tzKHBpY2tzOiBQaWNrW10pOiBQaWNrW10ge1xuICByZXR1cm4gcGlja3MgJiYgcGlja3MuZmlsdGVyKChwaWNrKSA9PiAhcGljay5pc0d1aWRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpY2tlZEV4aXN0aW5nRWRpdEhhbmRsZShcbiAgcGlja3M6IFBpY2tbXSB8IG51bGwgfCB1bmRlZmluZWRcbik6IEVkaXRIYW5kbGVGZWF0dXJlIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGhhbmRsZXMgPSBnZXRQaWNrZWRFZGl0SGFuZGxlcyhwaWNrcyk7XG4gIHJldHVybiBoYW5kbGVzLmZpbmQoXG4gICAgKHsgcHJvcGVydGllcyB9KSA9PiBwcm9wZXJ0aWVzLmZlYXR1cmVJbmRleCA+PSAwICYmIHByb3BlcnRpZXMuZWRpdEhhbmRsZVR5cGUgPT09ICdleGlzdGluZydcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpY2tlZEludGVybWVkaWF0ZUVkaXRIYW5kbGUoXG4gIHBpY2tzOiBQaWNrW10gfCBudWxsIHwgdW5kZWZpbmVkXG4pOiBFZGl0SGFuZGxlRmVhdHVyZSB8IG51bGwgfCB1bmRlZmluZWQge1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UGlja2VkRWRpdEhhbmRsZXMocGlja3MpO1xuICByZXR1cm4gaGFuZGxlcy5maW5kKFxuICAgICh7IHByb3BlcnRpZXMgfSkgPT4gcHJvcGVydGllcy5mZWF0dXJlSW5kZXggPj0gMCAmJiBwcm9wZXJ0aWVzLmVkaXRIYW5kbGVUeXBlID09PSAnaW50ZXJtZWRpYXRlJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGlja2VkRWRpdEhhbmRsZXMocGlja3M6IFBpY2tbXSB8IG51bGwgfCB1bmRlZmluZWQpOiBFZGl0SGFuZGxlRmVhdHVyZVtdIHtcbiAgY29uc3QgaGFuZGxlcyA9XG4gICAgKHBpY2tzICYmXG4gICAgICBwaWNrc1xuICAgICAgICAuZmlsdGVyKChwaWNrKSA9PiBwaWNrLmlzR3VpZGUgJiYgcGljay5vYmplY3QucHJvcGVydGllcy5ndWlkZVR5cGUgPT09ICdlZGl0SGFuZGxlJylcbiAgICAgICAgLm1hcCgocGljaykgPT4gcGljay5vYmplY3QpKSB8fFxuICAgIFtdO1xuXG4gIHJldHVybiBoYW5kbGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWRpdEhhbmRsZXNGb3JHZW9tZXRyeShcbiAgZ2VvbWV0cnk6IEdlb21ldHJ5LFxuICBmZWF0dXJlSW5kZXg6IG51bWJlcixcbiAgZWRpdEhhbmRsZVR5cGU6IEVkaXRIYW5kbGVUeXBlID0gJ2V4aXN0aW5nJ1xuKTogRWRpdEhhbmRsZUZlYXR1cmVbXSB7XG4gIGxldCBoYW5kbGVzOiBFZGl0SGFuZGxlRmVhdHVyZVtdID0gW107XG5cbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgICAgLy8gcG9zaXRpb25zIGFyZSBub3QgbmVzdGVkXG4gICAgICBoYW5kbGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGd1aWRlVHlwZTogJ2VkaXRIYW5kbGUnLFxuICAgICAgICAgICAgZWRpdEhhbmRsZVR5cGUsXG4gICAgICAgICAgICBwb3NpdGlvbkluZGV4ZXM6IFtdLFxuICAgICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgICBjb29yZGluYXRlczogZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDEgbGV2ZWxcbiAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyhnZW9tZXRyeS5jb29yZGluYXRlcywgW10sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDIgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKGdlb21ldHJ5LmNvb3JkaW5hdGVzW2FdLCBbYV0sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgLy8gcG9zaXRpb25zIGFyZSBuZXN0ZWQgMyBsZXZlbHNcbiAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBnZW9tZXRyeS5jb29yZGluYXRlc1thXS5sZW5ndGg7IGIrKykge1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgICAgIGdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMoXG4gICAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzW2FdW2JdLFxuICAgICAgICAgICAgICBbYSwgYl0sXG4gICAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgZWRpdEhhbmRsZVR5cGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIERvbid0IHJlcGVhdCB0aGUgZmlyc3QvbGFzdCBoYW5kbGUgZm9yIFBvbHlnb25zXG4gICAgICAgICAgaGFuZGxlcyA9IGhhbmRsZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aHJvdyBFcnJvcihgVW5oYW5kbGVkIGdlb21ldHJ5IHR5cGU6ICR7Z2VvbWV0cnkudHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVzO1xufVxuXG5mdW5jdGlvbiBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKFxuICBjb29yZGluYXRlczogYW55W10sXG4gIHBvc2l0aW9uSW5kZXhQcmVmaXg6IG51bWJlcltdLFxuICBmZWF0dXJlSW5kZXg6IG51bWJlcixcbiAgZWRpdEhhbmRsZVR5cGU6IEVkaXRIYW5kbGVUeXBlID0gJ2V4aXN0aW5nJ1xuKTogRWRpdEhhbmRsZUZlYXR1cmVbXSB7XG4gIGNvbnN0IGVkaXRIYW5kbGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNvb3JkaW5hdGVzW2ldO1xuICAgIGVkaXRIYW5kbGVzLnB1c2goe1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBndWlkZVR5cGU6ICdlZGl0SGFuZGxlJyxcbiAgICAgICAgcG9zaXRpb25JbmRleGVzOiBbLi4ucG9zaXRpb25JbmRleFByZWZpeCwgaV0sXG4gICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgZWRpdEhhbmRsZVR5cGUsXG4gICAgICB9LFxuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IHBvc2l0aW9uLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZWRpdEhhbmRsZXM7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBjb29yZGluYXRlcyBmb3IgYSBmZWF0dXJlIHByZXNlcnZpbmcgcmVjdGFuZ3VsYXIgc2hhcGUuXG4gKiBAcGFyYW0gZmVhdHVyZSBGZWF0dXJlIGJlZm9yZSBtb2RpZmljYXRpb24uXG4gKiBAcGFyYW0gZWRpdEhhbmRsZUluZGV4IEluZGV4IG9mIHRoZSBwb2ludCB0byBtb2RpZnkuXG4gKiBAcGFyYW0gbWFwQ29vcmRzIE5ldyBwb3NpdGlvbiBmb3IgdGhlIHBvaW50LlxuICogQHJldHVybnMgVXBkYXRlZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVJlY3RhbmdsZVBvc2l0aW9uKFxuICBmZWF0dXJlOiBGZWF0dXJlT2Y8UG9seWdvbj4sXG4gIGVkaXRIYW5kbGVJbmRleDogbnVtYmVyLFxuICBtYXBDb29yZHM6IFBvc2l0aW9uXG4pOiBQb3NpdGlvbltdW10ge1xuICBjb25zdCBjb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHBvaW50cyA9IGNvb3JkaW5hdGVzWzBdLnNsaWNlKDAsIDQpO1xuICBwb2ludHNbZWRpdEhhbmRsZUluZGV4ICUgNF0gPSBtYXBDb29yZHM7XG5cbiAgY29uc3QgcDAgPSBwb2ludHNbKGVkaXRIYW5kbGVJbmRleCArIDIpICUgNF07XG4gIGNvbnN0IHAyID0gcG9pbnRzW2VkaXRIYW5kbGVJbmRleCAlIDRdO1xuICBwb2ludHNbKGVkaXRIYW5kbGVJbmRleCArIDEpICUgNF0gPSBbcDJbMF0sIHAwWzFdXTtcbiAgcG9pbnRzWyhlZGl0SGFuZGxlSW5kZXggKyAzKSAlIDRdID0gW3AwWzBdLCBwMlsxXV07XG5cbiAgcmV0dXJuIFtbLi4ucG9pbnRzLCBwb2ludHNbMF1dXTtcbn1cblxuLyoqIENyZWF0ZXMgYSBjb3B5IG9mIGZlYXR1cmUncyBjb29yZGluYXRlcy5cbiAqIEVhY2ggcG9zaXRpb24gaW4gY29vcmRpbmF0ZXMgaXMgdHJhbnNmb3JtZWQgYnkgY2FsbGluZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0gY29vcmRzIENvb3JkaW5hdGVzIG9mIGEgZmVhdHVyZS5cbiAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBlYWNoIGNvb3JkaW5hdGUuXG4gKiBAcmV0dW5zIFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwQ29vcmRzKFxuICBjb29yZHM6IEFueUNvb3JkaW5hdGVzLFxuICBjYWxsYmFjazogKGNvb3JkczogUG9zaXRpb24pID0+IFBvc2l0aW9uXG4pOiBBbnlDb29yZGluYXRlcyB7XG4gIGlmICh0eXBlb2YgY29vcmRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIGlmICghaXNOYU4oY29vcmRzWzBdKSAmJiBpc0Zpbml0ZShjb29yZHNbMF0pKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soY29vcmRzIGFzIFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfVxuXG4gIHJldHVybiAoY29vcmRzIGFzIFBvc2l0aW9uW10pXG4gICAgLm1hcCgoY29vcmQpID0+IHtcbiAgICAgIHJldHVybiBtYXBDb29yZHMoY29vcmQsIGNhbGxiYWNrKSBhcyBQb3NpdGlvbjtcbiAgICB9KVxuICAgIC5maWx0ZXIoQm9vbGVhbik7XG59XG4iXX0=