"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureDistanceMode = void 0;

var _distance = _interopRequireDefault(require("@turf/distance"));

var _midpoint = _interopRequireDefault(require("@turf/midpoint"));

var _utils = require("../utils");

var _geojsonEditMode = require("./geojson-edit-mode");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MeasureDistanceMode = /*#__PURE__*/function (_GeoJsonEditMode) {
  _inherits(MeasureDistanceMode, _GeoJsonEditMode);

  var _super = _createSuper(MeasureDistanceMode);

  function MeasureDistanceMode() {
    var _this;

    _classCallCheck(this, MeasureDistanceMode);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "_isMeasuringSessionFinished", false);

    _defineProperty(_assertThisInitialized(_this), "_currentTooltips", []);

    _defineProperty(_assertThisInitialized(_this), "_currentDistance", 0);

    _defineProperty(_assertThisInitialized(_this), "_calculateDistanceForTooltip", function (_ref) {
      var positionA = _ref.positionA,
          positionB = _ref.positionB,
          modeConfig = _ref.modeConfig;

      var _ref2 = modeConfig || {},
          turfOptions = _ref2.turfOptions,
          measurementCallback = _ref2.measurementCallback;

      var distance = (0, _distance["default"])(positionA, positionB, turfOptions);

      if (measurementCallback) {
        measurementCallback(distance);
      }

      return distance;
    });

    return _this;
  }

  _createClass(MeasureDistanceMode, [{
    key: "_formatTooltip",
    value: function _formatTooltip(distance, modeConfig) {
      var _ref3 = modeConfig || {},
          formatTooltip = _ref3.formatTooltip,
          turfOptions = _ref3.turfOptions;

      var units = turfOptions && turfOptions.units || 'kilometers';
      var text;

      if (formatTooltip) {
        text = formatTooltip(distance);
      } else {
        // By default, round to 2 decimal places and append units
        text = "".concat(parseFloat(distance).toFixed(2), " ").concat(units);
      }

      return text;
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {
      var modeConfig = props.modeConfig,
          data = props.data,
          onEdit = props.onEdit;

      var _ref4 = modeConfig || {},
          _ref4$centerTooltipsO = _ref4.centerTooltipsOnLine,
          centerTooltipsOnLine = _ref4$centerTooltipsO === void 0 ? false : _ref4$centerTooltipsO; // restart measuring session


      if (this._isMeasuringSessionFinished) {
        this._isMeasuringSessionFinished = false;
        this.resetClickSequence();
        this._currentTooltips = [];
        this._currentDistance = 0;
      }

      var picks = event.picks;
      var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);
      var positionAdded = false;

      if (!clickedEditHandle) {
        // Don't add another point right next to an existing one
        this.addClickSequence(event);
        positionAdded = true;
      }

      var clickSequence = this.getClickSequence();

      if (clickSequence.length > 1 && clickedEditHandle && Array.isArray(clickedEditHandle.properties.positionIndexes) && clickedEditHandle.properties.positionIndexes[0] === clickSequence.length - 1) {
        // They clicked the last point (or double-clicked), so add the LineString
        this._isMeasuringSessionFinished = true;
      } else if (positionAdded) {
        if (clickSequence.length > 1) {
          this._currentDistance += this._calculateDistanceForTooltip({
            positionA: clickSequence[clickSequence.length - 2],
            positionB: clickSequence[clickSequence.length - 1],
            modeConfig: modeConfig
          });
          var tooltipPosition = centerTooltipsOnLine ? (0, _midpoint["default"])(clickSequence[clickSequence.length - 2], clickSequence[clickSequence.length - 1]).geometry.coordinates : event.mapCoords;

          this._currentTooltips.push({
            position: tooltipPosition,
            text: this._formatTooltip(this._currentDistance, modeConfig)
          });
        } // new tentative point


        onEdit({
          // data is the same
          updatedData: data,
          editType: 'addTentativePosition',
          editContext: {
            position: event.mapCoords
          }
        });
      }
    }
  }, {
    key: "handleKeyUp",
    value: function handleKeyUp(event, props) {
      if (this._isMeasuringSessionFinished) return;
      event.stopPropagation();
      var key = event.key;
      var clickSequenceLength = this.getClickSequence().length;

      switch (key) {
        case 'Escape':
          this._isMeasuringSessionFinished = true;

          if (clickSequenceLength === 1) {
            this.resetClickSequence();
            this._currentTooltips = [];
          } // force update drawings


          props.onUpdateCursor('cell');
          break;

        case 'Enter':
          this.handleClick(props.lastPointerMoveEvent, props);
          this._isMeasuringSessionFinished = true;
          break;

        default:
          break;
      }
    }
  }, {
    key: "getGuides",
    value: function getGuides(props) {
      var _guides$features;

      var lastPointerMoveEvent = props.lastPointerMoveEvent;
      var clickSequence = this.getClickSequence();
      var lastCoords = lastPointerMoveEvent && !this._isMeasuringSessionFinished ? [lastPointerMoveEvent.mapCoords] : [];
      var guides = {
        type: 'FeatureCollection',
        features: []
      };

      if (clickSequence.length > 0) {
        guides.features.push({
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'LineString',
            coordinates: [].concat(_toConsumableArray(clickSequence), lastCoords)
          }
        });
      }

      var editHandles = clickSequence.map(function (clickedCoord, index) {
        return {
          type: 'Feature',
          properties: {
            guideType: 'editHandle',
            editHandleType: 'existing',
            featureIndex: -1,
            positionIndexes: [index]
          },
          geometry: {
            type: 'Point',
            coordinates: clickedCoord
          }
        };
      });

      (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(editHandles)); // @ts-ignore


      return guides;
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      props.onUpdateCursor('cell');
    }
  }, {
    key: "getTooltips",
    value: function getTooltips(props) {
      var lastPointerMoveEvent = props.lastPointerMoveEvent,
          modeConfig = props.modeConfig;

      var _ref5 = modeConfig || {},
          _ref5$centerTooltipsO = _ref5.centerTooltipsOnLine,
          centerTooltipsOnLine = _ref5$centerTooltipsO === void 0 ? false : _ref5$centerTooltipsO;

      var positions = this.getClickSequence();

      if (positions.length > 0 && lastPointerMoveEvent && !this._isMeasuringSessionFinished) {
        var distance = this._calculateDistanceForTooltip({
          positionA: positions[positions.length - 1],
          positionB: lastPointerMoveEvent.mapCoords,
          modeConfig: props.modeConfig
        });

        var tooltipPosition = centerTooltipsOnLine ? (0, _midpoint["default"])(positions[positions.length - 1], lastPointerMoveEvent.mapCoords).geometry.coordinates : lastPointerMoveEvent.mapCoords;
        return [].concat(_toConsumableArray(this._currentTooltips), [{
          position: tooltipPosition,
          text: this._formatTooltip(this._currentDistance + distance, modeConfig)
        }]);
      }

      return this._currentTooltips;
    }
  }]);

  return MeasureDistanceMode;
}(_geojsonEditMode.GeoJsonEditMode);

exports.MeasureDistanceMode = MeasureDistanceMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbWVhc3VyZS1kaXN0YW5jZS1tb2RlLnRzIl0sIm5hbWVzIjpbIk1lYXN1cmVEaXN0YW5jZU1vZGUiLCJwb3NpdGlvbkEiLCJwb3NpdGlvbkIiLCJtb2RlQ29uZmlnIiwidHVyZk9wdGlvbnMiLCJtZWFzdXJlbWVudENhbGxiYWNrIiwiZGlzdGFuY2UiLCJmb3JtYXRUb29sdGlwIiwidW5pdHMiLCJ0ZXh0IiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJldmVudCIsInByb3BzIiwiZGF0YSIsIm9uRWRpdCIsImNlbnRlclRvb2x0aXBzT25MaW5lIiwiX2lzTWVhc3VyaW5nU2Vzc2lvbkZpbmlzaGVkIiwicmVzZXRDbGlja1NlcXVlbmNlIiwiX2N1cnJlbnRUb29sdGlwcyIsIl9jdXJyZW50RGlzdGFuY2UiLCJwaWNrcyIsImNsaWNrZWRFZGl0SGFuZGxlIiwicG9zaXRpb25BZGRlZCIsImFkZENsaWNrU2VxdWVuY2UiLCJjbGlja1NlcXVlbmNlIiwiZ2V0Q2xpY2tTZXF1ZW5jZSIsImxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInByb3BlcnRpZXMiLCJwb3NpdGlvbkluZGV4ZXMiLCJfY2FsY3VsYXRlRGlzdGFuY2VGb3JUb29sdGlwIiwidG9vbHRpcFBvc2l0aW9uIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsIm1hcENvb3JkcyIsInB1c2giLCJwb3NpdGlvbiIsIl9mb3JtYXRUb29sdGlwIiwidXBkYXRlZERhdGEiLCJlZGl0VHlwZSIsImVkaXRDb250ZXh0Iiwic3RvcFByb3BhZ2F0aW9uIiwia2V5IiwiY2xpY2tTZXF1ZW5jZUxlbmd0aCIsIm9uVXBkYXRlQ3Vyc29yIiwiaGFuZGxlQ2xpY2siLCJsYXN0UG9pbnRlck1vdmVFdmVudCIsImxhc3RDb29yZHMiLCJndWlkZXMiLCJ0eXBlIiwiZmVhdHVyZXMiLCJndWlkZVR5cGUiLCJlZGl0SGFuZGxlcyIsIm1hcCIsImNsaWNrZWRDb29yZCIsImluZGV4IiwiZWRpdEhhbmRs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LHNDQUUzQixLQUYyQjs7QUFHMUQsVUFBTTRDLFNBQVMsR0FBRyxLQUFLbEMsZ0JBQUwsRUFBbEI7O0FBRUEsVUFBSWtDLFNBQVMsQ0FBQ2pDLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JxQixvQkFBeEIsSUFBZ0QsQ0FBQyxLQUFLL0IsMkJBQTFELEVBQXVGO0FBQ3JGLFlBQU1YLFFBQVEsR0FBRyxLQUFLMEIsNEJBQUwsQ0FBa0M7QUFDakQvQixVQUFBQSxTQUFTLEVBQUUyRCxTQUFTLENBQUNBLFNBQVMsQ0FBQ2pDLE1BQVYsR0FBbUIsQ0FBcEIsQ0FENkI7QUFFakR6QixVQUFBQSxTQUFTLEVBQUU4QyxvQkFBb0IsQ0FBQ1osU0FGaUI7QUFHakRqQyxVQUFBQSxVQUFVLEVBQUVVLEtBQUssQ0FBQ1Y7QUFIK0IsU0FBbEMsQ0FBakI7O0FBTUEsWUFBTThCLGVBQWUsR0FBR2pCLG9CQUFvQixHQUN4QywwQkFBYTRDLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDakMsTUFBVixHQUFtQixDQUFwQixDQUF0QixFQUE4Q3FCLG9CQUFvQixDQUFDWixTQUFuRSxFQUE4RUYsUUFBOUUsQ0FDR0MsV0FGcUMsR0FHeENhLG9CQUFvQixDQUFDWixTQUh6QjtBQUtBLDRDQUNLLEtBQUtqQixnQkFEVixJQUVFO0FBQ0VtQixVQUFBQSxRQUFRLEVBQUVMLGVBRFo7QUFFRXhCLFVBQUFBLElBQUksRUFBRSxLQUFLOEIsY0FBTCxDQUFvQixLQUFLbkIsZ0JBQUwsR0FBd0JkLFFBQTVDLEVBQXNESCxVQUF0RDtBQUZSLFNBRkY7QUFPRDs7QUFFRCxhQUFPLEtBQUtnQixnQkFBWjtBQUNEOzs7O0VBdk1zQzBDLGdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR1cmZEaXN0YW5jZSBmcm9tICdAdHVyZi9kaXN0YW5jZSc7XG5pbXBvcnQgdHVyZk1pZHBvaW50IGZyb20gJ0B0dXJmL21pZHBvaW50JztcbmltcG9ydCB7IEZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnLi4vZ2VvanNvbi10eXBlcyc7XG5pbXBvcnQgeyBDbGlja0V2ZW50LCBQb2ludGVyTW92ZUV2ZW50LCBNb2RlUHJvcHMsIEd1aWRlRmVhdHVyZUNvbGxlY3Rpb24sIFRvb2x0aXAgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRQaWNrZWRFZGl0SGFuZGxlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgR2VvSnNvbkVkaXRNb2RlIH0gZnJvbSAnLi9nZW9qc29uLWVkaXQtbW9kZSc7XG5cbmV4cG9ydCBjbGFzcyBNZWFzdXJlRGlzdGFuY2VNb2RlIGV4dGVuZHMgR2VvSnNvbkVkaXRNb2RlIHtcbiAgX2lzTWVhc3VyaW5nU2Vzc2lvbkZpbmlzaGVkID0gZmFsc2U7XG4gIF9jdXJyZW50VG9vbHRpcHMgPSBbXTtcbiAgX2N1cnJlbnREaXN0YW5jZSA9IDA7XG5cbiAgX2NhbGN1bGF0ZURpc3RhbmNlRm9yVG9vbHRpcCA9ICh7IHBvc2l0aW9uQSwgcG9zaXRpb25CLCBtb2RlQ29uZmlnIH0pID0+IHtcbiAgICBjb25zdCB7IHR1cmZPcHRpb25zLCBtZWFzdXJlbWVudENhbGxiYWNrIH0gPSBtb2RlQ29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGRpc3RhbmNlID0gdHVyZkRpc3RhbmNlKHBvc2l0aW9uQSwgcG9zaXRpb25CLCB0dXJmT3B0aW9ucyk7XG5cbiAgICBpZiAobWVhc3VyZW1lbnRDYWxsYmFjaykge1xuICAgICAgbWVhc3VyZW1lbnRDYWxsYmFjayhkaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xuICB9O1xuXG4gIF9mb3JtYXRUb29sdGlwKGRpc3RhbmNlLCBtb2RlQ29uZmlnPykge1xuICAgIGNvbnN0IHsgZm9ybWF0VG9vbHRpcCwgdHVyZk9wdGlvbnMgfSA9IG1vZGVDb25maWcgfHwge307XG4gICAgY29uc3QgdW5pdHMgPSAodHVyZk9wdGlvbnMgJiYgdHVyZk9wdGlvbnMudW5pdHMpIHx8ICdraWxvbWV0ZXJzJztcblxuICAgIGxldCB0ZXh0O1xuICAgIGlmIChmb3JtYXRUb29sdGlwKSB7XG4gICAgICB0ZXh0ID0gZm9ybWF0VG9vbHRpcChkaXN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIHJvdW5kIHRvIDIgZGVjaW1hbCBwbGFjZXMgYW5kIGFwcGVuZCB1bml0c1xuICAgICAgdGV4dCA9IGAke3BhcnNlRmxvYXQoZGlzdGFuY2UpLnRvRml4ZWQoMil9ICR7dW5pdHN9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKGV2ZW50OiBDbGlja0V2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikge1xuICAgIGNvbnN0IHsgbW9kZUNvbmZpZywgZGF0YSwgb25FZGl0IH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGNlbnRlclRvb2x0aXBzT25MaW5lID0gZmFsc2UgfSA9IG1vZGVDb25maWcgfHwge307XG5cbiAgICAvLyByZXN0YXJ0IG1lYXN1cmluZyBzZXNzaW9uXG4gICAgaWYgKHRoaXMuX2lzTWVhc3VyaW5nU2Vzc2lvbkZpbmlzaGVkKSB7XG4gICAgICB0aGlzLl9pc01lYXN1cmluZ1Nlc3Npb25GaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXNldENsaWNrU2VxdWVuY2UoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUb29sdGlwcyA9IFtdO1xuICAgICAgdGhpcy5fY3VycmVudERpc3RhbmNlID0gMDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHBpY2tzIH0gPSBldmVudDtcbiAgICBjb25zdCBjbGlja2VkRWRpdEhhbmRsZSA9IGdldFBpY2tlZEVkaXRIYW5kbGUocGlja3MpO1xuXG4gICAgbGV0IHBvc2l0aW9uQWRkZWQgPSBmYWxzZTtcbiAgICBpZiAoIWNsaWNrZWRFZGl0SGFuZGxlKSB7XG4gICAgICAvLyBEb24ndCBhZGQgYW5vdGhlciBwb2ludCByaWdodCBuZXh0IHRvIGFuIGV4aXN0aW5nIG9uZVxuICAgICAgdGhpcy5hZGRDbGlja1NlcXVlbmNlKGV2ZW50KTtcbiAgICAgIHBvc2l0aW9uQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG5cbiAgICBpZiAoXG4gICAgICBjbGlja1NlcXVlbmNlLmxlbmd0aCA+IDEgJiZcbiAgICAgIGNsaWNrZWRFZGl0SGFuZGxlICYmXG4gICAgICBBcnJheS5pc0FycmF5KGNsaWNrZWRFZGl0SGFuZGxlLnByb3BlcnRpZXMucG9zaXRpb25JbmRleGVzKSAmJlxuICAgICAgY2xpY2tlZEVkaXRIYW5kbGUucHJvcGVydGllcy5wb3NpdGlvbkluZGV4ZXNbMF0gPT09IGNsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMVxuICAgICkge1xuICAgICAgLy8gVGhleSBjbGlja2VkIHRoZSBsYXN0IHBvaW50IChvciBkb3VibGUtY2xpY2tlZCksIHNvIGFkZCB0aGUgTGluZVN0cmluZ1xuICAgICAgdGhpcy5faXNNZWFzdXJpbmdTZXNzaW9uRmluaXNoZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25BZGRlZCkge1xuICAgICAgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50RGlzdGFuY2UgKz0gdGhpcy5fY2FsY3VsYXRlRGlzdGFuY2VGb3JUb29sdGlwKHtcbiAgICAgICAgICBwb3NpdGlvbkE6IGNsaWNrU2VxdWVuY2VbY2xpY2tTZXF1ZW5jZS5sZW5ndGggLSAyXSxcbiAgICAgICAgICBwb3NpdGlvbkI6IGNsaWNrU2VxdWVuY2VbY2xpY2tTZXF1ZW5jZS5sZW5ndGggLSAxXSxcbiAgICAgICAgICBtb2RlQ29uZmlnLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0b29sdGlwUG9zaXRpb24gPSBjZW50ZXJUb29sdGlwc09uTGluZVxuICAgICAgICAgID8gdHVyZk1pZHBvaW50KFxuICAgICAgICAgICAgICBjbGlja1NlcXVlbmNlW2NsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICAgIGNsaWNrU2VxdWVuY2VbY2xpY2tTZXF1ZW5jZS5sZW5ndGggLSAxXVxuICAgICAgICAgICAgKS5nZW9tZXRyeS5jb29yZGluYXRlc1xuICAgICAgICAgIDogZXZlbnQubWFwQ29vcmRzO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb29sdGlwcy5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogdG9vbHRpcFBvc2l0aW9uLFxuICAgICAgICAgIHRleHQ6IHRoaXMuX2Zvcm1hdFRvb2x0aXAodGhpcy5fY3VycmVudERpc3RhbmNlLCBtb2RlQ29uZmlnKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5ldyB0ZW50YXRpdmUgcG9pbnRcbiAgICAgIG9uRWRpdCh7XG4gICAgICAgIC8vIGRhdGEgaXMgdGhlIHNhbWVcbiAgICAgICAgdXBkYXRlZERhdGE6IGRhdGEsXG4gICAgICAgIGVkaXRUeXBlOiAnYWRkVGVudGF0aXZlUG9zaXRpb24nLFxuICAgICAgICBlZGl0Q29udGV4dDoge1xuICAgICAgICAgIHBvc2l0aW9uOiBldmVudC5tYXBDb29yZHMsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVLZXlVcChldmVudDogS2V5Ym9hcmRFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBpZiAodGhpcy5faXNNZWFzdXJpbmdTZXNzaW9uRmluaXNoZWQpIHJldHVybjtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IHsga2V5IH0gPSBldmVudDtcblxuICAgIGNvbnN0IGNsaWNrU2VxdWVuY2VMZW5ndGggPSB0aGlzLmdldENsaWNrU2VxdWVuY2UoKS5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgdGhpcy5faXNNZWFzdXJpbmdTZXNzaW9uRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2xpY2tTZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMucmVzZXRDbGlja1NlcXVlbmNlKCk7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRvb2x0aXBzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yY2UgdXBkYXRlIGRyYXdpbmdzXG4gICAgICAgIHByb3BzLm9uVXBkYXRlQ3Vyc29yKCdjZWxsJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKHByb3BzLmxhc3RQb2ludGVyTW92ZUV2ZW50LCBwcm9wcyk7XG4gICAgICAgIHRoaXMuX2lzTWVhc3VyaW5nU2Vzc2lvbkZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBnZXRHdWlkZXMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgICBjb25zdCB7IGxhc3RQb2ludGVyTW92ZUV2ZW50IH0gPSBwcm9wcztcbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG5cbiAgICBjb25zdCBsYXN0Q29vcmRzID1cbiAgICAgIGxhc3RQb2ludGVyTW92ZUV2ZW50ICYmICF0aGlzLl9pc01lYXN1cmluZ1Nlc3Npb25GaW5pc2hlZFxuICAgICAgICA/IFtsYXN0UG9pbnRlck1vdmVFdmVudC5tYXBDb29yZHNdXG4gICAgICAgIDogW107XG5cbiAgICBjb25zdCBndWlkZXMgPSB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IFtdLFxuICAgIH07XG5cbiAgICBpZiAoY2xpY2tTZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgICBndWlkZXMuZmVhdHVyZXMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGd1aWRlVHlwZTogJ3RlbnRhdGl2ZScsXG4gICAgICAgIH0sXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbLi4uY2xpY2tTZXF1ZW5jZSwgLi4ubGFzdENvb3Jkc10sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlZGl0SGFuZGxlcyA9IGNsaWNrU2VxdWVuY2UubWFwKChjbGlja2VkQ29vcmQsIGluZGV4KSA9PiAoe1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBndWlkZVR5cGU6ICdlZGl0SGFuZGxlJyxcbiAgICAgICAgZWRpdEhhbmRsZVR5cGU6ICdleGlzdGluZycsXG4gICAgICAgIGZlYXR1cmVJbmRleDogLTEsXG4gICAgICAgIHBvc2l0aW9uSW5kZXhlczogW2luZGV4XSxcbiAgICAgIH0sXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY2xpY2tlZENvb3JkLFxuICAgICAgfSxcbiAgICB9KSk7XG5cbiAgICBndWlkZXMuZmVhdHVyZXMucHVzaCguLi5lZGl0SGFuZGxlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBndWlkZXM7XG4gIH1cblxuICBoYW5kbGVQb2ludGVyTW92ZShldmVudDogUG9pbnRlck1vdmVFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBwcm9wcy5vblVwZGF0ZUN1cnNvcignY2VsbCcpO1xuICB9XG5cbiAgZ2V0VG9vbHRpcHMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBUb29sdGlwW10ge1xuICAgIGNvbnN0IHsgbGFzdFBvaW50ZXJNb3ZlRXZlbnQsIG1vZGVDb25maWcgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgY2VudGVyVG9vbHRpcHNPbkxpbmUgPSBmYWxzZSB9ID0gbW9kZUNvbmZpZyB8fCB7fTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLmdldENsaWNrU2VxdWVuY2UoKTtcblxuICAgIGlmIChwb3NpdGlvbnMubGVuZ3RoID4gMCAmJiBsYXN0UG9pbnRlck1vdmVFdmVudCAmJiAhdGhpcy5faXNNZWFzdXJpbmdTZXNzaW9uRmluaXNoZWQpIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fY2FsY3VsYXRlRGlzdGFuY2VGb3JUb29sdGlwKHtcbiAgICAgICAgcG9zaXRpb25BOiBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdLFxuICAgICAgICBwb3NpdGlvbkI6IGxhc3RQb2ludGVyTW92ZUV2ZW50Lm1hcENvb3JkcyxcbiAgICAgICAgbW9kZUNvbmZpZzogcHJvcHMubW9kZUNvbmZpZyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b29sdGlwUG9zaXRpb24gPSBjZW50ZXJUb29sdGlwc09uTGluZVxuICAgICAgICA/IHR1cmZNaWRwb2ludChwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdLCBsYXN0UG9pbnRlck1vdmVFdmVudC5tYXBDb29yZHMpLmdlb21ldHJ5XG4gICAgICAgICAgICAuY29vcmRpbmF0ZXNcbiAgICAgICAgOiBsYXN0UG9pbnRlck1vdmVFdmVudC5tYXBDb29yZHM7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLnRoaXMuX2N1cnJlbnRUb29sdGlwcyxcbiAgICAgICAge1xuICAgICAgICAgIHBvc2l0aW9uOiB0b29sdGlwUG9zaXRpb24sXG4gICAgICAgICAgdGV4dDogdGhpcy5fZm9ybWF0VG9vbHRpcCh0aGlzLl9jdXJyZW50RGlzdGFuY2UgKyBkaXN0YW5jZSwgbW9kZUNvbmZpZyksXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VG9vbHRpcHM7XG4gIH1cbn1cbiJdfQ==