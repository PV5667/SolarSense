"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.SELECTION_TYPE = void 0;

var _core = require("@deck.gl/core");

var _layers = require("@deck.gl/layers");

var _helpers = require("@turf/helpers");

var _buffer = _interopRequireDefault(require("@turf/buffer"));

var _difference = _interopRequireDefault(require("@turf/difference"));

var _editModes = require("@nebula.gl/edit-modes");

var _editableGeojsonLayer = _interopRequireDefault(require("./editable-geojson-layer"));

var _MODE_MAP;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SELECTION_TYPE = {
  NONE: null,
  RECTANGLE: 'rectangle',
  POLYGON: 'polygon'
};
exports.SELECTION_TYPE = SELECTION_TYPE;
var MODE_MAP = (_MODE_MAP = {}, _defineProperty(_MODE_MAP, SELECTION_TYPE.RECTANGLE, _editModes.DrawRectangleMode), _defineProperty(_MODE_MAP, SELECTION_TYPE.POLYGON, _editModes.DrawPolygonMode), _MODE_MAP);

var MODE_CONFIG_MAP = _defineProperty({}, SELECTION_TYPE.RECTANGLE, {
  dragToDraw: true
});

var defaultProps = {
  selectionType: SELECTION_TYPE.RECTANGLE,
  layerIds: [],
  onSelect: function onSelect() {}
};
var EMPTY_DATA = {
  type: 'FeatureCollection',
  features: []
};
var EXPANSION_KM = 50;
var LAYER_ID_GEOJSON = 'selection-geojson';
var LAYER_ID_BLOCKER = 'selection-blocker';
var PASS_THROUGH_PROPS = ['lineWidthScale', 'lineWidthMinPixels', 'lineWidthMaxPixels', 'lineWidthUnits', 'lineJointRounded', 'lineCapRounded', 'lineMiterLimit', 'pointRadiusScale', 'pointRadiusMinPixels', 'pointRadiusMaxPixels', 'lineDashJustified', 'getLineColor', 'getFillColor', 'getRadius', 'getLineWidth', 'getLineDashArray', 'getTentativeLineDashArray', 'getTentativeLineColor', 'getTentativeFillColor', 'getTentativeLineWidth'];

var SelectionLayer = /*#__PURE__*/function (_CompositeLayer) {
  _inherits(SelectionLayer, _CompositeLayer);

  var _super = _createSuper(SelectionLayer);

  function SelectionLayer() {
    _classCallCheck(this, SelectionLayer);

    return _super.apply(this, arguments);
  }

  _createClass(SelectionLayer, [{
    key: "_selectRectangleObjects",
    value: function _selectRectangleObjects(coordinates) {
      var _this$props = this.props,
          layerIds = _this$props.layerIds,
          onSelect = _this$props.onSelect; // @ts-ignore

      var _this$context$viewpor = this.context.viewport.project(coordinates[0][0]),
          _this$context$viewpor2 = _slicedToArray(_this$context$viewpor, 2),
          x1 = _this$context$viewpor2[0],
          y1 = _this$context$viewpor2[1]; // @ts-ignore


      var _this$context$viewpor3 = this.context.viewport.project(coordinates[0][2]),
          _this$context$viewpor4 = _slicedToArray(_this$context$viewpor3, 2),
          x2 = _this$context$viewpor4[0],
          y2 = _this$context$viewpor4[1]; // @ts-ignore


      var pickingInfos = this.context.deck.pickObjects({
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1),
        layerIds: layerIds
      });
      onSelect({
        pickingInfos: pickingInfos
      });
    }
  }, {
    key: "_selectPolygonObjects",
    value: function _selectPolygonObjects(coordinates) {
      var _this = this;

      var _this$props2 = this.props,
          layerIds = _this$props2.layerIds,
          onSelect = _this$props2.onSelect; // @ts-ignore

      var mousePoints = coordinates[0].map(function (c) {
        return _this.context.viewport.project(c);
      });
      var allX = mousePoints.map(function (mousePoint) {
        return mousePoint[0];
      });
      var allY = mousePoints.map(function (mousePoint) {
        return mousePoint[1];
      });
      var x = Math.min.apply(Math, _toConsumableArray(allX));
      var y = Math.min.apply(Math, _toConsumableArray(allY));
      var maxX = Math.max.apply(Math, _toConsumableArray(allX));
      var maxY = Math.max.apply(Math, _toConsumableArray(allY)); // Use a polygon to hide the outside, because pickObjects()
      // does not support polygons

      var landPointsPoly = (0, _helpers.polygon)(coordinates);
      var bigBuffer = (0, _buffer["default"])(landPointsPoly, EXPANSION_KM);
      var bigPolygon;

      try {
        // turfDifference throws an exception if the polygon
        // intersects with itself (TODO: check if true in all versions)
        bigPolygon = (0, _difference["default"])(bigBuffer, landPointsPoly);
      } catch (e) {
        // invalid selection polygon
        console.log('turfDifference() error', e); // eslint-disable-line

        return;
      }

      this.setState({
        pendingPolygonSelection: {
          bigPolygon: bigPolygon
        }
      });
      var blockerId = "".concat(this.props.id, "-").concat(LAYER_ID_BLOCKER); // HACK, find a better way

      setTimeout(function () {
        // @ts-ignore
        var pickingInfos = _this.context.deck.pickObjects({
          x: x,
          y: y,
          width: maxX - x,
          height: maxY - y,
          layerIds: [blockerId].concat(_toConsumableArray(layerIds))
        });

        onSelect({
          pickingInfos: pickingInfos.filter(function (item) {
            return item.layer.id !== _this.props.id;
          })
        });
      }, 250);
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _this2 = this;

      var pendingPolygonSelection = this.state.pendingPolygonSelection;
      var mode = MODE_MAP[this.props.selectionType] || _editModes.ViewMode;
      var modeConfig = MODE_CONFIG_MAP[this.props.selectionType];
      var inheritedProps = {};
      PASS_THROUGH_PROPS.forEach(function (p) {
        if (_this2.props[p] !== undefined) inheritedProps[p] = _this2.props[p];
      });
      var layers = [new _editableGeojsonLayer["default"](this.getSubLayerProps(_objectSpread({
        id: LAYER_ID_GEOJSON,
        pickable: true,
        mode: mode,
        modeConfig: modeConfig,
        selectedFeatureIndexes: [],
        data: EMPTY_DATA,
        onEdit: function onEdit(_ref) {
          var updatedData = _ref.updatedData,
              editType = _ref.editType;

          if (editType === 'addFeature') {
            var coordinates = updatedData.features[0].geometry.coordinates;

            if (_this2.props.selectionType === SELECTION_TYPE.RECTANGLE) {
              _this2._selectRectangleObjects(coordinates);
            } else if (_this2.props.selectionType === SELECTION_TYPE.POLYGON) {
              _this2._selectPolygonObjects(coordinates);
            }
          }
        }
      }, inheritedProps)))];

      if (pendingPolygonSelection) {
        var bigPolygon = pendingPolygonSelection.bigPolygon;
        layers.push( // @ts-ignore
        new _layers.PolygonLayer( // @ts-ignore
        this.getSubLayerProps({
          id: LAYER_ID_BLOCKER,
          pickable: true,
          stroked: false,
          opacity: 1.0,
          data: [bigPolygon],
          getLineColor: function getLineColor(obj) {
            return [0, 0, 0, 1];
          },
          getFillColor: function getFillColor(obj) {
            return [0, 0, 0, 1];
          },
          getPolygon: function getPolygon(o) {
            return o.geometry.coordinates;
          }
        })));
      }

      return layers;
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref2) {
      var _ref2$changeFlags = _ref2.changeFlags,
          stateChanged = _ref2$changeFlags.stateChanged,
          propsOrDataChanged = _ref2$changeFlags.propsOrDataChanged;
      return stateChanged || propsOrDataChanged;
    }
  }]);

  return SelectionLayer;
}(_core.CompositeLayer);

exports["default"] = SelectionLayer;

_defineProperty(SelectionLayer, "layerName", 'SelectionLayer');

_defineProperty(SelectionLayer, "defaultProps", defaultProps);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvc2VsZWN0aW9uLWxheWVyLnRzIl0sIm5hbWVzIjpbIlNFTEVDVElPTl9UWVBFIiwiTk9ORSIsIlJFQ1RBTkdMRSIsIlBPTFlHT04iLCJNT0RFX01BUCIsIkRyYXdSZWN0YW5nbGVNb2RlIiwiRHJhd1BvbHlnb25Nb2RlIiwiTU9ERV9DT05GSUdfTUFQIiwiZHJhZ1RvRHJhdyIsImRlZmF1bHRQcm9wcyIsInNlbGVjdGlvblR5cGUiLCJsYXllcklkcyIsIm9uU2VsZWN0IiwiRU1QVFlfREFUQSIsInR5cGUiLCJmZWF0dXJlcyIsIkVYUEFOU0lPTl9LTSIsIkxBWUVSX0lEX0dFT0pTT04iLCJMQVlFUl9JRF9CTE9DS0VSIiwiUEFTU19USFJPVUdIX1BST1BTIiwiU2VsZWN0aW9uTGF5ZXIiLCJjb29yZGluYXRlcyIsInByb3BzIiwiY29udGV4dCIsInZpZXdwb3J0IiwicHJvamVjdCIsIngxIiwieTEiLCJ4MiIsInkyIiwicGlja2luZ0luZm9zIiwiZGVjayIsInBpY2tPYmplY3RzIiwieCIsIk1hdGgiLCJtaW4iLCJ5Iiwid2lkdGgiLCJhYnMiLCJoZWlnaHQiLCJtb3VzZVBvaW50cyIsIm1hcCIsImMiLCJhbGxYIiwibW91c2VQb2ludCIsImFsbFkiLCJtYXhYIiwibWF4IiwibWF4WSIsImxhbmRQb2ludHNQb2x5IiwiYmlnQnVmZmVyIiwiYmlnUG9seWdvbiIsImUiLCJjb25zb2xlIiwibG9nIiwic2V0U3RhdGUiLCJwZW5kaW5nUG9seWdvblNlbGVjdGlvbiIsImJsb2NrZXJJZCIsImlkIiwic2V0VGltZW91dCIsImZpbHRlciIsIml0ZW0iLCJsYXllciIsInN0YXRlIiwibW9kZSIsIlZpZXdNb2RlIiwibW9kZUNvbmZpZyIsImluaGVyaXRlZFByb3BzIiwiZm9yRWFjaCIsInAiLCJ1bmRlZmluZWQiLCJsYXllcnMiLCJFZGl0YWJsZUdlb0pzb25MYXllciIsImdldFN1YkxheWVyUHJvcHMiLCJwaWNrYWJsZSIsInNlbGVjdGVkRmVhdHVyZUluZGV4ZXMiLCJkYXRhIiwib25FZGl0IiwidXBkYXRlZERhdGEiLCJlZGl0VHlwZSIsImdlb21ldHJ5IiwiX3NlbGVjdFJlY3RhbmdsZU9iamVjdHMiLCJfc2VsZWN0UG9seWdvbk9iamVjdHMiLCJwdXNoIiwiUG9seWdvbkxheWVyIiwic3Ryb2tlZCIsIm9wYWNpdHkiLCJnZXRMaW5lQ29sb3IiLCJvYmoiLCJnZXRGaWxsQ29sb3IiLCJnZXRQb2x5Z29uIiwibyIsImNoYW5nZUZsYWdzIiwic3RhdGVDaGFuZ2VkIiwicHJvcHNPckRhdGFDaGFuZ2VkIiwiQ29tcG9zaXRlTGF5ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRU8sSUFBTUEsY0FBYyxHQUFHO0FBQzVCQyxFQUFBQSxJQUFJLEVBQUUsSUFEc0I7QUFFNUJDLEVBQUFBLFNBQVMsRUFBRSxXQUZpQjtBQUc1QkMsRUFBQUEsT0FBTyxFQUFFO0FBSG1CLENBQXZCOztBQU1QLElBQU1DLFFBQVEsK0NBQ1hKLGNBQWMsQ0FBQ0UsU0FESixFQUNnQkcsNEJBRGhCLDhCQUVYTCxjQUFjLENBQUNHLE9BRkosRUFFY0csMEJBRmQsYUFBZDs7QUFLQSxJQUFNQyxlQUFlLHVCQUNsQlAsY0FBYyxDQUFDRSxTQURHLEVBQ1M7QUFBRU0sRUFBQUEsVUFBVSxFQUFFO0FBQWQsQ0FEVCxDQUFyQjs7QUFVQSxJQUFNQyxZQUFpQyxHQUFHO0FBQ3hDQyxFQUFBQSxhQUFhLEVBQUVWLGNBQWMsQ0FBQ0UsU0FEVTtBQUV4Q1MsRUFBQUEsUUFBUSxFQUFFLEVBRjhCO0FBR3hDQyxFQUFBQSxRQUFRLEVBQUUsb0JBQU0sQ0FBRTtBQUhzQixDQUExQztBQU1BLElBQU1DLFVBQVUsR0FBRztBQUNqQkMsRUFBQUEsSUFBSSxFQUFFLG1CQURXO0FBRWpCQyxFQUFBQSxRQUFRLEVBQUU7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QUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBVDtBQUFBLFdBTk07QUFPcEJDLFVBQUFBLFlBQVksRUFBRSxzQkFBQ0QsR0FBRDtBQUFBLG1CQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFUO0FBQUEsV0FQTTtBQVFwQkUsVUFBQUEsVUFBVSxFQUFFLG9CQUFDQyxDQUFEO0FBQUEsbUJBQU9BLENBQUMsQ0FBQ1gsUUFBRixDQUFXM0QsV0FBbEI7QUFBQTtBQVJRLFNBQXRCLENBRkYsQ0FGRjtBQWdCRDs7QUFFRCxhQUFPa0QsTUFBUDtBQUNEOzs7NkNBRTZGO0FBQUEsb0NBQTFFcUIsV0FBMEU7QUFBQSxVQUEzREMsWUFBMkQscUJBQTNEQSxZQUEyRDtBQUFBLFVBQTdDQyxrQkFBNkMscUJBQTdDQSxrQkFBNkM7QUFDNUYsYUFBT0QsWUFBWSxJQUFJQyxrQkFBdkI7QUFDRDs7OztFQXZJT0Msb0I7Ozs7Z0JBSFczRSxjLGVBSUEsZ0I7O2dCQUpBQSxjLGtCQUtHWCxZIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmltcG9ydCB7IENvbXBvc2l0ZUxheWVyIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgeyBQb2x5Z29uTGF5ZXIgfSBmcm9tICdAZGVjay5nbC9sYXllcnMnO1xuaW1wb3J0IHsgQ29tcG9zaXRlTGF5ZXJQcm9wcyB9IGZyb20gJ0BkZWNrLmdsL2NvcmUvbGliL2NvbXBvc2l0ZS1sYXllcic7XG5pbXBvcnQgeyBwb2x5Z29uIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgdHVyZkJ1ZmZlciBmcm9tICdAdHVyZi9idWZmZXInO1xuaW1wb3J0IHR1cmZEaWZmZXJlbmNlIGZyb20gJ0B0dXJmL2RpZmZlcmVuY2UnO1xuaW1wb3J0IHsgRHJhd1JlY3RhbmdsZU1vZGUsIERyYXdQb2x5Z29uTW9kZSwgVmlld01vZGUgfSBmcm9tICdAbmVidWxhLmdsL2VkaXQtbW9kZXMnO1xuXG5pbXBvcnQgRWRpdGFibGVHZW9Kc29uTGF5ZXIgZnJvbSAnLi9lZGl0YWJsZS1nZW9qc29uLWxheWVyJztcblxuZXhwb3J0IGNvbnN0IFNFTEVDVElPTl9UWVBFID0ge1xuICBOT05FOiBudWxsLFxuICBSRUNUQU5HTEU6ICdyZWN0YW5nbGUnLFxuICBQT0xZR09OOiAncG9seWdvbicsXG59O1xuXG5jb25zdCBNT0RFX01BUCA9IHtcbiAgW1NFTEVDVElPTl9UWVBFLlJFQ1RBTkdMRV06IERyYXdSZWN0YW5nbGVNb2RlLFxuICBbU0VMRUNUSU9OX1RZUEUuUE9MWUdPTl06IERyYXdQb2x5Z29uTW9kZSxcbn07XG5cbmNvbnN0IE1PREVfQ09ORklHX01BUCA9IHtcbiAgW1NFTEVDVElPTl9UWVBFLlJFQ1RBTkdMRV06IHsgZHJhZ1RvRHJhdzogdHJ1ZSB9LFxufTtcblxuaW50ZXJmYWNlIFNlbGVjdGlvbkxheWVyUHJvcHMgZXh0ZW5kcyBDb21wb3NpdGVMYXllclByb3BzPGFueT4ge1xuICBsYXllcklkczogYW55W107XG4gIG9uU2VsZWN0OiAoaW5mbzogYW55KSA9PiBhbnk7XG4gIHNlbGVjdGlvblR5cGU6IHN0cmluZyB8IG51bGw7XG59XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogU2VsZWN0aW9uTGF5ZXJQcm9wcyA9IHtcbiAgc2VsZWN0aW9uVHlwZTogU0VMRUNUSU9OX1RZUEUuUkVDVEFOR0xFLFxuICBsYXllcklkczogW10sXG4gIG9uU2VsZWN0OiAoKSA9PiB7fSxcbn07XG5cbmNvbnN0IEVNUFRZX0RBVEEgPSB7XG4gIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gIGZlYXR1cmVzOiBbXSxcbn07XG5cbmNvbnN0IEVYUEFOU0lPTl9LTSA9IDUwO1xuY29uc3QgTEFZRVJfSURfR0VPSlNPTiA9ICdzZWxlY3Rpb24tZ2VvanNvbic7XG5jb25zdCBMQVlFUl9JRF9CTE9DS0VSID0gJ3NlbGVjdGlvbi1ibG9ja2VyJztcblxuY29uc3QgUEFTU19USFJPVUdIX1BST1BTID0gW1xuICAnbGluZVdpZHRoU2NhbGUnLFxuICAnbGluZVdpZHRoTWluUGl4ZWxzJyxcbiAgJ2xpbmVXaWR0aE1heFBpeGVscycsXG4gICdsaW5lV2lkdGhVbml0cycsXG4gICdsaW5lSm9pbnRSb3VuZGVkJyxcbiAgJ2xpbmVDYXBSb3VuZGVkJyxcbiAgJ2xpbmVNaXRlckxpbWl0JyxcbiAgJ3BvaW50UmFkaXVzU2NhbGUnLFxuICAncG9pbnRSYWRpdXNNaW5QaXhlbHMnLFxuICAncG9pbnRSYWRpdXNNYXhQaXhlbHMnLFxuICAnbGluZURhc2hKdXN0aWZpZWQnLFxuICAnZ2V0TGluZUNvbG9yJyxcbiAgJ2dldEZpbGxDb2xvcicsXG4gICdnZXRSYWRpdXMnLFxuICAnZ2V0TGluZVdpZHRoJyxcbiAgJ2dldExpbmVEYXNoQXJyYXknLFxuICAnZ2V0VGVudGF0aXZlTGluZURhc2hBcnJheScsXG4gICdnZXRUZW50YXRpdmVMaW5lQ29sb3InLFxuICAnZ2V0VGVudGF0aXZlRmlsbENvbG9yJyxcbiAgJ2dldFRlbnRhdGl2ZUxpbmVXaWR0aCcsXG5dO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0aW9uTGF5ZXI8XG4gIEQsXG4gIFAgZXh0ZW5kcyBTZWxlY3Rpb25MYXllclByb3BzID0gU2VsZWN0aW9uTGF5ZXJQcm9wc1xuPiBleHRlbmRzIENvbXBvc2l0ZUxheWVyPEQsIFA+IHtcbiAgc3RhdGljIGxheWVyTmFtZSA9ICdTZWxlY3Rpb25MYXllcic7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbiAgX3NlbGVjdFJlY3RhbmdsZU9iamVjdHMoY29vcmRpbmF0ZXM6IGFueSkge1xuICAgIGNvbnN0IHsgbGF5ZXJJZHMsIG9uU2VsZWN0IH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBbeDEsIHkxXSA9IHRoaXMuY29udGV4dC52aWV3cG9ydC5wcm9qZWN0KGNvb3JkaW5hdGVzWzBdWzBdKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmNvbnRleHQudmlld3BvcnQucHJvamVjdChjb29yZGluYXRlc1swXVsyXSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHBpY2tpbmdJbmZvcyA9IHRoaXMuY29udGV4dC5kZWNrLnBpY2tPYmplY3RzKHtcbiAgICAgIHg6IE1hdGgubWluKHgxLCB4MiksXG4gICAgICB5OiBNYXRoLm1pbih5MSwgeTIpLFxuICAgICAgd2lkdGg6IE1hdGguYWJzKHgyIC0geDEpLFxuICAgICAgaGVpZ2h0OiBNYXRoLmFicyh5MiAtIHkxKSxcbiAgICAgIGxheWVySWRzLFxuICAgIH0pO1xuXG4gICAgb25TZWxlY3QoeyBwaWNraW5nSW5mb3MgfSk7XG4gIH1cblxuICBfc2VsZWN0UG9seWdvbk9iamVjdHMoY29vcmRpbmF0ZXM6IGFueSkge1xuICAgIGNvbnN0IHsgbGF5ZXJJZHMsIG9uU2VsZWN0IH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBtb3VzZVBvaW50cyA9IGNvb3JkaW5hdGVzWzBdLm1hcCgoYykgPT4gdGhpcy5jb250ZXh0LnZpZXdwb3J0LnByb2plY3QoYykpO1xuXG4gICAgY29uc3QgYWxsWCA9IG1vdXNlUG9pbnRzLm1hcCgobW91c2VQb2ludCkgPT4gbW91c2VQb2ludFswXSk7XG4gICAgY29uc3QgYWxsWSA9IG1vdXNlUG9pbnRzLm1hcCgobW91c2VQb2ludCkgPT4gbW91c2VQb2ludFsxXSk7XG4gICAgY29uc3QgeCA9IE1hdGgubWluKC4uLmFsbFgpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1pbiguLi5hbGxZKTtcbiAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgoLi4uYWxsWCk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KC4uLmFsbFkpO1xuXG4gICAgLy8gVXNlIGEgcG9seWdvbiB0byBoaWRlIHRoZSBvdXRzaWRlLCBiZWNhdXNlIHBpY2tPYmplY3RzKClcbiAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHBvbHlnb25zXG4gICAgY29uc3QgbGFuZFBvaW50c1BvbHkgPSBwb2x5Z29uKGNvb3JkaW5hdGVzKTtcbiAgICBjb25zdCBiaWdCdWZmZXIgPSB0dXJmQnVmZmVyKGxhbmRQb2ludHNQb2x5LCBFWFBBTlNJT05fS00pO1xuICAgIGxldCBiaWdQb2x5Z29uO1xuICAgIHRyeSB7XG4gICAgICAvLyB0dXJmRGlmZmVyZW5jZSB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBwb2x5Z29uXG4gICAgICAvLyBpbnRlcnNlY3RzIHdpdGggaXRzZWxmIChUT0RPOiBjaGVjayBpZiB0cnVlIGluIGFsbCB2ZXJzaW9ucylcbiAgICAgIGJpZ1BvbHlnb24gPSB0dXJmRGlmZmVyZW5jZShiaWdCdWZmZXIsIGxhbmRQb2ludHNQb2x5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpbnZhbGlkIHNlbGVjdGlvbiBwb2x5Z29uXG4gICAgICBjb25zb2xlLmxvZygndHVyZkRpZmZlcmVuY2UoKSBlcnJvcicsIGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwZW5kaW5nUG9seWdvblNlbGVjdGlvbjoge1xuICAgICAgICBiaWdQb2x5Z29uLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJsb2NrZXJJZCA9IGAke3RoaXMucHJvcHMuaWR9LSR7TEFZRVJfSURfQkxPQ0tFUn1gO1xuXG4gICAgLy8gSEFDSywgZmluZCBhIGJldHRlciB3YXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHBpY2tpbmdJbmZvcyA9IHRoaXMuY29udGV4dC5kZWNrLnBpY2tPYmplY3RzKHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IG1heFggLSB4LFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSB5LFxuICAgICAgICBsYXllcklkczogW2Jsb2NrZXJJZCwgLi4ubGF5ZXJJZHNdLFxuICAgICAgfSk7XG5cbiAgICAgIG9uU2VsZWN0KHtcbiAgICAgICAgcGlja2luZ0luZm9zOiBwaWNraW5nSW5mb3MuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmxheWVyLmlkICE9PSB0aGlzLnByb3BzLmlkKSxcbiAgICAgIH0pO1xuICAgIH0sIDI1MCk7XG4gIH1cblxuICByZW5kZXJMYXllcnMoKSB7XG4gICAgY29uc3QgeyBwZW5kaW5nUG9seWdvblNlbGVjdGlvbiB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IG1vZGUgPSBNT0RFX01BUFt0aGlzLnByb3BzLnNlbGVjdGlvblR5cGVdIHx8IFZpZXdNb2RlO1xuICAgIGNvbnN0IG1vZGVDb25maWcgPSBNT0RFX0NPTkZJR19NQVBbdGhpcy5wcm9wcy5zZWxlY3Rpb25UeXBlXTtcblxuICAgIGNvbnN0IGluaGVyaXRlZFByb3BzID0ge307XG4gICAgUEFTU19USFJPVUdIX1BST1BTLmZvckVhY2goKHApID0+IHtcbiAgICAgIGlmICh0aGlzLnByb3BzW3BdICE9PSB1bmRlZmluZWQpIGluaGVyaXRlZFByb3BzW3BdID0gdGhpcy5wcm9wc1twXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxheWVycyA9IFtcbiAgICAgIG5ldyBFZGl0YWJsZUdlb0pzb25MYXllcihcbiAgICAgICAgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgICBpZDogTEFZRVJfSURfR0VPSlNPTixcbiAgICAgICAgICBwaWNrYWJsZTogdHJ1ZSxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIG1vZGVDb25maWcsXG4gICAgICAgICAgc2VsZWN0ZWRGZWF0dXJlSW5kZXhlczogW10sXG4gICAgICAgICAgZGF0YTogRU1QVFlfREFUQSxcbiAgICAgICAgICBvbkVkaXQ6ICh7IHVwZGF0ZWREYXRhLCBlZGl0VHlwZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZWRpdFR5cGUgPT09ICdhZGRGZWF0dXJlJykge1xuICAgICAgICAgICAgICBjb25zdCB7IGNvb3JkaW5hdGVzIH0gPSB1cGRhdGVkRGF0YS5mZWF0dXJlc1swXS5nZW9tZXRyeTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3Rpb25UeXBlID09PSBTRUxFQ1RJT05fVFlQRS5SRUNUQU5HTEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RSZWN0YW5nbGVPYmplY3RzKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnNlbGVjdGlvblR5cGUgPT09IFNFTEVDVElPTl9UWVBFLlBPTFlHT04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RQb2x5Z29uT2JqZWN0cyhjb29yZGluYXRlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLmluaGVyaXRlZFByb3BzLFxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICBdO1xuXG4gICAgaWYgKHBlbmRpbmdQb2x5Z29uU2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCB7IGJpZ1BvbHlnb24gfSA9IHBlbmRpbmdQb2x5Z29uU2VsZWN0aW9uO1xuICAgICAgbGF5ZXJzLnB1c2goXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbmV3IFBvbHlnb25MYXllcihcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgICAgIGlkOiBMQVlFUl9JRF9CTE9DS0VSLFxuICAgICAgICAgICAgcGlja2FibGU6IHRydWUsXG4gICAgICAgICAgICBzdHJva2VkOiBmYWxzZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgICAgIGRhdGE6IFtiaWdQb2x5Z29uXSxcbiAgICAgICAgICAgIGdldExpbmVDb2xvcjogKG9iaikgPT4gWzAsIDAsIDAsIDFdLFxuICAgICAgICAgICAgZ2V0RmlsbENvbG9yOiAob2JqKSA9PiBbMCwgMCwgMCwgMV0sXG4gICAgICAgICAgICBnZXRQb2x5Z29uOiAobykgPT4gby5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICBzaG91bGRVcGRhdGVTdGF0ZSh7IGNoYW5nZUZsYWdzOiB7IHN0YXRlQ2hhbmdlZCwgcHJvcHNPckRhdGFDaGFuZ2VkIH0gfTogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHJldHVybiBzdGF0ZUNoYW5nZWQgfHwgcHJvcHNPckRhdGFDaGFuZ2VkO1xuICB9XG59XG4iXX0=