import {
  azimuthalEquidistant_default,
  init_d3_geo,
  require_geojson_rbush,
  require_rbush_min
} from "./chunk-EXNR5W7M.js";
import {
  require_earcut
} from "./chunk-GED75EK3.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty2.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/tinyqueue/index.js
var tinyqueue_exports = {};
__export(tinyqueue_exports, {
  default: () => TinyQueue
});
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var TinyQueue;
var init_tinyqueue = __esm({
  "node_modules/tinyqueue/index.js"() {
    TinyQueue = class {
      constructor(data = [], compare10 = defaultCompare) {
        this.data = data;
        this.length = this.data.length;
        this.compare = compare10;
        if (this.length > 0) {
          for (let i = (this.length >> 1) - 1; i >= 0; i--)
            this._down(i);
        }
      }
      push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
      }
      pop() {
        if (this.length === 0)
          return void 0;
        const top = this.data[0];
        const bottom = this.data.pop();
        this.length--;
        if (this.length > 0) {
          this.data[0] = bottom;
          this._down(0);
        }
        return top;
      }
      peek() {
        return this.data[0];
      }
      _up(pos) {
        const { data, compare: compare10 } = this;
        const item = data[pos];
        while (pos > 0) {
          const parent = pos - 1 >> 1;
          const current = data[parent];
          if (compare10(item, current) >= 0)
            break;
          data[pos] = current;
          pos = parent;
        }
        data[pos] = item;
      }
      _down(pos) {
        const { data, compare: compare10 } = this;
        const halfLength = this.length >> 1;
        const item = data[pos];
        while (pos < halfLength) {
          let left = (pos << 1) + 1;
          let best = data[left];
          const right = left + 1;
          if (right < this.length && compare10(data[right], best) < 0) {
            left = right;
            best = data[right];
          }
          if (compare10(best, item) >= 0)
            break;
          data[pos] = best;
          pos = left;
        }
        data[pos] = item;
      }
    };
  }
});

// node_modules/point-in-polygon/flat.js
var require_flat = __commonJS({
  "node_modules/point-in-polygon/flat.js"(exports, module) {
    module.exports = function pointInPolygonFlat(point4, vs, start, end) {
      var x2 = point4[0], y2 = point4[1];
      var inside = false;
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = vs.length;
      var len = (end - start) / 2;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
        var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
        var intersect4 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
        if (intersect4)
          inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/nested.js
var require_nested = __commonJS({
  "node_modules/point-in-polygon/nested.js"(exports, module) {
    module.exports = function pointInPolygonNested(point4, vs, start, end) {
      var x2 = point4[0], y2 = point4[1];
      var inside = false;
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = vs.length;
      var len = end - start;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i + start][0], yi = vs[i + start][1];
        var xj = vs[j + start][0], yj = vs[j + start][1];
        var intersect4 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
        if (intersect4)
          inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/index.js
var require_point_in_polygon = __commonJS({
  "node_modules/point-in-polygon/index.js"(exports, module) {
    var pointInPolygonFlat = require_flat();
    var pointInPolygonNested = require_nested();
    module.exports = function pointInPolygon(point4, vs, start, end) {
      if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point4, vs, start, end);
      } else {
        return pointInPolygonFlat(point4, vs, start, end);
      }
    };
    module.exports.nested = pointInPolygonNested;
    module.exports.flat = pointInPolygonFlat;
  }
});

// node_modules/robust-predicates/umd/orient2d.min.js
var require_orient2d_min = __commonJS({
  "node_modules/robust-predicates/umd/orient2d.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
    }(exports, function(t) {
      "use strict";
      const e = 134217729, n = 33306690738754706e-32;
      function r(t2, e2, n2, r2, o2) {
        let f2, i2, u2, c2, s2 = e2[0], a2 = r2[0], d2 = 0, l2 = 0;
        a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e2[++d2]) : (f2 = a2, a2 = r2[++l2]);
        let p = 0;
        if (d2 < t2 && l2 < n2)
          for (a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e2[++d2]) : (u2 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2); d2 < t2 && l2 < n2; )
            a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e2[++d2]) : (u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2);
        for (; d2 < t2; )
          u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e2[++d2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
        for (; l2 < n2; )
          u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
        return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
      }
      function o(t2) {
        return new Float64Array(t2);
      }
      const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
      t.orient2d = function(t2, o2, p, b, y2, h) {
        const M = (o2 - h) * (p - y2), x2 = (t2 - y2) * (b - h), j = M - x2;
        if (0 === M || 0 === x2 || M > 0 != x2 > 0)
          return j;
        const m = Math.abs(M + x2);
        return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y3, h2) {
          let M2, x3, j2, m2, _, v, w, A, F, O, P, g, k, q, z, B2, C, D;
          const E = t3 - b2, G = f2 - b2, H = o3 - y3, I = p2 - y3;
          _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
          let J = function(t4, e2) {
            let n2 = e2[0];
            for (let r2 = 1; r2 < t4; r2++)
              n2 += e2[r2];
            return n2;
          }(4, c), K = i * h2;
          if (J >= K || -J >= K)
            return J;
          if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m2 = p2 - (I + (_ = p2 - I)) + (_ - y3), 0 === M2 && 0 === x3 && 0 === j2 && 0 === m2)
            return J;
          if (K = u * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x3)) >= K || -J >= K)
            return J;
          _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = x3 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
          const L = r(4, c, 4, l, s);
          _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
          const N = r(L, s, 4, l, a);
          _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = x3 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
          const Q = r(N, a, 4, l, d);
          return d[Q - 1];
        }(t2, o2, p, b, y2, h, m);
      }, t.orient2dfast = function(t2, e2, n2, r2, o2, f2) {
        return (e2 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
      }, Object.defineProperty(t, "__esModule", { value: true });
    });
  }
});

// node_modules/concaveman/index.js
var require_concaveman = __commonJS({
  "node_modules/concaveman/index.js"(exports, module) {
    "use strict";
    var RBush = require_rbush_min();
    var Queue = (init_tinyqueue(), __toCommonJS(tinyqueue_exports));
    var pointInPolygon = require_point_in_polygon();
    var orient = require_orient2d_min().orient2d;
    if (Queue.default) {
      Queue = Queue.default;
    }
    module.exports = concaveman2;
    module.exports.default = concaveman2;
    function concaveman2(points2, concavity, lengthThreshold) {
      concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
      lengthThreshold = lengthThreshold || 0;
      var hull = fastConvexHull(points2);
      var tree = new RBush(16);
      tree.toBBox = function(a2) {
        return {
          minX: a2[0],
          minY: a2[1],
          maxX: a2[0],
          maxY: a2[1]
        };
      };
      tree.compareMinX = function(a2, b2) {
        return a2[0] - b2[0];
      };
      tree.compareMinY = function(a2, b2) {
        return a2[1] - b2[1];
      };
      tree.load(points2);
      var queue = [];
      for (var i = 0, last; i < hull.length; i++) {
        var p = hull[i];
        tree.remove(p);
        last = insertNode(p, last);
        queue.push(last);
      }
      var segTree = new RBush(16);
      for (i = 0; i < queue.length; i++)
        segTree.insert(updateBBox(queue[i]));
      var sqConcavity = concavity * concavity;
      var sqLenThreshold = lengthThreshold * lengthThreshold;
      while (queue.length) {
        var node = queue.shift();
        var a = node.p;
        var b = node.next.p;
        var sqLen = getSqDist2(a, b);
        if (sqLen < sqLenThreshold)
          continue;
        var maxSqLen = sqLen / sqConcavity;
        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
        if (p && Math.min(getSqDist2(p, a), getSqDist2(p, b)) <= maxSqLen) {
          queue.push(node);
          queue.push(insertNode(p, node));
          tree.remove(p);
          segTree.remove(node);
          segTree.insert(updateBBox(node));
          segTree.insert(updateBBox(node.next));
        }
      }
      node = last;
      var concave2 = [];
      do {
        concave2.push(node.p);
        node = node.next;
      } while (node !== last);
      concave2.push(node.p);
      return concave2;
    }
    function findCandidate(tree, a, b, c, d, maxDist, segTree) {
      var queue = new Queue([], compareDist);
      var node = tree.data;
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
          if (dist > maxDist)
            continue;
          queue.push({
            node: child,
            dist
          });
        }
        while (queue.length && !queue.peek().node.children) {
          var item = queue.pop();
          var p = item.node;
          var d0 = sqSegDist(p, a, b);
          var d1 = sqSegDist(p, c, d);
          if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree))
            return p;
        }
        node = queue.pop();
        if (node)
          node = node.node;
      }
      return null;
    }
    function compareDist(a, b) {
      return a.dist - b.dist;
    }
    function sqSegBoxDist(a, b, bbox3) {
      if (inside(a, bbox3) || inside(b, bbox3))
        return 0;
      var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.maxX, bbox3.minY);
      if (d1 === 0)
        return 0;
      var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.minX, bbox3.maxY);
      if (d2 === 0)
        return 0;
      var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.maxX, bbox3.minY, bbox3.maxX, bbox3.maxY);
      if (d3 === 0)
        return 0;
      var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.maxY, bbox3.maxX, bbox3.maxY);
      if (d4 === 0)
        return 0;
      return Math.min(d1, d2, d3, d4);
    }
    function inside(a, bbox3) {
      return a[0] >= bbox3.minX && a[0] <= bbox3.maxX && a[1] >= bbox3.minY && a[1] <= bbox3.maxY;
    }
    function noIntersections(a, b, segTree) {
      var minX2 = Math.min(a[0], b[0]);
      var minY2 = Math.min(a[1], b[1]);
      var maxX2 = Math.max(a[0], b[0]);
      var maxY2 = Math.max(a[1], b[1]);
      var edges2 = segTree.search({ minX: minX2, minY: minY2, maxX: maxX2, maxY: maxY2 });
      for (var i = 0; i < edges2.length; i++) {
        if (intersects7(edges2[i].p, edges2[i].next.p, a, b))
          return false;
      }
      return true;
    }
    function cross(p1, p2, p3) {
      return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }
    function intersects7(p1, q1, p2, q2) {
      return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
    }
    function updateBBox(node) {
      var p1 = node.p;
      var p2 = node.next.p;
      node.minX = Math.min(p1[0], p2[0]);
      node.minY = Math.min(p1[1], p2[1]);
      node.maxX = Math.max(p1[0], p2[0]);
      node.maxY = Math.max(p1[1], p2[1]);
      return node;
    }
    function fastConvexHull(points2) {
      var left = points2[0];
      var top = points2[0];
      var right = points2[0];
      var bottom = points2[0];
      for (var i = 0; i < points2.length; i++) {
        var p = points2[i];
        if (p[0] < left[0])
          left = p;
        if (p[0] > right[0])
          right = p;
        if (p[1] < top[1])
          top = p;
        if (p[1] > bottom[1])
          bottom = p;
      }
      var cull = [left, top, right, bottom];
      var filtered = cull.slice();
      for (i = 0; i < points2.length; i++) {
        if (!pointInPolygon(points2[i], cull))
          filtered.push(points2[i]);
      }
      return convexHull(filtered);
    }
    function insertNode(p, prev) {
      var node = {
        p,
        prev: null,
        next: null,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      };
      if (!prev) {
        node.prev = node;
        node.next = node;
      } else {
        node.next = prev.next;
        node.prev = prev;
        prev.next.prev = node;
        prev.next = node;
      }
      return node;
    }
    function getSqDist2(p1, p2) {
      var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
      return dx * dx + dy * dy;
    }
    function sqSegDist(p, p1, p2) {
      var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
      if (dx !== 0 || dy !== 0) {
        var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          x2 = p2[0];
          y2 = p2[1];
        } else if (t > 0) {
          x2 += dx * t;
          y2 += dy * t;
        }
      }
      dx = p[0] - x2;
      dy = p[1] - y2;
      return dx * dx + dy * dy;
    }
    function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {
      var ux = x1 - x0;
      var uy = y1 - y0;
      var vx = x3 - x2;
      var vy = y3 - y2;
      var wx = x0 - x2;
      var wy = y0 - y2;
      var a = ux * ux + uy * uy;
      var b = ux * vx + uy * vy;
      var c = vx * vx + vy * vy;
      var d = ux * wx + uy * wy;
      var e = vx * wx + vy * wy;
      var D = a * c - b * b;
      var sc, sN, tc, tN;
      var sD = D;
      var tD = D;
      if (D === 0) {
        sN = 0;
        sD = 1;
        tN = e;
        tD = c;
      } else {
        sN = b * e - c * d;
        tN = a * e - b * d;
        if (sN < 0) {
          sN = 0;
          tN = e;
          tD = c;
        } else if (sN > sD) {
          sN = sD;
          tN = e + b;
          tD = c;
        }
      }
      if (tN < 0) {
        tN = 0;
        if (-d < 0)
          sN = 0;
        else if (-d > a)
          sN = sD;
        else {
          sN = -d;
          sD = a;
        }
      } else if (tN > tD) {
        tN = tD;
        if (-d + b < 0)
          sN = 0;
        else if (-d + b > a)
          sN = sD;
        else {
          sN = -d + b;
          sD = a;
        }
      }
      sc = sN === 0 ? 0 : sN / sD;
      tc = tN === 0 ? 0 : tN / tD;
      var cx = (1 - sc) * x0 + sc * x1;
      var cy = (1 - sc) * y0 + sc * y1;
      var cx2 = (1 - tc) * x2 + tc * x3;
      var cy2 = (1 - tc) * y2 + tc * y3;
      var dx = cx2 - cx;
      var dy = cy2 - cy;
      return dx * dx + dy * dy;
    }
    function compareByX(a, b) {
      return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
    }
    function convexHull(points2) {
      points2.sort(compareByX);
      var lower = [];
      for (var i = 0; i < points2.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points2[i]) <= 0) {
          lower.pop();
        }
        lower.push(points2[i]);
      }
      var upper = [];
      for (var ii = points2.length - 1; ii >= 0; ii--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points2[ii]) <= 0) {
          upper.pop();
        }
        upper.push(points2[ii]);
      }
      upper.pop();
      lower.pop();
      return lower.concat(upper);
    }
  }
});

// node_modules/@turf/collect/node_modules/quickselect/quickselect.js
var require_quickselect = __commonJS({
  "node_modules/@turf/collect/node_modules/quickselect/quickselect.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.quickselect = factory();
    })(exports, function() {
      "use strict";
      function quickselect(arr, k, left, right, compare10) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare10 || defaultCompare2);
      }
      function quickselectStep(arr, k, left, right, compare10) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare10);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap2(arr, left, k);
          if (compare10(arr[right], t) > 0)
            swap2(arr, left, right);
          while (i < j) {
            swap2(arr, i, j);
            i++;
            j--;
            while (compare10(arr[i], t) < 0)
              i++;
            while (compare10(arr[j], t) > 0)
              j--;
          }
          if (compare10(arr[left], t) === 0)
            swap2(arr, left, j);
          else {
            j++;
            swap2(arr, j, right);
          }
          if (j <= k)
            left = j + 1;
          if (k <= j)
            right = j - 1;
        }
      }
      function swap2(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      function defaultCompare2(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      return quickselect;
    });
  }
});

// node_modules/@turf/collect/node_modules/rbush/index.js
var require_rbush = __commonJS({
  "node_modules/@turf/collect/node_modules/rbush/index.js"(exports, module) {
    "use strict";
    module.exports = rbush6;
    module.exports.default = rbush6;
    var quickselect = require_quickselect();
    function rbush6(maxEntries, format) {
      if (!(this instanceof rbush6))
        return new rbush6(maxEntries, format);
      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      if (format) {
        this._initFormat(format);
      }
      this.clear();
    }
    rbush6.prototype = {
      all: function() {
        return this._all(this.data, []);
      },
      search: function(bbox3) {
        var node = this.data, result = [], toBBox = this.toBBox;
        if (!intersects7(bbox3, node))
          return result;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;
            if (intersects7(bbox3, childBBox)) {
              if (node.leaf)
                result.push(child);
              else if (contains2(bbox3, childBBox))
                this._all(child, result);
              else
                nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      },
      collides: function(bbox3) {
        var node = this.data, toBBox = this.toBBox;
        if (!intersects7(bbox3, node))
          return false;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;
            if (intersects7(bbox3, childBBox)) {
              if (node.leaf || contains2(bbox3, childBBox))
                return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      },
      load: function(data) {
        if (!(data && data.length))
          return this;
        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        var node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      },
      insert: function(item) {
        if (item)
          this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function() {
        this.data = createNode2([]);
        return this;
      },
      remove: function(item, equalsFn) {
        if (!item)
          return this;
        var node = this.data, bbox3 = this.toBBox(item), path = [], indexes = [], i, parent, index2, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            index2 = findItem(item, node.children, equalsFn);
            if (index2 !== -1) {
              node.children.splice(index2, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains2(node, bbox3)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else
            node = null;
        }
        return this;
      },
      toBBox: function(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function() {
        return this.data;
      },
      fromJSON: function(data) {
        this.data = data;
        return this;
      },
      _all: function(node, result) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf)
            result.push.apply(result, node.children);
          else
            nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }
        return result;
      },
      _build: function(items, left, right, height) {
        var N = right - left + 1, M = this._maxEntries, node;
        if (N <= M) {
          node = createNode2(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode2([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
        multiSelect(items, left, right, N1, this.compareMinX);
        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function(bbox3, node, level, path) {
        var i, len, child, targetNode, area5, enlargement, minArea, minEnlargement;
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level)
            break;
          minArea = minEnlargement = Infinity;
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area5 = bboxArea(child);
            enlargement = enlargedArea(bbox3, child) - area5;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area5 < minArea ? area5 : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area5 < minArea) {
                minArea = area5;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      },
      _insert: function(item, level, isNode) {
        var toBBox = this.toBBox, bbox3 = isNode ? item : toBBox(item), insertPath = [];
        var node = this._chooseSubtree(bbox3, this.data, level, insertPath);
        node.children.push(item);
        extend2(node, bbox3);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else
            break;
        }
        this._adjustParentBBoxes(bbox3, insertPath, level);
      },
      // split overflowed node into two
      _split: function(insertPath, level) {
        var node = insertPath[level], M = node.children.length, m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode2(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level)
          insertPath[level - 1].children.push(newNode);
        else
          this._splitRoot(node, newNode);
      },
      _splitRoot: function(node, newNode) {
        this.data = createNode2([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function(node, m, M) {
        var i, bbox1, bbox22, overlap2, area5, minOverlap, minArea, index2;
        minOverlap = minArea = Infinity;
        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox22 = distBBox(node, i, M, this.toBBox);
          overlap2 = intersectionArea(bbox1, bbox22);
          area5 = bboxArea(bbox1) + bboxArea(bbox22);
          if (overlap2 < minOverlap) {
            minOverlap = overlap2;
            index2 = i;
            minArea = area5 < minArea ? area5 : minArea;
          } else if (overlap2 === minOverlap) {
            if (area5 < minArea) {
              minArea = area5;
              index2 = i;
            }
          }
        }
        return index2;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin)
          node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function(node, m, M, compare10) {
        node.children.sort(compare10);
        var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend2(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend2(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      },
      _adjustParentBBoxes: function(bbox3, path, level) {
        for (var i = level; i >= 0; i--) {
          extend2(path[i], bbox3);
        }
      },
      _condense: function(path) {
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else
              this.clear();
          } else
            calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function(format) {
        var compareArr = ["return a", " - b", ";"];
        this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
        this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
        this.toBBox = new Function(
          "a",
          "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
        );
      }
    };
    function findItem(item, items, equalsFn) {
      if (!equalsFn)
        return items.indexOf(item);
      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i]))
          return i;
      }
      return -1;
    }
    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode)
        destNode = createNode2(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend2(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend2(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }
    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }
    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }
    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }
    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }
    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }
    function intersectionArea(a, b) {
      var minX2 = Math.max(a.minX, b.minX), minY2 = Math.max(a.minY, b.minY), maxX2 = Math.min(a.maxX, b.maxX), maxY2 = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX2 - minX2) * Math.max(0, maxY2 - minY2);
    }
    function contains2(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }
    function intersects7(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }
    function createNode2(children) {
      return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    }
    function multiSelect(arr, left, right, n, compare10) {
      var stack = [left, right], mid;
      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n)
          continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare10);
        stack.push(left, mid, mid, right);
      }
    }
  }
});

// node_modules/@turf/unkink-polygon/node_modules/quickselect/quickselect.js
var require_quickselect2 = __commonJS({
  "node_modules/@turf/unkink-polygon/node_modules/quickselect/quickselect.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.quickselect = factory();
    })(exports, function() {
      "use strict";
      function quickselect(arr, k, left, right, compare10) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare10 || defaultCompare2);
      }
      function quickselectStep(arr, k, left, right, compare10) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare10);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap2(arr, left, k);
          if (compare10(arr[right], t) > 0)
            swap2(arr, left, right);
          while (i < j) {
            swap2(arr, i, j);
            i++;
            j--;
            while (compare10(arr[i], t) < 0)
              i++;
            while (compare10(arr[j], t) > 0)
              j--;
          }
          if (compare10(arr[left], t) === 0)
            swap2(arr, left, j);
          else {
            j++;
            swap2(arr, j, right);
          }
          if (j <= k)
            left = j + 1;
          if (k <= j)
            right = j - 1;
        }
      }
      function swap2(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      function defaultCompare2(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      return quickselect;
    });
  }
});

// node_modules/@turf/unkink-polygon/node_modules/rbush/index.js
var require_rbush2 = __commonJS({
  "node_modules/@turf/unkink-polygon/node_modules/rbush/index.js"(exports, module) {
    "use strict";
    module.exports = rbush6;
    module.exports.default = rbush6;
    var quickselect = require_quickselect2();
    function rbush6(maxEntries, format) {
      if (!(this instanceof rbush6))
        return new rbush6(maxEntries, format);
      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      if (format) {
        this._initFormat(format);
      }
      this.clear();
    }
    rbush6.prototype = {
      all: function() {
        return this._all(this.data, []);
      },
      search: function(bbox3) {
        var node = this.data, result = [], toBBox = this.toBBox;
        if (!intersects7(bbox3, node))
          return result;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;
            if (intersects7(bbox3, childBBox)) {
              if (node.leaf)
                result.push(child);
              else if (contains2(bbox3, childBBox))
                this._all(child, result);
              else
                nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      },
      collides: function(bbox3) {
        var node = this.data, toBBox = this.toBBox;
        if (!intersects7(bbox3, node))
          return false;
        var nodesToSearch = [], i, len, child, childBBox;
        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;
            if (intersects7(bbox3, childBBox)) {
              if (node.leaf || contains2(bbox3, childBBox))
                return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      },
      load: function(data) {
        if (!(data && data.length))
          return this;
        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        var node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      },
      insert: function(item) {
        if (item)
          this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function() {
        this.data = createNode2([]);
        return this;
      },
      remove: function(item, equalsFn) {
        if (!item)
          return this;
        var node = this.data, bbox3 = this.toBBox(item), path = [], indexes = [], i, parent, index2, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            index2 = findItem(item, node.children, equalsFn);
            if (index2 !== -1) {
              node.children.splice(index2, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains2(node, bbox3)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else
            node = null;
        }
        return this;
      },
      toBBox: function(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function() {
        return this.data;
      },
      fromJSON: function(data) {
        this.data = data;
        return this;
      },
      _all: function(node, result) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf)
            result.push.apply(result, node.children);
          else
            nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }
        return result;
      },
      _build: function(items, left, right, height) {
        var N = right - left + 1, M = this._maxEntries, node;
        if (N <= M) {
          node = createNode2(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode2([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
        multiSelect(items, left, right, N1, this.compareMinX);
        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function(bbox3, node, level, path) {
        var i, len, child, targetNode, area5, enlargement, minArea, minEnlargement;
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level)
            break;
          minArea = minEnlargement = Infinity;
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area5 = bboxArea(child);
            enlargement = enlargedArea(bbox3, child) - area5;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area5 < minArea ? area5 : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area5 < minArea) {
                minArea = area5;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      },
      _insert: function(item, level, isNode) {
        var toBBox = this.toBBox, bbox3 = isNode ? item : toBBox(item), insertPath = [];
        var node = this._chooseSubtree(bbox3, this.data, level, insertPath);
        node.children.push(item);
        extend2(node, bbox3);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else
            break;
        }
        this._adjustParentBBoxes(bbox3, insertPath, level);
      },
      // split overflowed node into two
      _split: function(insertPath, level) {
        var node = insertPath[level], M = node.children.length, m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        var splitIndex = this._chooseSplitIndex(node, m, M);
        var newNode = createNode2(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level)
          insertPath[level - 1].children.push(newNode);
        else
          this._splitRoot(node, newNode);
      },
      _splitRoot: function(node, newNode) {
        this.data = createNode2([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function(node, m, M) {
        var i, bbox1, bbox22, overlap2, area5, minOverlap, minArea, index2;
        minOverlap = minArea = Infinity;
        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox22 = distBBox(node, i, M, this.toBBox);
          overlap2 = intersectionArea(bbox1, bbox22);
          area5 = bboxArea(bbox1) + bboxArea(bbox22);
          if (overlap2 < minOverlap) {
            minOverlap = overlap2;
            index2 = i;
            minArea = area5 < minArea ? area5 : minArea;
          } else if (overlap2 === minOverlap) {
            if (area5 < minArea) {
              minArea = area5;
              index2 = i;
            }
          }
        }
        return index2;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin)
          node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function(node, m, M, compare10) {
        node.children.sort(compare10);
        var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend2(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend2(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      },
      _adjustParentBBoxes: function(bbox3, path, level) {
        for (var i = level; i >= 0; i--) {
          extend2(path[i], bbox3);
        }
      },
      _condense: function(path) {
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else
              this.clear();
          } else
            calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function(format) {
        var compareArr = ["return a", " - b", ";"];
        this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
        this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
        this.toBBox = new Function(
          "a",
          "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
        );
      }
    };
    function findItem(item, items, equalsFn) {
      if (!equalsFn)
        return items.indexOf(item);
      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i]))
          return i;
      }
      return -1;
    }
    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode)
        destNode = createNode2(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend2(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend2(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }
    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }
    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }
    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }
    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }
    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }
    function intersectionArea(a, b) {
      var minX2 = Math.max(a.minX, b.minX), minY2 = Math.max(a.minY, b.minY), maxX2 = Math.min(a.maxX, b.maxX), maxY2 = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX2 - minX2) * Math.max(0, maxY2 - minY2);
    }
    function contains2(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }
    function intersects7(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }
    function createNode2(children) {
      return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    }
    function multiSelect(arr, left, right, n, compare10) {
      var stack = [left, right], mid;
      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n)
          continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare10);
        stack.push(left, mid, mid, right);
      }
    }
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object2) {
        var isObject2 = object2 !== null && typeof object2 === "object";
        var isFunction = toStr.call(object2) === "[object Function]";
        var isArguments = isArgs(object2);
        var isString = isObject2 && toStr.call(object2) === "[object String]";
        var theKeys = [];
        if (!isObject2 && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object2.length > 0 && !has.call(object2, 0)) {
          for (var i = 0; i < object2.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object2.length > 0) {
          for (var j = 0; j < object2.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object2) {
            if (!(skipProto && name === "prototype") && has.call(object2, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object2) {
            if (isArgs(object2)) {
              return originalKeys(slice.call(object2));
            }
            return originalKeys(object2);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object2, name, value, predicate) {
      if (name in object2) {
        if (predicate === true) {
          if (object2[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object2, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object2[name] = value;
      }
    };
    var defineProperties = function(object2, map4) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map4);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map4));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object2, props[i], map4[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object-is/implementation.js"(exports, module) {
    "use strict";
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is(a, b) {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      if (a === b) {
        return true;
      }
      if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object-is/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/object-is/shim.js
var require_shim = __commonJS({
  "node_modules/object-is/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "node_modules/functions-have-names/index.js"(exports, module) {
    "use strict";
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f() {
      }.bind().name !== "";
    };
    module.exports = functionsHaveNames;
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
    "use strict";
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $Object = Object;
    var $TypeError = TypeError;
    module.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.unicodeSets) {
        result += "v";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    };
    if (functionsHaveConfigurableNames && Object.defineProperty) {
      Object.defineProperty(module.exports, "name", { value: "get flags" });
    }
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o = {};
          Object.defineProperty(o, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports, module) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(getPolyfill());
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = flagsBound;
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports, module) {
    "use strict";
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/deep-equal/index.js
var require_deep_equal = __commonJS({
  "node_modules/deep-equal/index.js"(exports, module) {
    var objectKeys = require_object_keys();
    var isArguments = require_is_arguments();
    var is = require_object_is();
    var isRegex = require_is_regex();
    var flags = require_regexp_prototype();
    var isDate = require_is_date_object();
    var getTime = Date.prototype.getTime;
    function deepEqual(actual, expected, options) {
      var opts = options || {};
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is(actual, expected) : actual == expected;
      }
      return objEquiv(actual, expected, opts);
    }
    function isUndefinedOrNull(value) {
      return value === null || value === void 0;
    }
    function isBuffer(x2) {
      if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
        return false;
      }
      if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
        return false;
      }
      if (x2.length > 0 && typeof x2[0] !== "number") {
        return false;
      }
      return true;
    }
    function objEquiv(a, b, opts) {
      var i, key;
      if (typeof a !== typeof b) {
        return false;
      }
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
        return false;
      }
      if (a.prototype !== b.prototype) {
        return false;
      }
      if (isArguments(a) !== isArguments(b)) {
        return false;
      }
      var aIsRegex = isRegex(a);
      var bIsRegex = isRegex(b);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if (aIsRegex || bIsRegex) {
        return a.source === b.source && flags(a) === flags(b);
      }
      if (isDate(a) && isDate(b)) {
        return getTime.call(a) === getTime.call(b);
      }
      var aIsBuffer = isBuffer(a);
      var bIsBuffer = isBuffer(b);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a.length !== b.length) {
          return false;
        }
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      try {
        var ka = objectKeys(a);
        var kb = objectKeys(b);
      } catch (e) {
        return false;
      }
      if (ka.length !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i]) {
          return false;
        }
      }
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) {
          return false;
        }
      }
      return true;
    }
    module.exports = deepEqual;
  }
});

// node_modules/geojson-equality/index.js
var require_geojson_equality = __commonJS({
  "node_modules/geojson-equality/index.js"(exports, module) {
    var deepEqual = require_deep_equal();
    var Equality = function(opt) {
      this.precision = opt && opt.precision ? opt.precision : 17;
      this.direction = opt && opt.direction ? opt.direction : false;
      this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
      this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
    };
    Equality.prototype.compare = function(g1, g2) {
      if (g1.type !== g2.type || !sameLength(g1, g2))
        return false;
      switch (g1.type) {
        case "Point":
          return this.compareCoord(g1.coordinates, g2.coordinates);
          break;
        case "LineString":
          return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
          break;
        case "Polygon":
          return this.comparePolygon(g1, g2);
          break;
        case "Feature":
          return this.compareFeature(g1, g2);
        default:
          if (g1.type.indexOf("Multi") === 0) {
            var context = this;
            var g1s = explode2(g1);
            var g2s = explode2(g2);
            return g1s.every(function(g1part) {
              return this.some(function(g2part) {
                return context.compare(g1part, g2part);
              });
            }, g2s);
          }
      }
      return false;
    };
    function explode2(g) {
      return g.coordinates.map(function(part) {
        return {
          type: g.type.replace("Multi", ""),
          coordinates: part
        };
      });
    }
    function sameLength(g1, g2) {
      return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
    }
    Equality.prototype.compareCoord = function(c1, c2) {
      if (c1.length !== c2.length) {
        return false;
      }
      for (var i = 0; i < c1.length; i++) {
        if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
          return false;
        }
      }
      return true;
    };
    Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
      if (!sameLength(path1, path2))
        return false;
      var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
      var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
      if (isPoly && !this.compareCoord(p1[0], p2[0])) {
        p2 = this.fixStartIndex(p2, p1);
        if (!p2)
          return;
      }
      var sameDirection = this.compareCoord(p1[ind], p2[ind]);
      if (this.direction || sameDirection) {
        return this.comparePath(p1, p2);
      } else {
        if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
          return this.comparePath(p1.slice().reverse(), p2);
        }
        return false;
      }
    };
    Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
      var correctPath, ind = -1;
      for (var i = 0; i < sourcePath.length; i++) {
        if (this.compareCoord(sourcePath[i], targetPath[0])) {
          ind = i;
          break;
        }
      }
      if (ind >= 0) {
        correctPath = [].concat(
          sourcePath.slice(ind, sourcePath.length),
          sourcePath.slice(1, ind + 1)
        );
      }
      return correctPath;
    };
    Equality.prototype.comparePath = function(p1, p2) {
      var cont = this;
      return p1.every(function(c, i) {
        return cont.compareCoord(c, this[i]);
      }, p2);
    };
    Equality.prototype.comparePolygon = function(g1, g2) {
      if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
        var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
        var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
        var cont = this;
        return holes1.every(function(h1) {
          return this.some(function(h2) {
            return cont.compareLine(h1, h2, 1, true);
          });
        }, holes2);
      } else {
        return false;
      }
    };
    Equality.prototype.compareFeature = function(g1, g2) {
      if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
        return false;
      }
      return this.compare(g1.geometry, g2.geometry);
    };
    Equality.prototype.compareBBox = function(g1, g2) {
      if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
        return true;
      }
      return false;
    };
    Equality.prototype.removePseudo = function(path) {
      return path;
    };
    function objectComparator(obj1, obj2) {
      return deepEqual(obj1, obj2, { strict: true });
    }
    module.exports = Equality;
  }
});

// node_modules/density-clustering/lib/DBSCAN.js
var require_DBSCAN = __commonJS({
  "node_modules/density-clustering/lib/DBSCAN.js"(exports, module) {
    function DBSCAN(dataset, epsilon4, minPts, distanceFunction) {
      this.dataset = [];
      this.epsilon = 1;
      this.minPts = 2;
      this.distance = this._euclideanDistance;
      this.clusters = [];
      this.noise = [];
      this._visited = [];
      this._assigned = [];
      this._datasetLength = 0;
      this._init(dataset, epsilon4, minPts, distanceFunction);
    }
    DBSCAN.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
      this._init(dataset, epsilon4, minPts, distanceFunction);
      for (var pointId = 0; pointId < this._datasetLength; pointId++) {
        if (this._visited[pointId] !== 1) {
          this._visited[pointId] = 1;
          var neighbors = this._regionQuery(pointId);
          if (neighbors.length < this.minPts) {
            this.noise.push(pointId);
          } else {
            var clusterId = this.clusters.length;
            this.clusters.push([]);
            this._addToCluster(pointId, clusterId);
            this._expandCluster(clusterId, neighbors);
          }
        }
      }
      return this.clusters;
    };
    DBSCAN.prototype._init = function(dataset, epsilon4, minPts, distance11) {
      if (dataset) {
        if (!(dataset instanceof Array)) {
          throw Error("Dataset must be of type array, " + typeof dataset + " given");
        }
        this.dataset = dataset;
        this.clusters = [];
        this.noise = [];
        this._datasetLength = dataset.length;
        this._visited = new Array(this._datasetLength);
        this._assigned = new Array(this._datasetLength);
      }
      if (epsilon4) {
        this.epsilon = epsilon4;
      }
      if (minPts) {
        this.minPts = minPts;
      }
      if (distance11) {
        this.distance = distance11;
      }
    };
    DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {
      for (var i = 0; i < neighbors.length; i++) {
        var pointId2 = neighbors[i];
        if (this._visited[pointId2] !== 1) {
          this._visited[pointId2] = 1;
          var neighbors2 = this._regionQuery(pointId2);
          if (neighbors2.length >= this.minPts) {
            neighbors = this._mergeArrays(neighbors, neighbors2);
          }
        }
        if (this._assigned[pointId2] !== 1) {
          this._addToCluster(pointId2, clusterId);
        }
      }
    };
    DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
      this.clusters[clusterId].push(pointId);
      this._assigned[pointId] = 1;
    };
    DBSCAN.prototype._regionQuery = function(pointId) {
      var neighbors = [];
      for (var id = 0; id < this._datasetLength; id++) {
        var dist = this.distance(this.dataset[pointId], this.dataset[id]);
        if (dist < this.epsilon) {
          neighbors.push(id);
        }
      }
      return neighbors;
    };
    DBSCAN.prototype._mergeArrays = function(a, b) {
      var len = b.length;
      for (var i = 0; i < len; i++) {
        var P = b[i];
        if (a.indexOf(P) < 0) {
          a.push(P);
        }
      }
      return a;
    };
    DBSCAN.prototype._euclideanDistance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);
      while (i--) {
        sum += (p[i] - q[i]) * (p[i] - q[i]);
      }
      return Math.sqrt(sum);
    };
    if (typeof module !== "undefined" && module.exports) {
      module.exports = DBSCAN;
    }
  }
});

// node_modules/density-clustering/lib/KMEANS.js
var require_KMEANS = __commonJS({
  "node_modules/density-clustering/lib/KMEANS.js"(exports, module) {
    function KMEANS(dataset, k, distance11) {
      this.k = 3;
      this.dataset = [];
      this.assignments = [];
      this.centroids = [];
      this.init(dataset, k, distance11);
    }
    KMEANS.prototype.init = function(dataset, k, distance11) {
      this.assignments = [];
      this.centroids = [];
      if (typeof dataset !== "undefined") {
        this.dataset = dataset;
      }
      if (typeof k !== "undefined") {
        this.k = k;
      }
      if (typeof distance11 !== "undefined") {
        this.distance = distance11;
      }
    };
    KMEANS.prototype.run = function(dataset, k) {
      this.init(dataset, k);
      var len = this.dataset.length;
      for (var i = 0; i < this.k; i++) {
        this.centroids[i] = this.randomCentroid();
      }
      var change = true;
      while (change) {
        change = this.assign();
        for (var centroidId = 0; centroidId < this.k; centroidId++) {
          var mean2 = new Array(maxDim);
          var count2 = 0;
          for (var dim = 0; dim < maxDim; dim++) {
            mean2[dim] = 0;
          }
          for (var j = 0; j < len; j++) {
            var maxDim = this.dataset[j].length;
            if (centroidId === this.assignments[j]) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean2[dim] += this.dataset[j][dim];
              }
              count2++;
            }
          }
          if (count2 > 0) {
            for (var dim = 0; dim < maxDim; dim++) {
              mean2[dim] /= count2;
            }
            this.centroids[centroidId] = mean2;
          } else {
            this.centroids[centroidId] = this.randomCentroid();
            change = true;
          }
        }
      }
      return this.getClusters();
    };
    KMEANS.prototype.randomCentroid = function() {
      var maxId = this.dataset.length - 1;
      var centroid4;
      var id;
      do {
        id = Math.round(Math.random() * maxId);
        centroid4 = this.dataset[id];
      } while (this.centroids.indexOf(centroid4) >= 0);
      return centroid4;
    };
    KMEANS.prototype.assign = function() {
      var change = false;
      var len = this.dataset.length;
      var closestCentroid;
      for (var i = 0; i < len; i++) {
        closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
        if (closestCentroid != this.assignments[i]) {
          this.assignments[i] = closestCentroid;
          change = true;
        }
      }
      return change;
    };
    KMEANS.prototype.getClusters = function() {
      var clusters = new Array(this.k);
      var centroidId;
      for (var pointId = 0; pointId < this.assignments.length; pointId++) {
        centroidId = this.assignments[pointId];
        if (typeof clusters[centroidId] === "undefined") {
          clusters[centroidId] = [];
        }
        clusters[centroidId].push(pointId);
      }
      return clusters;
    };
    KMEANS.prototype.argmin = function(point4, set, f) {
      var min4 = Number.MAX_VALUE;
      var arg = 0;
      var len = set.length;
      var d;
      for (var i = 0; i < len; i++) {
        d = f(point4, set[i]);
        if (d < min4) {
          min4 = d;
          arg = i;
        }
      }
      return arg;
    };
    KMEANS.prototype.distance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);
      while (i--) {
        var diff2 = p[i] - q[i];
        sum += diff2 * diff2;
      }
      return Math.sqrt(sum);
    };
    if (typeof module !== "undefined" && module.exports) {
      module.exports = KMEANS;
    }
  }
});

// node_modules/density-clustering/lib/PriorityQueue.js
var require_PriorityQueue = __commonJS({
  "node_modules/density-clustering/lib/PriorityQueue.js"(exports, module) {
    function PriorityQueue3(elements, priorities, sorting) {
      this._queue = [];
      this._priorities = [];
      this._sorting = "desc";
      this._init(elements, priorities, sorting);
    }
    PriorityQueue3.prototype.insert = function(ele, priority) {
      var indexToInsert = this._queue.length;
      var index2 = indexToInsert;
      while (index2--) {
        var priority2 = this._priorities[index2];
        if (this._sorting === "desc") {
          if (priority > priority2) {
            indexToInsert = index2;
          }
        } else {
          if (priority < priority2) {
            indexToInsert = index2;
          }
        }
      }
      this._insertAt(ele, priority, indexToInsert);
    };
    PriorityQueue3.prototype.remove = function(ele) {
      var index2 = this._queue.length;
      while (index2--) {
        var ele2 = this._queue[index2];
        if (ele === ele2) {
          this._queue.splice(index2, 1);
          this._priorities.splice(index2, 1);
          break;
        }
      }
    };
    PriorityQueue3.prototype.forEach = function(func) {
      this._queue.forEach(func);
    };
    PriorityQueue3.prototype.getElements = function() {
      return this._queue;
    };
    PriorityQueue3.prototype.getElementPriority = function(index2) {
      return this._priorities[index2];
    };
    PriorityQueue3.prototype.getPriorities = function() {
      return this._priorities;
    };
    PriorityQueue3.prototype.getElementsWithPriorities = function() {
      var result = [];
      for (var i = 0, l = this._queue.length; i < l; i++) {
        result.push([this._queue[i], this._priorities[i]]);
      }
      return result;
    };
    PriorityQueue3.prototype._init = function(elements, priorities, sorting) {
      if (elements && priorities) {
        this._queue = [];
        this._priorities = [];
        if (elements.length !== priorities.length) {
          throw new Error("Arrays must have the same length");
        }
        for (var i = 0; i < elements.length; i++) {
          this.insert(elements[i], priorities[i]);
        }
      }
      if (sorting) {
        this._sorting = sorting;
      }
    };
    PriorityQueue3.prototype._insertAt = function(ele, priority, index2) {
      if (this._queue.length === index2) {
        this._queue.push(ele);
        this._priorities.push(priority);
      } else {
        this._queue.splice(index2, 0, ele);
        this._priorities.splice(index2, 0, priority);
      }
    };
    if (typeof module !== "undefined" && module.exports) {
      module.exports = PriorityQueue3;
    }
  }
});

// node_modules/density-clustering/lib/OPTICS.js
var require_OPTICS = __commonJS({
  "node_modules/density-clustering/lib/OPTICS.js"(exports, module) {
    if (typeof module !== "undefined" && module.exports) {
      PriorityQueue3 = require_PriorityQueue();
    }
    var PriorityQueue3;
    function OPTICS(dataset, epsilon4, minPts, distanceFunction) {
      this.epsilon = 1;
      this.minPts = 1;
      this.distance = this._euclideanDistance;
      this._reachability = [];
      this._processed = [];
      this._coreDistance = 0;
      this._orderedList = [];
      this._init(dataset, epsilon4, minPts, distanceFunction);
    }
    OPTICS.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
      this._init(dataset, epsilon4, minPts, distanceFunction);
      for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
        if (this._processed[pointId] !== 1) {
          this._processed[pointId] = 1;
          this.clusters.push([pointId]);
          var clusterId = this.clusters.length - 1;
          this._orderedList.push(pointId);
          var priorityQueue = new PriorityQueue3(null, null, "asc");
          var neighbors = this._regionQuery(pointId);
          if (this._distanceToCore(pointId) !== void 0) {
            this._updateQueue(pointId, neighbors, priorityQueue);
            this._expandCluster(clusterId, priorityQueue);
          }
        }
      }
      return this.clusters;
    };
    OPTICS.prototype.getReachabilityPlot = function() {
      var reachabilityPlot = [];
      for (var i = 0, l = this._orderedList.length; i < l; i++) {
        var pointId = this._orderedList[i];
        var distance11 = this._reachability[pointId];
        reachabilityPlot.push([pointId, distance11]);
      }
      return reachabilityPlot;
    };
    OPTICS.prototype._init = function(dataset, epsilon4, minPts, distance11) {
      if (dataset) {
        if (!(dataset instanceof Array)) {
          throw Error("Dataset must be of type array, " + typeof dataset + " given");
        }
        this.dataset = dataset;
        this.clusters = [];
        this._reachability = new Array(this.dataset.length);
        this._processed = new Array(this.dataset.length);
        this._coreDistance = 0;
        this._orderedList = [];
      }
      if (epsilon4) {
        this.epsilon = epsilon4;
      }
      if (minPts) {
        this.minPts = minPts;
      }
      if (distance11) {
        this.distance = distance11;
      }
    };
    OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
      var self2 = this;
      this._coreDistance = this._distanceToCore(pointId);
      neighbors.forEach(function(pointId2) {
        if (self2._processed[pointId2] === void 0) {
          var dist = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
          var newReachableDistance = Math.max(self2._coreDistance, dist);
          if (self2._reachability[pointId2] === void 0) {
            self2._reachability[pointId2] = newReachableDistance;
            queue.insert(pointId2, newReachableDistance);
          } else {
            if (newReachableDistance < self2._reachability[pointId2]) {
              self2._reachability[pointId2] = newReachableDistance;
              queue.remove(pointId2);
              queue.insert(pointId2, newReachableDistance);
            }
          }
        }
      });
    };
    OPTICS.prototype._expandCluster = function(clusterId, queue) {
      var queueElements = queue.getElements();
      for (var p = 0, l = queueElements.length; p < l; p++) {
        var pointId = queueElements[p];
        if (this._processed[pointId] === void 0) {
          var neighbors = this._regionQuery(pointId);
          this._processed[pointId] = 1;
          this.clusters[clusterId].push(pointId);
          this._orderedList.push(pointId);
          if (this._distanceToCore(pointId) !== void 0) {
            this._updateQueue(pointId, neighbors, queue);
            this._expandCluster(clusterId, queue);
          }
        }
      }
    };
    OPTICS.prototype._distanceToCore = function(pointId) {
      var l = this.epsilon;
      for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
        var neighbors = this._regionQuery(pointId, coreDistCand);
        if (neighbors.length >= this.minPts) {
          return coreDistCand;
        }
      }
      return;
    };
    OPTICS.prototype._regionQuery = function(pointId, epsilon4) {
      epsilon4 = epsilon4 || this.epsilon;
      var neighbors = [];
      for (var id = 0, l = this.dataset.length; id < l; id++) {
        if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon4) {
          neighbors.push(id);
        }
      }
      return neighbors;
    };
    OPTICS.prototype._euclideanDistance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);
      while (i--) {
        sum += (p[i] - q[i]) * (p[i] - q[i]);
      }
      return Math.sqrt(sum);
    };
    if (typeof module !== "undefined" && module.exports) {
      module.exports = OPTICS;
    }
  }
});

// node_modules/density-clustering/lib/index.js
var require_lib = __commonJS({
  "node_modules/density-clustering/lib/index.js"(exports, module) {
    if (typeof module !== "undefined" && module.exports) {
      module.exports = {
        DBSCAN: require_DBSCAN(),
        KMEANS: require_KMEANS(),
        OPTICS: require_OPTICS(),
        PriorityQueue: require_PriorityQueue()
      };
    }
  }
});

// node_modules/skmeans/dist/node/distance.js
var require_distance = __commonJS({
  "node_modules/skmeans/dist/node/distance.js"(exports, module) {
    "use strict";
    module.exports = {
      /**
       * Euclidean distance
       */
      eudist: function eudist(v1, v2, sqrt3) {
        var len = v1.length;
        var sum = 0;
        for (var i = 0; i < len; i++) {
          var d = (v1[i] || 0) - (v2[i] || 0);
          sum += d * d;
        }
        return sqrt3 ? Math.sqrt(sum) : sum;
      },
      mandist: function mandist(v1, v2, sqrt3) {
        var len = v1.length;
        var sum = 0;
        for (var i = 0; i < len; i++) {
          sum += Math.abs((v1[i] || 0) - (v2[i] || 0));
        }
        return sqrt3 ? Math.sqrt(sum) : sum;
      },
      /**
       * Unidimensional distance
       */
      dist: function dist(v1, v2, sqrt3) {
        var d = Math.abs(v1 - v2);
        return sqrt3 ? d : d * d;
      }
    };
  }
});

// node_modules/skmeans/dist/node/kinit.js
var require_kinit = __commonJS({
  "node_modules/skmeans/dist/node/kinit.js"(exports, module) {
    "use strict";
    var Distance = require_distance();
    var eudist = Distance.eudist;
    var dist = Distance.dist;
    module.exports = {
      kmrand: function kmrand(data, k) {
        var map4 = {}, ks = [], t = k << 2;
        var len = data.length;
        var multi = data[0].length > 0;
        while (ks.length < k && t-- > 0) {
          var d = data[Math.floor(Math.random() * len)];
          var key = multi ? d.join("_") : "" + d;
          if (!map4[key]) {
            map4[key] = true;
            ks.push(d);
          }
        }
        if (ks.length < k)
          throw new Error("Error initializating clusters");
        else
          return ks;
      },
      /**
       * K-means++ initial centroid selection
       */
      kmpp: function kmpp(data, k) {
        var distance11 = data[0].length ? eudist : dist;
        var ks = [], len = data.length;
        var multi = data[0].length > 0;
        var map4 = {};
        var c = data[Math.floor(Math.random() * len)];
        var key = multi ? c.join("_") : "" + c;
        ks.push(c);
        map4[key] = true;
        while (ks.length < k) {
          var dists = [], lk = ks.length;
          var dsum = 0, prs = [];
          for (var i = 0; i < len; i++) {
            var min4 = Infinity;
            for (var j = 0; j < lk; j++) {
              var _dist = distance11(data[i], ks[j]);
              if (_dist <= min4)
                min4 = _dist;
            }
            dists[i] = min4;
          }
          for (var _i = 0; _i < len; _i++) {
            dsum += dists[_i];
          }
          for (var _i2 = 0; _i2 < len; _i2++) {
            prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
          }
          prs.sort(function(a, b) {
            return a.pr - b.pr;
          });
          prs[0].cs = prs[0].pr;
          for (var _i3 = 1; _i3 < len; _i3++) {
            prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
          }
          var rnd2 = Math.random();
          var idx = 0;
          while (idx < len - 1 && prs[idx++].cs < rnd2) {
          }
          ks.push(prs[idx - 1].v);
        }
        return ks;
      }
    };
  }
});

// node_modules/skmeans/dist/node/main.js
var require_main = __commonJS({
  "node_modules/skmeans/dist/node/main.js"(exports, module) {
    "use strict";
    var Distance = require_distance();
    var ClusterInit = require_kinit();
    var eudist = Distance.eudist;
    var mandist = Distance.mandist;
    var dist = Distance.dist;
    var kmrand = ClusterInit.kmrand;
    var kmpp = ClusterInit.kmpp;
    var MAX = 1e4;
    function init8(len, val, v) {
      v = v || [];
      for (var i = 0; i < len; i++) {
        v[i] = val;
      }
      return v;
    }
    function skmeans2(data, k, initial, maxit) {
      var ks = [], old = [], idxs = [], dist2 = [];
      var conv = false, it = maxit || MAX;
      var len = data.length, vlen = data[0].length, multi = vlen > 0;
      var count2 = [];
      if (!initial) {
        var _idxs = {};
        while (ks.length < k) {
          var idx = Math.floor(Math.random() * len);
          if (!_idxs[idx]) {
            _idxs[idx] = true;
            ks.push(data[idx]);
          }
        }
      } else if (initial == "kmrand") {
        ks = kmrand(data, k);
      } else if (initial == "kmpp") {
        ks = kmpp(data, k);
      } else {
        ks = initial;
      }
      do {
        init8(k, 0, count2);
        for (var i = 0; i < len; i++) {
          var min4 = Infinity, _idx = 0;
          for (var j = 0; j < k; j++) {
            var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
            if (dist2 <= min4) {
              min4 = dist2;
              _idx = j;
            }
          }
          idxs[i] = _idx;
          count2[_idx]++;
        }
        var sum = [], old = [], dif = 0;
        for (var _j = 0; _j < k; _j++) {
          sum[_j] = multi ? init8(vlen, 0, sum[_j]) : 0;
          old[_j] = ks[_j];
        }
        if (multi) {
          for (var _j2 = 0; _j2 < k; _j2++) {
            ks[_j2] = [];
          }
          for (var _i = 0; _i < len; _i++) {
            var _idx2 = idxs[_i], vsum = sum[_idx2], vect = data[_i];
            for (var h = 0; h < vlen; h++) {
              vsum[h] += vect[h];
            }
          }
          conv = true;
          for (var _j3 = 0; _j3 < k; _j3++) {
            var ksj = ks[_j3], sumj = sum[_j3], oldj = old[_j3], cj = count2[_j3];
            for (var _h = 0; _h < vlen; _h++) {
              ksj[_h] = sumj[_h] / cj || 0;
            }
            if (conv) {
              for (var _h2 = 0; _h2 < vlen; _h2++) {
                if (oldj[_h2] != ksj[_h2]) {
                  conv = false;
                  break;
                }
              }
            }
          }
        } else {
          for (var _i2 = 0; _i2 < len; _i2++) {
            var _idx3 = idxs[_i2];
            sum[_idx3] += data[_i2];
          }
          for (var _j4 = 0; _j4 < k; _j4++) {
            ks[_j4] = sum[_j4] / count2[_j4] || 0;
          }
          conv = true;
          for (var _j5 = 0; _j5 < k; _j5++) {
            if (old[_j5] != ks[_j5]) {
              conv = false;
              break;
            }
          }
        }
        conv = conv || --it <= 0;
      } while (!conv);
      return {
        it: MAX - it,
        k,
        idxs,
        centroids: ks
      };
    }
    module.exports = skmeans2;
  }
});

// node_modules/@turf/meta/dist/es/index.js
var es_exports2 = {};
__export(es_exports2, {
  coordAll: () => coordAll,
  coordEach: () => coordEach,
  coordReduce: () => coordReduce,
  featureEach: () => featureEach,
  featureReduce: () => featureReduce,
  findPoint: () => findPoint,
  findSegment: () => findSegment,
  flattenEach: () => flattenEach,
  flattenReduce: () => flattenReduce,
  geomEach: () => geomEach,
  geomReduce: () => geomReduce,
  lineEach: () => lineEach,
  lineReduce: () => lineReduce,
  propEach: () => propEach,
  propReduce: () => propReduce,
  segmentEach: () => segmentEach,
  segmentReduce: () => segmentReduce
});

// node_modules/@turf/helpers/dist/es/index.js
var es_exports = {};
__export(es_exports, {
  areaFactors: () => areaFactors,
  bearingToAzimuth: () => bearingToAzimuth,
  convertArea: () => convertArea,
  convertLength: () => convertLength,
  degreesToRadians: () => degreesToRadians,
  earthRadius: () => earthRadius,
  factors: () => factors,
  feature: () => feature,
  featureCollection: () => featureCollection,
  geometry: () => geometry,
  geometryCollection: () => geometryCollection,
  isNumber: () => isNumber,
  isObject: () => isObject,
  lengthToDegrees: () => lengthToDegrees,
  lengthToRadians: () => lengthToRadians,
  lineString: () => lineString,
  lineStrings: () => lineStrings,
  multiLineString: () => multiLineString,
  multiPoint: () => multiPoint,
  multiPolygon: () => multiPolygon,
  point: () => point,
  points: () => points,
  polygon: () => polygon,
  polygons: () => polygons,
  radiansToDegrees: () => radiansToDegrees,
  radiansToLength: () => radiansToLength,
  round: () => round,
  unitsFactors: () => unitsFactors,
  validateBBox: () => validateBBox,
  validateId: () => validateId
});
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
var areaFactors = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function geometry(type, coordinates, _options) {
  if (_options === void 0) {
    _options = {};
  }
  switch (type) {
    case "Point":
      return point(coordinates).geometry;
    case "LineString":
      return lineString(coordinates).geometry;
    case "Polygon":
      return polygon(coordinates).geometry;
    case "MultiPoint":
      return multiPoint(coordinates).geometry;
    case "MultiLineString":
      return multiLineString(coordinates).geometry;
    case "MultiPolygon":
      return multiPolygon(coordinates).geometry;
    default:
      throw new Error(type + " is invalid");
  }
}
function point(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  var geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
function points(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  return featureCollection(coordinates.map(function(coords) {
    return point(coords, properties);
  }), options);
}
function polygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
    var ring = coordinates_1[_i];
    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }
    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  var geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function polygons(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  return featureCollection(coordinates.map(function(coords) {
    return polygon(coords, properties);
  }), options);
}
function lineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  var geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function lineStrings(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  return featureCollection(coordinates.map(function(coords) {
    return lineString(coords, properties);
  }), options);
}
function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }
  var fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function multiLineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiLineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function multiPoint(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiPoint",
    coordinates
  };
  return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiPolygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function geometryCollection(geometries, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "GeometryCollection",
    geometries
  };
  return feature(geom, properties, options);
}
function round(num, precision) {
  if (precision === void 0) {
    precision = 0;
  }
  if (precision && !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }
  var multiplier = Math.pow(10, precision || 0);
  return Math.round(num * multiplier) / multiplier;
}
function radiansToLength(radians, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians * factor;
}
function lengthToRadians(distance11, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance11 / factor;
}
function lengthToDegrees(distance11, units) {
  return radiansToDegrees(lengthToRadians(distance11, units));
}
function bearingToAzimuth(bearing2) {
  var angle4 = bearing2 % 360;
  if (angle4 < 0) {
    angle4 += 360;
  }
  return angle4;
}
function radiansToDegrees(radians) {
  var degrees = radians % (2 * Math.PI);
  return degrees * 180 / Math.PI;
}
function degreesToRadians(degrees) {
  var radians = degrees % 360;
  return radians * Math.PI / 180;
}
function convertLength(length4, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "kilometers";
  }
  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }
  if (!(length4 >= 0)) {
    throw new Error("length must be a positive number");
  }
  return radiansToLength(lengthToRadians(length4, originalUnit), finalUnit);
}
function convertArea(area5, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "meters";
  }
  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }
  if (!(area5 >= 0)) {
    throw new Error("area must be a positive number");
  }
  var startFactor = areaFactors[originalUnit];
  if (!startFactor) {
    throw new Error("invalid original units");
  }
  var finalFactor = areaFactors[finalUnit];
  if (!finalFactor) {
    throw new Error("invalid final units");
  }
  return area5 / startFactor * finalFactor;
}
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
  return !!input && input.constructor === Object;
}
function validateBBox(bbox3) {
  if (!bbox3) {
    throw new Error("bbox is required");
  }
  if (!Array.isArray(bbox3)) {
    throw new Error("bbox must be an Array");
  }
  if (bbox3.length !== 4 && bbox3.length !== 6) {
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  }
  bbox3.forEach(function(num) {
    if (!isNumber(num)) {
      throw new Error("bbox must only contain numbers");
    }
  });
}
function validateId(id) {
  if (!id) {
    throw new Error("id is required");
  }
  if (["string", "number"].indexOf(typeof id) === -1) {
    throw new Error("id must be a number or a string");
  }
}

// node_modules/@turf/meta/dist/es/index.js
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null)
    return;
  var j, k, l, geometry2, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection2, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection2 = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection2 ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry2 = isGeometryCollection2 ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry2 === null)
        continue;
      coords = geometry2.coordinates;
      var geomType = geometry2.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint")
              multiFeatureIndex++;
          }
          if (geomType === "LineString")
            multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(
                coords[j][k],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString")
              multiFeatureIndex++;
            if (geomType === "Polygon")
              geometryIndex++;
          }
          if (geomType === "Polygon")
            multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(
                  coords[j][k][l],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry2.geometries.length; j++)
            if (coordEach(geometry2.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(
    geojson,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (coordIndex === 0 && initialValue === void 0)
        previousValue = currentCoord;
      else
        previousValue = callback(
          previousValue,
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    },
    excludeWrapCoord
  );
  return previousValue;
}
function propEach(geojson, callback) {
  var i;
  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false)
          break;
      }
      break;
    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}
function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function(currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentProperties;
    else
      previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false)
        break;
    }
  }
}
function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function(currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentFeature;
    else
      previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}
function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function(coord) {
    coords.push(coord);
  });
  return coords;
}
function geomEach(geojson, callback) {
  var i, j, g, geometry2, stopG, geometryMaybeCollection, isGeometryCollection2, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection2 = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection2 ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry2 = isGeometryCollection2 ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry2 === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry2.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry2,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry2.geometries.length; j++) {
            if (callback(
              geometry2.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentGeometry;
      else
        previousValue = callback(
          previousValue,
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        );
    }
  );
  return previousValue;
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry2, featureIndex, properties, bbox3, id) {
    var type = geometry2 === null ? null : geometry2.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry2, properties, { bbox: bbox3, id }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry2.coordinates.length; multiFeatureIndex++) {
      var coordinate2 = geometry2.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate2
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(
    geojson,
    function(currentFeature, featureIndex, multiFeatureIndex) {
      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
        previousValue = currentFeature;
      else
        previousValue = callback(
          previousValue,
          currentFeature,
          featureIndex,
          multiFeatureIndex
        );
    }
  );
  return previousValue;
}
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry)
      return;
    var type = feature2.geometry.type;
    if (type === "Point" || type === "MultiPoint")
      return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
      if (started === false && initialValue === void 0)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}
function lineEach(geojson, callback) {
  if (!geojson)
    throw new Error("geojson is required");
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    if (feature2.geometry === null)
      return;
    var type = feature2.geometry.type;
    var coords = feature2.geometry.coordinates;
    switch (type) {
      case "LineString":
        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
          return false;
        break;
      case "Polygon":
        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
          if (callback(
            lineString(coords[geometryIndex], feature2.properties),
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
        }
        break;
    }
  });
}
function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(
    geojson,
    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentLine;
      else
        previousValue = callback(
          previousValue,
          currentLine,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    }
  );
  return previousValue;
}
function findSegment(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      if (segmentIndex < 0)
        segmentIndex = coords.length + segmentIndex - 1;
      return lineString(
        [coords[segmentIndex], coords[segmentIndex + 1]],
        properties,
        options
      );
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[geometryIndex][segmentIndex],
          coords[geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][segmentIndex],
          coords[multiFeatureIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][geometryIndex][segmentIndex],
          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}
function findPoint(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
      return point(coords, properties, options);
    case "MultiPoint":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      return point(coords[multiFeatureIndex], properties, options);
    case "LineString":
      if (coordIndex < 0)
        coordIndex = coords.length + coordIndex;
      return point(coords[coordIndex], properties, options);
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[geometryIndex].length + coordIndex;
      return point(coords[geometryIndex][coordIndex], properties, options);
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return point(coords[multiFeatureIndex][coordIndex], properties, options);
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return point(
        coords[multiFeatureIndex][geometryIndex][coordIndex],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}

// node_modules/@turf/bbox/dist/es/index.js
function bbox(geojson) {
  var result = [Infinity, Infinity, -Infinity, -Infinity];
  coordEach(geojson, function(coord) {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }
    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }
    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }
    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}
bbox["default"] = bbox;
var es_default = bbox;

// node_modules/@turf/invariant/dist/es/index.js
var es_exports3 = {};
__export(es_exports3, {
  collectionOf: () => collectionOf,
  containsNumber: () => containsNumber,
  featureOf: () => featureOf,
  geojsonType: () => geojsonType,
  getCoord: () => getCoord,
  getCoords: () => getCoords,
  getGeom: () => getGeom,
  getType: () => getType
});
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return coord.geometry.coordinates;
    }
    if (coord.type === "Point") {
      return coord.coordinates;
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return coord;
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function containsNumber(coordinates) {
  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {
    return true;
  }
  if (Array.isArray(coordinates[0]) && coordinates[0].length) {
    return containsNumber(coordinates[0]);
  }
  throw new Error("coordinates must only contain numbers");
}
function geojsonType(value, type, name) {
  if (!type || !name) {
    throw new Error("type and name required");
  }
  if (!value || value.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
  }
}
function featureOf(feature2, type, name) {
  if (!feature2) {
    throw new Error("No feature passed");
  }
  if (!name) {
    throw new Error(".featureOf() requires a name");
  }
  if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
    throw new Error("Invalid input to " + name + ", Feature with geometry required");
  }
  if (!feature2.geometry || feature2.geometry.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
  }
}
function collectionOf(featureCollection2, type, name) {
  if (!featureCollection2) {
    throw new Error("No featureCollection passed");
  }
  if (!name) {
    throw new Error(".collectionOf() requires a name");
  }
  if (!featureCollection2 || featureCollection2.type !== "FeatureCollection") {
    throw new Error("Invalid input to " + name + ", FeatureCollection required");
  }
  for (var _i = 0, _a = featureCollection2.features; _i < _a.length; _i++) {
    var feature2 = _a[_i];
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature2.geometry || feature2.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
    }
  }
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}
function getType(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }
  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }
  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }
  return geojson.type;
}

// node_modules/@turf/isolines/dist/es/index.js
var import_object_assign = __toESM(require_object_assign());
var defaultSettings = {
  successCallback: null,
  verbose: false
};
var settings = {};
function isoContours(data, threshold, options) {
  options = options ? options : {};
  var optionKeys = Object.keys(defaultSettings);
  for (var i = 0; i < optionKeys.length; i++) {
    var key = optionKeys[i];
    var val = options[key];
    val = typeof val !== "undefined" && val !== null ? val : defaultSettings[key];
    settings[key] = val;
  }
  if (settings.verbose)
    console.log(
      "MarchingSquaresJS-isoContours: computing isocontour for " + threshold
    );
  var ret = contourGrid2Paths(computeContourGrid(data, threshold));
  if (typeof settings.successCallback === "function")
    settings.successCallback(ret);
  return ret;
}
function interpolateX(y2, y0, y1) {
  return (y2 - y0) / (y1 - y0);
}
function computeContourGrid(data, threshold) {
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var ContourGrid = { rows, cols, cells: [] };
  for (var j = 0; j < rows; ++j) {
    ContourGrid.cells[j] = [];
    for (var i = 0; i < cols; ++i) {
      var cval = 0;
      var tl = data[j + 1][i];
      var tr = data[j + 1][i + 1];
      var br = data[j][i + 1];
      var bl = data[j][i];
      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
        continue;
      }
      cval |= tl >= threshold ? 8 : 0;
      cval |= tr >= threshold ? 4 : 0;
      cval |= br >= threshold ? 2 : 0;
      cval |= bl >= threshold ? 1 : 0;
      var flipped = false;
      if (cval === 5 || cval === 10) {
        var average2 = (tl + tr + br + bl) / 4;
        if (cval === 5 && average2 < threshold) {
          cval = 10;
          flipped = true;
        } else if (cval === 10 && average2 < threshold) {
          cval = 5;
          flipped = true;
        }
      }
      if (cval !== 0 && cval !== 15) {
        var top, bottom, left, right;
        top = bottom = left = right = 0.5;
        if (cval === 1) {
          left = 1 - interpolateX(threshold, tl, bl);
          bottom = 1 - interpolateX(threshold, br, bl);
        } else if (cval === 2) {
          bottom = interpolateX(threshold, bl, br);
          right = 1 - interpolateX(threshold, tr, br);
        } else if (cval === 3) {
          left = 1 - interpolateX(threshold, tl, bl);
          right = 1 - interpolateX(threshold, tr, br);
        } else if (cval === 4) {
          top = interpolateX(threshold, tl, tr);
          right = interpolateX(threshold, br, tr);
        } else if (cval === 5) {
          top = interpolateX(threshold, tl, tr);
          right = interpolateX(threshold, br, tr);
          bottom = 1 - interpolateX(threshold, br, bl);
          left = 1 - interpolateX(threshold, tl, bl);
        } else if (cval === 6) {
          bottom = interpolateX(threshold, bl, br);
          top = interpolateX(threshold, tl, tr);
        } else if (cval === 7) {
          left = 1 - interpolateX(threshold, tl, bl);
          top = interpolateX(threshold, tl, tr);
        } else if (cval === 8) {
          left = interpolateX(threshold, bl, tl);
          top = 1 - interpolateX(threshold, tr, tl);
        } else if (cval === 9) {
          bottom = 1 - interpolateX(threshold, br, bl);
          top = 1 - interpolateX(threshold, tr, tl);
        } else if (cval === 10) {
          top = 1 - interpolateX(threshold, tr, tl);
          right = 1 - interpolateX(threshold, tr, br);
          bottom = interpolateX(threshold, bl, br);
          left = interpolateX(threshold, bl, tl);
        } else if (cval === 11) {
          top = 1 - interpolateX(threshold, tr, tl);
          right = 1 - interpolateX(threshold, tr, br);
        } else if (cval === 12) {
          left = interpolateX(threshold, bl, tl);
          right = interpolateX(threshold, br, tr);
        } else if (cval === 13) {
          bottom = 1 - interpolateX(threshold, br, bl);
          right = interpolateX(threshold, br, tr);
        } else if (cval === 14) {
          left = interpolateX(threshold, bl, tl);
          bottom = interpolateX(threshold, bl, br);
        } else {
          console.log(
            "MarchingSquaresJS-isoContours: Illegal cval detected: " + cval
          );
        }
        ContourGrid.cells[j][i] = {
          cval,
          flipped,
          top,
          right,
          bottom,
          left
        };
      }
    }
  }
  return ContourGrid;
}
function isSaddle(cell) {
  return cell.cval === 5 || cell.cval === 10;
}
function isTrivial(cell) {
  return cell.cval === 0 || cell.cval === 15;
}
function clearCell(cell) {
  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {
    cell.cval = 15;
  }
}
function getXY(cell, edge) {
  if (edge === "top") {
    return [cell.top, 1];
  } else if (edge === "bottom") {
    return [cell.bottom, 0];
  } else if (edge === "right") {
    return [1, cell.right];
  } else if (edge === "left") {
    return [0, cell.left];
  }
}
function contourGrid2Paths(grid) {
  var paths = [];
  var path_idx = 0;
  var epsilon4 = 1e-7;
  grid.cells.forEach(function(g, j) {
    g.forEach(function(gg, i) {
      if (typeof gg !== "undefined" && !isSaddle(gg) && !isTrivial(gg)) {
        var p = tracePath(grid.cells, j, i);
        var merged = false;
        if (p.info === "mergeable") {
          var x2 = p.path[p.path.length - 1][0], y2 = p.path[p.path.length - 1][1];
          for (var k = path_idx - 1; k >= 0; k--) {
            if (Math.abs(paths[k][0][0] - x2) <= epsilon4 && Math.abs(paths[k][0][1] - y2) <= epsilon4) {
              for (var l = p.path.length - 2; l >= 0; --l) {
                paths[k].unshift(p.path[l]);
              }
              merged = true;
              break;
            }
          }
        }
        if (!merged)
          paths[path_idx++] = p.path;
      }
    });
  });
  return paths;
}
function tracePath(grid, j, i) {
  var maxj = grid.length;
  var p = [];
  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];
  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];
  var dx, dy;
  var startEdge = [
    "none",
    "left",
    "bottom",
    "left",
    "right",
    "none",
    "bottom",
    "left",
    "top",
    "top",
    "none",
    "top",
    "right",
    "right",
    "bottom",
    "none"
  ];
  var nextEdge = [
    "none",
    "bottom",
    "right",
    "right",
    "top",
    "top",
    "top",
    "top",
    "left",
    "bottom",
    "right",
    "right",
    "left",
    "bottom",
    "left",
    "none"
  ];
  var edge;
  var currentCell = grid[j][i];
  var cval = currentCell.cval;
  var edge = startEdge[cval];
  var pt = getXY(currentCell, edge);
  p.push([i + pt[0], j + pt[1]]);
  edge = nextEdge[cval];
  pt = getXY(currentCell, edge);
  p.push([i + pt[0], j + pt[1]]);
  clearCell(currentCell);
  var k = i + dxContour[cval];
  var l = j + dyContour[cval];
  var prev_cval = cval;
  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {
    currentCell = grid[l][k];
    if (typeof currentCell === "undefined") {
      break;
    }
    cval = currentCell.cval;
    if (cval === 0 || cval === 15) {
      return { path: p, info: "mergeable" };
    }
    edge = nextEdge[cval];
    dx = dxContour[cval];
    dy = dyContour[cval];
    if (cval === 5 || cval === 10) {
      if (cval === 5) {
        if (currentCell.flipped) {
          if (dyContour[prev_cval] === -1) {
            edge = "left";
            dx = -1;
            dy = 0;
          } else {
            edge = "right";
            dx = 1;
            dy = 0;
          }
        } else {
          if (dxContour[prev_cval] === -1) {
            edge = "bottom";
            dx = 0;
            dy = -1;
          }
        }
      } else if (cval === 10) {
        if (currentCell.flipped) {
          if (dxContour[prev_cval] === -1) {
            edge = "top";
            dx = 0;
            dy = 1;
          } else {
            edge = "bottom";
            dx = 0;
            dy = -1;
          }
        } else {
          if (dyContour[prev_cval] === 1) {
            edge = "left";
            dx = -1;
            dy = 0;
          }
        }
      }
    }
    pt = getXY(currentCell, edge);
    p.push([k + pt[0], l + pt[1]]);
    clearCell(currentCell);
    k += dx;
    l += dy;
    prev_cval = cval;
  }
  return { path: p, info: "closed" };
}
function gridToMatrix(grid, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip4 = options.flip;
  var flags = options.flags;
  collectionOf(grid, "Point", "input must contain Points");
  var pointsMatrix = sortPointsByLatLng(grid, flip4);
  var matrix = [];
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point4 = pointRow[c];
      if (point4.properties[zProperty])
        row.push(point4.properties[zProperty]);
      else
        row.push(0);
      if (flags === true)
        point4.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }
  return matrix;
}
function sortPointsByLatLng(points2, flip4) {
  var pointsByLatitude = {};
  featureEach(points2, function(point4) {
    var lat2 = getCoords(point4)[1];
    if (!pointsByLatitude[lat2])
      pointsByLatitude[lat2] = [];
    pointsByLatitude[lat2].push(point4);
  });
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat2) {
    var row = pointsByLatitude[lat2];
    var rowOrderedByLongitude = row.sort(function(a, b) {
      return getCoords(a)[0] - getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });
  var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
    if (flip4)
      return getCoords(a[0])[1] - getCoords(b[0])[1];
    else
      return getCoords(b[0])[1] - getCoords(a[0])[1];
  });
  return pointMatrix;
}
function isolines(pointGrid2, breaks, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var commonProperties = options.commonProperties || {};
  var breaksProperties = options.breaksProperties || [];
  collectionOf(pointGrid2, "Point", "Input must contain Points");
  if (!breaks)
    throw new Error("breaks is required");
  if (!Array.isArray(breaks))
    throw new Error("breaks must be an Array");
  if (!isObject(commonProperties))
    throw new Error("commonProperties must be an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties must be an Array");
  var matrix = gridToMatrix(pointGrid2, { zProperty, flip: true });
  var createdIsoLines = createIsoLines(
    matrix,
    breaks,
    zProperty,
    commonProperties,
    breaksProperties
  );
  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid2);
  return featureCollection(scaledIsolines);
}
function createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {
  var results = [];
  for (var i = 1; i < breaks.length; i++) {
    var threshold = +breaks[i];
    var properties = (0, import_object_assign.default)({}, commonProperties, breaksProperties[i]);
    properties[zProperty] = threshold;
    var isoline = multiLineString(isoContours(matrix, threshold), properties);
    results.push(isoline);
  }
  return results;
}
function rescaleIsolines(createdIsoLines, matrix, points2) {
  var gridBbox = es_default(points2);
  var originalWidth = gridBbox[2] - gridBbox[0];
  var originalHeigth = gridBbox[3] - gridBbox[1];
  var x0 = gridBbox[0];
  var y0 = gridBbox[1];
  var matrixWidth = matrix[0].length - 1;
  var matrixHeight = matrix.length - 1;
  var scaleX = originalWidth / matrixWidth;
  var scaleY = originalHeigth / matrixHeight;
  var resize = function(point4) {
    point4[0] = point4[0] * scaleX + x0;
    point4[1] = point4[1] * scaleY + y0;
  };
  createdIsoLines.forEach(function(isoline) {
    coordEach(isoline, resize);
  });
  return createdIsoLines;
}
var es_default2 = isolines;

// node_modules/@turf/convex/dist/es/index.js
var import_concaveman = __toESM(require_concaveman());
function convex(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  options.concavity = options.concavity || Infinity;
  var points2 = [];
  coordEach(geojson, function(coord) {
    points2.push([coord[0], coord[1]]);
  });
  if (!points2.length) {
    return null;
  }
  var convexHull = (0, import_concaveman.default)(points2, options.concavity);
  if (convexHull.length > 3) {
    return polygon([convexHull]);
  }
  return null;
}

// node_modules/@turf/boolean-point-in-polygon/dist/es/index.js
function booleanPointInPolygon(point4, polygon4, options) {
  if (options === void 0) {
    options = {};
  }
  if (!point4) {
    throw new Error("point is required");
  }
  if (!polygon4) {
    throw new Error("polygon is required");
  }
  var pt = getCoord(point4);
  var geom = getGeom(polygon4);
  var type = geom.type;
  var bbox3 = polygon4.bbox;
  var polys = geom.coordinates;
  if (bbox3 && inBBox(pt, bbox3) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  var insidePoly = false;
  for (var i = 0; i < polys.length && !insidePoly; i++) {
    if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
      var inHole = false;
      var k = 1;
      while (k < polys[i].length && !inHole) {
        if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
          inHole = true;
        }
        k++;
      }
      if (!inHole) {
        insidePoly = true;
      }
    }
  }
  return insidePoly;
}
function inRing(pt, ring, ignoreBoundary) {
  var isInside3 = false;
  if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
    ring = ring.slice(0, ring.length - 1);
  }
  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    var xi = ring[i][0];
    var yi = ring[i][1];
    var xj = ring[j][0];
    var yj = ring[j][1];
    var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
    if (onBoundary) {
      return !ignoreBoundary;
    }
    var intersect4 = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
    if (intersect4) {
      isInside3 = !isInside3;
    }
  }
  return isInside3;
}
function inBBox(pt, bbox3) {
  return bbox3[0] <= pt[0] && bbox3[1] <= pt[1] && bbox3[2] >= pt[0] && bbox3[3] >= pt[1];
}

// node_modules/@turf/points-within-polygon/dist/es/index.js
function pointsWithinPolygon(points2, polygons2) {
  var results = [];
  featureEach(points2, function(point4) {
    var contained = false;
    if (point4.geometry.type === "Point") {
      geomEach(polygons2, function(polygon4) {
        if (booleanPointInPolygon(point4, polygon4))
          contained = true;
      });
      if (contained) {
        results.push(point4);
      }
    } else if (point4.geometry.type === "MultiPoint") {
      var pointsWithin = [];
      geomEach(polygons2, function(polygon4) {
        coordEach(point4, function(pointCoord) {
          if (booleanPointInPolygon(pointCoord, polygon4)) {
            contained = true;
            pointsWithin.push(pointCoord);
          }
        });
      });
      if (contained) {
        results.push(multiPoint(pointsWithin));
      }
    } else {
      throw new Error("Input geometry must be a Point or MultiPoint");
    }
  });
  return featureCollection(results);
}
var es_default3 = pointsWithinPolygon;

// node_modules/@turf/distance/dist/es/index.js
function distance(from, to, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
var es_default4 = distance;

// node_modules/@turf/tin/dist/es/index.js
function tin(points2, z) {
  var isPointZ = false;
  return featureCollection(triangulate(points2.features.map(function(p) {
    var point4 = {
      x: p.geometry.coordinates[0],
      y: p.geometry.coordinates[1]
    };
    if (z) {
      point4.z = p.properties[z];
    } else if (p.geometry.coordinates.length === 3) {
      isPointZ = true;
      point4.z = p.geometry.coordinates[2];
    }
    return point4;
  })).map(function(triangle) {
    var a = [triangle.a.x, triangle.a.y];
    var b = [triangle.b.x, triangle.b.y];
    var c = [triangle.c.x, triangle.c.y];
    var properties = {};
    if (isPointZ) {
      a.push(triangle.a.z);
      b.push(triangle.b.z);
      c.push(triangle.c.z);
    } else {
      properties = {
        a: triangle.a.z,
        b: triangle.b.z,
        c: triangle.c.z
      };
    }
    return polygon([[a, b, c, a]], properties);
  }));
}
var Triangle = (
  /** @class */
  function() {
    function Triangle4(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      var A = b.x - a.x;
      var B2 = b.y - a.y;
      var C = c.x - a.x;
      var D = c.y - a.y;
      var E = A * (a.x + b.x) + B2 * (a.y + b.y);
      var F = C * (a.x + c.x) + D * (a.y + c.y);
      var G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
      var dx;
      var dy;
      this.x = (D * E - B2 * F) / G;
      this.y = (A * F - C * E) / G;
      dx = this.x - a.x;
      dy = this.y - a.y;
      this.r = dx * dx + dy * dy;
    }
    return Triangle4;
  }()
);
function byX(a, b) {
  return b.x - a.x;
}
function dedup(edges2) {
  var j = edges2.length;
  var a;
  var b;
  var i;
  var m;
  var n;
  outer:
    while (j) {
      b = edges2[--j];
      a = edges2[--j];
      i = j;
      while (i) {
        n = edges2[--i];
        m = edges2[--i];
        if (a === m && b === n || a === n && b === m) {
          edges2.splice(j, 2);
          edges2.splice(i, 2);
          j -= 2;
          continue outer;
        }
      }
    }
}
function triangulate(vertices) {
  if (vertices.length < 3) {
    return [];
  }
  vertices.sort(byX);
  var i = vertices.length - 1;
  var xmin = vertices[i].x;
  var xmax = vertices[0].x;
  var ymin = vertices[i].y;
  var ymax = ymin;
  var epsilon4 = 1e-12;
  var a;
  var b;
  var c;
  var A;
  var B2;
  var G;
  while (i--) {
    if (vertices[i].y < ymin) {
      ymin = vertices[i].y;
    }
    if (vertices[i].y > ymax) {
      ymax = vertices[i].y;
    }
  }
  var dx = xmax - xmin;
  var dy = ymax - ymin;
  var dmax = dx > dy ? dx : dy;
  var xmid = (xmax + xmin) * 0.5;
  var ymid = (ymax + ymin) * 0.5;
  var open = [
    new Triangle({
      __sentinel: true,
      x: xmid - 20 * dmax,
      y: ymid - dmax
    }, {
      __sentinel: true,
      x: xmid,
      y: ymid + 20 * dmax
    }, {
      __sentinel: true,
      x: xmid + 20 * dmax,
      y: ymid - dmax
    })
  ];
  var closed = [];
  var edges2 = [];
  var j;
  i = vertices.length;
  while (i--) {
    edges2.length = 0;
    j = open.length;
    while (j--) {
      dx = vertices[i].x - open[j].x;
      if (dx > 0 && dx * dx > open[j].r) {
        closed.push(open[j]);
        open.splice(j, 1);
        continue;
      }
      dy = vertices[i].y - open[j].y;
      if (dx * dx + dy * dy > open[j].r) {
        continue;
      }
      edges2.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
      open.splice(j, 1);
    }
    dedup(edges2);
    j = edges2.length;
    while (j) {
      b = edges2[--j];
      a = edges2[--j];
      c = vertices[i];
      A = b.x - a.x;
      B2 = b.y - a.y;
      G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
      if (Math.abs(G) > epsilon4) {
        open.push(new Triangle(a, b, c));
      }
    }
  }
  Array.prototype.push.apply(closed, open);
  i = closed.length;
  while (i--) {
    if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
      closed.splice(i, 1);
    }
  }
  return closed;
}

// node_modules/@turf/clone/dist/es/index.js
function clone(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  var cloned = { type: "Feature" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  cloned.geometry = cloneGeometry(geojson.geometry);
  return cloned;
}
function cloneProperties(properties) {
  var cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach(function(key) {
    var value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map(function(item) {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  var cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map(function(feature2) {
    return cloneFeature(feature2);
  });
  return cloned;
}
function cloneGeometry(geometry2) {
  var geom = { type: geometry2.type };
  if (geometry2.bbox) {
    geom.bbox = geometry2.bbox;
  }
  if (geometry2.type === "GeometryCollection") {
    geom.geometries = geometry2.geometries.map(function(g) {
      return cloneGeometry(g);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry2.coordinates);
  return geom;
}
function deepSlice(coords) {
  var cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map(function(coord) {
    return deepSlice(coord);
  });
}
var es_default5 = clone;

// node_modules/@turf/concave/dist/es/lib/turf-line-dissolve.js
function lineDissolve(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  var mutate = options.mutate;
  if (getType(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (mutate === false || mutate === void 0) {
    geojson = es_default5(geojson);
  }
  var result = [];
  var lastLine = lineReduce(geojson, function(previousLine, currentLine) {
    var merged = mergeLineStrings(previousLine, currentLine);
    if (merged) {
      return merged;
    } else {
      result.push(previousLine);
      return currentLine;
    }
  });
  if (lastLine) {
    result.push(lastLine);
  }
  if (!result.length) {
    return null;
  } else if (result.length === 1) {
    return result[0];
  } else {
    return multiLineString(result.map(function(line) {
      return line.coordinates;
    }));
  }
}
function coordId(coord) {
  return coord[0].toString() + "," + coord[1].toString();
}
function mergeLineStrings(a, b) {
  var coords1 = a.geometry.coordinates;
  var coords2 = b.geometry.coordinates;
  var s1 = coordId(coords1[0]);
  var e1 = coordId(coords1[coords1.length - 1]);
  var s2 = coordId(coords2[0]);
  var e2 = coordId(coords2[coords2.length - 1]);
  var coords;
  if (s1 === e2) {
    coords = coords2.concat(coords1.slice(1));
  } else if (s2 === e1) {
    coords = coords1.concat(coords2.slice(1));
  } else if (s1 === s2) {
    coords = coords1.slice(1).reverse().concat(coords2);
  } else if (e1 === e2) {
    coords = coords1.concat(coords2.reverse().slice(1));
  } else {
    return null;
  }
  return lineString(coords);
}
var turf_line_dissolve_default = lineDissolve;

// node_modules/topojson-client/src/identity.js
function identity_default(x2) {
  return x2;
}

// node_modules/topojson-client/src/transform.js
function transform_default(transform2) {
  if (transform2 == null)
    return identity_default;
  var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
  return function(input, i) {
    if (!i)
      x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n)
      output[j] = input[j], ++j;
    return output;
  };
}

// node_modules/topojson-client/src/reverse.js
function reverse_default(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j)
    t = array[i], array[i++] = array[j], array[j] = t;
}

// node_modules/topojson-client/src/feature.js
function object(topology, o) {
  var transformPoint2 = transform_default(topology.transform), arcs = topology.arcs;
  function arc(i, points2) {
    if (points2.length)
      points2.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points2.push(transformPoint2(a[k], k));
    }
    if (i < 0)
      reverse_default(points2, n);
  }
  function point4(p) {
    return transformPoint2(p);
  }
  function line(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc(arcs2[i], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon4(arcs2) {
    return arcs2.map(ring);
  }
  function geometry2(o2) {
    var type = o2.type, coordinates;
    switch (type) {
      case "GeometryCollection":
        return { type, geometries: o2.geometries.map(geometry2) };
      case "Point":
        coordinates = point4(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point4);
        break;
      case "LineString":
        coordinates = line(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line);
        break;
      case "Polygon":
        coordinates = polygon4(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon4);
        break;
      default:
        return null;
    }
    return { type, coordinates };
  }
  return geometry2(o);
}

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e = ends(i), start = e[0], end = e[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }
  function flush(fragmentByEnd2, fragmentByStart2) {
    for (var k in fragmentByEnd2) {
      var f = fragmentByEnd2[k];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}

// node_modules/topojson-client/src/merge.js
function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area5 = 0;
  while (++i < n)
    a = b, b = ring[i], area5 += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area5);
}
function merge_default(topology) {
  return object(topology, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology, objects) {
  var polygonsByArc = {}, polygons2 = [], groups = [];
  objects.forEach(geometry2);
  function geometry2(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry2);
        break;
      case "Polygon":
        extract3(o.arcs);
        break;
      case "MultiPolygon":
        o.arcs.forEach(extract3);
        break;
    }
  }
  function extract3(polygon4) {
    polygon4.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon4);
      });
    });
    polygons2.push(polygon4);
  }
  function area5(ring) {
    return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
  }
  polygons2.forEach(function(polygon4) {
    if (!polygon4._) {
      var group = [], neighbors = [polygon4];
      polygon4._ = 1;
      groups.push(group);
      while (polygon4 = neighbors.pop()) {
        group.push(polygon4);
        polygon4.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon5) {
              if (!polygon5._) {
                polygon5._ = 1;
                neighbors.push(polygon5);
              }
            });
          });
        });
      }
    }
  });
  polygons2.forEach(function(polygon4) {
    delete polygon4._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons3) {
      var arcs = [], n;
      polygons3.forEach(function(polygon4) {
        polygon4.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });
      arcs = stitch_default(topology, arcs);
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area5(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area5(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }
      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}

// node_modules/topojson-server/src/object.js
var hasOwnProperty = Object.prototype.hasOwnProperty;

// node_modules/topojson-server/src/bounds.js
function bounds_default(objects) {
  var x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  function boundGeometry(geometry2) {
    if (geometry2 != null && hasOwnProperty.call(boundGeometryType, geometry2.type))
      boundGeometryType[geometry2.type](geometry2);
  }
  var boundGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(boundGeometry);
    },
    Point: function(o) {
      boundPoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates.forEach(boundPoint);
    },
    LineString: function(o) {
      boundLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs.forEach(boundLine);
    },
    Polygon: function(o) {
      o.arcs.forEach(boundLine);
    },
    MultiPolygon: function(o) {
      o.arcs.forEach(boundMultiLine);
    }
  };
  function boundPoint(coordinates) {
    var x2 = coordinates[0], y2 = coordinates[1];
    if (x2 < x0)
      x0 = x2;
    if (x2 > x1)
      x1 = x2;
    if (y2 < y0)
      y0 = y2;
    if (y2 > y1)
      y1 = y2;
  }
  function boundLine(coordinates) {
    coordinates.forEach(boundPoint);
  }
  function boundMultiLine(coordinates) {
    coordinates.forEach(boundLine);
  }
  for (var key in objects) {
    boundGeometry(objects[key]);
  }
  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : void 0;
}

// node_modules/topojson-server/src/hash/hashset.js
function hashset_default(size11, hash, equal3, type, empty) {
  if (arguments.length === 3) {
    type = Array;
    empty = null;
  }
  var store = new type(size11 = 1 << Math.max(4, Math.ceil(Math.log(size11) / Math.LN2))), mask2 = size11 - 1;
  for (var i = 0; i < size11; ++i) {
    store[i] = empty;
  }
  function add16(value) {
    var index2 = hash(value) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal3(match, value))
        return true;
      if (++collisions >= size11)
        throw new Error("full hashset");
      match = store[index2 = index2 + 1 & mask2];
    }
    store[index2] = value;
    return true;
  }
  function has(value) {
    var index2 = hash(value) & mask2, match = store[index2], collisions = 0;
    while (match != empty) {
      if (equal3(match, value))
        return true;
      if (++collisions >= size11)
        break;
      match = store[index2 = index2 + 1 & mask2];
    }
    return false;
  }
  function values3() {
    var values4 = [];
    for (var i2 = 0, n = store.length; i2 < n; ++i2) {
      var match = store[i2];
      if (match != empty)
        values4.push(match);
    }
    return values4;
  }
  return {
    add: add16,
    has,
    values: values3
  };
}

// node_modules/topojson-server/src/hash/hashmap.js
function hashmap_default(size11, hash, equal3, keyType, keyEmpty, valueType) {
  if (arguments.length === 3) {
    keyType = valueType = Array;
    keyEmpty = null;
  }
  var keystore = new keyType(size11 = 1 << Math.max(4, Math.ceil(Math.log(size11) / Math.LN2))), valstore = new valueType(size11), mask2 = size11 - 1;
  for (var i = 0; i < size11; ++i) {
    keystore[i] = keyEmpty;
  }
  function set(key, value) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal3(matchKey, key))
        return valstore[index2] = value;
      if (++collisions >= size11)
        throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key;
    valstore[index2] = value;
    return value;
  }
  function maybeSet(key, value) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal3(matchKey, key))
        return valstore[index2];
      if (++collisions >= size11)
        throw new Error("full hashmap");
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    keystore[index2] = key;
    valstore[index2] = value;
    return value;
  }
  function get4(key, missingValue) {
    var index2 = hash(key) & mask2, matchKey = keystore[index2], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal3(matchKey, key))
        return valstore[index2];
      if (++collisions >= size11)
        break;
      matchKey = keystore[index2 = index2 + 1 & mask2];
    }
    return missingValue;
  }
  function keys() {
    var keys2 = [];
    for (var i2 = 0, n = keystore.length; i2 < n; ++i2) {
      var matchKey = keystore[i2];
      if (matchKey != keyEmpty)
        keys2.push(matchKey);
    }
    return keys2;
  }
  return {
    set,
    maybeSet,
    // set if unset
    get: get4,
    keys
  };
}

// node_modules/topojson-server/src/hash/point-equal.js
function point_equal_default(pointA, pointB) {
  return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}

// node_modules/topojson-server/src/hash/point-hash.js
var buffer = new ArrayBuffer(16);
var floats = new Float64Array(buffer);
var uints = new Uint32Array(buffer);
function point_hash_default(point4) {
  floats[0] = point4[0];
  floats[1] = point4[1];
  var hash = uints[0] ^ uints[1];
  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
  return hash & 2147483647;
}

// node_modules/topojson-server/src/join.js
function join_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, indexes = index2(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i, n, previousIndex, currentIndex, nextIndex;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
  }
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineStart = line[0], lineEnd = line[1];
    currentIndex = indexes[lineStart];
    nextIndex = indexes[++lineStart];
    ++junctionCount, junctionByIndex[currentIndex] = 1;
    while (++lineStart <= lineEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
    }
    ++junctionCount, junctionByIndex[nextIndex] = 1;
  }
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = -1;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0] + 1, ringEnd = ring[1];
    previousIndex = indexes[ringEnd - 1];
    currentIndex = indexes[ringStart - 1];
    nextIndex = indexes[ringStart];
    sequence(i, previousIndex, currentIndex, nextIndex);
    while (++ringStart <= ringEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
    }
  }
  function sequence(i2, previousIndex2, currentIndex2, nextIndex2) {
    if (visitedByIndex[currentIndex2] === i2)
      return;
    visitedByIndex[currentIndex2] = i2;
    var leftIndex = leftByIndex[currentIndex2];
    if (leftIndex >= 0) {
      var rightIndex = rightByIndex[currentIndex2];
      if ((leftIndex !== previousIndex2 || rightIndex !== nextIndex2) && (leftIndex !== nextIndex2 || rightIndex !== previousIndex2)) {
        ++junctionCount, junctionByIndex[currentIndex2] = 1;
      }
    } else {
      leftByIndex[currentIndex2] = previousIndex2;
      rightByIndex[currentIndex2] = nextIndex2;
    }
  }
  function index2() {
    var indexByPoint = hashmap_default(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes2 = new Int32Array(coordinates.length);
    for (var i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
      indexes2[i2] = indexByPoint.maybeSet(i2, i2);
    }
    return indexes2;
  }
  function hashIndex(i2) {
    return point_hash_default(coordinates[i2]);
  }
  function equalIndex(i2, j2) {
    return point_equal_default(coordinates[i2], coordinates[j2]);
  }
  visitedByIndex = leftByIndex = rightByIndex = null;
  var junctionByPoint = hashset_default(junctionCount * 1.4, point_hash_default, point_equal_default), j;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    if (junctionByIndex[j = indexes[i]]) {
      junctionByPoint.add(coordinates[j]);
    }
  }
  return junctionByPoint;
}

// node_modules/topojson-server/src/cut.js
function cut_default(topology) {
  var junctions = join_default(topology), coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, next3, i, n;
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineMid = line[0], lineEnd = line[1];
    while (++lineMid < lineEnd) {
      if (junctions.has(coordinates[lineMid])) {
        next3 = { 0: lineMid, 1: line[1] };
        line[1] = lineMid;
        line = line.next = next3;
      }
    }
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
    while (++ringMid < ringEnd) {
      if (junctions.has(coordinates[ringMid])) {
        if (ringFixed) {
          next3 = { 0: ringMid, 1: ring[1] };
          ring[1] = ringMid;
          ring = ring.next = next3;
        } else {
          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
          coordinates[ringEnd] = coordinates[ringStart];
          ringFixed = true;
          ringMid = ringStart;
        }
      }
    }
  }
  return topology;
}
function rotateArray(array, start, end, offset) {
  reverse(array, start, end);
  reverse(array, start, start + offset);
  reverse(array, start + offset, end);
}
function reverse(array, start, end) {
  for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {
    t = array[start], array[start] = array[end], array[end] = t;
  }
}

// node_modules/topojson-server/src/dedup.js
function dedup_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, line, rings = topology.rings, ring, arcCount = lines.length + rings.length, i, n;
  delete topology.lines;
  delete topology.rings;
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    while (line = line.next)
      ++arcCount;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    while (ring = ring.next)
      ++arcCount;
  }
  var arcsByEnd = hashmap_default(arcCount * 2 * 1.4, point_hash_default, point_equal_default), arcs = topology.arcs = [];
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    do {
      dedupLine(line);
    } while (line = line.next);
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    if (ring.next) {
      do {
        dedupLine(ring);
      } while (ring = ring.next);
    } else {
      dedupRing(ring);
    }
  }
  function dedupLine(arc) {
    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i2, n2;
    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = startArcs.length; i2 < n2; ++i2) {
        startArc = startArcs[i2];
        if (equalLine(startArc, arc)) {
          arc[0] = startArc[0];
          arc[1] = startArc[1];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (reverseEqualLine(endArc, arc)) {
          arc[1] = endArc[0];
          arc[0] = endArc[1];
          return;
        }
      }
    }
    if (startArcs)
      startArcs.push(arc);
    else
      arcsByEnd.set(startPoint, [arc]);
    if (endArcs)
      endArcs.push(arc);
    else
      arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function dedupRing(arc) {
    var endPoint, endArcs, endArc, i2, n2;
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs)
      endArcs.push(arc);
    else
      arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function equalLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb)
      return false;
    for (; ia <= ja; ++ia, ++ib)
      if (!point_equal_default(coordinates[ia], coordinates[ib]))
        return false;
    return true;
  }
  function reverseEqualLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb)
      return false;
    for (; ia <= ja; ++ia, --jb)
      if (!point_equal_default(coordinates[ia], coordinates[jb]))
        return false;
    return true;
  }
  function equalRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib)
      return false;
    var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!point_equal_default(coordinates[ia + (i2 + ka) % n2], coordinates[ib + (i2 + kb) % n2]))
        return false;
    }
    return true;
  }
  function reverseEqualRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib)
      return false;
    var ka = findMinimumOffset(arcA), kb = n2 - findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!point_equal_default(coordinates[ia + (i2 + ka) % n2], coordinates[jb - (i2 + kb) % n2]))
        return false;
    }
    return true;
  }
  function findMinimumOffset(arc) {
    var start = arc[0], end = arc[1], mid = start, minimum = mid, minimumPoint = coordinates[mid];
    while (++mid < end) {
      var point4 = coordinates[mid];
      if (point4[0] < minimumPoint[0] || point4[0] === minimumPoint[0] && point4[1] < minimumPoint[1]) {
        minimum = mid;
        minimumPoint = point4;
      }
    }
    return minimum - start;
  }
  return topology;
}

// node_modules/topojson-server/src/delta.js
function delta_default(arcs) {
  var i = -1, n = arcs.length;
  while (++i < n) {
    var arc = arcs[i], j = 0, k = 1, m = arc.length, point4 = arc[0], x0 = point4[0], y0 = point4[1], x1, y1;
    while (++j < m) {
      point4 = arc[j], x1 = point4[0], y1 = point4[1];
      if (x1 !== x0 || y1 !== y0)
        arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
    }
    if (k === 1)
      arc[k++] = [0, 0];
    arc.length = k;
  }
  return arcs;
}

// node_modules/topojson-server/src/extract.js
function extract_default(objects) {
  var index2 = -1, lines = [], rings = [], coordinates = [];
  function extractGeometry2(geometry2) {
    if (geometry2 && hasOwnProperty.call(extractGeometryType, geometry2.type))
      extractGeometryType[geometry2.type](geometry2);
  }
  var extractGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(extractGeometry2);
    },
    LineString: function(o) {
      o.arcs = extractLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(extractLine);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(extractRing);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(extractMultiRing);
    }
  };
  function extractLine(line) {
    for (var i = 0, n = line.length; i < n; ++i)
      coordinates[++index2] = line[i];
    var arc = { 0: index2 - n + 1, 1: index2 };
    lines.push(arc);
    return arc;
  }
  function extractRing(ring) {
    for (var i = 0, n = ring.length; i < n; ++i)
      coordinates[++index2] = ring[i];
    var arc = { 0: index2 - n + 1, 1: index2 };
    rings.push(arc);
    return arc;
  }
  function extractMultiRing(rings2) {
    return rings2.map(extractRing);
  }
  for (var key in objects) {
    extractGeometry2(objects[key]);
  }
  return {
    type: "Topology",
    coordinates,
    lines,
    rings,
    objects
  };
}

// node_modules/topojson-server/src/geometry.js
function geometry_default(inputs) {
  var outputs = {}, key;
  for (key in inputs)
    outputs[key] = geomifyObject(inputs[key]);
  return outputs;
}
function geomifyObject(input) {
  return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
}
function geomifyFeatureCollection(input) {
  var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
  if (input.bbox != null)
    output.bbox = input.bbox;
  return output;
}
function geomifyFeature(input) {
  var output = geomifyGeometry(input.geometry), key;
  if (input.id != null)
    output.id = input.id;
  if (input.bbox != null)
    output.bbox = input.bbox;
  for (key in input.properties) {
    output.properties = input.properties;
    break;
  }
  return output;
}
function geomifyGeometry(input) {
  if (input == null)
    return { type: null };
  var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };
  if (input.bbox != null)
    output.bbox = input.bbox;
  return output;
}

// node_modules/topojson-server/src/prequantize.js
function prequantize_default(objects, bbox3, n) {
  var x0 = bbox3[0], y0 = bbox3[1], x1 = bbox3[2], y1 = bbox3[3], kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1, ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;
  function quantizePoint(input) {
    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
  }
  function quantizePoints(input, m) {
    var i = -1, j = 0, n2 = input.length, output = new Array(n2), pi, px, py, x2, y2;
    while (++i < n2) {
      pi = input[i];
      x2 = Math.round((pi[0] - x0) * kx);
      y2 = Math.round((pi[1] - y0) * ky);
      if (x2 !== px || y2 !== py)
        output[j++] = [px = x2, py = y2];
    }
    output.length = j;
    while (j < m)
      j = output.push([output[0][0], output[0][1]]);
    return output;
  }
  function quantizeLine(input) {
    return quantizePoints(input, 2);
  }
  function quantizeRing(input) {
    return quantizePoints(input, 4);
  }
  function quantizePolygon(input) {
    return input.map(quantizeRing);
  }
  function quantizeGeometry(o) {
    if (o != null && hasOwnProperty.call(quantizeGeometryType, o.type))
      quantizeGeometryType[o.type](o);
  }
  var quantizeGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(quantizeGeometry);
    },
    Point: function(o) {
      o.coordinates = quantizePoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates = o.coordinates.map(quantizePoint);
    },
    LineString: function(o) {
      o.arcs = quantizeLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(quantizeLine);
    },
    Polygon: function(o) {
      o.arcs = quantizePolygon(o.arcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(quantizePolygon);
    }
  };
  for (var key in objects) {
    quantizeGeometry(objects[key]);
  }
  return {
    scale: [1 / kx, 1 / ky],
    translate: [x0, y0]
  };
}

// node_modules/topojson-server/src/topology.js
function topology_default(objects, quantization) {
  var bbox3 = bounds_default(objects = geometry_default(objects)), transform2 = quantization > 0 && bbox3 && prequantize_default(objects, bbox3, quantization), topology = dedup_default(cut_default(extract_default(objects))), coordinates = topology.coordinates, indexByArc = hashmap_default(topology.arcs.length * 1.4, hashArc, equalArc);
  objects = topology.objects;
  topology.bbox = bbox3;
  topology.arcs = topology.arcs.map(function(arc, i) {
    indexByArc.set(arc, i);
    return coordinates.slice(arc[0], arc[1] + 1);
  });
  delete topology.coordinates;
  coordinates = null;
  function indexGeometry(geometry2) {
    if (geometry2 && hasOwnProperty.call(indexGeometryType, geometry2.type))
      indexGeometryType[geometry2.type](geometry2);
  }
  var indexGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(indexGeometry);
    },
    LineString: function(o) {
      o.arcs = indexArcs(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(indexMultiArcs);
    }
  };
  function indexArcs(arc) {
    var indexes = [];
    do {
      var index2 = indexByArc.get(arc);
      indexes.push(arc[0] < arc[1] ? index2 : ~index2);
    } while (arc = arc.next);
    return indexes;
  }
  function indexMultiArcs(arcs) {
    return arcs.map(indexArcs);
  }
  for (var key in objects) {
    indexGeometry(objects[key]);
  }
  if (transform2) {
    topology.transform = transform2;
    topology.arcs = delta_default(topology.arcs);
  }
  return topology;
}
function hashArc(arc) {
  var i = arc[0], j = arc[1], t;
  if (j < i)
    t = i, i = j, j = t;
  return i + 31 * j;
}
function equalArc(arcA, arcB) {
  var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t;
  if (ja < ia)
    t = ia, ia = ja, ja = t;
  if (jb < ib)
    t = ib, ib = jb, jb = t;
  return ia === ib && ja === jb;
}

// node_modules/@turf/concave/dist/es/lib/turf-polygon-dissolve.js
function polygonDissolve(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  if (getType(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (options.mutate === false || options.mutate === void 0) {
    geojson = es_default5(geojson);
  }
  var geoms = [];
  flattenEach(geojson, function(feature2) {
    geoms.push(feature2.geometry);
  });
  var topo = topology_default({ geoms: geometryCollection(geoms).geometry });
  var merged = merge_default(topo, topo.objects.geoms.geometries);
  return merged;
}

// node_modules/@turf/concave/dist/es/lib/turf-dissolve.js
function dissolve(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  var mutate = options.mutate;
  if (getType(geojson) !== "FeatureCollection") {
    throw new Error("geojson must be a FeatureCollection");
  }
  if (!geojson.features.length) {
    throw new Error("geojson is empty");
  }
  if (mutate === false || mutate === void 0) {
    geojson = es_default5(geojson);
  }
  var type = getHomogenousType(geojson);
  if (!type) {
    throw new Error("geojson must be homogenous");
  }
  var data = geojson;
  switch (type) {
    case "LineString":
      return turf_line_dissolve_default(data, options);
    case "Polygon":
      return polygonDissolve(data, options);
    default:
      throw new Error(type + " is not supported");
  }
}
function getHomogenousType(geojson) {
  var types = {};
  flattenEach(geojson, function(feature2) {
    types[feature2.geometry.type] = true;
  });
  var keys = Object.keys(types);
  if (keys.length === 1) {
    return keys[0];
  }
  return null;
}
var turf_dissolve_default = dissolve;

// node_modules/@turf/concave/dist/es/index.js
function concave(points2, options) {
  if (options === void 0) {
    options = {};
  }
  var maxEdge = options.maxEdge || Infinity;
  var cleaned = removeDuplicates(points2);
  var tinPolys = tin(cleaned);
  tinPolys.features = tinPolys.features.filter(function(triangle) {
    var pt1 = triangle.geometry.coordinates[0][0];
    var pt2 = triangle.geometry.coordinates[0][1];
    var pt3 = triangle.geometry.coordinates[0][2];
    var dist1 = es_default4(pt1, pt2, options);
    var dist2 = es_default4(pt2, pt3, options);
    var dist3 = es_default4(pt1, pt3, options);
    return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
  });
  if (tinPolys.features.length < 1) {
    return null;
  }
  var dissolved = turf_dissolve_default(tinPolys);
  if (dissolved.coordinates.length === 1) {
    dissolved.coordinates = dissolved.coordinates[0];
    dissolved.type = "Polygon";
  }
  return feature(dissolved);
}
function removeDuplicates(points2) {
  var cleaned = [];
  var existing = {};
  featureEach(points2, function(pt) {
    if (!pt.geometry) {
      return;
    }
    var key = pt.geometry.coordinates.join("-");
    if (!Object.prototype.hasOwnProperty.call(existing, key)) {
      cleaned.push(pt);
      existing[key] = true;
    }
  });
  return featureCollection(cleaned);
}
var es_default6 = concave;

// node_modules/@turf/collect/dist/es/index.js
var import_rbush = __toESM(require_rbush());
function collect(polygons2, points2, inProperty, outProperty) {
  var rtree = (0, import_rbush.default)(6);
  var treeItems = points2.features.map(function(item) {
    var _a;
    return {
      minX: item.geometry.coordinates[0],
      minY: item.geometry.coordinates[1],
      maxX: item.geometry.coordinates[0],
      maxY: item.geometry.coordinates[1],
      property: (_a = item.properties) === null || _a === void 0 ? void 0 : _a[inProperty]
    };
  });
  rtree.load(treeItems);
  polygons2.features.forEach(function(poly) {
    if (!poly.properties) {
      poly.properties = {};
    }
    var bbox3 = es_default(poly);
    var potentialPoints = rtree.search({
      minX: bbox3[0],
      minY: bbox3[1],
      maxX: bbox3[2],
      maxY: bbox3[3]
    });
    var values3 = [];
    potentialPoints.forEach(function(pt) {
      if (booleanPointInPolygon([pt.minX, pt.minY], poly)) {
        values3.push(pt.property);
      }
    });
    poly.properties[outProperty] = values3;
  });
  return polygons2;
}
var es_default7 = collect;

// node_modules/@turf/flip/dist/es/index.js
function flip(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (mutate === false || mutate === void 0)
    geojson = es_default5(geojson);
  coordEach(geojson, function(coord) {
    var x2 = coord[0];
    var y2 = coord[1];
    coord[0] = y2;
    coord[1] = x2;
  });
  return geojson;
}
var es_default8 = flip;

// node_modules/@turf/clean-coords/dist/es/index.js
function cleanCoords(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var mutate = typeof options === "object" ? options.mutate : options;
  if (!geojson)
    throw new Error("geojson is required");
  var type = getType(geojson);
  var newCoords = [];
  switch (type) {
    case "LineString":
      newCoords = cleanLine(geojson);
      break;
    case "MultiLineString":
    case "Polygon":
      getCoords(geojson).forEach(function(line) {
        newCoords.push(cleanLine(line));
      });
      break;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(polygons2) {
        var polyPoints = [];
        polygons2.forEach(function(ring) {
          polyPoints.push(cleanLine(ring));
        });
        newCoords.push(polyPoints);
      });
      break;
    case "Point":
      return geojson;
    case "MultiPoint":
      var existing = {};
      getCoords(geojson).forEach(function(coord) {
        var key = coord.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
          newCoords.push(coord);
          existing[key] = true;
        }
      });
      break;
    default:
      throw new Error(type + " geometry not supported");
  }
  if (geojson.coordinates) {
    if (mutate === true) {
      geojson.coordinates = newCoords;
      return geojson;
    }
    return { type, coordinates: newCoords };
  } else {
    if (mutate === true) {
      geojson.geometry.coordinates = newCoords;
      return geojson;
    }
    return feature({ type, coordinates: newCoords }, geojson.properties, {
      bbox: geojson.bbox,
      id: geojson.id
    });
  }
}
function cleanLine(line) {
  var points2 = getCoords(line);
  if (points2.length === 2 && !equals(points2[0], points2[1]))
    return points2;
  var newPoints = [];
  var secondToLast = points2.length - 1;
  var newPointsLength = newPoints.length;
  newPoints.push(points2[0]);
  for (var i = 1; i < secondToLast; i++) {
    var prevAddedPoint = newPoints[newPoints.length - 1];
    if (points2[i][0] === prevAddedPoint[0] && points2[i][1] === prevAddedPoint[1])
      continue;
    else {
      newPoints.push(points2[i]);
      newPointsLength = newPoints.length;
      if (newPointsLength > 2) {
        if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
          newPoints.splice(newPoints.length - 2, 1);
      }
    }
  }
  newPoints.push(points2[points2.length - 1]);
  newPointsLength = newPoints.length;
  if (equals(points2[0], points2[points2.length - 1]) && newPointsLength < 4)
    throw new Error("invalid polygon");
  if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
    newPoints.splice(newPoints.length - 2, 1);
  return newPoints;
}
function equals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
function isPointOnLineSegment(start, end, point4) {
  var x2 = point4[0], y2 = point4[1];
  var startX = start[0], startY = start[1];
  var endX = end[0], endY = end[1];
  var dxc = x2 - startX;
  var dyc = y2 - startY;
  var dxl = endX - startX;
  var dyl = endY - startY;
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0)
    return false;
  else if (Math.abs(dxl) >= Math.abs(dyl))
    return dxl > 0 ? startX <= x2 && x2 <= endX : endX <= x2 && x2 <= startX;
  else
    return dyl > 0 ? startY <= y2 && y2 <= endY : endY <= y2 && y2 <= startY;
}
var es_default9 = cleanCoords;

// node_modules/@turf/simplify/dist/es/index.js
function getSqDist(p1, p2) {
  var dx = p1.x - p2.x, dy = p1.y - p2.y;
  return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
  var x2 = p1.x, y2 = p1.y, dx = p2.x - x2, dy = p2.y - y2;
  if (dx !== 0 || dy !== 0) {
    var t = ((p.x - x2) * dx + (p.y - y2) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x2 = p2.x;
      y2 = p2.y;
    } else if (t > 0) {
      x2 += dx * t;
      y2 += dy * t;
    }
  }
  dx = p.x - x2;
  dy = p.y - y2;
  return dx * dx + dy * dy;
}
function simplifyRadialDist(points2, sqTolerance) {
  var prevPoint = points2[0], newPoints = [prevPoint], point4;
  for (var i = 1, len = points2.length; i < len; i++) {
    point4 = points2[i];
    if (getSqDist(point4, prevPoint) > sqTolerance) {
      newPoints.push(point4);
      prevPoint = point4;
    }
  }
  if (prevPoint !== point4)
    newPoints.push(point4);
  return newPoints;
}
function simplifyDPStep(points2, first, last, sqTolerance, simplified) {
  var maxSqDist = sqTolerance, index2;
  for (var i = first + 1; i < last; i++) {
    var sqDist = getSqSegDist(points2[i], points2[first], points2[last]);
    if (sqDist > maxSqDist) {
      index2 = i;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index2 - first > 1)
      simplifyDPStep(points2, first, index2, sqTolerance, simplified);
    simplified.push(points2[index2]);
    if (last - index2 > 1)
      simplifyDPStep(points2, index2, last, sqTolerance, simplified);
  }
}
function simplifyDouglasPeucker(points2, sqTolerance) {
  var last = points2.length - 1;
  var simplified = [points2[0]];
  simplifyDPStep(points2, 0, last, sqTolerance, simplified);
  simplified.push(points2[last]);
  return simplified;
}
function simplify(points2, tolerance, highestQuality) {
  if (points2.length <= 2)
    return points2;
  var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
  points2 = highestQuality ? points2 : simplifyRadialDist(points2, sqTolerance);
  points2 = simplifyDouglasPeucker(points2, sqTolerance);
  return points2;
}
function simplify$1(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var tolerance = options.tolerance !== void 0 ? options.tolerance : 1;
  var highQuality = options.highQuality || false;
  var mutate = options.mutate || false;
  if (!geojson)
    throw new Error("geojson is required");
  if (tolerance && tolerance < 0)
    throw new Error("invalid tolerance");
  if (mutate !== true)
    geojson = es_default5(geojson);
  geomEach(geojson, function(geom) {
    simplifyGeom(geom, tolerance, highQuality);
  });
  return geojson;
}
function simplifyGeom(geometry2, tolerance, highQuality) {
  var type = geometry2.type;
  if (type === "Point" || type === "MultiPoint")
    return geometry2;
  es_default9(geometry2, true);
  var coordinates = geometry2.coordinates;
  switch (type) {
    case "LineString":
      geometry2["coordinates"] = simplifyLine(
        coordinates,
        tolerance,
        highQuality
      );
      break;
    case "MultiLineString":
      geometry2["coordinates"] = coordinates.map(function(lines) {
        return simplifyLine(lines, tolerance, highQuality);
      });
      break;
    case "Polygon":
      geometry2["coordinates"] = simplifyPolygon(
        coordinates,
        tolerance,
        highQuality
      );
      break;
    case "MultiPolygon":
      geometry2["coordinates"] = coordinates.map(function(rings) {
        return simplifyPolygon(rings, tolerance, highQuality);
      });
  }
  return geometry2;
}
function simplifyLine(coordinates, tolerance, highQuality) {
  return simplify(
    coordinates.map(function(coord) {
      return { x: coord[0], y: coord[1], z: coord[2] };
    }),
    tolerance,
    highQuality
  ).map(function(coords) {
    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];
  });
}
function simplifyPolygon(coordinates, tolerance, highQuality) {
  return coordinates.map(function(ring) {
    var pts = ring.map(function(coord) {
      return { x: coord[0], y: coord[1] };
    });
    if (pts.length < 4) {
      throw new Error("invalid polygon");
    }
    var simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
      return [coords.x, coords.y];
    });
    while (!checkValidity(simpleRing)) {
      tolerance -= tolerance * 0.01;
      simpleRing = simplify(pts, tolerance, highQuality).map(function(coords) {
        return [coords.x, coords.y];
      });
    }
    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
      simpleRing.push(simpleRing[0]);
    }
    return simpleRing;
  });
}
function checkValidity(ring) {
  if (ring.length < 3)
    return false;
  return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
}
var es_default10 = simplify$1;

// node_modules/@turf/bezier-spline/dist/es/lib/spline.js
var Spline = (
  /** @class */
  function() {
    function Spline2(options) {
      this.points = options.points || [];
      this.duration = options.duration || 1e4;
      this.sharpness = options.sharpness || 0.85;
      this.centers = [];
      this.controls = [];
      this.stepLength = options.stepLength || 60;
      this.length = this.points.length;
      this.delay = 0;
      for (var i = 0; i < this.length; i++) {
        this.points[i].z = this.points[i].z || 0;
      }
      for (var i = 0; i < this.length - 1; i++) {
        var p1 = this.points[i];
        var p2 = this.points[i + 1];
        this.centers.push({
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
          z: (p1.z + p2.z) / 2
        });
      }
      this.controls.push([this.points[0], this.points[0]]);
      for (var i = 0; i < this.centers.length - 1; i++) {
        var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
        var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
        var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
        this.controls.push([
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
          },
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
          }
        ]);
      }
      this.controls.push([
        this.points[this.length - 1],
        this.points[this.length - 1]
      ]);
      this.steps = this.cacheSteps(this.stepLength);
      return this;
    }
    Spline2.prototype.cacheSteps = function(mindist) {
      var steps = [];
      var laststep = this.pos(0);
      steps.push(0);
      for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
          steps.push(t);
          laststep = step;
        }
      }
      return steps;
    };
    Spline2.prototype.vector = function(t) {
      var p1 = this.pos(t + 10);
      var p2 = this.pos(t - 10);
      return {
        angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
      };
    };
    Spline2.prototype.pos = function(time) {
      var t = time - this.delay;
      if (t < 0) {
        t = 0;
      }
      if (t > this.duration) {
        t = this.duration - 1;
      }
      var t2 = t / this.duration;
      if (t2 >= 1) {
        return this.points[this.length - 1];
      }
      var n = Math.floor((this.points.length - 1) * t2);
      var t1 = (this.length - 1) * t2 - n;
      return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    };
    return Spline2;
  }()
);
var spline_default = Spline;
function bezier(t, p1, c1, c2, p2) {
  var b = B(t);
  var pos = {
    x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
    y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
    z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
  };
  return pos;
}
function B(t) {
  var t2 = t * t;
  var t3 = t2 * t;
  return [
    t3,
    3 * t2 * (1 - t),
    3 * t * (1 - t) * (1 - t),
    (1 - t) * (1 - t) * (1 - t)
  ];
}

// node_modules/@turf/bezier-spline/dist/es/index.js
function bezier2(line, options) {
  if (options === void 0) {
    options = {};
  }
  var resolution = options.resolution || 1e4;
  var sharpness = options.sharpness || 0.85;
  var coords = [];
  var points2 = getGeom(line).coordinates.map(function(pt) {
    return { x: pt[0], y: pt[1] };
  });
  var spline = new spline_default({
    duration: resolution,
    points: points2,
    sharpness
  });
  var pushCoord = function(time) {
    var pos = spline.pos(time);
    if (Math.floor(time / 100) % 2 === 0) {
      coords.push([pos.x, pos.y]);
    }
  };
  for (var i = 0; i < spline.duration; i += 10) {
    pushCoord(i);
  }
  pushCoord(spline.duration);
  return lineString(coords, options.properties);
}
var es_default11 = bezier2;

// node_modules/@turf/tag/dist/es/index.js
function tag(points2, polygons2, field, outField) {
  points2 = es_default5(points2);
  polygons2 = es_default5(polygons2);
  featureEach(points2, function(pt) {
    if (!pt.properties)
      pt.properties = {};
    featureEach(polygons2, function(poly) {
      if (pt.properties[outField] === void 0) {
        if (booleanPointInPolygon(pt, poly))
          pt.properties[outField] = poly.properties[field];
      }
    });
  });
  return points2;
}
var es_default12 = tag;

// node_modules/@turf/sample/dist/es/index.js
function sample(featurecollection, num) {
  if (!featurecollection)
    throw new Error("featurecollection is required");
  if (num === null || num === void 0)
    throw new Error("num is required");
  if (typeof num !== "number")
    throw new Error("num must be a number");
  var outFC = featureCollection(
    getRandomSubarray(featurecollection.features, num)
  );
  return outFC;
}
function getRandomSubarray(arr, size11) {
  var shuffled = arr.slice(0), i = arr.length, min4 = i - size11, temp, index2;
  while (i-- > min4) {
    index2 = Math.floor((i + 1) * Math.random());
    temp = shuffled[index2];
    shuffled[index2] = shuffled[i];
    shuffled[i] = temp;
  }
  return shuffled.slice(min4);
}
var es_default13 = sample;

// node_modules/@turf/bbox-polygon/dist/es/index.js
function bboxPolygon(bbox3, options) {
  if (options === void 0) {
    options = {};
  }
  var west = Number(bbox3[0]);
  var south = Number(bbox3[1]);
  var east = Number(bbox3[2]);
  var north = Number(bbox3[3]);
  if (bbox3.length === 6) {
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  }
  var lowLeft = [west, south];
  var topLeft = [west, north];
  var topRight = [east, north];
  var lowRight = [east, south];
  return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox3, id: options.id });
}

// node_modules/@turf/envelope/dist/es/index.js
function envelope(geojson) {
  return bboxPolygon(es_default(geojson));
}
var es_default14 = envelope;

// node_modules/@turf/square/dist/es/index.js
function square(bbox3) {
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  var horizontalDistance = es_default4(bbox3.slice(0, 2), [east, south]);
  var verticalDistance = es_default4(bbox3.slice(0, 2), [west, north]);
  if (horizontalDistance >= verticalDistance) {
    var verticalMidpoint = (south + north) / 2;
    return [
      west,
      verticalMidpoint - (east - west) / 2,
      east,
      verticalMidpoint + (east - west) / 2
    ];
  } else {
    var horizontalMidpoint = (west + east) / 2;
    return [
      horizontalMidpoint - (north - south) / 2,
      south,
      horizontalMidpoint + (north - south) / 2,
      north
    ];
  }
}
var es_default15 = square;

// node_modules/@turf/destination/dist/es/index.js
function destination(origin, distance11, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(origin);
  var longitude1 = degreesToRadians(coordinates1[0]);
  var latitude1 = degreesToRadians(coordinates1[1]);
  var bearingRad = degreesToRadians(bearing2);
  var radians = lengthToRadians(distance11, options.units);
  var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
  var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
  var lng = radiansToDegrees(longitude2);
  var lat2 = radiansToDegrees(latitude2);
  return point([lng, lat2], options.properties);
}

// node_modules/@turf/circle/dist/es/index.js
function circle(center2, radius, options) {
  if (options === void 0) {
    options = {};
  }
  var steps = options.steps || 64;
  var properties = options.properties ? options.properties : !Array.isArray(center2) && center2.type === "Feature" && center2.properties ? center2.properties : {};
  var coordinates = [];
  for (var i = 0; i < steps; i++) {
    coordinates.push(destination(center2, radius, i * -360 / steps, options).geometry.coordinates);
  }
  coordinates.push(coordinates[0]);
  return polygon([coordinates], properties);
}
var es_default16 = circle;

// node_modules/@turf/bearing/dist/es/index.js
function bearing(start, end, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.final === true) {
    return calculateFinalBearing(start, end);
  }
  var coordinates1 = getCoord(start);
  var coordinates2 = getCoord(end);
  var lon1 = degreesToRadians(coordinates1[0]);
  var lon2 = degreesToRadians(coordinates2[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
  var bear = bearing(end, start);
  bear = (bear + 180) % 360;
  return bear;
}

// node_modules/@turf/midpoint/dist/es/index.js
function midpoint(point1, point22) {
  var dist = es_default4(point1, point22);
  var heading = bearing(point1, point22);
  var midpoint2 = destination(point1, dist / 2, heading);
  return midpoint2;
}
var es_default17 = midpoint;

// node_modules/@turf/center/dist/es/index.js
function center(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var ext = es_default(geojson);
  var x2 = (ext[0] + ext[2]) / 2;
  var y2 = (ext[1] + ext[3]) / 2;
  return point([x2, y2], options.properties, options);
}
var es_default18 = center;

// node_modules/@turf/centroid/dist/es/index.js
function centroid(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var xSum = 0;
  var ySum = 0;
  var len = 0;
  coordEach(geojson, function(coord) {
    xSum += coord[0];
    ySum += coord[1];
    len++;
  }, true);
  return point([xSum / len, ySum / len], options.properties);
}
var es_default19 = centroid;

// node_modules/@turf/center-of-mass/dist/es/index.js
function centerOfMass(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  switch (getType(geojson)) {
    case "Point":
      return point(getCoord(geojson), options.properties);
    case "Polygon":
      var coords = [];
      coordEach(geojson, function(coord) {
        coords.push(coord);
      });
      var centre2 = es_default19(geojson, { properties: options.properties });
      var translation = centre2.geometry.coordinates;
      var sx = 0;
      var sy = 0;
      var sArea = 0;
      var i, pi, pj, xi, xj, yi, yj, a;
      var neutralizedPoints = coords.map(function(point4) {
        return [point4[0] - translation[0], point4[1] - translation[1]];
      });
      for (i = 0; i < coords.length - 1; i++) {
        pi = neutralizedPoints[i];
        xi = pi[0];
        yi = pi[1];
        pj = neutralizedPoints[i + 1];
        xj = pj[0];
        yj = pj[1];
        a = xi * yj - xj * yi;
        sArea += a;
        sx += (xi + xj) * a;
        sy += (yi + yj) * a;
      }
      if (sArea === 0) {
        return centre2;
      } else {
        var area5 = sArea * 0.5;
        var areaFactor = 1 / (6 * area5);
        return point([translation[0] + areaFactor * sx, translation[1] + areaFactor * sy], options.properties);
      }
    default:
      var hull = convex(geojson);
      if (hull)
        return centerOfMass(hull, { properties: options.properties });
      else
        return es_default19(geojson, { properties: options.properties });
  }
}
var es_default20 = centerOfMass;

// node_modules/@turf/combine/dist/es/index.js
function combine(fc) {
  var groups = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  featureEach(fc, function(feature2) {
    var _a, _b, _c;
    var _d;
    switch ((_d = feature2.geometry) === null || _d === void 0 ? void 0 : _d.type) {
      case "Point":
        groups.MultiPoint.coordinates.push(feature2.geometry.coordinates);
        groups.MultiPoint.properties.push(feature2.properties);
        break;
      case "MultiPoint":
        (_a = groups.MultiPoint.coordinates).push.apply(_a, feature2.geometry.coordinates);
        groups.MultiPoint.properties.push(feature2.properties);
        break;
      case "LineString":
        groups.MultiLineString.coordinates.push(feature2.geometry.coordinates);
        groups.MultiLineString.properties.push(feature2.properties);
        break;
      case "MultiLineString":
        (_b = groups.MultiLineString.coordinates).push.apply(_b, feature2.geometry.coordinates);
        groups.MultiLineString.properties.push(feature2.properties);
        break;
      case "Polygon":
        groups.MultiPolygon.coordinates.push(feature2.geometry.coordinates);
        groups.MultiPolygon.properties.push(feature2.properties);
        break;
      case "MultiPolygon":
        (_c = groups.MultiPolygon.coordinates).push.apply(_c, feature2.geometry.coordinates);
        groups.MultiPolygon.properties.push(feature2.properties);
        break;
      default:
        break;
    }
  });
  return featureCollection(Object.keys(groups).filter(function(key) {
    return groups[key].coordinates.length;
  }).sort().map(function(key) {
    var geometry2 = { type: key, coordinates: groups[key].coordinates };
    var properties = { collectedProperties: groups[key].properties };
    return feature(geometry2, properties);
  }));
}
var es_default21 = combine;

// node_modules/@turf/explode/dist/es/index.js
function explode(geojson) {
  var points2 = [];
  if (geojson.type === "FeatureCollection") {
    featureEach(geojson, function(feature2) {
      coordEach(feature2, function(coord) {
        points2.push(point(coord, feature2.properties));
      });
    });
  } else {
    coordEach(geojson, function(coord) {
      points2.push(point(coord, geojson.properties));
    });
  }
  return featureCollection(points2);
}
var es_default22 = explode;

// node_modules/@turf/tesselate/dist/es/index.js
var import_earcut = __toESM(require_earcut());
function tesselate(poly) {
  if (!poly.geometry || poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon") {
    throw new Error("input must be a Polygon or MultiPolygon");
  }
  var fc = { type: "FeatureCollection", features: [] };
  if (poly.geometry.type === "Polygon") {
    fc.features = processPolygon(poly.geometry.coordinates);
  } else {
    poly.geometry.coordinates.forEach(function(coordinates) {
      fc.features = fc.features.concat(processPolygon(coordinates));
    });
  }
  return fc;
}
function processPolygon(coordinates) {
  var data = flattenCoords(coordinates);
  var dim = 2;
  var result = (0, import_earcut.default)(data.vertices, data.holes, dim);
  var features = [];
  var vertices = [];
  result.forEach(function(vert, i2) {
    var index2 = result[i2];
    vertices.push([data.vertices[index2 * dim], data.vertices[index2 * dim + 1]]);
  });
  for (var i = 0; i < vertices.length; i += 3) {
    var coords = vertices.slice(i, i + 3);
    coords.push(vertices[i]);
    features.push(polygon([coords]));
  }
  return features;
}
function flattenCoords(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
}
var es_default23 = tesselate;

// node_modules/@turf/nearest-point/dist/es/index.js
function nearestPoint(targetPoint, points2) {
  if (!targetPoint)
    throw new Error("targetPoint is required");
  if (!points2)
    throw new Error("points is required");
  var nearest;
  var minDist = Infinity;
  var bestFeatureIndex = 0;
  featureEach(points2, function(pt, featureIndex) {
    var distanceToPoint = es_default4(targetPoint, pt);
    if (distanceToPoint < minDist) {
      bestFeatureIndex = featureIndex;
      minDist = distanceToPoint;
    }
  });
  nearest = es_default5(points2.features[bestFeatureIndex]);
  nearest.properties.featureIndex = bestFeatureIndex;
  nearest.properties.distanceToPoint = minDist;
  return nearest;
}
var es_default24 = nearestPoint;

// node_modules/@turf/line-segment/dist/es/index.js
function lineSegment(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  var results = [];
  flattenEach(geojson, function(feature2) {
    lineSegmentFeature(feature2, results);
  });
  return featureCollection(results);
}
function lineSegmentFeature(geojson, results) {
  var coords = [];
  var geometry2 = geojson.geometry;
  if (geometry2 !== null) {
    switch (geometry2.type) {
      case "Polygon":
        coords = getCoords(geometry2);
        break;
      case "LineString":
        coords = [getCoords(geometry2)];
    }
    coords.forEach(function(coord) {
      var segments = createSegments(coord, geojson.properties);
      segments.forEach(function(segment) {
        segment.id = results.length;
        results.push(segment);
      });
    });
  }
}
function createSegments(coords, properties) {
  var segments = [];
  coords.reduce(function(previousCoords, currentCoords) {
    var segment = lineString([previousCoords, currentCoords], properties);
    segment.bbox = bbox2(previousCoords, currentCoords);
    segments.push(segment);
    return currentCoords;
  });
  return segments;
}
function bbox2(coords1, coords2) {
  var x1 = coords1[0];
  var y1 = coords1[1];
  var x2 = coords2[0];
  var y2 = coords2[1];
  var west = x1 < x2 ? x1 : x2;
  var south = y1 < y2 ? y1 : y2;
  var east = x1 > x2 ? x1 : x2;
  var north = y1 > y2 ? y1 : y2;
  return [west, south, east, north];
}
var es_default25 = lineSegment;

// node_modules/@turf/line-intersect/dist/es/index.js
var import_geojson_rbush = __toESM(require_geojson_rbush());
function lineIntersect(line1, line2) {
  var unique = {};
  var results = [];
  if (line1.type === "LineString") {
    line1 = feature(line1);
  }
  if (line2.type === "LineString") {
    line2 = feature(line2);
  }
  if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
    var intersect4 = intersects(line1, line2);
    if (intersect4) {
      results.push(intersect4);
    }
    return featureCollection(results);
  }
  var tree = (0, import_geojson_rbush.default)();
  tree.load(es_default25(line2));
  featureEach(es_default25(line1), function(segment) {
    featureEach(tree.search(segment), function(match) {
      var intersect5 = intersects(segment, match);
      if (intersect5) {
        var key = getCoords(intersect5).join(",");
        if (!unique[key]) {
          unique[key] = true;
          results.push(intersect5);
        }
      }
    });
  });
  return featureCollection(results);
}
function intersects(line1, line2) {
  var coords1 = getCoords(line1);
  var coords2 = getCoords(line2);
  if (coords1.length !== 2) {
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  }
  if (coords2.length !== 2) {
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  }
  var x1 = coords1[0][0];
  var y1 = coords1[0][1];
  var x2 = coords1[1][0];
  var y2 = coords1[1][1];
  var x3 = coords2[0][0];
  var y3 = coords2[0][1];
  var x4 = coords2[1][0];
  var y4 = coords2[1][1];
  var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
  var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
  var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
  if (denom === 0) {
    if (numeA === 0 && numeB === 0) {
      return null;
    }
    return null;
  }
  var uA = numeA / denom;
  var uB = numeB / denom;
  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
    var x5 = x1 + uA * (x2 - x1);
    var y5 = y1 + uA * (y2 - y1);
    return point([x5, y5]);
  }
  return null;
}
var es_default26 = lineIntersect;

// node_modules/@turf/nearest-point-on-line/dist/es/index.js
function nearestPointOnLine(lines, pt, options) {
  if (options === void 0) {
    options = {};
  }
  var closestPt = point([Infinity, Infinity], {
    dist: Infinity
  });
  var length4 = 0;
  flattenEach(lines, function(line) {
    var coords = getCoords(line);
    for (var i = 0; i < coords.length - 1; i++) {
      var start = point(coords[i]);
      start.properties.dist = es_default4(pt, start, options);
      var stop_1 = point(coords[i + 1]);
      stop_1.properties.dist = es_default4(pt, stop_1, options);
      var sectionLength = es_default4(start, stop_1, options);
      var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
      var direction = bearing(start, stop_1);
      var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);
      var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);
      var intersect4 = es_default26(lineString([
        perpendicularPt1.geometry.coordinates,
        perpendicularPt2.geometry.coordinates
      ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
      var intersectPt = null;
      if (intersect4.features.length > 0) {
        intersectPt = intersect4.features[0];
        intersectPt.properties.dist = es_default4(pt, intersectPt, options);
        intersectPt.properties.location = length4 + es_default4(start, intersectPt, options);
      }
      if (start.properties.dist < closestPt.properties.dist) {
        closestPt = start;
        closestPt.properties.index = i;
        closestPt.properties.location = length4;
      }
      if (stop_1.properties.dist < closestPt.properties.dist) {
        closestPt = stop_1;
        closestPt.properties.index = i + 1;
        closestPt.properties.location = length4 + sectionLength;
      }
      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
        closestPt = intersectPt;
        closestPt.properties.index = i;
      }
      length4 += sectionLength;
    }
  });
  return closestPt;
}
var es_default27 = nearestPointOnLine;

// node_modules/@turf/rhumb-distance/dist/es/index.js
function rhumbDistance(from, to, options) {
  if (options === void 0) {
    options = {};
  }
  var origin = getCoord(from);
  var destination2 = getCoord(to);
  destination2[0] += destination2[0] - origin[0] > 180 ? -360 : origin[0] - destination2[0] > 180 ? 360 : 0;
  var distanceInMeters = calculateRhumbDistance(origin, destination2);
  var distance11 = convertLength(distanceInMeters, "meters", options.units);
  return distance11;
}
function calculateRhumbDistance(origin, destination2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  var R = radius;
  var phi1 = origin[1] * Math.PI / 180;
  var phi2 = destination2[1] * Math.PI / 180;
  var DeltaPhi = phi2 - phi1;
  var DeltaLambda = Math.abs(destination2[0] - origin[0]) * Math.PI / 180;
  if (DeltaLambda > Math.PI) {
    DeltaLambda -= 2 * Math.PI;
  }
  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda);
  var dist = delta * R;
  return dist;
}
var es_default28 = rhumbDistance;

// node_modules/@turf/point-to-line-distance/dist/es/index.js
function pointToLineDistance(pt, line, options) {
  if (options === void 0) {
    options = {};
  }
  if (!options.method) {
    options.method = "geodesic";
  }
  if (!options.units) {
    options.units = "kilometers";
  }
  if (!pt) {
    throw new Error("pt is required");
  }
  if (Array.isArray(pt)) {
    pt = point(pt);
  } else if (pt.type === "Point") {
    pt = feature(pt);
  } else {
    featureOf(pt, "Point", "point");
  }
  if (!line) {
    throw new Error("line is required");
  }
  if (Array.isArray(line)) {
    line = lineString(line);
  } else if (line.type === "LineString") {
    line = feature(line);
  } else {
    featureOf(line, "LineString", "line");
  }
  var distance11 = Infinity;
  var p = pt.geometry.coordinates;
  segmentEach(line, function(segment) {
    var a = segment.geometry.coordinates[0];
    var b = segment.geometry.coordinates[1];
    var d = distanceToSegment(p, a, b, options);
    if (d < distance11) {
      distance11 = d;
    }
  });
  return convertLength(distance11, "degrees", options.units);
}
function distanceToSegment(p, a, b, options) {
  var v = [b[0] - a[0], b[1] - a[1]];
  var w = [p[0] - a[0], p[1] - a[1]];
  var c1 = dot(w, v);
  if (c1 <= 0) {
    return calcDistance(p, a, { method: options.method, units: "degrees" });
  }
  var c2 = dot(v, v);
  if (c2 <= c1) {
    return calcDistance(p, b, { method: options.method, units: "degrees" });
  }
  var b2 = c1 / c2;
  var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
  return calcDistance(p, Pb, { method: options.method, units: "degrees" });
}
function dot(u, v) {
  return u[0] * v[0] + u[1] * v[1];
}
function calcDistance(a, b, options) {
  return options.method === "planar" ? es_default28(a, b, options) : es_default4(a, b, options);
}
var es_default29 = pointToLineDistance;

// node_modules/@turf/nearest-point-to-line/dist/es/index.js
var import_object_assign2 = __toESM(require_object_assign());
function nearestPointToLine(points2, line, options) {
  if (options === void 0) {
    options = {};
  }
  var units = options.units;
  var properties = options.properties || {};
  var pts = normalize(points2);
  if (!pts.features.length) {
    throw new Error("points must contain features");
  }
  if (!line) {
    throw new Error("line is required");
  }
  if (getType(line) !== "LineString") {
    throw new Error("line must be a LineString");
  }
  var dist = Infinity;
  var pt = null;
  featureEach(pts, function(point4) {
    var d = es_default29(point4, line, { units });
    if (d < dist) {
      dist = d;
      pt = point4;
    }
  });
  if (pt) {
    pt.properties = (0, import_object_assign2.default)({ dist }, pt.properties, properties);
  }
  return pt;
}
function normalize(points2) {
  var features = [];
  var type = points2.geometry ? points2.geometry.type : points2.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(points2, function(geom) {
        if (geom.type === "Point") {
          features.push({ type: "Feature", properties: {}, geometry: geom });
        }
      });
      return { type: "FeatureCollection", features };
    case "FeatureCollection":
      points2.features = points2.features.filter(function(feature2) {
        return feature2.geometry.type === "Point";
      });
      return points2;
    default:
      throw new Error("points must be a Point Collection");
  }
}
var es_default30 = nearestPointToLine;

// node_modules/@turf/planepoint/dist/es/index.js
function planepoint(point4, triangle) {
  var coord = getCoord(point4);
  var geom = getGeom(triangle);
  var coords = geom.coordinates;
  var outer = coords[0];
  if (outer.length < 4)
    throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
  var properties = triangle.properties || {};
  var a = properties.a;
  var b = properties.b;
  var c = properties.c;
  var x2 = coord[0];
  var y2 = coord[1];
  var x1 = outer[0][0];
  var y1 = outer[0][1];
  var z1 = a !== void 0 ? a : outer[0][2];
  var x22 = outer[1][0];
  var y22 = outer[1][1];
  var z2 = b !== void 0 ? b : outer[1][2];
  var x3 = outer[2][0];
  var y3 = outer[2][1];
  var z3 = c !== void 0 ? c : outer[2][2];
  var z = (z3 * (x2 - x1) * (y2 - y22) + z1 * (x2 - x22) * (y2 - y3) + z2 * (x2 - x3) * (y2 - y1) - z2 * (x2 - x1) * (y2 - y3) - z3 * (x2 - x22) * (y2 - y1) - z1 * (x2 - x3) * (y2 - y22)) / ((x2 - x1) * (y2 - y22) + (x2 - x22) * (y2 - y3) + (x2 - x3) * (y2 - y1) - (x2 - x1) * (y2 - y3) - (x2 - x22) * (y2 - y1) - (x2 - x3) * (y2 - y22));
  return z;
}
var es_default31 = planepoint;

// node_modules/@turf/kinks/dist/es/index.js
function kinks(featureIn) {
  var coordinates;
  var feature2;
  var results = {
    type: "FeatureCollection",
    features: []
  };
  if (featureIn.type === "Feature") {
    feature2 = featureIn.geometry;
  } else {
    feature2 = featureIn;
  }
  if (feature2.type === "LineString") {
    coordinates = [feature2.coordinates];
  } else if (feature2.type === "MultiLineString") {
    coordinates = feature2.coordinates;
  } else if (feature2.type === "MultiPolygon") {
    coordinates = [].concat.apply([], feature2.coordinates);
  } else if (feature2.type === "Polygon") {
    coordinates = feature2.coordinates;
  } else {
    throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
  }
  coordinates.forEach(function(line1) {
    coordinates.forEach(function(line2) {
      for (var i = 0; i < line1.length - 1; i++) {
        for (var k = i; k < line2.length - 1; k++) {
          if (line1 === line2) {
            if (Math.abs(i - k) === 1) {
              continue;
            }
            if (
              // segments are first and last segment of lineString
              i === 0 && k === line1.length - 2 && // lineString is closed
              line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]
            ) {
              continue;
            }
          }
          var intersection12 = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
          if (intersection12) {
            results.features.push(point([intersection12[0], intersection12[1]]));
          }
        }
      }
    });
  });
  return results;
}
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  var denominator;
  var a;
  var b;
  var numerator1;
  var numerator2;
  var result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
  if (denominator === 0) {
    if (result.x !== null && result.y !== null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
  a = numerator1 / denominator;
  b = numerator2 / denominator;
  result.x = line1StartX + a * (line1EndX - line1StartX);
  result.y = line1StartY + a * (line1EndY - line1StartY);
  if (a >= 0 && a <= 1) {
    result.onLine1 = true;
  }
  if (b >= 0 && b <= 1) {
    result.onLine2 = true;
  }
  if (result.onLine1 && result.onLine2) {
    return [result.x, result.y];
  } else {
    return false;
  }
}

// node_modules/@turf/point-on-feature/dist/es/index.js
function pointOnFeature(geojson) {
  var fc = normalize2(geojson);
  var cent = es_default18(fc);
  var onSurface = false;
  var i = 0;
  while (!onSurface && i < fc.features.length) {
    var geom = fc.features[i].geometry;
    var x2, y2, x1, y1, x22, y22, k;
    var onLine = false;
    if (geom.type === "Point") {
      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
        onSurface = true;
      }
    } else if (geom.type === "MultiPoint") {
      var onMultiPoint = false;
      k = 0;
      while (!onMultiPoint && k < geom.coordinates.length) {
        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
          onSurface = true;
          onMultiPoint = true;
        }
        k++;
      }
    } else if (geom.type === "LineString") {
      k = 0;
      while (!onLine && k < geom.coordinates.length - 1) {
        x2 = cent.geometry.coordinates[0];
        y2 = cent.geometry.coordinates[1];
        x1 = geom.coordinates[k][0];
        y1 = geom.coordinates[k][1];
        x22 = geom.coordinates[k + 1][0];
        y22 = geom.coordinates[k + 1][1];
        if (pointOnSegment(x2, y2, x1, y1, x22, y22)) {
          onLine = true;
          onSurface = true;
        }
        k++;
      }
    } else if (geom.type === "MultiLineString") {
      var j = 0;
      while (j < geom.coordinates.length) {
        onLine = false;
        k = 0;
        var line = geom.coordinates[j];
        while (!onLine && k < line.length - 1) {
          x2 = cent.geometry.coordinates[0];
          y2 = cent.geometry.coordinates[1];
          x1 = line[k][0];
          y1 = line[k][1];
          x22 = line[k + 1][0];
          y22 = line[k + 1][1];
          if (pointOnSegment(x2, y2, x1, y1, x22, y22)) {
            onLine = true;
            onSurface = true;
          }
          k++;
        }
        j++;
      }
    } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
      if (booleanPointInPolygon(cent, geom)) {
        onSurface = true;
      }
    }
    i++;
  }
  if (onSurface) {
    return cent;
  } else {
    var vertices = featureCollection([]);
    for (i = 0; i < fc.features.length; i++) {
      vertices.features = vertices.features.concat(
        es_default22(fc.features[i]).features
      );
    }
    return point(es_default24(cent, vertices).geometry.coordinates);
  }
}
function normalize2(geojson) {
  if (geojson.type !== "FeatureCollection") {
    if (geojson.type !== "Feature") {
      return featureCollection([feature(geojson)]);
    }
    return featureCollection([geojson]);
  }
  return geojson;
}
function pointOnSegment(x2, y2, x1, y1, x22, y22) {
  var ab2 = Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
  var ap = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  var pb = Math.sqrt((x22 - x2) * (x22 - x2) + (y22 - y2) * (y22 - y2));
  return ab2 === ap + pb;
}
var es_default32 = pointOnFeature;

// node_modules/@turf/area/dist/es/index.js
var RADIUS = 6378137;
function area(geojson) {
  return geomReduce(geojson, function(value, geom) {
    return value + calculateArea(geom);
  }, 0);
}
function calculateArea(geom) {
  var total = 0;
  var i;
  switch (geom.type) {
    case "Polygon":
      return polygonArea(geom.coordinates);
    case "MultiPolygon":
      for (i = 0; i < geom.coordinates.length; i++) {
        total += polygonArea(geom.coordinates[i]);
      }
      return total;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function polygonArea(coords) {
  var total = 0;
  if (coords && coords.length > 0) {
    total += Math.abs(ringArea(coords[0]));
    for (var i = 1; i < coords.length; i++) {
      total -= Math.abs(ringArea(coords[i]));
    }
  }
  return total;
}
function ringArea(coords) {
  var p1;
  var p2;
  var p3;
  var lowerIndex;
  var middleIndex;
  var upperIndex;
  var i;
  var total = 0;
  var coordsLength = coords.length;
  if (coordsLength > 2) {
    for (i = 0; i < coordsLength; i++) {
      if (i === coordsLength - 2) {
        lowerIndex = coordsLength - 2;
        middleIndex = coordsLength - 1;
        upperIndex = 0;
      } else if (i === coordsLength - 1) {
        lowerIndex = coordsLength - 1;
        middleIndex = 0;
        upperIndex = 1;
      } else {
        lowerIndex = i;
        middleIndex = i + 1;
        upperIndex = i + 2;
      }
      p1 = coords[lowerIndex];
      p2 = coords[middleIndex];
      p3 = coords[upperIndex];
      total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
    }
    total = total * RADIUS * RADIUS / 2;
  }
  return total;
}
function rad(num) {
  return num * Math.PI / 180;
}

// node_modules/@turf/along/dist/es/index.js
function along(line, distance11, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(line);
  var coords = geom.coordinates;
  var travelled = 0;
  for (var i = 0; i < coords.length; i++) {
    if (distance11 >= travelled && i === coords.length - 1) {
      break;
    } else if (travelled >= distance11) {
      var overshot = distance11 - travelled;
      if (!overshot) {
        return point(coords[i]);
      } else {
        var direction = bearing(coords[i], coords[i - 1]) - 180;
        var interpolated = destination(coords[i], overshot, direction, options);
        return interpolated;
      }
    } else {
      travelled += es_default4(coords[i], coords[i + 1], options);
    }
  }
  return point(coords[coords.length - 1]);
}

// node_modules/@turf/length/dist/es/index.js
function length(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return segmentReduce(geojson, function(previousValue, segment) {
    var coords = segment.geometry.coordinates;
    return previousValue + es_default4(coords[0], coords[1], options);
  }, 0);
}

// node_modules/@turf/line-slice/dist/es/index.js
function lineSlice(startPt, stopPt, line) {
  var coords = getCoords(line);
  if (getType(line) !== "LineString")
    throw new Error("line must be a LineString");
  var startVertex = es_default27(line, startPt);
  var stopVertex = es_default27(line, stopPt);
  var ends;
  if (startVertex.properties.index <= stopVertex.properties.index) {
    ends = [startVertex, stopVertex];
  } else {
    ends = [stopVertex, startVertex];
  }
  var clipCoords = [ends[0].geometry.coordinates];
  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
    clipCoords.push(coords[i]);
  }
  clipCoords.push(ends[1].geometry.coordinates);
  return lineString(clipCoords, line.properties);
}
var es_default33 = lineSlice;

// node_modules/@turf/line-slice-along/dist/es/index.js
function lineSliceAlong(line, startDist, stopDist, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var coords;
  var slice = [];
  if (line.type === "Feature")
    coords = line.geometry.coordinates;
  else if (line.type === "LineString")
    coords = line.coordinates;
  else
    throw new Error("input must be a LineString Feature or Geometry");
  var origCoordsLength = coords.length;
  var travelled = 0;
  var overshot, direction, interpolated;
  for (var i = 0; i < coords.length; i++) {
    if (startDist >= travelled && i === coords.length - 1)
      break;
    else if (travelled > startDist && slice.length === 0) {
      overshot = startDist - travelled;
      if (!overshot) {
        slice.push(coords[i]);
        return lineString(slice);
      }
      direction = bearing(coords[i], coords[i - 1]) - 180;
      interpolated = destination(coords[i], overshot, direction, options);
      slice.push(interpolated.geometry.coordinates);
    }
    if (travelled >= stopDist) {
      overshot = stopDist - travelled;
      if (!overshot) {
        slice.push(coords[i]);
        return lineString(slice);
      }
      direction = bearing(coords[i], coords[i - 1]) - 180;
      interpolated = destination(coords[i], overshot, direction, options);
      slice.push(interpolated.geometry.coordinates);
      return lineString(slice);
    }
    if (travelled >= startDist) {
      slice.push(coords[i]);
    }
    if (i === coords.length - 1) {
      return lineString(slice);
    }
    travelled += es_default4(coords[i], coords[i + 1], options);
  }
  if (travelled < startDist && coords.length === origCoordsLength)
    throw new Error("Start position is beyond line");
  var last = coords[coords.length - 1];
  return lineString([last, last]);
}
var es_default34 = lineSliceAlong;

// node_modules/@turf/boolean-point-on-line/dist/es/index.js
function booleanPointOnLine(pt, line, options) {
  if (options === void 0) {
    options = {};
  }
  var ptCoords = getCoord(pt);
  var lineCoords = getCoords(line);
  for (var i = 0; i < lineCoords.length - 1; i++) {
    var ignoreBoundary = false;
    if (options.ignoreEndVertices) {
      if (i === 0) {
        ignoreBoundary = "start";
      }
      if (i === lineCoords.length - 2) {
        ignoreBoundary = "end";
      }
      if (i === 0 && i + 1 === lineCoords.length - 1) {
        ignoreBoundary = "both";
      }
    }
    if (isPointOnLineSegment2(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
      return true;
    }
  }
  return false;
}
function isPointOnLineSegment2(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon4) {
  var x2 = pt[0];
  var y2 = pt[1];
  var x1 = lineSegmentStart[0];
  var y1 = lineSegmentStart[1];
  var x22 = lineSegmentEnd[0];
  var y22 = lineSegmentEnd[1];
  var dxc = pt[0] - x1;
  var dyc = pt[1] - y1;
  var dxl = x22 - x1;
  var dyl = y22 - y1;
  var cross = dxc * dyl - dyc * dxl;
  if (epsilon4 !== null) {
    if (Math.abs(cross) > epsilon4) {
      return false;
    }
  } else if (cross !== 0) {
    return false;
  }
  if (!excludeBoundary) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x1 <= x2 && x2 <= x22 : x22 <= x2 && x2 <= x1;
    }
    return dyl > 0 ? y1 <= y2 && y2 <= y22 : y22 <= y2 && y2 <= y1;
  } else if (excludeBoundary === "start") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x1 < x2 && x2 <= x22 : x22 <= x2 && x2 < x1;
    }
    return dyl > 0 ? y1 < y2 && y2 <= y22 : y22 <= y2 && y2 < y1;
  } else if (excludeBoundary === "end") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x1 <= x2 && x2 < x22 : x22 < x2 && x2 <= x1;
    }
    return dyl > 0 ? y1 <= y2 && y2 < y22 : y22 < y2 && y2 <= y1;
  } else if (excludeBoundary === "both") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x1 < x2 && x2 < x22 : x22 < x2 && x2 < x1;
    }
    return dyl > 0 ? y1 < y2 && y2 < y22 : y22 < y2 && y2 < y1;
  }
  return false;
}
var es_default35 = booleanPointOnLine;

// node_modules/@turf/boolean-within/dist/es/index.js
function booleanWithin(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "MultiPoint":
          return isPointInMultiPoint(geom1, geom2);
        case "LineString":
          return es_default35(geom1, geom2, { ignoreEndVertices: true });
        case "Polygon":
        case "MultiPolygon":
          return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "MultiPoint":
          return isMultiPointInMultiPoint(geom1, geom2);
        case "LineString":
          return isMultiPointOnLine(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isMultiPointInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "LineString":
          return isLineOnLine(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isLineInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Polygon":
        case "MultiPolygon":
          return isPolyInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPointInMultiPoint(point4, multiPoint2) {
  var i;
  var output = false;
  for (i = 0; i < multiPoint2.coordinates.length; i++) {
    if (compareCoords(multiPoint2.coordinates[i], point4.coordinates)) {
      output = true;
      break;
    }
  }
  return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
  for (var i = 0; i < multiPoint1.coordinates.length; i++) {
    var anyMatch = false;
    for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
      if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
        anyMatch = true;
      }
    }
    if (!anyMatch) {
      return false;
    }
  }
  return true;
}
function isMultiPointOnLine(multiPoint2, lineString2) {
  var foundInsidePoint = false;
  for (var i = 0; i < multiPoint2.coordinates.length; i++) {
    if (!es_default35(multiPoint2.coordinates[i], lineString2)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = es_default35(multiPoint2.coordinates[i], lineString2, { ignoreEndVertices: true });
    }
  }
  return foundInsidePoint;
}
function isMultiPointInPoly(multiPoint2, polygon4) {
  var output = true;
  var oneInside = false;
  var isInside3 = false;
  for (var i = 0; i < multiPoint2.coordinates.length; i++) {
    isInside3 = booleanPointInPolygon(multiPoint2.coordinates[1], polygon4);
    if (!isInside3) {
      output = false;
      break;
    }
    if (!oneInside) {
      isInside3 = booleanPointInPolygon(multiPoint2.coordinates[1], polygon4, {
        ignoreBoundary: true
      });
    }
  }
  return output && isInside3;
}
function isLineOnLine(lineString1, lineString2) {
  for (var i = 0; i < lineString1.coordinates.length; i++) {
    if (!es_default35(lineString1.coordinates[i], lineString2)) {
      return false;
    }
  }
  return true;
}
function isLineInPoly(linestring3, polygon4) {
  var polyBbox = es_default(polygon4);
  var lineBbox = es_default(linestring3);
  if (!doBBoxOverlap(polyBbox, lineBbox)) {
    return false;
  }
  var foundInsidePoint = false;
  for (var i = 0; i < linestring3.coordinates.length - 1; i++) {
    if (!booleanPointInPolygon(linestring3.coordinates[i], polygon4)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = booleanPointInPolygon(linestring3.coordinates[i], polygon4, { ignoreBoundary: true });
    }
    if (!foundInsidePoint) {
      var midpoint2 = getMidpoint(linestring3.coordinates[i], linestring3.coordinates[i + 1]);
      foundInsidePoint = booleanPointInPolygon(midpoint2, polygon4, {
        ignoreBoundary: true
      });
    }
  }
  return foundInsidePoint;
}
function isPolyInPoly(geometry1, geometry2) {
  var poly1Bbox = es_default(geometry1);
  var poly2Bbox = es_default(geometry2);
  if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
    return false;
  }
  for (var i = 0; i < geometry1.coordinates[0].length; i++) {
    if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {
      return false;
    }
  }
  return true;
}
function doBBoxOverlap(bbox1, bbox22) {
  if (bbox1[0] > bbox22[0])
    return false;
  if (bbox1[2] < bbox22[2])
    return false;
  if (bbox1[1] > bbox22[1])
    return false;
  if (bbox1[3] < bbox22[3])
    return false;
  return true;
}
function compareCoords(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
var es_default36 = booleanWithin;

// node_modules/@turf/point-grid/dist/es/index.js
function pointGrid(bbox3, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.mask && !options.units)
    options.units = "kilometers";
  var results = [];
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  var xFraction = cellSide / es_default4([west, south], [east, south], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = cellSide / es_default4([west, south], [west, north], options);
  var cellHeight = yFraction * (north - south);
  var bboxWidth = east - west;
  var bboxHeight = north - south;
  var columns = Math.floor(bboxWidth / cellWidth);
  var rows = Math.floor(bboxHeight / cellHeight);
  var deltaX = (bboxWidth - columns * cellWidth) / 2;
  var deltaY = (bboxHeight - rows * cellHeight) / 2;
  var currentX = west + deltaX;
  while (currentX <= east) {
    var currentY = south + deltaY;
    while (currentY <= north) {
      var cellPt = point([currentX, currentY], options.properties);
      if (options.mask) {
        if (es_default36(cellPt, options.mask))
          results.push(cellPt);
      } else {
        results.push(cellPt);
      }
      currentY += cellHeight;
    }
    currentX += cellWidth;
  }
  return featureCollection(results);
}
var es_default37 = pointGrid;

// node_modules/@turf/truncate/dist/es/index.js
function truncate(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var precision = options.precision;
  var coordinates = options.coordinates;
  var mutate = options.mutate;
  precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
  coordinates = coordinates === void 0 || coordinates === null || isNaN(coordinates) ? 3 : coordinates;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof precision !== "number")
    throw new Error("<precision> must be a number");
  if (typeof coordinates !== "number")
    throw new Error("<coordinates> must be a number");
  if (mutate === false || mutate === void 0)
    geojson = JSON.parse(JSON.stringify(geojson));
  var factor = Math.pow(10, precision);
  coordEach(geojson, function(coords) {
    truncateCoords(coords, factor, coordinates);
  });
  return geojson;
}
function truncateCoords(coords, factor, coordinates) {
  if (coords.length > coordinates)
    coords.splice(coordinates, coords.length);
  for (var i = 0; i < coords.length; i++) {
    coords[i] = Math.round(coords[i] * factor) / factor;
  }
  return coords;
}
var es_default38 = truncate;

// node_modules/@turf/flatten/dist/es/index.js
function flatten(geojson) {
  if (!geojson)
    throw new Error("geojson is required");
  var results = [];
  flattenEach(geojson, function(feature2) {
    results.push(feature2);
  });
  return featureCollection(results);
}
var es_default39 = flatten;

// node_modules/@turf/line-chunk/dist/es/index.js
function lineChunk(geojson, segmentLength, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var units = options.units;
  var reverse5 = options.reverse;
  if (!geojson)
    throw new Error("geojson is required");
  if (segmentLength <= 0)
    throw new Error("segmentLength must be greater than 0");
  var results = [];
  flattenEach(geojson, function(feature2) {
    if (reverse5)
      feature2.geometry.coordinates = feature2.geometry.coordinates.reverse();
    sliceLineSegments(feature2, segmentLength, units, function(segment) {
      results.push(segment);
    });
  });
  return featureCollection(results);
}
function sliceLineSegments(line, segmentLength, units, callback) {
  var lineLength = length(line, { units });
  if (lineLength <= segmentLength)
    return callback(line);
  var numberOfSegments = lineLength / segmentLength;
  if (!Number.isInteger(numberOfSegments)) {
    numberOfSegments = Math.floor(numberOfSegments) + 1;
  }
  for (var i = 0; i < numberOfSegments; i++) {
    var outline = es_default34(
      line,
      segmentLength * i,
      segmentLength * (i + 1),
      { units }
    );
    callback(outline, i);
  }
}
var es_default40 = lineChunk;

// node_modules/@turf/unkink-polygon/dist/es/index.js
var import_rbush2 = __toESM(require_rbush2());
function isects(feature2, filterFn, useSpatialIndex) {
  if (feature2.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  if (useSpatialIndex === void 0)
    useSpatialIndex = 1;
  var coord = feature2.geometry.coordinates;
  var output = [];
  var seen = {};
  if (useSpatialIndex) {
    var allEdgesAsRbushTreeItems = [];
    for (var ring0 = 0; ring0 < coord.length; ring0++) {
      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
      }
    }
    var tree = (0, import_rbush2.default)();
    tree.load(allEdgesAsRbushTreeItems);
  }
  for (var ringA = 0; ringA < coord.length; ringA++) {
    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {
      if (useSpatialIndex) {
        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
        bboxOverlaps.forEach(function(bboxIsect) {
          var ring12 = bboxIsect.ring;
          var edge12 = bboxIsect.edge;
          ifIsectAddToOutput(ringA, edgeA, ring12, edge12);
        });
      } else {
        for (var ring1 = 0; ring1 < coord.length; ring1++) {
          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
          }
        }
      }
    }
  }
  if (!filterFn)
    output = {
      type: "Feature",
      geometry: { type: "MultiPoint", coordinates: output }
    };
  return output;
  function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {
    var start0 = coord[ring02][edge02];
    var end0 = coord[ring02][edge02 + 1];
    var start1 = coord[ring12][edge12];
    var end1 = coord[ring12][edge12 + 1];
    var isect = intersect(start0, end0, start1, end1);
    if (isect === null)
      return;
    var frac0;
    var frac1;
    if (end0[0] !== start0[0]) {
      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
    } else {
      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
    }
    if (end1[0] !== start1[0]) {
      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
    } else {
      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
    }
    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0)
      return;
    var key = isect;
    var unique = !seen[key];
    if (unique) {
      seen[key] = true;
    }
    if (filterFn) {
      output.push(
        filterFn(
          isect,
          ring02,
          edge02,
          start0,
          end0,
          frac0,
          ring12,
          edge12,
          start1,
          end1,
          frac1,
          unique
        )
      );
    } else {
      output.push(isect);
    }
  }
  function rbushTreeItem(ring, edge) {
    var start = coord[ring][edge];
    var end = coord[ring][edge + 1];
    var minX2;
    var maxX2;
    var minY2;
    var maxY2;
    if (start[0] < end[0]) {
      minX2 = start[0];
      maxX2 = end[0];
    } else {
      minX2 = end[0];
      maxX2 = start[0];
    }
    if (start[1] < end[1]) {
      minY2 = start[1];
      maxY2 = end[1];
    } else {
      minY2 = end[1];
      maxY2 = start[1];
    }
    return {
      minX: minX2,
      minY: minY2,
      maxX: maxX2,
      maxY: maxY2,
      ring,
      edge
    };
  }
}
function intersect(start0, end0, start1, end1) {
  if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1))
    return null;
  var x0 = start0[0], y0 = start0[1], x1 = end0[0], y1 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
  var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
  if (denom === 0)
    return null;
  var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
  var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
  return [x4, y4];
}
function equalArrays(array1, array2) {
  if (!array1 || !array2)
    return false;
  if (array1.length !== array2.length)
    return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays(array1[i], array2[i]))
        return false;
    } else if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function simplepolygon(feature2) {
  if (feature2.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (feature2.geometry === void 0 || feature2.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (feature2.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  var numRings = feature2.geometry.coordinates.length;
  var vertices = [];
  for (var i = 0; i < numRings; i++) {
    var ring = feature2.geometry.coordinates[i];
    if (!equalArrays$1(ring[0], ring[ring.length - 1])) {
      ring.push(ring[0]);
    }
    vertices.push.apply(vertices, ring.slice(0, ring.length - 1));
  }
  if (!isUnique(vertices))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var numvertices = vertices.length;
  var selfIsectsData = isects(
    feature2,
    function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
      return [
        isect,
        ring0,
        edge0,
        start0,
        end0,
        frac0,
        ring1,
        edge1,
        start1,
        end1,
        frac1,
        unique
      ];
    }
  );
  var numSelfIsect = selfIsectsData.length;
  if (numSelfIsect == 0) {
    var outputFeatureArray = [];
    for (var i = 0; i < numRings; i++) {
      outputFeatureArray.push(
        polygon([feature2.geometry.coordinates[i]], {
          parent: -1,
          winding: windingOfRing(feature2.geometry.coordinates[i])
        })
      );
    }
    var output = featureCollection(outputFeatureArray);
    determineParents();
    setNetWinding();
    return output;
  }
  var pseudoVtxListByRingAndEdge = [];
  var isectList = [];
  for (var i = 0; i < numRings; i++) {
    pseudoVtxListByRingAndEdge.push([]);
    for (var j = 0; j < feature2.geometry.coordinates[i].length - 1; j++) {
      pseudoVtxListByRingAndEdge[i].push([
        new PseudoVtx(
          feature2.geometry.coordinates[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          1,
          [i, j],
          [i, modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          void 0
        )
      ]);
      isectList.push(
        new Isect(
          feature2.geometry.coordinates[i][j],
          [i, modulo(j - 1, feature2.geometry.coordinates[i].length - 1)],
          [i, j],
          void 0,
          void 0,
          false,
          true
        )
      );
    }
  }
  for (var i = 0; i < numSelfIsect; i++) {
    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(
      new PseudoVtx(
        selfIsectsData[i][0],
        selfIsectsData[i][5],
        [selfIsectsData[i][1], selfIsectsData[i][2]],
        [selfIsectsData[i][6], selfIsectsData[i][7]],
        void 0
      )
    );
    if (selfIsectsData[i][11])
      isectList.push(
        new Isect(
          selfIsectsData[i][0],
          [selfIsectsData[i][1], selfIsectsData[i][2]],
          [selfIsectsData[i][6], selfIsectsData[i][7]],
          void 0,
          void 0,
          true,
          true
        )
      );
  }
  var numIsect = isectList.length;
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {
        return a.param < b.param ? -1 : 1;
      });
    }
  }
  var allIsectsAsIsectRbushTreeItem = [];
  for (var i = 0; i < numIsect; i++) {
    allIsectsAsIsectRbushTreeItem.push({
      minX: isectList[i].coord[0],
      minY: isectList[i].coord[1],
      maxX: isectList[i].coord[0],
      maxY: isectList[i].coord[1],
      index: i
    });
  }
  var isectRbushTree = (0, import_rbush2.default)();
  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind;
        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
          coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)][0].coord;
        } else {
          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
        }
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
      }
    }
  }
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        var l = IsectRbushTreeItemFound.index;
        if (l < numvertices) {
          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
        } else {
          if (equalArrays$1(
            isectList[l].ringAndEdge1,
            pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn
          )) {
            isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          } else {
            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          }
        }
      }
    }
  }
  var queue = [];
  var i = 0;
  for (var j = 0; j < numRings; j++) {
    var leftIsect = i;
    for (var k = 0; k < feature2.geometry.coordinates[j].length - 1; k++) {
      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
        leftIsect = i;
      }
      i++;
    }
    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
    for (var k = 0; k < isectList.length; k++) {
      if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
        var isectBeforeLeftIsect = k;
        break;
      }
    }
    var windingAtIsect = isConvex(
      [
        isectList[isectBeforeLeftIsect].coord,
        isectList[leftIsect].coord,
        isectList[isectAfterLeftIsect].coord
      ],
      true
    ) ? 1 : -1;
    queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
  }
  queue.sort(function(a, b) {
    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
  });
  var outputFeatureArray = [];
  while (queue.length > 0) {
    var popped = queue.pop();
    var startIsect = popped.isect;
    var currentOutputRingParent = popped.parent;
    var currentOutputRingWinding = popped.winding;
    var currentOutputRing = outputFeatureArray.length;
    var currentOutputRingCoords = [isectList[startIsect].coord];
    var currentIsect = startIsect;
    if (isectList[startIsect].ringAndEdge1Walkable) {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
    } else {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
    }
    while (!equalArrays$1(isectList[startIsect].coord, isectList[nxtIsect].coord)) {
      currentOutputRingCoords.push(isectList[nxtIsect].coord);
      var nxtIsectInQueue = void 0;
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].isect == nxtIsect) {
          nxtIsectInQueue = i;
          break;
        }
      }
      if (nxtIsectInQueue != void 0) {
        queue.splice(nxtIsectInQueue, 1);
      }
      if (equalArrays$1(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
        isectList[nxtIsect].ringAndEdge2Walkable = false;
        if (isectList[nxtIsect].ringAndEdge1Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
      } else {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
        isectList[nxtIsect].ringAndEdge1Walkable = false;
        if (isectList[nxtIsect].ringAndEdge2Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
      }
    }
    currentOutputRingCoords.push(isectList[nxtIsect].coord);
    outputFeatureArray.push(
      polygon([currentOutputRingCoords], {
        index: currentOutputRing,
        parent: currentOutputRingParent,
        winding: currentOutputRingWinding,
        netWinding: void 0
      })
    );
  }
  var output = featureCollection(outputFeatureArray);
  determineParents();
  setNetWinding();
  function determineParents() {
    var featuresWithoutParent = [];
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1)
        featuresWithoutParent.push(i2);
    }
    if (featuresWithoutParent.length > 1) {
      for (var i2 = 0; i2 < featuresWithoutParent.length; i2++) {
        var parent = -1;
        var parentArea = Infinity;
        for (var j2 = 0; j2 < output.features.length; j2++) {
          if (featuresWithoutParent[i2] == j2)
            continue;
          if (booleanPointInPolygon(
            output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0],
            output.features[j2],
            { ignoreBoundary: true }
          )) {
            if (area(output.features[j2]) < parentArea) {
              parent = j2;
            }
          }
        }
        output.features[featuresWithoutParent[i2]].properties.parent = parent;
      }
    }
  }
  function setNetWinding() {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1) {
        var netWinding = output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  function setNetWindingOfChildren(parent, ParentNetWinding) {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == parent) {
        var netWinding = ParentNetWinding + output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  return output;
}
var PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
  this.coord = coord;
  this.param = param;
  this.ringAndEdgeIn = ringAndEdgeIn;
  this.ringAndEdgeOut = ringAndEdgeOut;
  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;
};
var Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
  this.coord = coord;
  this.ringAndEdge1 = ringAndEdge1;
  this.ringAndEdge2 = ringAndEdge2;
  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;
  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;
  this.ringAndEdge1Walkable = ringAndEdge1Walkable;
  this.ringAndEdge2Walkable = ringAndEdge2Walkable;
};
function isConvex(pts, righthanded) {
  if (typeof righthanded === "undefined")
    righthanded = true;
  if (pts.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
  return d >= 0 == righthanded;
}
function windingOfRing(ring) {
  var leftVtx = 0;
  for (var i = 0; i < ring.length - 1; i++) {
    if (ring[i][0] < ring[leftVtx][0])
      leftVtx = i;
  }
  if (isConvex(
    [
      ring[modulo(leftVtx - 1, ring.length - 1)],
      ring[leftVtx],
      ring[modulo(leftVtx + 1, ring.length - 1)]
    ],
    true
  )) {
    var winding = 1;
  } else {
    var winding = -1;
  }
  return winding;
}
function equalArrays$1(array1, array2) {
  if (!array1 || !array2)
    return false;
  if (array1.length != array2.length)
    return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays$1(array1[i], array2[i]))
        return false;
    } else if (array1[i] != array2[i]) {
      return false;
    }
  }
  return true;
}
function modulo(n, m) {
  return (n % m + m) % m;
}
function isUnique(array) {
  var u = {};
  var isUnique2 = 1;
  for (var i = 0, l = array.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(u, array[i])) {
      isUnique2 = 0;
      break;
    }
    u[array[i]] = 1;
  }
  return isUnique2;
}
function unkinkPolygon(geojson) {
  var features = [];
  flattenEach(geojson, function(feature2) {
    if (feature2.geometry.type !== "Polygon")
      return;
    featureEach(simplepolygon(feature2), function(poly) {
      features.push(polygon(poly.geometry.coordinates, feature2.properties));
    });
  });
  return featureCollection(features);
}
var es_default41 = unkinkPolygon;

// node_modules/@turf/great-circle/dist/es/index.js
var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;
var Coord = function(lon2, lat2) {
  this.lon = lon2;
  this.lat = lat2;
  this.x = D2R * lon2;
  this.y = D2R * lat2;
};
Coord.prototype.view = function() {
  return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};
Coord.prototype.antipode = function() {
  var anti_lat = -1 * this.lat;
  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
  return new Coord(anti_lon, anti_lat);
};
var LineString = function() {
  this.coords = [];
  this.length = 0;
};
LineString.prototype.move_to = function(coord) {
  this.length++;
  this.coords.push(coord);
};
var Arc = function(properties) {
  this.properties = properties || {};
  this.geometries = [];
};
Arc.prototype.json = function() {
  if (this.geometries.length <= 0) {
    return {
      geometry: { type: "LineString", coordinates: null },
      type: "Feature",
      properties: this.properties
    };
  } else if (this.geometries.length === 1) {
    return {
      geometry: { type: "LineString", coordinates: this.geometries[0].coords },
      type: "Feature",
      properties: this.properties
    };
  } else {
    var multiline = [];
    for (var i = 0; i < this.geometries.length; i++) {
      multiline.push(this.geometries[i].coords);
    }
    return {
      geometry: { type: "MultiLineString", coordinates: multiline },
      type: "Feature",
      properties: this.properties
    };
  }
};
Arc.prototype.wkt = function() {
  var wkt_string = "";
  var wkt = "LINESTRING(";
  var collect2 = function(c) {
    wkt += c[0] + " " + c[1] + ",";
  };
  for (var i = 0; i < this.geometries.length; i++) {
    if (this.geometries[i].coords.length === 0) {
      return "LINESTRING(empty)";
    } else {
      var coords = this.geometries[i].coords;
      coords.forEach(collect2);
      wkt_string += wkt.substring(0, wkt.length - 1) + ")";
    }
  }
  return wkt_string;
};
var GreatCircle = function(start, end, properties) {
  if (!start || start.x === void 0 || start.y === void 0) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  if (!end || end.x === void 0 || end.y === void 0) {
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  }
  this.start = new Coord(start.x, start.y);
  this.end = new Coord(end.x, end.y);
  this.properties = properties || {};
  var w = this.start.x - this.end.x;
  var h = this.start.y - this.end.y;
  var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
  this.g = 2 * Math.asin(Math.sqrt(z));
  if (this.g === Math.PI) {
    throw new Error(
      "it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
    );
  } else if (isNaN(this.g)) {
    throw new Error(
      "could not calculate great circle between " + start + " and " + end
    );
  }
};
GreatCircle.prototype.interpolate = function(f) {
  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
  var B2 = Math.sin(f * this.g) / Math.sin(this.g);
  var x2 = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B2 * Math.cos(this.end.y) * Math.cos(this.end.x);
  var y2 = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B2 * Math.cos(this.end.y) * Math.sin(this.end.x);
  var z = A * Math.sin(this.start.y) + B2 * Math.sin(this.end.y);
  var lat2 = R2D * Math.atan2(z, Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
  var lon2 = R2D * Math.atan2(y2, x2);
  return [lon2, lat2];
};
GreatCircle.prototype.Arc = function(npoints, options) {
  var first_pass = [];
  if (!npoints || npoints <= 2) {
    first_pass.push([this.start.lon, this.start.lat]);
    first_pass.push([this.end.lon, this.end.lat]);
  } else {
    var delta = 1 / (npoints - 1);
    for (var i = 0; i < npoints; ++i) {
      var step = delta * i;
      var pair = this.interpolate(step);
      first_pass.push(pair);
    }
  }
  var bHasBigDiff = false;
  var dfMaxSmallDiffLong = 0;
  var dfDateLineOffset = options && options.offset ? options.offset : 10;
  var dfLeftBorderX = 180 - dfDateLineOffset;
  var dfRightBorderX = -180 + dfDateLineOffset;
  var dfDiffSpace = 360 - dfDateLineOffset;
  for (var j = 1; j < first_pass.length; ++j) {
    var dfPrevX = first_pass[j - 1][0];
    var dfX = first_pass[j][0];
    var dfDiffLong = Math.abs(dfX - dfPrevX);
    if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
      bHasBigDiff = true;
    } else if (dfDiffLong > dfMaxSmallDiffLong) {
      dfMaxSmallDiffLong = dfDiffLong;
    }
  }
  var poMulti = [];
  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
    var poNewLS = [];
    poMulti.push(poNewLS);
    for (var k = 0; k < first_pass.length; ++k) {
      var dfX0 = parseFloat(first_pass[k][0]);
      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
        var dfX1 = parseFloat(first_pass[k - 1][0]);
        var dfY1 = parseFloat(first_pass[k - 1][1]);
        var dfX2 = parseFloat(first_pass[k][0]);
        var dfY2 = parseFloat(first_pass[k][1]);
        if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
          poNewLS.push([-180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
          poNewLS.push([180, first_pass[k][1]]);
          k++;
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          continue;
        }
        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
          var tmpX = dfX1;
          dfX1 = dfX2;
          dfX2 = tmpX;
          var tmpY = dfY1;
          dfY1 = dfY2;
          dfY2 = tmpY;
        }
        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
          dfX2 += 360;
        }
        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
            dfY
          ]);
          poNewLS = [];
          poNewLS.push([
            first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
            dfY
          ]);
          poMulti.push(poNewLS);
        } else {
          poNewLS = [];
          poMulti.push(poNewLS);
        }
        poNewLS.push([dfX0, first_pass[k][1]]);
      } else {
        poNewLS.push([first_pass[k][0], first_pass[k][1]]);
      }
    }
  } else {
    var poNewLS0 = [];
    poMulti.push(poNewLS0);
    for (var l = 0; l < first_pass.length; ++l) {
      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
    }
  }
  var arc = new Arc(this.properties);
  for (var m = 0; m < poMulti.length; ++m) {
    var line = new LineString();
    arc.geometries.push(line);
    var points2 = poMulti[m];
    for (var j0 = 0; j0 < points2.length; ++j0) {
      line.move_to(points2[j0]);
    }
  }
  return arc;
};
function greatCircle(start, end, options) {
  options = options || {};
  if (typeof options !== "object")
    throw new Error("options is invalid");
  var properties = options.properties;
  var npoints = options.npoints;
  var offset = options.offset;
  start = getCoord(start);
  end = getCoord(end);
  properties = properties || {};
  npoints = npoints || 100;
  offset = offset || 10;
  var generator = new GreatCircle(
    { x: start[0], y: start[1] },
    { x: end[0], y: end[1] },
    properties
  );
  var line = generator.Arc(npoints, { offset });
  return line.json();
}
var es_default42 = greatCircle;

// node_modules/@turf/line-split/dist/es/index.js
var import_geojson_rbush2 = __toESM(require_geojson_rbush());
function lineSplit(line, splitter) {
  if (!line)
    throw new Error("line is required");
  if (!splitter)
    throw new Error("splitter is required");
  var lineType = getType(line);
  var splitterType = getType(splitter);
  if (lineType !== "LineString")
    throw new Error("line must be LineString");
  if (splitterType === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (splitterType === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var truncatedSplitter = es_default38(splitter, { precision: 7 });
  switch (splitterType) {
    case "Point":
      return splitLineWithPoint(line, truncatedSplitter);
    case "MultiPoint":
      return splitLineWithPoints(line, truncatedSplitter);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return splitLineWithPoints(line, es_default26(line, truncatedSplitter));
  }
}
function splitLineWithPoints(line, splitter) {
  var results = [];
  var tree = (0, import_geojson_rbush2.default)();
  flattenEach(splitter, function(point4) {
    results.forEach(function(feature2, index2) {
      feature2.id = index2;
    });
    if (!results.length) {
      results = splitLineWithPoint(line, point4).features;
      results.forEach(function(feature2) {
        if (!feature2.bbox)
          feature2.bbox = es_default15(es_default(feature2));
      });
      tree.load(featureCollection(results));
    } else {
      var search = tree.search(point4);
      if (search.features.length) {
        var closestLine = findClosestFeature(point4, search);
        results = results.filter(function(feature2) {
          return feature2.id !== closestLine.id;
        });
        tree.remove(closestLine);
        featureEach(splitLineWithPoint(closestLine, point4), function(line2) {
          results.push(line2);
          tree.insert(line2);
        });
      }
    }
  });
  return featureCollection(results);
}
function splitLineWithPoint(line, splitter) {
  var results = [];
  var startPoint = getCoords(line)[0];
  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];
  if (pointsEquals(startPoint, getCoord(splitter)) || pointsEquals(endPoint, getCoord(splitter)))
    return featureCollection([line]);
  var tree = (0, import_geojson_rbush2.default)();
  var segments = es_default25(line);
  tree.load(segments);
  var search = tree.search(splitter);
  if (!search.features.length)
    return featureCollection([line]);
  var closestSegment = findClosestFeature(splitter, search);
  var initialValue = [startPoint];
  var lastCoords = featureReduce(
    segments,
    function(previous, current, index2) {
      var currentCoords = getCoords(current)[1];
      var splitterCoords = getCoord(splitter);
      if (index2 === closestSegment.id) {
        previous.push(splitterCoords);
        results.push(lineString(previous));
        if (pointsEquals(splitterCoords, currentCoords))
          return [splitterCoords];
        return [splitterCoords, currentCoords];
      } else {
        previous.push(currentCoords);
        return previous;
      }
    },
    initialValue
  );
  if (lastCoords.length > 1) {
    results.push(lineString(lastCoords));
  }
  return featureCollection(results);
}
function findClosestFeature(point4, lines) {
  if (!lines.features.length)
    throw new Error("lines must contain features");
  if (lines.features.length === 1)
    return lines.features[0];
  var closestFeature;
  var closestDistance = Infinity;
  featureEach(lines, function(segment) {
    var pt = es_default27(segment, point4);
    var dist = pt.properties.dist;
    if (dist < closestDistance) {
      closestFeature = segment;
      closestDistance = dist;
    }
  });
  return closestFeature;
}
function pointsEquals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
var es_default43 = lineSplit;

// node_modules/@turf/line-arc/dist/es/index.js
function lineArc(center2, radius, bearing1, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var steps = options.steps || 64;
  var angle1 = convertAngleTo360(bearing1);
  var angle22 = convertAngleTo360(bearing2);
  var properties = !Array.isArray(center2) && center2.type === "Feature" ? center2.properties : {};
  if (angle1 === angle22) {
    return lineString(es_default16(center2, radius, options).geometry.coordinates[0], properties);
  }
  var arcStartDegree = angle1;
  var arcEndDegree = angle1 < angle22 ? angle22 : angle22 + 360;
  var alfa = arcStartDegree;
  var coordinates = [];
  var i = 0;
  while (alfa < arcEndDegree) {
    coordinates.push(destination(center2, radius, alfa, options).geometry.coordinates);
    i++;
    alfa = arcStartDegree + i * 360 / steps;
  }
  if (alfa > arcEndDegree) {
    coordinates.push(destination(center2, radius, arcEndDegree, options).geometry.coordinates);
  }
  return lineString(coordinates, properties);
}
function convertAngleTo360(alfa) {
  var beta = alfa % 360;
  if (beta < 0) {
    beta += 360;
  }
  return beta;
}

// node_modules/@turf/polygon-to-line/dist/es/index.js
function es_default44(poly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(poly);
  if (!options.properties && poly.type === "Feature") {
    options.properties = poly.properties;
  }
  switch (geom.type) {
    case "Polygon":
      return polygonToLine(geom, options);
    case "MultiPolygon":
      return multiPolygonToLine(geom, options);
    default:
      throw new Error("invalid poly");
  }
}
function polygonToLine(poly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(poly);
  var coords = geom.coordinates;
  var properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
  return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(multiPoly);
  var coords = geom.coordinates;
  var properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
  var lines = [];
  coords.forEach(function(coord) {
    lines.push(coordsToLine(coord, properties));
  });
  return featureCollection(lines);
}
function coordsToLine(coords, properties) {
  if (coords.length > 1) {
    return multiLineString(coords, properties);
  }
  return lineString(coords[0], properties);
}

// node_modules/@turf/line-to-polygon/dist/es/index.js
function lineToPolygon(lines, options) {
  if (options === void 0) {
    options = {};
  }
  var _a, _b, _c;
  var properties = options.properties;
  var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;
  var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;
  var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;
  if (!mutate) {
    lines = es_default5(lines);
  }
  switch (lines.type) {
    case "FeatureCollection":
      var coords = [];
      lines.features.forEach(function(line) {
        coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));
      });
      return multiPolygon(coords, properties);
    default:
      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
  }
}
function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
  properties = properties ? properties : line.type === "Feature" ? line.properties : {};
  var geom = getGeom(line);
  var coords = geom.coordinates;
  var type = geom.type;
  if (!coords.length)
    throw new Error("line must contain coordinates");
  switch (type) {
    case "LineString":
      if (autoComplete)
        coords = autoCompleteCoords(coords);
      return polygon([coords], properties);
    case "MultiLineString":
      var multiCoords = [];
      var largestArea = 0;
      coords.forEach(function(coord) {
        if (autoComplete)
          coord = autoCompleteCoords(coord);
        if (orderCoords) {
          var area5 = calculateArea2(es_default(lineString(coord)));
          if (area5 > largestArea) {
            multiCoords.unshift(coord);
            largestArea = area5;
          } else
            multiCoords.push(coord);
        } else {
          multiCoords.push(coord);
        }
      });
      return polygon(multiCoords, properties);
    default:
      throw new Error("geometry type " + type + " is not supported");
  }
}
function autoCompleteCoords(coords) {
  var first = coords[0];
  var x1 = first[0];
  var y1 = first[1];
  var last = coords[coords.length - 1];
  var x2 = last[0];
  var y2 = last[1];
  if (x1 !== x2 || y1 !== y2) {
    coords.push(first);
  }
  return coords;
}
function calculateArea2(bbox3) {
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  return Math.abs(west - east) * Math.abs(south - north);
}
var es_default45 = lineToPolygon;

// node_modules/@turf/bbox-clip/dist/es/lib/lineclip.js
function lineclip(points2, bbox3, result) {
  var len = points2.length, codeA = bitCode(points2[0], bbox3), part = [], i, codeB, lastCode;
  var a;
  var b;
  if (!result)
    result = [];
  for (i = 1; i < len; i++) {
    a = points2[i - 1];
    b = points2[i];
    codeB = lastCode = bitCode(b, bbox3);
    while (true) {
      if (!(codeA | codeB)) {
        part.push(a);
        if (codeB !== lastCode) {
          part.push(b);
          if (i < len - 1) {
            result.push(part);
            part = [];
          }
        } else if (i === len - 1) {
          part.push(b);
        }
        break;
      } else if (codeA & codeB) {
        break;
      } else if (codeA) {
        a = intersect2(a, b, codeA, bbox3);
        codeA = bitCode(a, bbox3);
      } else {
        b = intersect2(a, b, codeB, bbox3);
        codeB = bitCode(b, bbox3);
      }
    }
    codeA = lastCode;
  }
  if (part.length)
    result.push(part);
  return result;
}
function polygonclip(points2, bbox3) {
  var result, edge, prev, prevInside, i, p, inside;
  for (edge = 1; edge <= 8; edge *= 2) {
    result = [];
    prev = points2[points2.length - 1];
    prevInside = !(bitCode(prev, bbox3) & edge);
    for (i = 0; i < points2.length; i++) {
      p = points2[i];
      inside = !(bitCode(p, bbox3) & edge);
      if (inside !== prevInside)
        result.push(intersect2(prev, p, edge, bbox3));
      if (inside)
        result.push(p);
      prev = p;
      prevInside = inside;
    }
    points2 = result;
    if (!points2.length)
      break;
  }
  return result;
}
function intersect2(a, b, edge, bbox3) {
  return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox3[3] - a[1]) / (b[1] - a[1]), bbox3[3]] : edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox3[1] - a[1]) / (b[1] - a[1]), bbox3[1]] : edge & 2 ? [bbox3[2], a[1] + (b[1] - a[1]) * (bbox3[2] - a[0]) / (b[0] - a[0])] : edge & 1 ? [bbox3[0], a[1] + (b[1] - a[1]) * (bbox3[0] - a[0]) / (b[0] - a[0])] : null;
}
function bitCode(p, bbox3) {
  var code = 0;
  if (p[0] < bbox3[0])
    code |= 1;
  else if (p[0] > bbox3[2])
    code |= 2;
  if (p[1] < bbox3[1])
    code |= 4;
  else if (p[1] > bbox3[3])
    code |= 8;
  return code;
}

// node_modules/@turf/bbox-clip/dist/es/index.js
function bboxClip(feature2, bbox3) {
  var geom = getGeom(feature2);
  var type = geom.type;
  var properties = feature2.type === "Feature" ? feature2.properties : {};
  var coords = geom.coordinates;
  switch (type) {
    case "LineString":
    case "MultiLineString": {
      var lines_1 = [];
      if (type === "LineString") {
        coords = [coords];
      }
      coords.forEach(function(line) {
        lineclip(line, bbox3, lines_1);
      });
      if (lines_1.length === 1) {
        return lineString(lines_1[0], properties);
      }
      return multiLineString(lines_1, properties);
    }
    case "Polygon":
      return polygon(clipPolygon(coords, bbox3), properties);
    case "MultiPolygon":
      return multiPolygon(coords.map(function(poly) {
        return clipPolygon(poly, bbox3);
      }), properties);
    default:
      throw new Error("geometry " + type + " not supported");
  }
}
function clipPolygon(rings, bbox3) {
  var outRings = [];
  for (var _i = 0, rings_1 = rings; _i < rings_1.length; _i++) {
    var ring = rings_1[_i];
    var clipped = polygonclip(ring, bbox3);
    if (clipped.length > 0) {
      if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
        clipped.push(clipped[0]);
      }
      if (clipped.length >= 4) {
        outRings.push(clipped);
      }
    }
  }
  return outRings;
}

// node_modules/@turf/line-overlap/dist/es/index.js
var import_geojson_rbush3 = __toESM(require_geojson_rbush());
var import_deep_equal = __toESM(require_deep_equal());
function lineOverlap(line1, line2, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var tolerance = options.tolerance || 0;
  var features = [];
  var tree = (0, import_geojson_rbush3.default)();
  var line = es_default25(line1);
  tree.load(line);
  var overlapSegment;
  segmentEach(line2, function(segment) {
    var doesOverlaps = false;
    if (!segment) {
      return;
    }
    featureEach(tree.search(segment), function(match) {
      if (doesOverlaps === false) {
        var coordsSegment = getCoords(segment).sort();
        var coordsMatch = getCoords(match).sort();
        if ((0, import_deep_equal.default)(coordsSegment, coordsMatch)) {
          doesOverlaps = true;
          if (overlapSegment)
            overlapSegment = concatSegment(overlapSegment, segment);
          else
            overlapSegment = segment;
        } else if (tolerance === 0 ? es_default35(coordsSegment[0], match) && es_default35(coordsSegment[1], match) : es_default27(match, coordsSegment[0]).properties.dist <= tolerance && es_default27(match, coordsSegment[1]).properties.dist <= tolerance) {
          doesOverlaps = true;
          if (overlapSegment)
            overlapSegment = concatSegment(overlapSegment, segment);
          else
            overlapSegment = segment;
        } else if (tolerance === 0 ? es_default35(coordsMatch[0], segment) && es_default35(coordsMatch[1], segment) : es_default27(segment, coordsMatch[0]).properties.dist <= tolerance && es_default27(segment, coordsMatch[1]).properties.dist <= tolerance) {
          if (overlapSegment)
            overlapSegment = concatSegment(overlapSegment, match);
          else
            overlapSegment = match;
        }
      }
    });
    if (doesOverlaps === false && overlapSegment) {
      features.push(overlapSegment);
      overlapSegment = void 0;
    }
  });
  if (overlapSegment)
    features.push(overlapSegment);
  return featureCollection(features);
}
function concatSegment(line, segment) {
  var coords = getCoords(segment);
  var lineCoords = getCoords(line);
  var start = lineCoords[0];
  var end = lineCoords[lineCoords.length - 1];
  var geom = line.geometry.coordinates;
  if ((0, import_deep_equal.default)(coords[0], start))
    geom.unshift(coords[1]);
  else if ((0, import_deep_equal.default)(coords[0], end))
    geom.push(coords[1]);
  else if ((0, import_deep_equal.default)(coords[1], start))
    geom.unshift(coords[0]);
  else if ((0, import_deep_equal.default)(coords[1], end))
    geom.push(coords[0]);
  return line;
}
var es_default46 = lineOverlap;

// node_modules/@turf/sector/dist/es/index.js
function sector(center2, radius, bearing1, bearing2, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var properties = options.properties;
  if (!center2)
    throw new Error("center is required");
  if (bearing1 === void 0 || bearing1 === null)
    throw new Error("bearing1 is required");
  if (bearing2 === void 0 || bearing2 === null)
    throw new Error("bearing2 is required");
  if (!radius)
    throw new Error("radius is required");
  if (typeof options !== "object")
    throw new Error("options must be an object");
  if (convertAngleTo3602(bearing1) === convertAngleTo3602(bearing2)) {
    return es_default16(center2, radius, options);
  }
  var coords = getCoords(center2);
  var arc = lineArc(center2, radius, bearing1, bearing2, options);
  var sliceCoords = [[coords]];
  coordEach(arc, function(currentCoords) {
    sliceCoords[0].push(currentCoords);
  });
  sliceCoords[0].push(coords);
  return polygon(sliceCoords, properties);
}
function convertAngleTo3602(alfa) {
  var beta = alfa % 360;
  if (beta < 0)
    beta += 360;
  return beta;
}
var es_default47 = sector;

// node_modules/@turf/rhumb-bearing/dist/es/index.js
function rhumbBearing(start, end, options) {
  if (options === void 0) {
    options = {};
  }
  var bear360;
  if (options.final) {
    bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));
  } else {
    bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));
  }
  var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
  return bear180;
}
function calculateRhumbBearing(from, to) {
  var phi1 = degreesToRadians(from[1]);
  var phi2 = degreesToRadians(to[1]);
  var deltaLambda = degreesToRadians(to[0] - from[0]);
  if (deltaLambda > Math.PI) {
    deltaLambda -= 2 * Math.PI;
  }
  if (deltaLambda < -Math.PI) {
    deltaLambda += 2 * Math.PI;
  }
  var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var theta = Math.atan2(deltaLambda, deltaPsi);
  return (radiansToDegrees(theta) + 360) % 360;
}
var es_default48 = rhumbBearing;

// node_modules/@turf/rhumb-destination/dist/es/index.js
function rhumbDestination(origin, distance11, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var wasNegativeDistance = distance11 < 0;
  var distanceInMeters = convertLength(Math.abs(distance11), options.units, "meters");
  if (wasNegativeDistance)
    distanceInMeters = -Math.abs(distanceInMeters);
  var coords = getCoord(origin);
  var destination2 = calculateRhumbDestination(coords, distanceInMeters, bearing2);
  destination2[0] += destination2[0] - coords[0] > 180 ? -360 : coords[0] - destination2[0] > 180 ? 360 : 0;
  return point(destination2, options.properties);
}
function calculateRhumbDestination(origin, distance11, bearing2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  var delta = distance11 / radius;
  var lambda1 = origin[0] * Math.PI / 180;
  var phi1 = degreesToRadians(origin[1]);
  var theta = degreesToRadians(bearing2);
  var DeltaPhi = delta * Math.cos(theta);
  var phi2 = phi1 + DeltaPhi;
  if (Math.abs(phi2) > Math.PI / 2) {
    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
  }
  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  var DeltaLambda = delta * Math.sin(theta) / q;
  var lambda2 = lambda1 + DeltaLambda;
  return [
    (lambda2 * 180 / Math.PI + 540) % 360 - 180,
    phi2 * 180 / Math.PI
  ];
}
var es_default49 = rhumbDestination;

// node_modules/@turf/polygon-tangents/dist/es/index.js
function polygonTangents(pt, polygon4) {
  var pointCoords = getCoords(pt);
  var polyCoords = getCoords(polygon4);
  var rtan;
  var ltan;
  var enext;
  var eprev;
  var bbox3 = es_default(polygon4);
  var nearestPtIndex = 0;
  var nearest = null;
  if (pointCoords[0] > bbox3[0] && pointCoords[0] < bbox3[2] && pointCoords[1] > bbox3[1] && pointCoords[1] < bbox3[3]) {
    nearest = es_default24(pt, es_default22(polygon4));
    nearestPtIndex = nearest.properties.featureIndex;
  }
  var type = getType(polygon4);
  switch (type) {
    case "Polygon":
      rtan = polyCoords[0][nearestPtIndex];
      ltan = polyCoords[0][0];
      if (nearest !== null) {
        if (nearest.geometry.coordinates[1] < pointCoords[1])
          ltan = polyCoords[0][nearestPtIndex];
      }
      eprev = isLeft(
        polyCoords[0][0],
        polyCoords[0][polyCoords[0].length - 1],
        pointCoords
      );
      var out = processPolygon2(
        polyCoords[0],
        pointCoords,
        eprev,
        enext,
        rtan,
        ltan
      );
      rtan = out[0];
      ltan = out[1];
      break;
    case "MultiPolygon":
      var closestFeature = 0;
      var closestVertex = 0;
      var verticesCounted = 0;
      for (var i = 0; i < polyCoords[0].length; i++) {
        closestFeature = i;
        var verticeFound = false;
        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {
          closestVertex = i2;
          if (verticesCounted === nearestPtIndex) {
            verticeFound = true;
            break;
          }
          verticesCounted++;
        }
        if (verticeFound)
          break;
      }
      rtan = polyCoords[0][closestFeature][closestVertex];
      ltan = polyCoords[0][closestFeature][closestVertex];
      eprev = isLeft(
        polyCoords[0][0][0],
        polyCoords[0][0][polyCoords[0][0].length - 1],
        pointCoords
      );
      polyCoords.forEach(function(ring) {
        var out2 = processPolygon2(
          ring[0],
          pointCoords,
          eprev,
          enext,
          rtan,
          ltan
        );
        rtan = out2[0];
        ltan = out2[1];
      });
      break;
  }
  return featureCollection([point(rtan), point(ltan)]);
}
function processPolygon2(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {
  for (var i = 0; i < polygonCoords.length; i++) {
    var currentCoords = polygonCoords[i];
    var nextCoordPair = polygonCoords[i + 1];
    if (i === polygonCoords.length - 1) {
      nextCoordPair = polygonCoords[0];
    }
    enext = isLeft(currentCoords, nextCoordPair, ptCoords);
    if (eprev <= 0 && enext > 0) {
      if (!isBelow(ptCoords, currentCoords, rtan)) {
        rtan = currentCoords;
      }
    } else if (eprev > 0 && enext <= 0) {
      if (!isAbove(ptCoords, currentCoords, ltan)) {
        ltan = currentCoords;
      }
    }
    eprev = enext;
  }
  return [rtan, ltan];
}
function isAbove(point1, point22, point32) {
  return isLeft(point1, point22, point32) > 0;
}
function isBelow(point1, point22, point32) {
  return isLeft(point1, point22, point32) < 0;
}
function isLeft(point1, point22, point32) {
  return (point22[0] - point1[0]) * (point32[1] - point1[1]) - (point32[0] - point1[0]) * (point22[1] - point1[1]);
}
var es_default50 = polygonTangents;

// node_modules/@turf/turf/node_modules/@turf/boolean-clockwise/dist/es/index.js
function booleanClockwise(line) {
  var ring = getCoords(line);
  var sum = 0;
  var i = 1;
  var prev;
  var cur;
  while (i < ring.length) {
    prev = cur || ring[0];
    cur = ring[i];
    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i++;
  }
  return sum > 0;
}

// node_modules/@turf/turf/node_modules/@turf/rewind/dist/es/index.js
function rewind(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var reverse5 = options.reverse || false;
  var mutate = options.mutate || false;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof reverse5 !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (mutate === false)
    geojson = es_default5(geojson);
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        rewindFeature(geometry2, reverse5);
      });
      return geojson;
    case "FeatureCollection":
      featureEach(geojson, function(feature2) {
        featureEach(rewindFeature(feature2, reverse5), function(result) {
          results.push(result);
        });
      });
      return featureCollection(results);
  }
  return rewindFeature(geojson, reverse5);
}
function rewindFeature(geojson, reverse5) {
  var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        rewindFeature(geometry2, reverse5);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords(geojson), reverse5);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords(geojson), reverse5);
      return geojson;
    case "MultiLineString":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse5);
      });
      return geojson;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse5);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}
function rewindLineString(coords, reverse5) {
  if (booleanClockwise(coords) === reverse5)
    coords.reverse();
}
function rewindPolygon(coords, reverse5) {
  if (booleanClockwise(coords[0]) !== reverse5) {
    coords[0].reverse();
  }
  for (var i = 1; i < coords.length; i++) {
    if (booleanClockwise(coords[i]) === reverse5) {
      coords[i].reverse();
    }
  }
}
var es_default51 = rewind;

// node_modules/@turf/isobands/dist/es/index.js
var import_object_assign3 = __toESM(require_object_assign());
function gridToMatrix2(grid, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var flip4 = options.flip;
  var flags = options.flags;
  collectionOf(grid, "Point", "input must contain Points");
  var pointsMatrix = sortPointsByLatLng2(grid, flip4);
  var matrix = [];
  for (var r = 0; r < pointsMatrix.length; r++) {
    var pointRow = pointsMatrix[r];
    var row = [];
    for (var c = 0; c < pointRow.length; c++) {
      var point4 = pointRow[c];
      if (point4.properties[zProperty])
        row.push(point4.properties[zProperty]);
      else
        row.push(0);
      if (flags === true)
        point4.properties.matrixPosition = [r, c];
    }
    matrix.push(row);
  }
  return matrix;
}
function sortPointsByLatLng2(points2, flip4) {
  var pointsByLatitude = {};
  featureEach(points2, function(point4) {
    var lat2 = getCoords(point4)[1];
    if (!pointsByLatitude[lat2])
      pointsByLatitude[lat2] = [];
    pointsByLatitude[lat2].push(point4);
  });
  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat2) {
    var row = pointsByLatitude[lat2];
    var rowOrderedByLongitude = row.sort(function(a, b) {
      return getCoords(a)[0] - getCoords(b)[0];
    });
    return rowOrderedByLongitude;
  });
  var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
    if (flip4)
      return getCoords(a[0])[1] - getCoords(b[0])[1];
    else
      return getCoords(b[0])[1] - getCoords(a[0])[1];
  });
  return pointMatrix;
}
var defaultSettings2 = {
  successCallback: null,
  verbose: false,
  polygons: false
};
var settings2 = {};
function isoBands(data, minV, bandwidth, options) {
  options = options ? options : {};
  var optionKeys = Object.keys(defaultSettings2);
  for (var i = 0; i < optionKeys.length; i++) {
    var key = optionKeys[i];
    var val = options[key];
    val = typeof val !== "undefined" && val !== null ? val : defaultSettings2[key];
    settings2[key] = val;
  }
  if (settings2.verbose)
    console.log(
      "MarchingSquaresJS-isoBands: computing isobands for [" + minV + ":" + (minV + bandwidth) + "]"
    );
  var grid = computeBandGrid(data, minV, bandwidth);
  var ret;
  if (settings2.polygons) {
    if (settings2.verbose)
      console.log(
        "MarchingSquaresJS-isoBands: returning single polygons for each grid cell"
      );
    ret = BandGrid2Areas(grid);
  } else {
    if (settings2.verbose)
      console.log(
        "MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"
      );
    ret = BandGrid2AreaPaths(grid);
  }
  if (typeof settings2.successCallback === "function")
    settings2.successCallback(ret);
  return ret;
}
var Node0 = 64;
var Node1 = 16;
var Node2 = 4;
var Node3 = 1;
var isoBandNextXTL = [];
var isoBandNextYTL = [];
var isoBandNextOTL = [];
var isoBandNextXTR = [];
var isoBandNextYTR = [];
var isoBandNextOTR = [];
var isoBandNextXRT = [];
var isoBandNextYRT = [];
var isoBandNextORT = [];
var isoBandNextXRB = [];
var isoBandNextYRB = [];
var isoBandNextORB = [];
var isoBandNextXBL = [];
var isoBandNextYBL = [];
var isoBandNextOBL = [];
var isoBandNextXBR = [];
var isoBandNextYBR = [];
var isoBandNextOBR = [];
var isoBandNextXLT = [];
var isoBandNextYLT = [];
var isoBandNextOLT = [];
var isoBandNextXLB = [];
var isoBandNextYLB = [];
var isoBandNextOLB = [];
isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
isoBandNextORT[85] = isoBandNextORB[85] = 1;
isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
isoBandNextORB[4] = isoBandNextORB[166] = 1;
isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
isoBandNextORT[16] = isoBandNextORT[154] = 1;
isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
isoBandNextORT[8] = isoBandNextORT[162] = 0;
isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
isoBandNextORB[8] = isoBandNextORB[162] = 1;
isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
isoBandNextORT[32] = isoBandNextORT[138] = 1;
isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
isoBandNextORB[32] = isoBandNextORB[138] = 0;
isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
isoBandNextORB[5] = isoBandNextORB[165] = 0;
isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
isoBandNextORT[80] = isoBandNextORT[90] = 1;
isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
isoBandNextORT[160] = isoBandNextORT[10] = 1;
isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
isoBandNextORB[160] = isoBandNextORB[10] = 0;
isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
isoBandNextORB[37] = isoBandNextORB[133] = 1;
isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
isoBandNextORT[82] = isoBandNextORT[88] = 1;
isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
isoBandNextORT[73] = isoBandNextORT[97] = 0;
isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
isoBandNextORB[73] = isoBandNextORB[97] = 0;
isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
isoBandNextORT[145] = isoBandNextORT[25] = 0;
isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
isoBandNextORB[70] = isoBandNextORB[100] = 0;
isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
isoBandNextORB[101] = isoBandNextORB[69] = 0;
isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
isoBandNextORT[89] = isoBandNextORT[81] = 0;
isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
isoBandNextORT[96] = isoBandNextORT[74] = 0;
isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
isoBandNextORB[96] = isoBandNextORB[74] = 1;
isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
isoBandNextORT[24] = isoBandNextORT[146] = 1;
isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
isoBandNextORB[6] = isoBandNextORB[164] = 1;
isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
isoBandNextORT[144] = isoBandNextORT[26] = 0;
isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
isoBandNextORB[36] = isoBandNextORB[134] = 1;
isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
isoBandNextORT[9] = isoBandNextORT[161] = 0;
isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
isoBandNextORB[9] = isoBandNextORB[161] = 0;
isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
isoBandNextXRT[136] = 0;
isoBandNextYRT[136] = 1;
isoBandNextORT[136] = 1;
isoBandNextXRB[136] = 0;
isoBandNextYRB[136] = 1;
isoBandNextORB[136] = 0;
isoBandNextXBR[136] = -1;
isoBandNextYBR[136] = 0;
isoBandNextOBR[136] = 1;
isoBandNextXBL[136] = -1;
isoBandNextYBL[136] = 0;
isoBandNextOBL[136] = 0;
isoBandNextXLB[136] = 0;
isoBandNextYLB[136] = -1;
isoBandNextOLB[136] = 0;
isoBandNextXLT[136] = 0;
isoBandNextYLT[136] = -1;
isoBandNextOLT[136] = 1;
isoBandNextXTL[136] = 1;
isoBandNextYTL[136] = 0;
isoBandNextOTL[136] = 0;
isoBandNextXTR[136] = 1;
isoBandNextYTR[136] = 0;
isoBandNextOTR[136] = 1;
isoBandNextXRT[34] = 0;
isoBandNextYRT[34] = -1;
isoBandNextORT[34] = 0;
isoBandNextXRB[34] = 0;
isoBandNextYRB[34] = -1;
isoBandNextORB[34] = 1;
isoBandNextXBR[34] = 1;
isoBandNextYBR[34] = 0;
isoBandNextOBR[34] = 0;
isoBandNextXBL[34] = 1;
isoBandNextYBL[34] = 0;
isoBandNextOBL[34] = 1;
isoBandNextXLB[34] = 0;
isoBandNextYLB[34] = 1;
isoBandNextOLB[34] = 1;
isoBandNextXLT[34] = 0;
isoBandNextYLT[34] = 1;
isoBandNextOLT[34] = 0;
isoBandNextXTL[34] = -1;
isoBandNextYTL[34] = 0;
isoBandNextOTL[34] = 1;
isoBandNextXTR[34] = -1;
isoBandNextYTR[34] = 0;
isoBandNextOTR[34] = 0;
isoBandNextXRT[35] = 0;
isoBandNextYRT[35] = 1;
isoBandNextORT[35] = 1;
isoBandNextXRB[35] = 0;
isoBandNextYRB[35] = -1;
isoBandNextORB[35] = 1;
isoBandNextXBR[35] = 1;
isoBandNextYBR[35] = 0;
isoBandNextOBR[35] = 0;
isoBandNextXBL[35] = -1;
isoBandNextYBL[35] = 0;
isoBandNextOBL[35] = 0;
isoBandNextXLB[35] = 0;
isoBandNextYLB[35] = -1;
isoBandNextOLB[35] = 0;
isoBandNextXLT[35] = 0;
isoBandNextYLT[35] = 1;
isoBandNextOLT[35] = 0;
isoBandNextXTL[35] = -1;
isoBandNextYTL[35] = 0;
isoBandNextOTL[35] = 1;
isoBandNextXTR[35] = 1;
isoBandNextYTR[35] = 0;
isoBandNextOTR[35] = 1;
isoBandNextXRT[153] = 0;
isoBandNextYRT[153] = 1;
isoBandNextORT[153] = 1;
isoBandNextXBL[153] = -1;
isoBandNextYBL[153] = 0;
isoBandNextOBL[153] = 0;
isoBandNextXLB[153] = 0;
isoBandNextYLB[153] = -1;
isoBandNextOLB[153] = 0;
isoBandNextXTR[153] = 1;
isoBandNextYTR[153] = 0;
isoBandNextOTR[153] = 1;
isoBandNextXRB[102] = 0;
isoBandNextYRB[102] = -1;
isoBandNextORB[102] = 1;
isoBandNextXBR[102] = 1;
isoBandNextYBR[102] = 0;
isoBandNextOBR[102] = 0;
isoBandNextXLT[102] = 0;
isoBandNextYLT[102] = 1;
isoBandNextOLT[102] = 0;
isoBandNextXTL[102] = -1;
isoBandNextYTL[102] = 0;
isoBandNextOTL[102] = 1;
isoBandNextXRT[155] = 0;
isoBandNextYRT[155] = -1;
isoBandNextORT[155] = 0;
isoBandNextXBL[155] = 1;
isoBandNextYBL[155] = 0;
isoBandNextOBL[155] = 1;
isoBandNextXLB[155] = 0;
isoBandNextYLB[155] = 1;
isoBandNextOLB[155] = 1;
isoBandNextXTR[155] = -1;
isoBandNextYTR[155] = 0;
isoBandNextOTR[155] = 0;
isoBandNextXRB[103] = 0;
isoBandNextYRB[103] = 1;
isoBandNextORB[103] = 0;
isoBandNextXBR[103] = -1;
isoBandNextYBR[103] = 0;
isoBandNextOBR[103] = 1;
isoBandNextXLT[103] = 0;
isoBandNextYLT[103] = -1;
isoBandNextOLT[103] = 1;
isoBandNextXTL[103] = 1;
isoBandNextYTL[103] = 0;
isoBandNextOTL[103] = 0;
isoBandNextXRT[152] = 0;
isoBandNextYRT[152] = 1;
isoBandNextORT[152] = 1;
isoBandNextXBR[152] = -1;
isoBandNextYBR[152] = 0;
isoBandNextOBR[152] = 1;
isoBandNextXBL[152] = -1;
isoBandNextYBL[152] = 0;
isoBandNextOBL[152] = 0;
isoBandNextXLB[152] = 0;
isoBandNextYLB[152] = -1;
isoBandNextOLB[152] = 0;
isoBandNextXLT[152] = 0;
isoBandNextYLT[152] = -1;
isoBandNextOLT[152] = 1;
isoBandNextXTR[152] = 1;
isoBandNextYTR[152] = 0;
isoBandNextOTR[152] = 1;
isoBandNextXRT[156] = 0;
isoBandNextYRT[156] = -1;
isoBandNextORT[156] = 1;
isoBandNextXBR[156] = 1;
isoBandNextYBR[156] = 0;
isoBandNextOBR[156] = 1;
isoBandNextXBL[156] = -1;
isoBandNextYBL[156] = 0;
isoBandNextOBL[156] = 0;
isoBandNextXLB[156] = 0;
isoBandNextYLB[156] = -1;
isoBandNextOLB[156] = 0;
isoBandNextXLT[156] = 0;
isoBandNextYLT[156] = 1;
isoBandNextOLT[156] = 1;
isoBandNextXTR[156] = -1;
isoBandNextYTR[156] = 0;
isoBandNextOTR[156] = 1;
isoBandNextXRT[137] = 0;
isoBandNextYRT[137] = 1;
isoBandNextORT[137] = 1;
isoBandNextXRB[137] = 0;
isoBandNextYRB[137] = 1;
isoBandNextORB[137] = 0;
isoBandNextXBL[137] = -1;
isoBandNextYBL[137] = 0;
isoBandNextOBL[137] = 0;
isoBandNextXLB[137] = 0;
isoBandNextYLB[137] = -1;
isoBandNextOLB[137] = 0;
isoBandNextXTL[137] = 1;
isoBandNextYTL[137] = 0;
isoBandNextOTL[137] = 0;
isoBandNextXTR[137] = 1;
isoBandNextYTR[137] = 0;
isoBandNextOTR[137] = 1;
isoBandNextXRT[139] = 0;
isoBandNextYRT[139] = 1;
isoBandNextORT[139] = 1;
isoBandNextXRB[139] = 0;
isoBandNextYRB[139] = -1;
isoBandNextORB[139] = 0;
isoBandNextXBL[139] = 1;
isoBandNextYBL[139] = 0;
isoBandNextOBL[139] = 0;
isoBandNextXLB[139] = 0;
isoBandNextYLB[139] = 1;
isoBandNextOLB[139] = 0;
isoBandNextXTL[139] = -1;
isoBandNextYTL[139] = 0;
isoBandNextOTL[139] = 0;
isoBandNextXTR[139] = 1;
isoBandNextYTR[139] = 0;
isoBandNextOTR[139] = 1;
isoBandNextXRT[98] = 0;
isoBandNextYRT[98] = -1;
isoBandNextORT[98] = 0;
isoBandNextXRB[98] = 0;
isoBandNextYRB[98] = -1;
isoBandNextORB[98] = 1;
isoBandNextXBR[98] = 1;
isoBandNextYBR[98] = 0;
isoBandNextOBR[98] = 0;
isoBandNextXBL[98] = 1;
isoBandNextYBL[98] = 0;
isoBandNextOBL[98] = 1;
isoBandNextXLT[98] = 0;
isoBandNextYLT[98] = 1;
isoBandNextOLT[98] = 0;
isoBandNextXTL[98] = -1;
isoBandNextYTL[98] = 0;
isoBandNextOTL[98] = 1;
isoBandNextXRT[99] = 0;
isoBandNextYRT[99] = 1;
isoBandNextORT[99] = 0;
isoBandNextXRB[99] = 0;
isoBandNextYRB[99] = -1;
isoBandNextORB[99] = 1;
isoBandNextXBR[99] = 1;
isoBandNextYBR[99] = 0;
isoBandNextOBR[99] = 0;
isoBandNextXBL[99] = -1;
isoBandNextYBL[99] = 0;
isoBandNextOBL[99] = 1;
isoBandNextXLT[99] = 0;
isoBandNextYLT[99] = -1;
isoBandNextOLT[99] = 0;
isoBandNextXTL[99] = 1;
isoBandNextYTL[99] = 0;
isoBandNextOTL[99] = 1;
isoBandNextXRB[38] = 0;
isoBandNextYRB[38] = -1;
isoBandNextORB[38] = 1;
isoBandNextXBR[38] = 1;
isoBandNextYBR[38] = 0;
isoBandNextOBR[38] = 0;
isoBandNextXLB[38] = 0;
isoBandNextYLB[38] = 1;
isoBandNextOLB[38] = 1;
isoBandNextXLT[38] = 0;
isoBandNextYLT[38] = 1;
isoBandNextOLT[38] = 0;
isoBandNextXTL[38] = -1;
isoBandNextYTL[38] = 0;
isoBandNextOTL[38] = 1;
isoBandNextXTR[38] = -1;
isoBandNextYTR[38] = 0;
isoBandNextOTR[38] = 0;
isoBandNextXRB[39] = 0;
isoBandNextYRB[39] = 1;
isoBandNextORB[39] = 1;
isoBandNextXBR[39] = -1;
isoBandNextYBR[39] = 0;
isoBandNextOBR[39] = 0;
isoBandNextXLB[39] = 0;
isoBandNextYLB[39] = -1;
isoBandNextOLB[39] = 1;
isoBandNextXLT[39] = 0;
isoBandNextYLT[39] = 1;
isoBandNextOLT[39] = 0;
isoBandNextXTL[39] = -1;
isoBandNextYTL[39] = 0;
isoBandNextOTL[39] = 1;
isoBandNextXTR[39] = 1;
isoBandNextYTR[39] = 0;
isoBandNextOTR[39] = 0;
var p00 = function(cell) {
  return [
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom]
  ];
};
var p01 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0]
  ];
};
var p02 = function(cell) {
  return [
    [cell.topright, 1],
    [1, 1],
    [1, cell.righttop]
  ];
};
var p03 = function(cell) {
  return [
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p04 = function(cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop]
  ];
};
var p05 = function(cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [1, cell.righttop],
    [1, cell.rightbottom]
  ];
};
var p06 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p07 = function(cell) {
  return [
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p08 = function(cell) {
  return [
    [0, 0],
    [0, cell.leftbottom],
    [1, cell.rightbottom],
    [1, 0]
  ];
};
var p09 = function(cell) {
  return [
    [1, 0],
    [cell.bottomright, 0],
    [cell.topright, 1],
    [1, 1]
  ];
};
var p10 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [0, cell.lefttop],
    [0, 1]
  ];
};
var p11 = function(cell) {
  return [
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p12 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [0, cell.leftbottom],
    [0, cell.lefttop]
  ];
};
var p13 = function(cell) {
  return [
    [cell.topleft, 1],
    [cell.topright, 1],
    [cell.bottomright, 0],
    [cell.bottomleft, 0]
  ];
};
var p14 = function() {
  return [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0]
  ];
};
var p15 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p16 = function(cell) {
  return [
    [cell.topright, 1],
    [1, 1],
    [1, 0],
    [0, 0],
    [0, cell.leftbottom]
  ];
};
var p17 = function(cell) {
  return [
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [1, 1]
  ];
};
var p18 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1]
  ];
};
var p19 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p20 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [cell.topright, 1]
  ];
};
var p21 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop]
  ];
};
var p22 = function(cell) {
  return [
    [cell.topright, 1],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1]
  ];
};
var p23 = function(cell) {
  return [
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p24 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1]
  ];
};
var p25 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p26 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom]
  ];
};
var p27 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p28 = function(cell) {
  return [
    [1, 1],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1]
  ];
};
var p29 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1]
  ];
};
var p30 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p31 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topright, 1]
  ];
};
var p32 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p33 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p34 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topright, 1]
  ];
};
var p35 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p36 = function(cell) {
  return [
    [1, 1],
    [1, cell.righttop],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topright, 1]
  ];
};
var p37 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomleft, 0],
    [0, 0],
    [0, cell.leftbottom],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var p38 = function(cell) {
  return [
    [1, cell.righttop],
    [1, cell.rightbottom],
    [cell.bottomright, 0],
    [cell.bottomleft, 0],
    [0, cell.lefttop],
    [0, 1],
    [cell.topleft, 1]
  ];
};
var p39 = function(cell) {
  return [
    [1, cell.rightbottom],
    [1, 0],
    [cell.bottomright, 0],
    [0, cell.leftbottom],
    [0, cell.lefttop],
    [cell.topleft, 1],
    [cell.topright, 1]
  ];
};
var isoBandEdgeRT = [];
var isoBandEdgeRB = [];
var isoBandEdgeBR = [];
var isoBandEdgeBL = [];
var isoBandEdgeLB = [];
var isoBandEdgeLT = [];
var isoBandEdgeTL = [];
var isoBandEdgeTR = [];
isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
var polygon_table = [];
polygon_table[1] = polygon_table[169] = p00;
polygon_table[4] = polygon_table[166] = p01;
polygon_table[16] = polygon_table[154] = p02;
polygon_table[64] = polygon_table[106] = p03;
polygon_table[168] = polygon_table[2] = p04;
polygon_table[162] = polygon_table[8] = p05;
polygon_table[138] = polygon_table[32] = p06;
polygon_table[42] = polygon_table[128] = p07;
polygon_table[5] = polygon_table[165] = p08;
polygon_table[20] = polygon_table[150] = p09;
polygon_table[80] = polygon_table[90] = p10;
polygon_table[65] = polygon_table[105] = p11;
polygon_table[160] = polygon_table[10] = p12;
polygon_table[130] = polygon_table[40] = p13;
polygon_table[85] = p14;
polygon_table[101] = polygon_table[69] = p15;
polygon_table[149] = polygon_table[21] = p16;
polygon_table[86] = polygon_table[84] = p17;
polygon_table[89] = polygon_table[81] = p18;
polygon_table[96] = polygon_table[74] = p19;
polygon_table[24] = polygon_table[146] = p20;
polygon_table[6] = polygon_table[164] = p21;
polygon_table[129] = polygon_table[41] = p22;
polygon_table[66] = polygon_table[104] = p23;
polygon_table[144] = polygon_table[26] = p24;
polygon_table[36] = polygon_table[134] = p25;
polygon_table[9] = polygon_table[161] = p26;
polygon_table[37] = polygon_table[133] = p27;
polygon_table[148] = polygon_table[22] = p28;
polygon_table[82] = polygon_table[88] = p29;
polygon_table[73] = polygon_table[97] = p30;
polygon_table[145] = polygon_table[25] = p31;
polygon_table[70] = polygon_table[100] = p32;
polygon_table[34] = function(c) {
  return [p07(c), p05(c)];
};
polygon_table[35] = p33;
polygon_table[136] = function(c) {
  return [p06(c), p04(c)];
};
polygon_table[153] = function(c) {
  return [p02(c), p00(c)];
};
polygon_table[102] = function(c) {
  return [p01(c), p03(c)];
};
polygon_table[155] = p34;
polygon_table[103] = p35;
polygon_table[152] = function(c) {
  return [p02(c), p04(c)];
};
polygon_table[156] = p36;
polygon_table[137] = function(c) {
  return [p06(c), p00(c)];
};
polygon_table[139] = p37;
polygon_table[98] = function(c) {
  return [p05(c), p03(c)];
};
polygon_table[99] = p38;
polygon_table[38] = function(c) {
  return [p01(c), p07(c)];
};
polygon_table[39] = p39;
function interpolateX2(y2, y0, y1) {
  return (y2 - y0) / (y1 - y0);
}
function isArray(myArray) {
  return myArray.constructor.toString().indexOf("Array") > -1;
}
function computeBandGrid(data, minV, bandwidth) {
  var rows = data.length - 1;
  var cols = data[0].length - 1;
  var BandGrid = { rows, cols, cells: [] };
  var maxV = minV + Math.abs(bandwidth);
  for (var j = 0; j < rows; ++j) {
    BandGrid.cells[j] = [];
    for (var i = 0; i < cols; ++i) {
      var cval = 0;
      var tl = data[j + 1][i];
      var tr = data[j + 1][i + 1];
      var br = data[j][i + 1];
      var bl = data[j][i];
      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
        continue;
      }
      cval |= tl < minV ? 0 : tl > maxV ? 128 : 64;
      cval |= tr < minV ? 0 : tr > maxV ? 32 : 16;
      cval |= br < minV ? 0 : br > maxV ? 8 : 4;
      cval |= bl < minV ? 0 : bl > maxV ? 2 : 1;
      var cval_real = +cval;
      var flipped = 0;
      if (cval === 17 || cval === 18 || cval === 33 || cval === 34 || cval === 38 || cval === 68 || cval === 72 || cval === 98 || cval === 102 || cval === 132 || cval === 136 || cval === 137 || cval === 152 || cval === 153) {
        var average2 = (tl + tr + br + bl) / 4;
        flipped = average2 > maxV ? 2 : average2 < minV ? 0 : 1;
        if (cval === 34) {
          if (flipped === 1) {
            cval = 35;
          } else if (flipped === 0) {
            cval = 136;
          }
        } else if (cval === 136) {
          if (flipped === 1) {
            cval = 35;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 34;
          }
        } else if (cval === 17) {
          if (flipped === 1) {
            cval = 155;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 153;
          }
        } else if (cval === 68) {
          if (flipped === 1) {
            cval = 103;
            flipped = 4;
          } else if (flipped === 0) {
            cval = 102;
          }
        } else if (cval === 153) {
          if (flipped === 1)
            cval = 155;
        } else if (cval === 102) {
          if (flipped === 1)
            cval = 103;
        } else if (cval === 152) {
          if (flipped < 2) {
            cval = 156;
            flipped = 1;
          }
        } else if (cval === 137) {
          if (flipped < 2) {
            cval = 139;
            flipped = 1;
          }
        } else if (cval === 98) {
          if (flipped < 2) {
            cval = 99;
            flipped = 1;
          }
        } else if (cval === 38) {
          if (flipped < 2) {
            cval = 39;
            flipped = 1;
          }
        } else if (cval === 18) {
          if (flipped > 0) {
            cval = 156;
            flipped = 4;
          } else {
            cval = 152;
          }
        } else if (cval === 33) {
          if (flipped > 0) {
            cval = 139;
            flipped = 4;
          } else {
            cval = 137;
          }
        } else if (cval === 72) {
          if (flipped > 0) {
            cval = 99;
            flipped = 4;
          } else {
            cval = 98;
          }
        } else if (cval === 132) {
          if (flipped > 0) {
            cval = 39;
            flipped = 4;
          } else {
            cval = 38;
          }
        }
      }
      if (cval != 0 && cval != 170) {
        var topleft, topright, bottomleft, bottomright, righttop, rightbottom, lefttop, leftbottom;
        topleft = topright = bottomleft = bottomright = righttop = rightbottom = lefttop = leftbottom = 0.5;
        var edges2 = [];
        if (cval === 1) {
          bottomleft = 1 - interpolateX2(minV, br, bl);
          leftbottom = 1 - interpolateX2(minV, tl, bl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 169) {
          bottomleft = interpolateX2(maxV, bl, br);
          leftbottom = interpolateX2(maxV, bl, tl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 4) {
          rightbottom = 1 - interpolateX2(minV, tr, br);
          bottomright = interpolateX2(minV, bl, br);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 166) {
          rightbottom = interpolateX2(maxV, br, tr);
          bottomright = 1 - interpolateX2(maxV, br, bl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 16) {
          righttop = interpolateX2(minV, br, tr);
          topright = interpolateX2(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 154) {
          righttop = 1 - interpolateX2(maxV, tr, br);
          topright = 1 - interpolateX2(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 64) {
          lefttop = interpolateX2(minV, bl, tl);
          topleft = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 106) {
          lefttop = 1 - interpolateX2(maxV, tl, bl);
          topleft = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 168) {
          bottomright = interpolateX2(maxV, bl, br);
          bottomleft = interpolateX2(minV, bl, br);
          leftbottom = interpolateX2(minV, bl, tl);
          lefttop = interpolateX2(maxV, bl, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 2) {
          bottomright = 1 - interpolateX2(minV, br, bl);
          bottomleft = 1 - interpolateX2(maxV, br, bl);
          leftbottom = 1 - interpolateX2(maxV, tl, bl);
          lefttop = 1 - interpolateX2(minV, tl, bl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 162) {
          righttop = interpolateX2(maxV, br, tr);
          rightbottom = interpolateX2(minV, br, tr);
          bottomright = 1 - interpolateX2(minV, br, bl);
          bottomleft = 1 - interpolateX2(maxV, br, bl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 8) {
          righttop = 1 - interpolateX2(minV, tr, br);
          rightbottom = 1 - interpolateX2(maxV, tr, br);
          bottomright = interpolateX2(maxV, bl, br);
          bottomleft = interpolateX2(minV, bl, br);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 138) {
          righttop = 1 - interpolateX2(minV, tr, br);
          rightbottom = 1 - interpolateX2(maxV, tr, br);
          topleft = 1 - interpolateX2(maxV, tr, tl);
          topright = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 32) {
          righttop = interpolateX2(maxV, br, tr);
          rightbottom = interpolateX2(minV, br, tr);
          topleft = interpolateX2(minV, tl, tr);
          topright = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 42) {
          leftbottom = 1 - interpolateX2(maxV, tl, bl);
          lefttop = 1 - interpolateX2(minV, tl, bl);
          topleft = interpolateX2(minV, tl, tr);
          topright = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 128) {
          leftbottom = interpolateX2(minV, bl, tl);
          lefttop = interpolateX2(maxV, bl, tl);
          topleft = 1 - interpolateX2(maxV, tr, tl);
          topright = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        }
        if (cval === 5) {
          rightbottom = 1 - interpolateX2(minV, tr, br);
          leftbottom = 1 - interpolateX2(minV, tl, bl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 165) {
          rightbottom = interpolateX2(maxV, br, tr);
          leftbottom = interpolateX2(maxV, bl, tl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 20) {
          bottomright = interpolateX2(minV, bl, br);
          topright = interpolateX2(minV, tl, tr);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 150) {
          bottomright = 1 - interpolateX2(maxV, br, bl);
          topright = 1 - interpolateX2(maxV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 80) {
          righttop = interpolateX2(minV, br, tr);
          lefttop = interpolateX2(minV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 90) {
          righttop = 1 - interpolateX2(maxV, tr, br);
          lefttop = 1 - interpolateX2(maxV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
        } else if (cval === 65) {
          bottomleft = 1 - interpolateX2(minV, br, bl);
          topleft = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 105) {
          bottomleft = interpolateX2(maxV, bl, br);
          topleft = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 160) {
          righttop = interpolateX2(maxV, br, tr);
          rightbottom = interpolateX2(minV, br, tr);
          leftbottom = interpolateX2(minV, bl, tl);
          lefttop = interpolateX2(maxV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 10) {
          righttop = 1 - interpolateX2(minV, tr, br);
          rightbottom = 1 - interpolateX2(maxV, tr, br);
          leftbottom = 1 - interpolateX2(maxV, tl, bl);
          lefttop = 1 - interpolateX2(minV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 130) {
          bottomright = 1 - interpolateX2(minV, br, bl);
          bottomleft = 1 - interpolateX2(maxV, br, bl);
          topleft = 1 - interpolateX2(maxV, tr, tl);
          topright = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 40) {
          bottomright = interpolateX2(maxV, bl, br);
          bottomleft = interpolateX2(minV, bl, br);
          topleft = interpolateX2(minV, tl, tr);
          topright = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 101) {
          rightbottom = interpolateX2(maxV, br, tr);
          topleft = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 69) {
          rightbottom = 1 - interpolateX2(minV, tr, br);
          topleft = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 149) {
          leftbottom = interpolateX2(maxV, bl, tl);
          topright = 1 - interpolateX2(maxV, tr, tl);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 21) {
          leftbottom = 1 - interpolateX2(minV, tl, bl);
          topright = interpolateX2(minV, tl, tr);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 86) {
          bottomright = 1 - interpolateX2(maxV, br, bl);
          lefttop = 1 - interpolateX2(maxV, tl, bl);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 84) {
          bottomright = interpolateX2(minV, bl, br);
          lefttop = interpolateX2(minV, bl, tl);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 89) {
          righttop = 1 - interpolateX2(maxV, tr, br);
          bottomleft = interpolateX2(maxV, bl, br);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 81) {
          righttop = interpolateX2(minV, br, tr);
          bottomleft = 1 - interpolateX2(minV, br, bl);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 96) {
          righttop = interpolateX2(maxV, br, tr);
          rightbottom = interpolateX2(minV, br, tr);
          lefttop = interpolateX2(minV, bl, tl);
          topleft = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 74) {
          righttop = 1 - interpolateX2(minV, tr, br);
          rightbottom = 1 - interpolateX2(maxV, tr, br);
          lefttop = 1 - interpolateX2(maxV, tl, bl);
          topleft = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 24) {
          righttop = 1 - interpolateX2(maxV, tr, br);
          bottomright = interpolateX2(maxV, bl, br);
          bottomleft = interpolateX2(minV, bl, br);
          topright = interpolateX2(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 146) {
          righttop = interpolateX2(minV, br, tr);
          bottomright = 1 - interpolateX2(minV, br, bl);
          bottomleft = 1 - interpolateX2(maxV, br, bl);
          topright = 1 - interpolateX2(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 6) {
          rightbottom = 1 - interpolateX2(minV, tr, br);
          bottomright = 1 - interpolateX2(maxV, br, bl);
          leftbottom = 1 - interpolateX2(maxV, tl, bl);
          lefttop = 1 - interpolateX2(minV, tl, bl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 164) {
          rightbottom = interpolateX2(maxV, br, tr);
          bottomright = interpolateX2(minV, bl, br);
          leftbottom = interpolateX2(minV, bl, tl);
          lefttop = interpolateX2(maxV, bl, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 129) {
          bottomleft = 1 - interpolateX2(minV, br, bl);
          leftbottom = interpolateX2(maxV, bl, tl);
          topleft = 1 - interpolateX2(maxV, tr, tl);
          topright = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 41) {
          bottomleft = interpolateX2(maxV, bl, br);
          leftbottom = 1 - interpolateX2(minV, tl, bl);
          topleft = interpolateX2(minV, tl, tr);
          topright = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 66) {
          bottomright = 1 - interpolateX2(minV, br, bl);
          bottomleft = 1 - interpolateX2(maxV, br, bl);
          lefttop = 1 - interpolateX2(maxV, tl, bl);
          topleft = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 104) {
          bottomright = interpolateX2(maxV, bl, br);
          bottomleft = interpolateX2(minV, bl, br);
          lefttop = interpolateX2(minV, bl, tl);
          topleft = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeTL[cval]);
        } else if (cval === 144) {
          righttop = interpolateX2(minV, br, tr);
          leftbottom = interpolateX2(minV, bl, tl);
          lefttop = interpolateX2(maxV, bl, tl);
          topright = 1 - interpolateX2(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 26) {
          righttop = 1 - interpolateX2(maxV, tr, br);
          leftbottom = 1 - interpolateX2(maxV, tl, bl);
          lefttop = 1 - interpolateX2(minV, tl, bl);
          topright = interpolateX2(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 36) {
          rightbottom = interpolateX2(maxV, br, tr);
          bottomright = interpolateX2(minV, bl, br);
          topleft = interpolateX2(minV, tl, tr);
          topright = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 134) {
          rightbottom = 1 - interpolateX2(minV, tr, br);
          bottomright = 1 - interpolateX2(maxV, br, bl);
          topleft = 1 - interpolateX2(maxV, tr, tl);
          topright = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 9) {
          righttop = 1 - interpolateX2(minV, tr, br);
          rightbottom = 1 - interpolateX2(maxV, tr, br);
          bottomleft = interpolateX2(maxV, bl, br);
          leftbottom = 1 - interpolateX2(minV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 161) {
          righttop = interpolateX2(maxV, br, tr);
          rightbottom = interpolateX2(minV, br, tr);
          bottomleft = 1 - interpolateX2(minV, br, bl);
          leftbottom = interpolateX2(maxV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 37) {
          rightbottom = interpolateX2(maxV, br, tr);
          leftbottom = 1 - interpolateX2(minV, tl, bl);
          topleft = interpolateX2(minV, tl, tr);
          topright = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 133) {
          rightbottom = 1 - interpolateX2(minV, tr, br);
          leftbottom = interpolateX2(maxV, bl, tl);
          topleft = 1 - interpolateX2(maxV, tr, tl);
          topright = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 148) {
          bottomright = interpolateX2(minV, bl, br);
          leftbottom = interpolateX2(minV, bl, tl);
          lefttop = interpolateX2(maxV, bl, tl);
          topright = 1 - interpolateX2(maxV, tr, tl);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 22) {
          bottomright = 1 - interpolateX2(maxV, br, bl);
          leftbottom = 1 - interpolateX2(maxV, tl, bl);
          lefttop = 1 - interpolateX2(minV, tl, bl);
          topright = interpolateX2(minV, tl, tr);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 82) {
          righttop = interpolateX2(minV, br, tr);
          bottomright = 1 - interpolateX2(minV, br, bl);
          bottomleft = 1 - interpolateX2(maxV, br, bl);
          lefttop = 1 - interpolateX2(maxV, tl, bl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 88) {
          righttop = 1 - interpolateX2(maxV, tr, br);
          bottomright = interpolateX2(maxV, bl, br);
          bottomleft = interpolateX2(minV, bl, br);
          lefttop = interpolateX2(minV, bl, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 73) {
          righttop = 1 - interpolateX2(minV, tr, br);
          rightbottom = 1 - interpolateX2(maxV, tr, br);
          bottomleft = interpolateX2(maxV, bl, br);
          topleft = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 97) {
          righttop = interpolateX2(maxV, br, tr);
          rightbottom = interpolateX2(minV, br, tr);
          bottomleft = 1 - interpolateX2(minV, br, bl);
          topleft = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
        } else if (cval === 145) {
          righttop = interpolateX2(minV, br, tr);
          bottomleft = 1 - interpolateX2(minV, br, bl);
          leftbottom = interpolateX2(maxV, bl, tl);
          topright = 1 - interpolateX2(maxV, tr, tl);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 25) {
          righttop = 1 - interpolateX2(maxV, tr, br);
          bottomleft = interpolateX2(maxV, bl, br);
          leftbottom = 1 - interpolateX2(minV, tl, bl);
          topright = interpolateX2(minV, tl, tr);
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 70) {
          rightbottom = 1 - interpolateX2(minV, tr, br);
          bottomright = 1 - interpolateX2(maxV, br, bl);
          lefttop = 1 - interpolateX2(maxV, tl, bl);
          topleft = 1 - interpolateX2(minV, tr, tl);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 100) {
          rightbottom = interpolateX2(maxV, br, tr);
          bottomright = interpolateX2(minV, bl, br);
          lefttop = interpolateX2(minV, bl, tl);
          topleft = interpolateX2(maxV, tl, tr);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 34) {
          if (flipped === 0) {
            righttop = 1 - interpolateX2(minV, tr, br);
            rightbottom = 1 - interpolateX2(maxV, tr, br);
            bottomright = interpolateX2(maxV, bl, br);
            bottomleft = interpolateX2(minV, bl, br);
            leftbottom = interpolateX2(minV, bl, tl);
            lefttop = interpolateX2(maxV, bl, tl);
            topleft = 1 - interpolateX2(maxV, tr, tl);
            topright = 1 - interpolateX2(minV, tr, tl);
          } else {
            righttop = interpolateX2(maxV, br, tr);
            rightbottom = interpolateX2(minV, br, tr);
            bottomright = 1 - interpolateX2(minV, br, bl);
            bottomleft = 1 - interpolateX2(maxV, br, bl);
            leftbottom = 1 - interpolateX2(maxV, tl, bl);
            lefttop = 1 - interpolateX2(minV, tl, bl);
            topleft = interpolateX2(minV, tl, tr);
            topright = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 35) {
          if (flipped === 4) {
            righttop = 1 - interpolateX2(minV, tr, br);
            rightbottom = 1 - interpolateX2(maxV, tr, br);
            bottomright = interpolateX2(maxV, bl, br);
            bottomleft = interpolateX2(minV, bl, br);
            leftbottom = interpolateX2(minV, bl, tl);
            lefttop = interpolateX2(maxV, bl, tl);
            topleft = 1 - interpolateX2(maxV, tr, tl);
            topright = 1 - interpolateX2(minV, tr, tl);
          } else {
            righttop = interpolateX2(maxV, br, tr);
            rightbottom = interpolateX2(minV, br, tr);
            bottomright = 1 - interpolateX2(minV, br, bl);
            bottomleft = 1 - interpolateX2(maxV, br, bl);
            leftbottom = 1 - interpolateX2(maxV, tl, bl);
            lefttop = 1 - interpolateX2(minV, tl, bl);
            topleft = interpolateX2(minV, tl, tr);
            topright = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 136) {
          if (flipped === 0) {
            righttop = interpolateX2(maxV, br, tr);
            rightbottom = interpolateX2(minV, br, tr);
            bottomright = 1 - interpolateX2(minV, br, bl);
            bottomleft = 1 - interpolateX2(maxV, br, bl);
            leftbottom = 1 - interpolateX2(maxV, tl, bl);
            lefttop = 1 - interpolateX2(minV, tl, bl);
            topleft = interpolateX2(minV, tl, tr);
            topright = interpolateX2(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX2(minV, tr, br);
            rightbottom = 1 - interpolateX2(maxV, tr, br);
            bottomright = interpolateX2(maxV, bl, br);
            bottomleft = interpolateX2(minV, bl, br);
            leftbottom = interpolateX2(minV, bl, tl);
            lefttop = interpolateX2(maxV, bl, tl);
            topleft = 1 - interpolateX2(maxV, tr, tl);
            topright = 1 - interpolateX2(minV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 153) {
          if (flipped === 0) {
            righttop = interpolateX2(minV, br, tr);
            bottomleft = 1 - interpolateX2(minV, br, bl);
            leftbottom = 1 - interpolateX2(minV, tl, bl);
            topright = interpolateX2(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX2(maxV, tr, br);
            bottomleft = interpolateX2(maxV, bl, br);
            leftbottom = interpolateX2(maxV, bl, tl);
            topright = 1 - interpolateX2(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 102) {
          if (flipped === 0) {
            rightbottom = 1 - interpolateX2(minV, tr, br);
            bottomright = interpolateX2(minV, bl, br);
            lefttop = interpolateX2(minV, bl, tl);
            topleft = 1 - interpolateX2(minV, tr, tl);
          } else {
            rightbottom = interpolateX2(maxV, br, tr);
            bottomright = 1 - interpolateX2(maxV, br, bl);
            lefttop = 1 - interpolateX2(maxV, tl, bl);
            topleft = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 155) {
          if (flipped === 4) {
            righttop = interpolateX2(minV, br, tr);
            bottomleft = 1 - interpolateX2(minV, br, bl);
            leftbottom = 1 - interpolateX2(minV, tl, bl);
            topright = interpolateX2(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX2(maxV, tr, br);
            bottomleft = interpolateX2(maxV, bl, br);
            leftbottom = interpolateX2(maxV, bl, tl);
            topright = 1 - interpolateX2(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 103) {
          if (flipped === 4) {
            rightbottom = 1 - interpolateX2(minV, tr, br);
            bottomright = interpolateX2(minV, bl, br);
            lefttop = interpolateX2(minV, bl, tl);
            topleft = 1 - interpolateX2(minV, tr, tl);
          } else {
            rightbottom = interpolateX2(maxV, br, tr);
            bottomright = 1 - interpolateX2(maxV, br, bl);
            lefttop = 1 - interpolateX2(maxV, tl, bl);
            topleft = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
        } else if (cval === 152) {
          if (flipped === 0) {
            righttop = interpolateX2(minV, br, tr);
            bottomright = 1 - interpolateX2(minV, br, bl);
            bottomleft = 1 - interpolateX2(maxV, br, bl);
            leftbottom = 1 - interpolateX2(maxV, tl, bl);
            lefttop = 1 - interpolateX2(minV, tl, bl);
            topright = interpolateX2(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX2(maxV, tr, br);
            bottomright = interpolateX2(maxV, bl, br);
            bottomleft = interpolateX2(minV, bl, br);
            leftbottom = interpolateX2(minV, bl, tl);
            lefttop = interpolateX2(maxV, bl, tl);
            topright = 1 - interpolateX2(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 156) {
          if (flipped === 4) {
            righttop = interpolateX2(minV, br, tr);
            bottomright = 1 - interpolateX2(minV, br, bl);
            bottomleft = 1 - interpolateX2(maxV, br, bl);
            leftbottom = 1 - interpolateX2(maxV, tl, bl);
            lefttop = 1 - interpolateX2(minV, tl, bl);
            topright = interpolateX2(minV, tl, tr);
          } else {
            righttop = 1 - interpolateX2(maxV, tr, br);
            bottomright = interpolateX2(maxV, bl, br);
            bottomleft = interpolateX2(minV, bl, br);
            leftbottom = interpolateX2(minV, bl, tl);
            lefttop = interpolateX2(maxV, bl, tl);
            topright = 1 - interpolateX2(maxV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeBL[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 137) {
          if (flipped === 0) {
            righttop = interpolateX2(maxV, br, tr);
            rightbottom = interpolateX2(minV, br, tr);
            bottomleft = 1 - interpolateX2(minV, br, bl);
            leftbottom = 1 - interpolateX2(minV, tl, bl);
            topleft = interpolateX2(minV, tl, tr);
            topright = interpolateX2(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX2(minV, tr, br);
            rightbottom = 1 - interpolateX2(maxV, tr, br);
            bottomleft = interpolateX2(maxV, bl, br);
            leftbottom = interpolateX2(maxV, bl, tl);
            topleft = 1 - interpolateX2(maxV, tr, tl);
            topright = 1 - interpolateX2(minV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 139) {
          if (flipped === 4) {
            righttop = interpolateX2(maxV, br, tr);
            rightbottom = interpolateX2(minV, br, tr);
            bottomleft = 1 - interpolateX2(minV, br, bl);
            leftbottom = 1 - interpolateX2(minV, tl, bl);
            topleft = interpolateX2(minV, tl, tr);
            topright = interpolateX2(maxV, tl, tr);
          } else {
            righttop = 1 - interpolateX2(minV, tr, br);
            rightbottom = 1 - interpolateX2(maxV, tr, br);
            bottomleft = interpolateX2(maxV, bl, br);
            leftbottom = interpolateX2(maxV, bl, tl);
            topleft = 1 - interpolateX2(maxV, tr, tl);
            topright = 1 - interpolateX2(minV, tr, tl);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
        } else if (cval === 98) {
          if (flipped === 0) {
            righttop = 1 - interpolateX2(minV, tr, br);
            rightbottom = 1 - interpolateX2(maxV, tr, br);
            bottomright = interpolateX2(maxV, bl, br);
            bottomleft = interpolateX2(minV, bl, br);
            lefttop = interpolateX2(minV, bl, tl);
            topleft = 1 - interpolateX2(minV, tr, tl);
          } else {
            righttop = interpolateX2(maxV, br, tr);
            rightbottom = interpolateX2(minV, br, tr);
            bottomright = 1 - interpolateX2(minV, br, bl);
            bottomleft = 1 - interpolateX2(maxV, br, bl);
            lefttop = 1 - interpolateX2(maxV, tl, bl);
            topleft = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 99) {
          if (flipped === 4) {
            righttop = 1 - interpolateX2(minV, tr, br);
            rightbottom = 1 - interpolateX2(maxV, tr, br);
            bottomright = interpolateX2(maxV, bl, br);
            bottomleft = interpolateX2(minV, bl, br);
            lefttop = interpolateX2(minV, bl, tl);
            topleft = 1 - interpolateX2(minV, tr, tl);
          } else {
            righttop = interpolateX2(maxV, br, tr);
            rightbottom = interpolateX2(minV, br, tr);
            bottomright = 1 - interpolateX2(minV, br, bl);
            bottomleft = 1 - interpolateX2(maxV, br, bl);
            lefttop = 1 - interpolateX2(maxV, tl, bl);
            topleft = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRT[cval]);
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBL[cval]);
        } else if (cval === 38) {
          if (flipped === 0) {
            rightbottom = 1 - interpolateX2(minV, tr, br);
            bottomright = interpolateX2(minV, bl, br);
            leftbottom = interpolateX2(minV, bl, tl);
            lefttop = interpolateX2(maxV, bl, tl);
            topleft = 1 - interpolateX2(maxV, tr, tl);
            topright = 1 - interpolateX2(minV, tr, tl);
          } else {
            rightbottom = interpolateX2(maxV, br, tr);
            bottomright = 1 - interpolateX2(maxV, br, bl);
            leftbottom = 1 - interpolateX2(maxV, tl, bl);
            lefttop = 1 - interpolateX2(minV, tl, bl);
            topleft = interpolateX2(minV, tl, tr);
            topright = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeLB[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 39) {
          if (flipped === 4) {
            rightbottom = 1 - interpolateX2(minV, tr, br);
            bottomright = interpolateX2(minV, bl, br);
            leftbottom = interpolateX2(minV, bl, tl);
            lefttop = interpolateX2(maxV, bl, tl);
            topleft = 1 - interpolateX2(maxV, tr, tl);
            topright = 1 - interpolateX2(minV, tr, tl);
          } else {
            rightbottom = interpolateX2(maxV, br, tr);
            bottomright = 1 - interpolateX2(maxV, br, bl);
            leftbottom = 1 - interpolateX2(maxV, tl, bl);
            lefttop = 1 - interpolateX2(minV, tl, bl);
            topleft = interpolateX2(minV, tl, tr);
            topright = interpolateX2(maxV, tl, tr);
          }
          edges2.push(isoBandEdgeRB[cval]);
          edges2.push(isoBandEdgeBR[cval]);
          edges2.push(isoBandEdgeLT[cval]);
        } else if (cval === 85) {
          righttop = 1;
          rightbottom = 0;
          bottomright = 1;
          bottomleft = 0;
          leftbottom = 0;
          lefttop = 1;
          topleft = 0;
          topright = 1;
        }
        if (topleft < 0 || topleft > 1 || topright < 0 || topright > 1 || righttop < 0 || righttop > 1 || bottomright < 0 || bottomright > 1 || leftbottom < 0 || leftbottom > 1 || lefttop < 0 || lefttop > 1) {
          console.log(
            "MarchingSquaresJS-isoBands: " + cval + " " + cval_real + " " + tl + "," + tr + "," + br + "," + bl + " " + flipped + " " + topleft + " " + topright + " " + righttop + " " + rightbottom + " " + bottomright + " " + bottomleft + " " + leftbottom + " " + lefttop
          );
        }
        BandGrid.cells[j][i] = {
          cval,
          cval_real,
          flipped,
          topleft,
          topright,
          righttop,
          rightbottom,
          bottomright,
          bottomleft,
          leftbottom,
          lefttop,
          edges: edges2
        };
      }
    }
  }
  return BandGrid;
}
function BandGrid2AreaPaths(grid) {
  var areas = [];
  var rows = grid.rows;
  var cols = grid.cols;
  var currentPolygon = [];
  for (var j = 0; j < rows; j++) {
    for (var i = 0; i < cols; i++) {
      if (typeof grid.cells[j][i] !== "undefined" && grid.cells[j][i].edges.length > 0) {
        var cell = grid.cells[j][i];
        var prev = getStartXY(cell), next3 = null, p = i, q = j;
        if (prev !== null) {
          currentPolygon.push([prev.p[0] + p, prev.p[1] + q]);
        }
        do {
          next3 = getExitXY(grid.cells[q][p], prev.x, prev.y, prev.o);
          if (next3 !== null) {
            currentPolygon.push([next3.p[0] + p, next3.p[1] + q]);
            p += next3.x;
            q += next3.y;
            prev = next3;
          } else {
            break;
          }
          if (q < 0 || q >= rows || p < 0 || p >= cols || typeof grid.cells[q][p] === "undefined") {
            p -= next3.x;
            q -= next3.y;
            var missing = traceOutOfGridPath(
              grid,
              p,
              q,
              next3.x,
              next3.y,
              next3.o
            );
            if (missing !== null) {
              missing.path.forEach(function(pp) {
                currentPolygon.push(pp);
              });
              p = missing.i;
              q = missing.j;
              prev = missing;
            } else {
              break;
            }
          }
        } while (typeof grid.cells[q][p] !== "undefined" && grid.cells[q][p].edges.length > 0);
        areas.push(currentPolygon);
        currentPolygon = [];
        if (grid.cells[j][i].edges.length > 0)
          i--;
      }
    }
  }
  return areas;
}
function traceOutOfGridPath(grid, i, j, d_x, d_y, d_o) {
  var cell = grid.cells[j][i];
  var cval = cell.cval_real;
  var p = i + d_x, q = j + d_y;
  var path = [];
  var closed = false;
  while (!closed) {
    if (typeof grid.cells[q] === "undefined" || typeof grid.cells[q][p] === "undefined") {
      q -= d_y;
      p -= d_x;
      cell = grid.cells[q][p];
      cval = cell.cval_real;
      if (d_y === -1) {
        if (d_o === 0) {
          if (cval & Node3) {
            path.push([p, q]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
          } else if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
          } else {
            path.push([p + cell.bottomright, q]);
            d_x = 0;
            d_y = 1;
            d_o = 1;
            closed = true;
            break;
          }
        } else if (cval & Node3) {
          path.push([p, q]);
          d_x = -1;
          d_y = 0;
          d_o = 0;
        } else if (cval & Node2) {
          path.push([p + cell.bottomright, q]);
          d_x = 0;
          d_y = 1;
          d_o = 1;
          closed = true;
          break;
        } else {
          path.push([p + cell.bottomleft, q]);
          d_x = 0;
          d_y = 1;
          d_o = 0;
          closed = true;
          break;
        }
      } else if (d_y === 1) {
        if (d_o === 0) {
          if (cval & Node1) {
            path.push([p + 1, q + 1]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else if (!(cval & Node0)) {
            path.push([p + cell.topright, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
            closed = true;
            break;
          } else {
            path.push([p + cell.topleft, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 0;
            closed = true;
            break;
          }
        } else if (cval & Node1) {
          path.push([p + 1, q + 1]);
          d_x = 1;
          d_y = 0;
          d_o = 1;
        } else {
          path.push([p + 1, q + 1]);
          d_x = 1;
          d_y = 0;
          d_o = 1;
        }
      } else if (d_x === -1) {
        if (d_o === 0) {
          if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else if (!(cval & Node3)) {
            path.push([p, q + cell.lefttop]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
            closed = true;
            break;
          } else {
            path.push([p, q + cell.leftbottom]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else {
            console.log("MarchingSquaresJS-isoBands: wtf");
            break;
          }
        }
      } else if (d_x === 1) {
        if (d_o === 0) {
          if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else {
            path.push([p + 1, q + cell.rightbottom]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else if (!(cval & Node1)) {
            path.push([p + 1, q + cell.rightbottom]);
            d_x = -1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          } else {
            path.push([p + 1, q + cell.righttop]);
            d_x = -1;
            d_y = 0;
            d_o = 1;
            break;
          }
        }
      } else {
        console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
        break;
      }
    } else {
      cell = grid.cells[q][p];
      cval = cell.cval_real;
      if (d_x === -1) {
        if (d_o === 0) {
          if (typeof grid.cells[q - 1] !== "undefined" && typeof grid.cells[q - 1][p] !== "undefined") {
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else if (cval & Node3) {
            path.push([p, q]);
          } else {
            path.push([p + cell.bottomright, q]);
            d_x = 0;
            d_y = 1;
            d_o = 1;
            closed = true;
            break;
          }
        } else if (cval & Node0) {
          console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!");
        } else {
          console.log(
            "MarchingSquaresJS-isoBands: found entry from top at " + p + "," + q
          );
          break;
        }
      } else if (d_x === 1) {
        if (d_o === 0) {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        } else {
          if (typeof grid.cells[q + 1] !== "undefined" && typeof grid.cells[q + 1][p] !== "undefined") {
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else if (cval & Node1) {
            path.push([p + 1, q + 1]);
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else {
            path.push([p + cell.topleft, q + 1]);
            d_x = 0;
            d_y = -1;
            d_o = 0;
            closed = true;
            break;
          }
        }
      } else if (d_y === -1) {
        if (d_o === 1) {
          if (typeof grid.cells[q][p + 1] !== "undefined") {
            d_x = 1;
            d_y = 0;
            d_o = 1;
          } else if (cval & Node2) {
            path.push([p + 1, q]);
            d_x = 0;
            d_y = -1;
            d_o = 1;
          } else {
            path.push([p + 1, q + cell.righttop]);
            d_x = -1;
            d_y = 0;
            d_o = 1;
            closed = true;
            break;
          }
        } else {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        }
      } else if (d_y === 1) {
        if (d_o === 0) {
          if (typeof grid.cells[q][p - 1] !== "undefined") {
            d_x = -1;
            d_y = 0;
            d_o = 0;
          } else if (cval & Node0) {
            path.push([p, q + 1]);
            d_x = 0;
            d_y = 1;
            d_o = 0;
          } else {
            path.push([p, q + cell.leftbottom]);
            d_x = 1;
            d_y = 0;
            d_o = 0;
            closed = true;
            break;
          }
        } else {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        }
      } else {
        console.log("MarchingSquaresJS-isoBands: where did we came from???");
        break;
      }
    }
    p += d_x;
    q += d_y;
    if (p === i && q === j) {
      break;
    }
  }
  return { path, i: p, j: q, x: d_x, y: d_y, o: d_o };
}
function deleteEdge(cell, edgeIdx) {
  delete cell.edges[edgeIdx];
  for (var k = edgeIdx + 1; k < cell.edges.length; k++) {
    cell.edges[k - 1] = cell.edges[k];
  }
  cell.edges.pop();
}
function getStartXY(cell) {
  if (cell.edges.length > 0) {
    var e = cell.edges[cell.edges.length - 1];
    var cval = cell.cval_real;
    switch (e) {
      case 0:
        if (cval & Node1) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        }
      case 1:
        if (cval & Node2) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 2:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        }
      case 3:
        if (cval & Node3) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 4:
        if (cval & Node1) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 5:
        if (cval & Node2) {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 6:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 7:
        if (cval & Node3) {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 8:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        }
      case 9:
        if (cval & Node3) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 10:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        }
      case 11:
        if (cval & Node0) {
          return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 12:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 13:
        if (cval & Node3) {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 14:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        }
      case 15:
        if (cval & Node0) {
          return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 16:
        if (cval & Node2) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        }
      case 17:
        if (cval & Node0) {
          return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 18:
        if (cval & Node3) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        }
      case 19:
        if (cval & Node0) {
          return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 20:
        if (cval & Node0) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        }
      case 21:
        if (cval & Node1) {
          return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      case 22:
        if (cval & Node0) {
          return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
        } else {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        }
      case 23:
        if (cval & Node1) {
          return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
        } else {
          return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
        }
      default:
        console.log("MarchingSquaresJS-isoBands: edge index out of range!");
        console.log(cell);
        break;
    }
  }
  return null;
}
function getExitXY(cell, x2, y2, o) {
  var e, id_x, d_x, d_y, cval = cell.cval;
  var d_o;
  switch (x2) {
    case -1:
      switch (o) {
        case 0:
          e = isoBandEdgeRB[cval];
          d_x = isoBandNextXRB[cval];
          d_y = isoBandNextYRB[cval];
          d_o = isoBandNextORB[cval];
          break;
        default:
          e = isoBandEdgeRT[cval];
          d_x = isoBandNextXRT[cval];
          d_y = isoBandNextYRT[cval];
          d_o = isoBandNextORT[cval];
          break;
      }
      break;
    case 1:
      switch (o) {
        case 0:
          e = isoBandEdgeLB[cval];
          d_x = isoBandNextXLB[cval];
          d_y = isoBandNextYLB[cval];
          d_o = isoBandNextOLB[cval];
          break;
        default:
          e = isoBandEdgeLT[cval];
          d_x = isoBandNextXLT[cval];
          d_y = isoBandNextYLT[cval];
          d_o = isoBandNextOLT[cval];
          break;
      }
      break;
    default:
      switch (y2) {
        case -1:
          switch (o) {
            case 0:
              e = isoBandEdgeTL[cval];
              d_x = isoBandNextXTL[cval];
              d_y = isoBandNextYTL[cval];
              d_o = isoBandNextOTL[cval];
              break;
            default:
              e = isoBandEdgeTR[cval];
              d_x = isoBandNextXTR[cval];
              d_y = isoBandNextYTR[cval];
              d_o = isoBandNextOTR[cval];
              break;
          }
          break;
        case 1:
          switch (o) {
            case 0:
              e = isoBandEdgeBL[cval];
              d_x = isoBandNextXBL[cval];
              d_y = isoBandNextYBL[cval];
              d_o = isoBandNextOBL[cval];
              break;
            default:
              e = isoBandEdgeBR[cval];
              d_x = isoBandNextXBR[cval];
              d_y = isoBandNextYBR[cval];
              d_o = isoBandNextOBR[cval];
              break;
          }
          break;
      }
      break;
  }
  id_x = cell.edges.indexOf(e);
  if (typeof cell.edges[id_x] !== "undefined") {
    deleteEdge(cell, id_x);
  } else {
    return null;
  }
  cval = cell.cval_real;
  switch (e) {
    case 0:
      if (cval & Node1) {
        x2 = cell.topleft;
        y2 = 1;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 1:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 2:
      if (cval & Node2) {
        x2 = cell.topleft;
        y2 = 1;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 3:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 4:
      if (cval & Node1) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 5:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = cell.topright;
        y2 = 1;
      }
      break;
    case 6:
      if (cval & Node2) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 7:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = cell.topright;
        y2 = 1;
      }
      break;
    case 8:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.righttop;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 9:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 10:
      if (cval & Node3) {
        x2 = 1;
        y2 = cell.righttop;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 11:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = 1;
        y2 = cell.righttop;
      }
      break;
    case 12:
      if (cval & Node2) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 13:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = 1;
        y2 = cell.rightbottom;
      }
      break;
    case 14:
      if (cval & Node3) {
        x2 = 1;
        y2 = cell.rightbottom;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 15:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = 1;
        y2 = cell.rightbottom;
      }
      break;
    case 16:
      if (cval & Node2) {
        x2 = 0;
        y2 = cell.leftbottom;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 17:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = cell.bottomright;
        y2 = 0;
      }
      break;
    case 18:
      if (cval & Node3) {
        x2 = cell.bottomleft;
        y2 = 0;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 19:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = cell.bottomleft;
        y2 = 0;
      }
      break;
    case 20:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.leftbottom;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 21:
      if (cval & Node1) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = 0;
        y2 = cell.leftbottom;
      }
      break;
    case 22:
      if (cval & Node0) {
        x2 = 0;
        y2 = cell.lefttop;
      } else {
        x2 = cell.topleft;
        y2 = 1;
      }
      break;
    case 23:
      if (cval & Node1) {
        x2 = cell.topright;
        y2 = 1;
      } else {
        x2 = 0;
        y2 = cell.lefttop;
      }
      break;
    default:
      console.log("MarchingSquaresJS-isoBands: edge index out of range!");
      console.log(cell);
      return null;
  }
  if (typeof x2 === "undefined" || typeof y2 === "undefined" || typeof d_x === "undefined" || typeof d_y === "undefined" || typeof d_o === "undefined") {
    console.log("MarchingSquaresJS-isoBands: undefined value!");
    console.log(cell);
    console.log(x2 + " " + y2 + " " + d_x + " " + d_y + " " + d_o);
  }
  return { p: [x2, y2], x: d_x, y: d_y, o: d_o };
}
function BandGrid2Areas(grid) {
  var areas = [];
  var area_idx = 0;
  grid.cells.forEach(function(g, j) {
    g.forEach(function(gg, i) {
      if (typeof gg !== "undefined") {
        var a = polygon_table[gg.cval](gg);
        if (typeof a === "object" && isArray(a)) {
          if (typeof a[0] === "object" && isArray(a[0])) {
            if (typeof a[0][0] === "object" && isArray(a[0][0])) {
              a.forEach(function(aa) {
                aa.forEach(function(aaa) {
                  aaa[0] += i;
                  aaa[1] += j;
                });
                areas[area_idx++] = aa;
              });
            } else {
              a.forEach(function(aa) {
                aa[0] += i;
                aa[1] += j;
              });
              areas[area_idx++] = a;
            }
          } else {
            console.log(
              "MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates"
            );
          }
        } else {
          console.log(
            "MarchingSquaresJS-isoBands: bandcell polygon with null coordinates"
          );
        }
      }
    });
  });
  return areas;
}
function isobands(pointGrid2, breaks, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var zProperty = options.zProperty || "elevation";
  var commonProperties = options.commonProperties || {};
  var breaksProperties = options.breaksProperties || [];
  collectionOf(pointGrid2, "Point", "Input must contain Points");
  if (!breaks)
    throw new Error("breaks is required");
  if (!Array.isArray(breaks))
    throw new Error("breaks is not an Array");
  if (!isObject(commonProperties))
    throw new Error("commonProperties is not an Object");
  if (!Array.isArray(breaksProperties))
    throw new Error("breaksProperties is not an Array");
  var matrix = gridToMatrix2(pointGrid2, { zProperty, flip: true });
  var contours = createContourLines(matrix, breaks, zProperty);
  contours = rescaleContours(contours, matrix, pointGrid2);
  var multipolygons = contours.map(function(contour, index2) {
    if (breaksProperties[index2] && !isObject(breaksProperties[index2])) {
      throw new Error("Each mappedProperty is required to be an Object");
    }
    var contourProperties = (0, import_object_assign3.default)(
      {},
      commonProperties,
      breaksProperties[index2]
    );
    contourProperties[zProperty] = contour[zProperty];
    var multiP = multiPolygon(contour.groupedRings, contourProperties);
    return multiP;
  });
  return featureCollection(multipolygons);
}
function createContourLines(matrix, breaks, property) {
  var contours = [];
  for (var i = 1; i < breaks.length; i++) {
    var lowerBand = +breaks[i - 1];
    var upperBand = +breaks[i];
    var isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);
    var nestedRings = orderByArea(isobandsCoords);
    var groupedRings = groupNestedRings(nestedRings);
    var obj = {};
    obj["groupedRings"] = groupedRings;
    obj[property] = lowerBand + "-" + upperBand;
    contours.push(obj);
  }
  return contours;
}
function rescaleContours(contours, matrix, points2) {
  var gridBbox = es_default(points2);
  var originalWidth = gridBbox[2] - gridBbox[0];
  var originalHeigth = gridBbox[3] - gridBbox[1];
  var x0 = gridBbox[0];
  var y0 = gridBbox[1];
  var matrixWidth = matrix[0].length - 1;
  var matrixHeight = matrix.length - 1;
  var scaleX = originalWidth / matrixWidth;
  var scaleY = originalHeigth / matrixHeight;
  var resize = function(point4) {
    point4[0] = point4[0] * scaleX + x0;
    point4[1] = point4[1] * scaleY + y0;
  };
  contours.forEach(function(contour) {
    contour.groupedRings.forEach(function(lineRingSet) {
      lineRingSet.forEach(function(lineRing) {
        lineRing.forEach(resize);
      });
    });
  });
  return contours;
}
function orderByArea(ringsCoords) {
  var ringsWithArea = [];
  var areas = [];
  ringsCoords.forEach(function(coords) {
    var ringArea2 = area(polygon([coords]));
    areas.push(ringArea2);
    ringsWithArea.push({ ring: coords, area: ringArea2 });
  });
  areas.sort(function(a, b) {
    return b - a;
  });
  var orderedByArea = [];
  areas.forEach(function(area5) {
    for (var lr = 0; lr < ringsWithArea.length; lr++) {
      if (ringsWithArea[lr].area === area5) {
        orderedByArea.push(ringsWithArea[lr].ring);
        ringsWithArea.splice(lr, 1);
        break;
      }
    }
  });
  return orderedByArea;
}
function groupNestedRings(orderedLinearRings) {
  var lrList = orderedLinearRings.map(function(lr) {
    return { lrCoordinates: lr, grouped: false };
  });
  var groupedLinearRingsCoords = [];
  while (!allGrouped(lrList)) {
    for (var i = 0; i < lrList.length; i++) {
      if (!lrList[i].grouped) {
        var group = [];
        group.push(lrList[i].lrCoordinates);
        lrList[i].grouped = true;
        var outerMostPoly = polygon([lrList[i].lrCoordinates]);
        for (var j = i + 1; j < lrList.length; j++) {
          if (!lrList[j].grouped) {
            var lrPoly = polygon([lrList[j].lrCoordinates]);
            if (isInside(lrPoly, outerMostPoly)) {
              group.push(lrList[j].lrCoordinates);
              lrList[j].grouped = true;
            }
          }
        }
        groupedLinearRingsCoords.push(group);
      }
    }
  }
  return groupedLinearRingsCoords;
}
function isInside(testPolygon, targetPolygon) {
  var points2 = es_default22(testPolygon);
  for (var i = 0; i < points2.features.length; i++) {
    if (!booleanPointInPolygon(points2.features[i], targetPolygon)) {
      return false;
    }
  }
  return true;
}
function allGrouped(list) {
  for (var i = 0; i < list.length; i++) {
    if (list[i].grouped === false) {
      return false;
    }
  }
  return true;
}
var es_default52 = isobands;

// node_modules/@turf/transform-rotate/dist/es/index.js
function transformRotate(geojson, angle4, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var pivot = options.pivot;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (angle4 === void 0 || angle4 === null || isNaN(angle4))
    throw new Error("angle is required");
  if (angle4 === 0)
    return geojson;
  if (!pivot)
    pivot = es_default19(geojson);
  if (mutate === false || mutate === void 0)
    geojson = es_default5(geojson);
  coordEach(geojson, function(pointCoords) {
    var initialAngle = es_default48(pivot, pointCoords);
    var finalAngle = initialAngle + angle4;
    var distance11 = es_default28(pivot, pointCoords);
    var newCoords = getCoords(es_default49(pivot, distance11, finalAngle));
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
  });
  return geojson;
}
var es_default53 = transformRotate;

// node_modules/@turf/transform-scale/dist/es/index.js
function transformScale(geojson, factor, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var origin = options.origin;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson required");
  if (typeof factor !== "number" || factor === 0)
    throw new Error("invalid factor");
  var originIsPoint = Array.isArray(origin) || typeof origin === "object";
  if (mutate !== true)
    geojson = es_default5(geojson);
  if (geojson.type === "FeatureCollection" && !originIsPoint) {
    featureEach(geojson, function(feature2, index2) {
      geojson.features[index2] = scale(feature2, factor, origin);
    });
    return geojson;
  }
  return scale(geojson, factor, origin);
}
function scale(feature2, factor, origin) {
  var isPoint = getType(feature2) === "Point";
  origin = defineOrigin(feature2, origin);
  if (factor === 1 || isPoint)
    return feature2;
  coordEach(feature2, function(coord) {
    var originalDistance = es_default28(origin, coord);
    var bearing2 = es_default48(origin, coord);
    var newDistance = originalDistance * factor;
    var newCoord = getCoords(es_default49(origin, newDistance, bearing2));
    coord[0] = newCoord[0];
    coord[1] = newCoord[1];
    if (coord.length === 3)
      coord[2] *= factor;
  });
  return feature2;
}
function defineOrigin(geojson, origin) {
  if (origin === void 0 || origin === null)
    origin = "centroid";
  if (Array.isArray(origin) || typeof origin === "object")
    return getCoord(origin);
  var bbox3 = geojson.bbox ? geojson.bbox : es_default(geojson);
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  switch (origin) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return point([west, south]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return point([east, south]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return point([west, north]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return point([east, north]);
    case "center":
      return es_default18(geojson);
    case void 0:
    case null:
    case "centroid":
      return es_default19(geojson);
    default:
      throw new Error("invalid origin");
  }
}
var es_default54 = transformScale;

// node_modules/@turf/transform-translate/dist/es/index.js
function transformTranslate(geojson, distance11, direction, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var units = options.units;
  var zTranslation = options.zTranslation;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (distance11 === void 0 || distance11 === null || isNaN(distance11))
    throw new Error("distance is required");
  if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
    throw new Error("zTranslation is not a number");
  zTranslation = zTranslation !== void 0 ? zTranslation : 0;
  if (distance11 === 0 && zTranslation === 0)
    return geojson;
  if (direction === void 0 || direction === null || isNaN(direction))
    throw new Error("direction is required");
  if (distance11 < 0) {
    distance11 = -distance11;
    direction = direction + 180;
  }
  if (mutate === false || mutate === void 0)
    geojson = es_default5(geojson);
  coordEach(geojson, function(pointCoords) {
    var newCoords = getCoords(
      es_default49(pointCoords, distance11, direction, { units })
    );
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
    if (zTranslation && pointCoords.length === 3)
      pointCoords[2] += zTranslation;
  });
  return geojson;
}
var es_default55 = transformTranslate;

// node_modules/@turf/line-offset/dist/es/index.js
function ab(segment) {
  var start = segment[0];
  var end = segment[1];
  return [end[0] - start[0], end[1] - start[1]];
}
function crossProduct(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function add(v1, v2) {
  return [v1[0] + v2[0], v1[1] + v2[1]];
}
function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}
function scalarMult(s, v) {
  return [s * v[0], s * v[1]];
}
function intersectSegments(a, b) {
  var p = a[0];
  var r = ab(a);
  var q = b[0];
  var s = ab(b);
  var cross = crossProduct(r, s);
  var qmp = sub(q, p);
  var numerator = crossProduct(qmp, s);
  var t = numerator / cross;
  var intersection12 = add(p, scalarMult(t, r));
  return intersection12;
}
function isParallel(a, b) {
  var r = ab(a);
  var s = ab(b);
  return crossProduct(r, s) === 0;
}
function intersection(a, b) {
  if (isParallel(a, b))
    return false;
  return intersectSegments(a, b);
}
function lineOffset(geojson, distance11, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var units = options.units;
  if (!geojson)
    throw new Error("geojson is required");
  if (distance11 === void 0 || distance11 === null || isNaN(distance11))
    throw new Error("distance is required");
  var type = getType(geojson);
  var properties = geojson.properties;
  switch (type) {
    case "LineString":
      return lineOffsetFeature(geojson, distance11, units);
    case "MultiLineString":
      var coords = [];
      flattenEach(geojson, function(feature2) {
        coords.push(
          lineOffsetFeature(feature2, distance11, units).geometry.coordinates
        );
      });
      return multiLineString(coords, properties);
    default:
      throw new Error("geometry " + type + " is not supported");
  }
}
function lineOffsetFeature(line, distance11, units) {
  var segments = [];
  var offsetDegrees = lengthToDegrees(distance11, units);
  var coords = getCoords(line);
  var finalCoords = [];
  coords.forEach(function(currentCoords, index2) {
    if (index2 !== coords.length - 1) {
      var segment = processSegment(
        currentCoords,
        coords[index2 + 1],
        offsetDegrees
      );
      segments.push(segment);
      if (index2 > 0) {
        var seg2Coords = segments[index2 - 1];
        var intersects7 = intersection(segment, seg2Coords);
        if (intersects7 !== false) {
          seg2Coords[1] = intersects7;
          segment[0] = intersects7;
        }
        finalCoords.push(seg2Coords[0]);
        if (index2 === coords.length - 2) {
          finalCoords.push(segment[0]);
          finalCoords.push(segment[1]);
        }
      }
      if (coords.length === 2) {
        finalCoords.push(segment[0]);
        finalCoords.push(segment[1]);
      }
    }
  });
  return lineString(finalCoords, line.properties);
}
function processSegment(point1, point22, offset) {
  var L = Math.sqrt(
    (point1[0] - point22[0]) * (point1[0] - point22[0]) + (point1[1] - point22[1]) * (point1[1] - point22[1])
  );
  var out1x = point1[0] + offset * (point22[1] - point1[1]) / L;
  var out2x = point22[0] + offset * (point22[1] - point1[1]) / L;
  var out1y = point1[1] + offset * (point1[0] - point22[0]) / L;
  var out2y = point22[1] + offset * (point1[0] - point22[0]) / L;
  return [
    [out1x, out1y],
    [out2x, out2y]
  ];
}
var es_default56 = lineOffset;

// node_modules/@turf/polygonize/dist/es/lib/util.js
function mathSign(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function orientationIndex(p1, p2, q) {
  var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
  return mathSign(dx1 * dy2 - dx2 * dy1);
}
function envelopeIsEqual(env1, env2) {
  var envX1 = env1.geometry.coordinates[0].map(function(c) {
    return c[0];
  }), envY1 = env1.geometry.coordinates[0].map(function(c) {
    return c[1];
  }), envX2 = env2.geometry.coordinates[0].map(function(c) {
    return c[0];
  }), envY2 = env2.geometry.coordinates[0].map(function(c) {
    return c[1];
  });
  return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
}
function envelopeContains(self2, env) {
  return env.geometry.coordinates[0].every(function(c) {
    return booleanPointInPolygon(point(c), self2);
  });
}
function coordinatesEqual(coord1, coord2) {
  return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}

// node_modules/@turf/polygonize/dist/es/lib/Node.js
var Node = (
  /** @class */
  function() {
    function Node6(coordinates) {
      this.id = Node6.buildId(coordinates);
      this.coordinates = coordinates;
      this.innerEdges = [];
      this.outerEdges = [];
      this.outerEdgesSorted = false;
    }
    Node6.buildId = function(coordinates) {
      return coordinates.join(",");
    };
    Node6.prototype.removeInnerEdge = function(edge) {
      this.innerEdges = this.innerEdges.filter(function(e) {
        return e.from.id !== edge.from.id;
      });
    };
    Node6.prototype.removeOuterEdge = function(edge) {
      this.outerEdges = this.outerEdges.filter(function(e) {
        return e.to.id !== edge.to.id;
      });
    };
    Node6.prototype.addOuterEdge = function(edge) {
      this.outerEdges.push(edge);
      this.outerEdgesSorted = false;
    };
    Node6.prototype.sortOuterEdges = function() {
      var _this = this;
      if (!this.outerEdgesSorted) {
        this.outerEdges.sort(function(a, b) {
          var aNode = a.to, bNode = b.to;
          if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
            return 1;
          if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
            return -1;
          if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
            if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
              return aNode.coordinates[1] - bNode.coordinates[1];
            return bNode.coordinates[1] - aNode.coordinates[1];
          }
          var det2 = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
          if (det2 < 0)
            return 1;
          if (det2 > 0)
            return -1;
          var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
          return d1 - d2;
        });
        this.outerEdgesSorted = true;
      }
    };
    Node6.prototype.getOuterEdges = function() {
      this.sortOuterEdges();
      return this.outerEdges;
    };
    Node6.prototype.getOuterEdge = function(i) {
      this.sortOuterEdges();
      return this.outerEdges[i];
    };
    Node6.prototype.addInnerEdge = function(edge) {
      this.innerEdges.push(edge);
    };
    return Node6;
  }()
);
var Node_default = Node;

// node_modules/@turf/polygonize/dist/es/lib/Edge.js
var Edge = (
  /** @class */
  function() {
    function Edge3(from, to) {
      this.from = from;
      this.to = to;
      this.next = void 0;
      this.label = void 0;
      this.symetric = void 0;
      this.ring = void 0;
      this.from.addOuterEdge(this);
      this.to.addInnerEdge(this);
    }
    Edge3.prototype.getSymetric = function() {
      if (!this.symetric) {
        this.symetric = new Edge3(this.to, this.from);
        this.symetric.symetric = this;
      }
      return this.symetric;
    };
    Edge3.prototype.deleteEdge = function() {
      this.from.removeOuterEdge(this);
      this.to.removeInnerEdge(this);
    };
    Edge3.prototype.isEqual = function(edge) {
      return this.from.id === edge.from.id && this.to.id === edge.to.id;
    };
    Edge3.prototype.toString = function() {
      return "Edge { " + this.from.id + " -> " + this.to.id + " }";
    };
    Edge3.prototype.toLineString = function() {
      return lineString([this.from.coordinates, this.to.coordinates]);
    };
    Edge3.prototype.compareTo = function(edge) {
      return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
    };
    return Edge3;
  }()
);
var Edge_default = Edge;

// node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js
var EdgeRing = (
  /** @class */
  function() {
    function EdgeRing4() {
      this.edges = [];
      this.polygon = void 0;
      this.envelope = void 0;
    }
    EdgeRing4.prototype.push = function(edge) {
      this.edges.push(edge);
      this.polygon = this.envelope = void 0;
    };
    EdgeRing4.prototype.get = function(i) {
      return this.edges[i];
    };
    Object.defineProperty(EdgeRing4.prototype, "length", {
      /**
       * Getter of length property.
       *
       * @memberof EdgeRing
       * @returns {number} - Length of the edge ring.
       */
      get: function() {
        return this.edges.length;
      },
      enumerable: true,
      configurable: true
    });
    EdgeRing4.prototype.forEach = function(f) {
      this.edges.forEach(f);
    };
    EdgeRing4.prototype.map = function(f) {
      return this.edges.map(f);
    };
    EdgeRing4.prototype.some = function(f) {
      return this.edges.some(f);
    };
    EdgeRing4.prototype.isValid = function() {
      return true;
    };
    EdgeRing4.prototype.isHole = function() {
      var _this = this;
      var hiIndex = this.edges.reduce(function(high, edge, i) {
        if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
          high = i;
        return high;
      }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
      if (disc === 0)
        return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
      return disc > 0;
    };
    EdgeRing4.prototype.toMultiPoint = function() {
      return multiPoint(this.edges.map(function(edge) {
        return edge.from.coordinates;
      }));
    };
    EdgeRing4.prototype.toPolygon = function() {
      if (this.polygon)
        return this.polygon;
      var coordinates = this.edges.map(function(edge) {
        return edge.from.coordinates;
      });
      coordinates.push(this.edges[0].from.coordinates);
      return this.polygon = polygon([coordinates]);
    };
    EdgeRing4.prototype.getEnvelope = function() {
      if (this.envelope)
        return this.envelope;
      return this.envelope = es_default14(this.toPolygon());
    };
    EdgeRing4.findEdgeRingContaining = function(testEdgeRing, shellList) {
      var testEnvelope = testEdgeRing.getEnvelope();
      var minEnvelope, minShell;
      shellList.forEach(function(shell) {
        var tryEnvelope = shell.getEnvelope();
        if (minShell)
          minEnvelope = minShell.getEnvelope();
        if (envelopeIsEqual(tryEnvelope, testEnvelope))
          return;
        if (envelopeContains(tryEnvelope, testEnvelope)) {
          var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
            return edge.from.coordinates;
          });
          var testPoint = void 0;
          var _loop_1 = function(pt2) {
            if (!shell.some(function(edge) {
              return coordinatesEqual(pt2, edge.from.coordinates);
            })) {
              testPoint = pt2;
            }
          };
          for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
            var pt = testEdgeRingCoordinates_1[_i];
            _loop_1(pt);
          }
          if (testPoint && shell.inside(point(testPoint))) {
            if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
              minShell = shell;
          }
        }
      });
      return minShell;
    };
    EdgeRing4.prototype.inside = function(pt) {
      return booleanPointInPolygon(pt, this.toPolygon());
    };
    return EdgeRing4;
  }()
);
var EdgeRing_default = EdgeRing;

// node_modules/@turf/polygonize/dist/es/lib/Graph.js
function validateGeoJson(geoJson) {
  if (!geoJson)
    throw new Error("No geojson passed");
  if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
    throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
}
var Graph = (
  /** @class */
  function() {
    function Graph3() {
      this.edges = [];
      this.nodes = {};
    }
    Graph3.fromGeoJson = function(geoJson) {
      validateGeoJson(geoJson);
      var graph = new Graph3();
      flattenEach(geoJson, function(feature2) {
        featureOf(feature2, "LineString", "Graph::fromGeoJson");
        coordReduce(feature2, function(prev, cur) {
          if (prev) {
            var start = graph.getNode(prev), end = graph.getNode(cur);
            graph.addEdge(start, end);
          }
          return cur;
        });
      });
      return graph;
    };
    Graph3.prototype.getNode = function(coordinates) {
      var id = Node_default.buildId(coordinates);
      var node = this.nodes[id];
      if (!node)
        node = this.nodes[id] = new Node_default(coordinates);
      return node;
    };
    Graph3.prototype.addEdge = function(from, to) {
      var edge = new Edge_default(from, to), symetricEdge = edge.getSymetric();
      this.edges.push(edge);
      this.edges.push(symetricEdge);
    };
    Graph3.prototype.deleteDangles = function() {
      var _this = this;
      Object.keys(this.nodes).map(function(id) {
        return _this.nodes[id];
      }).forEach(function(node) {
        return _this._removeIfDangle(node);
      });
    };
    Graph3.prototype._removeIfDangle = function(node) {
      var _this = this;
      if (node.innerEdges.length <= 1) {
        var outerNodes = node.getOuterEdges().map(function(e) {
          return e.to;
        });
        this.removeNode(node);
        outerNodes.forEach(function(n) {
          return _this._removeIfDangle(n);
        });
      }
    };
    Graph3.prototype.deleteCutEdges = function() {
      var _this = this;
      this._computeNextCWEdges();
      this._findLabeledEdgeRings();
      this.edges.forEach(function(edge) {
        if (edge.label === edge.symetric.label) {
          _this.removeEdge(edge.symetric);
          _this.removeEdge(edge);
        }
      });
    };
    Graph3.prototype._computeNextCWEdges = function(node) {
      var _this = this;
      if (typeof node === "undefined") {
        Object.keys(this.nodes).forEach(function(id) {
          return _this._computeNextCWEdges(_this.nodes[id]);
        });
      } else {
        node.getOuterEdges().forEach(function(edge, i) {
          node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
        });
      }
    };
    Graph3.prototype._computeNextCCWEdges = function(node, label) {
      var edges2 = node.getOuterEdges();
      var firstOutDE, prevInDE;
      for (var i = edges2.length - 1; i >= 0; --i) {
        var de = edges2[i], sym = de.symetric, outDE = void 0, inDE = void 0;
        if (de.label === label)
          outDE = de;
        if (sym.label === label)
          inDE = sym;
        if (!outDE || !inDE)
          continue;
        if (inDE)
          prevInDE = inDE;
        if (outDE) {
          if (prevInDE) {
            prevInDE.next = outDE;
            prevInDE = void 0;
          }
          if (!firstOutDE)
            firstOutDE = outDE;
        }
      }
      if (prevInDE)
        prevInDE.next = firstOutDE;
    };
    Graph3.prototype._findLabeledEdgeRings = function() {
      var edgeRingStarts = [];
      var label = 0;
      this.edges.forEach(function(edge) {
        if (edge.label >= 0)
          return;
        edgeRingStarts.push(edge);
        var e = edge;
        do {
          e.label = label;
          e = e.next;
        } while (!edge.isEqual(e));
        label++;
      });
      return edgeRingStarts;
    };
    Graph3.prototype.getEdgeRings = function() {
      var _this = this;
      this._computeNextCWEdges();
      this.edges.forEach(function(edge) {
        edge.label = void 0;
      });
      this._findLabeledEdgeRings().forEach(function(edge) {
        _this._findIntersectionNodes(edge).forEach(function(node) {
          _this._computeNextCCWEdges(node, edge.label);
        });
      });
      var edgeRingList = [];
      this.edges.forEach(function(edge) {
        if (edge.ring)
          return;
        edgeRingList.push(_this._findEdgeRing(edge));
      });
      return edgeRingList;
    };
    Graph3.prototype._findIntersectionNodes = function(startEdge) {
      var intersectionNodes = [];
      var edge = startEdge;
      var _loop_1 = function() {
        var degree = 0;
        edge.from.getOuterEdges().forEach(function(e) {
          if (e.label === startEdge.label)
            ++degree;
        });
        if (degree > 1)
          intersectionNodes.push(edge.from);
        edge = edge.next;
      };
      do {
        _loop_1();
      } while (!startEdge.isEqual(edge));
      return intersectionNodes;
    };
    Graph3.prototype._findEdgeRing = function(startEdge) {
      var edge = startEdge;
      var edgeRing = new EdgeRing_default();
      do {
        edgeRing.push(edge);
        edge.ring = edgeRing;
        edge = edge.next;
      } while (!startEdge.isEqual(edge));
      return edgeRing;
    };
    Graph3.prototype.removeNode = function(node) {
      var _this = this;
      node.getOuterEdges().forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      node.innerEdges.forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      delete this.nodes[node.id];
    };
    Graph3.prototype.removeEdge = function(edge) {
      this.edges = this.edges.filter(function(e) {
        return !e.isEqual(edge);
      });
      edge.deleteEdge();
    };
    return Graph3;
  }()
);
var Graph_default = Graph;

// node_modules/@turf/polygonize/dist/es/index.js
function polygonize(geoJson) {
  var graph = Graph_default.fromGeoJson(geoJson);
  graph.deleteDangles();
  graph.deleteCutEdges();
  var holes = [], shells = [];
  graph.getEdgeRings().filter(function(edgeRing) {
    return edgeRing.isValid();
  }).forEach(function(edgeRing) {
    if (edgeRing.isHole())
      holes.push(edgeRing);
    else
      shells.push(edgeRing);
  });
  holes.forEach(function(hole) {
    if (EdgeRing_default.findEdgeRingContaining(hole, shells))
      shells.push(hole);
  });
  return featureCollection(shells.map(function(shell) {
    return shell.toPolygon();
  }));
}

// node_modules/@turf/boolean-disjoint/dist/es/index.js
function booleanDisjoint(feature1, feature2) {
  var bool = true;
  flattenEach(feature1, function(flatten1) {
    flattenEach(feature2, function(flatten2) {
      if (bool === false) {
        return false;
      }
      bool = disjoint(flatten1.geometry, flatten2.geometry);
    });
  });
  return bool;
}
function disjoint(geom1, geom2) {
  switch (geom1.type) {
    case "Point":
      switch (geom2.type) {
        case "Point":
          return !compareCoords2(geom1.coordinates, geom2.coordinates);
        case "LineString":
          return !isPointOnLine(geom2, geom1);
        case "Polygon":
          return !booleanPointInPolygon(geom1, geom2);
      }
      break;
    case "LineString":
      switch (geom2.type) {
        case "Point":
          return !isPointOnLine(geom1, geom2);
        case "LineString":
          return !isLineOnLine2(geom1, geom2);
        case "Polygon":
          return !isLineInPoly2(geom2, geom1);
      }
      break;
    case "Polygon":
      switch (geom2.type) {
        case "Point":
          return !booleanPointInPolygon(geom2, geom1);
        case "LineString":
          return !isLineInPoly2(geom1, geom2);
        case "Polygon":
          return !isPolyInPoly2(geom2, geom1);
      }
  }
  return false;
}
function isPointOnLine(lineString2, pt) {
  for (var i = 0; i < lineString2.coordinates.length - 1; i++) {
    if (isPointOnLineSegment3(lineString2.coordinates[i], lineString2.coordinates[i + 1], pt.coordinates)) {
      return true;
    }
  }
  return false;
}
function isLineOnLine2(lineString1, lineString2) {
  var doLinesIntersect = es_default26(lineString1, lineString2);
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isLineInPoly2(polygon4, lineString2) {
  for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
    var coord = _a[_i];
    if (booleanPointInPolygon(coord, polygon4)) {
      return true;
    }
  }
  var doLinesIntersect = es_default26(lineString2, es_default44(polygon4));
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPolyInPoly2(feature1, feature2) {
  for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {
    var coord1 = _a[_i];
    if (booleanPointInPolygon(coord1, feature2)) {
      return true;
    }
  }
  for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {
    var coord2 = _c[_b];
    if (booleanPointInPolygon(coord2, feature1)) {
      return true;
    }
  }
  var doLinesIntersect = es_default26(es_default44(feature1), es_default44(feature2));
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPointOnLineSegment3(lineSegmentStart, lineSegmentEnd, pt) {
  var dxc = pt[0] - lineSegmentStart[0];
  var dyc = pt[1] - lineSegmentStart[1];
  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) {
    return false;
  }
  if (Math.abs(dxl) >= Math.abs(dyl)) {
    if (dxl > 0) {
      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
    } else {
      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
  } else if (dyl > 0) {
    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
  } else {
    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  }
}
function compareCoords2(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
var es_default57 = booleanDisjoint;

// node_modules/@turf/boolean-contains/dist/es/index.js
function booleanContains(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  var coords1 = geom1.coordinates;
  var coords2 = geom2.coordinates;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "Point":
          return compareCoords3(coords1, coords2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "Point":
          return isPointInMultiPoint2(geom1, geom2);
        case "MultiPoint":
          return isMultiPointInMultiPoint2(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "Point":
          return es_default35(geom2, geom1, { ignoreEndVertices: true });
        case "LineString":
          return isLineOnLine3(geom1, geom2);
        case "MultiPoint":
          return isMultiPointOnLine2(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Point":
          return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });
        case "LineString":
          return isLineInPoly3(geom1, geom2);
        case "Polygon":
          return isPolyInPoly3(geom1, geom2);
        case "MultiPoint":
          return isMultiPointInPoly2(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPointInMultiPoint2(multiPoint2, pt) {
  var i;
  var output = false;
  for (i = 0; i < multiPoint2.coordinates.length; i++) {
    if (compareCoords3(multiPoint2.coordinates[i], pt.coordinates)) {
      output = true;
      break;
    }
  }
  return output;
}
function isMultiPointInMultiPoint2(multiPoint1, multiPoint2) {
  for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
    var coord2 = _a[_i];
    var matchFound = false;
    for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {
      var coord1 = _c[_b];
      if (compareCoords3(coord2, coord1)) {
        matchFound = true;
        break;
      }
    }
    if (!matchFound) {
      return false;
    }
  }
  return true;
}
function isMultiPointOnLine2(lineString2, multiPoint2) {
  var haveFoundInteriorPoint = false;
  for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
    var coord = _a[_i];
    if (es_default35(coord, lineString2, { ignoreEndVertices: true })) {
      haveFoundInteriorPoint = true;
    }
    if (!es_default35(coord, lineString2)) {
      return false;
    }
  }
  if (haveFoundInteriorPoint) {
    return true;
  }
  return false;
}
function isMultiPointInPoly2(polygon4, multiPoint2) {
  for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
    var coord = _a[_i];
    if (!booleanPointInPolygon(coord, polygon4, { ignoreBoundary: true })) {
      return false;
    }
  }
  return true;
}
function isLineOnLine3(lineString1, lineString2) {
  var haveFoundInteriorPoint = false;
  for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
    var coords = _a[_i];
    if (es_default35({ type: "Point", coordinates: coords }, lineString1, {
      ignoreEndVertices: true
    })) {
      haveFoundInteriorPoint = true;
    }
    if (!es_default35({ type: "Point", coordinates: coords }, lineString1, {
      ignoreEndVertices: false
    })) {
      return false;
    }
  }
  return haveFoundInteriorPoint;
}
function isLineInPoly3(polygon4, linestring3) {
  var output = false;
  var i = 0;
  var polyBbox = es_default(polygon4);
  var lineBbox = es_default(linestring3);
  if (!doBBoxOverlap2(polyBbox, lineBbox)) {
    return false;
  }
  for (i; i < linestring3.coordinates.length - 1; i++) {
    var midPoint3 = getMidpoint2(linestring3.coordinates[i], linestring3.coordinates[i + 1]);
    if (booleanPointInPolygon({ type: "Point", coordinates: midPoint3 }, polygon4, {
      ignoreBoundary: true
    })) {
      output = true;
      break;
    }
  }
  return output;
}
function isPolyInPoly3(feature1, feature2) {
  if (feature1.type === "Feature" && feature1.geometry === null) {
    return false;
  }
  if (feature2.type === "Feature" && feature2.geometry === null) {
    return false;
  }
  var poly1Bbox = es_default(feature1);
  var poly2Bbox = es_default(feature2);
  if (!doBBoxOverlap2(poly1Bbox, poly2Bbox)) {
    return false;
  }
  var coords = getGeom(feature2).coordinates;
  for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
    var ring = coords_1[_i];
    for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {
      var coord = ring_1[_a];
      if (!booleanPointInPolygon(coord, feature1)) {
        return false;
      }
    }
  }
  return true;
}
function doBBoxOverlap2(bbox1, bbox22) {
  if (bbox1[0] > bbox22[0]) {
    return false;
  }
  if (bbox1[2] < bbox22[2]) {
    return false;
  }
  if (bbox1[1] > bbox22[1]) {
    return false;
  }
  if (bbox1[3] < bbox22[3]) {
    return false;
  }
  return true;
}
function compareCoords3(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint2(pair1, pair2) {
  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}

// node_modules/@turf/boolean-crosses/dist/es/index.js
function booleanCrosses(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "MultiPoint":
      switch (type2) {
        case "LineString":
          return doMultiPointAndLineStringCross(geom1, geom2);
        case "Polygon":
          return doesMultiPointCrossPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "MultiPoint":
          return doMultiPointAndLineStringCross(geom2, geom1);
        case "LineString":
          return doLineStringsCross(geom1, geom2);
        case "Polygon":
          return doLineStringAndPolygonCross(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "MultiPoint":
          return doesMultiPointCrossPoly(geom2, geom1);
        case "LineString":
          return doLineStringAndPolygonCross(geom2, geom1);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function doMultiPointAndLineStringCross(multiPoint2, lineString2) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint2.coordinates.length;
  var i = 0;
  while (i < pointLength && !foundIntPoint && !foundExtPoint) {
    for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
      var incEndVertices = true;
      if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
        incEndVertices = false;
      }
      if (isPointOnLineSegment4(lineString2.coordinates[i2], lineString2.coordinates[i2 + 1], multiPoint2.coordinates[i], incEndVertices)) {
        foundIntPoint = true;
      } else {
        foundExtPoint = true;
      }
    }
    i++;
  }
  return foundIntPoint && foundExtPoint;
}
function doLineStringsCross(lineString1, lineString2) {
  var doLinesIntersect = es_default26(lineString1, lineString2);
  if (doLinesIntersect.features.length > 0) {
    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {
      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
        var incEndVertices = true;
        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
          incEndVertices = false;
        }
        if (isPointOnLineSegment4(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {
          return true;
        }
      }
    }
  }
  return false;
}
function doLineStringAndPolygonCross(lineString2, polygon4) {
  var line = polygonToLine(polygon4);
  var doLinesIntersect = es_default26(lineString2, line);
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function doesMultiPointCrossPoly(multiPoint2, polygon4) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint2.coordinates.length;
  for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {
    if (booleanPointInPolygon(point(multiPoint2.coordinates[i]), polygon4)) {
      foundIntPoint = true;
    } else {
      foundExtPoint = true;
    }
  }
  return foundExtPoint && foundIntPoint;
}
function isPointOnLineSegment4(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
  var dxc = pt[0] - lineSegmentStart[0];
  var dyc = pt[1] - lineSegmentStart[1];
  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) {
    return false;
  }
  if (incEnd) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  } else {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
  }
}
var es_default58 = booleanCrosses;

// node_modules/@turf/boolean-overlap/dist/es/index.js
var import_geojson_equality = __toESM(require_geojson_equality());
function booleanOverlap(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  if (type1 === "MultiPoint" && type2 !== "MultiPoint" || (type1 === "LineString" || type1 === "MultiLineString") && type2 !== "LineString" && type2 !== "MultiLineString" || (type1 === "Polygon" || type1 === "MultiPolygon") && type2 !== "Polygon" && type2 !== "MultiPolygon") {
    throw new Error("features must be of the same type");
  }
  if (type1 === "Point")
    throw new Error("Point geometry not supported");
  var equality = new import_geojson_equality.default({ precision: 6 });
  if (equality.compare(feature1, feature2))
    return false;
  var overlap2 = 0;
  switch (type1) {
    case "MultiPoint":
      for (var i = 0; i < geom1.coordinates.length; i++) {
        for (var j = 0; j < geom2.coordinates.length; j++) {
          var coord1 = geom1.coordinates[i];
          var coord2 = geom2.coordinates[j];
          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
            return true;
          }
        }
      }
      return false;
    case "LineString":
    case "MultiLineString":
      segmentEach(feature1, function(segment1) {
        segmentEach(feature2, function(segment2) {
          if (es_default46(segment1, segment2).features.length)
            overlap2++;
        });
      });
      break;
    case "Polygon":
    case "MultiPolygon":
      segmentEach(feature1, function(segment1) {
        segmentEach(feature2, function(segment2) {
          if (es_default26(segment1, segment2).features.length)
            overlap2++;
        });
      });
      break;
  }
  return overlap2 > 0;
}

// node_modules/@turf/boolean-equal/dist/es/index.js
var import_geojson_equality2 = __toESM(require_geojson_equality());
function booleanEqual(feature1, feature2) {
  var type1 = getGeom(feature1).type;
  var type2 = getGeom(feature2).type;
  if (type1 !== type2)
    return false;
  var equality = new import_geojson_equality2.default({ precision: 6 });
  return equality.compare(es_default9(feature1), es_default9(feature2));
}
var es_default59 = booleanEqual;

// node_modules/@turf/boolean-intersects/dist/es/index.js
function booleanIntersects(feature1, feature2) {
  var bool = false;
  flattenEach(feature1, function(flatten1) {
    flattenEach(feature2, function(flatten2) {
      if (bool === true) {
        return true;
      }
      bool = !es_default57(flatten1.geometry, flatten2.geometry);
    });
  });
  return bool;
}

// node_modules/@turf/clusters-dbscan/dist/es/index.js
var import_density_clustering = __toESM(require_lib());
function clustersDbscan(points2, maxDistance, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.mutate !== true)
    points2 = es_default5(points2);
  options.minPoints = options.minPoints || 3;
  var dbscan = new import_density_clustering.default.DBSCAN();
  var clusteredIds = dbscan.run(coordAll(points2), convertLength(maxDistance, options.units), options.minPoints, es_default4);
  var clusterId = -1;
  clusteredIds.forEach(function(clusterIds) {
    clusterId++;
    clusterIds.forEach(function(idx) {
      var clusterPoint = points2.features[idx];
      if (!clusterPoint.properties)
        clusterPoint.properties = {};
      clusterPoint.properties.cluster = clusterId;
      clusterPoint.properties.dbscan = "core";
    });
  });
  dbscan.noise.forEach(function(noiseId) {
    var noisePoint = points2.features[noiseId];
    if (!noisePoint.properties)
      noisePoint.properties = {};
    if (noisePoint.properties.cluster)
      noisePoint.properties.dbscan = "edge";
    else
      noisePoint.properties.dbscan = "noise";
  });
  return points2;
}
var es_default60 = clustersDbscan;

// node_modules/@turf/clusters-kmeans/dist/es/index.js
var import_skmeans = __toESM(require_main());
function clustersKmeans(points2, options) {
  if (options === void 0) {
    options = {};
  }
  var count2 = points2.features.length;
  options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count2 / 2));
  if (options.numberOfClusters > count2)
    options.numberOfClusters = count2;
  if (options.mutate !== true)
    points2 = es_default5(points2);
  var data = coordAll(points2);
  var initialCentroids = data.slice(0, options.numberOfClusters);
  var skmeansResult = (0, import_skmeans.default)(data, options.numberOfClusters, initialCentroids);
  var centroids = {};
  skmeansResult.centroids.forEach(function(coord, idx) {
    centroids[idx] = coord;
  });
  featureEach(points2, function(point4, index2) {
    var clusterId = skmeansResult.idxs[index2];
    point4.properties.cluster = clusterId;
    point4.properties.centroid = centroids[clusterId];
  });
  return points2;
}
var es_default61 = clustersKmeans;

// node_modules/@turf/boolean-parallel/dist/es/index.js
function booleanParallel(line1, line2) {
  if (!line1)
    throw new Error("line1 is required");
  if (!line2)
    throw new Error("line2 is required");
  var type1 = getType2(line1, "line1");
  if (type1 !== "LineString")
    throw new Error("line1 must be a LineString");
  var type2 = getType2(line2, "line2");
  if (type2 !== "LineString")
    throw new Error("line2 must be a LineString");
  var segments1 = es_default25(es_default9(line1)).features;
  var segments2 = es_default25(es_default9(line2)).features;
  for (var i = 0; i < segments1.length; i++) {
    var segment1 = segments1[i].geometry.coordinates;
    if (!segments2[i])
      break;
    var segment2 = segments2[i].geometry.coordinates;
    if (!isParallel2(segment1, segment2))
      return false;
  }
  return true;
}
function isParallel2(segment1, segment2) {
  var slope1 = bearingToAzimuth(es_default48(segment1[0], segment1[1]));
  var slope2 = bearingToAzimuth(es_default48(segment2[0], segment2[1]));
  return slope1 === slope2;
}
function getType2(geojson, name) {
  if (geojson.geometry && geojson.geometry.type)
    return geojson.geometry.type;
  if (geojson.type)
    return geojson.type;
  throw new Error("Invalid GeoJSON object for " + name);
}
var es_default62 = booleanParallel;

// node_modules/@turf/shortest-path/dist/es/index.js
function pathTo(node) {
  var curr = node, path = [];
  while (curr.parent) {
    path.unshift(curr);
    curr = curr.parent;
  }
  return path;
}
function getHeap() {
  return new BinaryHeap(function(node) {
    return node.f;
  });
}
var astar = {
  /**
   * Perform an A* Search on a graph given a start and end node.
   *
   * @private
   * @memberof astar
   * @param {Graph} graph Graph
   * @param {GridNode} start Start
   * @param {GridNode} end End
   * @param {Object} [options] Options
   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
   * @returns {Object} Search
   */
  search: function(graph, start, end, options) {
    graph.cleanDirty();
    options = options || {};
    var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
    var openHeap = getHeap(), closestNode = start;
    start.h = heuristic(start, end);
    openHeap.push(start);
    while (openHeap.size() > 0) {
      var currentNode = openHeap.pop();
      if (currentNode === end) {
        return pathTo(currentNode);
      }
      currentNode.closed = true;
      var neighbors = graph.neighbors(currentNode);
      for (var i = 0, il = neighbors.length; i < il; ++i) {
        var neighbor = neighbors[i];
        if (neighbor.closed || neighbor.isWall()) {
          continue;
        }
        var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
        if (!beenVisited || gScore < neighbor.g) {
          neighbor.visited = true;
          neighbor.parent = currentNode;
          neighbor.h = neighbor.h || heuristic(neighbor, end);
          neighbor.g = gScore;
          neighbor.f = neighbor.g + neighbor.h;
          graph.markDirty(neighbor);
          if (closest) {
            if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
              closestNode = neighbor;
            }
          }
          if (!beenVisited) {
            openHeap.push(neighbor);
          } else {
            openHeap.rescoreElement(neighbor);
          }
        }
      }
    }
    if (closest) {
      return pathTo(closestNode);
    }
    return [];
  },
  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
  heuristics: {
    manhattan: function(pos0, pos1) {
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return d1 + d2;
    },
    diagonal: function(pos0, pos1) {
      var D = 1;
      var D2 = Math.sqrt(2);
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
    }
  },
  cleanNode: function(node) {
    node.f = 0;
    node.g = 0;
    node.h = 0;
    node.visited = false;
    node.closed = false;
    node.parent = null;
  }
};
function Graph2(gridIn, options) {
  options = options || {};
  this.nodes = [];
  this.diagonal = !!options.diagonal;
  this.grid = [];
  for (var x2 = 0; x2 < gridIn.length; x2++) {
    this.grid[x2] = [];
    for (var y2 = 0, row = gridIn[x2]; y2 < row.length; y2++) {
      var node = new GridNode(x2, y2, row[y2]);
      this.grid[x2][y2] = node;
      this.nodes.push(node);
    }
  }
  this.init();
}
Graph2.prototype.init = function() {
  this.dirtyNodes = [];
  for (var i = 0; i < this.nodes.length; i++) {
    astar.cleanNode(this.nodes[i]);
  }
};
Graph2.prototype.cleanDirty = function() {
  for (var i = 0; i < this.dirtyNodes.length; i++) {
    astar.cleanNode(this.dirtyNodes[i]);
  }
  this.dirtyNodes = [];
};
Graph2.prototype.markDirty = function(node) {
  this.dirtyNodes.push(node);
};
Graph2.prototype.neighbors = function(node) {
  var ret = [], x2 = node.x, y2 = node.y, grid = this.grid;
  if (grid[x2 - 1] && grid[x2 - 1][y2]) {
    ret.push(grid[x2 - 1][y2]);
  }
  if (grid[x2 + 1] && grid[x2 + 1][y2]) {
    ret.push(grid[x2 + 1][y2]);
  }
  if (grid[x2] && grid[x2][y2 - 1]) {
    ret.push(grid[x2][y2 - 1]);
  }
  if (grid[x2] && grid[x2][y2 + 1]) {
    ret.push(grid[x2][y2 + 1]);
  }
  if (this.diagonal) {
    if (grid[x2 - 1] && grid[x2 - 1][y2 - 1]) {
      ret.push(grid[x2 - 1][y2 - 1]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2 - 1]) {
      ret.push(grid[x2 + 1][y2 - 1]);
    }
    if (grid[x2 - 1] && grid[x2 - 1][y2 + 1]) {
      ret.push(grid[x2 - 1][y2 + 1]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2 + 1]) {
      ret.push(grid[x2 + 1][y2 + 1]);
    }
  }
  return ret;
};
Graph2.prototype.toString = function() {
  var graphString = [], nodes = this.grid, rowDebug, row, y2, l;
  for (var x2 = 0, len = nodes.length; x2 < len; x2++) {
    rowDebug = [];
    row = nodes[x2];
    for (y2 = 0, l = row.length; y2 < l; y2++) {
      rowDebug.push(row[y2].weight);
    }
    graphString.push(rowDebug.join(" "));
  }
  return graphString.join("\n");
};
function GridNode(x2, y2, weight) {
  this.x = x2;
  this.y = y2;
  this.weight = weight;
}
GridNode.prototype.toString = function() {
  return "[" + this.x + " " + this.y + "]";
};
GridNode.prototype.getCost = function(fromNeighbor) {
  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
    return this.weight * 1.41421;
  }
  return this.weight;
};
GridNode.prototype.isWall = function() {
  return this.weight === 0;
};
function BinaryHeap(scoreFunction) {
  this.content = [];
  this.scoreFunction = scoreFunction;
}
BinaryHeap.prototype = {
  push: function(element) {
    this.content.push(element);
    this.sinkDown(this.content.length - 1);
  },
  pop: function() {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.bubbleUp(0);
    }
    return result;
  },
  remove: function(node) {
    var i = this.content.indexOf(node);
    var end = this.content.pop();
    if (i !== this.content.length - 1) {
      this.content[i] = end;
      if (this.scoreFunction(end) < this.scoreFunction(node)) {
        this.sinkDown(i);
      } else {
        this.bubbleUp(i);
      }
    }
  },
  size: function() {
    return this.content.length;
  },
  rescoreElement: function(node) {
    this.sinkDown(this.content.indexOf(node));
  },
  sinkDown: function(n) {
    var element = this.content[n];
    while (n > 0) {
      var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
        this.content[parentN] = element;
        this.content[n] = parent;
        n = parentN;
      } else {
        break;
      }
    }
  },
  bubbleUp: function(n) {
    var length4 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
    while (true) {
      var child2N = n + 1 << 1, child1N = child2N - 1;
      var swap2 = null, child1Score;
      if (child1N < length4) {
        var child1 = this.content[child1N];
        child1Score = this.scoreFunction(child1);
        if (child1Score < elemScore) {
          swap2 = child1N;
        }
      }
      if (child2N < length4) {
        var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
        if (child2Score < (swap2 === null ? elemScore : child1Score)) {
          swap2 = child2N;
        }
      }
      if (swap2 !== null) {
        this.content[n] = this.content[swap2];
        this.content[swap2] = element;
        n = swap2;
      } else {
        break;
      }
    }
  }
};
function shortestPath(start, end, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var resolution = options.resolution;
  var minDistance = options.minDistance;
  var obstacles = options.obstacles || featureCollection([]);
  if (!start)
    throw new Error("start is required");
  if (!end)
    throw new Error("end is required");
  if (resolution && !isNumber(resolution) || resolution <= 0)
    throw new Error("options.resolution must be a number, greater than 0");
  if (minDistance)
    throw new Error("options.minDistance is not yet implemented");
  var startCoord = getCoord(start);
  var endCoord = getCoord(end);
  start = point(startCoord);
  end = point(endCoord);
  switch (getType(obstacles)) {
    case "FeatureCollection":
      if (obstacles.features.length === 0)
        return lineString([startCoord, endCoord]);
      break;
    case "Polygon":
      obstacles = featureCollection([feature(getGeom(obstacles))]);
      break;
    default:
      throw new Error("invalid obstacles");
  }
  var collection = obstacles;
  collection.features.push(start);
  collection.features.push(end);
  var box = es_default(es_default54(bboxPolygon(es_default(collection)), 1.15));
  if (!resolution) {
    var width = es_default4([box[0], box[1]], [box[2], box[1]], options);
    resolution = width / 100;
  }
  collection.features.pop();
  collection.features.pop();
  var west = box[0];
  var south = box[1];
  var east = box[2];
  var north = box[3];
  var xFraction = resolution / es_default4([west, south], [east, south], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = resolution / es_default4([west, south], [west, north], options);
  var cellHeight = yFraction * (north - south);
  var bboxHorizontalSide = east - west;
  var bboxVerticalSide = north - south;
  var columns = Math.floor(bboxHorizontalSide / cellWidth);
  var rows = Math.floor(bboxVerticalSide / cellHeight);
  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;
  var pointMatrix = [];
  var matrix = [];
  var closestToStart = [];
  var closestToEnd = [];
  var minDistStart = Infinity;
  var minDistEnd = Infinity;
  var currentY = north - deltaY;
  var r = 0;
  while (currentY >= south) {
    var matrixRow = [];
    var pointMatrixRow = [];
    var currentX = west + deltaX;
    var c = 0;
    while (currentX <= east) {
      var pt = point([currentX, currentY]);
      var isInsideObstacle = isInside2(pt, obstacles);
      matrixRow.push(isInsideObstacle ? 0 : 1);
      pointMatrixRow.push(currentX + "|" + currentY);
      var distStart = es_default4(pt, start);
      if (!isInsideObstacle && distStart < minDistStart) {
        minDistStart = distStart;
        closestToStart = { x: c, y: r };
      }
      var distEnd = es_default4(pt, end);
      if (!isInsideObstacle && distEnd < minDistEnd) {
        minDistEnd = distEnd;
        closestToEnd = { x: c, y: r };
      }
      currentX += cellWidth;
      c++;
    }
    matrix.push(matrixRow);
    pointMatrix.push(pointMatrixRow);
    currentY -= cellHeight;
    r++;
  }
  var graph = new Graph2(matrix, { diagonal: true });
  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
  var result = astar.search(graph, startOnMatrix, endOnMatrix);
  var path = [startCoord];
  result.forEach(function(coord) {
    var coords = pointMatrix[coord.x][coord.y].split("|");
    path.push([+coords[0], +coords[1]]);
  });
  path.push(endCoord);
  return es_default9(lineString(path));
}
function isInside2(pt, polygons2) {
  for (var i = 0; i < polygons2.features.length; i++) {
    if (booleanPointInPolygon(pt, polygons2.features[i])) {
      return true;
    }
  }
  return false;
}
var es_default63 = shortestPath;

// node_modules/d3-voronoi/src/constant.js
function constant_default(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-voronoi/src/point.js
function x(d) {
  return d[0];
}
function y(d) {
  return d[1];
}

// node_modules/d3-voronoi/src/RedBlackTree.js
function RedBlackTree() {
  this._ = null;
}
function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null;
}
RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function(after, node) {
    var parent, grandpa, uncle;
    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N)
        after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L)
          after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;
    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },
  remove: function(node) {
    if (node.N)
      node.N.P = node.P;
    if (node.P)
      node.P.N = node.N;
    node.N = node.P = null;
    var parent = node.U, sibling, left = node.L, right = node.R, next3, red;
    if (!left)
      next3 = right;
    else if (!right)
      next3 = left;
    else
      next3 = RedBlackFirst(right);
    if (parent) {
      if (parent.L === node)
        parent.L = next3;
      else
        parent.R = next3;
    } else {
      this._ = next3;
    }
    if (left && right) {
      red = next3.C;
      next3.C = node.C;
      next3.L = left;
      left.U = next3;
      if (next3 !== right) {
        parent = next3.U;
        next3.U = node.U;
        node = next3.R;
        parent.L = node;
        next3.R = right;
        right.U = next3;
      } else {
        next3.U = parent;
        parent = next3;
        node = next3.R;
      }
    } else {
      red = node.C;
      node = next3;
    }
    if (node)
      node.U = parent;
    if (red)
      return;
    if (node && node.C) {
      node.C = false;
      return;
    }
    do {
      if (node === this._)
        break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);
    if (node)
      node.C = false;
  }
};
function RedBlackRotateLeft(tree, node) {
  var p = node, q = node.R, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree._ = q;
  }
  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R)
    p.R.U = p;
  q.L = p;
}
function RedBlackRotateRight(tree, node) {
  var p = node, q = node.L, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree._ = q;
  }
  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L)
    p.L.U = p;
  q.R = p;
}
function RedBlackFirst(node) {
  while (node.L)
    node = node.L;
  return node;
}
var RedBlackTree_default = RedBlackTree;

// node_modules/d3-voronoi/src/Edge.js
function createEdge(left, right, v0, v1) {
  var edge = [null, null], index2 = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0)
    setEdgeEnd(edge, left, right, v0);
  if (v1)
    setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index2);
  cells[right.index].halfedges.push(index2);
  return edge;
}
function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}
function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
  r = x0 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dx > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = x1 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dx > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  r = y0 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dy > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = y1 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dy > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  if (!(t0 > 0) && !(t1 < 1))
    return true;
  if (t0 > 0)
    edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1)
    edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}
function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1)
    return true;
  var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
  if (ry === ly) {
    if (fx < x0 || fx >= x1)
      return;
    if (lx > rx) {
      if (!v0)
        v0 = [fx, y0];
      else if (v0[1] >= y1)
        return;
      v1 = [fx, y1];
    } else {
      if (!v0)
        v0 = [fx, y1];
      else if (v0[1] < y0)
        return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0)
          v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1)
          return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0)
          v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0)
          return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0)
          v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1)
          return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0)
          v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0)
          return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }
  edge[0] = v0;
  edge[1] = v1;
  return true;
}
function clipEdges(x0, y0, x1, y1) {
  var i = edges.length, edge;
  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges[i];
    }
  }
}

// node_modules/d3-voronoi/src/Cell.js
function createCell(site) {
  return cells[site.index] = {
    site,
    halfedges: []
  };
}
function cellHalfedgeAngle(cell, edge) {
  var site = cell.site, va = edge.left, vb = edge.right;
  if (site === vb)
    vb = va, va = site;
  if (vb)
    return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va)
    va = edge[1], vb = edge[0];
  else
    va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index2 = new Array(m), array = new Array(m);
      for (j = 0; j < m; ++j)
        index2[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index2.sort(function(i2, j2) {
        return array[j2] - array[i2];
      });
      for (j = 0; j < m; ++j)
        array[j] = halfedges[index2[j]];
      for (j = 0; j < m; ++j)
        halfedges[j] = array[j];
    }
  }
}
function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
            site,
            end,
            Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1] : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0] : null
          )) - 1);
          ++nHalfedges;
        }
      }
      if (nHalfedges)
        cover = false;
    }
  }
  if (cover) {
    var dx, dy, d2, dc = Infinity;
    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc)
          dc = d2, cover = cell;
      }
    }
    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

// node_modules/d3-voronoi/src/Circle.js
var circlePool = [];
var firstCircle;
function Circle() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc) {
  var lArc = arc.P, rArc = arc.N;
  if (!lArc || !rArc)
    return;
  var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
  if (lSite === rSite)
    return;
  var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2)
    return;
  var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
  var circle2 = circlePool.pop() || new Circle();
  circle2.arc = arc;
  circle2.site = cSite;
  circle2.x = x2 + bx;
  circle2.y = (circle2.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
  arc.circle = circle2;
  var before = null, node = circles._;
  while (node) {
    if (circle2.y < node.y || circle2.y === node.y && circle2.x <= node.x) {
      if (node.L)
        node = node.L;
      else {
        before = node.P;
        break;
      }
    } else {
      if (node.R)
        node = node.R;
      else {
        before = node;
        break;
      }
    }
  }
  circles.insert(before, circle2);
  if (!before)
    firstCircle = circle2;
}
function detachCircle(arc) {
  var circle2 = arc.circle;
  if (circle2) {
    if (!circle2.P)
      firstCircle = circle2.N;
    circles.remove(circle2);
    circlePool.push(circle2);
    RedBlackNode(circle2);
    arc.circle = null;
  }
}

// node_modules/d3-voronoi/src/Beach.js
var beachPool = [];
function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}
function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}
function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}
function removeBeach(beach) {
  var circle2 = beach.circle, x2 = circle2.x, y2 = circle2.cy, vertex = [x2, y2], previous = beach.P, next3 = beach.N, disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;
  while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }
  disappearing.unshift(lArc);
  detachCircle(lArc);
  var rArc = next3;
  while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
    next3 = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next3;
  }
  disappearing.push(rArc);
  detachCircle(rArc);
  var nArcs = disappearing.length, iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }
  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function addBeach(site) {
  var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
  while (node) {
    dxl = leftBreakPoint(node, directrix) - x2;
    if (dxl > epsilon)
      node = node.L;
    else {
      dxr = x2 - rightBreakPoint(node, directrix);
      if (dxr > epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }
  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);
  if (!lArc && !rArc)
    return;
  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }
  if (!rArc) {
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }
  detachCircle(lArc);
  detachCircle(rArc);
  var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function leftBreakPoint(arc, directrix) {
  var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
  if (!pby2)
    return rfocx;
  var lArc = arc.P;
  if (!lArc)
    return -Infinity;
  site = lArc.site;
  var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
  if (!plby2)
    return lfocx;
  var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
  if (aby2)
    return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc)
    return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

// node_modules/d3-voronoi/src/Diagram.js
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;
function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}
function lexicographic(a, b) {
  return b[1] - a[1] || b[0] - a[0];
}
function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(), x2, y2, circle2;
  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree_default();
  circles = new RedBlackTree_default();
  while (true) {
    circle2 = firstCircle;
    if (site && (!circle2 || site[1] < circle2.y || site[1] === circle2.y && site[0] < circle2.x)) {
      if (site[0] !== x2 || site[1] !== y2) {
        addBeach(site);
        x2 = site[0], y2 = site[1];
      }
      site = sites.pop();
    } else if (circle2) {
      removeBeach(circle2.arc);
    } else {
      break;
    }
  }
  sortCellHalfedges();
  if (extent) {
    var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }
  this.edges = edges;
  this.cells = cells;
  beaches = circles = edges = cells = null;
}
Diagram.prototype = {
  constructor: Diagram,
  polygons: function() {
    var edges2 = this.edges;
    return this.cells.map(function(cell) {
      var polygon4 = cell.halfedges.map(function(i) {
        return cellHalfedgeStart(cell, edges2[i]);
      });
      polygon4.data = cell.site.data;
      return polygon4;
    });
  },
  triangles: function() {
    var triangles = [], edges2 = this.edges;
    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length))
        return;
      var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
      while (++j < m) {
        s0 = s1;
        e1 = edges2[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function(x2, y2, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
    while (!(cell = that.cells[i1]))
      if (++i1 >= n)
        return null;
    var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right))
          return;
        var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2)
          d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);
    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

// node_modules/d3-voronoi/src/voronoi.js
function voronoi_default() {
  var x2 = x, y2 = y, extent = null;
  function voronoi2(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x2(d, i, data) / epsilon) * epsilon, Math.round(y2(d, i, data) / epsilon) * epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }
  voronoi2.polygons = function(data) {
    return voronoi2(data).polygons();
  };
  voronoi2.links = function(data) {
    return voronoi2(data).links();
  };
  voronoi2.triangles = function(data) {
    return voronoi2(data).triangles();
  };
  voronoi2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default(+_), voronoi2) : x2;
  };
  voronoi2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default(+_), voronoi2) : y2;
  };
  voronoi2.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi2) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };
  voronoi2.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi2) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };
  return voronoi2;
}

// node_modules/@turf/voronoi/dist/es/index.js
function coordsToPolygon(coords) {
  coords = coords.slice();
  coords.push(coords[0]);
  return polygon([coords]);
}
function voronoi(points2, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var bbox3 = options.bbox || [-180, -85, 180, 85];
  if (!points2)
    throw new Error("points is required");
  if (!Array.isArray(bbox3))
    throw new Error("bbox is invalid");
  collectionOf(points2, "Point", "points");
  return featureCollection(
    voronoi_default().x(function(feature2) {
      return feature2.geometry.coordinates[0];
    }).y(function(feature2) {
      return feature2.geometry.coordinates[1];
    }).extent([
      [bbox3[0], bbox3[1]],
      [bbox3[2], bbox3[3]]
    ]).polygons(points2.features).map(coordsToPolygon)
  );
}
var es_default64 = voronoi;

// node_modules/@turf/ellipse/dist/es/index.js
function ellipse(center2, xSemiAxis, ySemiAxis, options) {
  options = options || {};
  var steps = options.steps || 64;
  var units = options.units || "kilometers";
  var angle4 = options.angle || 0;
  var pivot = options.pivot || center2;
  var properties = options.properties || center2.properties || {};
  if (!center2)
    throw new Error("center is required");
  if (!xSemiAxis)
    throw new Error("xSemiAxis is required");
  if (!ySemiAxis)
    throw new Error("ySemiAxis is required");
  if (!isObject(options))
    throw new Error("options must be an object");
  if (!isNumber(steps))
    throw new Error("steps must be a number");
  if (!isNumber(angle4))
    throw new Error("angle must be a number");
  var centerCoords = getCoord(center2);
  if (units === "degrees") {
    var angleRad = degreesToRadians(angle4);
  } else {
    xSemiAxis = es_default49(center2, xSemiAxis, 90, { units });
    ySemiAxis = es_default49(center2, ySemiAxis, 0, { units });
    xSemiAxis = getCoord(xSemiAxis)[0] - centerCoords[0];
    ySemiAxis = getCoord(ySemiAxis)[1] - centerCoords[1];
  }
  var coordinates = [];
  for (var i = 0; i < steps; i += 1) {
    var stepAngle = i * -360 / steps;
    var x2 = xSemiAxis * ySemiAxis / Math.sqrt(
      Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)
    );
    var y2 = xSemiAxis * ySemiAxis / Math.sqrt(
      Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)
    );
    if (stepAngle < -90 && stepAngle >= -270)
      x2 = -x2;
    if (stepAngle < -180 && stepAngle >= -360)
      y2 = -y2;
    if (units === "degrees") {
      var newx = x2 * Math.cos(angleRad) + y2 * Math.sin(angleRad);
      var newy = y2 * Math.cos(angleRad) - x2 * Math.sin(angleRad);
      x2 = newx;
      y2 = newy;
    }
    coordinates.push([x2 + centerCoords[0], y2 + centerCoords[1]]);
  }
  coordinates.push(coordinates[0]);
  if (units === "degrees") {
    return polygon([coordinates], properties);
  } else {
    return es_default53(polygon([coordinates], properties), angle4, {
      pivot
    });
  }
}
function getTanDeg(deg) {
  var rad2 = deg * Math.PI / 180;
  return Math.tan(rad2);
}
var es_default65 = ellipse;

// node_modules/@turf/center-mean/dist/es/index.js
function centerMean(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var sumXs = 0;
  var sumYs = 0;
  var sumNs = 0;
  geomEach(geojson, function(geom, featureIndex, properties) {
    var weight = options.weight ? properties === null || properties === void 0 ? void 0 : properties[options.weight] : void 0;
    weight = weight === void 0 || weight === null ? 1 : weight;
    if (!isNumber(weight))
      throw new Error("weight value must be a number for feature index " + featureIndex);
    weight = Number(weight);
    if (weight > 0) {
      coordEach(geom, function(coord) {
        sumXs += coord[0] * weight;
        sumYs += coord[1] * weight;
        sumNs += weight;
      });
    }
  });
  return point([sumXs / sumNs, sumYs / sumNs], options.properties, options);
}
var es_default66 = centerMean;

// node_modules/@turf/center-median/dist/es/index.js
function centerMedian(features, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var counter = options.counter || 10;
  if (!isNumber(counter))
    throw new Error("counter must be a number");
  var weightTerm = options.weight;
  var meanCenter = es_default66(features, { weight: options.weight });
  var centroids = featureCollection([]);
  featureEach(features, function(feature2) {
    var _a;
    centroids.features.push(es_default19(feature2, {
      properties: { weight: (_a = feature2.properties) === null || _a === void 0 ? void 0 : _a[weightTerm] }
    }));
  });
  var properties = {
    tolerance: options.tolerance,
    medianCandidates: []
  };
  return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);
}
function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
  var tolerance = properties.tolerance || 1e-3;
  var candidateXsum = 0;
  var candidateYsum = 0;
  var kSum = 0;
  var centroidCount = 0;
  featureEach(centroids, function(theCentroid) {
    var _a;
    var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;
    var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;
    weight = Number(weight);
    if (!isNumber(weight))
      throw new Error("weight value must be a number");
    if (weight > 0) {
      centroidCount += 1;
      var distanceFromCandidate = weight * es_default4(theCentroid, candidateMedian);
      if (distanceFromCandidate === 0)
        distanceFromCandidate = 1;
      var k = weight / distanceFromCandidate;
      candidateXsum += theCentroid.geometry.coordinates[0] * k;
      candidateYsum += theCentroid.geometry.coordinates[1] * k;
      kSum += k;
    }
  });
  if (centroidCount < 1)
    throw new Error("no features to measure");
  var candidateX = candidateXsum / kSum;
  var candidateY = candidateYsum / kSum;
  if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {
    return point([candidateX, candidateY], {
      medianCandidates: properties.medianCandidates
    });
  } else {
    properties.medianCandidates.push([candidateX, candidateY]);
    return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);
  }
}
var es_default67 = centerMedian;

// node_modules/@turf/standard-deviational-ellipse/dist/es/index.js
function standardDeviationalEllipse(points2, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var steps = options.steps || 64;
  var weightTerm = options.weight;
  var properties = options.properties || {};
  if (!isNumber(steps))
    throw new Error("steps must be a number");
  if (!isObject(properties))
    throw new Error("properties must be a number");
  var numberOfFeatures = coordAll(points2).length;
  var meanCenter = es_default66(points2, { weight: weightTerm });
  var xDeviationSquaredSum = 0;
  var yDeviationSquaredSum = 0;
  var xyDeviationSum = 0;
  featureEach(points2, function(point4) {
    var weight = point4.properties[weightTerm] || 1;
    var deviation = getDeviations(getCoords(point4), getCoords(meanCenter));
    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
    xyDeviationSum += deviation.x * deviation.y * weight;
  });
  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;
  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
  var bigC = 2 * xyDeviationSum;
  var theta = Math.atan((bigA + bigB) / bigC);
  var thetaDeg = theta * 180 / Math.PI;
  var sigmaXsum = 0;
  var sigmaYsum = 0;
  var weightsum = 0;
  featureEach(points2, function(point4) {
    var weight = point4.properties[weightTerm] || 1;
    var deviation = getDeviations(getCoords(point4), getCoords(meanCenter));
    sigmaXsum += Math.pow(
      deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
      2
    ) * weight;
    sigmaYsum += Math.pow(
      deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
      2
    ) * weight;
    weightsum += weight;
  });
  var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
  var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
  var theEllipse = es_default65(meanCenter, sigmaX, sigmaY, {
    units: "degrees",
    angle: thetaDeg,
    steps,
    properties
  });
  var pointsWithinEllipse = es_default3(
    points2,
    featureCollection([theEllipse])
  );
  var standardDeviationalEllipseProperties = {
    meanCenterCoordinates: getCoords(meanCenter),
    semiMajorAxis: sigmaX,
    semiMinorAxis: sigmaY,
    numberOfFeatures,
    angle: thetaDeg,
    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures
  };
  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
  return theEllipse;
}
function getDeviations(coordinates, center2) {
  return {
    x: coordinates[0] - center2[0],
    y: coordinates[1] - center2[1]
  };
}
var es_default68 = standardDeviationalEllipse;

// node_modules/@turf/angle/dist/es/index.js
function angle(startPoint, midPoint3, endPoint, options) {
  if (options === void 0) {
    options = {};
  }
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  if (!startPoint) {
    throw new Error("startPoint is required");
  }
  if (!midPoint3) {
    throw new Error("midPoint is required");
  }
  if (!endPoint) {
    throw new Error("endPoint is required");
  }
  var A = startPoint;
  var O = midPoint3;
  var B2 = endPoint;
  var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : es_default48(A, O));
  var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B2, O) : es_default48(B2, O));
  var angleAO = Math.abs(azimuthAO - azimuthBO);
  if (options.explementary === true) {
    return 360 - angleAO;
  }
  return angleAO;
}
var es_default69 = angle;

// node_modules/@turf/polygon-smooth/dist/es/index.js
function polygonSmooth(inputPolys, options) {
  var outPolys = [];
  var iterations = options.iterations || 1;
  if (!inputPolys)
    throw new Error("inputPolys is required");
  geomEach(inputPolys, function(geom, geomIndex, properties) {
    var outCoords;
    var poly;
    var tempOutput;
    switch (geom.type) {
      case "Polygon":
        outCoords = [[]];
        for (var i = 0; i < iterations; i++) {
          tempOutput = [[]];
          poly = geom;
          if (i > 0)
            poly = polygon(outCoords).geometry;
          processPolygon3(poly, tempOutput);
          outCoords = tempOutput.slice(0);
        }
        outPolys.push(polygon(outCoords, properties));
        break;
      case "MultiPolygon":
        outCoords = [[[]]];
        for (var y2 = 0; y2 < iterations; y2++) {
          tempOutput = [[[]]];
          poly = geom;
          if (y2 > 0)
            poly = multiPolygon(outCoords).geometry;
          processMultiPolygon(poly, tempOutput);
          outCoords = tempOutput.slice(0);
        }
        outPolys.push(multiPolygon(outCoords, properties));
        break;
      default:
        throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
    }
  });
  return featureCollection(outPolys);
}
function processPolygon3(poly, tempOutput) {
  var prevGeomIndex = 0;
  var subtractCoordIndex = 0;
  coordEach(
    poly,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (geometryIndex > prevGeomIndex) {
        prevGeomIndex = geometryIndex;
        subtractCoordIndex = coordIndex;
        tempOutput.push([]);
      }
      var realCoordIndex = coordIndex - subtractCoordIndex;
      var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];
      var p0x = currentCoord[0];
      var p0y = currentCoord[1];
      var p1x = p1[0];
      var p1y = p1[1];
      tempOutput[geometryIndex].push([
        0.75 * p0x + 0.25 * p1x,
        0.75 * p0y + 0.25 * p1y
      ]);
      tempOutput[geometryIndex].push([
        0.25 * p0x + 0.75 * p1x,
        0.25 * p0y + 0.75 * p1y
      ]);
    },
    true
  );
  tempOutput.forEach(function(ring) {
    ring.push(ring[0]);
  });
}
function processMultiPolygon(poly, tempOutput) {
  var prevGeomIndex = 0;
  var subtractCoordIndex = 0;
  var prevMultiIndex = 0;
  coordEach(
    poly,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (multiFeatureIndex > prevMultiIndex) {
        prevMultiIndex = multiFeatureIndex;
        subtractCoordIndex = coordIndex;
        tempOutput.push([[]]);
      }
      if (geometryIndex > prevGeomIndex) {
        prevGeomIndex = geometryIndex;
        subtractCoordIndex = coordIndex;
        tempOutput[multiFeatureIndex].push([]);
      }
      var realCoordIndex = coordIndex - subtractCoordIndex;
      var p1 = poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];
      var p0x = currentCoord[0];
      var p0y = currentCoord[1];
      var p1x = p1[0];
      var p1y = p1[1];
      tempOutput[multiFeatureIndex][geometryIndex].push([
        0.75 * p0x + 0.25 * p1x,
        0.75 * p0y + 0.25 * p1y
      ]);
      tempOutput[multiFeatureIndex][geometryIndex].push([
        0.25 * p0x + 0.75 * p1x,
        0.25 * p0y + 0.75 * p1y
      ]);
    },
    true
  );
  tempOutput.forEach(function(poly2) {
    poly2.forEach(function(ring) {
      ring.push(ring[0]);
    });
  });
}
var es_default70 = polygonSmooth;

// node_modules/@turf/distance-weight/dist/es/index.js
function pNormDistance(feature1, feature2, p) {
  if (p === void 0) {
    p = 2;
  }
  var coordinate1 = getCoord(feature1);
  var coordinate2 = getCoord(feature2);
  var xDiff = coordinate1[0] - coordinate2[0];
  var yDiff = coordinate1[1] - coordinate2[1];
  if (p === 1) {
    return Math.abs(xDiff) + Math.abs(yDiff);
  }
  return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
}
function distanceWeight(fc, options) {
  options = options || {};
  var threshold = options.threshold || 1e4;
  var p = options.p || 2;
  var binary = options.binary || false;
  var alpha = options.alpha || -1;
  var rowTransform = options.standardization || false;
  var features = [];
  featureEach(fc, function(feature2) {
    features.push(es_default19(feature2));
  });
  var weights = [];
  for (var i = 0; i < features.length; i++) {
    weights[i] = [];
  }
  for (var i = 0; i < features.length; i++) {
    for (var j = i; j < features.length; j++) {
      if (i === j) {
        weights[i][j] = 0;
      }
      var dis = pNormDistance(features[i], features[j], p);
      weights[i][j] = dis;
      weights[j][i] = dis;
    }
  }
  for (var i = 0; i < features.length; i++) {
    for (var j = 0; j < features.length; j++) {
      var dis = weights[i][j];
      if (dis === 0) {
        continue;
      }
      if (binary) {
        if (dis <= threshold) {
          weights[i][j] = 1;
        } else {
          weights[i][j] = 0;
        }
      } else {
        if (dis <= threshold) {
          weights[i][j] = Math.pow(dis, alpha);
        } else {
          weights[i][j] = 0;
        }
      }
    }
  }
  if (rowTransform) {
    for (var i = 0; i < features.length; i++) {
      var rowSum = weights[i].reduce(function(sum, currentVal) {
        return sum + currentVal;
      }, 0);
      for (var j = 0; j < features.length; j++) {
        weights[i][j] = weights[i][j] / rowSum;
      }
    }
  }
  return weights;
}

// node_modules/@turf/moran-index/dist/es/index.js
function es_default71(fc, options) {
  var inputField = options.inputField;
  var threshold = options.threshold || 1e5;
  var p = options.p || 2;
  var binary = options.binary || false;
  var alpha = options.alpha || -1;
  var standardization = options.standardization || true;
  var weight = distanceWeight(fc, {
    alpha,
    binary,
    p,
    standardization,
    threshold
  });
  var y2 = [];
  featureEach(fc, function(feature2) {
    var feaProperties = feature2.properties || {};
    y2.push(feaProperties[inputField]);
  });
  var yMean = mean(y2);
  var yVar = variance(y2);
  var weightSum = 0;
  var s0 = 0;
  var s1 = 0;
  var s2 = 0;
  var n = weight.length;
  for (var i = 0; i < n; i++) {
    var subS2 = 0;
    for (var j = 0; j < n; j++) {
      weightSum += weight[i][j] * (y2[i] - yMean) * (y2[j] - yMean);
      s0 += weight[i][j];
      s1 += Math.pow(weight[i][j] + weight[j][i], 2);
      subS2 += weight[i][j] + weight[j][i];
    }
    s2 += Math.pow(subS2, 2);
  }
  s1 = 0.5 * s1;
  var moranIndex = weightSum / s0 / yVar;
  var expectedMoranIndex = -1 / (n - 1);
  var vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
  var vDen = (n - 1) * (n + 1) * (s0 * s0);
  var vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
  var stdNorm = Math.sqrt(vNorm);
  var zNorm = (moranIndex - expectedMoranIndex) / stdNorm;
  return {
    expectedMoranIndex,
    moranIndex,
    stdNorm,
    zNorm
  };
}
function mean(y2) {
  var sum = 0;
  for (var _i = 0, y_1 = y2; _i < y_1.length; _i++) {
    var item = y_1[_i];
    sum += item;
  }
  return sum / y2.length;
}
function variance(y2) {
  var yMean = mean(y2);
  var sum = 0;
  for (var _i = 0, y_2 = y2; _i < y_2.length; _i++) {
    var item = y_2[_i];
    sum += Math.pow(item - yMean, 2);
  }
  return sum / y2.length;
}

// node_modules/@turf/projection/dist/es/index.js
var es_exports4 = {};
__export(es_exports4, {
  toMercator: () => toMercator,
  toWgs84: () => toWgs84
});
function toMercator(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return convert(geojson, "mercator", options);
}
function toWgs84(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return convert(geojson, "wgs84", options);
}
function convert(geojson, projection, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson is required");
  if (Array.isArray(geojson) && isNumber(geojson[0]))
    geojson = projection === "mercator" ? convertToMercator(geojson) : convertToWgs84(geojson);
  else {
    if (mutate !== true)
      geojson = es_default5(geojson);
    coordEach(geojson, function(coord) {
      var newCoord = projection === "mercator" ? convertToMercator(coord) : convertToWgs84(coord);
      coord[0] = newCoord[0];
      coord[1] = newCoord[1];
    });
  }
  return geojson;
}
function convertToMercator(lonLat) {
  var D2R2 = Math.PI / 180, A = 6378137, MAXEXTENT = 20037508342789244e-9;
  var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;
  var xy = [
    A * adjusted * D2R2,
    A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R2))
  ];
  if (xy[0] > MAXEXTENT)
    xy[0] = MAXEXTENT;
  if (xy[0] < -MAXEXTENT)
    xy[0] = -MAXEXTENT;
  if (xy[1] > MAXEXTENT)
    xy[1] = MAXEXTENT;
  if (xy[1] < -MAXEXTENT)
    xy[1] = -MAXEXTENT;
  return xy;
}
function convertToWgs84(xy) {
  var R2D2 = 180 / Math.PI;
  var A = 6378137;
  return [
    xy[0] * R2D2 / A,
    (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-xy[1] / A))) * R2D2
  ];
}
function sign(x2) {
  return x2 < 0 ? -1 : x2 > 0 ? 1 : 0;
}

// node_modules/@turf/random/dist/es/index.js
var es_exports5 = {};
__export(es_exports5, {
  randomLineString: () => randomLineString,
  randomPoint: () => randomPoint,
  randomPolygon: () => randomPolygon,
  randomPosition: () => randomPosition
});
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
function randomPosition(bbox3) {
  if (Array.isArray(bbox3)) {
    return coordInBBox(bbox3);
  }
  if (bbox3 && bbox3.bbox) {
    return coordInBBox(bbox3.bbox);
  }
  return [lon(), lat()];
}
function randomPoint(count2, options) {
  if (options === void 0) {
    options = {};
  }
  if (count2 === void 0 || count2 === null) {
    count2 = 1;
  }
  var features = [];
  for (var i = 0; i < count2; i++) {
    features.push(point(randomPosition(options.bbox)));
  }
  return featureCollection(features);
}
function randomPolygon(count2, options) {
  if (options === void 0) {
    options = {};
  }
  if (count2 === void 0 || count2 === null) {
    count2 = 1;
  }
  if (!isNumber(options.num_vertices) || options.num_vertices === void 0) {
    options.num_vertices = 10;
  }
  if (!isNumber(options.max_radial_length) || options.max_radial_length === void 0) {
    options.max_radial_length = 10;
  }
  var features = [];
  var _loop_1 = function(i2) {
    var vertices = [];
    var circleOffsets = __spreadArrays(Array(options.num_vertices + 1)).map(Math.random);
    circleOffsets.forEach(function(cur, index2, arr) {
      arr[index2] = index2 > 0 ? cur + arr[index2 - 1] : cur;
    });
    circleOffsets.forEach(function(cur) {
      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];
      var radialScaler = Math.random();
      vertices.push([
        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
        radialScaler * (options.max_radial_length || 10) * Math.cos(cur)
      ]);
    });
    vertices[vertices.length - 1] = vertices[0];
    vertices = vertices.map(vertexToCoordinate(randomPosition(options.bbox)));
    features.push(polygon([vertices]));
  };
  for (var i = 0; i < count2; i++) {
    _loop_1(i);
  }
  return featureCollection(features);
}
function randomLineString(count2, options) {
  if (options === void 0) {
    options = {};
  }
  options = options || {};
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  var bbox3 = options.bbox;
  var num_vertices = options.num_vertices;
  var max_length = options.max_length;
  var max_rotation = options.max_rotation;
  if (count2 === void 0 || count2 === null) {
    count2 = 1;
  }
  if (!isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {
    num_vertices = 10;
  }
  if (!isNumber(max_length) || max_length === void 0) {
    max_length = 1e-4;
  }
  if (!isNumber(max_rotation) || max_rotation === void 0) {
    max_rotation = Math.PI / 8;
  }
  var features = [];
  for (var i = 0; i < count2; i++) {
    var startingPoint = randomPosition(bbox3);
    var vertices = [startingPoint];
    for (var j = 0; j < num_vertices - 1; j++) {
      var priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));
      var angle4 = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
      var distance11 = Math.random() * max_length;
      vertices.push([
        vertices[j][0] + distance11 * Math.cos(angle4),
        vertices[j][1] + distance11 * Math.sin(angle4)
      ]);
    }
    features.push(lineString(vertices));
  }
  return featureCollection(features);
}
function vertexToCoordinate(hub) {
  return function(cur) {
    return [cur[0] + hub[0], cur[1] + hub[1]];
  };
}
function rnd() {
  return Math.random() - 0.5;
}
function lon() {
  return rnd() * 360;
}
function lat() {
  return rnd() * 180;
}
function coordInBBox(bbox3) {
  return [
    Math.random() * (bbox3[2] - bbox3[0]) + bbox3[0],
    Math.random() * (bbox3[3] - bbox3[1]) + bbox3[1]
  ];
}

// node_modules/@turf/clusters/dist/es/index.js
var es_exports6 = {};
__export(es_exports6, {
  applyFilter: () => applyFilter,
  clusterEach: () => clusterEach,
  clusterReduce: () => clusterReduce,
  createBins: () => createBins,
  filterProperties: () => filterProperties,
  getCluster: () => getCluster,
  propertiesContainsFilter: () => propertiesContainsFilter
});
function getCluster(geojson, filter17) {
  if (!geojson)
    throw new Error("geojson is required");
  if (geojson.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (filter17 === void 0 || filter17 === null)
    throw new Error("filter is required");
  var features = [];
  featureEach(geojson, function(feature2) {
    if (applyFilter(feature2.properties, filter17))
      features.push(feature2);
  });
  return featureCollection(features);
}
function clusterEach(geojson, property, callback) {
  if (!geojson)
    throw new Error("geojson is required");
  if (geojson.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (property === void 0 || property === null)
    throw new Error("property is required");
  var bins = createBins(geojson, property);
  var values3 = Object.keys(bins);
  for (var index2 = 0; index2 < values3.length; index2++) {
    var value = values3[index2];
    var bin = bins[value];
    var features = [];
    for (var i = 0; i < bin.length; i++) {
      features.push(geojson.features[bin[i]]);
    }
    callback(featureCollection(features), value, index2);
  }
}
function clusterReduce(geojson, property, callback, initialValue) {
  var previousValue = initialValue;
  clusterEach(geojson, property, function(cluster, clusterValue, currentIndex) {
    if (currentIndex === 0 && initialValue === void 0)
      previousValue = cluster;
    else
      previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
  });
  return previousValue;
}
function createBins(geojson, property) {
  var bins = {};
  featureEach(geojson, function(feature2, i) {
    var properties = feature2.properties || {};
    if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
      var value = properties[property];
      if (Object.prototype.hasOwnProperty.call(bins, value))
        bins[value].push(i);
      else
        bins[value] = [i];
    }
  });
  return bins;
}
function applyFilter(properties, filter17) {
  if (properties === void 0)
    return false;
  var filterType = typeof filter17;
  if (filterType === "number" || filterType === "string")
    return Object.prototype.hasOwnProperty.call(properties, filter17);
  else if (Array.isArray(filter17)) {
    for (var i = 0; i < filter17.length; i++) {
      if (!applyFilter(properties, filter17[i]))
        return false;
    }
    return true;
  } else {
    return propertiesContainsFilter(properties, filter17);
  }
}
function propertiesContainsFilter(properties, filter17) {
  var keys = Object.keys(filter17);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (properties[key] !== filter17[key])
      return false;
  }
  return true;
}
function filterProperties(properties, keys) {
  if (!keys)
    return {};
  if (!keys.length)
    return {};
  var newProperties = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (Object.prototype.hasOwnProperty.call(properties, key))
      newProperties[key] = properties[key];
  }
  return newProperties;
}

// node_modules/splaytree/dist/splay.esm.js
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done)
          return t;
        if (y2 = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var Node4 = (
  /** @class */
  function() {
    function Node6(key, data) {
      this.next = null;
      this.key = key;
      this.data = data;
      this.left = null;
      this.right = null;
    }
    return Node6;
  }()
);
function DEFAULT_COMPARE(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function splay(i, t, comparator) {
  var N = new Node4(null, null);
  var l = N;
  var r = N;
  while (true) {
    var cmp3 = comparator(i, t.key);
    if (cmp3 < 0) {
      if (t.left === null)
        break;
      if (comparator(i, t.left.key) < 0) {
        var y2 = t.left;
        t.left = y2.right;
        y2.right = t;
        t = y2;
        if (t.left === null)
          break;
      }
      r.left = t;
      r = t;
      t = t.left;
    } else if (cmp3 > 0) {
      if (t.right === null)
        break;
      if (comparator(i, t.right.key) > 0) {
        var y2 = t.right;
        t.right = y2.left;
        y2.left = t;
        t = y2;
        if (t.right === null)
          break;
      }
      l.right = t;
      l = t;
      t = t.right;
    } else
      break;
  }
  l.right = t.left;
  r.left = t.right;
  t.left = N.right;
  t.right = N.left;
  return t;
}
function insert(i, data, t, comparator) {
  var node = new Node4(i, data);
  if (t === null) {
    node.left = node.right = null;
    return node;
  }
  t = splay(i, t, comparator);
  var cmp3 = comparator(i, t.key);
  if (cmp3 < 0) {
    node.left = t.left;
    node.right = t;
    t.left = null;
  } else if (cmp3 >= 0) {
    node.right = t.right;
    node.left = t;
    t.right = null;
  }
  return node;
}
function split(key, v, comparator) {
  var left = null;
  var right = null;
  if (v) {
    v = splay(key, v, comparator);
    var cmp3 = comparator(v.key, key);
    if (cmp3 === 0) {
      left = v.left;
      right = v.right;
    } else if (cmp3 < 0) {
      right = v.right;
      v.right = null;
      left = v;
    } else {
      left = v.left;
      v.left = null;
      right = v;
    }
  }
  return { left, right };
}
function merge(left, right, comparator) {
  if (right === null)
    return left;
  if (left === null)
    return right;
  right = splay(left.key, right, comparator);
  right.left = left;
  return right;
}
function printRow(root, prefix, isTail, out, printNode2) {
  if (root) {
    out("" + prefix + (isTail ? "└── " : "├── ") + printNode2(root) + "\n");
    var indent = prefix + (isTail ? "    " : "│   ");
    if (root.left)
      printRow(root.left, indent, false, out, printNode2);
    if (root.right)
      printRow(root.right, indent, true, out, printNode2);
  }
}
var Tree = (
  /** @class */
  function() {
    function Tree2(comparator) {
      if (comparator === void 0) {
        comparator = DEFAULT_COMPARE;
      }
      this._root = null;
      this._size = 0;
      this._comparator = comparator;
    }
    Tree2.prototype.insert = function(key, data) {
      this._size++;
      return this._root = insert(key, data, this._root, this._comparator);
    };
    Tree2.prototype.add = function(key, data) {
      var node = new Node4(key, data);
      if (this._root === null) {
        node.left = node.right = null;
        this._size++;
        this._root = node;
      }
      var comparator = this._comparator;
      var t = splay(key, this._root, comparator);
      var cmp3 = comparator(key, t.key);
      if (cmp3 === 0)
        this._root = t;
      else {
        if (cmp3 < 0) {
          node.left = t.left;
          node.right = t;
          t.left = null;
        } else if (cmp3 > 0) {
          node.right = t.right;
          node.left = t;
          t.right = null;
        }
        this._size++;
        this._root = node;
      }
      return this._root;
    };
    Tree2.prototype.remove = function(key) {
      this._root = this._remove(key, this._root, this._comparator);
    };
    Tree2.prototype._remove = function(i, t, comparator) {
      var x2;
      if (t === null)
        return null;
      t = splay(i, t, comparator);
      var cmp3 = comparator(i, t.key);
      if (cmp3 === 0) {
        if (t.left === null) {
          x2 = t.right;
        } else {
          x2 = splay(i, t.left, comparator);
          x2.right = t.right;
        }
        this._size--;
        return x2;
      }
      return t;
    };
    Tree2.prototype.pop = function() {
      var node = this._root;
      if (node) {
        while (node.left)
          node = node.left;
        this._root = splay(node.key, this._root, this._comparator);
        this._root = this._remove(node.key, this._root, this._comparator);
        return { key: node.key, data: node.data };
      }
      return null;
    };
    Tree2.prototype.findStatic = function(key) {
      var current = this._root;
      var compare10 = this._comparator;
      while (current) {
        var cmp3 = compare10(key, current.key);
        if (cmp3 === 0)
          return current;
        else if (cmp3 < 0)
          current = current.left;
        else
          current = current.right;
      }
      return null;
    };
    Tree2.prototype.find = function(key) {
      if (this._root) {
        this._root = splay(key, this._root, this._comparator);
        if (this._comparator(key, this._root.key) !== 0)
          return null;
      }
      return this._root;
    };
    Tree2.prototype.contains = function(key) {
      var current = this._root;
      var compare10 = this._comparator;
      while (current) {
        var cmp3 = compare10(key, current.key);
        if (cmp3 === 0)
          return true;
        else if (cmp3 < 0)
          current = current.left;
        else
          current = current.right;
      }
      return false;
    };
    Tree2.prototype.forEach = function(visitor, ctx) {
      var current = this._root;
      var Q = [];
      var done = false;
      while (!done) {
        if (current !== null) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length !== 0) {
            current = Q.pop();
            visitor.call(ctx, current);
            current = current.right;
          } else
            done = true;
        }
      }
      return this;
    };
    Tree2.prototype.range = function(low, high, fn, ctx) {
      var Q = [];
      var compare10 = this._comparator;
      var node = this._root;
      var cmp3;
      while (Q.length !== 0 || node) {
        if (node) {
          Q.push(node);
          node = node.left;
        } else {
          node = Q.pop();
          cmp3 = compare10(node.key, high);
          if (cmp3 > 0) {
            break;
          } else if (compare10(node.key, low) >= 0) {
            if (fn.call(ctx, node))
              return this;
          }
          node = node.right;
        }
      }
      return this;
    };
    Tree2.prototype.keys = function() {
      var keys = [];
      this.forEach(function(_a) {
        var key = _a.key;
        return keys.push(key);
      });
      return keys;
    };
    Tree2.prototype.values = function() {
      var values3 = [];
      this.forEach(function(_a) {
        var data = _a.data;
        return values3.push(data);
      });
      return values3;
    };
    Tree2.prototype.min = function() {
      if (this._root)
        return this.minNode(this._root).key;
      return null;
    };
    Tree2.prototype.max = function() {
      if (this._root)
        return this.maxNode(this._root).key;
      return null;
    };
    Tree2.prototype.minNode = function(t) {
      if (t === void 0) {
        t = this._root;
      }
      if (t)
        while (t.left)
          t = t.left;
      return t;
    };
    Tree2.prototype.maxNode = function(t) {
      if (t === void 0) {
        t = this._root;
      }
      if (t)
        while (t.right)
          t = t.right;
      return t;
    };
    Tree2.prototype.at = function(index2) {
      var current = this._root;
      var done = false;
      var i = 0;
      var Q = [];
      while (!done) {
        if (current) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length > 0) {
            current = Q.pop();
            if (i === index2)
              return current;
            i++;
            current = current.right;
          } else
            done = true;
        }
      }
      return null;
    };
    Tree2.prototype.next = function(d) {
      var root = this._root;
      var successor = null;
      if (d.right) {
        successor = d.right;
        while (successor.left)
          successor = successor.left;
        return successor;
      }
      var comparator = this._comparator;
      while (root) {
        var cmp3 = comparator(d.key, root.key);
        if (cmp3 === 0)
          break;
        else if (cmp3 < 0) {
          successor = root;
          root = root.left;
        } else
          root = root.right;
      }
      return successor;
    };
    Tree2.prototype.prev = function(d) {
      var root = this._root;
      var predecessor = null;
      if (d.left !== null) {
        predecessor = d.left;
        while (predecessor.right)
          predecessor = predecessor.right;
        return predecessor;
      }
      var comparator = this._comparator;
      while (root) {
        var cmp3 = comparator(d.key, root.key);
        if (cmp3 === 0)
          break;
        else if (cmp3 < 0)
          root = root.left;
        else {
          predecessor = root;
          root = root.right;
        }
      }
      return predecessor;
    };
    Tree2.prototype.clear = function() {
      this._root = null;
      this._size = 0;
      return this;
    };
    Tree2.prototype.toList = function() {
      return toList(this._root);
    };
    Tree2.prototype.load = function(keys, values3, presort) {
      if (values3 === void 0) {
        values3 = [];
      }
      if (presort === void 0) {
        presort = false;
      }
      var size11 = keys.length;
      var comparator = this._comparator;
      if (presort)
        sort(keys, values3, 0, size11 - 1, comparator);
      if (this._root === null) {
        this._root = loadRecursive(keys, values3, 0, size11);
        this._size = size11;
      } else {
        var mergedList = mergeLists(this.toList(), createList(keys, values3), comparator);
        size11 = this._size + size11;
        this._root = sortedListToBST({ head: mergedList }, 0, size11);
      }
      return this;
    };
    Tree2.prototype.isEmpty = function() {
      return this._root === null;
    };
    Object.defineProperty(Tree2.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tree2.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: true,
      configurable: true
    });
    Tree2.prototype.toString = function(printNode2) {
      if (printNode2 === void 0) {
        printNode2 = function(n) {
          return String(n.key);
        };
      }
      var out = [];
      printRow(this._root, "", true, function(v) {
        return out.push(v);
      }, printNode2);
      return out.join("");
    };
    Tree2.prototype.update = function(key, newKey, newData) {
      var comparator = this._comparator;
      var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
      if (comparator(key, newKey) < 0) {
        right = insert(newKey, newData, right, comparator);
      } else {
        left = insert(newKey, newData, left, comparator);
      }
      this._root = merge(left, right, comparator);
    };
    Tree2.prototype.split = function(key) {
      return split(key, this._root, this._comparator);
    };
    Tree2.prototype[Symbol.iterator] = function() {
      var current, Q, done;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            current = this._root;
            Q = [];
            done = false;
            _a.label = 1;
          case 1:
            if (!!done)
              return [3, 6];
            if (!(current !== null))
              return [3, 2];
            Q.push(current);
            current = current.left;
            return [3, 5];
          case 2:
            if (!(Q.length !== 0))
              return [3, 4];
            current = Q.pop();
            return [4, current];
          case 3:
            _a.sent();
            current = current.right;
            return [3, 5];
          case 4:
            done = true;
            _a.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    return Tree2;
  }()
);
function loadRecursive(keys, values3, start, end) {
  var size11 = end - start;
  if (size11 > 0) {
    var middle = start + Math.floor(size11 / 2);
    var key = keys[middle];
    var data = values3[middle];
    var node = new Node4(key, data);
    node.left = loadRecursive(keys, values3, start, middle);
    node.right = loadRecursive(keys, values3, middle + 1, end);
    return node;
  }
  return null;
}
function createList(keys, values3) {
  var head = new Node4(null, null);
  var p = head;
  for (var i = 0; i < keys.length; i++) {
    p = p.next = new Node4(keys[i], values3[i]);
  }
  p.next = null;
  return head.next;
}
function toList(root) {
  var current = root;
  var Q = [];
  var done = false;
  var head = new Node4(null, null);
  var p = head;
  while (!done) {
    if (current) {
      Q.push(current);
      current = current.left;
    } else {
      if (Q.length > 0) {
        current = p = p.next = Q.pop();
        current = current.right;
      } else
        done = true;
    }
  }
  p.next = null;
  return head.next;
}
function sortedListToBST(list, start, end) {
  var size11 = end - start;
  if (size11 > 0) {
    var middle = start + Math.floor(size11 / 2);
    var left = sortedListToBST(list, start, middle);
    var root = list.head;
    root.left = left;
    list.head = list.head.next;
    root.right = sortedListToBST(list, middle + 1, end);
    return root;
  }
  return null;
}
function mergeLists(l1, l2, compare10) {
  var head = new Node4(null, null);
  var p = head;
  var p1 = l1;
  var p2 = l2;
  while (p1 !== null && p2 !== null) {
    if (compare10(p1.key, p2.key) < 0) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }
  if (p1 !== null) {
    p.next = p1;
  } else if (p2 !== null) {
    p.next = p2;
  }
  return head.next;
}
function sort(keys, values3, left, right, compare10) {
  if (left >= right)
    return;
  var pivot = keys[left + right >> 1];
  var i = left - 1;
  var j = right + 1;
  while (true) {
    do
      i++;
    while (compare10(keys[i], pivot) < 0);
    do
      j--;
    while (compare10(keys[j], pivot) > 0);
    if (i >= j)
      break;
    var tmp = keys[i];
    keys[i] = keys[j];
    keys[j] = tmp;
    tmp = values3[i];
    values3[i] = values3[j];
    values3[j] = tmp;
  }
  sort(keys, values3, left, j, compare10);
  sort(keys, values3, j + 1, right, compare10);
}
var splay_esm_default = Tree;

// node_modules/polygon-clipping/dist/polygon-clipping.esm.js
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var isInBbox = function isInBbox2(bbox3, point4) {
  return bbox3.ll.x <= point4.x && point4.x <= bbox3.ur.x && bbox3.ll.y <= point4.y && point4.y <= bbox3.ur.y;
};
var getBboxOverlap = function getBboxOverlap2(b1, b2) {
  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
    return null;
  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
  return {
    ll: {
      x: lowerX,
      y: lowerY
    },
    ur: {
      x: upperX,
      y: upperY
    }
  };
};
var epsilon3 = Number.EPSILON;
if (epsilon3 === void 0)
  epsilon3 = Math.pow(2, -52);
var EPSILON_SQ = epsilon3 * epsilon3;
var cmp = function cmp2(a, b) {
  if (-epsilon3 < a && a < epsilon3) {
    if (-epsilon3 < b && b < epsilon3) {
      return 0;
    }
  }
  var ab2 = a - b;
  if (ab2 * ab2 < EPSILON_SQ * a * b) {
    return 0;
  }
  return a < b ? -1 : 1;
};
var PtRounder = function() {
  function PtRounder2() {
    _classCallCheck(this, PtRounder2);
    this.reset();
  }
  _createClass(PtRounder2, [{
    key: "reset",
    value: function reset() {
      this.xRounder = new CoordRounder();
      this.yRounder = new CoordRounder();
    }
  }, {
    key: "round",
    value: function round2(x2, y2) {
      return {
        x: this.xRounder.round(x2),
        y: this.yRounder.round(y2)
      };
    }
  }]);
  return PtRounder2;
}();
var CoordRounder = function() {
  function CoordRounder2() {
    _classCallCheck(this, CoordRounder2);
    this.tree = new splay_esm_default();
    this.round(0);
  }
  _createClass(CoordRounder2, [{
    key: "round",
    value: function round2(coord) {
      var node = this.tree.add(coord);
      var prevNode = this.tree.prev(node);
      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
        this.tree.remove(coord);
        return prevNode.key;
      }
      var nextNode = this.tree.next(node);
      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
        this.tree.remove(coord);
        return nextNode.key;
      }
      return coord;
    }
  }]);
  return CoordRounder2;
}();
var rounder = new PtRounder();
var crossProduct2 = function crossProduct3(a, b) {
  return a.x * b.y - a.y * b.x;
};
var dotProduct = function dotProduct2(a, b) {
  return a.x * b.x + a.y * b.y;
};
var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
  var v1 = {
    x: endPt1.x - basePt.x,
    y: endPt1.y - basePt.y
  };
  var v2 = {
    x: endPt2.x - basePt.x,
    y: endPt2.y - basePt.y
  };
  var kross = crossProduct2(v1, v2);
  return cmp(kross, 0);
};
var length2 = function length3(v) {
  return Math.sqrt(dotProduct(v, v));
};
var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
  var vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  var vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return crossProduct2(vAngle, vBase) / length2(vAngle) / length2(vBase);
};
var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
  var vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  var vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return dotProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
};
var horizontalIntersection = function horizontalIntersection2(pt, v, y2) {
  if (v.y === 0)
    return null;
  return {
    x: pt.x + v.x / v.y * (y2 - pt.y),
    y: y2
  };
};
var verticalIntersection = function verticalIntersection2(pt, v, x2) {
  if (v.x === 0)
    return null;
  return {
    x: x2,
    y: pt.y + v.y / v.x * (x2 - pt.x)
  };
};
var intersection2 = function intersection3(pt1, v1, pt2, v2) {
  if (v1.x === 0)
    return verticalIntersection(pt2, v2, pt1.x);
  if (v2.x === 0)
    return verticalIntersection(pt1, v1, pt2.x);
  if (v1.y === 0)
    return horizontalIntersection(pt2, v2, pt1.y);
  if (v2.y === 0)
    return horizontalIntersection(pt1, v1, pt2.y);
  var kross = crossProduct2(v1, v2);
  if (kross == 0)
    return null;
  var ve = {
    x: pt2.x - pt1.x,
    y: pt2.y - pt1.y
  };
  var d1 = crossProduct2(ve, v1) / kross;
  var d2 = crossProduct2(ve, v2) / kross;
  var x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
  var y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
  var x3 = (x1 + x2) / 2;
  var y3 = (y1 + y2) / 2;
  return {
    x: x3,
    y: y3
  };
};
var SweepEvent = function() {
  _createClass(SweepEvent2, null, [{
    key: "compare",
    // for ordering sweep events in the sweep event queue
    value: function compare10(a, b) {
      var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
      if (ptCmp !== 0)
        return ptCmp;
      if (a.point !== b.point)
        a.link(b);
      if (a.isLeft !== b.isLeft)
        return a.isLeft ? 1 : -1;
      return Segment.compare(a.segment, b.segment);
    }
    // for ordering points in sweep line order
  }, {
    key: "comparePoints",
    value: function comparePoints(aPt, bPt) {
      if (aPt.x < bPt.x)
        return -1;
      if (aPt.x > bPt.x)
        return 1;
      if (aPt.y < bPt.y)
        return -1;
      if (aPt.y > bPt.y)
        return 1;
      return 0;
    }
    // Warning: 'point' input will be modified and re-used (for performance)
  }]);
  function SweepEvent2(point4, isLeft2) {
    _classCallCheck(this, SweepEvent2);
    if (point4.events === void 0)
      point4.events = [this];
    else
      point4.events.push(this);
    this.point = point4;
    this.isLeft = isLeft2;
  }
  _createClass(SweepEvent2, [{
    key: "link",
    value: function link(other) {
      if (other.point === this.point) {
        throw new Error("Tried to link already linked events");
      }
      var otherEvents = other.point.events;
      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
        var evt = otherEvents[i];
        this.point.events.push(evt);
        evt.point = this.point;
      }
      this.checkForConsuming();
    }
    /* Do a pass over our linked events and check to see if any pair
     * of segments match, and should be consumed. */
  }, {
    key: "checkForConsuming",
    value: function checkForConsuming() {
      var numEvents = this.point.events.length;
      for (var i = 0; i < numEvents; i++) {
        var evt1 = this.point.events[i];
        if (evt1.segment.consumedBy !== void 0)
          continue;
        for (var j = i + 1; j < numEvents; j++) {
          var evt2 = this.point.events[j];
          if (evt2.consumedBy !== void 0)
            continue;
          if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
            continue;
          evt1.segment.consume(evt2.segment);
        }
      }
    }
  }, {
    key: "getAvailableLinkedEvents",
    value: function getAvailableLinkedEvents() {
      var events = [];
      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
        var evt = this.point.events[i];
        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
          events.push(evt);
        }
      }
      return events;
    }
    /**
     * Returns a comparator function for sorting linked events that will
     * favor the event that will give us the smallest left-side angle.
     * All ring construction starts as low as possible heading to the right,
     * so by always turning left as sharp as possible we'll get polygons
     * without uncessary loops & holes.
     *
     * The comparator function has a compute cache such that it avoids
     * re-computing already-computed values.
     */
  }, {
    key: "getLeftmostComparator",
    value: function getLeftmostComparator(baseEvent) {
      var _this = this;
      var cache = /* @__PURE__ */ new Map();
      var fillCache = function fillCache2(linkedEvent) {
        var nextEvent = linkedEvent.otherSE;
        cache.set(linkedEvent, {
          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
        });
      };
      return function(a, b) {
        if (!cache.has(a))
          fillCache(a);
        if (!cache.has(b))
          fillCache(b);
        var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
        var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
        if (asine >= 0 && bsine >= 0) {
          if (acosine < bcosine)
            return 1;
          if (acosine > bcosine)
            return -1;
          return 0;
        }
        if (asine < 0 && bsine < 0) {
          if (acosine < bcosine)
            return -1;
          if (acosine > bcosine)
            return 1;
          return 0;
        }
        if (bsine < asine)
          return -1;
        if (bsine > asine)
          return 1;
        return 0;
      };
    }
  }]);
  return SweepEvent2;
}();
var segmentId = 0;
var Segment = function() {
  _createClass(Segment2, null, [{
    key: "compare",
    /* This compare() function is for ordering segments in the sweep
     * line tree, and does so according to the following criteria:
     *
     * Consider the vertical line that lies an infinestimal step to the
     * right of the right-more of the two left endpoints of the input
     * segments. Imagine slowly moving a point up from negative infinity
     * in the increasing y direction. Which of the two segments will that
     * point intersect first? That segment comes 'before' the other one.
     *
     * If neither segment would be intersected by such a line, (if one
     * or more of the segments are vertical) then the line to be considered
     * is directly on the right-more of the two left inputs.
     */
    value: function compare10(a, b) {
      var alx = a.leftSE.point.x;
      var blx = b.leftSE.point.x;
      var arx = a.rightSE.point.x;
      var brx = b.rightSE.point.x;
      if (brx < alx)
        return 1;
      if (arx < blx)
        return -1;
      var aly = a.leftSE.point.y;
      var bly = b.leftSE.point.y;
      var ary = a.rightSE.point.y;
      var bry = b.rightSE.point.y;
      if (alx < blx) {
        if (bly < aly && bly < ary)
          return 1;
        if (bly > aly && bly > ary)
          return -1;
        var aCmpBLeft = a.comparePoint(b.leftSE.point);
        if (aCmpBLeft < 0)
          return 1;
        if (aCmpBLeft > 0)
          return -1;
        var bCmpARight = b.comparePoint(a.rightSE.point);
        if (bCmpARight !== 0)
          return bCmpARight;
        return -1;
      }
      if (alx > blx) {
        if (aly < bly && aly < bry)
          return -1;
        if (aly > bly && aly > bry)
          return 1;
        var bCmpALeft = b.comparePoint(a.leftSE.point);
        if (bCmpALeft !== 0)
          return bCmpALeft;
        var aCmpBRight = a.comparePoint(b.rightSE.point);
        if (aCmpBRight < 0)
          return 1;
        if (aCmpBRight > 0)
          return -1;
        return 1;
      }
      if (aly < bly)
        return -1;
      if (aly > bly)
        return 1;
      if (arx < brx) {
        var _bCmpARight = b.comparePoint(a.rightSE.point);
        if (_bCmpARight !== 0)
          return _bCmpARight;
      }
      if (arx > brx) {
        var _aCmpBRight = a.comparePoint(b.rightSE.point);
        if (_aCmpBRight < 0)
          return 1;
        if (_aCmpBRight > 0)
          return -1;
      }
      if (arx !== brx) {
        var ay = ary - aly;
        var ax = arx - alx;
        var by = bry - bly;
        var bx = brx - blx;
        if (ay > ax && by < bx)
          return 1;
        if (ay < ax && by > bx)
          return -1;
      }
      if (arx > brx)
        return 1;
      if (arx < brx)
        return -1;
      if (ary < bry)
        return -1;
      if (ary > bry)
        return 1;
      if (a.id < b.id)
        return -1;
      if (a.id > b.id)
        return 1;
      return 0;
    }
    /* Warning: a reference to ringWindings input will be stored,
     *  and possibly will be later modified */
  }]);
  function Segment2(leftSE, rightSE, rings, windings) {
    _classCallCheck(this, Segment2);
    this.id = ++segmentId;
    this.leftSE = leftSE;
    leftSE.segment = this;
    leftSE.otherSE = rightSE;
    this.rightSE = rightSE;
    rightSE.segment = this;
    rightSE.otherSE = leftSE;
    this.rings = rings;
    this.windings = windings;
  }
  _createClass(Segment2, [{
    key: "replaceRightSE",
    /* When a segment is split, the rightSE is replaced with a new sweep event */
    value: function replaceRightSE(newRightSE) {
      this.rightSE = newRightSE;
      this.rightSE.segment = this;
      this.rightSE.otherSE = this.leftSE;
      this.leftSE.otherSE = this.rightSE;
    }
  }, {
    key: "bbox",
    value: function bbox3() {
      var y1 = this.leftSE.point.y;
      var y2 = this.rightSE.point.y;
      return {
        ll: {
          x: this.leftSE.point.x,
          y: y1 < y2 ? y1 : y2
        },
        ur: {
          x: this.rightSE.point.x,
          y: y1 > y2 ? y1 : y2
        }
      };
    }
    /* A vector from the left point to the right */
  }, {
    key: "vector",
    value: function vector() {
      return {
        x: this.rightSE.point.x - this.leftSE.point.x,
        y: this.rightSE.point.y - this.leftSE.point.y
      };
    }
  }, {
    key: "isAnEndpoint",
    value: function isAnEndpoint(pt) {
      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
    }
    /* Compare this segment with a point.
     *
     * A point P is considered to be colinear to a segment if there
     * exists a distance D such that if we travel along the segment
     * from one * endpoint towards the other a distance D, we find
     * ourselves at point P.
     *
     * Return value indicates:
     *
     *   1: point lies above the segment (to the left of vertical)
     *   0: point is colinear to segment
     *  -1: point lies below the segment (to the right of vertical)
     */
  }, {
    key: "comparePoint",
    value: function comparePoint(point4) {
      if (this.isAnEndpoint(point4))
        return 0;
      var lPt = this.leftSE.point;
      var rPt = this.rightSE.point;
      var v = this.vector();
      if (lPt.x === rPt.x) {
        if (point4.x === lPt.x)
          return 0;
        return point4.x < lPt.x ? 1 : -1;
      }
      var yDist = (point4.y - lPt.y) / v.y;
      var xFromYDist = lPt.x + yDist * v.x;
      if (point4.x === xFromYDist)
        return 0;
      var xDist = (point4.x - lPt.x) / v.x;
      var yFromXDist = lPt.y + xDist * v.y;
      if (point4.y === yFromXDist)
        return 0;
      return point4.y < yFromXDist ? -1 : 1;
    }
    /**
     * Given another segment, returns the first non-trivial intersection
     * between the two segments (in terms of sweep line ordering), if it exists.
     *
     * A 'non-trivial' intersection is one that will cause one or both of the
     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
     *
     *   * endpoint of segA with endpoint of segB --> trivial
     *   * endpoint of segA with point along segB --> non-trivial
     *   * endpoint of segB with point along segA --> non-trivial
     *   * point along segA with point along segB --> non-trivial
     *
     * If no non-trivial intersection exists, return null
     * Else, return null.
     */
  }, {
    key: "getIntersection",
    value: function getIntersection2(other) {
      var tBbox = this.bbox();
      var oBbox = other.bbox();
      var bboxOverlap = getBboxOverlap(tBbox, oBbox);
      if (bboxOverlap === null)
        return null;
      var tlp = this.leftSE.point;
      var trp = this.rightSE.point;
      var olp = other.leftSE.point;
      var orp = other.rightSE.point;
      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
      if (touchesThisLSE && touchesOtherLSE) {
        if (touchesThisRSE && !touchesOtherRSE)
          return trp;
        if (!touchesThisRSE && touchesOtherRSE)
          return orp;
        return null;
      }
      if (touchesThisLSE) {
        if (touchesOtherRSE) {
          if (tlp.x === orp.x && tlp.y === orp.y)
            return null;
        }
        return tlp;
      }
      if (touchesOtherLSE) {
        if (touchesThisRSE) {
          if (trp.x === olp.x && trp.y === olp.y)
            return null;
        }
        return olp;
      }
      if (touchesThisRSE && touchesOtherRSE)
        return null;
      if (touchesThisRSE)
        return trp;
      if (touchesOtherRSE)
        return orp;
      var pt = intersection2(tlp, this.vector(), olp, other.vector());
      if (pt === null)
        return null;
      if (!isInBbox(bboxOverlap, pt))
        return null;
      return rounder.round(pt.x, pt.y);
    }
    /**
     * Split the given segment into multiple segments on the given points.
     *  * Each existing segment will retain its leftSE and a new rightSE will be
     *    generated for it.
     *  * A new segment will be generated which will adopt the original segment's
     *    rightSE, and a new leftSE will be generated for it.
     *  * If there are more than two points given to split on, new segments
     *    in the middle will be generated with new leftSE and rightSE's.
     *  * An array of the newly generated SweepEvents will be returned.
     *
     * Warning: input array of points is modified
     */
  }, {
    key: "split",
    value: function split3(point4) {
      var newEvents = [];
      var alreadyLinked = point4.events !== void 0;
      var newLeftSE = new SweepEvent(point4, true);
      var newRightSE = new SweepEvent(point4, false);
      var oldRightSE = this.rightSE;
      this.replaceRightSE(newRightSE);
      newEvents.push(newRightSE);
      newEvents.push(newLeftSE);
      var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
        newSeg.swapEvents();
      }
      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
        this.swapEvents();
      }
      if (alreadyLinked) {
        newLeftSE.checkForConsuming();
        newRightSE.checkForConsuming();
      }
      return newEvents;
    }
    /* Swap which event is left and right */
  }, {
    key: "swapEvents",
    value: function swapEvents() {
      var tmpEvt = this.rightSE;
      this.rightSE = this.leftSE;
      this.leftSE = tmpEvt;
      this.leftSE.isLeft = true;
      this.rightSE.isLeft = false;
      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
        this.windings[i] *= -1;
      }
    }
    /* Consume another segment. We take their rings under our wing
     * and mark them as consumed. Use for perfectly overlapping segments */
  }, {
    key: "consume",
    value: function consume(other) {
      var consumer = this;
      var consumee = other;
      while (consumer.consumedBy) {
        consumer = consumer.consumedBy;
      }
      while (consumee.consumedBy) {
        consumee = consumee.consumedBy;
      }
      var cmp3 = Segment2.compare(consumer, consumee);
      if (cmp3 === 0)
        return;
      if (cmp3 > 0) {
        var tmp = consumer;
        consumer = consumee;
        consumee = tmp;
      }
      if (consumer.prev === consumee) {
        var _tmp = consumer;
        consumer = consumee;
        consumee = _tmp;
      }
      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
        var ring = consumee.rings[i];
        var winding = consumee.windings[i];
        var index2 = consumer.rings.indexOf(ring);
        if (index2 === -1) {
          consumer.rings.push(ring);
          consumer.windings.push(winding);
        } else
          consumer.windings[index2] += winding;
      }
      consumee.rings = null;
      consumee.windings = null;
      consumee.consumedBy = consumer;
      consumee.leftSE.consumedBy = consumer.leftSE;
      consumee.rightSE.consumedBy = consumer.rightSE;
    }
    /* The first segment previous segment chain that is in the result */
  }, {
    key: "prevInResult",
    value: function prevInResult() {
      if (this._prevInResult !== void 0)
        return this._prevInResult;
      if (!this.prev)
        this._prevInResult = null;
      else if (this.prev.isInResult())
        this._prevInResult = this.prev;
      else
        this._prevInResult = this.prev.prevInResult();
      return this._prevInResult;
    }
  }, {
    key: "beforeState",
    value: function beforeState() {
      if (this._beforeState !== void 0)
        return this._beforeState;
      if (!this.prev)
        this._beforeState = {
          rings: [],
          windings: [],
          multiPolys: []
        };
      else {
        var seg = this.prev.consumedBy || this.prev;
        this._beforeState = seg.afterState();
      }
      return this._beforeState;
    }
  }, {
    key: "afterState",
    value: function afterState() {
      if (this._afterState !== void 0)
        return this._afterState;
      var beforeState = this.beforeState();
      this._afterState = {
        rings: beforeState.rings.slice(0),
        windings: beforeState.windings.slice(0),
        multiPolys: []
      };
      var ringsAfter = this._afterState.rings;
      var windingsAfter = this._afterState.windings;
      var mpsAfter = this._afterState.multiPolys;
      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
        var ring = this.rings[i];
        var winding = this.windings[i];
        var index2 = ringsAfter.indexOf(ring);
        if (index2 === -1) {
          ringsAfter.push(ring);
          windingsAfter.push(winding);
        } else
          windingsAfter[index2] += winding;
      }
      var polysAfter = [];
      var polysExclude = [];
      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
        if (windingsAfter[_i] === 0)
          continue;
        var _ring = ringsAfter[_i];
        var poly = _ring.poly;
        if (polysExclude.indexOf(poly) !== -1)
          continue;
        if (_ring.isExterior)
          polysAfter.push(poly);
        else {
          if (polysExclude.indexOf(poly) === -1)
            polysExclude.push(poly);
          var _index = polysAfter.indexOf(_ring.poly);
          if (_index !== -1)
            polysAfter.splice(_index, 1);
        }
      }
      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
        var mp = polysAfter[_i2].multiPoly;
        if (mpsAfter.indexOf(mp) === -1)
          mpsAfter.push(mp);
      }
      return this._afterState;
    }
    /* Is this segment part of the final result? */
  }, {
    key: "isInResult",
    value: function isInResult2() {
      if (this.consumedBy)
        return false;
      if (this._isInResult !== void 0)
        return this._isInResult;
      var mpsBefore = this.beforeState().multiPolys;
      var mpsAfter = this.afterState().multiPolys;
      switch (operation.type) {
        case "union": {
          var noBefores = mpsBefore.length === 0;
          var noAfters = mpsAfter.length === 0;
          this._isInResult = noBefores !== noAfters;
          break;
        }
        case "intersection": {
          var least;
          var most;
          if (mpsBefore.length < mpsAfter.length) {
            least = mpsBefore.length;
            most = mpsAfter.length;
          } else {
            least = mpsAfter.length;
            most = mpsBefore.length;
          }
          this._isInResult = most === operation.numMultiPolys && least < most;
          break;
        }
        case "xor": {
          var diff2 = Math.abs(mpsBefore.length - mpsAfter.length);
          this._isInResult = diff2 % 2 === 1;
          break;
        }
        case "difference": {
          var isJustSubject = function isJustSubject2(mps) {
            return mps.length === 1 && mps[0].isSubject;
          };
          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
          break;
        }
        default:
          throw new Error("Unrecognized operation type found ".concat(operation.type));
      }
      return this._isInResult;
    }
  }], [{
    key: "fromRing",
    value: function fromRing(pt1, pt2, ring) {
      var leftPt, rightPt, winding;
      var cmpPts = SweepEvent.comparePoints(pt1, pt2);
      if (cmpPts < 0) {
        leftPt = pt1;
        rightPt = pt2;
        winding = 1;
      } else if (cmpPts > 0) {
        leftPt = pt2;
        rightPt = pt1;
        winding = -1;
      } else
        throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
      var leftSE = new SweepEvent(leftPt, true);
      var rightSE = new SweepEvent(rightPt, false);
      return new Segment2(leftSE, rightSE, [ring], [winding]);
    }
  }]);
  return Segment2;
}();
var RingIn = function() {
  function RingIn2(geomRing, poly, isExterior) {
    _classCallCheck(this, RingIn2);
    if (!Array.isArray(geomRing) || geomRing.length === 0) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.poly = poly;
    this.isExterior = isExterior;
    this.segments = [];
    if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
    this.bbox = {
      ll: {
        x: firstPoint.x,
        y: firstPoint.y
      },
      ur: {
        x: firstPoint.x,
        y: firstPoint.y
      }
    };
    var prevPoint = firstPoint;
    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
      if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      var point4 = rounder.round(geomRing[i][0], geomRing[i][1]);
      if (point4.x === prevPoint.x && point4.y === prevPoint.y)
        continue;
      this.segments.push(Segment.fromRing(prevPoint, point4, this));
      if (point4.x < this.bbox.ll.x)
        this.bbox.ll.x = point4.x;
      if (point4.y < this.bbox.ll.y)
        this.bbox.ll.y = point4.y;
      if (point4.x > this.bbox.ur.x)
        this.bbox.ur.x = point4.x;
      if (point4.y > this.bbox.ur.y)
        this.bbox.ur.y = point4.y;
      prevPoint = point4;
    }
    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
    }
  }
  _createClass(RingIn2, [{
    key: "getSweepEvents",
    value: function getSweepEvents() {
      var sweepEvents = [];
      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
        var segment = this.segments[i];
        sweepEvents.push(segment.leftSE);
        sweepEvents.push(segment.rightSE);
      }
      return sweepEvents;
    }
  }]);
  return RingIn2;
}();
var PolyIn = function() {
  function PolyIn2(geomPoly, multiPoly) {
    _classCallCheck(this, PolyIn2);
    if (!Array.isArray(geomPoly)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.exteriorRing = new RingIn(geomPoly[0], this, true);
    this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    };
    this.interiorRings = [];
    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
      var ring = new RingIn(geomPoly[i], this, false);
      if (ring.bbox.ll.x < this.bbox.ll.x)
        this.bbox.ll.x = ring.bbox.ll.x;
      if (ring.bbox.ll.y < this.bbox.ll.y)
        this.bbox.ll.y = ring.bbox.ll.y;
      if (ring.bbox.ur.x > this.bbox.ur.x)
        this.bbox.ur.x = ring.bbox.ur.x;
      if (ring.bbox.ur.y > this.bbox.ur.y)
        this.bbox.ur.y = ring.bbox.ur.y;
      this.interiorRings.push(ring);
    }
    this.multiPoly = multiPoly;
  }
  _createClass(PolyIn2, [{
    key: "getSweepEvents",
    value: function getSweepEvents() {
      var sweepEvents = this.exteriorRing.getSweepEvents();
      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
        var ringSweepEvents = this.interiorRings[i].getSweepEvents();
        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
          sweepEvents.push(ringSweepEvents[j]);
        }
      }
      return sweepEvents;
    }
  }]);
  return PolyIn2;
}();
var MultiPolyIn = function() {
  function MultiPolyIn2(geom, isSubject) {
    _classCallCheck(this, MultiPolyIn2);
    if (!Array.isArray(geom)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    try {
      if (typeof geom[0][0][0] === "number")
        geom = [geom];
    } catch (ex) {
    }
    this.polys = [];
    this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (var i = 0, iMax = geom.length; i < iMax; i++) {
      var poly = new PolyIn(geom[i], this);
      if (poly.bbox.ll.x < this.bbox.ll.x)
        this.bbox.ll.x = poly.bbox.ll.x;
      if (poly.bbox.ll.y < this.bbox.ll.y)
        this.bbox.ll.y = poly.bbox.ll.y;
      if (poly.bbox.ur.x > this.bbox.ur.x)
        this.bbox.ur.x = poly.bbox.ur.x;
      if (poly.bbox.ur.y > this.bbox.ur.y)
        this.bbox.ur.y = poly.bbox.ur.y;
      this.polys.push(poly);
    }
    this.isSubject = isSubject;
  }
  _createClass(MultiPolyIn2, [{
    key: "getSweepEvents",
    value: function getSweepEvents() {
      var sweepEvents = [];
      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
        var polySweepEvents = this.polys[i].getSweepEvents();
        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
          sweepEvents.push(polySweepEvents[j]);
        }
      }
      return sweepEvents;
    }
  }]);
  return MultiPolyIn2;
}();
var RingOut = function() {
  _createClass(RingOut2, null, [{
    key: "factory",
    /* Given the segments from the sweep line pass, compute & return a series
     * of closed rings from all the segments marked to be part of the result */
    value: function factory(allSegments) {
      var ringsOut = [];
      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
        var segment = allSegments[i];
        if (!segment.isInResult() || segment.ringOut)
          continue;
        var prevEvent = null;
        var event = segment.leftSE;
        var nextEvent = segment.rightSE;
        var events = [event];
        var startingPoint = event.point;
        var intersectionLEs = [];
        while (true) {
          prevEvent = event;
          event = nextEvent;
          events.push(event);
          if (event.point === startingPoint)
            break;
          while (true) {
            var availableLEs = event.getAvailableLinkedEvents();
            if (availableLEs.length === 0) {
              var firstPt = events[0].point;
              var lastPt = events[events.length - 1].point;
              throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
            }
            if (availableLEs.length === 1) {
              nextEvent = availableLEs[0].otherSE;
              break;
            }
            var indexLE = null;
            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
              if (intersectionLEs[j].point === event.point) {
                indexLE = j;
                break;
              }
            }
            if (indexLE !== null) {
              var intersectionLE = intersectionLEs.splice(indexLE)[0];
              var ringEvents = events.splice(intersectionLE.index);
              ringEvents.unshift(ringEvents[0].otherSE);
              ringsOut.push(new RingOut2(ringEvents.reverse()));
              continue;
            }
            intersectionLEs.push({
              index: events.length,
              point: event.point
            });
            var comparator = event.getLeftmostComparator(prevEvent);
            nextEvent = availableLEs.sort(comparator)[0].otherSE;
            break;
          }
        }
        ringsOut.push(new RingOut2(events));
      }
      return ringsOut;
    }
  }]);
  function RingOut2(events) {
    _classCallCheck(this, RingOut2);
    this.events = events;
    for (var i = 0, iMax = events.length; i < iMax; i++) {
      events[i].segment.ringOut = this;
    }
    this.poly = null;
  }
  _createClass(RingOut2, [{
    key: "getGeom",
    value: function getGeom2() {
      var prevPt = this.events[0].point;
      var points2 = [prevPt];
      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
        var _pt = this.events[i].point;
        var _nextPt = this.events[i + 1].point;
        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
          continue;
        points2.push(_pt);
        prevPt = _pt;
      }
      if (points2.length === 1)
        return null;
      var pt = points2[0];
      var nextPt = points2[1];
      if (compareVectorAngles(pt, prevPt, nextPt) === 0)
        points2.shift();
      points2.push(points2[0]);
      var step = this.isExteriorRing() ? 1 : -1;
      var iStart = this.isExteriorRing() ? 0 : points2.length - 1;
      var iEnd = this.isExteriorRing() ? points2.length : -1;
      var orderedPoints = [];
      for (var _i = iStart; _i != iEnd; _i += step) {
        orderedPoints.push([points2[_i].x, points2[_i].y]);
      }
      return orderedPoints;
    }
  }, {
    key: "isExteriorRing",
    value: function isExteriorRing() {
      if (this._isExteriorRing === void 0) {
        var enclosing = this.enclosingRing();
        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
      }
      return this._isExteriorRing;
    }
  }, {
    key: "enclosingRing",
    value: function enclosingRing() {
      if (this._enclosingRing === void 0) {
        this._enclosingRing = this._calcEnclosingRing();
      }
      return this._enclosingRing;
    }
    /* Returns the ring that encloses this one, if any */
  }, {
    key: "_calcEnclosingRing",
    value: function _calcEnclosingRing() {
      var leftMostEvt = this.events[0];
      for (var i = 1, iMax = this.events.length; i < iMax; i++) {
        var evt = this.events[i];
        if (SweepEvent.compare(leftMostEvt, evt) > 0)
          leftMostEvt = evt;
      }
      var prevSeg = leftMostEvt.segment.prevInResult();
      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      while (true) {
        if (!prevSeg)
          return null;
        if (!prevPrevSeg)
          return prevSeg.ringOut;
        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
            return prevSeg.ringOut;
          } else
            return prevSeg.ringOut.enclosingRing();
        }
        prevSeg = prevPrevSeg.prevInResult();
        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      }
    }
  }]);
  return RingOut2;
}();
var PolyOut = function() {
  function PolyOut2(exteriorRing) {
    _classCallCheck(this, PolyOut2);
    this.exteriorRing = exteriorRing;
    exteriorRing.poly = this;
    this.interiorRings = [];
  }
  _createClass(PolyOut2, [{
    key: "addInterior",
    value: function addInterior(ring) {
      this.interiorRings.push(ring);
      ring.poly = this;
    }
  }, {
    key: "getGeom",
    value: function getGeom2() {
      var geom = [this.exteriorRing.getGeom()];
      if (geom[0] === null)
        return null;
      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
        var ringGeom = this.interiorRings[i].getGeom();
        if (ringGeom === null)
          continue;
        geom.push(ringGeom);
      }
      return geom;
    }
  }]);
  return PolyOut2;
}();
var MultiPolyOut = function() {
  function MultiPolyOut2(rings) {
    _classCallCheck(this, MultiPolyOut2);
    this.rings = rings;
    this.polys = this._composePolys(rings);
  }
  _createClass(MultiPolyOut2, [{
    key: "getGeom",
    value: function getGeom2() {
      var geom = [];
      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
        var polyGeom = this.polys[i].getGeom();
        if (polyGeom === null)
          continue;
        geom.push(polyGeom);
      }
      return geom;
    }
  }, {
    key: "_composePolys",
    value: function _composePolys(rings) {
      var polys = [];
      for (var i = 0, iMax = rings.length; i < iMax; i++) {
        var ring = rings[i];
        if (ring.poly)
          continue;
        if (ring.isExteriorRing())
          polys.push(new PolyOut(ring));
        else {
          var enclosingRing = ring.enclosingRing();
          if (!enclosingRing.poly)
            polys.push(new PolyOut(enclosingRing));
          enclosingRing.poly.addInterior(ring);
        }
      }
      return polys;
    }
  }]);
  return MultiPolyOut2;
}();
var SweepLine = function() {
  function SweepLine2(queue) {
    var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
    _classCallCheck(this, SweepLine2);
    this.queue = queue;
    this.tree = new splay_esm_default(comparator);
    this.segments = [];
  }
  _createClass(SweepLine2, [{
    key: "process",
    value: function process2(event) {
      var segment = event.segment;
      var newEvents = [];
      if (event.consumedBy) {
        if (event.isLeft)
          this.queue.remove(event.otherSE);
        else
          this.tree.remove(segment);
        return newEvents;
      }
      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
      if (!node)
        throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
      var prevNode = node;
      var nextNode = node;
      var prevSeg = void 0;
      var nextSeg = void 0;
      while (prevSeg === void 0) {
        prevNode = this.tree.prev(prevNode);
        if (prevNode === null)
          prevSeg = null;
        else if (prevNode.key.consumedBy === void 0)
          prevSeg = prevNode.key;
      }
      while (nextSeg === void 0) {
        nextNode = this.tree.next(nextNode);
        if (nextNode === null)
          nextSeg = null;
        else if (nextNode.key.consumedBy === void 0)
          nextSeg = nextNode.key;
      }
      if (event.isLeft) {
        var prevMySplitter = null;
        if (prevSeg) {
          var prevInter = prevSeg.getIntersection(segment);
          if (prevInter !== null) {
            if (!segment.isAnEndpoint(prevInter))
              prevMySplitter = prevInter;
            if (!prevSeg.isAnEndpoint(prevInter)) {
              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                newEvents.push(newEventsFromSplit[i]);
              }
            }
          }
        }
        var nextMySplitter = null;
        if (nextSeg) {
          var nextInter = nextSeg.getIntersection(segment);
          if (nextInter !== null) {
            if (!segment.isAnEndpoint(nextInter))
              nextMySplitter = nextInter;
            if (!nextSeg.isAnEndpoint(nextInter)) {
              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                newEvents.push(_newEventsFromSplit[_i]);
              }
            }
          }
        }
        if (prevMySplitter !== null || nextMySplitter !== null) {
          var mySplitter = null;
          if (prevMySplitter === null)
            mySplitter = nextMySplitter;
          else if (nextMySplitter === null)
            mySplitter = prevMySplitter;
          else {
            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
          }
          this.queue.remove(segment.rightSE);
          newEvents.push(segment.rightSE);
          var _newEventsFromSplit2 = segment.split(mySplitter);
          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
            newEvents.push(_newEventsFromSplit2[_i2]);
          }
        }
        if (newEvents.length > 0) {
          this.tree.remove(segment);
          newEvents.push(event);
        } else {
          this.segments.push(segment);
          segment.prev = prevSeg;
        }
      } else {
        if (prevSeg && nextSeg) {
          var inter = prevSeg.getIntersection(nextSeg);
          if (inter !== null) {
            if (!prevSeg.isAnEndpoint(inter)) {
              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                newEvents.push(_newEventsFromSplit3[_i3]);
              }
            }
            if (!nextSeg.isAnEndpoint(inter)) {
              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                newEvents.push(_newEventsFromSplit4[_i4]);
              }
            }
          }
        }
        this.tree.remove(segment);
      }
      return newEvents;
    }
    /* Safely split a segment that is currently in the datastructures
     * IE - a segment other than the one that is currently being processed. */
  }, {
    key: "_splitSafely",
    value: function _splitSafely(seg, pt) {
      this.tree.remove(seg);
      var rightSE = seg.rightSE;
      this.queue.remove(rightSE);
      var newEvents = seg.split(pt);
      newEvents.push(rightSE);
      if (seg.consumedBy === void 0)
        this.tree.insert(seg);
      return newEvents;
    }
  }]);
  return SweepLine2;
}();
var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
var Operation = function() {
  function Operation2() {
    _classCallCheck(this, Operation2);
  }
  _createClass(Operation2, [{
    key: "run",
    value: function run(type, geom, moreGeoms) {
      operation.type = type;
      rounder.reset();
      var multipolys = [new MultiPolyIn(geom, true)];
      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
        multipolys.push(new MultiPolyIn(moreGeoms[i], false));
      }
      operation.numMultiPolys = multipolys.length;
      if (operation.type === "difference") {
        var subject = multipolys[0];
        var _i = 1;
        while (_i < multipolys.length) {
          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
            _i++;
          else
            multipolys.splice(_i, 1);
        }
      }
      if (operation.type === "intersection") {
        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
          var mpA = multipolys[_i2];
          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
              return [];
          }
        }
      }
      var queue = new splay_esm_default(SweepEvent.compare);
      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
        var sweepEvents = multipolys[_i3].getSweepEvents();
        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
          queue.insert(sweepEvents[_j]);
          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
            throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
          }
        }
      }
      var sweepLine = new SweepLine(queue);
      var prevQueueSize = queue.size;
      var node = queue.pop();
      while (node) {
        var evt = node.key;
        if (queue.size === prevQueueSize) {
          var seg = evt.segment;
          throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
        }
        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
          throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
        }
        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
          throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
        }
        var newEvents = sweepLine.process(evt);
        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
          var _evt = newEvents[_i4];
          if (_evt.consumedBy === void 0)
            queue.insert(_evt);
        }
        prevQueueSize = queue.size;
        node = queue.pop();
      }
      rounder.reset();
      var ringsOut = RingOut.factory(sweepLine.segments);
      var result = new MultiPolyOut(ringsOut);
      return result.getGeom();
    }
  }]);
  return Operation2;
}();
var operation = new Operation();
var union = function union2(geom) {
  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    moreGeoms[_key - 1] = arguments[_key];
  }
  return operation.run("union", geom, moreGeoms);
};
var intersection$1 = function intersection4(geom) {
  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    moreGeoms[_key2 - 1] = arguments[_key2];
  }
  return operation.run("intersection", geom, moreGeoms);
};
var xor = function xor2(geom) {
  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    moreGeoms[_key3 - 1] = arguments[_key3];
  }
  return operation.run("xor", geom, moreGeoms);
};
var difference = function difference2(subjectGeom) {
  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    clippingGeoms[_key4 - 1] = arguments[_key4];
  }
  return operation.run("difference", subjectGeom, clippingGeoms);
};
var index = {
  union,
  intersection: intersection$1,
  xor,
  difference
};
var polygon_clipping_esm_default = index;

// node_modules/@turf/difference/dist/es/index.js
function difference3(polygon1, polygon22) {
  var geom1 = getGeom(polygon1);
  var geom2 = getGeom(polygon22);
  var properties = polygon1.properties || {};
  var differenced = polygon_clipping_esm_default.difference(
    geom1.coordinates,
    geom2.coordinates
  );
  if (differenced.length === 0)
    return null;
  if (differenced.length === 1)
    return polygon(differenced[0], properties);
  return multiPolygon(differenced, properties);
}
var es_default72 = difference3;

// node_modules/turf-jsts/jsts.mjs
if (!("fill" in Array.prototype)) {
  Object.defineProperty(Array.prototype, "fill", {
    configurable: true,
    value: function fill(value) {
      if (this === void 0 || this === null) {
        throw new TypeError(this + " is not an object");
      }
      var arrayLike = Object(this);
      var length4 = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;
      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
      relativeStart = relativeStart < 0 ? Math.max(length4 + relativeStart, 0) : Math.min(relativeStart, length4);
      var relativeEnd = 2 in arguments && arguments[2] !== void 0 ? parseInt(Number(arguments[2]), 10) || 0 : length4;
      relativeEnd = relativeEnd < 0 ? Math.max(length4 + arguments[2], 0) : Math.min(relativeEnd, length4);
      while (relativeStart < relativeEnd) {
        arrayLike[relativeStart] = value;
        ++relativeStart;
      }
      return arrayLike;
    },
    writable: true
  });
}
Number.isFinite = Number.isFinite || function(value) {
  return typeof value === "number" && isFinite(value);
};
Number.isInteger = Number.isInteger || function(val) {
  return typeof val === "number" && isFinite(val) && Math.floor(val) === val;
};
Number.parseFloat = Number.parseFloat || parseFloat;
Number.isNaN = Number.isNaN || function(value) {
  return value !== value;
};
Math.trunc = Math.trunc || function(x2) {
  return x2 < 0 ? Math.ceil(x2) : Math.floor(x2);
};
var NumberUtil = function NumberUtil2() {
};
NumberUtil.prototype.interfaces_ = function interfaces_() {
  return [];
};
NumberUtil.prototype.getClass = function getClass() {
  return NumberUtil;
};
NumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance(x1, x2, tolerance) {
  return Math.abs(x1 - x2) <= tolerance;
};
var IllegalArgumentException = function(Error2) {
  function IllegalArgumentException2(message) {
    Error2.call(this, message);
    this.name = "IllegalArgumentException";
    this.message = message;
    this.stack = new Error2().stack;
  }
  if (Error2)
    IllegalArgumentException2.__proto__ = Error2;
  IllegalArgumentException2.prototype = Object.create(Error2 && Error2.prototype);
  IllegalArgumentException2.prototype.constructor = IllegalArgumentException2;
  return IllegalArgumentException2;
}(Error);
var Double = function Double2() {
};
var staticAccessors$1 = { MAX_VALUE: { configurable: true } };
Double.isNaN = function isNaN2(n) {
  return Number.isNaN(n);
};
Double.doubleToLongBits = function doubleToLongBits(n) {
  return n;
};
Double.longBitsToDouble = function longBitsToDouble(n) {
  return n;
};
Double.isInfinite = function isInfinite(n) {
  return !Number.isFinite(n);
};
staticAccessors$1.MAX_VALUE.get = function() {
  return Number.MAX_VALUE;
};
Object.defineProperties(Double, staticAccessors$1);
var Comparable = function Comparable2() {
};
var Clonable = function Clonable2() {
};
var Comparator = function Comparator2() {
};
function Serializable() {
}
var Coordinate = function Coordinate2() {
  this.x = null;
  this.y = null;
  this.z = null;
  if (arguments.length === 0) {
    this.x = 0;
    this.y = 0;
    this.z = Coordinate2.NULL_ORDINATE;
  } else if (arguments.length === 1) {
    var c = arguments[0];
    this.x = c.x;
    this.y = c.y;
    this.z = c.z;
  } else if (arguments.length === 2) {
    this.x = arguments[0];
    this.y = arguments[1];
    this.z = Coordinate2.NULL_ORDINATE;
  } else if (arguments.length === 3) {
    this.x = arguments[0];
    this.y = arguments[1];
    this.z = arguments[2];
  }
};
var staticAccessors = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
Coordinate.prototype.setOrdinate = function setOrdinate(ordinateIndex, value) {
  switch (ordinateIndex) {
    case Coordinate.X:
      this.x = value;
      break;
    case Coordinate.Y:
      this.y = value;
      break;
    case Coordinate.Z:
      this.z = value;
      break;
    default:
      throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
  }
};
Coordinate.prototype.equals2D = function equals2D() {
  if (arguments.length === 1) {
    var other = arguments[0];
    if (this.x !== other.x) {
      return false;
    }
    if (this.y !== other.y) {
      return false;
    }
    return true;
  } else if (arguments.length === 2) {
    var c = arguments[0];
    var tolerance = arguments[1];
    if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
      return false;
    }
    if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
      return false;
    }
    return true;
  }
};
Coordinate.prototype.getOrdinate = function getOrdinate(ordinateIndex) {
  switch (ordinateIndex) {
    case Coordinate.X:
      return this.x;
    case Coordinate.Y:
      return this.y;
    case Coordinate.Z:
      return this.z;
    default:
  }
  throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
};
Coordinate.prototype.equals3D = function equals3D(other) {
  return this.x === other.x && this.y === other.y && ((this.z === other.z || Double.isNaN(this.z)) && Double.isNaN(other.z));
};
Coordinate.prototype.equals = function equals2(other) {
  if (!(other instanceof Coordinate)) {
    return false;
  }
  return this.equals2D(other);
};
Coordinate.prototype.equalInZ = function equalInZ(c, tolerance) {
  return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);
};
Coordinate.prototype.compareTo = function compareTo(o) {
  var other = o;
  if (this.x < other.x) {
    return -1;
  }
  if (this.x > other.x) {
    return 1;
  }
  if (this.y < other.y) {
    return -1;
  }
  if (this.y > other.y) {
    return 1;
  }
  return 0;
};
Coordinate.prototype.clone = function clone2() {
};
Coordinate.prototype.copy = function copy() {
  return new Coordinate(this);
};
Coordinate.prototype.toString = function toString() {
  return "(" + this.x + ", " + this.y + ", " + this.z + ")";
};
Coordinate.prototype.distance3D = function distance3D(c) {
  var dx = this.x - c.x;
  var dy = this.y - c.y;
  var dz = this.z - c.z;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
};
Coordinate.prototype.distance = function distance2(c) {
  var dx = this.x - c.x;
  var dy = this.y - c.y;
  return Math.sqrt(dx * dx + dy * dy);
};
Coordinate.prototype.hashCode = function hashCode() {
  var result = 17;
  result = 37 * result + Coordinate.hashCode(this.x);
  result = 37 * result + Coordinate.hashCode(this.y);
  return result;
};
Coordinate.prototype.setCoordinate = function setCoordinate(other) {
  this.x = other.x;
  this.y = other.y;
  this.z = other.z;
};
Coordinate.prototype.interfaces_ = function interfaces_2() {
  return [Comparable, Clonable, Serializable];
};
Coordinate.prototype.getClass = function getClass2() {
  return Coordinate;
};
Coordinate.hashCode = function hashCode2() {
  if (arguments.length === 1) {
    var x2 = arguments[0];
    var f = Double.doubleToLongBits(x2);
    return Math.trunc((f ^ f) >>> 32);
  }
};
staticAccessors.DimensionalComparator.get = function() {
  return DimensionalComparator;
};
staticAccessors.serialVersionUID.get = function() {
  return 6683108902428367e3;
};
staticAccessors.NULL_ORDINATE.get = function() {
  return Double.NaN;
};
staticAccessors.X.get = function() {
  return 0;
};
staticAccessors.Y.get = function() {
  return 1;
};
staticAccessors.Z.get = function() {
  return 2;
};
Object.defineProperties(Coordinate, staticAccessors);
var DimensionalComparator = function DimensionalComparator2(dimensionsToTest) {
  this._dimensionsToTest = 2;
  if (arguments.length === 0) {
  } else if (arguments.length === 1) {
    var dimensionsToTest$1 = arguments[0];
    if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) {
      throw new IllegalArgumentException("only 2 or 3 dimensions may be specified");
    }
    this._dimensionsToTest = dimensionsToTest$1;
  }
};
DimensionalComparator.prototype.compare = function compare(o1, o2) {
  var c1 = o1;
  var c2 = o2;
  var compX = DimensionalComparator.compare(c1.x, c2.x);
  if (compX !== 0) {
    return compX;
  }
  var compY = DimensionalComparator.compare(c1.y, c2.y);
  if (compY !== 0) {
    return compY;
  }
  if (this._dimensionsToTest <= 2) {
    return 0;
  }
  var compZ = DimensionalComparator.compare(c1.z, c2.z);
  return compZ;
};
DimensionalComparator.prototype.interfaces_ = function interfaces_3() {
  return [Comparator];
};
DimensionalComparator.prototype.getClass = function getClass3() {
  return DimensionalComparator;
};
DimensionalComparator.compare = function compare2(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  if (Double.isNaN(a)) {
    if (Double.isNaN(b)) {
      return 0;
    }
    return -1;
  }
  if (Double.isNaN(b)) {
    return 1;
  }
  return 0;
};
var CoordinateSequenceFactory = function CoordinateSequenceFactory2() {
};
CoordinateSequenceFactory.prototype.create = function create() {
};
CoordinateSequenceFactory.prototype.interfaces_ = function interfaces_4() {
  return [];
};
CoordinateSequenceFactory.prototype.getClass = function getClass4() {
  return CoordinateSequenceFactory;
};
var Location = function Location2() {
};
var staticAccessors$4 = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
Location.prototype.interfaces_ = function interfaces_5() {
  return [];
};
Location.prototype.getClass = function getClass5() {
  return Location;
};
Location.toLocationSymbol = function toLocationSymbol(locationValue) {
  switch (locationValue) {
    case Location.EXTERIOR:
      return "e";
    case Location.BOUNDARY:
      return "b";
    case Location.INTERIOR:
      return "i";
    case Location.NONE:
      return "-";
    default:
  }
  throw new IllegalArgumentException("Unknown location value: " + locationValue);
};
staticAccessors$4.INTERIOR.get = function() {
  return 0;
};
staticAccessors$4.BOUNDARY.get = function() {
  return 1;
};
staticAccessors$4.EXTERIOR.get = function() {
  return 2;
};
staticAccessors$4.NONE.get = function() {
  return -1;
};
Object.defineProperties(Location, staticAccessors$4);
var hasInterface = function(o, i) {
  return o.interfaces_ && o.interfaces_().indexOf(i) > -1;
};
var MathUtil = function MathUtil2() {
};
var staticAccessors$5 = { LOG_10: { configurable: true } };
MathUtil.prototype.interfaces_ = function interfaces_6() {
  return [];
};
MathUtil.prototype.getClass = function getClass6() {
  return MathUtil;
};
MathUtil.log10 = function log10(x2) {
  var ln = Math.log(x2);
  if (Double.isInfinite(ln)) {
    return ln;
  }
  if (Double.isNaN(ln)) {
    return ln;
  }
  return ln / MathUtil.LOG_10;
};
MathUtil.min = function min(v1, v2, v3, v4) {
  var min4 = v1;
  if (v2 < min4) {
    min4 = v2;
  }
  if (v3 < min4) {
    min4 = v3;
  }
  if (v4 < min4) {
    min4 = v4;
  }
  return min4;
};
MathUtil.clamp = function clamp() {
  if (typeof arguments[2] === "number" && (typeof arguments[0] === "number" && typeof arguments[1] === "number")) {
    var x2 = arguments[0];
    var min4 = arguments[1];
    var max3 = arguments[2];
    if (x2 < min4) {
      return min4;
    }
    if (x2 > max3) {
      return max3;
    }
    return x2;
  } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
    var x$1 = arguments[0];
    var min$1 = arguments[1];
    var max$1 = arguments[2];
    if (x$1 < min$1) {
      return min$1;
    }
    if (x$1 > max$1) {
      return max$1;
    }
    return x$1;
  }
};
MathUtil.wrap = function wrap(index2, max3) {
  if (index2 < 0) {
    return max3 - -index2 % max3;
  }
  return index2 % max3;
};
MathUtil.max = function max() {
  if (arguments.length === 3) {
    var v1 = arguments[0];
    var v2 = arguments[1];
    var v3 = arguments[2];
    var max3 = v1;
    if (v2 > max3) {
      max3 = v2;
    }
    if (v3 > max3) {
      max3 = v3;
    }
    return max3;
  } else if (arguments.length === 4) {
    var v1$1 = arguments[0];
    var v2$1 = arguments[1];
    var v3$1 = arguments[2];
    var v4 = arguments[3];
    var max$1 = v1$1;
    if (v2$1 > max$1) {
      max$1 = v2$1;
    }
    if (v3$1 > max$1) {
      max$1 = v3$1;
    }
    if (v4 > max$1) {
      max$1 = v4;
    }
    return max$1;
  }
};
MathUtil.average = function average(x1, x2) {
  return (x1 + x2) / 2;
};
staticAccessors$5.LOG_10.get = function() {
  return Math.log(10);
};
Object.defineProperties(MathUtil, staticAccessors$5);
var StringBuffer = function StringBuffer2(str) {
  this.str = str;
};
StringBuffer.prototype.append = function append(e) {
  this.str += e;
};
StringBuffer.prototype.setCharAt = function setCharAt(i, c) {
  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
};
StringBuffer.prototype.toString = function toString2(e) {
  return this.str;
};
var Integer = function Integer2(value) {
  this.value = value;
};
Integer.prototype.intValue = function intValue() {
  return this.value;
};
Integer.prototype.compareTo = function compareTo2(o) {
  if (this.value < o) {
    return -1;
  }
  if (this.value > o) {
    return 1;
  }
  return 0;
};
Integer.isNaN = function isNaN3(n) {
  return Number.isNaN(n);
};
var Character = function Character2() {
};
Character.isWhitespace = function isWhitespace(c) {
  return c <= 32 && c >= 0 || c === 127;
};
Character.toUpperCase = function toUpperCase(c) {
  return c.toUpperCase();
};
var DD = function DD2() {
  this._hi = 0;
  this._lo = 0;
  if (arguments.length === 0) {
    this.init(0);
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === "number") {
      var x2 = arguments[0];
      this.init(x2);
    } else if (arguments[0] instanceof DD2) {
      var dd = arguments[0];
      this.init(dd);
    } else if (typeof arguments[0] === "string") {
      var str = arguments[0];
      DD2.call(this, DD2.parse(str));
    }
  } else if (arguments.length === 2) {
    var hi = arguments[0];
    var lo = arguments[1];
    this.init(hi, lo);
  }
};
var staticAccessors$7 = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
DD.prototype.le = function le(y2) {
  return (this._hi < y2._hi || this._hi === y2._hi) && this._lo <= y2._lo;
};
DD.prototype.extractSignificantDigits = function extractSignificantDigits(insertDecimalPoint, magnitude2) {
  var y2 = this.abs();
  var mag = DD.magnitude(y2._hi);
  var scale4 = DD.TEN.pow(mag);
  y2 = y2.divide(scale4);
  if (y2.gt(DD.TEN)) {
    y2 = y2.divide(DD.TEN);
    mag += 1;
  } else if (y2.lt(DD.ONE)) {
    y2 = y2.multiply(DD.TEN);
    mag -= 1;
  }
  var decimalPointPos = mag + 1;
  var buf = new StringBuffer();
  var numDigits = DD.MAX_PRINT_DIGITS - 1;
  for (var i = 0; i <= numDigits; i++) {
    if (insertDecimalPoint && i === decimalPointPos) {
      buf.append(".");
    }
    var digit = Math.trunc(y2._hi);
    if (digit < 0) {
      break;
    }
    var rebiasBy10 = false;
    var digitChar = 0;
    if (digit > 9) {
      rebiasBy10 = true;
      digitChar = "9";
    } else {
      digitChar = "0" + digit;
    }
    buf.append(digitChar);
    y2 = y2.subtract(DD.valueOf(digit)).multiply(DD.TEN);
    if (rebiasBy10) {
      y2.selfAdd(DD.TEN);
    }
    var continueExtractingDigits = true;
    var remMag = DD.magnitude(y2._hi);
    if (remMag < 0 && Math.abs(remMag) >= numDigits - i) {
      continueExtractingDigits = false;
    }
    if (!continueExtractingDigits) {
      break;
    }
  }
  magnitude2[0] = mag;
  return buf.toString();
};
DD.prototype.sqr = function sqr() {
  return this.multiply(this);
};
DD.prototype.doubleValue = function doubleValue() {
  return this._hi + this._lo;
};
DD.prototype.subtract = function subtract() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    return this.add(y2.negate());
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    return this.add(-y$1);
  }
};
DD.prototype.equals = function equals3() {
  if (arguments.length === 1) {
    var y2 = arguments[0];
    return this._hi === y2._hi && this._lo === y2._lo;
  }
};
DD.prototype.isZero = function isZero() {
  return this._hi === 0 && this._lo === 0;
};
DD.prototype.selfSubtract = function selfSubtract() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    if (this.isNaN()) {
      return this;
    }
    return this.selfAdd(-y2._hi, -y2._lo);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    if (this.isNaN()) {
      return this;
    }
    return this.selfAdd(-y$1, 0);
  }
};
DD.prototype.getSpecialNumberString = function getSpecialNumberString() {
  if (this.isZero()) {
    return "0.0";
  }
  if (this.isNaN()) {
    return "NaN ";
  }
  return null;
};
DD.prototype.min = function min2(x2) {
  if (this.le(x2)) {
    return this;
  } else {
    return x2;
  }
};
DD.prototype.selfDivide = function selfDivide() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof DD) {
      var y2 = arguments[0];
      return this.selfDivide(y2._hi, y2._lo);
    } else if (typeof arguments[0] === "number") {
      var y$1 = arguments[0];
      return this.selfDivide(y$1, 0);
    }
  } else if (arguments.length === 2) {
    var yhi = arguments[0];
    var ylo = arguments[1];
    var hc = null;
    var tc = null;
    var hy = null;
    var ty = null;
    var C = null;
    var c = null;
    var U = null;
    var u = null;
    C = this._hi / yhi;
    c = DD.SPLIT * C;
    hc = c - C;
    u = DD.SPLIT * yhi;
    hc = c - hc;
    tc = C - hc;
    hy = u - yhi;
    U = C * yhi;
    hy = u - hy;
    ty = yhi - hy;
    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
    c = (this._hi - U - u + this._lo - C * ylo) / yhi;
    u = C + c;
    this._hi = u;
    this._lo = C - u + c;
    return this;
  }
};
DD.prototype.dump = function dump() {
  return "DD<" + this._hi + ", " + this._lo + ">";
};
DD.prototype.divide = function divide() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    var hc = null;
    var tc = null;
    var hy = null;
    var ty = null;
    var C = null;
    var c = null;
    var U = null;
    var u = null;
    C = this._hi / y2._hi;
    c = DD.SPLIT * C;
    hc = c - C;
    u = DD.SPLIT * y2._hi;
    hc = c - hc;
    tc = C - hc;
    hy = u - y2._hi;
    U = C * y2._hi;
    hy = u - hy;
    ty = y2._hi - hy;
    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
    c = (this._hi - U - u + this._lo - C * y2._lo) / y2._hi;
    u = C + c;
    var zhi = u;
    var zlo = C - u + c;
    return new DD(zhi, zlo);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    if (Double.isNaN(y$1)) {
      return DD.createNaN();
    }
    return DD.copy(this).selfDivide(y$1, 0);
  }
};
DD.prototype.ge = function ge(y2) {
  return (this._hi > y2._hi || this._hi === y2._hi) && this._lo >= y2._lo;
};
DD.prototype.pow = function pow(exp) {
  if (exp === 0) {
    return DD.valueOf(1);
  }
  var r = new DD(this);
  var s = DD.valueOf(1);
  var n = Math.abs(exp);
  if (n > 1) {
    while (n > 0) {
      if (n % 2 === 1) {
        s.selfMultiply(r);
      }
      n /= 2;
      if (n > 0) {
        r = r.sqr();
      }
    }
  } else {
    s = r;
  }
  if (exp < 0) {
    return s.reciprocal();
  }
  return s;
};
DD.prototype.ceil = function ceil() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  var fhi = Math.ceil(this._hi);
  var flo = 0;
  if (fhi === this._hi) {
    flo = Math.ceil(this._lo);
  }
  return new DD(fhi, flo);
};
DD.prototype.compareTo = function compareTo3(o) {
  var other = o;
  if (this._hi < other._hi) {
    return -1;
  }
  if (this._hi > other._hi) {
    return 1;
  }
  if (this._lo < other._lo) {
    return -1;
  }
  if (this._lo > other._lo) {
    return 1;
  }
  return 0;
};
DD.prototype.rint = function rint() {
  if (this.isNaN()) {
    return this;
  }
  var plus5 = this.add(0.5);
  return plus5.floor();
};
DD.prototype.setValue = function setValue() {
  if (arguments[0] instanceof DD) {
    var value = arguments[0];
    this.init(value);
    return this;
  } else if (typeof arguments[0] === "number") {
    var value$1 = arguments[0];
    this.init(value$1);
    return this;
  }
};
DD.prototype.max = function max2(x2) {
  if (this.ge(x2)) {
    return this;
  } else {
    return x2;
  }
};
DD.prototype.sqrt = function sqrt() {
  if (this.isZero()) {
    return DD.valueOf(0);
  }
  if (this.isNegative()) {
    return DD.NaN;
  }
  var x2 = 1 / Math.sqrt(this._hi);
  var ax = this._hi * x2;
  var axdd = DD.valueOf(ax);
  var diffSq = this.subtract(axdd.sqr());
  var d2 = diffSq._hi * (x2 * 0.5);
  return axdd.add(d2);
};
DD.prototype.selfAdd = function selfAdd() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof DD) {
      var y2 = arguments[0];
      return this.selfAdd(y2._hi, y2._lo);
    } else if (typeof arguments[0] === "number") {
      var y$1 = arguments[0];
      var H = null;
      var h = null;
      var S = null;
      var s = null;
      var e = null;
      var f = null;
      S = this._hi + y$1;
      e = S - this._hi;
      s = S - e;
      s = y$1 - e + (this._hi - s);
      f = s + this._lo;
      H = S + f;
      h = f + (S - H);
      this._hi = H + h;
      this._lo = h + (H - this._hi);
      return this;
    }
  } else if (arguments.length === 2) {
    var yhi = arguments[0];
    var ylo = arguments[1];
    var H$1 = null;
    var h$1 = null;
    var T = null;
    var t = null;
    var S$1 = null;
    var s$1 = null;
    var e$1 = null;
    var f$1 = null;
    S$1 = this._hi + yhi;
    T = this._lo + ylo;
    e$1 = S$1 - this._hi;
    f$1 = T - this._lo;
    s$1 = S$1 - e$1;
    t = T - f$1;
    s$1 = yhi - e$1 + (this._hi - s$1);
    t = ylo - f$1 + (this._lo - t);
    e$1 = s$1 + T;
    H$1 = S$1 + e$1;
    h$1 = e$1 + (S$1 - H$1);
    e$1 = t + h$1;
    var zhi = H$1 + e$1;
    var zlo = e$1 + (H$1 - zhi);
    this._hi = zhi;
    this._lo = zlo;
    return this;
  }
};
DD.prototype.selfMultiply = function selfMultiply() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof DD) {
      var y2 = arguments[0];
      return this.selfMultiply(y2._hi, y2._lo);
    } else if (typeof arguments[0] === "number") {
      var y$1 = arguments[0];
      return this.selfMultiply(y$1, 0);
    }
  } else if (arguments.length === 2) {
    var yhi = arguments[0];
    var ylo = arguments[1];
    var hx = null;
    var tx = null;
    var hy = null;
    var ty = null;
    var C = null;
    var c = null;
    C = DD.SPLIT * this._hi;
    hx = C - this._hi;
    c = DD.SPLIT * yhi;
    hx = C - hx;
    tx = this._hi - hx;
    hy = c - yhi;
    C = this._hi * yhi;
    hy = c - hy;
    ty = yhi - hy;
    c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
    var zhi = C + c;
    hx = C - zhi;
    var zlo = c + hx;
    this._hi = zhi;
    this._lo = zlo;
    return this;
  }
};
DD.prototype.selfSqr = function selfSqr() {
  return this.selfMultiply(this);
};
DD.prototype.floor = function floor() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  var fhi = Math.floor(this._hi);
  var flo = 0;
  if (fhi === this._hi) {
    flo = Math.floor(this._lo);
  }
  return new DD(fhi, flo);
};
DD.prototype.negate = function negate() {
  if (this.isNaN()) {
    return this;
  }
  return new DD(-this._hi, -this._lo);
};
DD.prototype.clone = function clone3() {
};
DD.prototype.multiply = function multiply() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    if (y2.isNaN()) {
      return DD.createNaN();
    }
    return DD.copy(this).selfMultiply(y2);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    if (Double.isNaN(y$1)) {
      return DD.createNaN();
    }
    return DD.copy(this).selfMultiply(y$1, 0);
  }
};
DD.prototype.isNaN = function isNaN4() {
  return Double.isNaN(this._hi);
};
DD.prototype.intValue = function intValue2() {
  return Math.trunc(this._hi);
};
DD.prototype.toString = function toString3() {
  var mag = DD.magnitude(this._hi);
  if (mag >= -3 && mag <= 20) {
    return this.toStandardNotation();
  }
  return this.toSciNotation();
};
DD.prototype.toStandardNotation = function toStandardNotation() {
  var specialStr = this.getSpecialNumberString();
  if (specialStr !== null) {
    return specialStr;
  }
  var magnitude2 = new Array(1).fill(null);
  var sigDigits = this.extractSignificantDigits(true, magnitude2);
  var decimalPointPos = magnitude2[0] + 1;
  var num = sigDigits;
  if (sigDigits.charAt(0) === ".") {
    num = "0" + sigDigits;
  } else if (decimalPointPos < 0) {
    num = "0." + DD.stringOfChar("0", -decimalPointPos) + sigDigits;
  } else if (sigDigits.indexOf(".") === -1) {
    var numZeroes = decimalPointPos - sigDigits.length;
    var zeroes = DD.stringOfChar("0", numZeroes);
    num = sigDigits + zeroes + ".0";
  }
  if (this.isNegative()) {
    return "-" + num;
  }
  return num;
};
DD.prototype.reciprocal = function reciprocal() {
  var hc = null;
  var tc = null;
  var hy = null;
  var ty = null;
  var C = null;
  var c = null;
  var U = null;
  var u = null;
  C = 1 / this._hi;
  c = DD.SPLIT * C;
  hc = c - C;
  u = DD.SPLIT * this._hi;
  hc = c - hc;
  tc = C - hc;
  hy = u - this._hi;
  U = C * this._hi;
  hy = u - hy;
  ty = this._hi - hy;
  u = hc * hy - U + hc * ty + tc * hy + tc * ty;
  c = (1 - U - u - C * this._lo) / this._hi;
  var zhi = C + c;
  var zlo = C - zhi + c;
  return new DD(zhi, zlo);
};
DD.prototype.toSciNotation = function toSciNotation() {
  if (this.isZero()) {
    return DD.SCI_NOT_ZERO;
  }
  var specialStr = this.getSpecialNumberString();
  if (specialStr !== null) {
    return specialStr;
  }
  var magnitude2 = new Array(1).fill(null);
  var digits = this.extractSignificantDigits(false, magnitude2);
  var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude2[0];
  if (digits.charAt(0) === "0") {
    throw new Error("Found leading zero: " + digits);
  }
  var trailingDigits = "";
  if (digits.length > 1) {
    trailingDigits = digits.substring(1);
  }
  var digitsWithDecimal = digits.charAt(0) + "." + trailingDigits;
  if (this.isNegative()) {
    return "-" + digitsWithDecimal + expStr;
  }
  return digitsWithDecimal + expStr;
};
DD.prototype.abs = function abs() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  if (this.isNegative()) {
    return this.negate();
  }
  return new DD(this);
};
DD.prototype.isPositive = function isPositive() {
  return (this._hi > 0 || this._hi === 0) && this._lo > 0;
};
DD.prototype.lt = function lt(y2) {
  return (this._hi < y2._hi || this._hi === y2._hi) && this._lo < y2._lo;
};
DD.prototype.add = function add2() {
  if (arguments[0] instanceof DD) {
    var y2 = arguments[0];
    return DD.copy(this).selfAdd(y2);
  } else if (typeof arguments[0] === "number") {
    var y$1 = arguments[0];
    return DD.copy(this).selfAdd(y$1);
  }
};
DD.prototype.init = function init() {
  if (arguments.length === 1) {
    if (typeof arguments[0] === "number") {
      var x2 = arguments[0];
      this._hi = x2;
      this._lo = 0;
    } else if (arguments[0] instanceof DD) {
      var dd = arguments[0];
      this._hi = dd._hi;
      this._lo = dd._lo;
    }
  } else if (arguments.length === 2) {
    var hi = arguments[0];
    var lo = arguments[1];
    this._hi = hi;
    this._lo = lo;
  }
};
DD.prototype.gt = function gt(y2) {
  return (this._hi > y2._hi || this._hi === y2._hi) && this._lo > y2._lo;
};
DD.prototype.isNegative = function isNegative() {
  return (this._hi < 0 || this._hi === 0) && this._lo < 0;
};
DD.prototype.trunc = function trunc() {
  if (this.isNaN()) {
    return DD.NaN;
  }
  if (this.isPositive()) {
    return this.floor();
  } else {
    return this.ceil();
  }
};
DD.prototype.signum = function signum() {
  if (this._hi > 0) {
    return 1;
  }
  if (this._hi < 0) {
    return -1;
  }
  if (this._lo > 0) {
    return 1;
  }
  if (this._lo < 0) {
    return -1;
  }
  return 0;
};
DD.prototype.interfaces_ = function interfaces_7() {
  return [Serializable, Comparable, Clonable];
};
DD.prototype.getClass = function getClass7() {
  return DD;
};
DD.sqr = function sqr2(x2) {
  return DD.valueOf(x2).selfMultiply(x2);
};
DD.valueOf = function valueOf() {
  if (typeof arguments[0] === "string") {
    var str = arguments[0];
    return DD.parse(str);
  } else if (typeof arguments[0] === "number") {
    var x2 = arguments[0];
    return new DD(x2);
  }
};
DD.sqrt = function sqrt2(x2) {
  return DD.valueOf(x2).sqrt();
};
DD.parse = function parse(str) {
  var i = 0;
  var strlen = str.length;
  while (Character.isWhitespace(str.charAt(i))) {
    i++;
  }
  var isNegative2 = false;
  if (i < strlen) {
    var signCh = str.charAt(i);
    if (signCh === "-" || signCh === "+") {
      i++;
      if (signCh === "-") {
        isNegative2 = true;
      }
    }
  }
  var val = new DD();
  var numDigits = 0;
  var numBeforeDec = 0;
  var exp = 0;
  while (true) {
    if (i >= strlen) {
      break;
    }
    var ch = str.charAt(i);
    i++;
    if (Character.isDigit(ch)) {
      var d = ch - "0";
      val.selfMultiply(DD.TEN);
      val.selfAdd(d);
      numDigits++;
      continue;
    }
    if (ch === ".") {
      numBeforeDec = numDigits;
      continue;
    }
    if (ch === "e" || ch === "E") {
      var expStr = str.substring(i);
      try {
        exp = Integer.parseInt(expStr);
      } catch (ex) {
        if (ex instanceof Error) {
          throw new Error("Invalid exponent " + expStr + " in string " + str);
        } else {
          throw ex;
        }
      } finally {
      }
      break;
    }
    throw new Error("Unexpected character '" + ch + "' at position " + i + " in string " + str);
  }
  var val2 = val;
  var numDecPlaces = numDigits - numBeforeDec - exp;
  if (numDecPlaces === 0) {
    val2 = val;
  } else if (numDecPlaces > 0) {
    var scale4 = DD.TEN.pow(numDecPlaces);
    val2 = val.divide(scale4);
  } else if (numDecPlaces < 0) {
    var scale$1 = DD.TEN.pow(-numDecPlaces);
    val2 = val.multiply(scale$1);
  }
  if (isNegative2) {
    return val2.negate();
  }
  return val2;
};
DD.createNaN = function createNaN() {
  return new DD(Double.NaN, Double.NaN);
};
DD.copy = function copy2(dd) {
  return new DD(dd);
};
DD.magnitude = function magnitude(x2) {
  var xAbs = Math.abs(x2);
  var xLog10 = Math.log(xAbs) / Math.log(10);
  var xMag = Math.trunc(Math.floor(xLog10));
  var xApprox = Math.pow(10, xMag);
  if (xApprox * 10 <= xAbs) {
    xMag += 1;
  }
  return xMag;
};
DD.stringOfChar = function stringOfChar(ch, len) {
  var buf = new StringBuffer();
  for (var i = 0; i < len; i++) {
    buf.append(ch);
  }
  return buf.toString();
};
staticAccessors$7.PI.get = function() {
  return new DD(3.141592653589793, 12246467991473532e-32);
};
staticAccessors$7.TWO_PI.get = function() {
  return new DD(6.283185307179586, 24492935982947064e-32);
};
staticAccessors$7.PI_2.get = function() {
  return new DD(1.5707963267948966, 6123233995736766e-32);
};
staticAccessors$7.E.get = function() {
  return new DD(2.718281828459045, 14456468917292502e-32);
};
staticAccessors$7.NaN.get = function() {
  return new DD(Double.NaN, Double.NaN);
};
staticAccessors$7.EPS.get = function() {
  return 123259516440783e-46;
};
staticAccessors$7.SPLIT.get = function() {
  return 134217729;
};
staticAccessors$7.MAX_PRINT_DIGITS.get = function() {
  return 32;
};
staticAccessors$7.TEN.get = function() {
  return DD.valueOf(10);
};
staticAccessors$7.ONE.get = function() {
  return DD.valueOf(1);
};
staticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function() {
  return "E";
};
staticAccessors$7.SCI_NOT_ZERO.get = function() {
  return "0.0E0";
};
Object.defineProperties(DD, staticAccessors$7);
var CGAlgorithmsDD = function CGAlgorithmsDD2() {
};
var staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };
CGAlgorithmsDD.prototype.interfaces_ = function interfaces_8() {
  return [];
};
CGAlgorithmsDD.prototype.getClass = function getClass8() {
  return CGAlgorithmsDD;
};
CGAlgorithmsDD.orientationIndex = function orientationIndex2(p1, p2, q) {
  var index2 = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
  if (index2 <= 1) {
    return index2;
  }
  var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
  var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
  var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
  var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
  return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
};
CGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2(x1, y1, x2, y2) {
  var det2 = x1.multiply(y2).selfSubtract(y1.multiply(x2));
  return det2.signum();
};
CGAlgorithmsDD.intersection = function intersection5(p1, p2, q1, q2) {
  var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
  var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
  var denom = denom1.subtract(denom2);
  var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
  var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
  var numx = numx1.subtract(numx2);
  var fracP = numx.selfDivide(denom).doubleValue();
  var x2 = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
  var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
  var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
  var numy = numy1.subtract(numy2);
  var fracQ = numy.selfDivide(denom).doubleValue();
  var y2 = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
  return new Coordinate(x2, y2);
};
CGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter(pa, pb, pc) {
  var detsum = null;
  var detleft = (pa.x - pc.x) * (pb.y - pc.y);
  var detright = (pa.y - pc.y) * (pb.x - pc.x);
  var det2 = detleft - detright;
  if (detleft > 0) {
    if (detright <= 0) {
      return CGAlgorithmsDD.signum(det2);
    } else {
      detsum = detleft + detright;
    }
  } else if (detleft < 0) {
    if (detright >= 0) {
      return CGAlgorithmsDD.signum(det2);
    } else {
      detsum = -detleft - detright;
    }
  } else {
    return CGAlgorithmsDD.signum(det2);
  }
  var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
  if (det2 >= errbound || -det2 >= errbound) {
    return CGAlgorithmsDD.signum(det2);
  }
  return 2;
};
CGAlgorithmsDD.signum = function signum2(x2) {
  if (x2 > 0) {
    return 1;
  }
  if (x2 < 0) {
    return -1;
  }
  return 0;
};
staticAccessors$6.DP_SAFE_EPSILON.get = function() {
  return 1e-15;
};
Object.defineProperties(CGAlgorithmsDD, staticAccessors$6);
var CoordinateSequence = function CoordinateSequence2() {
};
var staticAccessors$8 = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
staticAccessors$8.X.get = function() {
  return 0;
};
staticAccessors$8.Y.get = function() {
  return 1;
};
staticAccessors$8.Z.get = function() {
  return 2;
};
staticAccessors$8.M.get = function() {
  return 3;
};
CoordinateSequence.prototype.setOrdinate = function setOrdinate2(index2, ordinateIndex, value) {
};
CoordinateSequence.prototype.size = function size() {
};
CoordinateSequence.prototype.getOrdinate = function getOrdinate2(index2, ordinateIndex) {
};
CoordinateSequence.prototype.getCoordinate = function getCoordinate() {
};
CoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) {
};
CoordinateSequence.prototype.getDimension = function getDimension() {
};
CoordinateSequence.prototype.getX = function getX(index2) {
};
CoordinateSequence.prototype.clone = function clone4() {
};
CoordinateSequence.prototype.expandEnvelope = function expandEnvelope(env) {
};
CoordinateSequence.prototype.copy = function copy3() {
};
CoordinateSequence.prototype.getY = function getY(index2) {
};
CoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray() {
};
CoordinateSequence.prototype.interfaces_ = function interfaces_9() {
  return [Clonable];
};
CoordinateSequence.prototype.getClass = function getClass9() {
  return CoordinateSequence;
};
Object.defineProperties(CoordinateSequence, staticAccessors$8);
var Exception = function Exception2() {
};
var NotRepresentableException = function(Exception$$1) {
  function NotRepresentableException2() {
    Exception$$1.call(this, "Projective point not representable on the Cartesian plane.");
  }
  if (Exception$$1)
    NotRepresentableException2.__proto__ = Exception$$1;
  NotRepresentableException2.prototype = Object.create(Exception$$1 && Exception$$1.prototype);
  NotRepresentableException2.prototype.constructor = NotRepresentableException2;
  NotRepresentableException2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  NotRepresentableException2.prototype.getClass = function getClass169() {
    return NotRepresentableException2;
  };
  return NotRepresentableException2;
}(Exception);
var System = function System2() {
};
System.arraycopy = function arraycopy(src, srcPos, dest, destPos, len) {
  var c = 0;
  for (var i = srcPos; i < srcPos + len; i++) {
    dest[destPos + c] = src[i];
    c++;
  }
};
System.getProperty = function getProperty(name) {
  return {
    "line.separator": "\n"
  }[name];
};
var HCoordinate = function HCoordinate2() {
  this.x = null;
  this.y = null;
  this.w = null;
  if (arguments.length === 0) {
    this.x = 0;
    this.y = 0;
    this.w = 1;
  } else if (arguments.length === 1) {
    var p = arguments[0];
    this.x = p.x;
    this.y = p.y;
    this.w = 1;
  } else if (arguments.length === 2) {
    if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
      var _x = arguments[0];
      var _y = arguments[1];
      this.x = _x;
      this.y = _y;
      this.w = 1;
    } else if (arguments[0] instanceof HCoordinate2 && arguments[1] instanceof HCoordinate2) {
      var p1 = arguments[0];
      var p2 = arguments[1];
      this.x = p1.y * p2.w - p2.y * p1.w;
      this.y = p2.x * p1.w - p1.x * p2.w;
      this.w = p1.x * p2.y - p2.x * p1.y;
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
      var p1$1 = arguments[0];
      var p2$1 = arguments[1];
      this.x = p1$1.y - p2$1.y;
      this.y = p2$1.x - p1$1.x;
      this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;
    }
  } else if (arguments.length === 3) {
    var _x$1 = arguments[0];
    var _y$1 = arguments[1];
    var _w = arguments[2];
    this.x = _x$1;
    this.y = _y$1;
    this.w = _w;
  } else if (arguments.length === 4) {
    var p1$2 = arguments[0];
    var p2$2 = arguments[1];
    var q1 = arguments[2];
    var q2 = arguments[3];
    var px = p1$2.y - p2$2.y;
    var py = p2$2.x - p1$2.x;
    var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;
    var qx = q1.y - q2.y;
    var qy = q2.x - q1.x;
    var qw = q1.x * q2.y - q2.x * q1.y;
    this.x = py * qw - qy * pw;
    this.y = qx * pw - px * qw;
    this.w = px * qy - qx * py;
  }
};
HCoordinate.prototype.getY = function getY2() {
  var a = this.y / this.w;
  if (Double.isNaN(a) || Double.isInfinite(a)) {
    throw new NotRepresentableException();
  }
  return a;
};
HCoordinate.prototype.getX = function getX2() {
  var a = this.x / this.w;
  if (Double.isNaN(a) || Double.isInfinite(a)) {
    throw new NotRepresentableException();
  }
  return a;
};
HCoordinate.prototype.getCoordinate = function getCoordinate2() {
  var p = new Coordinate();
  p.x = this.getX();
  p.y = this.getY();
  return p;
};
HCoordinate.prototype.interfaces_ = function interfaces_10() {
  return [];
};
HCoordinate.prototype.getClass = function getClass10() {
  return HCoordinate;
};
HCoordinate.intersection = function intersection6(p1, p2, q1, q2) {
  var px = p1.y - p2.y;
  var py = p2.x - p1.x;
  var pw = p1.x * p2.y - p2.x * p1.y;
  var qx = q1.y - q2.y;
  var qy = q2.x - q1.x;
  var qw = q1.x * q2.y - q2.x * q1.y;
  var x2 = py * qw - qy * pw;
  var y2 = qx * pw - px * qw;
  var w = px * qy - qx * py;
  var xInt = x2 / w;
  var yInt = y2 / w;
  if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {
    throw new NotRepresentableException();
  }
  return new Coordinate(xInt, yInt);
};
var Envelope = function Envelope2() {
  this._minx = null;
  this._maxx = null;
  this._miny = null;
  this._maxy = null;
  if (arguments.length === 0) {
    this.init();
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      this.init(p.x, p.x, p.y, p.y);
    } else if (arguments[0] instanceof Envelope2) {
      var env = arguments[0];
      this.init(env);
    }
  } else if (arguments.length === 2) {
    var p1 = arguments[0];
    var p2 = arguments[1];
    this.init(p1.x, p2.x, p1.y, p2.y);
  } else if (arguments.length === 4) {
    var x1 = arguments[0];
    var x2 = arguments[1];
    var y1 = arguments[2];
    var y2 = arguments[3];
    this.init(x1, x2, y1, y2);
  }
};
var staticAccessors$9 = { serialVersionUID: { configurable: true } };
Envelope.prototype.getArea = function getArea() {
  return this.getWidth() * this.getHeight();
};
Envelope.prototype.equals = function equals4(other) {
  if (!(other instanceof Envelope)) {
    return false;
  }
  var otherEnvelope = other;
  if (this.isNull()) {
    return otherEnvelope.isNull();
  }
  return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
};
Envelope.prototype.intersection = function intersection7(env) {
  if (this.isNull() || env.isNull() || !this.intersects(env)) {
    return new Envelope();
  }
  var intMinX = this._minx > env._minx ? this._minx : env._minx;
  var intMinY = this._miny > env._miny ? this._miny : env._miny;
  var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
  var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
  return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
};
Envelope.prototype.isNull = function isNull() {
  return this._maxx < this._minx;
};
Envelope.prototype.getMaxX = function getMaxX() {
  return this._maxx;
};
Envelope.prototype.covers = function covers() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      return this.covers(p.x, p.y);
    } else if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      if (this.isNull() || other.isNull()) {
        return false;
      }
      return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    if (this.isNull()) {
      return false;
    }
    return x2 >= this._minx && x2 <= this._maxx && y2 >= this._miny && y2 <= this._maxy;
  }
};
Envelope.prototype.intersects = function intersects2() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      if (this.isNull() || other.isNull()) {
        return false;
      }
      return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
    } else if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      return this.intersects(p.x, p.y);
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    if (this.isNull()) {
      return false;
    }
    return !(x2 > this._maxx || x2 < this._minx || y2 > this._maxy || y2 < this._miny);
  }
};
Envelope.prototype.getMinY = function getMinY() {
  return this._miny;
};
Envelope.prototype.getMinX = function getMinX() {
  return this._minx;
};
Envelope.prototype.expandToInclude = function expandToInclude() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      this.expandToInclude(p.x, p.y);
    } else if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      if (other.isNull()) {
        return null;
      }
      if (this.isNull()) {
        this._minx = other.getMinX();
        this._maxx = other.getMaxX();
        this._miny = other.getMinY();
        this._maxy = other.getMaxY();
      } else {
        if (other._minx < this._minx) {
          this._minx = other._minx;
        }
        if (other._maxx > this._maxx) {
          this._maxx = other._maxx;
        }
        if (other._miny < this._miny) {
          this._miny = other._miny;
        }
        if (other._maxy > this._maxy) {
          this._maxy = other._maxy;
        }
      }
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    if (this.isNull()) {
      this._minx = x2;
      this._maxx = x2;
      this._miny = y2;
      this._maxy = y2;
    } else {
      if (x2 < this._minx) {
        this._minx = x2;
      }
      if (x2 > this._maxx) {
        this._maxx = x2;
      }
      if (y2 < this._miny) {
        this._miny = y2;
      }
      if (y2 > this._maxy) {
        this._maxy = y2;
      }
    }
  }
};
Envelope.prototype.minExtent = function minExtent() {
  if (this.isNull()) {
    return 0;
  }
  var w = this.getWidth();
  var h = this.getHeight();
  if (w < h) {
    return w;
  }
  return h;
};
Envelope.prototype.getWidth = function getWidth() {
  if (this.isNull()) {
    return 0;
  }
  return this._maxx - this._minx;
};
Envelope.prototype.compareTo = function compareTo4(o) {
  var env = o;
  if (this.isNull()) {
    if (env.isNull()) {
      return 0;
    }
    return -1;
  } else {
    if (env.isNull()) {
      return 1;
    }
  }
  if (this._minx < env._minx) {
    return -1;
  }
  if (this._minx > env._minx) {
    return 1;
  }
  if (this._miny < env._miny) {
    return -1;
  }
  if (this._miny > env._miny) {
    return 1;
  }
  if (this._maxx < env._maxx) {
    return -1;
  }
  if (this._maxx > env._maxx) {
    return 1;
  }
  if (this._maxy < env._maxy) {
    return -1;
  }
  if (this._maxy > env._maxy) {
    return 1;
  }
  return 0;
};
Envelope.prototype.translate = function translate(transX, transY) {
  if (this.isNull()) {
    return null;
  }
  this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
};
Envelope.prototype.toString = function toString4() {
  return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
};
Envelope.prototype.setToNull = function setToNull() {
  this._minx = 0;
  this._maxx = -1;
  this._miny = 0;
  this._maxy = -1;
};
Envelope.prototype.getHeight = function getHeight() {
  if (this.isNull()) {
    return 0;
  }
  return this._maxy - this._miny;
};
Envelope.prototype.maxExtent = function maxExtent() {
  if (this.isNull()) {
    return 0;
  }
  var w = this.getWidth();
  var h = this.getHeight();
  if (w > h) {
    return w;
  }
  return h;
};
Envelope.prototype.expandBy = function expandBy() {
  if (arguments.length === 1) {
    var distance11 = arguments[0];
    this.expandBy(distance11, distance11);
  } else if (arguments.length === 2) {
    var deltaX = arguments[0];
    var deltaY = arguments[1];
    if (this.isNull()) {
      return null;
    }
    this._minx -= deltaX;
    this._maxx += deltaX;
    this._miny -= deltaY;
    this._maxy += deltaY;
    if (this._minx > this._maxx || this._miny > this._maxy) {
      this.setToNull();
    }
  }
};
Envelope.prototype.contains = function contains() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Envelope) {
      var other = arguments[0];
      return this.covers(other);
    } else if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      return this.covers(p);
    }
  } else if (arguments.length === 2) {
    var x2 = arguments[0];
    var y2 = arguments[1];
    return this.covers(x2, y2);
  }
};
Envelope.prototype.centre = function centre() {
  if (this.isNull()) {
    return null;
  }
  return new Coordinate((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
};
Envelope.prototype.init = function init2() {
  if (arguments.length === 0) {
    this.setToNull();
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var p = arguments[0];
      this.init(p.x, p.x, p.y, p.y);
    } else if (arguments[0] instanceof Envelope) {
      var env = arguments[0];
      this._minx = env._minx;
      this._maxx = env._maxx;
      this._miny = env._miny;
      this._maxy = env._maxy;
    }
  } else if (arguments.length === 2) {
    var p1 = arguments[0];
    var p2 = arguments[1];
    this.init(p1.x, p2.x, p1.y, p2.y);
  } else if (arguments.length === 4) {
    var x1 = arguments[0];
    var x2 = arguments[1];
    var y1 = arguments[2];
    var y2 = arguments[3];
    if (x1 < x2) {
      this._minx = x1;
      this._maxx = x2;
    } else {
      this._minx = x2;
      this._maxx = x1;
    }
    if (y1 < y2) {
      this._miny = y1;
      this._maxy = y2;
    } else {
      this._miny = y2;
      this._maxy = y1;
    }
  }
};
Envelope.prototype.getMaxY = function getMaxY() {
  return this._maxy;
};
Envelope.prototype.distance = function distance3(env) {
  if (this.intersects(env)) {
    return 0;
  }
  var dx = 0;
  if (this._maxx < env._minx) {
    dx = env._minx - this._maxx;
  } else if (this._minx > env._maxx) {
    dx = this._minx - env._maxx;
  }
  var dy = 0;
  if (this._maxy < env._miny) {
    dy = env._miny - this._maxy;
  } else if (this._miny > env._maxy) {
    dy = this._miny - env._maxy;
  }
  if (dx === 0) {
    return dy;
  }
  if (dy === 0) {
    return dx;
  }
  return Math.sqrt(dx * dx + dy * dy);
};
Envelope.prototype.hashCode = function hashCode3() {
  var result = 17;
  result = 37 * result + Coordinate.hashCode(this._minx);
  result = 37 * result + Coordinate.hashCode(this._maxx);
  result = 37 * result + Coordinate.hashCode(this._miny);
  result = 37 * result + Coordinate.hashCode(this._maxy);
  return result;
};
Envelope.prototype.interfaces_ = function interfaces_11() {
  return [Comparable, Serializable];
};
Envelope.prototype.getClass = function getClass11() {
  return Envelope;
};
Envelope.intersects = function intersects3() {
  if (arguments.length === 3) {
    var p1 = arguments[0];
    var p2 = arguments[1];
    var q = arguments[2];
    if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
      return true;
    }
    return false;
  } else if (arguments.length === 4) {
    var p1$1 = arguments[0];
    var p2$1 = arguments[1];
    var q1 = arguments[2];
    var q2 = arguments[3];
    var minq = Math.min(q1.x, q2.x);
    var maxq = Math.max(q1.x, q2.x);
    var minp = Math.min(p1$1.x, p2$1.x);
    var maxp = Math.max(p1$1.x, p2$1.x);
    if (minp > maxq) {
      return false;
    }
    if (maxp < minq) {
      return false;
    }
    minq = Math.min(q1.y, q2.y);
    maxq = Math.max(q1.y, q2.y);
    minp = Math.min(p1$1.y, p2$1.y);
    maxp = Math.max(p1$1.y, p2$1.y);
    if (minp > maxq) {
      return false;
    }
    if (maxp < minq) {
      return false;
    }
    return true;
  }
};
staticAccessors$9.serialVersionUID.get = function() {
  return 5873921885273102e3;
};
Object.defineProperties(Envelope, staticAccessors$9);
var regExes = {
  "typeStr": /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  "emptyTypeStr": /^\s*(\w+)\s*EMPTY\s*$/,
  "spaces": /\s+/,
  "parenComma": /\)\s*,\s*\(/,
  "doubleParenComma": /\)\s*\)\s*,\s*\(\s*\(/,
  // can't use {2} here
  "trimParens": /^\s*\(?(.*?)\)?\s*$/
};
var WKTParser = function WKTParser2(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
};
WKTParser.prototype.read = function read(wkt) {
  var geometry2, type, str;
  wkt = wkt.replace(/[\n\r]/g, " ");
  var matches = regExes.typeStr.exec(wkt);
  if (wkt.search("EMPTY") !== -1) {
    matches = regExes.emptyTypeStr.exec(wkt);
    matches[2] = void 0;
  }
  if (matches) {
    type = matches[1].toLowerCase();
    str = matches[2];
    if (parse$1[type]) {
      geometry2 = parse$1[type].apply(this, [str]);
    }
  }
  if (geometry2 === void 0) {
    throw new Error("Could not parse WKT " + wkt);
  }
  return geometry2;
};
WKTParser.prototype.write = function write(geometry2) {
  return this.extractGeometry(geometry2);
};
WKTParser.prototype.extractGeometry = function extractGeometry(geometry2) {
  var type = geometry2.getGeometryType().toLowerCase();
  if (!extract$1[type]) {
    return null;
  }
  var wktType = type.toUpperCase();
  var data;
  if (geometry2.isEmpty()) {
    data = wktType + " EMPTY";
  } else {
    data = wktType + "(" + extract$1[type].apply(this, [geometry2]) + ")";
  }
  return data;
};
var extract$1 = {
  coordinate: function coordinate(coordinate$1) {
    return coordinate$1.x + " " + coordinate$1.y;
  },
  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point: function point2(point$1) {
    return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0]);
  },
  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint: function multipoint(multipoint$1) {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = multipoint$1._geometries.length; i < len; ++i) {
      array.push("(" + extract$1.point.apply(this$1, [multipoint$1._geometries[i]]) + ")");
    }
    return array.join(",");
  },
  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring: function linestring(linestring$1) {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i) {
      array.push(extract$1.coordinate.apply(this$1, [linestring$1._points._coordinates[i]]));
    }
    return array.join(",");
  },
  linearring: function linearring(linearring$1) {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i) {
      array.push(extract$1.coordinate.apply(this$1, [linearring$1._points._coordinates[i]]));
    }
    return array.join(",");
  },
  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring: function multilinestring(multilinestring$1) {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = multilinestring$1._geometries.length; i < len; ++i) {
      array.push("(" + extract$1.linestring.apply(this$1, [multilinestring$1._geometries[i]]) + ")");
    }
    return array.join(",");
  },
  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon: function polygon2(polygon$1) {
    var this$1 = this;
    var array = [];
    array.push("(" + extract$1.linestring.apply(this, [polygon$1._shell]) + ")");
    for (var i = 0, len = polygon$1._holes.length; i < len; ++i) {
      array.push("(" + extract$1.linestring.apply(this$1, [polygon$1._holes[i]]) + ")");
    }
    return array.join(",");
  },
  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon: function multipolygon(multipolygon$1) {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = multipolygon$1._geometries.length; i < len; ++i) {
      array.push("(" + extract$1.polygon.apply(this$1, [multipolygon$1._geometries[i]]) + ")");
    }
    return array.join(",");
  },
  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection: function geometrycollection(collection) {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = collection._geometries.length; i < len; ++i) {
      array.push(this$1.extractGeometry(collection._geometries[i]));
    }
    return array.join(",");
  }
};
var parse$1 = {
  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point: function point3(str) {
    if (str === void 0) {
      return this.geometryFactory.createPoint();
    }
    var coords = str.trim().split(regExes.spaces);
    return this.geometryFactory.createPoint(new Coordinate(
      Number.parseFloat(coords[0]),
      Number.parseFloat(coords[1])
    ));
  },
  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint: function multipoint2(str) {
    var this$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createMultiPoint();
    }
    var point4;
    var points2 = str.trim().split(",");
    var components = [];
    for (var i = 0, len = points2.length; i < len; ++i) {
      point4 = points2[i].replace(regExes.trimParens, "$1");
      components.push(parse$1.point.apply(this$1, [point4]));
    }
    return this.geometryFactory.createMultiPoint(components);
  },
  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring: function linestring2(str) {
    if (str === void 0) {
      return this.geometryFactory.createLineString();
    }
    var points2 = str.trim().split(",");
    var components = [];
    var coords;
    for (var i = 0, len = points2.length; i < len; ++i) {
      coords = points2[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLineString(components);
  },
  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring: function linearring2(str) {
    if (str === void 0) {
      return this.geometryFactory.createLinearRing();
    }
    var points2 = str.trim().split(",");
    var components = [];
    var coords;
    for (var i = 0, len = points2.length; i < len; ++i) {
      coords = points2[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLinearRing(components);
  },
  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring: function multilinestring2(str) {
    var this$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createMultiLineString();
    }
    var line;
    var lines = str.trim().split(regExes.parenComma);
    var components = [];
    for (var i = 0, len = lines.length; i < len; ++i) {
      line = lines[i].replace(regExes.trimParens, "$1");
      components.push(parse$1.linestring.apply(this$1, [line]));
    }
    return this.geometryFactory.createMultiLineString(components);
  },
  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon: function polygon3(str) {
    var this$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createPolygon();
    }
    var ring, linestring3, linearring3;
    var rings = str.trim().split(regExes.parenComma);
    var shell;
    var holes = [];
    for (var i = 0, len = rings.length; i < len; ++i) {
      ring = rings[i].replace(regExes.trimParens, "$1");
      linestring3 = parse$1.linestring.apply(this$1, [ring]);
      linearring3 = this$1.geometryFactory.createLinearRing(linestring3._points);
      if (i === 0) {
        shell = linearring3;
      } else {
        holes.push(linearring3);
      }
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },
  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon: function multipolygon2(str) {
    var this$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createMultiPolygon();
    }
    var polygon4;
    var polygons2 = str.trim().split(regExes.doubleParenComma);
    var components = [];
    for (var i = 0, len = polygons2.length; i < len; ++i) {
      polygon4 = polygons2[i].replace(regExes.trimParens, "$1");
      components.push(parse$1.polygon.apply(this$1, [polygon4]));
    }
    return this.geometryFactory.createMultiPolygon(components);
  },
  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection: function geometrycollection2(str) {
    var this$1 = this;
    if (str === void 0) {
      return this.geometryFactory.createGeometryCollection();
    }
    str = str.replace(/,\s*([A-Za-z])/g, "|$1");
    var wktArray = str.trim().split("|");
    var components = [];
    for (var i = 0, len = wktArray.length; i < len; ++i) {
      components.push(this$1.read(wktArray[i]));
    }
    return this.geometryFactory.createGeometryCollection(components);
  }
};
var WKTWriter = function WKTWriter2(geometryFactory) {
  this.parser = new WKTParser(geometryFactory);
};
WKTWriter.prototype.write = function write2(geometry2) {
  return this.parser.write(geometry2);
};
WKTWriter.toLineString = function toLineString(p0, p1) {
  if (arguments.length !== 2) {
    throw new Error("Not implemented");
  }
  return "LINESTRING ( " + p0.x + " " + p0.y + ", " + p1.x + " " + p1.y + " )";
};
var RuntimeException = function(Error2) {
  function RuntimeException2(message) {
    Error2.call(this, message);
    this.name = "RuntimeException";
    this.message = message;
    this.stack = new Error2().stack;
  }
  if (Error2)
    RuntimeException2.__proto__ = Error2;
  RuntimeException2.prototype = Object.create(Error2 && Error2.prototype);
  RuntimeException2.prototype.constructor = RuntimeException2;
  return RuntimeException2;
}(Error);
var AssertionFailedException = function(RuntimeException$$1) {
  function AssertionFailedException2() {
    RuntimeException$$1.call(this);
    if (arguments.length === 0) {
      RuntimeException$$1.call(this);
    } else if (arguments.length === 1) {
      var message = arguments[0];
      RuntimeException$$1.call(this, message);
    }
  }
  if (RuntimeException$$1)
    AssertionFailedException2.__proto__ = RuntimeException$$1;
  AssertionFailedException2.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
  AssertionFailedException2.prototype.constructor = AssertionFailedException2;
  AssertionFailedException2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  AssertionFailedException2.prototype.getClass = function getClass169() {
    return AssertionFailedException2;
  };
  return AssertionFailedException2;
}(RuntimeException);
var Assert = function Assert2() {
};
Assert.prototype.interfaces_ = function interfaces_12() {
  return [];
};
Assert.prototype.getClass = function getClass12() {
  return Assert;
};
Assert.shouldNeverReachHere = function shouldNeverReachHere() {
  if (arguments.length === 0) {
    Assert.shouldNeverReachHere(null);
  } else if (arguments.length === 1) {
    var message = arguments[0];
    throw new AssertionFailedException("Should never reach here" + (message !== null ? ": " + message : ""));
  }
};
Assert.isTrue = function isTrue() {
  var assertion;
  var message;
  if (arguments.length === 1) {
    assertion = arguments[0];
    Assert.isTrue(assertion, null);
  } else if (arguments.length === 2) {
    assertion = arguments[0];
    message = arguments[1];
    if (!assertion) {
      if (message === null) {
        throw new AssertionFailedException();
      } else {
        throw new AssertionFailedException(message);
      }
    }
  }
};
Assert.equals = function equals5() {
  var expectedValue;
  var actualValue;
  var message;
  if (arguments.length === 2) {
    expectedValue = arguments[0];
    actualValue = arguments[1];
    Assert.equals(expectedValue, actualValue, null);
  } else if (arguments.length === 3) {
    expectedValue = arguments[0];
    actualValue = arguments[1];
    message = arguments[2];
    if (!actualValue.equals(expectedValue)) {
      throw new AssertionFailedException("Expected " + expectedValue + " but encountered " + actualValue + (message !== null ? ": " + message : ""));
    }
  }
};
var LineIntersector = function LineIntersector2() {
  this._result = null;
  this._inputLines = Array(2).fill().map(function() {
    return Array(2);
  });
  this._intPt = new Array(2).fill(null);
  this._intLineIndex = null;
  this._isProper = null;
  this._pa = null;
  this._pb = null;
  this._precisionModel = null;
  this._intPt[0] = new Coordinate();
  this._intPt[1] = new Coordinate();
  this._pa = this._intPt[0];
  this._pb = this._intPt[1];
  this._result = 0;
};
var staticAccessors$10 = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
LineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment(segmentIndex, intIndex) {
  this.computeIntLineIndex();
  return this._intLineIndex[segmentIndex][intIndex];
};
LineIntersector.prototype.getTopologySummary = function getTopologySummary() {
  var catBuf = new StringBuffer();
  if (this.isEndPoint()) {
    catBuf.append(" endpoint");
  }
  if (this._isProper) {
    catBuf.append(" proper");
  }
  if (this.isCollinear()) {
    catBuf.append(" collinear");
  }
  return catBuf.toString();
};
LineIntersector.prototype.computeIntersection = function computeIntersection(p1, p2, p3, p4) {
  this._inputLines[0][0] = p1;
  this._inputLines[0][1] = p2;
  this._inputLines[1][0] = p3;
  this._inputLines[1][1] = p4;
  this._result = this.computeIntersect(p1, p2, p3, p4);
};
LineIntersector.prototype.getIntersectionNum = function getIntersectionNum() {
  return this._result;
};
LineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex() {
  if (arguments.length === 0) {
    if (this._intLineIndex === null) {
      this._intLineIndex = Array(2).fill().map(function() {
        return Array(2);
      });
      this.computeIntLineIndex(0);
      this.computeIntLineIndex(1);
    }
  } else if (arguments.length === 1) {
    var segmentIndex = arguments[0];
    var dist0 = this.getEdgeDistance(segmentIndex, 0);
    var dist1 = this.getEdgeDistance(segmentIndex, 1);
    if (dist0 > dist1) {
      this._intLineIndex[segmentIndex][0] = 0;
      this._intLineIndex[segmentIndex][1] = 1;
    } else {
      this._intLineIndex[segmentIndex][0] = 1;
      this._intLineIndex[segmentIndex][1] = 0;
    }
  }
};
LineIntersector.prototype.isProper = function isProper() {
  return this.hasIntersection() && this._isProper;
};
LineIntersector.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {
  this._precisionModel = precisionModel;
};
LineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection() {
  var this$1 = this;
  if (arguments.length === 0) {
    if (this.isInteriorIntersection(0)) {
      return true;
    }
    if (this.isInteriorIntersection(1)) {
      return true;
    }
    return false;
  } else if (arguments.length === 1) {
    var inputLineIndex = arguments[0];
    for (var i = 0; i < this._result; i++) {
      if (!(this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][0]) || this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][1]))) {
        return true;
      }
    }
    return false;
  }
};
LineIntersector.prototype.getIntersection = function getIntersection(intIndex) {
  return this._intPt[intIndex];
};
LineIntersector.prototype.isEndPoint = function isEndPoint() {
  return this.hasIntersection() && !this._isProper;
};
LineIntersector.prototype.hasIntersection = function hasIntersection() {
  return this._result !== LineIntersector.NO_INTERSECTION;
};
LineIntersector.prototype.getEdgeDistance = function getEdgeDistance(segmentIndex, intIndex) {
  var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
  return dist;
};
LineIntersector.prototype.isCollinear = function isCollinear() {
  return this._result === LineIntersector.COLLINEAR_INTERSECTION;
};
LineIntersector.prototype.toString = function toString5() {
  return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
};
LineIntersector.prototype.getEndpoint = function getEndpoint(segmentIndex, ptIndex) {
  return this._inputLines[segmentIndex][ptIndex];
};
LineIntersector.prototype.isIntersection = function isIntersection(pt) {
  var this$1 = this;
  for (var i = 0; i < this._result; i++) {
    if (this$1._intPt[i].equals2D(pt)) {
      return true;
    }
  }
  return false;
};
LineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment(segmentIndex, intIndex) {
  this.computeIntLineIndex();
  return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
};
LineIntersector.prototype.interfaces_ = function interfaces_13() {
  return [];
};
LineIntersector.prototype.getClass = function getClass13() {
  return LineIntersector;
};
LineIntersector.computeEdgeDistance = function computeEdgeDistance(p, p0, p1) {
  var dx = Math.abs(p1.x - p0.x);
  var dy = Math.abs(p1.y - p0.y);
  var dist = -1;
  if (p.equals(p0)) {
    dist = 0;
  } else if (p.equals(p1)) {
    if (dx > dy) {
      dist = dx;
    } else {
      dist = dy;
    }
  } else {
    var pdx = Math.abs(p.x - p0.x);
    var pdy = Math.abs(p.y - p0.y);
    if (dx > dy) {
      dist = pdx;
    } else {
      dist = pdy;
    }
    if (dist === 0 && !p.equals(p0)) {
      dist = Math.max(pdx, pdy);
    }
  }
  Assert.isTrue(!(dist === 0 && !p.equals(p0)), "Bad distance calculation");
  return dist;
};
LineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance(p, p1, p2) {
  var dx = p.x - p1.x;
  var dy = p.y - p1.y;
  var dist = Math.sqrt(dx * dx + dy * dy);
  Assert.isTrue(!(dist === 0 && !p.equals(p1)), "Invalid distance calculation");
  return dist;
};
staticAccessors$10.DONT_INTERSECT.get = function() {
  return 0;
};
staticAccessors$10.DO_INTERSECT.get = function() {
  return 1;
};
staticAccessors$10.COLLINEAR.get = function() {
  return 2;
};
staticAccessors$10.NO_INTERSECTION.get = function() {
  return 0;
};
staticAccessors$10.POINT_INTERSECTION.get = function() {
  return 1;
};
staticAccessors$10.COLLINEAR_INTERSECTION.get = function() {
  return 2;
};
Object.defineProperties(LineIntersector, staticAccessors$10);
var RobustLineIntersector = function(LineIntersector$$1) {
  function RobustLineIntersector2() {
    LineIntersector$$1.apply(this, arguments);
  }
  if (LineIntersector$$1)
    RobustLineIntersector2.__proto__ = LineIntersector$$1;
  RobustLineIntersector2.prototype = Object.create(LineIntersector$$1 && LineIntersector$$1.prototype);
  RobustLineIntersector2.prototype.constructor = RobustLineIntersector2;
  RobustLineIntersector2.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes(intPt) {
    var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
    var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
    return env0.contains(intPt) && env1.contains(intPt);
  };
  RobustLineIntersector2.prototype.computeIntersection = function computeIntersection2() {
    if (arguments.length === 3) {
      var p = arguments[0];
      var p1 = arguments[1];
      var p2 = arguments[2];
      this._isProper = false;
      if (Envelope.intersects(p1, p2, p)) {
        if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {
          this._isProper = true;
          if (p.equals(p1) || p.equals(p2)) {
            this._isProper = false;
          }
          this._result = LineIntersector$$1.POINT_INTERSECTION;
          return null;
        }
      }
      this._result = LineIntersector$$1.NO_INTERSECTION;
    } else {
      return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments);
    }
  };
  RobustLineIntersector2.prototype.normalizeToMinimum = function normalizeToMinimum(n1, n2, n3, n4, normPt) {
    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
    n1.x -= normPt.x;
    n1.y -= normPt.y;
    n2.x -= normPt.x;
    n2.y -= normPt.y;
    n3.x -= normPt.x;
    n3.y -= normPt.y;
    n4.x -= normPt.x;
    n4.y -= normPt.y;
  };
  RobustLineIntersector2.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection(p1, p2, q1, q2) {
    var intPt = null;
    try {
      intPt = HCoordinate.intersection(p1, p2, q1, q2);
    } catch (e) {
      if (e instanceof NotRepresentableException) {
        intPt = RobustLineIntersector2.nearestEndpoint(p1, p2, q1, q2);
      } else {
        throw e;
      }
    } finally {
    }
    return intPt;
  };
  RobustLineIntersector2.prototype.intersection = function intersection12(p1, p2, q1, q2) {
    var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
    if (!this.isInSegmentEnvelopes(intPt)) {
      intPt = new Coordinate(RobustLineIntersector2.nearestEndpoint(p1, p2, q1, q2));
    }
    if (this._precisionModel !== null) {
      this._precisionModel.makePrecise(intPt);
    }
    return intPt;
  };
  RobustLineIntersector2.prototype.smallestInAbsValue = function smallestInAbsValue(x1, x2, x3, x4) {
    var x5 = x1;
    var xabs = Math.abs(x5);
    if (Math.abs(x2) < xabs) {
      x5 = x2;
      xabs = Math.abs(x2);
    }
    if (Math.abs(x3) < xabs) {
      x5 = x3;
      xabs = Math.abs(x3);
    }
    if (Math.abs(x4) < xabs) {
      x5 = x4;
    }
    return x5;
  };
  RobustLineIntersector2.prototype.checkDD = function checkDD(p1, p2, q1, q2, intPt) {
    var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
    var isIn = this.isInSegmentEnvelopes(intPtDD);
    System.out.println("DD in env = " + isIn + "  --------------------- " + intPtDD);
    if (intPt.distance(intPtDD) > 1e-4) {
      System.out.println("Distance = " + intPt.distance(intPtDD));
    }
  };
  RobustLineIntersector2.prototype.intersectionWithNormalization = function intersectionWithNormalization(p1, p2, q1, q2) {
    var n1 = new Coordinate(p1);
    var n2 = new Coordinate(p2);
    var n3 = new Coordinate(q1);
    var n4 = new Coordinate(q2);
    var normPt = new Coordinate();
    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
    var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
    intPt.x += normPt.x;
    intPt.y += normPt.y;
    return intPt;
  };
  RobustLineIntersector2.prototype.computeCollinearIntersection = function computeCollinearIntersection(p1, p2, q1, q2) {
    var p1q1p2 = Envelope.intersects(p1, p2, q1);
    var p1q2p2 = Envelope.intersects(p1, p2, q2);
    var q1p1q2 = Envelope.intersects(q1, q2, p1);
    var q1p2q2 = Envelope.intersects(q1, q2, p2);
    if (p1q1p2 && p1q2p2) {
      this._intPt[0] = q1;
      this._intPt[1] = q2;
      return LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (q1p1q2 && q1p2q2) {
      this._intPt[0] = p1;
      this._intPt[1] = p2;
      return LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q1p2 && q1p1q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p1;
      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q1p2 && q1p2q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p2;
      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q2p2 && q1p1q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p1;
      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    if (p1q2p2 && q1p2q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p2;
      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;
    }
    return LineIntersector$$1.NO_INTERSECTION;
  };
  RobustLineIntersector2.prototype.normalizeToEnvCentre = function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {
    var minX0 = n00.x < n01.x ? n00.x : n01.x;
    var minY0 = n00.y < n01.y ? n00.y : n01.y;
    var maxX0 = n00.x > n01.x ? n00.x : n01.x;
    var maxY0 = n00.y > n01.y ? n00.y : n01.y;
    var minX1 = n10.x < n11.x ? n10.x : n11.x;
    var minY1 = n10.y < n11.y ? n10.y : n11.y;
    var maxX1 = n10.x > n11.x ? n10.x : n11.x;
    var maxY1 = n10.y > n11.y ? n10.y : n11.y;
    var intMinX = minX0 > minX1 ? minX0 : minX1;
    var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
    var intMinY = minY0 > minY1 ? minY0 : minY1;
    var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
    var intMidX = (intMinX + intMaxX) / 2;
    var intMidY = (intMinY + intMaxY) / 2;
    normPt.x = intMidX;
    normPt.y = intMidY;
    n00.x -= normPt.x;
    n00.y -= normPt.y;
    n01.x -= normPt.x;
    n01.y -= normPt.y;
    n10.x -= normPt.x;
    n10.y -= normPt.y;
    n11.x -= normPt.x;
    n11.y -= normPt.y;
  };
  RobustLineIntersector2.prototype.computeIntersect = function computeIntersect(p1, p2, q1, q2) {
    this._isProper = false;
    if (!Envelope.intersects(p1, p2, q1, q2)) {
      return LineIntersector$$1.NO_INTERSECTION;
    }
    var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
    var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);
    if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {
      return LineIntersector$$1.NO_INTERSECTION;
    }
    var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
    var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);
    if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {
      return LineIntersector$$1.NO_INTERSECTION;
    }
    var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
    if (collinear) {
      return this.computeCollinearIntersection(p1, p2, q1, q2);
    }
    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
      this._isProper = false;
      if (p1.equals2D(q1) || p1.equals2D(q2)) {
        this._intPt[0] = p1;
      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
        this._intPt[0] = p2;
      } else if (Pq1 === 0) {
        this._intPt[0] = new Coordinate(q1);
      } else if (Pq2 === 0) {
        this._intPt[0] = new Coordinate(q2);
      } else if (Qp1 === 0) {
        this._intPt[0] = new Coordinate(p1);
      } else if (Qp2 === 0) {
        this._intPt[0] = new Coordinate(p2);
      }
    } else {
      this._isProper = true;
      this._intPt[0] = this.intersection(p1, p2, q1, q2);
    }
    return LineIntersector$$1.POINT_INTERSECTION;
  };
  RobustLineIntersector2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  RobustLineIntersector2.prototype.getClass = function getClass169() {
    return RobustLineIntersector2;
  };
  RobustLineIntersector2.nearestEndpoint = function nearestEndpoint(p1, p2, q1, q2) {
    var nearestPt = p1;
    var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);
    var dist = CGAlgorithms.distancePointLine(p2, q1, q2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = p2;
    }
    dist = CGAlgorithms.distancePointLine(q1, p1, p2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = q1;
    }
    dist = CGAlgorithms.distancePointLine(q2, p1, p2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = q2;
    }
    return nearestPt;
  };
  return RobustLineIntersector2;
}(LineIntersector);
var RobustDeterminant = function RobustDeterminant2() {
};
RobustDeterminant.prototype.interfaces_ = function interfaces_14() {
  return [];
};
RobustDeterminant.prototype.getClass = function getClass14() {
  return RobustDeterminant;
};
RobustDeterminant.orientationIndex = function orientationIndex3(p1, p2, q) {
  var dx1 = p2.x - p1.x;
  var dy1 = p2.y - p1.y;
  var dx2 = q.x - p2.x;
  var dy2 = q.y - p2.y;
  return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
};
RobustDeterminant.signOfDet2x2 = function signOfDet2x22(x1, y1, x2, y2) {
  var sign2 = null;
  var swap2 = null;
  var k = null;
  sign2 = 1;
  if (x1 === 0 || y2 === 0) {
    if (y1 === 0 || x2 === 0) {
      return 0;
    } else if (y1 > 0) {
      if (x2 > 0) {
        return -sign2;
      } else {
        return sign2;
      }
    } else {
      if (x2 > 0) {
        return sign2;
      } else {
        return -sign2;
      }
    }
  }
  if (y1 === 0 || x2 === 0) {
    if (y2 > 0) {
      if (x1 > 0) {
        return sign2;
      } else {
        return -sign2;
      }
    } else {
      if (x1 > 0) {
        return -sign2;
      } else {
        return sign2;
      }
    }
  }
  if (y1 > 0) {
    if (y2 > 0) {
      if (y1 <= y2) {
      } else {
        sign2 = -sign2;
        swap2 = x1;
        x1 = x2;
        x2 = swap2;
        swap2 = y1;
        y1 = y2;
        y2 = swap2;
      }
    } else {
      if (y1 <= -y2) {
        sign2 = -sign2;
        x2 = -x2;
        y2 = -y2;
      } else {
        swap2 = x1;
        x1 = -x2;
        x2 = swap2;
        swap2 = y1;
        y1 = -y2;
        y2 = swap2;
      }
    }
  } else {
    if (y2 > 0) {
      if (-y1 <= y2) {
        sign2 = -sign2;
        x1 = -x1;
        y1 = -y1;
      } else {
        swap2 = -x1;
        x1 = x2;
        x2 = swap2;
        swap2 = -y1;
        y1 = y2;
        y2 = swap2;
      }
    } else {
      if (y1 >= y2) {
        x1 = -x1;
        y1 = -y1;
        x2 = -x2;
        y2 = -y2;
      } else {
        sign2 = -sign2;
        swap2 = -x1;
        x1 = -x2;
        x2 = swap2;
        swap2 = -y1;
        y1 = -y2;
        y2 = swap2;
      }
    }
  }
  if (x1 > 0) {
    if (x2 > 0) {
      if (x1 <= x2) {
      } else {
        return sign2;
      }
    } else {
      return sign2;
    }
  } else {
    if (x2 > 0) {
      return -sign2;
    } else {
      if (x1 >= x2) {
        sign2 = -sign2;
        x1 = -x1;
        x2 = -x2;
      } else {
        return -sign2;
      }
    }
  }
  while (true) {
    k = Math.floor(x2 / x1);
    x2 = x2 - k * x1;
    y2 = y2 - k * y1;
    if (y2 < 0) {
      return -sign2;
    }
    if (y2 > y1) {
      return sign2;
    }
    if (x1 > x2 + x2) {
      if (y1 < y2 + y2) {
        return sign2;
      }
    } else {
      if (y1 > y2 + y2) {
        return -sign2;
      } else {
        x2 = x1 - x2;
        y2 = y1 - y2;
        sign2 = -sign2;
      }
    }
    if (y2 === 0) {
      if (x2 === 0) {
        return 0;
      } else {
        return -sign2;
      }
    }
    if (x2 === 0) {
      return sign2;
    }
    k = Math.floor(x1 / x2);
    x1 = x1 - k * x2;
    y1 = y1 - k * y2;
    if (y1 < 0) {
      return sign2;
    }
    if (y1 > y2) {
      return -sign2;
    }
    if (x2 > x1 + x1) {
      if (y2 < y1 + y1) {
        return -sign2;
      }
    } else {
      if (y2 > y1 + y1) {
        return sign2;
      } else {
        x1 = x2 - x1;
        y1 = y2 - y1;
        sign2 = -sign2;
      }
    }
    if (y1 === 0) {
      if (x1 === 0) {
        return 0;
      } else {
        return sign2;
      }
    }
    if (x1 === 0) {
      return -sign2;
    }
  }
};
var RayCrossingCounter = function RayCrossingCounter2() {
  this._p = null;
  this._crossingCount = 0;
  this._isPointOnSegment = false;
  var p = arguments[0];
  this._p = p;
};
RayCrossingCounter.prototype.countSegment = function countSegment(p1, p2) {
  if (p1.x < this._p.x && p2.x < this._p.x) {
    return null;
  }
  if (this._p.x === p2.x && this._p.y === p2.y) {
    this._isPointOnSegment = true;
    return null;
  }
  if (p1.y === this._p.y && p2.y === this._p.y) {
    var minx = p1.x;
    var maxx = p2.x;
    if (minx > maxx) {
      minx = p2.x;
      maxx = p1.x;
    }
    if (this._p.x >= minx && this._p.x <= maxx) {
      this._isPointOnSegment = true;
    }
    return null;
  }
  if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
    var x1 = p1.x - this._p.x;
    var y1 = p1.y - this._p.y;
    var x2 = p2.x - this._p.x;
    var y2 = p2.y - this._p.y;
    var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);
    if (xIntSign === 0) {
      this._isPointOnSegment = true;
      return null;
    }
    if (y2 < y1) {
      xIntSign = -xIntSign;
    }
    if (xIntSign > 0) {
      this._crossingCount++;
    }
  }
};
RayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon() {
  return this.getLocation() !== Location.EXTERIOR;
};
RayCrossingCounter.prototype.getLocation = function getLocation() {
  if (this._isPointOnSegment) {
    return Location.BOUNDARY;
  }
  if (this._crossingCount % 2 === 1) {
    return Location.INTERIOR;
  }
  return Location.EXTERIOR;
};
RayCrossingCounter.prototype.isOnSegment = function isOnSegment() {
  return this._isPointOnSegment;
};
RayCrossingCounter.prototype.interfaces_ = function interfaces_15() {
  return [];
};
RayCrossingCounter.prototype.getClass = function getClass15() {
  return RayCrossingCounter;
};
RayCrossingCounter.locatePointInRing = function locatePointInRing() {
  if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
    var p = arguments[0];
    var ring = arguments[1];
    var counter = new RayCrossingCounter(p);
    var p1 = new Coordinate();
    var p2 = new Coordinate();
    for (var i = 1; i < ring.size(); i++) {
      ring.getCoordinate(i, p1);
      ring.getCoordinate(i - 1, p2);
      counter.countSegment(p1, p2);
      if (counter.isOnSegment()) {
        return counter.getLocation();
      }
    }
    return counter.getLocation();
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
    var p$1 = arguments[0];
    var ring$1 = arguments[1];
    var counter$1 = new RayCrossingCounter(p$1);
    for (var i$1 = 1; i$1 < ring$1.length; i$1++) {
      var p1$1 = ring$1[i$1];
      var p2$1 = ring$1[i$1 - 1];
      counter$1.countSegment(p1$1, p2$1);
      if (counter$1.isOnSegment()) {
        return counter$1.getLocation();
      }
    }
    return counter$1.getLocation();
  }
};
var CGAlgorithms = function CGAlgorithms2() {
};
var staticAccessors$3 = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
CGAlgorithms.prototype.interfaces_ = function interfaces_16() {
  return [];
};
CGAlgorithms.prototype.getClass = function getClass16() {
  return CGAlgorithms;
};
CGAlgorithms.orientationIndex = function orientationIndex4(p1, p2, q) {
  return CGAlgorithmsDD.orientationIndex(p1, p2, q);
};
CGAlgorithms.signedArea = function signedArea() {
  if (arguments[0] instanceof Array) {
    var ring = arguments[0];
    if (ring.length < 3) {
      return 0;
    }
    var sum = 0;
    var x0 = ring[0].x;
    for (var i = 1; i < ring.length - 1; i++) {
      var x2 = ring[i].x - x0;
      var y1 = ring[i + 1].y;
      var y2 = ring[i - 1].y;
      sum += x2 * (y2 - y1);
    }
    return sum / 2;
  } else if (hasInterface(arguments[0], CoordinateSequence)) {
    var ring$1 = arguments[0];
    var n = ring$1.size();
    if (n < 3) {
      return 0;
    }
    var p0 = new Coordinate();
    var p1 = new Coordinate();
    var p2 = new Coordinate();
    ring$1.getCoordinate(0, p1);
    ring$1.getCoordinate(1, p2);
    var x0$1 = p1.x;
    p2.x -= x0$1;
    var sum$1 = 0;
    for (var i$1 = 1; i$1 < n - 1; i$1++) {
      p0.y = p1.y;
      p1.x = p2.x;
      p1.y = p2.y;
      ring$1.getCoordinate(i$1 + 1, p2);
      p2.x -= x0$1;
      sum$1 += p1.x * (p0.y - p2.y);
    }
    return sum$1 / 2;
  }
};
CGAlgorithms.distanceLineLine = function distanceLineLine(A, B2, C, D) {
  if (A.equals(B2)) {
    return CGAlgorithms.distancePointLine(A, C, D);
  }
  if (C.equals(D)) {
    return CGAlgorithms.distancePointLine(D, A, B2);
  }
  var noIntersection = false;
  if (!Envelope.intersects(A, B2, C, D)) {
    noIntersection = true;
  } else {
    var denom = (B2.x - A.x) * (D.y - C.y) - (B2.y - A.y) * (D.x - C.x);
    if (denom === 0) {
      noIntersection = true;
    } else {
      var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
      var sNum = (A.y - C.y) * (B2.x - A.x) - (A.x - C.x) * (B2.y - A.y);
      var s = sNum / denom;
      var r = rNumb / denom;
      if (r < 0 || r > 1 || s < 0 || s > 1) {
        noIntersection = true;
      }
    }
  }
  if (noIntersection) {
    return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B2, C, D), CGAlgorithms.distancePointLine(C, A, B2), CGAlgorithms.distancePointLine(D, A, B2));
  }
  return 0;
};
CGAlgorithms.isPointInRing = function isPointInRing(p, ring) {
  return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;
};
CGAlgorithms.computeLength = function computeLength(pts) {
  var n = pts.size();
  if (n <= 1) {
    return 0;
  }
  var len = 0;
  var p = new Coordinate();
  pts.getCoordinate(0, p);
  var x0 = p.x;
  var y0 = p.y;
  for (var i = 1; i < n; i++) {
    pts.getCoordinate(i, p);
    var x1 = p.x;
    var y1 = p.y;
    var dx = x1 - x0;
    var dy = y1 - y0;
    len += Math.sqrt(dx * dx + dy * dy);
    x0 = x1;
    y0 = y1;
  }
  return len;
};
CGAlgorithms.isCCW = function isCCW(ring) {
  var nPts = ring.length - 1;
  if (nPts < 3) {
    throw new IllegalArgumentException("Ring has fewer than 4 points, so orientation cannot be determined");
  }
  var hiPt = ring[0];
  var hiIndex = 0;
  for (var i = 1; i <= nPts; i++) {
    var p = ring[i];
    if (p.y > hiPt.y) {
      hiPt = p;
      hiIndex = i;
    }
  }
  var iPrev = hiIndex;
  do {
    iPrev = iPrev - 1;
    if (iPrev < 0) {
      iPrev = nPts;
    }
  } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
  var iNext = hiIndex;
  do {
    iNext = (iNext + 1) % nPts;
  } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
  var prev = ring[iPrev];
  var next3 = ring[iNext];
  if (prev.equals2D(hiPt) || next3.equals2D(hiPt) || prev.equals2D(next3)) {
    return false;
  }
  var disc = CGAlgorithms.computeOrientation(prev, hiPt, next3);
  var isCCW2 = false;
  if (disc === 0) {
    isCCW2 = prev.x > next3.x;
  } else {
    isCCW2 = disc > 0;
  }
  return isCCW2;
};
CGAlgorithms.locatePointInRing = function locatePointInRing2(p, ring) {
  return RayCrossingCounter.locatePointInRing(p, ring);
};
CGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular(p, A, B2) {
  var len2 = (B2.x - A.x) * (B2.x - A.x) + (B2.y - A.y) * (B2.y - A.y);
  var s = ((A.y - p.y) * (B2.x - A.x) - (A.x - p.x) * (B2.y - A.y)) / len2;
  return Math.abs(s) * Math.sqrt(len2);
};
CGAlgorithms.computeOrientation = function computeOrientation(p1, p2, q) {
  return CGAlgorithms.orientationIndex(p1, p2, q);
};
CGAlgorithms.distancePointLine = function distancePointLine() {
  if (arguments.length === 2) {
    var p = arguments[0];
    var line = arguments[1];
    if (line.length === 0) {
      throw new IllegalArgumentException("Line array must contain at least one vertex");
    }
    var minDistance = p.distance(line[0]);
    for (var i = 0; i < line.length - 1; i++) {
      var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
      if (dist < minDistance) {
        minDistance = dist;
      }
    }
    return minDistance;
  } else if (arguments.length === 3) {
    var p$1 = arguments[0];
    var A = arguments[1];
    var B2 = arguments[2];
    if (A.x === B2.x && A.y === B2.y) {
      return p$1.distance(A);
    }
    var len2 = (B2.x - A.x) * (B2.x - A.x) + (B2.y - A.y) * (B2.y - A.y);
    var r = ((p$1.x - A.x) * (B2.x - A.x) + (p$1.y - A.y) * (B2.y - A.y)) / len2;
    if (r <= 0) {
      return p$1.distance(A);
    }
    if (r >= 1) {
      return p$1.distance(B2);
    }
    var s = ((A.y - p$1.y) * (B2.x - A.x) - (A.x - p$1.x) * (B2.y - A.y)) / len2;
    return Math.abs(s) * Math.sqrt(len2);
  }
};
CGAlgorithms.isOnLine = function isOnLine(p, pt) {
  var lineIntersector = new RobustLineIntersector();
  for (var i = 1; i < pt.length; i++) {
    var p0 = pt[i - 1];
    var p1 = pt[i];
    lineIntersector.computeIntersection(p, p0, p1);
    if (lineIntersector.hasIntersection()) {
      return true;
    }
  }
  return false;
};
staticAccessors$3.CLOCKWISE.get = function() {
  return -1;
};
staticAccessors$3.RIGHT.get = function() {
  return CGAlgorithms.CLOCKWISE;
};
staticAccessors$3.COUNTERCLOCKWISE.get = function() {
  return 1;
};
staticAccessors$3.LEFT.get = function() {
  return CGAlgorithms.COUNTERCLOCKWISE;
};
staticAccessors$3.COLLINEAR.get = function() {
  return 0;
};
staticAccessors$3.STRAIGHT.get = function() {
  return CGAlgorithms.COLLINEAR;
};
Object.defineProperties(CGAlgorithms, staticAccessors$3);
var GeometryComponentFilter = function GeometryComponentFilter2() {
};
GeometryComponentFilter.prototype.filter = function filter(geom) {
};
GeometryComponentFilter.prototype.interfaces_ = function interfaces_17() {
  return [];
};
GeometryComponentFilter.prototype.getClass = function getClass17() {
  return GeometryComponentFilter;
};
var Geometry = function Geometry2() {
  var factory = arguments[0];
  this._envelope = null;
  this._factory = null;
  this._SRID = null;
  this._userData = null;
  this._factory = factory;
  this._SRID = factory.getSRID();
};
var staticAccessors$11 = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
Geometry.prototype.isGeometryCollection = function isGeometryCollection() {
  return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;
};
Geometry.prototype.getFactory = function getFactory() {
  return this._factory;
};
Geometry.prototype.getGeometryN = function getGeometryN(n) {
  return this;
};
Geometry.prototype.getArea = function getArea2() {
  return 0;
};
Geometry.prototype.isRectangle = function isRectangle() {
  return false;
};
Geometry.prototype.equals = function equals6() {
  if (arguments[0] instanceof Geometry) {
    var g$1 = arguments[0];
    if (g$1 === null) {
      return false;
    }
    return this.equalsTopo(g$1);
  } else if (arguments[0] instanceof Object) {
    var o = arguments[0];
    if (!(o instanceof Geometry)) {
      return false;
    }
    var g = o;
    return this.equalsExact(g);
  }
};
Geometry.prototype.equalsExact = function equalsExact(other) {
  return this === other || this.equalsExact(other, 0);
};
Geometry.prototype.geometryChanged = function geometryChanged() {
  this.apply(Geometry.geometryChangedFilter);
};
Geometry.prototype.geometryChangedAction = function geometryChangedAction() {
  this._envelope = null;
};
Geometry.prototype.equalsNorm = function equalsNorm(g) {
  if (g === null) {
    return false;
  }
  return this.norm().equalsExact(g.norm());
};
Geometry.prototype.getLength = function getLength() {
  return 0;
};
Geometry.prototype.getNumGeometries = function getNumGeometries() {
  return 1;
};
Geometry.prototype.compareTo = function compareTo5() {
  if (arguments.length === 1) {
    var o = arguments[0];
    var other = o;
    if (this.getSortIndex() !== other.getSortIndex()) {
      return this.getSortIndex() - other.getSortIndex();
    }
    if (this.isEmpty() && other.isEmpty()) {
      return 0;
    }
    if (this.isEmpty()) {
      return -1;
    }
    if (other.isEmpty()) {
      return 1;
    }
    return this.compareToSameClass(o);
  } else if (arguments.length === 2) {
    var other$1 = arguments[0];
    var comp = arguments[1];
    if (this.getSortIndex() !== other$1.getSortIndex()) {
      return this.getSortIndex() - other$1.getSortIndex();
    }
    if (this.isEmpty() && other$1.isEmpty()) {
      return 0;
    }
    if (this.isEmpty()) {
      return -1;
    }
    if (other$1.isEmpty()) {
      return 1;
    }
    return this.compareToSameClass(other$1, comp);
  }
};
Geometry.prototype.getUserData = function getUserData() {
  return this._userData;
};
Geometry.prototype.getSRID = function getSRID() {
  return this._SRID;
};
Geometry.prototype.getEnvelope = function getEnvelope() {
  return this.getFactory().toGeometry(this.getEnvelopeInternal());
};
Geometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection(g) {
  if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
    throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
  }
};
Geometry.prototype.equal = function equal2(a, b, tolerance) {
  if (tolerance === 0) {
    return a.equals(b);
  }
  return a.distance(b) <= tolerance;
};
Geometry.prototype.norm = function norm() {
  var copy7 = this.copy();
  copy7.normalize();
  return copy7;
};
Geometry.prototype.getPrecisionModel = function getPrecisionModel() {
  return this._factory.getPrecisionModel();
};
Geometry.prototype.getEnvelopeInternal = function getEnvelopeInternal() {
  if (this._envelope === null) {
    this._envelope = this.computeEnvelopeInternal();
  }
  return new Envelope(this._envelope);
};
Geometry.prototype.setSRID = function setSRID(SRID) {
  this._SRID = SRID;
};
Geometry.prototype.setUserData = function setUserData(userData) {
  this._userData = userData;
};
Geometry.prototype.compare = function compare3(a, b) {
  var i = a.iterator();
  var j = b.iterator();
  while (i.hasNext() && j.hasNext()) {
    var aElement = i.next();
    var bElement = j.next();
    var comparison = aElement.compareTo(bElement);
    if (comparison !== 0) {
      return comparison;
    }
  }
  if (i.hasNext()) {
    return 1;
  }
  if (j.hasNext()) {
    return -1;
  }
  return 0;
};
Geometry.prototype.hashCode = function hashCode4() {
  return this.getEnvelopeInternal().hashCode();
};
Geometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived() {
  if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
    return true;
  }
  return false;
};
Geometry.prototype.interfaces_ = function interfaces_18() {
  return [Clonable, Comparable, Serializable];
};
Geometry.prototype.getClass = function getClass18() {
  return Geometry;
};
Geometry.hasNonEmptyElements = function hasNonEmptyElements(geometries) {
  for (var i = 0; i < geometries.length; i++) {
    if (!geometries[i].isEmpty()) {
      return true;
    }
  }
  return false;
};
Geometry.hasNullElements = function hasNullElements(array) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === null) {
      return true;
    }
  }
  return false;
};
staticAccessors$11.serialVersionUID.get = function() {
  return 8763622679187377e3;
};
staticAccessors$11.SORTINDEX_POINT.get = function() {
  return 0;
};
staticAccessors$11.SORTINDEX_MULTIPOINT.get = function() {
  return 1;
};
staticAccessors$11.SORTINDEX_LINESTRING.get = function() {
  return 2;
};
staticAccessors$11.SORTINDEX_LINEARRING.get = function() {
  return 3;
};
staticAccessors$11.SORTINDEX_MULTILINESTRING.get = function() {
  return 4;
};
staticAccessors$11.SORTINDEX_POLYGON.get = function() {
  return 5;
};
staticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function() {
  return 6;
};
staticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
  return 7;
};
staticAccessors$11.geometryChangedFilter.get = function() {
  return geometryChangedFilter;
};
Object.defineProperties(Geometry, staticAccessors$11);
var geometryChangedFilter = function geometryChangedFilter2() {
};
geometryChangedFilter.interfaces_ = function interfaces_19() {
  return [GeometryComponentFilter];
};
geometryChangedFilter.filter = function filter2(geom) {
  geom.geometryChangedAction();
};
var CoordinateFilter = function CoordinateFilter2() {
};
CoordinateFilter.prototype.filter = function filter3(coord) {
};
CoordinateFilter.prototype.interfaces_ = function interfaces_20() {
  return [];
};
CoordinateFilter.prototype.getClass = function getClass19() {
  return CoordinateFilter;
};
var BoundaryNodeRule = function BoundaryNodeRule2() {
};
var staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
BoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {
};
BoundaryNodeRule.prototype.interfaces_ = function interfaces_21() {
  return [];
};
BoundaryNodeRule.prototype.getClass = function getClass20() {
  return BoundaryNodeRule;
};
staticAccessors$12.Mod2BoundaryNodeRule.get = function() {
  return Mod2BoundaryNodeRule;
};
staticAccessors$12.EndPointBoundaryNodeRule.get = function() {
  return EndPointBoundaryNodeRule;
};
staticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function() {
  return MultiValentEndPointBoundaryNodeRule;
};
staticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function() {
  return MonoValentEndPointBoundaryNodeRule;
};
staticAccessors$12.MOD2_BOUNDARY_RULE.get = function() {
  return new Mod2BoundaryNodeRule();
};
staticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function() {
  return new EndPointBoundaryNodeRule();
};
staticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new MultiValentEndPointBoundaryNodeRule();
};
staticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new MonoValentEndPointBoundaryNodeRule();
};
staticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function() {
  return BoundaryNodeRule.MOD2_BOUNDARY_RULE;
};
Object.defineProperties(BoundaryNodeRule, staticAccessors$12);
var Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule2() {
};
Mod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary2(boundaryCount) {
  return boundaryCount % 2 === 1;
};
Mod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_22() {
  return [BoundaryNodeRule];
};
Mod2BoundaryNodeRule.prototype.getClass = function getClass21() {
  return Mod2BoundaryNodeRule;
};
var EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule2() {
};
EndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary3(boundaryCount) {
  return boundaryCount > 0;
};
EndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_23() {
  return [BoundaryNodeRule];
};
EndPointBoundaryNodeRule.prototype.getClass = function getClass22() {
  return EndPointBoundaryNodeRule;
};
var MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule2() {
};
MultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary4(boundaryCount) {
  return boundaryCount > 1;
};
MultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_24() {
  return [BoundaryNodeRule];
};
MultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass23() {
  return MultiValentEndPointBoundaryNodeRule;
};
var MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule2() {
};
MonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary5(boundaryCount) {
  return boundaryCount === 1;
};
MonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_25() {
  return [BoundaryNodeRule];
};
MonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass24() {
  return MonoValentEndPointBoundaryNodeRule;
};
var Collection = function Collection2() {
};
Collection.prototype.add = function add3() {
};
Collection.prototype.addAll = function addAll() {
};
Collection.prototype.isEmpty = function isEmpty() {
};
Collection.prototype.iterator = function iterator() {
};
Collection.prototype.size = function size2() {
};
Collection.prototype.toArray = function toArray() {
};
Collection.prototype.remove = function remove() {
};
function IndexOutOfBoundsException(message) {
  this.message = message || "";
}
IndexOutOfBoundsException.prototype = new Error();
IndexOutOfBoundsException.prototype.name = "IndexOutOfBoundsException";
var Iterator = function Iterator2() {
};
Iterator.prototype.hasNext = function hasNext() {
};
Iterator.prototype.next = function next() {
};
Iterator.prototype.remove = function remove2() {
};
var List = function(Collection$$1) {
  function List2() {
    Collection$$1.apply(this, arguments);
  }
  if (Collection$$1)
    List2.__proto__ = Collection$$1;
  List2.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
  List2.prototype.constructor = List2;
  List2.prototype.get = function get4() {
  };
  List2.prototype.set = function set() {
  };
  List2.prototype.isEmpty = function isEmpty6() {
  };
  return List2;
}(Collection);
function NoSuchElementException(message) {
  this.message = message || "";
}
NoSuchElementException.prototype = new Error();
NoSuchElementException.prototype.name = "NoSuchElementException";
var ArrayList = function(List$$1) {
  function ArrayList2() {
    List$$1.call(this);
    this.array_ = [];
    if (arguments[0] instanceof Collection) {
      this.addAll(arguments[0]);
    }
  }
  if (List$$1)
    ArrayList2.__proto__ = List$$1;
  ArrayList2.prototype = Object.create(List$$1 && List$$1.prototype);
  ArrayList2.prototype.constructor = ArrayList2;
  ArrayList2.prototype.ensureCapacity = function ensureCapacity() {
  };
  ArrayList2.prototype.interfaces_ = function interfaces_170() {
    return [List$$1, Collection];
  };
  ArrayList2.prototype.add = function add16(e) {
    if (arguments.length === 1) {
      this.array_.push(e);
    } else {
      this.array_.splice(arguments[0], arguments[1]);
    }
    return true;
  };
  ArrayList2.prototype.clear = function clear2() {
    this.array_ = [];
  };
  ArrayList2.prototype.addAll = function addAll3(c) {
    var this$1 = this;
    for (var i = c.iterator(); i.hasNext(); ) {
      this$1.add(i.next());
    }
    return true;
  };
  ArrayList2.prototype.set = function set(index2, element) {
    var oldElement = this.array_[index2];
    this.array_[index2] = element;
    return oldElement;
  };
  ArrayList2.prototype.iterator = function iterator7() {
    return new Iterator_(this);
  };
  ArrayList2.prototype.get = function get4(index2) {
    if (index2 < 0 || index2 >= this.size()) {
      throw new IndexOutOfBoundsException();
    }
    return this.array_[index2];
  };
  ArrayList2.prototype.isEmpty = function isEmpty6() {
    return this.array_.length === 0;
  };
  ArrayList2.prototype.size = function size11() {
    return this.array_.length;
  };
  ArrayList2.prototype.toArray = function toArray2() {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = this.array_.length; i < len; i++) {
      array.push(this$1.array_[i]);
    }
    return array;
  };
  ArrayList2.prototype.remove = function remove6(o) {
    var this$1 = this;
    var found = false;
    for (var i = 0, len = this.array_.length; i < len; i++) {
      if (this$1.array_[i] === o) {
        this$1.array_.splice(i, 1);
        found = true;
        break;
      }
    }
    return found;
  };
  return ArrayList2;
}(List);
var Iterator_ = function(Iterator$$1) {
  function Iterator_2(arrayList) {
    Iterator$$1.call(this);
    this.arrayList_ = arrayList;
    this.position_ = 0;
  }
  if (Iterator$$1)
    Iterator_2.__proto__ = Iterator$$1;
  Iterator_2.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
  Iterator_2.prototype.constructor = Iterator_2;
  Iterator_2.prototype.next = function next3() {
    if (this.position_ === this.arrayList_.size()) {
      throw new NoSuchElementException();
    }
    return this.arrayList_.get(this.position_++);
  };
  Iterator_2.prototype.hasNext = function hasNext3() {
    if (this.position_ < this.arrayList_.size()) {
      return true;
    } else {
      return false;
    }
  };
  Iterator_2.prototype.set = function set(element) {
    return this.arrayList_.set(this.position_ - 1, element);
  };
  Iterator_2.prototype.remove = function remove6() {
    this.arrayList_.remove(this.arrayList_.get(this.position_));
  };
  return Iterator_2;
}(Iterator);
var CoordinateList = function(ArrayList$$1) {
  function CoordinateList2() {
    ArrayList$$1.call(this);
    if (arguments.length === 0) {
    } else if (arguments.length === 1) {
      var coord = arguments[0];
      this.ensureCapacity(coord.length);
      this.add(coord, true);
    } else if (arguments.length === 2) {
      var coord$1 = arguments[0];
      var allowRepeated = arguments[1];
      this.ensureCapacity(coord$1.length);
      this.add(coord$1, allowRepeated);
    }
  }
  if (ArrayList$$1)
    CoordinateList2.__proto__ = ArrayList$$1;
  CoordinateList2.prototype = Object.create(ArrayList$$1 && ArrayList$$1.prototype);
  CoordinateList2.prototype.constructor = CoordinateList2;
  var staticAccessors2 = { coordArrayType: { configurable: true } };
  staticAccessors2.coordArrayType.get = function() {
    return new Array(0).fill(null);
  };
  CoordinateList2.prototype.getCoordinate = function getCoordinate18(i) {
    return this.get(i);
  };
  CoordinateList2.prototype.addAll = function addAll3() {
    var this$1 = this;
    if (arguments.length === 2) {
      var coll = arguments[0];
      var allowRepeated = arguments[1];
      var isChanged = false;
      for (var i = coll.iterator(); i.hasNext(); ) {
        this$1.add(i.next(), allowRepeated);
        isChanged = true;
      }
      return isChanged;
    } else {
      return ArrayList$$1.prototype.addAll.apply(this, arguments);
    }
  };
  CoordinateList2.prototype.clone = function clone6() {
    var this$1 = this;
    var clone7 = ArrayList$$1.prototype.clone.call(this);
    for (var i = 0; i < this.size(); i++) {
      clone7.add(i, this$1.get(i).copy());
    }
    return clone7;
  };
  CoordinateList2.prototype.toCoordinateArray = function toCoordinateArray4() {
    return this.toArray(CoordinateList2.coordArrayType);
  };
  CoordinateList2.prototype.add = function add16() {
    var this$1 = this;
    if (arguments.length === 1) {
      var coord = arguments[0];
      ArrayList$$1.prototype.add.call(this, coord);
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && typeof arguments[1] === "boolean") {
        var coord$1 = arguments[0];
        var allowRepeated = arguments[1];
        this.add(coord$1, allowRepeated, true);
        return true;
      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === "boolean") {
        var coord$2 = arguments[0];
        var allowRepeated$1 = arguments[1];
        if (!allowRepeated$1) {
          if (this.size() >= 1) {
            var last = this.get(this.size() - 1);
            if (last.equals2D(coord$2)) {
              return null;
            }
          }
        }
        ArrayList$$1.prototype.add.call(this, coord$2);
      } else if (arguments[0] instanceof Object && typeof arguments[1] === "boolean") {
        var obj = arguments[0];
        var allowRepeated$2 = arguments[1];
        this.add(obj, allowRepeated$2);
        return true;
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[2] === "boolean" && (arguments[0] instanceof Array && typeof arguments[1] === "boolean")) {
        var coord$3 = arguments[0];
        var allowRepeated$3 = arguments[1];
        var direction = arguments[2];
        if (direction) {
          for (var i$1 = 0; i$1 < coord$3.length; i$1++) {
            this$1.add(coord$3[i$1], allowRepeated$3);
          }
        } else {
          for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {
            this$1.add(coord$3[i$2], allowRepeated$3);
          }
        }
        return true;
      } else if (typeof arguments[2] === "boolean" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {
        var i$3 = arguments[0];
        var coord$4 = arguments[1];
        var allowRepeated$4 = arguments[2];
        if (!allowRepeated$4) {
          var size11 = this.size();
          if (size11 > 0) {
            if (i$3 > 0) {
              var prev = this.get(i$3 - 1);
              if (prev.equals2D(coord$4)) {
                return null;
              }
            }
            if (i$3 < size11) {
              var next3 = this.get(i$3);
              if (next3.equals2D(coord$4)) {
                return null;
              }
            }
          }
        }
        ArrayList$$1.prototype.add.call(this, i$3, coord$4);
      }
    } else if (arguments.length === 4) {
      var coord$5 = arguments[0];
      var allowRepeated$5 = arguments[1];
      var start = arguments[2];
      var end = arguments[3];
      var inc = 1;
      if (start > end) {
        inc = -1;
      }
      for (var i = start; i !== end; i += inc) {
        this$1.add(coord$5[i], allowRepeated$5);
      }
      return true;
    }
  };
  CoordinateList2.prototype.closeRing = function closeRing3() {
    if (this.size() > 0) {
      this.add(new Coordinate(this.get(0)), false);
    }
  };
  CoordinateList2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  CoordinateList2.prototype.getClass = function getClass169() {
    return CoordinateList2;
  };
  Object.defineProperties(CoordinateList2, staticAccessors2);
  return CoordinateList2;
}(ArrayList);
var CoordinateArrays = function CoordinateArrays2() {
};
var staticAccessors$13 = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
staticAccessors$13.ForwardComparator.get = function() {
  return ForwardComparator;
};
staticAccessors$13.BidirectionalComparator.get = function() {
  return BidirectionalComparator;
};
staticAccessors$13.coordArrayType.get = function() {
  return new Array(0).fill(null);
};
CoordinateArrays.prototype.interfaces_ = function interfaces_26() {
  return [];
};
CoordinateArrays.prototype.getClass = function getClass25() {
  return CoordinateArrays;
};
CoordinateArrays.isRing = function isRing(pts) {
  if (pts.length < 4) {
    return false;
  }
  if (!pts[0].equals2D(pts[pts.length - 1])) {
    return false;
  }
  return true;
};
CoordinateArrays.ptNotInList = function ptNotInList(testPts, pts) {
  for (var i = 0; i < testPts.length; i++) {
    var testPt = testPts[i];
    if (CoordinateArrays.indexOf(testPt, pts) < 0) {
      return testPt;
    }
  }
  return null;
};
CoordinateArrays.scroll = function scroll(coordinates, firstCoordinate) {
  var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
  if (i < 0) {
    return null;
  }
  var newCoordinates = new Array(coordinates.length).fill(null);
  System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
  System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
  System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
};
CoordinateArrays.equals = function equals7() {
  if (arguments.length === 2) {
    var coord1 = arguments[0];
    var coord2 = arguments[1];
    if (coord1 === coord2) {
      return true;
    }
    if (coord1 === null || coord2 === null) {
      return false;
    }
    if (coord1.length !== coord2.length) {
      return false;
    }
    for (var i = 0; i < coord1.length; i++) {
      if (!coord1[i].equals(coord2[i])) {
        return false;
      }
    }
    return true;
  } else if (arguments.length === 3) {
    var coord1$1 = arguments[0];
    var coord2$1 = arguments[1];
    var coordinateComparator = arguments[2];
    if (coord1$1 === coord2$1) {
      return true;
    }
    if (coord1$1 === null || coord2$1 === null) {
      return false;
    }
    if (coord1$1.length !== coord2$1.length) {
      return false;
    }
    for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {
      if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) {
        return false;
      }
    }
    return true;
  }
};
CoordinateArrays.intersection = function intersection8(coordinates, env) {
  var coordList = new CoordinateList();
  for (var i = 0; i < coordinates.length; i++) {
    if (env.intersects(coordinates[i])) {
      coordList.add(coordinates[i], true);
    }
  }
  return coordList.toCoordinateArray();
};
CoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints(coord) {
  for (var i = 1; i < coord.length; i++) {
    if (coord[i - 1].equals(coord[i])) {
      return true;
    }
  }
  return false;
};
CoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints(coord) {
  if (!CoordinateArrays.hasRepeatedPoints(coord)) {
    return coord;
  }
  var coordList = new CoordinateList(coord, false);
  return coordList.toCoordinateArray();
};
CoordinateArrays.reverse = function reverse2(coord) {
  var last = coord.length - 1;
  var mid = Math.trunc(last / 2);
  for (var i = 0; i <= mid; i++) {
    var tmp = coord[i];
    coord[i] = coord[last - i];
    coord[last - i] = tmp;
  }
};
CoordinateArrays.removeNull = function removeNull(coord) {
  var nonNull = 0;
  for (var i = 0; i < coord.length; i++) {
    if (coord[i] !== null) {
      nonNull++;
    }
  }
  var newCoord = new Array(nonNull).fill(null);
  if (nonNull === 0) {
    return newCoord;
  }
  var j = 0;
  for (var i$1 = 0; i$1 < coord.length; i$1++) {
    if (coord[i$1] !== null) {
      newCoord[j++] = coord[i$1];
    }
  }
  return newCoord;
};
CoordinateArrays.copyDeep = function copyDeep() {
  if (arguments.length === 1) {
    var coordinates = arguments[0];
    var copy7 = new Array(coordinates.length).fill(null);
    for (var i = 0; i < coordinates.length; i++) {
      copy7[i] = new Coordinate(coordinates[i]);
    }
    return copy7;
  } else if (arguments.length === 5) {
    var src = arguments[0];
    var srcStart = arguments[1];
    var dest = arguments[2];
    var destStart = arguments[3];
    var length4 = arguments[4];
    for (var i$1 = 0; i$1 < length4; i$1++) {
      dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);
    }
  }
};
CoordinateArrays.isEqualReversed = function isEqualReversed(pts1, pts2) {
  for (var i = 0; i < pts1.length; i++) {
    var p1 = pts1[i];
    var p2 = pts2[pts1.length - i - 1];
    if (p1.compareTo(p2) !== 0) {
      return false;
    }
  }
  return true;
};
CoordinateArrays.envelope = function envelope2(coordinates) {
  var env = new Envelope();
  for (var i = 0; i < coordinates.length; i++) {
    env.expandToInclude(coordinates[i]);
  }
  return env;
};
CoordinateArrays.toCoordinateArray = function toCoordinateArray2(coordList) {
  return coordList.toArray(CoordinateArrays.coordArrayType);
};
CoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing(n, c) {
  return c.length >= n ? c : [];
};
CoordinateArrays.indexOf = function indexOf(coordinate2, coordinates) {
  for (var i = 0; i < coordinates.length; i++) {
    if (coordinate2.equals(coordinates[i])) {
      return i;
    }
  }
  return -1;
};
CoordinateArrays.increasingDirection = function increasingDirection(pts) {
  for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
    var j = pts.length - 1 - i;
    var comp = pts[i].compareTo(pts[j]);
    if (comp !== 0) {
      return comp;
    }
  }
  return 1;
};
CoordinateArrays.compare = function compare4(pts1, pts2) {
  var i = 0;
  while (i < pts1.length && i < pts2.length) {
    var compare10 = pts1[i].compareTo(pts2[i]);
    if (compare10 !== 0) {
      return compare10;
    }
    i++;
  }
  if (i < pts2.length) {
    return -1;
  }
  if (i < pts1.length) {
    return 1;
  }
  return 0;
};
CoordinateArrays.minCoordinate = function minCoordinate(coordinates) {
  var minCoord = null;
  for (var i = 0; i < coordinates.length; i++) {
    if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
      minCoord = coordinates[i];
    }
  }
  return minCoord;
};
CoordinateArrays.extract = function extract(pts, start, end) {
  start = MathUtil.clamp(start, 0, pts.length);
  end = MathUtil.clamp(end, -1, pts.length);
  var npts = end - start + 1;
  if (end < 0) {
    npts = 0;
  }
  if (start >= pts.length) {
    npts = 0;
  }
  if (end < start) {
    npts = 0;
  }
  var extractPts = new Array(npts).fill(null);
  if (npts === 0) {
    return extractPts;
  }
  var iPts = 0;
  for (var i = start; i <= end; i++) {
    extractPts[iPts++] = pts[i];
  }
  return extractPts;
};
Object.defineProperties(CoordinateArrays, staticAccessors$13);
var ForwardComparator = function ForwardComparator2() {
};
ForwardComparator.prototype.compare = function compare5(o1, o2) {
  var pts1 = o1;
  var pts2 = o2;
  return CoordinateArrays.compare(pts1, pts2);
};
ForwardComparator.prototype.interfaces_ = function interfaces_27() {
  return [Comparator];
};
ForwardComparator.prototype.getClass = function getClass26() {
  return ForwardComparator;
};
var BidirectionalComparator = function BidirectionalComparator2() {
};
BidirectionalComparator.prototype.compare = function compare6(o1, o2) {
  var pts1 = o1;
  var pts2 = o2;
  if (pts1.length < pts2.length) {
    return -1;
  }
  if (pts1.length > pts2.length) {
    return 1;
  }
  if (pts1.length === 0) {
    return 0;
  }
  var forwardComp = CoordinateArrays.compare(pts1, pts2);
  var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
  if (isEqualRev) {
    return 0;
  }
  return forwardComp;
};
BidirectionalComparator.prototype.OLDcompare = function OLDcompare(o1, o2) {
  var pts1 = o1;
  var pts2 = o2;
  if (pts1.length < pts2.length) {
    return -1;
  }
  if (pts1.length > pts2.length) {
    return 1;
  }
  if (pts1.length === 0) {
    return 0;
  }
  var dir1 = CoordinateArrays.increasingDirection(pts1);
  var dir2 = CoordinateArrays.increasingDirection(pts2);
  var i1 = dir1 > 0 ? 0 : pts1.length - 1;
  var i2 = dir2 > 0 ? 0 : pts1.length - 1;
  for (var i = 0; i < pts1.length; i++) {
    var comparePt = pts1[i1].compareTo(pts2[i2]);
    if (comparePt !== 0) {
      return comparePt;
    }
    i1 += dir1;
    i2 += dir2;
  }
  return 0;
};
BidirectionalComparator.prototype.interfaces_ = function interfaces_28() {
  return [Comparator];
};
BidirectionalComparator.prototype.getClass = function getClass27() {
  return BidirectionalComparator;
};
var Map$1 = function Map2() {
};
Map$1.prototype.get = function get() {
};
Map$1.prototype.put = function put() {
};
Map$1.prototype.size = function size3() {
};
Map$1.prototype.values = function values() {
};
Map$1.prototype.entrySet = function entrySet() {
};
var SortedMap = function(Map3) {
  function SortedMap2() {
    Map3.apply(this, arguments);
  }
  if (Map3)
    SortedMap2.__proto__ = Map3;
  SortedMap2.prototype = Object.create(Map3 && Map3.prototype);
  SortedMap2.prototype.constructor = SortedMap2;
  return SortedMap2;
}(Map$1);
function OperationNotSupported(message) {
  this.message = message || "";
}
OperationNotSupported.prototype = new Error();
OperationNotSupported.prototype.name = "OperationNotSupported";
function Set2() {
}
Set2.prototype = new Collection();
Set2.prototype.contains = function() {
};
var HashSet = function(Set$$1) {
  function HashSet2() {
    Set$$1.call(this);
    this.array_ = [];
    if (arguments[0] instanceof Collection) {
      this.addAll(arguments[0]);
    }
  }
  if (Set$$1)
    HashSet2.__proto__ = Set$$1;
  HashSet2.prototype = Object.create(Set$$1 && Set$$1.prototype);
  HashSet2.prototype.constructor = HashSet2;
  HashSet2.prototype.contains = function contains2(o) {
    var this$1 = this;
    for (var i = 0, len = this.array_.length; i < len; i++) {
      var e = this$1.array_[i];
      if (e === o) {
        return true;
      }
    }
    return false;
  };
  HashSet2.prototype.add = function add16(o) {
    if (this.contains(o)) {
      return false;
    }
    this.array_.push(o);
    return true;
  };
  HashSet2.prototype.addAll = function addAll3(c) {
    var this$1 = this;
    for (var i = c.iterator(); i.hasNext(); ) {
      this$1.add(i.next());
    }
    return true;
  };
  HashSet2.prototype.remove = function remove6(o) {
    throw new Error();
  };
  HashSet2.prototype.size = function size11() {
    return this.array_.length;
  };
  HashSet2.prototype.isEmpty = function isEmpty6() {
    return this.array_.length === 0;
  };
  HashSet2.prototype.toArray = function toArray2() {
    var this$1 = this;
    var array = [];
    for (var i = 0, len = this.array_.length; i < len; i++) {
      array.push(this$1.array_[i]);
    }
    return array;
  };
  HashSet2.prototype.iterator = function iterator7() {
    return new Iterator_$1(this);
  };
  return HashSet2;
}(Set2);
var Iterator_$1 = function(Iterator$$1) {
  function Iterator_2(hashSet) {
    Iterator$$1.call(this);
    this.hashSet_ = hashSet;
    this.position_ = 0;
  }
  if (Iterator$$1)
    Iterator_2.__proto__ = Iterator$$1;
  Iterator_2.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
  Iterator_2.prototype.constructor = Iterator_2;
  Iterator_2.prototype.next = function next3() {
    if (this.position_ === this.hashSet_.size()) {
      throw new NoSuchElementException();
    }
    return this.hashSet_.array_[this.position_++];
  };
  Iterator_2.prototype.hasNext = function hasNext3() {
    if (this.position_ < this.hashSet_.size()) {
      return true;
    } else {
      return false;
    }
  };
  Iterator_2.prototype.remove = function remove6() {
    throw new OperationNotSupported();
  };
  return Iterator_2;
}(Iterator);
var BLACK = 0;
var RED = 1;
function colorOf(p) {
  return p === null ? BLACK : p.color;
}
function parentOf(p) {
  return p === null ? null : p.parent;
}
function setColor(p, c) {
  if (p !== null) {
    p.color = c;
  }
}
function leftOf(p) {
  return p === null ? null : p.left;
}
function rightOf(p) {
  return p === null ? null : p.right;
}
function TreeMap() {
  this.root_ = null;
  this.size_ = 0;
}
TreeMap.prototype = new SortedMap();
TreeMap.prototype.get = function(key) {
  var p = this.root_;
  while (p !== null) {
    var cmp3 = key["compareTo"](p.key);
    if (cmp3 < 0) {
      p = p.left;
    } else if (cmp3 > 0) {
      p = p.right;
    } else {
      return p.value;
    }
  }
  return null;
};
TreeMap.prototype.put = function(key, value) {
  if (this.root_ === null) {
    this.root_ = {
      key,
      value,
      left: null,
      right: null,
      parent: null,
      color: BLACK,
      getValue: function getValue() {
        return this.value;
      },
      getKey: function getKey() {
        return this.key;
      }
    };
    this.size_ = 1;
    return null;
  }
  var t = this.root_;
  var parent;
  var cmp3;
  do {
    parent = t;
    cmp3 = key["compareTo"](t.key);
    if (cmp3 < 0) {
      t = t.left;
    } else if (cmp3 > 0) {
      t = t.right;
    } else {
      var oldValue = t.value;
      t.value = value;
      return oldValue;
    }
  } while (t !== null);
  var e = {
    key,
    left: null,
    right: null,
    value,
    parent,
    color: BLACK,
    getValue: function getValue() {
      return this.value;
    },
    getKey: function getKey() {
      return this.key;
    }
  };
  if (cmp3 < 0) {
    parent.left = e;
  } else {
    parent.right = e;
  }
  this.fixAfterInsertion(e);
  this.size_++;
  return null;
};
TreeMap.prototype.fixAfterInsertion = function(x2) {
  var this$1 = this;
  x2.color = RED;
  while (x2 != null && x2 !== this.root_ && x2.parent.color === RED) {
    if (parentOf(x2) === leftOf(parentOf(parentOf(x2)))) {
      var y2 = rightOf(parentOf(parentOf(x2)));
      if (colorOf(y2) === RED) {
        setColor(parentOf(x2), BLACK);
        setColor(y2, BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        x2 = parentOf(parentOf(x2));
      } else {
        if (x2 === rightOf(parentOf(x2))) {
          x2 = parentOf(x2);
          this$1.rotateLeft(x2);
        }
        setColor(parentOf(x2), BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        this$1.rotateRight(parentOf(parentOf(x2)));
      }
    } else {
      var y$1 = leftOf(parentOf(parentOf(x2)));
      if (colorOf(y$1) === RED) {
        setColor(parentOf(x2), BLACK);
        setColor(y$1, BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        x2 = parentOf(parentOf(x2));
      } else {
        if (x2 === leftOf(parentOf(x2))) {
          x2 = parentOf(x2);
          this$1.rotateRight(x2);
        }
        setColor(parentOf(x2), BLACK);
        setColor(parentOf(parentOf(x2)), RED);
        this$1.rotateLeft(parentOf(parentOf(x2)));
      }
    }
  }
  this.root_.color = BLACK;
};
TreeMap.prototype.values = function() {
  var arrayList = new ArrayList();
  var p = this.getFirstEntry();
  if (p !== null) {
    arrayList.add(p.value);
    while ((p = TreeMap.successor(p)) !== null) {
      arrayList.add(p.value);
    }
  }
  return arrayList;
};
TreeMap.prototype.entrySet = function() {
  var hashSet = new HashSet();
  var p = this.getFirstEntry();
  if (p !== null) {
    hashSet.add(p);
    while ((p = TreeMap.successor(p)) !== null) {
      hashSet.add(p);
    }
  }
  return hashSet;
};
TreeMap.prototype.rotateLeft = function(p) {
  if (p != null) {
    var r = p.right;
    p.right = r.left;
    if (r.left != null) {
      r.left.parent = p;
    }
    r.parent = p.parent;
    if (p.parent === null) {
      this.root_ = r;
    } else if (p.parent.left === p) {
      p.parent.left = r;
    } else {
      p.parent.right = r;
    }
    r.left = p;
    p.parent = r;
  }
};
TreeMap.prototype.rotateRight = function(p) {
  if (p != null) {
    var l = p.left;
    p.left = l.right;
    if (l.right != null) {
      l.right.parent = p;
    }
    l.parent = p.parent;
    if (p.parent === null) {
      this.root_ = l;
    } else if (p.parent.right === p) {
      p.parent.right = l;
    } else {
      p.parent.left = l;
    }
    l.right = p;
    p.parent = l;
  }
};
TreeMap.prototype.getFirstEntry = function() {
  var p = this.root_;
  if (p != null) {
    while (p.left != null) {
      p = p.left;
    }
  }
  return p;
};
TreeMap.successor = function(t) {
  if (t === null) {
    return null;
  } else if (t.right !== null) {
    var p = t.right;
    while (p.left !== null) {
      p = p.left;
    }
    return p;
  } else {
    var p$1 = t.parent;
    var ch = t;
    while (p$1 !== null && ch === p$1.right) {
      ch = p$1;
      p$1 = p$1.parent;
    }
    return p$1;
  }
};
TreeMap.prototype.size = function() {
  return this.size_;
};
var Lineal = function Lineal2() {
};
Lineal.prototype.interfaces_ = function interfaces_29() {
  return [];
};
Lineal.prototype.getClass = function getClass28() {
  return Lineal;
};
function SortedSet() {
}
SortedSet.prototype = new Set2();
function TreeSet() {
  this.array_ = [];
  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}
TreeSet.prototype = new SortedSet();
TreeSet.prototype.contains = function(o) {
  var this$1 = this;
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this$1.array_[i];
    if (e["compareTo"](o) === 0) {
      return true;
    }
  }
  return false;
};
TreeSet.prototype.add = function(o) {
  var this$1 = this;
  if (this.contains(o)) {
    return false;
  }
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this$1.array_[i];
    if (e["compareTo"](o) === 1) {
      this$1.array_.splice(i, 0, o);
      return true;
    }
  }
  this.array_.push(o);
  return true;
};
TreeSet.prototype.addAll = function(c) {
  var this$1 = this;
  for (var i = c.iterator(); i.hasNext(); ) {
    this$1.add(i.next());
  }
  return true;
};
TreeSet.prototype.remove = function(e) {
  throw new OperationNotSupported();
};
TreeSet.prototype.size = function() {
  return this.array_.length;
};
TreeSet.prototype.isEmpty = function() {
  return this.array_.length === 0;
};
TreeSet.prototype.toArray = function() {
  var this$1 = this;
  var array = [];
  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this$1.array_[i]);
  }
  return array;
};
TreeSet.prototype.iterator = function() {
  return new Iterator_$2(this);
};
var Iterator_$2 = function(treeSet) {
  this.treeSet_ = treeSet;
  this.position_ = 0;
};
Iterator_$2.prototype.next = function() {
  if (this.position_ === this.treeSet_.size()) {
    throw new NoSuchElementException();
  }
  return this.treeSet_.array_[this.position_++];
};
Iterator_$2.prototype.hasNext = function() {
  if (this.position_ < this.treeSet_.size()) {
    return true;
  } else {
    return false;
  }
};
Iterator_$2.prototype.remove = function() {
  throw new OperationNotSupported();
};
var Arrays = function Arrays2() {
};
Arrays.sort = function sort2() {
  var a = arguments[0];
  var i;
  var t;
  var comparator;
  var compare10;
  if (arguments.length === 1) {
    compare10 = function(a2, b) {
      return a2.compareTo(b);
    };
    a.sort(compare10);
  } else if (arguments.length === 2) {
    comparator = arguments[1];
    compare10 = function(a2, b) {
      return comparator["compare"](a2, b);
    };
    a.sort(compare10);
  } else if (arguments.length === 3) {
    t = a.slice(arguments[1], arguments[2]);
    t.sort();
    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
  } else if (arguments.length === 4) {
    t = a.slice(arguments[1], arguments[2]);
    comparator = arguments[3];
    compare10 = function(a2, b) {
      return comparator["compare"](a2, b);
    };
    t.sort(compare10);
    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
  }
};
Arrays.asList = function asList(array) {
  var arrayList = new ArrayList();
  for (var i = 0, len = array.length; i < len; i++) {
    arrayList.add(array[i]);
  }
  return arrayList;
};
var Dimension = function Dimension2() {
};
var staticAccessors$14 = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
staticAccessors$14.P.get = function() {
  return 0;
};
staticAccessors$14.L.get = function() {
  return 1;
};
staticAccessors$14.A.get = function() {
  return 2;
};
staticAccessors$14.FALSE.get = function() {
  return -1;
};
staticAccessors$14.TRUE.get = function() {
  return -2;
};
staticAccessors$14.DONTCARE.get = function() {
  return -3;
};
staticAccessors$14.SYM_FALSE.get = function() {
  return "F";
};
staticAccessors$14.SYM_TRUE.get = function() {
  return "T";
};
staticAccessors$14.SYM_DONTCARE.get = function() {
  return "*";
};
staticAccessors$14.SYM_P.get = function() {
  return "0";
};
staticAccessors$14.SYM_L.get = function() {
  return "1";
};
staticAccessors$14.SYM_A.get = function() {
  return "2";
};
Dimension.prototype.interfaces_ = function interfaces_30() {
  return [];
};
Dimension.prototype.getClass = function getClass29() {
  return Dimension;
};
Dimension.toDimensionSymbol = function toDimensionSymbol(dimensionValue) {
  switch (dimensionValue) {
    case Dimension.FALSE:
      return Dimension.SYM_FALSE;
    case Dimension.TRUE:
      return Dimension.SYM_TRUE;
    case Dimension.DONTCARE:
      return Dimension.SYM_DONTCARE;
    case Dimension.P:
      return Dimension.SYM_P;
    case Dimension.L:
      return Dimension.SYM_L;
    case Dimension.A:
      return Dimension.SYM_A;
    default:
  }
  throw new IllegalArgumentException("Unknown dimension value: " + dimensionValue);
};
Dimension.toDimensionValue = function toDimensionValue(dimensionSymbol) {
  switch (Character.toUpperCase(dimensionSymbol)) {
    case Dimension.SYM_FALSE:
      return Dimension.FALSE;
    case Dimension.SYM_TRUE:
      return Dimension.TRUE;
    case Dimension.SYM_DONTCARE:
      return Dimension.DONTCARE;
    case Dimension.SYM_P:
      return Dimension.P;
    case Dimension.SYM_L:
      return Dimension.L;
    case Dimension.SYM_A:
      return Dimension.A;
    default:
  }
  throw new IllegalArgumentException("Unknown dimension symbol: " + dimensionSymbol);
};
Object.defineProperties(Dimension, staticAccessors$14);
var GeometryFilter = function GeometryFilter2() {
};
GeometryFilter.prototype.filter = function filter4(geom) {
};
GeometryFilter.prototype.interfaces_ = function interfaces_31() {
  return [];
};
GeometryFilter.prototype.getClass = function getClass30() {
  return GeometryFilter;
};
var CoordinateSequenceFilter = function CoordinateSequenceFilter2() {
};
CoordinateSequenceFilter.prototype.filter = function filter5(seq, i) {
};
CoordinateSequenceFilter.prototype.isDone = function isDone() {
};
CoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged() {
};
CoordinateSequenceFilter.prototype.interfaces_ = function interfaces_32() {
  return [];
};
CoordinateSequenceFilter.prototype.getClass = function getClass31() {
  return CoordinateSequenceFilter;
};
var GeometryCollection = function(Geometry$$1) {
  function GeometryCollection2(geometries, factory) {
    Geometry$$1.call(this, factory);
    this._geometries = geometries || [];
    if (Geometry$$1.hasNullElements(this._geometries)) {
      throw new IllegalArgumentException("geometries must not contain null elements");
    }
  }
  if (Geometry$$1)
    GeometryCollection2.__proto__ = Geometry$$1;
  GeometryCollection2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  GeometryCollection2.prototype.constructor = GeometryCollection2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  GeometryCollection2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    var this$1 = this;
    var envelope3 = new Envelope();
    for (var i = 0; i < this._geometries.length; i++) {
      envelope3.expandToInclude(this$1._geometries[i].getEnvelopeInternal());
    }
    return envelope3;
  };
  GeometryCollection2.prototype.getGeometryN = function getGeometryN2(n) {
    return this._geometries[n];
  };
  GeometryCollection2.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION;
  };
  GeometryCollection2.prototype.getCoordinates = function getCoordinates11() {
    var this$1 = this;
    var coordinates = new Array(this.getNumPoints()).fill(null);
    var k = -1;
    for (var i = 0; i < this._geometries.length; i++) {
      var childCoordinates = this$1._geometries[i].getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates;
  };
  GeometryCollection2.prototype.getArea = function getArea3() {
    var this$1 = this;
    var area5 = 0;
    for (var i = 0; i < this._geometries.length; i++) {
      area5 += this$1._geometries[i].getArea();
    }
    return area5;
  };
  GeometryCollection2.prototype.equalsExact = function equalsExact2() {
    var this$1 = this;
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      var otherCollection = other;
      if (this._geometries.length !== otherCollection._geometries.length) {
        return false;
      }
      for (var i = 0; i < this._geometries.length; i++) {
        if (!this$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
          return false;
        }
      }
      return true;
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  GeometryCollection2.prototype.normalize = function normalize6() {
    var this$1 = this;
    for (var i = 0; i < this._geometries.length; i++) {
      this$1._geometries[i].normalize();
    }
    Arrays.sort(this._geometries);
  };
  GeometryCollection2.prototype.getCoordinate = function getCoordinate18() {
    if (this.isEmpty()) {
      return null;
    }
    return this._geometries[0].getCoordinate();
  };
  GeometryCollection2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    var this$1 = this;
    var dimension = Dimension.FALSE;
    for (var i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this$1._geometries[i].getBoundaryDimension());
    }
    return dimension;
  };
  GeometryCollection2.prototype.getDimension = function getDimension3() {
    var this$1 = this;
    var dimension = Dimension.FALSE;
    for (var i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this$1._geometries[i].getDimension());
    }
    return dimension;
  };
  GeometryCollection2.prototype.getLength = function getLength3() {
    var this$1 = this;
    var sum = 0;
    for (var i = 0; i < this._geometries.length; i++) {
      sum += this$1._geometries[i].getLength();
    }
    return sum;
  };
  GeometryCollection2.prototype.getNumPoints = function getNumPoints() {
    var this$1 = this;
    var numPoints = 0;
    for (var i = 0; i < this._geometries.length; i++) {
      numPoints += this$1._geometries[i].getNumPoints();
    }
    return numPoints;
  };
  GeometryCollection2.prototype.getNumGeometries = function getNumGeometries2() {
    return this._geometries.length;
  };
  GeometryCollection2.prototype.reverse = function reverse5() {
    var this$1 = this;
    var n = this._geometries.length;
    var revGeoms = new Array(n).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this$1._geometries[i].reverse();
    }
    return this.getFactory().createGeometryCollection(revGeoms);
  };
  GeometryCollection2.prototype.compareToSameClass = function compareToSameClass() {
    var this$1 = this;
    if (arguments.length === 1) {
      var o = arguments[0];
      var theseElements = new TreeSet(Arrays.asList(this._geometries));
      var otherElements = new TreeSet(Arrays.asList(o._geometries));
      return this.compare(theseElements, otherElements);
    } else if (arguments.length === 2) {
      var o$1 = arguments[0];
      var comp = arguments[1];
      var gc = o$1;
      var n1 = this.getNumGeometries();
      var n2 = gc.getNumGeometries();
      var i = 0;
      while (i < n1 && i < n2) {
        var thisGeom = this$1.getGeometryN(i);
        var otherGeom = gc.getGeometryN(i);
        var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
        if (holeComp !== 0) {
          return holeComp;
        }
        i++;
      }
      if (i < n1) {
        return 1;
      }
      if (i < n2) {
        return -1;
      }
      return 0;
    }
  };
  GeometryCollection2.prototype.apply = function apply() {
    var this$1 = this;
    if (hasInterface(arguments[0], CoordinateFilter)) {
      var filter17 = arguments[0];
      for (var i = 0; i < this._geometries.length; i++) {
        this$1._geometries[i].apply(filter17);
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      var filter$1 = arguments[0];
      if (this._geometries.length === 0) {
        return null;
      }
      for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {
        this$1._geometries[i$1].apply(filter$1);
        if (filter$1.isDone()) {
          break;
        }
      }
      if (filter$1.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      var filter$2 = arguments[0];
      filter$2.filter(this);
      for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {
        this$1._geometries[i$2].apply(filter$2);
      }
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      var filter$3 = arguments[0];
      filter$3.filter(this);
      for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {
        this$1._geometries[i$3].apply(filter$3);
      }
    }
  };
  GeometryCollection2.prototype.getBoundary = function getBoundary3() {
    this.checkNotGeometryCollection(this);
    Assert.shouldNeverReachHere();
    return null;
  };
  GeometryCollection2.prototype.clone = function clone6() {
    var this$1 = this;
    var gc = Geometry$$1.prototype.clone.call(this);
    gc._geometries = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      gc._geometries[i] = this$1._geometries[i].clone();
    }
    return gc;
  };
  GeometryCollection2.prototype.getGeometryType = function getGeometryType() {
    return "GeometryCollection";
  };
  GeometryCollection2.prototype.copy = function copy7() {
    var this$1 = this;
    var geometries = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < geometries.length; i++) {
      geometries[i] = this$1._geometries[i].copy();
    }
    return new GeometryCollection2(geometries, this._factory);
  };
  GeometryCollection2.prototype.isEmpty = function isEmpty6() {
    var this$1 = this;
    for (var i = 0; i < this._geometries.length; i++) {
      if (!this$1._geometries[i].isEmpty()) {
        return false;
      }
    }
    return true;
  };
  GeometryCollection2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  GeometryCollection2.prototype.getClass = function getClass169() {
    return GeometryCollection2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -5694727726395021e3;
  };
  Object.defineProperties(GeometryCollection2, staticAccessors2);
  return GeometryCollection2;
}(Geometry);
var MultiLineString = function(GeometryCollection$$1) {
  function MultiLineString2() {
    GeometryCollection$$1.apply(this, arguments);
  }
  if (GeometryCollection$$1)
    MultiLineString2.__proto__ = GeometryCollection$$1;
  MultiLineString2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
  MultiLineString2.prototype.constructor = MultiLineString2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  MultiLineString2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_MULTILINESTRING;
  };
  MultiLineString2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
    } else {
      return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  MultiLineString2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    if (this.isClosed()) {
      return Dimension.FALSE;
    }
    return 0;
  };
  MultiLineString2.prototype.isClosed = function isClosed5() {
    var this$1 = this;
    if (this.isEmpty()) {
      return false;
    }
    for (var i = 0; i < this._geometries.length; i++) {
      if (!this$1._geometries[i].isClosed()) {
        return false;
      }
    }
    return true;
  };
  MultiLineString2.prototype.getDimension = function getDimension3() {
    return 1;
  };
  MultiLineString2.prototype.reverse = function reverse5() {
    var this$1 = this;
    var nLines = this._geometries.length;
    var revLines = new Array(nLines).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revLines[nLines - 1 - i] = this$1._geometries[i].reverse();
    }
    return this.getFactory().createMultiLineString(revLines);
  };
  MultiLineString2.prototype.getBoundary = function getBoundary3() {
    return new BoundaryOp(this).getBoundary();
  };
  MultiLineString2.prototype.getGeometryType = function getGeometryType() {
    return "MultiLineString";
  };
  MultiLineString2.prototype.copy = function copy7() {
    var this$1 = this;
    var lineStrings2 = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < lineStrings2.length; i++) {
      lineStrings2[i] = this$1._geometries[i].copy();
    }
    return new MultiLineString2(lineStrings2, this._factory);
  };
  MultiLineString2.prototype.interfaces_ = function interfaces_170() {
    return [Lineal];
  };
  MultiLineString2.prototype.getClass = function getClass169() {
    return MultiLineString2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 8166665132445434e3;
  };
  Object.defineProperties(MultiLineString2, staticAccessors2);
  return MultiLineString2;
}(GeometryCollection);
var BoundaryOp = function BoundaryOp2() {
  this._geom = null;
  this._geomFact = null;
  this._bnRule = null;
  this._endpointMap = null;
  if (arguments.length === 1) {
    var geom = arguments[0];
    var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;
    this._geom = geom;
    this._geomFact = geom.getFactory();
    this._bnRule = bnRule;
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var bnRule$1 = arguments[1];
    this._geom = geom$1;
    this._geomFact = geom$1.getFactory();
    this._bnRule = bnRule$1;
  }
};
BoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString(mLine) {
  if (this._geom.isEmpty()) {
    return this.getEmptyMultiPoint();
  }
  var bdyPts = this.computeBoundaryCoordinates(mLine);
  if (bdyPts.length === 1) {
    return this._geomFact.createPoint(bdyPts[0]);
  }
  return this._geomFact.createMultiPointFromCoords(bdyPts);
};
BoundaryOp.prototype.getBoundary = function getBoundary() {
  if (this._geom instanceof LineString2) {
    return this.boundaryLineString(this._geom);
  }
  if (this._geom instanceof MultiLineString) {
    return this.boundaryMultiLineString(this._geom);
  }
  return this._geom.getBoundary();
};
BoundaryOp.prototype.boundaryLineString = function boundaryLineString(line) {
  if (this._geom.isEmpty()) {
    return this.getEmptyMultiPoint();
  }
  if (line.isClosed()) {
    var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
    if (closedEndpointOnBoundary) {
      return line.getStartPoint();
    } else {
      return this._geomFact.createMultiPoint();
    }
  }
  return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);
};
BoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint() {
  return this._geomFact.createMultiPoint();
};
BoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates(mLine) {
  var this$1 = this;
  var bdyPts = new ArrayList();
  this._endpointMap = new TreeMap();
  for (var i = 0; i < mLine.getNumGeometries(); i++) {
    var line = mLine.getGeometryN(i);
    if (line.getNumPoints() === 0) {
      continue;
    }
    this$1.addEndpoint(line.getCoordinateN(0));
    this$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
  }
  for (var it = this._endpointMap.entrySet().iterator(); it.hasNext(); ) {
    var entry = it.next();
    var counter = entry.getValue();
    var valence = counter.count;
    if (this$1._bnRule.isInBoundary(valence)) {
      bdyPts.add(entry.getKey());
    }
  }
  return CoordinateArrays.toCoordinateArray(bdyPts);
};
BoundaryOp.prototype.addEndpoint = function addEndpoint(pt) {
  var counter = this._endpointMap.get(pt);
  if (counter === null) {
    counter = new Counter();
    this._endpointMap.put(pt, counter);
  }
  counter.count++;
};
BoundaryOp.prototype.interfaces_ = function interfaces_33() {
  return [];
};
BoundaryOp.prototype.getClass = function getClass32() {
  return BoundaryOp;
};
BoundaryOp.getBoundary = function getBoundary2() {
  if (arguments.length === 1) {
    var g = arguments[0];
    var bop = new BoundaryOp(g);
    return bop.getBoundary();
  } else if (arguments.length === 2) {
    var g$1 = arguments[0];
    var bnRule = arguments[1];
    var bop$1 = new BoundaryOp(g$1, bnRule);
    return bop$1.getBoundary();
  }
};
var Counter = function Counter2() {
  this.count = null;
};
Counter.prototype.interfaces_ = function interfaces_34() {
  return [];
};
Counter.prototype.getClass = function getClass33() {
  return Counter;
};
function PrintStream() {
}
function StringReader() {
}
var DecimalFormat = function DecimalFormat2() {
};
function ByteArrayOutputStream() {
}
function IOException() {
}
function LineNumberReader() {
}
var StringUtil = function StringUtil2() {
};
var staticAccessors$15 = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
StringUtil.prototype.interfaces_ = function interfaces_35() {
  return [];
};
StringUtil.prototype.getClass = function getClass34() {
  return StringUtil;
};
StringUtil.chars = function chars(c, n) {
  var ch = new Array(n).fill(null);
  for (var i = 0; i < n; i++) {
    ch[i] = c;
  }
  return String(ch);
};
StringUtil.getStackTrace = function getStackTrace() {
  if (arguments.length === 1) {
    var t = arguments[0];
    var os = new ByteArrayOutputStream();
    var ps = new PrintStream(os);
    t.printStackTrace(ps);
    return os.toString();
  } else if (arguments.length === 2) {
    var t$1 = arguments[0];
    var depth2 = arguments[1];
    var stackTrace = "";
    var stringReader = new StringReader(StringUtil.getStackTrace(t$1));
    var lineNumberReader = new LineNumberReader(stringReader);
    for (var i = 0; i < depth2; i++) {
      try {
        stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
      } catch (e) {
        if (e instanceof IOException) {
          Assert.shouldNeverReachHere();
        } else {
          throw e;
        }
      } finally {
      }
    }
    return stackTrace;
  }
};
StringUtil.split = function split2(s, separator) {
  var separatorlen = separator.length;
  var tokenList = new ArrayList();
  var tmpString = "" + s;
  var pos = tmpString.indexOf(separator);
  while (pos >= 0) {
    var token = tmpString.substring(0, pos);
    tokenList.add(token);
    tmpString = tmpString.substring(pos + separatorlen);
    pos = tmpString.indexOf(separator);
  }
  if (tmpString.length > 0) {
    tokenList.add(tmpString);
  }
  var res = new Array(tokenList.size()).fill(null);
  for (var i = 0; i < res.length; i++) {
    res[i] = tokenList.get(i);
  }
  return res;
};
StringUtil.toString = function toString6() {
  if (arguments.length === 1) {
    var d = arguments[0];
    return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);
  }
};
StringUtil.spaces = function spaces(n) {
  return StringUtil.chars(" ", n);
};
staticAccessors$15.NEWLINE.get = function() {
  return System.getProperty("line.separator");
};
staticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function() {
  return new DecimalFormat("0.#");
};
Object.defineProperties(StringUtil, staticAccessors$15);
var CoordinateSequences = function CoordinateSequences2() {
};
CoordinateSequences.prototype.interfaces_ = function interfaces_36() {
  return [];
};
CoordinateSequences.prototype.getClass = function getClass35() {
  return CoordinateSequences;
};
CoordinateSequences.copyCoord = function copyCoord(src, srcPos, dest, destPos) {
  var minDim = Math.min(src.getDimension(), dest.getDimension());
  for (var dim = 0; dim < minDim; dim++) {
    dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
  }
};
CoordinateSequences.isRing = function isRing2(seq) {
  var n = seq.size();
  if (n === 0) {
    return true;
  }
  if (n <= 3) {
    return false;
  }
  return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
};
CoordinateSequences.isEqual = function isEqual(cs1, cs2) {
  var cs1Size = cs1.size();
  var cs2Size = cs2.size();
  if (cs1Size !== cs2Size) {
    return false;
  }
  var dim = Math.min(cs1.getDimension(), cs2.getDimension());
  for (var i = 0; i < cs1Size; i++) {
    for (var d = 0; d < dim; d++) {
      var v1 = cs1.getOrdinate(i, d);
      var v2 = cs2.getOrdinate(i, d);
      if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) {
        continue;
      }
      if (Double.isNaN(v1) && Double.isNaN(v2)) {
        continue;
      }
      return false;
    }
  }
  return true;
};
CoordinateSequences.extend = function extend(fact, seq, size11) {
  var newseq = fact.create(size11, seq.getDimension());
  var n = seq.size();
  CoordinateSequences.copy(seq, 0, newseq, 0, n);
  if (n > 0) {
    for (var i = n; i < size11; i++) {
      CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
    }
  }
  return newseq;
};
CoordinateSequences.reverse = function reverse3(seq) {
  var last = seq.size() - 1;
  var mid = Math.trunc(last / 2);
  for (var i = 0; i <= mid; i++) {
    CoordinateSequences.swap(seq, i, last - i);
  }
};
CoordinateSequences.swap = function swap(seq, i, j) {
  if (i === j) {
    return null;
  }
  for (var dim = 0; dim < seq.getDimension(); dim++) {
    var tmp = seq.getOrdinate(i, dim);
    seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
    seq.setOrdinate(j, dim, tmp);
  }
};
CoordinateSequences.copy = function copy4(src, srcPos, dest, destPos, length4) {
  for (var i = 0; i < length4; i++) {
    CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
  }
};
CoordinateSequences.toString = function toString7() {
  if (arguments.length === 1) {
    var cs = arguments[0];
    var size11 = cs.size();
    if (size11 === 0) {
      return "()";
    }
    var dim = cs.getDimension();
    var buf = new StringBuffer();
    buf.append("(");
    for (var i = 0; i < size11; i++) {
      if (i > 0) {
        buf.append(" ");
      }
      for (var d = 0; d < dim; d++) {
        if (d > 0) {
          buf.append(",");
        }
        buf.append(StringUtil.toString(cs.getOrdinate(i, d)));
      }
    }
    buf.append(")");
    return buf.toString();
  }
};
CoordinateSequences.ensureValidRing = function ensureValidRing(fact, seq) {
  var n = seq.size();
  if (n === 0) {
    return seq;
  }
  if (n <= 3) {
    return CoordinateSequences.createClosedRing(fact, seq, 4);
  }
  var isClosed5 = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
  if (isClosed5) {
    return seq;
  }
  return CoordinateSequences.createClosedRing(fact, seq, n + 1);
};
CoordinateSequences.createClosedRing = function createClosedRing(fact, seq, size11) {
  var newseq = fact.create(size11, seq.getDimension());
  var n = seq.size();
  CoordinateSequences.copy(seq, 0, newseq, 0, n);
  for (var i = n; i < size11; i++) {
    CoordinateSequences.copy(seq, 0, newseq, i, 1);
  }
  return newseq;
};
var LineString2 = function(Geometry$$1) {
  function LineString3(points2, factory) {
    Geometry$$1.call(this, factory);
    this._points = null;
    this.init(points2);
  }
  if (Geometry$$1)
    LineString3.__proto__ = Geometry$$1;
  LineString3.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  LineString3.prototype.constructor = LineString3;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  LineString3.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    if (this.isEmpty()) {
      return new Envelope();
    }
    return this._points.expandEnvelope(new Envelope());
  };
  LineString3.prototype.isRing = function isRing3() {
    return this.isClosed() && this.isSimple();
  };
  LineString3.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_LINESTRING;
  };
  LineString3.prototype.getCoordinates = function getCoordinates11() {
    return this._points.toCoordinateArray();
  };
  LineString3.prototype.equalsExact = function equalsExact2() {
    var this$1 = this;
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      var otherLineString = other;
      if (this._points.size() !== otherLineString._points.size()) {
        return false;
      }
      for (var i = 0; i < this._points.size(); i++) {
        if (!this$1.equal(this$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
          return false;
        }
      }
      return true;
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  LineString3.prototype.normalize = function normalize6() {
    var this$1 = this;
    for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
      var j = this$1._points.size() - 1 - i;
      if (!this$1._points.getCoordinate(i).equals(this$1._points.getCoordinate(j))) {
        if (this$1._points.getCoordinate(i).compareTo(this$1._points.getCoordinate(j)) > 0) {
          CoordinateSequences.reverse(this$1._points);
        }
        return null;
      }
    }
  };
  LineString3.prototype.getCoordinate = function getCoordinate18() {
    if (this.isEmpty()) {
      return null;
    }
    return this._points.getCoordinate(0);
  };
  LineString3.prototype.getBoundaryDimension = function getBoundaryDimension() {
    if (this.isClosed()) {
      return Dimension.FALSE;
    }
    return 0;
  };
  LineString3.prototype.isClosed = function isClosed5() {
    if (this.isEmpty()) {
      return false;
    }
    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
  };
  LineString3.prototype.getEndPoint = function getEndPoint() {
    if (this.isEmpty()) {
      return null;
    }
    return this.getPointN(this.getNumPoints() - 1);
  };
  LineString3.prototype.getDimension = function getDimension3() {
    return 1;
  };
  LineString3.prototype.getLength = function getLength3() {
    return CGAlgorithms.computeLength(this._points);
  };
  LineString3.prototype.getNumPoints = function getNumPoints() {
    return this._points.size();
  };
  LineString3.prototype.reverse = function reverse5() {
    var seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    var revLine = this.getFactory().createLineString(seq);
    return revLine;
  };
  LineString3.prototype.compareToSameClass = function compareToSameClass() {
    var this$1 = this;
    if (arguments.length === 1) {
      var o = arguments[0];
      var line = o;
      var i = 0;
      var j = 0;
      while (i < this._points.size() && j < line._points.size()) {
        var comparison = this$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
        if (comparison !== 0) {
          return comparison;
        }
        i++;
        j++;
      }
      if (i < this._points.size()) {
        return 1;
      }
      if (j < line._points.size()) {
        return -1;
      }
      return 0;
    } else if (arguments.length === 2) {
      var o$1 = arguments[0];
      var comp = arguments[1];
      var line$1 = o$1;
      return comp.compare(this._points, line$1._points);
    }
  };
  LineString3.prototype.apply = function apply() {
    var this$1 = this;
    if (hasInterface(arguments[0], CoordinateFilter)) {
      var filter17 = arguments[0];
      for (var i = 0; i < this._points.size(); i++) {
        filter17.filter(this$1._points.getCoordinate(i));
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      var filter$1 = arguments[0];
      if (this._points.size() === 0) {
        return null;
      }
      for (var i$1 = 0; i$1 < this._points.size(); i$1++) {
        filter$1.filter(this$1._points, i$1);
        if (filter$1.isDone()) {
          break;
        }
      }
      if (filter$1.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      var filter$2 = arguments[0];
      filter$2.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      var filter$3 = arguments[0];
      filter$3.filter(this);
    }
  };
  LineString3.prototype.getBoundary = function getBoundary3() {
    return new BoundaryOp(this).getBoundary();
  };
  LineString3.prototype.isEquivalentClass = function isEquivalentClass(other) {
    return other instanceof LineString3;
  };
  LineString3.prototype.clone = function clone6() {
    var ls = Geometry$$1.prototype.clone.call(this);
    ls._points = this._points.clone();
    return ls;
  };
  LineString3.prototype.getCoordinateN = function getCoordinateN(n) {
    return this._points.getCoordinate(n);
  };
  LineString3.prototype.getGeometryType = function getGeometryType() {
    return "LineString";
  };
  LineString3.prototype.copy = function copy7() {
    return new LineString3(this._points.copy(), this._factory);
  };
  LineString3.prototype.getCoordinateSequence = function getCoordinateSequence() {
    return this._points;
  };
  LineString3.prototype.isEmpty = function isEmpty6() {
    return this._points.size() === 0;
  };
  LineString3.prototype.init = function init8(points2) {
    if (points2 === null) {
      points2 = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    if (points2.size() === 1) {
      throw new IllegalArgumentException("Invalid number of points in LineString (found " + points2.size() + " - must be 0 or >= 2)");
    }
    this._points = points2;
  };
  LineString3.prototype.isCoordinate = function isCoordinate(pt) {
    var this$1 = this;
    for (var i = 0; i < this._points.size(); i++) {
      if (this$1._points.getCoordinate(i).equals(pt)) {
        return true;
      }
    }
    return false;
  };
  LineString3.prototype.getStartPoint = function getStartPoint() {
    if (this.isEmpty()) {
      return null;
    }
    return this.getPointN(0);
  };
  LineString3.prototype.getPointN = function getPointN(n) {
    return this.getFactory().createPoint(this._points.getCoordinate(n));
  };
  LineString3.prototype.interfaces_ = function interfaces_170() {
    return [Lineal];
  };
  LineString3.prototype.getClass = function getClass169() {
    return LineString3;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 3110669828065365500;
  };
  Object.defineProperties(LineString3, staticAccessors2);
  return LineString3;
}(Geometry);
var Puntal = function Puntal2() {
};
Puntal.prototype.interfaces_ = function interfaces_37() {
  return [];
};
Puntal.prototype.getClass = function getClass36() {
  return Puntal;
};
var Point = function(Geometry$$1) {
  function Point2(coordinates, factory) {
    Geometry$$1.call(this, factory);
    this._coordinates = coordinates || null;
    this.init(this._coordinates);
  }
  if (Geometry$$1)
    Point2.__proto__ = Geometry$$1;
  Point2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  Point2.prototype.constructor = Point2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  Point2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    if (this.isEmpty()) {
      return new Envelope();
    }
    var env = new Envelope();
    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
    return env;
  };
  Point2.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_POINT;
  };
  Point2.prototype.getCoordinates = function getCoordinates11() {
    return this.isEmpty() ? [] : [this.getCoordinate()];
  };
  Point2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      if (this.isEmpty() && other.isEmpty()) {
        return true;
      }
      if (this.isEmpty() !== other.isEmpty()) {
        return false;
      }
      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  Point2.prototype.normalize = function normalize6() {
  };
  Point2.prototype.getCoordinate = function getCoordinate18() {
    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
  };
  Point2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return Dimension.FALSE;
  };
  Point2.prototype.getDimension = function getDimension3() {
    return 0;
  };
  Point2.prototype.getNumPoints = function getNumPoints() {
    return this.isEmpty() ? 0 : 1;
  };
  Point2.prototype.reverse = function reverse5() {
    return this.copy();
  };
  Point2.prototype.getX = function getX4() {
    if (this.getCoordinate() === null) {
      throw new Error("getX called on empty Point");
    }
    return this.getCoordinate().x;
  };
  Point2.prototype.compareToSameClass = function compareToSameClass() {
    if (arguments.length === 1) {
      var other = arguments[0];
      var point$1 = other;
      return this.getCoordinate().compareTo(point$1.getCoordinate());
    } else if (arguments.length === 2) {
      var other$1 = arguments[0];
      var comp = arguments[1];
      var point4 = other$1;
      return comp.compare(this._coordinates, point4._coordinates);
    }
  };
  Point2.prototype.apply = function apply() {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      var filter17 = arguments[0];
      if (this.isEmpty()) {
        return null;
      }
      filter17.filter(this.getCoordinate());
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      var filter$1 = arguments[0];
      if (this.isEmpty()) {
        return null;
      }
      filter$1.filter(this._coordinates, 0);
      if (filter$1.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      var filter$2 = arguments[0];
      filter$2.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      var filter$3 = arguments[0];
      filter$3.filter(this);
    }
  };
  Point2.prototype.getBoundary = function getBoundary3() {
    return this.getFactory().createGeometryCollection(null);
  };
  Point2.prototype.clone = function clone6() {
    var p = Geometry$$1.prototype.clone.call(this);
    p._coordinates = this._coordinates.clone();
    return p;
  };
  Point2.prototype.getGeometryType = function getGeometryType() {
    return "Point";
  };
  Point2.prototype.copy = function copy7() {
    return new Point2(this._coordinates.copy(), this._factory);
  };
  Point2.prototype.getCoordinateSequence = function getCoordinateSequence() {
    return this._coordinates;
  };
  Point2.prototype.getY = function getY4() {
    if (this.getCoordinate() === null) {
      throw new Error("getY called on empty Point");
    }
    return this.getCoordinate().y;
  };
  Point2.prototype.isEmpty = function isEmpty6() {
    return this._coordinates.size() === 0;
  };
  Point2.prototype.init = function init8(coordinates) {
    if (coordinates === null) {
      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    Assert.isTrue(coordinates.size() <= 1);
    this._coordinates = coordinates;
  };
  Point2.prototype.isSimple = function isSimple() {
    return true;
  };
  Point2.prototype.interfaces_ = function interfaces_170() {
    return [Puntal];
  };
  Point2.prototype.getClass = function getClass169() {
    return Point2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 4902022702746615e3;
  };
  Object.defineProperties(Point2, staticAccessors2);
  return Point2;
}(Geometry);
var Polygonal = function Polygonal2() {
};
Polygonal.prototype.interfaces_ = function interfaces_38() {
  return [];
};
Polygonal.prototype.getClass = function getClass37() {
  return Polygonal;
};
var Polygon = function(Geometry$$1) {
  function Polygon2(shell, holes, factory) {
    Geometry$$1.call(this, factory);
    this._shell = null;
    this._holes = null;
    if (shell === null) {
      shell = this.getFactory().createLinearRing();
    }
    if (holes === null) {
      holes = [];
    }
    if (Geometry$$1.hasNullElements(holes)) {
      throw new IllegalArgumentException("holes must not contain null elements");
    }
    if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {
      throw new IllegalArgumentException("shell is empty but holes are not");
    }
    this._shell = shell;
    this._holes = holes;
  }
  if (Geometry$$1)
    Polygon2.__proto__ = Geometry$$1;
  Polygon2.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);
  Polygon2.prototype.constructor = Polygon2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  Polygon2.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {
    return this._shell.getEnvelopeInternal();
  };
  Polygon2.prototype.getSortIndex = function getSortIndex() {
    return Geometry$$1.SORTINDEX_POLYGON;
  };
  Polygon2.prototype.getCoordinates = function getCoordinates11() {
    var this$1 = this;
    if (this.isEmpty()) {
      return [];
    }
    var coordinates = new Array(this.getNumPoints()).fill(null);
    var k = -1;
    var shellCoordinates = this._shell.getCoordinates();
    for (var x2 = 0; x2 < shellCoordinates.length; x2++) {
      k++;
      coordinates[k] = shellCoordinates[x2];
    }
    for (var i = 0; i < this._holes.length; i++) {
      var childCoordinates = this$1._holes[i].getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates;
  };
  Polygon2.prototype.getArea = function getArea3() {
    var this$1 = this;
    var area5 = 0;
    area5 += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));
    for (var i = 0; i < this._holes.length; i++) {
      area5 -= Math.abs(CGAlgorithms.signedArea(this$1._holes[i].getCoordinateSequence()));
    }
    return area5;
  };
  Polygon2.prototype.isRectangle = function isRectangle2() {
    if (this.getNumInteriorRing() !== 0) {
      return false;
    }
    if (this._shell === null) {
      return false;
    }
    if (this._shell.getNumPoints() !== 5) {
      return false;
    }
    var seq = this._shell.getCoordinateSequence();
    var env = this.getEnvelopeInternal();
    for (var i = 0; i < 5; i++) {
      var x2 = seq.getX(i);
      if (!(x2 === env.getMinX() || x2 === env.getMaxX())) {
        return false;
      }
      var y2 = seq.getY(i);
      if (!(y2 === env.getMinY() || y2 === env.getMaxY())) {
        return false;
      }
    }
    var prevX = seq.getX(0);
    var prevY = seq.getY(0);
    for (var i$1 = 1; i$1 <= 4; i$1++) {
      var x$1 = seq.getX(i$1);
      var y$1 = seq.getY(i$1);
      var xChanged = x$1 !== prevX;
      var yChanged = y$1 !== prevY;
      if (xChanged === yChanged) {
        return false;
      }
      prevX = x$1;
      prevY = y$1;
    }
    return true;
  };
  Polygon2.prototype.equalsExact = function equalsExact2() {
    var this$1 = this;
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      var otherPolygon = other;
      var thisShell = this._shell;
      var otherPolygonShell = otherPolygon._shell;
      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
        return false;
      }
      if (this._holes.length !== otherPolygon._holes.length) {
        return false;
      }
      for (var i = 0; i < this._holes.length; i++) {
        if (!this$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
          return false;
        }
      }
      return true;
    } else {
      return Geometry$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  Polygon2.prototype.normalize = function normalize6() {
    var this$1 = this;
    if (arguments.length === 0) {
      this.normalize(this._shell, true);
      for (var i = 0; i < this._holes.length; i++) {
        this$1.normalize(this$1._holes[i], false);
      }
      Arrays.sort(this._holes);
    } else if (arguments.length === 2) {
      var ring = arguments[0];
      var clockwise = arguments[1];
      if (ring.isEmpty()) {
        return null;
      }
      var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
      var minCoordinate2 = CoordinateArrays.minCoordinate(ring.getCoordinates());
      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate2);
      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
      if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {
        CoordinateArrays.reverse(ring.getCoordinates());
      }
    }
  };
  Polygon2.prototype.getCoordinate = function getCoordinate18() {
    return this._shell.getCoordinate();
  };
  Polygon2.prototype.getNumInteriorRing = function getNumInteriorRing() {
    return this._holes.length;
  };
  Polygon2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return 1;
  };
  Polygon2.prototype.getDimension = function getDimension3() {
    return 2;
  };
  Polygon2.prototype.getLength = function getLength3() {
    var this$1 = this;
    var len = 0;
    len += this._shell.getLength();
    for (var i = 0; i < this._holes.length; i++) {
      len += this$1._holes[i].getLength();
    }
    return len;
  };
  Polygon2.prototype.getNumPoints = function getNumPoints() {
    var this$1 = this;
    var numPoints = this._shell.getNumPoints();
    for (var i = 0; i < this._holes.length; i++) {
      numPoints += this$1._holes[i].getNumPoints();
    }
    return numPoints;
  };
  Polygon2.prototype.reverse = function reverse5() {
    var this$1 = this;
    var poly = this.copy();
    poly._shell = this._shell.copy().reverse();
    poly._holes = new Array(this._holes.length).fill(null);
    for (var i = 0; i < this._holes.length; i++) {
      poly._holes[i] = this$1._holes[i].copy().reverse();
    }
    return poly;
  };
  Polygon2.prototype.convexHull = function convexHull() {
    return this.getExteriorRing().convexHull();
  };
  Polygon2.prototype.compareToSameClass = function compareToSameClass() {
    var this$1 = this;
    if (arguments.length === 1) {
      var o = arguments[0];
      var thisShell = this._shell;
      var otherShell = o._shell;
      return thisShell.compareToSameClass(otherShell);
    } else if (arguments.length === 2) {
      var o$1 = arguments[0];
      var comp = arguments[1];
      var poly = o$1;
      var thisShell$1 = this._shell;
      var otherShell$1 = poly._shell;
      var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);
      if (shellComp !== 0) {
        return shellComp;
      }
      var nHole1 = this.getNumInteriorRing();
      var nHole2 = poly.getNumInteriorRing();
      var i = 0;
      while (i < nHole1 && i < nHole2) {
        var thisHole = this$1.getInteriorRingN(i);
        var otherHole = poly.getInteriorRingN(i);
        var holeComp = thisHole.compareToSameClass(otherHole, comp);
        if (holeComp !== 0) {
          return holeComp;
        }
        i++;
      }
      if (i < nHole1) {
        return 1;
      }
      if (i < nHole2) {
        return -1;
      }
      return 0;
    }
  };
  Polygon2.prototype.apply = function apply(filter17) {
    var this$1 = this;
    if (hasInterface(filter17, CoordinateFilter)) {
      this._shell.apply(filter17);
      for (var i$1 = 0; i$1 < this._holes.length; i$1++) {
        this$1._holes[i$1].apply(filter17);
      }
    } else if (hasInterface(filter17, CoordinateSequenceFilter)) {
      this._shell.apply(filter17);
      if (!filter17.isDone()) {
        for (var i$2 = 0; i$2 < this._holes.length; i$2++) {
          this$1._holes[i$2].apply(filter17);
          if (filter17.isDone()) {
            break;
          }
        }
      }
      if (filter17.isGeometryChanged()) {
        this.geometryChanged();
      }
    } else if (hasInterface(filter17, GeometryFilter)) {
      filter17.filter(this);
    } else if (hasInterface(filter17, GeometryComponentFilter)) {
      filter17.filter(this);
      this._shell.apply(filter17);
      for (var i = 0; i < this._holes.length; i++) {
        this$1._holes[i].apply(filter17);
      }
    }
  };
  Polygon2.prototype.getBoundary = function getBoundary3() {
    var this$1 = this;
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString();
    }
    var rings = new Array(this._holes.length + 1).fill(null);
    rings[0] = this._shell;
    for (var i = 0; i < this._holes.length; i++) {
      rings[i + 1] = this$1._holes[i];
    }
    if (rings.length <= 1) {
      return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
    }
    return this.getFactory().createMultiLineString(rings);
  };
  Polygon2.prototype.clone = function clone6() {
    var this$1 = this;
    var poly = Geometry$$1.prototype.clone.call(this);
    poly._shell = this._shell.clone();
    poly._holes = new Array(this._holes.length).fill(null);
    for (var i = 0; i < this._holes.length; i++) {
      poly._holes[i] = this$1._holes[i].clone();
    }
    return poly;
  };
  Polygon2.prototype.getGeometryType = function getGeometryType() {
    return "Polygon";
  };
  Polygon2.prototype.copy = function copy7() {
    var this$1 = this;
    var shell = this._shell.copy();
    var holes = new Array(this._holes.length).fill(null);
    for (var i = 0; i < holes.length; i++) {
      holes[i] = this$1._holes[i].copy();
    }
    return new Polygon2(shell, holes, this._factory);
  };
  Polygon2.prototype.getExteriorRing = function getExteriorRing() {
    return this._shell;
  };
  Polygon2.prototype.isEmpty = function isEmpty6() {
    return this._shell.isEmpty();
  };
  Polygon2.prototype.getInteriorRingN = function getInteriorRingN(n) {
    return this._holes[n];
  };
  Polygon2.prototype.interfaces_ = function interfaces_170() {
    return [Polygonal];
  };
  Polygon2.prototype.getClass = function getClass169() {
    return Polygon2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -3494792200821764600;
  };
  Object.defineProperties(Polygon2, staticAccessors2);
  return Polygon2;
}(Geometry);
var MultiPoint = function(GeometryCollection$$1) {
  function MultiPoint2() {
    GeometryCollection$$1.apply(this, arguments);
  }
  if (GeometryCollection$$1)
    MultiPoint2.__proto__ = GeometryCollection$$1;
  MultiPoint2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
  MultiPoint2.prototype.constructor = MultiPoint2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  MultiPoint2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_MULTIPOINT;
  };
  MultiPoint2.prototype.isValid = function isValid7() {
    return true;
  };
  MultiPoint2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
    } else {
      return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  MultiPoint2.prototype.getCoordinate = function getCoordinate18() {
    if (arguments.length === 1) {
      var n = arguments[0];
      return this._geometries[n].getCoordinate();
    } else {
      return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments);
    }
  };
  MultiPoint2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return Dimension.FALSE;
  };
  MultiPoint2.prototype.getDimension = function getDimension3() {
    return 0;
  };
  MultiPoint2.prototype.getBoundary = function getBoundary3() {
    return this.getFactory().createGeometryCollection(null);
  };
  MultiPoint2.prototype.getGeometryType = function getGeometryType() {
    return "MultiPoint";
  };
  MultiPoint2.prototype.copy = function copy7() {
    var this$1 = this;
    var points2 = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < points2.length; i++) {
      points2[i] = this$1._geometries[i].copy();
    }
    return new MultiPoint2(points2, this._factory);
  };
  MultiPoint2.prototype.interfaces_ = function interfaces_170() {
    return [Puntal];
  };
  MultiPoint2.prototype.getClass = function getClass169() {
    return MultiPoint2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -8048474874175356e3;
  };
  Object.defineProperties(MultiPoint2, staticAccessors2);
  return MultiPoint2;
}(GeometryCollection);
var LinearRing = function(LineString$$1) {
  function LinearRing2(points2, factory) {
    if (points2 instanceof Coordinate && factory instanceof GeometryFactory) {
      points2 = factory.getCoordinateSequenceFactory().create(points2);
    }
    LineString$$1.call(this, points2, factory);
    this.validateConstruction();
  }
  if (LineString$$1)
    LinearRing2.__proto__ = LineString$$1;
  LinearRing2.prototype = Object.create(LineString$$1 && LineString$$1.prototype);
  LinearRing2.prototype.constructor = LinearRing2;
  var staticAccessors2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
  LinearRing2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_LINEARRING;
  };
  LinearRing2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return Dimension.FALSE;
  };
  LinearRing2.prototype.isClosed = function isClosed5() {
    if (this.isEmpty()) {
      return true;
    }
    return LineString$$1.prototype.isClosed.call(this);
  };
  LinearRing2.prototype.reverse = function reverse5() {
    var seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    var rev = this.getFactory().createLinearRing(seq);
    return rev;
  };
  LinearRing2.prototype.validateConstruction = function validateConstruction() {
    if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {
      throw new IllegalArgumentException("Points of LinearRing do not form a closed linestring");
    }
    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing2.MINIMUM_VALID_SIZE) {
      throw new IllegalArgumentException("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
    }
  };
  LinearRing2.prototype.getGeometryType = function getGeometryType() {
    return "LinearRing";
  };
  LinearRing2.prototype.copy = function copy7() {
    return new LinearRing2(this._points.copy(), this._factory);
  };
  LinearRing2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  LinearRing2.prototype.getClass = function getClass169() {
    return LinearRing2;
  };
  staticAccessors2.MINIMUM_VALID_SIZE.get = function() {
    return 4;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -4261142084085851600;
  };
  Object.defineProperties(LinearRing2, staticAccessors2);
  return LinearRing2;
}(LineString2);
var MultiPolygon = function(GeometryCollection$$1) {
  function MultiPolygon2() {
    GeometryCollection$$1.apply(this, arguments);
  }
  if (GeometryCollection$$1)
    MultiPolygon2.__proto__ = GeometryCollection$$1;
  MultiPolygon2.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);
  MultiPolygon2.prototype.constructor = MultiPolygon2;
  var staticAccessors2 = { serialVersionUID: { configurable: true } };
  MultiPolygon2.prototype.getSortIndex = function getSortIndex() {
    return Geometry.SORTINDEX_MULTIPOLYGON;
  };
  MultiPolygon2.prototype.equalsExact = function equalsExact2() {
    if (arguments.length === 2) {
      var other = arguments[0];
      var tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false;
      }
      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);
    } else {
      return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);
    }
  };
  MultiPolygon2.prototype.getBoundaryDimension = function getBoundaryDimension() {
    return 1;
  };
  MultiPolygon2.prototype.getDimension = function getDimension3() {
    return 2;
  };
  MultiPolygon2.prototype.reverse = function reverse5() {
    var this$1 = this;
    var n = this._geometries.length;
    var revGeoms = new Array(n).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this$1._geometries[i].reverse();
    }
    return this.getFactory().createMultiPolygon(revGeoms);
  };
  MultiPolygon2.prototype.getBoundary = function getBoundary3() {
    var this$1 = this;
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString();
    }
    var allRings = new ArrayList();
    for (var i = 0; i < this._geometries.length; i++) {
      var polygon4 = this$1._geometries[i];
      var rings = polygon4.getBoundary();
      for (var j = 0; j < rings.getNumGeometries(); j++) {
        allRings.add(rings.getGeometryN(j));
      }
    }
    var allRingsArray = new Array(allRings.size()).fill(null);
    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
  };
  MultiPolygon2.prototype.getGeometryType = function getGeometryType() {
    return "MultiPolygon";
  };
  MultiPolygon2.prototype.copy = function copy7() {
    var this$1 = this;
    var polygons2 = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < polygons2.length; i++) {
      polygons2[i] = this$1._geometries[i].copy();
    }
    return new MultiPolygon2(polygons2, this._factory);
  };
  MultiPolygon2.prototype.interfaces_ = function interfaces_170() {
    return [Polygonal];
  };
  MultiPolygon2.prototype.getClass = function getClass169() {
    return MultiPolygon2;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return -551033529766975900;
  };
  Object.defineProperties(MultiPolygon2, staticAccessors2);
  return MultiPolygon2;
}(GeometryCollection);
var GeometryEditor = function GeometryEditor2(factory) {
  this._factory = factory || null;
  this._isUserDataCopied = false;
};
var staticAccessors$16 = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
GeometryEditor.prototype.setCopyUserData = function setCopyUserData(isUserDataCopied) {
  this._isUserDataCopied = isUserDataCopied;
};
GeometryEditor.prototype.edit = function edit(geometry2, operation2) {
  if (geometry2 === null) {
    return null;
  }
  var result = this.editInternal(geometry2, operation2);
  if (this._isUserDataCopied) {
    result.setUserData(geometry2.getUserData());
  }
  return result;
};
GeometryEditor.prototype.editInternal = function editInternal(geometry2, operation2) {
  if (this._factory === null) {
    this._factory = geometry2.getFactory();
  }
  if (geometry2 instanceof GeometryCollection) {
    return this.editGeometryCollection(geometry2, operation2);
  }
  if (geometry2 instanceof Polygon) {
    return this.editPolygon(geometry2, operation2);
  }
  if (geometry2 instanceof Point) {
    return operation2.edit(geometry2, this._factory);
  }
  if (geometry2 instanceof LineString2) {
    return operation2.edit(geometry2, this._factory);
  }
  Assert.shouldNeverReachHere("Unsupported Geometry class: " + geometry2.getClass().getName());
  return null;
};
GeometryEditor.prototype.editGeometryCollection = function editGeometryCollection(collection, operation2) {
  var this$1 = this;
  var collectionForType = operation2.edit(collection, this._factory);
  var geometries = new ArrayList();
  for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
    var geometry2 = this$1.edit(collectionForType.getGeometryN(i), operation2);
    if (geometry2 === null || geometry2.isEmpty()) {
      continue;
    }
    geometries.add(geometry2);
  }
  if (collectionForType.getClass() === MultiPoint) {
    return this._factory.createMultiPoint(geometries.toArray([]));
  }
  if (collectionForType.getClass() === MultiLineString) {
    return this._factory.createMultiLineString(geometries.toArray([]));
  }
  if (collectionForType.getClass() === MultiPolygon) {
    return this._factory.createMultiPolygon(geometries.toArray([]));
  }
  return this._factory.createGeometryCollection(geometries.toArray([]));
};
GeometryEditor.prototype.editPolygon = function editPolygon(polygon4, operation2) {
  var this$1 = this;
  var newPolygon = operation2.edit(polygon4, this._factory);
  if (newPolygon === null) {
    newPolygon = this._factory.createPolygon(null);
  }
  if (newPolygon.isEmpty()) {
    return newPolygon;
  }
  var shell = this.edit(newPolygon.getExteriorRing(), operation2);
  if (shell === null || shell.isEmpty()) {
    return this._factory.createPolygon();
  }
  var holes = new ArrayList();
  for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
    var hole = this$1.edit(newPolygon.getInteriorRingN(i), operation2);
    if (hole === null || hole.isEmpty()) {
      continue;
    }
    holes.add(hole);
  }
  return this._factory.createPolygon(shell, holes.toArray([]));
};
GeometryEditor.prototype.interfaces_ = function interfaces_39() {
  return [];
};
GeometryEditor.prototype.getClass = function getClass38() {
  return GeometryEditor;
};
GeometryEditor.GeometryEditorOperation = function GeometryEditorOperation() {
};
staticAccessors$16.NoOpGeometryOperation.get = function() {
  return NoOpGeometryOperation;
};
staticAccessors$16.CoordinateOperation.get = function() {
  return CoordinateOperation;
};
staticAccessors$16.CoordinateSequenceOperation.get = function() {
  return CoordinateSequenceOperation;
};
Object.defineProperties(GeometryEditor, staticAccessors$16);
var NoOpGeometryOperation = function NoOpGeometryOperation2() {
};
NoOpGeometryOperation.prototype.edit = function edit2(geometry2, factory) {
  return geometry2;
};
NoOpGeometryOperation.prototype.interfaces_ = function interfaces_40() {
  return [GeometryEditor.GeometryEditorOperation];
};
NoOpGeometryOperation.prototype.getClass = function getClass39() {
  return NoOpGeometryOperation;
};
var CoordinateOperation = function CoordinateOperation2() {
};
CoordinateOperation.prototype.edit = function edit3(geometry2, factory) {
  var coords = this.editCoordinates(geometry2.getCoordinates(), geometry2);
  if (coords === null) {
    return geometry2;
  }
  if (geometry2 instanceof LinearRing) {
    return factory.createLinearRing(coords);
  }
  if (geometry2 instanceof LineString2) {
    return factory.createLineString(coords);
  }
  if (geometry2 instanceof Point) {
    if (coords.length > 0) {
      return factory.createPoint(coords[0]);
    } else {
      return factory.createPoint();
    }
  }
  return geometry2;
};
CoordinateOperation.prototype.interfaces_ = function interfaces_41() {
  return [GeometryEditor.GeometryEditorOperation];
};
CoordinateOperation.prototype.getClass = function getClass40() {
  return CoordinateOperation;
};
var CoordinateSequenceOperation = function CoordinateSequenceOperation2() {
};
CoordinateSequenceOperation.prototype.edit = function edit4(geometry2, factory) {
  if (geometry2 instanceof LinearRing) {
    return factory.createLinearRing(this.edit(geometry2.getCoordinateSequence(), geometry2));
  }
  if (geometry2 instanceof LineString2) {
    return factory.createLineString(this.edit(geometry2.getCoordinateSequence(), geometry2));
  }
  if (geometry2 instanceof Point) {
    return factory.createPoint(this.edit(geometry2.getCoordinateSequence(), geometry2));
  }
  return geometry2;
};
CoordinateSequenceOperation.prototype.interfaces_ = function interfaces_42() {
  return [GeometryEditor.GeometryEditorOperation];
};
CoordinateSequenceOperation.prototype.getClass = function getClass41() {
  return CoordinateSequenceOperation;
};
var CoordinateArraySequence = function CoordinateArraySequence2() {
  var this$1 = this;
  this._dimension = 3;
  this._coordinates = null;
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      this._coordinates = arguments[0];
      this._dimension = 3;
    } else if (Number.isInteger(arguments[0])) {
      var size11 = arguments[0];
      this._coordinates = new Array(size11).fill(null);
      for (var i = 0; i < size11; i++) {
        this$1._coordinates[i] = new Coordinate();
      }
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordSeq = arguments[0];
      if (coordSeq === null) {
        this._coordinates = new Array(0).fill(null);
        return null;
      }
      this._dimension = coordSeq.getDimension();
      this._coordinates = new Array(coordSeq.size()).fill(null);
      for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {
        this$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);
      }
    }
  } else if (arguments.length === 2) {
    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
      var coordinates = arguments[0];
      var dimension = arguments[1];
      this._coordinates = coordinates;
      this._dimension = dimension;
      if (coordinates === null) {
        this._coordinates = new Array(0).fill(null);
      }
    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var size$1 = arguments[0];
      var dimension$1 = arguments[1];
      this._coordinates = new Array(size$1).fill(null);
      this._dimension = dimension$1;
      for (var i$2 = 0; i$2 < size$1; i$2++) {
        this$1._coordinates[i$2] = new Coordinate();
      }
    }
  }
};
var staticAccessors$18 = { serialVersionUID: { configurable: true } };
CoordinateArraySequence.prototype.setOrdinate = function setOrdinate3(index2, ordinateIndex, value) {
  switch (ordinateIndex) {
    case CoordinateSequence.X:
      this._coordinates[index2].x = value;
      break;
    case CoordinateSequence.Y:
      this._coordinates[index2].y = value;
      break;
    case CoordinateSequence.Z:
      this._coordinates[index2].z = value;
      break;
    default:
      throw new IllegalArgumentException("invalid ordinateIndex");
  }
};
CoordinateArraySequence.prototype.size = function size4() {
  return this._coordinates.length;
};
CoordinateArraySequence.prototype.getOrdinate = function getOrdinate3(index2, ordinateIndex) {
  switch (ordinateIndex) {
    case CoordinateSequence.X:
      return this._coordinates[index2].x;
    case CoordinateSequence.Y:
      return this._coordinates[index2].y;
    case CoordinateSequence.Z:
      return this._coordinates[index2].z;
    default:
  }
  return Double.NaN;
};
CoordinateArraySequence.prototype.getCoordinate = function getCoordinate3() {
  if (arguments.length === 1) {
    var i = arguments[0];
    return this._coordinates[i];
  } else if (arguments.length === 2) {
    var index2 = arguments[0];
    var coord = arguments[1];
    coord.x = this._coordinates[index2].x;
    coord.y = this._coordinates[index2].y;
    coord.z = this._coordinates[index2].z;
  }
};
CoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy2(i) {
  return new Coordinate(this._coordinates[i]);
};
CoordinateArraySequence.prototype.getDimension = function getDimension2() {
  return this._dimension;
};
CoordinateArraySequence.prototype.getX = function getX3(index2) {
  return this._coordinates[index2].x;
};
CoordinateArraySequence.prototype.clone = function clone5() {
  var this$1 = this;
  var cloneCoordinates = new Array(this.size()).fill(null);
  for (var i = 0; i < this._coordinates.length; i++) {
    cloneCoordinates[i] = this$1._coordinates[i].clone();
  }
  return new CoordinateArraySequence(cloneCoordinates, this._dimension);
};
CoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope2(env) {
  var this$1 = this;
  for (var i = 0; i < this._coordinates.length; i++) {
    env.expandToInclude(this$1._coordinates[i]);
  }
  return env;
};
CoordinateArraySequence.prototype.copy = function copy5() {
  var this$1 = this;
  var cloneCoordinates = new Array(this.size()).fill(null);
  for (var i = 0; i < this._coordinates.length; i++) {
    cloneCoordinates[i] = this$1._coordinates[i].copy();
  }
  return new CoordinateArraySequence(cloneCoordinates, this._dimension);
};
CoordinateArraySequence.prototype.toString = function toString8() {
  var this$1 = this;
  if (this._coordinates.length > 0) {
    var strBuf = new StringBuffer(17 * this._coordinates.length);
    strBuf.append("(");
    strBuf.append(this._coordinates[0]);
    for (var i = 1; i < this._coordinates.length; i++) {
      strBuf.append(", ");
      strBuf.append(this$1._coordinates[i]);
    }
    strBuf.append(")");
    return strBuf.toString();
  } else {
    return "()";
  }
};
CoordinateArraySequence.prototype.getY = function getY3(index2) {
  return this._coordinates[index2].y;
};
CoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray3() {
  return this._coordinates;
};
CoordinateArraySequence.prototype.interfaces_ = function interfaces_43() {
  return [CoordinateSequence, Serializable];
};
CoordinateArraySequence.prototype.getClass = function getClass42() {
  return CoordinateArraySequence;
};
staticAccessors$18.serialVersionUID.get = function() {
  return -915438501601840600;
};
Object.defineProperties(CoordinateArraySequence, staticAccessors$18);
var CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory2() {
};
var staticAccessors$17 = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
CoordinateArraySequenceFactory.prototype.readResolve = function readResolve() {
  return CoordinateArraySequenceFactory.instance();
};
CoordinateArraySequenceFactory.prototype.create = function create2() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var coordinates = arguments[0];
      return new CoordinateArraySequence(coordinates);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordSeq = arguments[0];
      return new CoordinateArraySequence(coordSeq);
    }
  } else if (arguments.length === 2) {
    var size11 = arguments[0];
    var dimension = arguments[1];
    if (dimension > 3) {
      dimension = 3;
    }
    if (dimension < 2) {
      return new CoordinateArraySequence(size11);
    }
    return new CoordinateArraySequence(size11, dimension);
  }
};
CoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_44() {
  return [CoordinateSequenceFactory, Serializable];
};
CoordinateArraySequenceFactory.prototype.getClass = function getClass43() {
  return CoordinateArraySequenceFactory;
};
CoordinateArraySequenceFactory.instance = function instance() {
  return CoordinateArraySequenceFactory.instanceObject;
};
staticAccessors$17.serialVersionUID.get = function() {
  return -4099577099607551500;
};
staticAccessors$17.instanceObject.get = function() {
  return new CoordinateArraySequenceFactory();
};
Object.defineProperties(CoordinateArraySequenceFactory, staticAccessors$17);
var HashMap = function(MapInterface) {
  function HashMap2() {
    MapInterface.call(this);
    this.map_ = /* @__PURE__ */ new Map();
  }
  if (MapInterface)
    HashMap2.__proto__ = MapInterface;
  HashMap2.prototype = Object.create(MapInterface && MapInterface.prototype);
  HashMap2.prototype.constructor = HashMap2;
  HashMap2.prototype.get = function get4(key) {
    return this.map_.get(key) || null;
  };
  HashMap2.prototype.put = function put2(key, value) {
    this.map_.set(key, value);
    return value;
  };
  HashMap2.prototype.values = function values3() {
    var arrayList = new ArrayList();
    var it = this.map_.values();
    var o = it.next();
    while (!o.done) {
      arrayList.add(o.value);
      o = it.next();
    }
    return arrayList;
  };
  HashMap2.prototype.entrySet = function entrySet2() {
    var hashSet = new HashSet();
    this.map_.entries().forEach(function(entry) {
      return hashSet.add(entry);
    });
    return hashSet;
  };
  HashMap2.prototype.size = function size11() {
    return this.map_.size();
  };
  return HashMap2;
}(Map$1);
var PrecisionModel = function PrecisionModel2() {
  this._modelType = null;
  this._scale = null;
  if (arguments.length === 0) {
    this._modelType = PrecisionModel2.FLOATING;
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Type) {
      var modelType = arguments[0];
      this._modelType = modelType;
      if (modelType === PrecisionModel2.FIXED) {
        this.setScale(1);
      }
    } else if (typeof arguments[0] === "number") {
      var scale4 = arguments[0];
      this._modelType = PrecisionModel2.FIXED;
      this.setScale(scale4);
    } else if (arguments[0] instanceof PrecisionModel2) {
      var pm = arguments[0];
      this._modelType = pm._modelType;
      this._scale = pm._scale;
    }
  }
};
var staticAccessors$19 = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
PrecisionModel.prototype.equals = function equals8(other) {
  if (!(other instanceof PrecisionModel)) {
    return false;
  }
  var otherPrecisionModel = other;
  return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
};
PrecisionModel.prototype.compareTo = function compareTo6(o) {
  var other = o;
  var sigDigits = this.getMaximumSignificantDigits();
  var otherSigDigits = other.getMaximumSignificantDigits();
  return new Integer(sigDigits).compareTo(new Integer(otherSigDigits));
};
PrecisionModel.prototype.getScale = function getScale() {
  return this._scale;
};
PrecisionModel.prototype.isFloating = function isFloating() {
  return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
};
PrecisionModel.prototype.getType = function getType3() {
  return this._modelType;
};
PrecisionModel.prototype.toString = function toString9() {
  var description = "UNKNOWN";
  if (this._modelType === PrecisionModel.FLOATING) {
    description = "Floating";
  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
    description = "Floating-Single";
  } else if (this._modelType === PrecisionModel.FIXED) {
    description = "Fixed (Scale=" + this.getScale() + ")";
  }
  return description;
};
PrecisionModel.prototype.makePrecise = function makePrecise() {
  if (typeof arguments[0] === "number") {
    var val = arguments[0];
    if (Double.isNaN(val)) {
      return val;
    }
    if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
      var floatSingleVal = val;
      return floatSingleVal;
    }
    if (this._modelType === PrecisionModel.FIXED) {
      return Math.round(val * this._scale) / this._scale;
    }
    return val;
  } else if (arguments[0] instanceof Coordinate) {
    var coord = arguments[0];
    if (this._modelType === PrecisionModel.FLOATING) {
      return null;
    }
    coord.x = this.makePrecise(coord.x);
    coord.y = this.makePrecise(coord.y);
  }
};
PrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits() {
  var maxSigDigits = 16;
  if (this._modelType === PrecisionModel.FLOATING) {
    maxSigDigits = 16;
  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
    maxSigDigits = 6;
  } else if (this._modelType === PrecisionModel.FIXED) {
    maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
  }
  return maxSigDigits;
};
PrecisionModel.prototype.setScale = function setScale(scale4) {
  this._scale = Math.abs(scale4);
};
PrecisionModel.prototype.interfaces_ = function interfaces_45() {
  return [Serializable, Comparable];
};
PrecisionModel.prototype.getClass = function getClass44() {
  return PrecisionModel;
};
PrecisionModel.mostPrecise = function mostPrecise(pm1, pm2) {
  if (pm1.compareTo(pm2) >= 0) {
    return pm1;
  }
  return pm2;
};
staticAccessors$19.serialVersionUID.get = function() {
  return 7777263578777804e3;
};
staticAccessors$19.maximumPreciseValue.get = function() {
  return 9007199254740992;
};
Object.defineProperties(PrecisionModel, staticAccessors$19);
var Type = function Type2(name) {
  this._name = name || null;
  Type2.nameToTypeMap.put(name, this);
};
var staticAccessors$1$1 = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
Type.prototype.readResolve = function readResolve2() {
  return Type.nameToTypeMap.get(this._name);
};
Type.prototype.toString = function toString10() {
  return this._name;
};
Type.prototype.interfaces_ = function interfaces_46() {
  return [Serializable];
};
Type.prototype.getClass = function getClass45() {
  return Type;
};
staticAccessors$1$1.serialVersionUID.get = function() {
  return -552860263173159e4;
};
staticAccessors$1$1.nameToTypeMap.get = function() {
  return new HashMap();
};
Object.defineProperties(Type, staticAccessors$1$1);
PrecisionModel.Type = Type;
PrecisionModel.FIXED = new Type("FIXED");
PrecisionModel.FLOATING = new Type("FLOATING");
PrecisionModel.FLOATING_SINGLE = new Type("FLOATING SINGLE");
var GeometryFactory = function GeometryFactory2() {
  this._precisionModel = new PrecisionModel();
  this._SRID = 0;
  this._coordinateSequenceFactory = GeometryFactory2.getDefaultCoordinateSequenceFactory();
  if (arguments.length === 0) {
  } else if (arguments.length === 1) {
    if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
      this._coordinateSequenceFactory = arguments[0];
    } else if (arguments[0] instanceof PrecisionModel) {
      this._precisionModel = arguments[0];
    }
  } else if (arguments.length === 2) {
    this._precisionModel = arguments[0];
    this._SRID = arguments[1];
  } else if (arguments.length === 3) {
    this._precisionModel = arguments[0];
    this._SRID = arguments[1];
    this._coordinateSequenceFactory = arguments[2];
  }
};
var staticAccessors$2 = { serialVersionUID: { configurable: true } };
GeometryFactory.prototype.toGeometry = function toGeometry(envelope3) {
  if (envelope3.isNull()) {
    return this.createPoint(null);
  }
  if (envelope3.getMinX() === envelope3.getMaxX() && envelope3.getMinY() === envelope3.getMaxY()) {
    return this.createPoint(new Coordinate(envelope3.getMinX(), envelope3.getMinY()));
  }
  if (envelope3.getMinX() === envelope3.getMaxX() || envelope3.getMinY() === envelope3.getMaxY()) {
    return this.createLineString([new Coordinate(envelope3.getMinX(), envelope3.getMinY()), new Coordinate(envelope3.getMaxX(), envelope3.getMaxY())]);
  }
  return this.createPolygon(this.createLinearRing([new Coordinate(envelope3.getMinX(), envelope3.getMinY()), new Coordinate(envelope3.getMinX(), envelope3.getMaxY()), new Coordinate(envelope3.getMaxX(), envelope3.getMaxY()), new Coordinate(envelope3.getMaxX(), envelope3.getMinY()), new Coordinate(envelope3.getMinX(), envelope3.getMinY())]), null);
};
GeometryFactory.prototype.createLineString = function createLineString(coordinates) {
  if (!coordinates) {
    return new LineString2(this.getCoordinateSequenceFactory().create([]), this);
  } else if (coordinates instanceof Array) {
    return new LineString2(this.getCoordinateSequenceFactory().create(coordinates), this);
  } else if (hasInterface(coordinates, CoordinateSequence)) {
    return new LineString2(coordinates, this);
  }
};
GeometryFactory.prototype.createMultiLineString = function createMultiLineString() {
  if (arguments.length === 0) {
    return new MultiLineString(null, this);
  } else if (arguments.length === 1) {
    var lineStrings2 = arguments[0];
    return new MultiLineString(lineStrings2, this);
  }
};
GeometryFactory.prototype.buildGeometry = function buildGeometry(geomList) {
  var geomClass = null;
  var isHeterogeneous = false;
  var hasGeometryCollection = false;
  for (var i = geomList.iterator(); i.hasNext(); ) {
    var geom = i.next();
    var partClass = geom.getClass();
    if (geomClass === null) {
      geomClass = partClass;
    }
    if (partClass !== geomClass) {
      isHeterogeneous = true;
    }
    if (geom.isGeometryCollectionOrDerived()) {
      hasGeometryCollection = true;
    }
  }
  if (geomClass === null) {
    return this.createGeometryCollection();
  }
  if (isHeterogeneous || hasGeometryCollection) {
    return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
  }
  var geom0 = geomList.iterator().next();
  var isCollection = geomList.size() > 1;
  if (isCollection) {
    if (geom0 instanceof Polygon) {
      return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
    } else if (geom0 instanceof LineString2) {
      return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
    } else if (geom0 instanceof Point) {
      return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
    }
    Assert.shouldNeverReachHere("Unhandled class: " + geom0.getClass().getName());
  }
  return geom0;
};
GeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords(coordinates) {
  return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
};
GeometryFactory.prototype.createPoint = function createPoint() {
  if (arguments.length === 0) {
    return this.createPoint(this.getCoordinateSequenceFactory().create([]));
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      var coordinate2 = arguments[0];
      return this.createPoint(coordinate2 !== null ? this.getCoordinateSequenceFactory().create([coordinate2]) : null);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates = arguments[0];
      return new Point(coordinates, this);
    }
  }
};
GeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory() {
  return this._coordinateSequenceFactory;
};
GeometryFactory.prototype.createPolygon = function createPolygon() {
  if (arguments.length === 0) {
    return new Polygon(null, null, this);
  } else if (arguments.length === 1) {
    if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates = arguments[0];
      return this.createPolygon(this.createLinearRing(coordinates));
    } else if (arguments[0] instanceof Array) {
      var coordinates$1 = arguments[0];
      return this.createPolygon(this.createLinearRing(coordinates$1));
    } else if (arguments[0] instanceof LinearRing) {
      var shell = arguments[0];
      return this.createPolygon(shell, null);
    }
  } else if (arguments.length === 2) {
    var shell$1 = arguments[0];
    var holes = arguments[1];
    return new Polygon(shell$1, holes, this);
  }
};
GeometryFactory.prototype.getSRID = function getSRID2() {
  return this._SRID;
};
GeometryFactory.prototype.createGeometryCollection = function createGeometryCollection() {
  if (arguments.length === 0) {
    return new GeometryCollection(null, this);
  } else if (arguments.length === 1) {
    var geometries = arguments[0];
    return new GeometryCollection(geometries, this);
  }
};
GeometryFactory.prototype.createGeometry = function createGeometry(g) {
  var editor = new GeometryEditor(this);
  return editor.edit(g, {
    edit: function() {
      if (arguments.length === 2) {
        var coordSeq = arguments[0];
        return this._coordinateSequenceFactory.create(coordSeq);
      }
    }
  });
};
GeometryFactory.prototype.getPrecisionModel = function getPrecisionModel2() {
  return this._precisionModel;
};
GeometryFactory.prototype.createLinearRing = function createLinearRing() {
  if (arguments.length === 0) {
    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var coordinates = arguments[0];
      return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates$1 = arguments[0];
      return new LinearRing(coordinates$1, this);
    }
  }
};
GeometryFactory.prototype.createMultiPolygon = function createMultiPolygon() {
  if (arguments.length === 0) {
    return new MultiPolygon(null, this);
  } else if (arguments.length === 1) {
    var polygons2 = arguments[0];
    return new MultiPolygon(polygons2, this);
  }
};
GeometryFactory.prototype.createMultiPoint = function createMultiPoint() {
  var this$1 = this;
  if (arguments.length === 0) {
    return new MultiPoint(null, this);
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var point4 = arguments[0];
      return new MultiPoint(point4, this);
    } else if (arguments[0] instanceof Array) {
      var coordinates = arguments[0];
      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      var coordinates$1 = arguments[0];
      if (coordinates$1 === null) {
        return this.createMultiPoint(new Array(0).fill(null));
      }
      var points2 = new Array(coordinates$1.size()).fill(null);
      for (var i = 0; i < coordinates$1.size(); i++) {
        var ptSeq = this$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());
        CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);
        points2[i] = this$1.createPoint(ptSeq);
      }
      return this.createMultiPoint(points2);
    }
  }
};
GeometryFactory.prototype.interfaces_ = function interfaces_47() {
  return [Serializable];
};
GeometryFactory.prototype.getClass = function getClass46() {
  return GeometryFactory;
};
GeometryFactory.toMultiPolygonArray = function toMultiPolygonArray(multiPolygons) {
  var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
  return multiPolygons.toArray(multiPolygonArray);
};
GeometryFactory.toGeometryArray = function toGeometryArray(geometries) {
  if (geometries === null) {
    return null;
  }
  var geometryArray = new Array(geometries.size()).fill(null);
  return geometries.toArray(geometryArray);
};
GeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory() {
  return CoordinateArraySequenceFactory.instance();
};
GeometryFactory.toMultiLineStringArray = function toMultiLineStringArray(multiLineStrings) {
  var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
  return multiLineStrings.toArray(multiLineStringArray);
};
GeometryFactory.toLineStringArray = function toLineStringArray(lineStrings2) {
  var lineStringArray = new Array(lineStrings2.size()).fill(null);
  return lineStrings2.toArray(lineStringArray);
};
GeometryFactory.toMultiPointArray = function toMultiPointArray(multiPoints) {
  var multiPointArray = new Array(multiPoints.size()).fill(null);
  return multiPoints.toArray(multiPointArray);
};
GeometryFactory.toLinearRingArray = function toLinearRingArray(linearRings) {
  var linearRingArray = new Array(linearRings.size()).fill(null);
  return linearRings.toArray(linearRingArray);
};
GeometryFactory.toPointArray = function toPointArray(points2) {
  var pointArray = new Array(points2.size()).fill(null);
  return points2.toArray(pointArray);
};
GeometryFactory.toPolygonArray = function toPolygonArray(polygons2) {
  var polygonArray = new Array(polygons2.size()).fill(null);
  return polygons2.toArray(polygonArray);
};
GeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord(coord, exemplar) {
  exemplar.getPrecisionModel().makePrecise(coord);
  return exemplar.getFactory().createPoint(coord);
};
staticAccessors$2.serialVersionUID.get = function() {
  return -6820524753094096e3;
};
Object.defineProperties(GeometryFactory, staticAccessors$2);
var geometryTypes = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];
var GeoJSONParser = function GeoJSONParser2(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
};
GeoJSONParser.prototype.read = function read2(json) {
  var obj;
  if (typeof json === "string") {
    obj = JSON.parse(json);
  } else {
    obj = json;
  }
  var type = obj.type;
  if (!parse2[type]) {
    throw new Error("Unknown GeoJSON type: " + obj.type);
  }
  if (geometryTypes.indexOf(type) !== -1) {
    return parse2[type].apply(this, [obj.coordinates]);
  } else if (type === "GeometryCollection") {
    return parse2[type].apply(this, [obj.geometries]);
  }
  return parse2[type].apply(this, [obj]);
};
GeoJSONParser.prototype.write = function write3(geometry2) {
  var type = geometry2.getGeometryType();
  if (!extract2[type]) {
    throw new Error("Geometry is not supported");
  }
  return extract2[type].apply(this, [geometry2]);
};
var parse2 = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function(obj) {
    var feature2 = {};
    for (var key in obj) {
      feature2[key] = obj[key];
    }
    if (obj.geometry) {
      var type = obj.geometry.type;
      if (!parse2[type]) {
        throw new Error("Unknown GeoJSON type: " + obj.type);
      }
      feature2.geometry = this.read(obj.geometry);
    }
    if (obj.bbox) {
      feature2.bbox = parse2.bbox.apply(this, [obj.bbox]);
    }
    return feature2;
  },
  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function(obj) {
    var this$1 = this;
    var featureCollection2 = {};
    if (obj.features) {
      featureCollection2.features = [];
      for (var i = 0; i < obj.features.length; ++i) {
        featureCollection2.features.push(this$1.read(obj.features[i]));
      }
    }
    if (obj.bbox) {
      featureCollection2.bbox = this.parse.bbox.apply(this, [obj.bbox]);
    }
    return featureCollection2;
  },
  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function(array) {
    var coordinates = [];
    for (var i = 0; i < array.length; ++i) {
      var sub2 = array[i];
      coordinates.push(new Coordinate(sub2[0], sub2[1]));
    }
    return coordinates;
  },
  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function(array) {
    return this.geometryFactory.createLinearRing([
      new Coordinate(array[0], array[1]),
      new Coordinate(array[2], array[1]),
      new Coordinate(array[2], array[3]),
      new Coordinate(array[0], array[3]),
      new Coordinate(array[0], array[1])
    ]);
  },
  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function(array) {
    var coordinate2 = new Coordinate(array[0], array[1]);
    return this.geometryFactory.createPoint(coordinate2);
  },
  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function(array) {
    var this$1 = this;
    var points2 = [];
    for (var i = 0; i < array.length; ++i) {
      points2.push(parse2.Point.apply(this$1, [array[i]]));
    }
    return this.geometryFactory.createMultiPoint(points2);
  },
  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function(array) {
    var coordinates = parse2.coordinates.apply(this, [array]);
    return this.geometryFactory.createLineString(coordinates);
  },
  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function(array) {
    var this$1 = this;
    var lineStrings2 = [];
    for (var i = 0; i < array.length; ++i) {
      lineStrings2.push(parse2.LineString.apply(this$1, [array[i]]));
    }
    return this.geometryFactory.createMultiLineString(lineStrings2);
  },
  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function(array) {
    var this$1 = this;
    var shellCoordinates = parse2.coordinates.apply(this, [array[0]]);
    var shell = this.geometryFactory.createLinearRing(shellCoordinates);
    var holes = [];
    for (var i = 1; i < array.length; ++i) {
      var hole = array[i];
      var coordinates = parse2.coordinates.apply(this$1, [hole]);
      var linearRing = this$1.geometryFactory.createLinearRing(coordinates);
      holes.push(linearRing);
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },
  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function(array) {
    var this$1 = this;
    var polygons2 = [];
    for (var i = 0; i < array.length; ++i) {
      var polygon4 = array[i];
      polygons2.push(parse2.Polygon.apply(this$1, [polygon4]));
    }
    return this.geometryFactory.createMultiPolygon(polygons2);
  },
  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function(array) {
    var this$1 = this;
    var geometries = [];
    for (var i = 0; i < array.length; ++i) {
      var geometry2 = array[i];
      geometries.push(this$1.read(geometry2));
    }
    return this.geometryFactory.createGeometryCollection(geometries);
  }
};
var extract2 = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function(coordinate2) {
    return [coordinate2.x, coordinate2.y];
  },
  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function(point4) {
    var array = extract2.coordinate.apply(this, [point4.getCoordinate()]);
    return {
      type: "Point",
      coordinates: array
    };
  },
  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function(multipoint3) {
    var this$1 = this;
    var array = [];
    for (var i = 0; i < multipoint3._geometries.length; ++i) {
      var point4 = multipoint3._geometries[i];
      var geoJson = extract2.Point.apply(this$1, [point4]);
      array.push(geoJson.coordinates);
    }
    return {
      type: "MultiPoint",
      coordinates: array
    };
  },
  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function(linestring3) {
    var this$1 = this;
    var array = [];
    var coordinates = linestring3.getCoordinates();
    for (var i = 0; i < coordinates.length; ++i) {
      var coordinate2 = coordinates[i];
      array.push(extract2.coordinate.apply(this$1, [coordinate2]));
    }
    return {
      type: "LineString",
      coordinates: array
    };
  },
  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function(multilinestring3) {
    var this$1 = this;
    var array = [];
    for (var i = 0; i < multilinestring3._geometries.length; ++i) {
      var linestring3 = multilinestring3._geometries[i];
      var geoJson = extract2.LineString.apply(this$1, [linestring3]);
      array.push(geoJson.coordinates);
    }
    return {
      type: "MultiLineString",
      coordinates: array
    };
  },
  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function(polygon4) {
    var this$1 = this;
    var array = [];
    var shellGeoJson = extract2.LineString.apply(this, [polygon4._shell]);
    array.push(shellGeoJson.coordinates);
    for (var i = 0; i < polygon4._holes.length; ++i) {
      var hole = polygon4._holes[i];
      var holeGeoJson = extract2.LineString.apply(this$1, [hole]);
      array.push(holeGeoJson.coordinates);
    }
    return {
      type: "Polygon",
      coordinates: array
    };
  },
  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function(multipolygon3) {
    var this$1 = this;
    var array = [];
    for (var i = 0; i < multipolygon3._geometries.length; ++i) {
      var polygon4 = multipolygon3._geometries[i];
      var geoJson = extract2.Polygon.apply(this$1, [polygon4]);
      array.push(geoJson.coordinates);
    }
    return {
      type: "MultiPolygon",
      coordinates: array
    };
  },
  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function(collection) {
    var this$1 = this;
    var array = [];
    for (var i = 0; i < collection._geometries.length; ++i) {
      var geometry2 = collection._geometries[i];
      var type = geometry2.getGeometryType();
      array.push(extract2[type].apply(this$1, [geometry2]));
    }
    return {
      type: "GeometryCollection",
      geometries: array
    };
  }
};
var GeoJSONReader = function GeoJSONReader2(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
  this.precisionModel = this.geometryFactory.getPrecisionModel();
  this.parser = new GeoJSONParser(this.geometryFactory);
};
GeoJSONReader.prototype.read = function read3(geoJson) {
  var geometry2 = this.parser.read(geoJson);
  if (this.precisionModel.getType() === PrecisionModel.FIXED) {
    this.reducePrecision(geometry2);
  }
  return geometry2;
};
GeoJSONReader.prototype.reducePrecision = function reducePrecision(geometry2) {
  var this$1 = this;
  var i, len;
  if (geometry2.coordinate) {
    this.precisionModel.makePrecise(geometry2.coordinate);
  } else if (geometry2.points) {
    for (i = 0, len = geometry2.points.length; i < len; i++) {
      this$1.precisionModel.makePrecise(geometry2.points[i]);
    }
  } else if (geometry2.geometries) {
    for (i = 0, len = geometry2.geometries.length; i < len; i++) {
      this$1.reducePrecision(geometry2.geometries[i]);
    }
  }
};
var GeoJSONWriter = function GeoJSONWriter2() {
  this.parser = new GeoJSONParser(this.geometryFactory);
};
GeoJSONWriter.prototype.write = function write4(geometry2) {
  return this.parser.write(geometry2);
};
var Position = function Position2() {
};
var staticAccessors$20 = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
Position.prototype.interfaces_ = function interfaces_48() {
  return [];
};
Position.prototype.getClass = function getClass47() {
  return Position;
};
Position.opposite = function opposite(position) {
  if (position === Position.LEFT) {
    return Position.RIGHT;
  }
  if (position === Position.RIGHT) {
    return Position.LEFT;
  }
  return position;
};
staticAccessors$20.ON.get = function() {
  return 0;
};
staticAccessors$20.LEFT.get = function() {
  return 1;
};
staticAccessors$20.RIGHT.get = function() {
  return 2;
};
Object.defineProperties(Position, staticAccessors$20);
function EmptyStackException(message) {
  this.message = message || "";
}
EmptyStackException.prototype = new Error();
EmptyStackException.prototype.name = "EmptyStackException";
function Stack() {
  this.array_ = [];
}
Stack.prototype = new List();
Stack.prototype.add = function(e) {
  this.array_.push(e);
  return true;
};
Stack.prototype.get = function(index2) {
  if (index2 < 0 || index2 >= this.size()) {
    throw new Error();
  }
  return this.array_[index2];
};
Stack.prototype.push = function(e) {
  this.array_.push(e);
  return e;
};
Stack.prototype.pop = function(e) {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }
  return this.array_.pop();
};
Stack.prototype.peek = function() {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }
  return this.array_[this.array_.length - 1];
};
Stack.prototype.empty = function() {
  if (this.array_.length === 0) {
    return true;
  } else {
    return false;
  }
};
Stack.prototype.isEmpty = function() {
  return this.empty();
};
Stack.prototype.search = function(o) {
  return this.array_.indexOf(o);
};
Stack.prototype.size = function() {
  return this.array_.length;
};
Stack.prototype.toArray = function() {
  var this$1 = this;
  var array = [];
  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this$1.array_[i]);
  }
  return array;
};
var RightmostEdgeFinder = function RightmostEdgeFinder2() {
  this._minIndex = -1;
  this._minCoord = null;
  this._minDe = null;
  this._orientedDe = null;
};
RightmostEdgeFinder.prototype.getCoordinate = function getCoordinate4() {
  return this._minCoord;
};
RightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide(de, index2) {
  var side = this.getRightmostSideOfSegment(de, index2);
  if (side < 0) {
    side = this.getRightmostSideOfSegment(de, index2 - 1);
  }
  if (side < 0) {
    this._minCoord = null;
    this.checkForRightmostCoordinate(de);
  }
  return side;
};
RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex() {
  var pts = this._minDe.getEdge().getCoordinates();
  Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, "rightmost point expected to be interior vertex of edge");
  var pPrev = pts[this._minIndex - 1];
  var pNext = pts[this._minIndex + 1];
  var orientation2 = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);
  var usePrev = false;
  if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation2 === CGAlgorithms.COUNTERCLOCKWISE) {
    usePrev = true;
  } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation2 === CGAlgorithms.CLOCKWISE) {
    usePrev = true;
  }
  if (usePrev) {
    this._minIndex = this._minIndex - 1;
  }
};
RightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment(de, i) {
  var e = de.getEdge();
  var coord = e.getCoordinates();
  if (i < 0 || i + 1 >= coord.length) {
    return -1;
  }
  if (coord[i].y === coord[i + 1].y) {
    return -1;
  }
  var pos = Position.LEFT;
  if (coord[i].y < coord[i + 1].y) {
    pos = Position.RIGHT;
  }
  return pos;
};
RightmostEdgeFinder.prototype.getEdge = function getEdge() {
  return this._orientedDe;
};
RightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate(de) {
  var this$1 = this;
  var coord = de.getEdge().getCoordinates();
  for (var i = 0; i < coord.length - 1; i++) {
    if (this$1._minCoord === null || coord[i].x > this$1._minCoord.x) {
      this$1._minDe = de;
      this$1._minIndex = i;
      this$1._minCoord = coord[i];
    }
  }
};
RightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode() {
  var node = this._minDe.getNode();
  var star = node.getEdges();
  this._minDe = star.getRightmostEdge();
  if (!this._minDe.isForward()) {
    this._minDe = this._minDe.getSym();
    this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
  }
};
RightmostEdgeFinder.prototype.findEdge = function findEdge(dirEdgeList) {
  var this$1 = this;
  for (var i = dirEdgeList.iterator(); i.hasNext(); ) {
    var de = i.next();
    if (!de.isForward()) {
      continue;
    }
    this$1.checkForRightmostCoordinate(de);
  }
  Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing");
  if (this._minIndex === 0) {
    this.findRightmostEdgeAtNode();
  } else {
    this.findRightmostEdgeAtVertex();
  }
  this._orientedDe = this._minDe;
  var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
  if (rightmostSide === Position.LEFT) {
    this._orientedDe = this._minDe.getSym();
  }
};
RightmostEdgeFinder.prototype.interfaces_ = function interfaces_49() {
  return [];
};
RightmostEdgeFinder.prototype.getClass = function getClass48() {
  return RightmostEdgeFinder;
};
var TopologyException = function(RuntimeException$$1) {
  function TopologyException2(msg, pt) {
    RuntimeException$$1.call(this, TopologyException2.msgWithCoord(msg, pt));
    this.pt = pt ? new Coordinate(pt) : null;
    this.name = "TopologyException";
  }
  if (RuntimeException$$1)
    TopologyException2.__proto__ = RuntimeException$$1;
  TopologyException2.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);
  TopologyException2.prototype.constructor = TopologyException2;
  TopologyException2.prototype.getCoordinate = function getCoordinate18() {
    return this.pt;
  };
  TopologyException2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  TopologyException2.prototype.getClass = function getClass169() {
    return TopologyException2;
  };
  TopologyException2.msgWithCoord = function msgWithCoord(msg, pt) {
    if (!pt) {
      return msg + " [ " + pt + " ]";
    }
    return msg;
  };
  return TopologyException2;
}(RuntimeException);
var LinkedList = function LinkedList2() {
  this.array_ = [];
};
LinkedList.prototype.addLast = function addLast(e) {
  this.array_.push(e);
};
LinkedList.prototype.removeFirst = function removeFirst() {
  return this.array_.shift();
};
LinkedList.prototype.isEmpty = function isEmpty2() {
  return this.array_.length === 0;
};
var BufferSubgraph = function BufferSubgraph2() {
  this._finder = null;
  this._dirEdgeList = new ArrayList();
  this._nodes = new ArrayList();
  this._rightMostCoord = null;
  this._env = null;
  this._finder = new RightmostEdgeFinder();
};
BufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges() {
  for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
    var de = it.next();
    de.setVisited(false);
  }
};
BufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate() {
  return this._rightMostCoord;
};
BufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth(n) {
  var this$1 = this;
  var startEdge = null;
  for (var i = n.getEdges().iterator(); i.hasNext(); ) {
    var de = i.next();
    if (de.isVisited() || de.getSym().isVisited()) {
      startEdge = de;
      break;
    }
  }
  if (startEdge === null) {
    throw new TopologyException("unable to find edge to compute depths at " + n.getCoordinate());
  }
  n.getEdges().computeDepths(startEdge);
  for (var i$1 = n.getEdges().iterator(); i$1.hasNext(); ) {
    var de$1 = i$1.next();
    de$1.setVisited(true);
    this$1.copySymDepths(de$1);
  }
};
BufferSubgraph.prototype.computeDepth = function computeDepth(outsideDepth) {
  this.clearVisitedEdges();
  var de = this._finder.getEdge();
  de.setEdgeDepths(Position.RIGHT, outsideDepth);
  this.copySymDepths(de);
  this.computeDepths(de);
};
BufferSubgraph.prototype.create = function create3(node) {
  this.addReachable(node);
  this._finder.findEdge(this._dirEdgeList);
  this._rightMostCoord = this._finder.getCoordinate();
};
BufferSubgraph.prototype.findResultEdges = function findResultEdges() {
  for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
    var de = it.next();
    if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
      de.setInResult(true);
    }
  }
};
BufferSubgraph.prototype.computeDepths = function computeDepths(startEdge) {
  var this$1 = this;
  var nodesVisited = new HashSet();
  var nodeQueue = new LinkedList();
  var startNode = startEdge.getNode();
  nodeQueue.addLast(startNode);
  nodesVisited.add(startNode);
  startEdge.setVisited(true);
  while (!nodeQueue.isEmpty()) {
    var n = nodeQueue.removeFirst();
    nodesVisited.add(n);
    this$1.computeNodeDepth(n);
    for (var i = n.getEdges().iterator(); i.hasNext(); ) {
      var de = i.next();
      var sym = de.getSym();
      if (sym.isVisited()) {
        continue;
      }
      var adjNode = sym.getNode();
      if (!nodesVisited.contains(adjNode)) {
        nodeQueue.addLast(adjNode);
        nodesVisited.add(adjNode);
      }
    }
  }
};
BufferSubgraph.prototype.compareTo = function compareTo7(o) {
  var graph = o;
  if (this._rightMostCoord.x < graph._rightMostCoord.x) {
    return -1;
  }
  if (this._rightMostCoord.x > graph._rightMostCoord.x) {
    return 1;
  }
  return 0;
};
BufferSubgraph.prototype.getEnvelope = function getEnvelope2() {
  if (this._env === null) {
    var edgeEnv = new Envelope();
    for (var it = this._dirEdgeList.iterator(); it.hasNext(); ) {
      var dirEdge = it.next();
      var pts = dirEdge.getEdge().getCoordinates();
      for (var i = 0; i < pts.length - 1; i++) {
        edgeEnv.expandToInclude(pts[i]);
      }
    }
    this._env = edgeEnv;
  }
  return this._env;
};
BufferSubgraph.prototype.addReachable = function addReachable(startNode) {
  var this$1 = this;
  var nodeStack = new Stack();
  nodeStack.add(startNode);
  while (!nodeStack.empty()) {
    var node = nodeStack.pop();
    this$1.add(node, nodeStack);
  }
};
BufferSubgraph.prototype.copySymDepths = function copySymDepths(de) {
  var sym = de.getSym();
  sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
  sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
};
BufferSubgraph.prototype.add = function add4(node, nodeStack) {
  var this$1 = this;
  node.setVisited(true);
  this._nodes.add(node);
  for (var i = node.getEdges().iterator(); i.hasNext(); ) {
    var de = i.next();
    this$1._dirEdgeList.add(de);
    var sym = de.getSym();
    var symNode = sym.getNode();
    if (!symNode.isVisited()) {
      nodeStack.push(symNode);
    }
  }
};
BufferSubgraph.prototype.getNodes = function getNodes() {
  return this._nodes;
};
BufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges() {
  return this._dirEdgeList;
};
BufferSubgraph.prototype.interfaces_ = function interfaces_50() {
  return [Comparable];
};
BufferSubgraph.prototype.getClass = function getClass49() {
  return BufferSubgraph;
};
var TopologyLocation = function TopologyLocation2() {
  var this$1 = this;
  this.location = null;
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var location = arguments[0];
      this.init(location.length);
    } else if (Number.isInteger(arguments[0])) {
      var on = arguments[0];
      this.init(1);
      this.location[Position.ON] = on;
    } else if (arguments[0] instanceof TopologyLocation2) {
      var gl = arguments[0];
      this.init(gl.location.length);
      if (gl !== null) {
        for (var i = 0; i < this.location.length; i++) {
          this$1.location[i] = gl.location[i];
        }
      }
    }
  } else if (arguments.length === 3) {
    var on$1 = arguments[0];
    var left = arguments[1];
    var right = arguments[2];
    this.init(3);
    this.location[Position.ON] = on$1;
    this.location[Position.LEFT] = left;
    this.location[Position.RIGHT] = right;
  }
};
TopologyLocation.prototype.setAllLocations = function setAllLocations(locValue) {
  var this$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    this$1.location[i] = locValue;
  }
};
TopologyLocation.prototype.isNull = function isNull2() {
  var this$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1.location[i] !== Location.NONE) {
      return false;
    }
  }
  return true;
};
TopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull(locValue) {
  var this$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1.location[i] === Location.NONE) {
      this$1.location[i] = locValue;
    }
  }
};
TopologyLocation.prototype.isLine = function isLine() {
  return this.location.length === 1;
};
TopologyLocation.prototype.merge = function merge2(gl) {
  var this$1 = this;
  if (gl.location.length > this.location.length) {
    var newLoc = new Array(3).fill(null);
    newLoc[Position.ON] = this.location[Position.ON];
    newLoc[Position.LEFT] = Location.NONE;
    newLoc[Position.RIGHT] = Location.NONE;
    this.location = newLoc;
  }
  for (var i = 0; i < this.location.length; i++) {
    if (this$1.location[i] === Location.NONE && i < gl.location.length) {
      this$1.location[i] = gl.location[i];
    }
  }
};
TopologyLocation.prototype.getLocations = function getLocations() {
  return this.location;
};
TopologyLocation.prototype.flip = function flip2() {
  if (this.location.length <= 1) {
    return null;
  }
  var temp = this.location[Position.LEFT];
  this.location[Position.LEFT] = this.location[Position.RIGHT];
  this.location[Position.RIGHT] = temp;
};
TopologyLocation.prototype.toString = function toString11() {
  var buf = new StringBuffer();
  if (this.location.length > 1) {
    buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));
  }
  buf.append(Location.toLocationSymbol(this.location[Position.ON]));
  if (this.location.length > 1) {
    buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));
  }
  return buf.toString();
};
TopologyLocation.prototype.setLocations = function setLocations(on, left, right) {
  this.location[Position.ON] = on;
  this.location[Position.LEFT] = left;
  this.location[Position.RIGHT] = right;
};
TopologyLocation.prototype.get = function get2(posIndex) {
  if (posIndex < this.location.length) {
    return this.location[posIndex];
  }
  return Location.NONE;
};
TopologyLocation.prototype.isArea = function isArea() {
  return this.location.length > 1;
};
TopologyLocation.prototype.isAnyNull = function isAnyNull() {
  var this$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1.location[i] === Location.NONE) {
      return true;
    }
  }
  return false;
};
TopologyLocation.prototype.setLocation = function setLocation() {
  if (arguments.length === 1) {
    var locValue = arguments[0];
    this.setLocation(Position.ON, locValue);
  } else if (arguments.length === 2) {
    var locIndex = arguments[0];
    var locValue$1 = arguments[1];
    this.location[locIndex] = locValue$1;
  }
};
TopologyLocation.prototype.init = function init3(size11) {
  this.location = new Array(size11).fill(null);
  this.setAllLocations(Location.NONE);
};
TopologyLocation.prototype.isEqualOnSide = function isEqualOnSide(le2, locIndex) {
  return this.location[locIndex] === le2.location[locIndex];
};
TopologyLocation.prototype.allPositionsEqual = function allPositionsEqual(loc) {
  var this$1 = this;
  for (var i = 0; i < this.location.length; i++) {
    if (this$1.location[i] !== loc) {
      return false;
    }
  }
  return true;
};
TopologyLocation.prototype.interfaces_ = function interfaces_51() {
  return [];
};
TopologyLocation.prototype.getClass = function getClass50() {
  return TopologyLocation;
};
var Label = function Label2() {
  this.elt = new Array(2).fill(null);
  if (arguments.length === 1) {
    if (Number.isInteger(arguments[0])) {
      var onLoc = arguments[0];
      this.elt[0] = new TopologyLocation(onLoc);
      this.elt[1] = new TopologyLocation(onLoc);
    } else if (arguments[0] instanceof Label2) {
      var lbl = arguments[0];
      this.elt[0] = new TopologyLocation(lbl.elt[0]);
      this.elt[1] = new TopologyLocation(lbl.elt[1]);
    }
  } else if (arguments.length === 2) {
    var geomIndex = arguments[0];
    var onLoc$1 = arguments[1];
    this.elt[0] = new TopologyLocation(Location.NONE);
    this.elt[1] = new TopologyLocation(Location.NONE);
    this.elt[geomIndex].setLocation(onLoc$1);
  } else if (arguments.length === 3) {
    var onLoc$2 = arguments[0];
    var leftLoc = arguments[1];
    var rightLoc = arguments[2];
    this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
    this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);
  } else if (arguments.length === 4) {
    var geomIndex$1 = arguments[0];
    var onLoc$3 = arguments[1];
    var leftLoc$1 = arguments[2];
    var rightLoc$1 = arguments[3];
    this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
    this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
    this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);
  }
};
Label.prototype.getGeometryCount = function getGeometryCount() {
  var count2 = 0;
  if (!this.elt[0].isNull()) {
    count2++;
  }
  if (!this.elt[1].isNull()) {
    count2++;
  }
  return count2;
};
Label.prototype.setAllLocations = function setAllLocations2(geomIndex, location) {
  this.elt[geomIndex].setAllLocations(location);
};
Label.prototype.isNull = function isNull3(geomIndex) {
  return this.elt[geomIndex].isNull();
};
Label.prototype.setAllLocationsIfNull = function setAllLocationsIfNull2() {
  if (arguments.length === 1) {
    var location = arguments[0];
    this.setAllLocationsIfNull(0, location);
    this.setAllLocationsIfNull(1, location);
  } else if (arguments.length === 2) {
    var geomIndex = arguments[0];
    var location$1 = arguments[1];
    this.elt[geomIndex].setAllLocationsIfNull(location$1);
  }
};
Label.prototype.isLine = function isLine2(geomIndex) {
  return this.elt[geomIndex].isLine();
};
Label.prototype.merge = function merge3(lbl) {
  var this$1 = this;
  for (var i = 0; i < 2; i++) {
    if (this$1.elt[i] === null && lbl.elt[i] !== null) {
      this$1.elt[i] = new TopologyLocation(lbl.elt[i]);
    } else {
      this$1.elt[i].merge(lbl.elt[i]);
    }
  }
};
Label.prototype.flip = function flip3() {
  this.elt[0].flip();
  this.elt[1].flip();
};
Label.prototype.getLocation = function getLocation2() {
  if (arguments.length === 1) {
    var geomIndex = arguments[0];
    return this.elt[geomIndex].get(Position.ON);
  } else if (arguments.length === 2) {
    var geomIndex$1 = arguments[0];
    var posIndex = arguments[1];
    return this.elt[geomIndex$1].get(posIndex);
  }
};
Label.prototype.toString = function toString12() {
  var buf = new StringBuffer();
  if (this.elt[0] !== null) {
    buf.append("A:");
    buf.append(this.elt[0].toString());
  }
  if (this.elt[1] !== null) {
    buf.append(" B:");
    buf.append(this.elt[1].toString());
  }
  return buf.toString();
};
Label.prototype.isArea = function isArea2() {
  if (arguments.length === 0) {
    return this.elt[0].isArea() || this.elt[1].isArea();
  } else if (arguments.length === 1) {
    var geomIndex = arguments[0];
    return this.elt[geomIndex].isArea();
  }
};
Label.prototype.isAnyNull = function isAnyNull2(geomIndex) {
  return this.elt[geomIndex].isAnyNull();
};
Label.prototype.setLocation = function setLocation2() {
  if (arguments.length === 2) {
    var geomIndex = arguments[0];
    var location = arguments[1];
    this.elt[geomIndex].setLocation(Position.ON, location);
  } else if (arguments.length === 3) {
    var geomIndex$1 = arguments[0];
    var posIndex = arguments[1];
    var location$1 = arguments[2];
    this.elt[geomIndex$1].setLocation(posIndex, location$1);
  }
};
Label.prototype.isEqualOnSide = function isEqualOnSide2(lbl, side) {
  return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
};
Label.prototype.allPositionsEqual = function allPositionsEqual2(geomIndex, loc) {
  return this.elt[geomIndex].allPositionsEqual(loc);
};
Label.prototype.toLine = function toLine(geomIndex) {
  if (this.elt[geomIndex].isArea()) {
    this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);
  }
};
Label.prototype.interfaces_ = function interfaces_52() {
  return [];
};
Label.prototype.getClass = function getClass51() {
  return Label;
};
Label.toLineLabel = function toLineLabel(label) {
  var lineLabel = new Label(Location.NONE);
  for (var i = 0; i < 2; i++) {
    lineLabel.setLocation(i, label.getLocation(i));
  }
  return lineLabel;
};
var EdgeRing2 = function EdgeRing3() {
  this._startDe = null;
  this._maxNodeDegree = -1;
  this._edges = new ArrayList();
  this._pts = new ArrayList();
  this._label = new Label(Location.NONE);
  this._ring = null;
  this._isHole = null;
  this._shell = null;
  this._holes = new ArrayList();
  this._geometryFactory = null;
  var start = arguments[0];
  var geometryFactory = arguments[1];
  this._geometryFactory = geometryFactory;
  this.computePoints(start);
  this.computeRing();
};
EdgeRing2.prototype.computeRing = function computeRing() {
  var this$1 = this;
  if (this._ring !== null) {
    return null;
  }
  var coord = new Array(this._pts.size()).fill(null);
  for (var i = 0; i < this._pts.size(); i++) {
    coord[i] = this$1._pts.get(i);
  }
  this._ring = this._geometryFactory.createLinearRing(coord);
  this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());
};
EdgeRing2.prototype.isIsolated = function isIsolated() {
  return this._label.getGeometryCount() === 1;
};
EdgeRing2.prototype.computePoints = function computePoints(start) {
  var this$1 = this;
  this._startDe = start;
  var de = start;
  var isFirstEdge = true;
  do {
    if (de === null) {
      throw new TopologyException("Found null DirectedEdge");
    }
    if (de.getEdgeRing() === this$1) {
      throw new TopologyException("Directed Edge visited twice during ring-building at " + de.getCoordinate());
    }
    this$1._edges.add(de);
    var label = de.getLabel();
    Assert.isTrue(label.isArea());
    this$1.mergeLabel(label);
    this$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
    isFirstEdge = false;
    this$1.setEdgeRing(de, this$1);
    de = this$1.getNext(de);
  } while (de !== this._startDe);
};
EdgeRing2.prototype.getLinearRing = function getLinearRing() {
  return this._ring;
};
EdgeRing2.prototype.getCoordinate = function getCoordinate5(i) {
  return this._pts.get(i);
};
EdgeRing2.prototype.computeMaxNodeDegree = function computeMaxNodeDegree() {
  var this$1 = this;
  this._maxNodeDegree = 0;
  var de = this._startDe;
  do {
    var node = de.getNode();
    var degree = node.getEdges().getOutgoingDegree(this$1);
    if (degree > this$1._maxNodeDegree) {
      this$1._maxNodeDegree = degree;
    }
    de = this$1.getNext(de);
  } while (de !== this._startDe);
  this._maxNodeDegree *= 2;
};
EdgeRing2.prototype.addPoints = function addPoints(edge, isForward, isFirstEdge) {
  var this$1 = this;
  var edgePts = edge.getCoordinates();
  if (isForward) {
    var startIndex = 1;
    if (isFirstEdge) {
      startIndex = 0;
    }
    for (var i = startIndex; i < edgePts.length; i++) {
      this$1._pts.add(edgePts[i]);
    }
  } else {
    var startIndex$1 = edgePts.length - 2;
    if (isFirstEdge) {
      startIndex$1 = edgePts.length - 1;
    }
    for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {
      this$1._pts.add(edgePts[i$1]);
    }
  }
};
EdgeRing2.prototype.isHole = function isHole() {
  return this._isHole;
};
EdgeRing2.prototype.setInResult = function setInResult() {
  var de = this._startDe;
  do {
    de.getEdge().setInResult(true);
    de = de.getNext();
  } while (de !== this._startDe);
};
EdgeRing2.prototype.containsPoint = function containsPoint(p) {
  var shell = this.getLinearRing();
  var env = shell.getEnvelopeInternal();
  if (!env.contains(p)) {
    return false;
  }
  if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) {
    return false;
  }
  for (var i = this._holes.iterator(); i.hasNext(); ) {
    var hole = i.next();
    if (hole.containsPoint(p)) {
      return false;
    }
  }
  return true;
};
EdgeRing2.prototype.addHole = function addHole(ring) {
  this._holes.add(ring);
};
EdgeRing2.prototype.isShell = function isShell() {
  return this._shell === null;
};
EdgeRing2.prototype.getLabel = function getLabel() {
  return this._label;
};
EdgeRing2.prototype.getEdges = function getEdges() {
  return this._edges;
};
EdgeRing2.prototype.getMaxNodeDegree = function getMaxNodeDegree() {
  if (this._maxNodeDegree < 0) {
    this.computeMaxNodeDegree();
  }
  return this._maxNodeDegree;
};
EdgeRing2.prototype.getShell = function getShell() {
  return this._shell;
};
EdgeRing2.prototype.mergeLabel = function mergeLabel() {
  if (arguments.length === 1) {
    var deLabel = arguments[0];
    this.mergeLabel(deLabel, 0);
    this.mergeLabel(deLabel, 1);
  } else if (arguments.length === 2) {
    var deLabel$1 = arguments[0];
    var geomIndex = arguments[1];
    var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);
    if (loc === Location.NONE) {
      return null;
    }
    if (this._label.getLocation(geomIndex) === Location.NONE) {
      this._label.setLocation(geomIndex, loc);
      return null;
    }
  }
};
EdgeRing2.prototype.setShell = function setShell(shell) {
  this._shell = shell;
  if (shell !== null) {
    shell.addHole(this);
  }
};
EdgeRing2.prototype.toPolygon = function toPolygon(geometryFactory) {
  var this$1 = this;
  var holeLR = new Array(this._holes.size()).fill(null);
  for (var i = 0; i < this._holes.size(); i++) {
    holeLR[i] = this$1._holes.get(i).getLinearRing();
  }
  var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
  return poly;
};
EdgeRing2.prototype.interfaces_ = function interfaces_53() {
  return [];
};
EdgeRing2.prototype.getClass = function getClass52() {
  return EdgeRing2;
};
var MinimalEdgeRing = function(EdgeRing$$1) {
  function MinimalEdgeRing2() {
    var start = arguments[0];
    var geometryFactory = arguments[1];
    EdgeRing$$1.call(this, start, geometryFactory);
  }
  if (EdgeRing$$1)
    MinimalEdgeRing2.__proto__ = EdgeRing$$1;
  MinimalEdgeRing2.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
  MinimalEdgeRing2.prototype.constructor = MinimalEdgeRing2;
  MinimalEdgeRing2.prototype.setEdgeRing = function setEdgeRing(de, er) {
    de.setMinEdgeRing(er);
  };
  MinimalEdgeRing2.prototype.getNext = function getNext(de) {
    return de.getNextMin();
  };
  MinimalEdgeRing2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  MinimalEdgeRing2.prototype.getClass = function getClass169() {
    return MinimalEdgeRing2;
  };
  return MinimalEdgeRing2;
}(EdgeRing2);
var MaximalEdgeRing = function(EdgeRing$$1) {
  function MaximalEdgeRing2() {
    var start = arguments[0];
    var geometryFactory = arguments[1];
    EdgeRing$$1.call(this, start, geometryFactory);
  }
  if (EdgeRing$$1)
    MaximalEdgeRing2.__proto__ = EdgeRing$$1;
  MaximalEdgeRing2.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);
  MaximalEdgeRing2.prototype.constructor = MaximalEdgeRing2;
  MaximalEdgeRing2.prototype.buildMinimalRings = function buildMinimalRings() {
    var this$1 = this;
    var minEdgeRings = new ArrayList();
    var de = this._startDe;
    do {
      if (de.getMinEdgeRing() === null) {
        var minEr = new MinimalEdgeRing(de, this$1._geometryFactory);
        minEdgeRings.add(minEr);
      }
      de = de.getNext();
    } while (de !== this._startDe);
    return minEdgeRings;
  };
  MaximalEdgeRing2.prototype.setEdgeRing = function setEdgeRing(de, er) {
    de.setEdgeRing(er);
  };
  MaximalEdgeRing2.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings() {
    var this$1 = this;
    var de = this._startDe;
    do {
      var node = de.getNode();
      node.getEdges().linkMinimalDirectedEdges(this$1);
      de = de.getNext();
    } while (de !== this._startDe);
  };
  MaximalEdgeRing2.prototype.getNext = function getNext(de) {
    return de.getNext();
  };
  MaximalEdgeRing2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  MaximalEdgeRing2.prototype.getClass = function getClass169() {
    return MaximalEdgeRing2;
  };
  return MaximalEdgeRing2;
}(EdgeRing2);
var GraphComponent = function GraphComponent2() {
  this._label = null;
  this._isInResult = false;
  this._isCovered = false;
  this._isCoveredSet = false;
  this._isVisited = false;
  if (arguments.length === 0) {
  } else if (arguments.length === 1) {
    var label = arguments[0];
    this._label = label;
  }
};
GraphComponent.prototype.setVisited = function setVisited(isVisited2) {
  this._isVisited = isVisited2;
};
GraphComponent.prototype.setInResult = function setInResult2(isInResult2) {
  this._isInResult = isInResult2;
};
GraphComponent.prototype.isCovered = function isCovered() {
  return this._isCovered;
};
GraphComponent.prototype.isCoveredSet = function isCoveredSet() {
  return this._isCoveredSet;
};
GraphComponent.prototype.setLabel = function setLabel(label) {
  this._label = label;
};
GraphComponent.prototype.getLabel = function getLabel2() {
  return this._label;
};
GraphComponent.prototype.setCovered = function setCovered(isCovered2) {
  this._isCovered = isCovered2;
  this._isCoveredSet = true;
};
GraphComponent.prototype.updateIM = function updateIM(im) {
  Assert.isTrue(this._label.getGeometryCount() >= 2, "found partial label");
  this.computeIM(im);
};
GraphComponent.prototype.isInResult = function isInResult() {
  return this._isInResult;
};
GraphComponent.prototype.isVisited = function isVisited() {
  return this._isVisited;
};
GraphComponent.prototype.interfaces_ = function interfaces_54() {
  return [];
};
GraphComponent.prototype.getClass = function getClass53() {
  return GraphComponent;
};
var Node5 = function(GraphComponent$$1) {
  function Node6() {
    GraphComponent$$1.call(this);
    this._coord = null;
    this._edges = null;
    var coord = arguments[0];
    var edges2 = arguments[1];
    this._coord = coord;
    this._edges = edges2;
    this._label = new Label(0, Location.NONE);
  }
  if (GraphComponent$$1)
    Node6.__proto__ = GraphComponent$$1;
  Node6.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
  Node6.prototype.constructor = Node6;
  Node6.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult() {
    for (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {
      var de = it.next();
      if (de.getEdge().isInResult()) {
        return true;
      }
    }
    return false;
  };
  Node6.prototype.isIsolated = function isIsolated2() {
    return this._label.getGeometryCount() === 1;
  };
  Node6.prototype.getCoordinate = function getCoordinate18() {
    return this._coord;
  };
  Node6.prototype.print = function print9(out) {
    out.println("node " + this._coord + " lbl: " + this._label);
  };
  Node6.prototype.computeIM = function computeIM(im) {
  };
  Node6.prototype.computeMergedLocation = function computeMergedLocation(label2, eltIndex) {
    var loc = Location.NONE;
    loc = this._label.getLocation(eltIndex);
    if (!label2.isNull(eltIndex)) {
      var nLoc = label2.getLocation(eltIndex);
      if (loc !== Location.BOUNDARY) {
        loc = nLoc;
      }
    }
    return loc;
  };
  Node6.prototype.setLabel = function setLabel2() {
    if (arguments.length === 2) {
      var argIndex = arguments[0];
      var onLocation = arguments[1];
      if (this._label === null) {
        this._label = new Label(argIndex, onLocation);
      } else {
        this._label.setLocation(argIndex, onLocation);
      }
    } else {
      return GraphComponent$$1.prototype.setLabel.apply(this, arguments);
    }
  };
  Node6.prototype.getEdges = function getEdges4() {
    return this._edges;
  };
  Node6.prototype.mergeLabel = function mergeLabel2() {
    var this$1 = this;
    if (arguments[0] instanceof Node6) {
      var n = arguments[0];
      this.mergeLabel(n._label);
    } else if (arguments[0] instanceof Label) {
      var label2 = arguments[0];
      for (var i = 0; i < 2; i++) {
        var loc = this$1.computeMergedLocation(label2, i);
        var thisLoc = this$1._label.getLocation(i);
        if (thisLoc === Location.NONE) {
          this$1._label.setLocation(i, loc);
        }
      }
    }
  };
  Node6.prototype.add = function add16(e) {
    this._edges.insert(e);
    e.setNode(this);
  };
  Node6.prototype.setLabelBoundary = function setLabelBoundary(argIndex) {
    if (this._label === null) {
      return null;
    }
    var loc = Location.NONE;
    if (this._label !== null) {
      loc = this._label.getLocation(argIndex);
    }
    var newLoc = null;
    switch (loc) {
      case Location.BOUNDARY:
        newLoc = Location.INTERIOR;
        break;
      case Location.INTERIOR:
        newLoc = Location.BOUNDARY;
        break;
      default:
        newLoc = Location.BOUNDARY;
        break;
    }
    this._label.setLocation(argIndex, newLoc);
  };
  Node6.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  Node6.prototype.getClass = function getClass169() {
    return Node6;
  };
  return Node6;
}(GraphComponent);
var NodeMap = function NodeMap2() {
  this.nodeMap = new TreeMap();
  this.nodeFact = null;
  var nodeFact = arguments[0];
  this.nodeFact = nodeFact;
};
NodeMap.prototype.find = function find(coord) {
  return this.nodeMap.get(coord);
};
NodeMap.prototype.addNode = function addNode() {
  if (arguments[0] instanceof Coordinate) {
    var coord = arguments[0];
    var node = this.nodeMap.get(coord);
    if (node === null) {
      node = this.nodeFact.createNode(coord);
      this.nodeMap.put(coord, node);
    }
    return node;
  } else if (arguments[0] instanceof Node5) {
    var n = arguments[0];
    var node$1 = this.nodeMap.get(n.getCoordinate());
    if (node$1 === null) {
      this.nodeMap.put(n.getCoordinate(), n);
      return n;
    }
    node$1.mergeLabel(n);
    return node$1;
  }
};
NodeMap.prototype.print = function print(out) {
  for (var it = this.iterator(); it.hasNext(); ) {
    var n = it.next();
    n.print(out);
  }
};
NodeMap.prototype.iterator = function iterator2() {
  return this.nodeMap.values().iterator();
};
NodeMap.prototype.values = function values2() {
  return this.nodeMap.values();
};
NodeMap.prototype.getBoundaryNodes = function getBoundaryNodes(geomIndex) {
  var bdyNodes = new ArrayList();
  for (var i = this.iterator(); i.hasNext(); ) {
    var node = i.next();
    if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) {
      bdyNodes.add(node);
    }
  }
  return bdyNodes;
};
NodeMap.prototype.add = function add5(e) {
  var p = e.getCoordinate();
  var n = this.addNode(p);
  n.add(e);
};
NodeMap.prototype.interfaces_ = function interfaces_55() {
  return [];
};
NodeMap.prototype.getClass = function getClass54() {
  return NodeMap;
};
var Quadrant = function Quadrant2() {
};
var staticAccessors$21 = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
Quadrant.prototype.interfaces_ = function interfaces_56() {
  return [];
};
Quadrant.prototype.getClass = function getClass55() {
  return Quadrant;
};
Quadrant.isNorthern = function isNorthern(quad) {
  return quad === Quadrant.NE || quad === Quadrant.NW;
};
Quadrant.isOpposite = function isOpposite(quad1, quad2) {
  if (quad1 === quad2) {
    return false;
  }
  var diff2 = (quad1 - quad2 + 4) % 4;
  if (diff2 === 2) {
    return true;
  }
  return false;
};
Quadrant.commonHalfPlane = function commonHalfPlane(quad1, quad2) {
  if (quad1 === quad2) {
    return quad1;
  }
  var diff2 = (quad1 - quad2 + 4) % 4;
  if (diff2 === 2) {
    return -1;
  }
  var min4 = quad1 < quad2 ? quad1 : quad2;
  var max3 = quad1 > quad2 ? quad1 : quad2;
  if (min4 === 0 && max3 === 3) {
    return 3;
  }
  return min4;
};
Quadrant.isInHalfPlane = function isInHalfPlane(quad, halfPlane) {
  if (halfPlane === Quadrant.SE) {
    return quad === Quadrant.SE || quad === Quadrant.SW;
  }
  return quad === halfPlane || quad === halfPlane + 1;
};
Quadrant.quadrant = function quadrant() {
  if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
    var dx = arguments[0];
    var dy = arguments[1];
    if (dx === 0 && dy === 0) {
      throw new IllegalArgumentException("Cannot compute the quadrant for point ( " + dx + ", " + dy + " )");
    }
    if (dx >= 0) {
      if (dy >= 0) {
        return Quadrant.NE;
      } else {
        return Quadrant.SE;
      }
    } else {
      if (dy >= 0) {
        return Quadrant.NW;
      } else {
        return Quadrant.SW;
      }
    }
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (p1.x === p0.x && p1.y === p0.y) {
      throw new IllegalArgumentException("Cannot compute the quadrant for two identical points " + p0);
    }
    if (p1.x >= p0.x) {
      if (p1.y >= p0.y) {
        return Quadrant.NE;
      } else {
        return Quadrant.SE;
      }
    } else {
      if (p1.y >= p0.y) {
        return Quadrant.NW;
      } else {
        return Quadrant.SW;
      }
    }
  }
};
staticAccessors$21.NE.get = function() {
  return 0;
};
staticAccessors$21.NW.get = function() {
  return 1;
};
staticAccessors$21.SW.get = function() {
  return 2;
};
staticAccessors$21.SE.get = function() {
  return 3;
};
Object.defineProperties(Quadrant, staticAccessors$21);
var EdgeEnd = function EdgeEnd2() {
  this._edge = null;
  this._label = null;
  this._node = null;
  this._p0 = null;
  this._p1 = null;
  this._dx = null;
  this._dy = null;
  this._quadrant = null;
  if (arguments.length === 1) {
    var edge = arguments[0];
    this._edge = edge;
  } else if (arguments.length === 3) {
    var edge$1 = arguments[0];
    var p0 = arguments[1];
    var p1 = arguments[2];
    var label = null;
    this._edge = edge$1;
    this.init(p0, p1);
    this._label = label;
  } else if (arguments.length === 4) {
    var edge$2 = arguments[0];
    var p0$1 = arguments[1];
    var p1$1 = arguments[2];
    var label$1 = arguments[3];
    this._edge = edge$2;
    this.init(p0$1, p1$1);
    this._label = label$1;
  }
};
EdgeEnd.prototype.compareDirection = function compareDirection(e) {
  if (this._dx === e._dx && this._dy === e._dy) {
    return 0;
  }
  if (this._quadrant > e._quadrant) {
    return 1;
  }
  if (this._quadrant < e._quadrant) {
    return -1;
  }
  return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);
};
EdgeEnd.prototype.getDy = function getDy() {
  return this._dy;
};
EdgeEnd.prototype.getCoordinate = function getCoordinate6() {
  return this._p0;
};
EdgeEnd.prototype.setNode = function setNode(node) {
  this._node = node;
};
EdgeEnd.prototype.print = function print2(out) {
  var angle4 = Math.atan2(this._dy, this._dx);
  var className = this.getClass().getName();
  var lastDotPos = className.lastIndexOf(".");
  var name = className.substring(lastDotPos + 1);
  out.print("  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle4 + "   " + this._label);
};
EdgeEnd.prototype.compareTo = function compareTo8(obj) {
  var e = obj;
  return this.compareDirection(e);
};
EdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate() {
  return this._p1;
};
EdgeEnd.prototype.getDx = function getDx() {
  return this._dx;
};
EdgeEnd.prototype.getLabel = function getLabel3() {
  return this._label;
};
EdgeEnd.prototype.getEdge = function getEdge2() {
  return this._edge;
};
EdgeEnd.prototype.getQuadrant = function getQuadrant() {
  return this._quadrant;
};
EdgeEnd.prototype.getNode = function getNode() {
  return this._node;
};
EdgeEnd.prototype.toString = function toString13() {
  var angle4 = Math.atan2(this._dy, this._dx);
  var className = this.getClass().getName();
  var lastDotPos = className.lastIndexOf(".");
  var name = className.substring(lastDotPos + 1);
  return "  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle4 + "   " + this._label;
};
EdgeEnd.prototype.computeLabel = function computeLabel(boundaryNodeRule) {
};
EdgeEnd.prototype.init = function init4(p0, p1) {
  this._p0 = p0;
  this._p1 = p1;
  this._dx = p1.x - p0.x;
  this._dy = p1.y - p0.y;
  this._quadrant = Quadrant.quadrant(this._dx, this._dy);
  Assert.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
};
EdgeEnd.prototype.interfaces_ = function interfaces_57() {
  return [Comparable];
};
EdgeEnd.prototype.getClass = function getClass56() {
  return EdgeEnd;
};
var DirectedEdge = function(EdgeEnd$$1) {
  function DirectedEdge2() {
    var edge = arguments[0];
    var isForward = arguments[1];
    EdgeEnd$$1.call(this, edge);
    this._isForward = null;
    this._isInResult = false;
    this._isVisited = false;
    this._sym = null;
    this._next = null;
    this._nextMin = null;
    this._edgeRing = null;
    this._minEdgeRing = null;
    this._depth = [0, -999, -999];
    this._isForward = isForward;
    if (isForward) {
      this.init(edge.getCoordinate(0), edge.getCoordinate(1));
    } else {
      var n = edge.getNumPoints() - 1;
      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
    }
    this.computeDirectedLabel();
  }
  if (EdgeEnd$$1)
    DirectedEdge2.__proto__ = EdgeEnd$$1;
  DirectedEdge2.prototype = Object.create(EdgeEnd$$1 && EdgeEnd$$1.prototype);
  DirectedEdge2.prototype.constructor = DirectedEdge2;
  DirectedEdge2.prototype.getNextMin = function getNextMin() {
    return this._nextMin;
  };
  DirectedEdge2.prototype.getDepth = function getDepth3(position) {
    return this._depth[position];
  };
  DirectedEdge2.prototype.setVisited = function setVisited2(isVisited2) {
    this._isVisited = isVisited2;
  };
  DirectedEdge2.prototype.computeDirectedLabel = function computeDirectedLabel() {
    this._label = new Label(this._edge.getLabel());
    if (!this._isForward) {
      this._label.flip();
    }
  };
  DirectedEdge2.prototype.getNext = function getNext() {
    return this._next;
  };
  DirectedEdge2.prototype.setDepth = function setDepth2(position, depthVal) {
    if (this._depth[position] !== -999) {
      if (this._depth[position] !== depthVal) {
        throw new TopologyException("assigned depths do not match", this.getCoordinate());
      }
    }
    this._depth[position] = depthVal;
  };
  DirectedEdge2.prototype.isInteriorAreaEdge = function isInteriorAreaEdge() {
    var this$1 = this;
    var isInteriorAreaEdge2 = true;
    for (var i = 0; i < 2; i++) {
      if (!(this$1._label.isArea(i) && this$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
        isInteriorAreaEdge2 = false;
      }
    }
    return isInteriorAreaEdge2;
  };
  DirectedEdge2.prototype.setNextMin = function setNextMin(nextMin) {
    this._nextMin = nextMin;
  };
  DirectedEdge2.prototype.print = function print9(out) {
    EdgeEnd$$1.prototype.print.call(this, out);
    out.print(" " + this._depth[Position.LEFT] + "/" + this._depth[Position.RIGHT]);
    out.print(" (" + this.getDepthDelta() + ")");
    if (this._isInResult) {
      out.print(" inResult");
    }
  };
  DirectedEdge2.prototype.setMinEdgeRing = function setMinEdgeRing(minEdgeRing) {
    this._minEdgeRing = minEdgeRing;
  };
  DirectedEdge2.prototype.isLineEdge = function isLineEdge() {
    var isLine3 = this._label.isLine(0) || this._label.isLine(1);
    var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
    var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
    return isLine3 && isExteriorIfArea0 && isExteriorIfArea1;
  };
  DirectedEdge2.prototype.setEdgeRing = function setEdgeRing(edgeRing) {
    this._edgeRing = edgeRing;
  };
  DirectedEdge2.prototype.getMinEdgeRing = function getMinEdgeRing() {
    return this._minEdgeRing;
  };
  DirectedEdge2.prototype.getDepthDelta = function getDepthDelta() {
    var depthDelta2 = this._edge.getDepthDelta();
    if (!this._isForward) {
      depthDelta2 = -depthDelta2;
    }
    return depthDelta2;
  };
  DirectedEdge2.prototype.setInResult = function setInResult3(isInResult2) {
    this._isInResult = isInResult2;
  };
  DirectedEdge2.prototype.getSym = function getSym() {
    return this._sym;
  };
  DirectedEdge2.prototype.isForward = function isForward() {
    return this._isForward;
  };
  DirectedEdge2.prototype.getEdge = function getEdge4() {
    return this._edge;
  };
  DirectedEdge2.prototype.printEdge = function printEdge(out) {
    this.print(out);
    out.print(" ");
    if (this._isForward) {
      this._edge.print(out);
    } else {
      this._edge.printReverse(out);
    }
  };
  DirectedEdge2.prototype.setSym = function setSym(de) {
    this._sym = de;
  };
  DirectedEdge2.prototype.setVisitedEdge = function setVisitedEdge(isVisited2) {
    this.setVisited(isVisited2);
    this._sym.setVisited(isVisited2);
  };
  DirectedEdge2.prototype.setEdgeDepths = function setEdgeDepths(position, depth2) {
    var depthDelta2 = this.getEdge().getDepthDelta();
    if (!this._isForward) {
      depthDelta2 = -depthDelta2;
    }
    var directionFactor = 1;
    if (position === Position.LEFT) {
      directionFactor = -1;
    }
    var oppositePos = Position.opposite(position);
    var delta = depthDelta2 * directionFactor;
    var oppositeDepth = depth2 + delta;
    this.setDepth(position, depth2);
    this.setDepth(oppositePos, oppositeDepth);
  };
  DirectedEdge2.prototype.getEdgeRing = function getEdgeRing() {
    return this._edgeRing;
  };
  DirectedEdge2.prototype.isInResult = function isInResult2() {
    return this._isInResult;
  };
  DirectedEdge2.prototype.setNext = function setNext(next3) {
    this._next = next3;
  };
  DirectedEdge2.prototype.isVisited = function isVisited2() {
    return this._isVisited;
  };
  DirectedEdge2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  DirectedEdge2.prototype.getClass = function getClass169() {
    return DirectedEdge2;
  };
  DirectedEdge2.depthFactor = function depthFactor(currLocation, nextLocation) {
    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) {
      return 1;
    } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) {
      return -1;
    }
    return 0;
  };
  return DirectedEdge2;
}(EdgeEnd);
var NodeFactory = function NodeFactory2() {
};
NodeFactory.prototype.createNode = function createNode(coord) {
  return new Node5(coord, null);
};
NodeFactory.prototype.interfaces_ = function interfaces_58() {
  return [];
};
NodeFactory.prototype.getClass = function getClass57() {
  return NodeFactory;
};
var PlanarGraph = function PlanarGraph2() {
  this._edges = new ArrayList();
  this._nodes = null;
  this._edgeEndList = new ArrayList();
  if (arguments.length === 0) {
    this._nodes = new NodeMap(new NodeFactory());
  } else if (arguments.length === 1) {
    var nodeFact = arguments[0];
    this._nodes = new NodeMap(nodeFact);
  }
};
PlanarGraph.prototype.printEdges = function printEdges(out) {
  var this$1 = this;
  out.println("Edges:");
  for (var i = 0; i < this._edges.size(); i++) {
    out.println("edge " + i + ":");
    var e = this$1._edges.get(i);
    e.print(out);
    e.eiList.print(out);
  }
};
PlanarGraph.prototype.find = function find2(coord) {
  return this._nodes.find(coord);
};
PlanarGraph.prototype.addNode = function addNode2() {
  if (arguments[0] instanceof Node5) {
    var node = arguments[0];
    return this._nodes.addNode(node);
  } else if (arguments[0] instanceof Coordinate) {
    var coord = arguments[0];
    return this._nodes.addNode(coord);
  }
};
PlanarGraph.prototype.getNodeIterator = function getNodeIterator() {
  return this._nodes.iterator();
};
PlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {
  for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().linkResultDirectedEdges();
  }
};
PlanarGraph.prototype.debugPrintln = function debugPrintln(o) {
  System.out.println(o);
};
PlanarGraph.prototype.isBoundaryNode = function isBoundaryNode(geomIndex, coord) {
  var node = this._nodes.find(coord);
  if (node === null) {
    return false;
  }
  var label = node.getLabel();
  if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) {
    return true;
  }
  return false;
};
PlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {
  for (var nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().linkAllDirectedEdges();
  }
};
PlanarGraph.prototype.matchInSameDirection = function matchInSameDirection(p0, p1, ep0, ep1) {
  if (!p0.equals(ep0)) {
    return false;
  }
  if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) {
    return true;
  }
  return false;
};
PlanarGraph.prototype.getEdgeEnds = function getEdgeEnds() {
  return this._edgeEndList;
};
PlanarGraph.prototype.debugPrint = function debugPrint(o) {
  System.out.print(o);
};
PlanarGraph.prototype.getEdgeIterator = function getEdgeIterator() {
  return this._edges.iterator();
};
PlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection(p0, p1) {
  var this$1 = this;
  for (var i = 0; i < this._edges.size(); i++) {
    var e = this$1._edges.get(i);
    var eCoord = e.getCoordinates();
    if (this$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) {
      return e;
    }
    if (this$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) {
      return e;
    }
  }
  return null;
};
PlanarGraph.prototype.insertEdge = function insertEdge(e) {
  this._edges.add(e);
};
PlanarGraph.prototype.findEdgeEnd = function findEdgeEnd(e) {
  for (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {
    var ee = i.next();
    if (ee.getEdge() === e) {
      return ee;
    }
  }
  return null;
};
PlanarGraph.prototype.addEdges = function addEdges(edgesToAdd) {
  var this$1 = this;
  for (var it = edgesToAdd.iterator(); it.hasNext(); ) {
    var e = it.next();
    this$1._edges.add(e);
    var de1 = new DirectedEdge(e, true);
    var de2 = new DirectedEdge(e, false);
    de1.setSym(de2);
    de2.setSym(de1);
    this$1.add(de1);
    this$1.add(de2);
  }
};
PlanarGraph.prototype.add = function add6(e) {
  this._nodes.add(e);
  this._edgeEndList.add(e);
};
PlanarGraph.prototype.getNodes = function getNodes2() {
  return this._nodes.values();
};
PlanarGraph.prototype.findEdge = function findEdge2(p0, p1) {
  var this$1 = this;
  for (var i = 0; i < this._edges.size(); i++) {
    var e = this$1._edges.get(i);
    var eCoord = e.getCoordinates();
    if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) {
      return e;
    }
  }
  return null;
};
PlanarGraph.prototype.interfaces_ = function interfaces_59() {
  return [];
};
PlanarGraph.prototype.getClass = function getClass58() {
  return PlanarGraph;
};
PlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges2(nodes) {
  for (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().linkResultDirectedEdges();
  }
};
var PolygonBuilder = function PolygonBuilder2() {
  this._geometryFactory = null;
  this._shellList = new ArrayList();
  var geometryFactory = arguments[0];
  this._geometryFactory = geometryFactory;
};
PolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
  for (var it = edgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.isHole()) {
      freeHoleList.add(er);
    } else {
      shellList.add(er);
    }
  }
};
PolygonBuilder.prototype.computePolygons = function computePolygons(shellList) {
  var this$1 = this;
  var resultPolyList = new ArrayList();
  for (var it = shellList.iterator(); it.hasNext(); ) {
    var er = it.next();
    var poly = er.toPolygon(this$1._geometryFactory);
    resultPolyList.add(poly);
  }
  return resultPolyList;
};
PolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles(shellList, freeHoleList) {
  var this$1 = this;
  for (var it = freeHoleList.iterator(); it.hasNext(); ) {
    var hole = it.next();
    if (hole.getShell() === null) {
      var shell = this$1.findEdgeRingContaining(hole, shellList);
      if (shell === null) {
        throw new TopologyException("unable to assign hole to a shell", hole.getCoordinate(0));
      }
      hole.setShell(shell);
    }
  }
};
PolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
  var this$1 = this;
  var edgeRings = new ArrayList();
  for (var it = maxEdgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.getMaxNodeDegree() > 2) {
      er.linkDirectedEdgesForMinimalEdgeRings();
      var minEdgeRings = er.buildMinimalRings();
      var shell = this$1.findShell(minEdgeRings);
      if (shell !== null) {
        this$1.placePolygonHoles(shell, minEdgeRings);
        shellList.add(shell);
      } else {
        freeHoleList.addAll(minEdgeRings);
      }
    } else {
      edgeRings.add(er);
    }
  }
  return edgeRings;
};
PolygonBuilder.prototype.containsPoint = function containsPoint2(p) {
  for (var it = this._shellList.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.containsPoint(p)) {
      return true;
    }
  }
  return false;
};
PolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings(dirEdges) {
  var this$1 = this;
  var maxEdgeRings = new ArrayList();
  for (var it = dirEdges.iterator(); it.hasNext(); ) {
    var de = it.next();
    if (de.isInResult() && de.getLabel().isArea()) {
      if (de.getEdgeRing() === null) {
        var er = new MaximalEdgeRing(de, this$1._geometryFactory);
        maxEdgeRings.add(er);
        er.setInResult();
      }
    }
  }
  return maxEdgeRings;
};
PolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles(shell, minEdgeRings) {
  for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (er.isHole()) {
      er.setShell(shell);
    }
  }
};
PolygonBuilder.prototype.getPolygons = function getPolygons() {
  var resultPolyList = this.computePolygons(this._shellList);
  return resultPolyList;
};
PolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining(testEr, shellList) {
  var testRing = testEr.getLinearRing();
  var testEnv = testRing.getEnvelopeInternal();
  var testPt = testRing.getCoordinateN(0);
  var minShell = null;
  var minEnv = null;
  for (var it = shellList.iterator(); it.hasNext(); ) {
    var tryShell = it.next();
    var tryRing = tryShell.getLinearRing();
    var tryEnv = tryRing.getEnvelopeInternal();
    if (minShell !== null) {
      minEnv = minShell.getLinearRing().getEnvelopeInternal();
    }
    var isContained = false;
    if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) {
      isContained = true;
    }
    if (isContained) {
      if (minShell === null || minEnv.contains(tryEnv)) {
        minShell = tryShell;
      }
    }
  }
  return minShell;
};
PolygonBuilder.prototype.findShell = function findShell(minEdgeRings) {
  var shellCount = 0;
  var shell = null;
  for (var it = minEdgeRings.iterator(); it.hasNext(); ) {
    var er = it.next();
    if (!er.isHole()) {
      shell = er;
      shellCount++;
    }
  }
  Assert.isTrue(shellCount <= 1, "found two shells in MinimalEdgeRing list");
  return shell;
};
PolygonBuilder.prototype.add = function add7() {
  if (arguments.length === 1) {
    var graph = arguments[0];
    this.add(graph.getEdgeEnds(), graph.getNodes());
  } else if (arguments.length === 2) {
    var dirEdges = arguments[0];
    var nodes = arguments[1];
    PlanarGraph.linkResultDirectedEdges(nodes);
    var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
    var freeHoleList = new ArrayList();
    var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
    this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
    this.placeFreeHoles(this._shellList, freeHoleList);
  }
};
PolygonBuilder.prototype.interfaces_ = function interfaces_60() {
  return [];
};
PolygonBuilder.prototype.getClass = function getClass59() {
  return PolygonBuilder;
};
var Boundable = function Boundable2() {
};
Boundable.prototype.getBounds = function getBounds() {
};
Boundable.prototype.interfaces_ = function interfaces_61() {
  return [];
};
Boundable.prototype.getClass = function getClass60() {
  return Boundable;
};
var ItemBoundable = function ItemBoundable2() {
  this._bounds = null;
  this._item = null;
  var bounds = arguments[0];
  var item = arguments[1];
  this._bounds = bounds;
  this._item = item;
};
ItemBoundable.prototype.getItem = function getItem() {
  return this._item;
};
ItemBoundable.prototype.getBounds = function getBounds2() {
  return this._bounds;
};
ItemBoundable.prototype.interfaces_ = function interfaces_62() {
  return [Boundable, Serializable];
};
ItemBoundable.prototype.getClass = function getClass61() {
  return ItemBoundable;
};
var PriorityQueue = function PriorityQueue2() {
  this._size = null;
  this._items = null;
  this._size = 0;
  this._items = new ArrayList();
  this._items.add(null);
};
PriorityQueue.prototype.poll = function poll() {
  if (this.isEmpty()) {
    return null;
  }
  var minItem = this._items.get(1);
  this._items.set(1, this._items.get(this._size));
  this._size -= 1;
  this.reorder(1);
  return minItem;
};
PriorityQueue.prototype.size = function size5() {
  return this._size;
};
PriorityQueue.prototype.reorder = function reorder(hole) {
  var this$1 = this;
  var child = null;
  var tmp = this._items.get(hole);
  for (; hole * 2 <= this._size; hole = child) {
    child = hole * 2;
    if (child !== this$1._size && this$1._items.get(child + 1).compareTo(this$1._items.get(child)) < 0) {
      child++;
    }
    if (this$1._items.get(child).compareTo(tmp) < 0) {
      this$1._items.set(hole, this$1._items.get(child));
    } else {
      break;
    }
  }
  this._items.set(hole, tmp);
};
PriorityQueue.prototype.clear = function clear() {
  this._size = 0;
  this._items.clear();
};
PriorityQueue.prototype.isEmpty = function isEmpty3() {
  return this._size === 0;
};
PriorityQueue.prototype.add = function add8(x2) {
  var this$1 = this;
  this._items.add(null);
  this._size += 1;
  var hole = this._size;
  this._items.set(0, x2);
  for (; x2.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
    this$1._items.set(hole, this$1._items.get(Math.trunc(hole / 2)));
  }
  this._items.set(hole, x2);
};
PriorityQueue.prototype.interfaces_ = function interfaces_63() {
  return [];
};
PriorityQueue.prototype.getClass = function getClass62() {
  return PriorityQueue;
};
var ItemVisitor = function ItemVisitor2() {
};
ItemVisitor.prototype.visitItem = function visitItem(item) {
};
ItemVisitor.prototype.interfaces_ = function interfaces_64() {
  return [];
};
ItemVisitor.prototype.getClass = function getClass63() {
  return ItemVisitor;
};
var SpatialIndex = function SpatialIndex2() {
};
SpatialIndex.prototype.insert = function insert2(itemEnv, item) {
};
SpatialIndex.prototype.remove = function remove3(itemEnv, item) {
};
SpatialIndex.prototype.query = function query() {
};
SpatialIndex.prototype.interfaces_ = function interfaces_65() {
  return [];
};
SpatialIndex.prototype.getClass = function getClass64() {
  return SpatialIndex;
};
var AbstractNode = function AbstractNode2() {
  this._childBoundables = new ArrayList();
  this._bounds = null;
  this._level = null;
  if (arguments.length === 0) {
  } else if (arguments.length === 1) {
    var level = arguments[0];
    this._level = level;
  }
};
var staticAccessors$22 = { serialVersionUID: { configurable: true } };
AbstractNode.prototype.getLevel = function getLevel() {
  return this._level;
};
AbstractNode.prototype.size = function size6() {
  return this._childBoundables.size();
};
AbstractNode.prototype.getChildBoundables = function getChildBoundables() {
  return this._childBoundables;
};
AbstractNode.prototype.addChildBoundable = function addChildBoundable(childBoundable) {
  Assert.isTrue(this._bounds === null);
  this._childBoundables.add(childBoundable);
};
AbstractNode.prototype.isEmpty = function isEmpty4() {
  return this._childBoundables.isEmpty();
};
AbstractNode.prototype.getBounds = function getBounds3() {
  if (this._bounds === null) {
    this._bounds = this.computeBounds();
  }
  return this._bounds;
};
AbstractNode.prototype.interfaces_ = function interfaces_66() {
  return [Boundable, Serializable];
};
AbstractNode.prototype.getClass = function getClass65() {
  return AbstractNode;
};
staticAccessors$22.serialVersionUID.get = function() {
  return 6493722185909574e3;
};
Object.defineProperties(AbstractNode, staticAccessors$22);
var Collections = function Collections2() {
};
Collections.reverseOrder = function reverseOrder() {
  return {
    compare: function compare10(a, b) {
      return b.compareTo(a);
    }
  };
};
Collections.min = function min3(l) {
  Collections.sort(l);
  return l.get(0);
};
Collections.sort = function sort3(l, c) {
  var a = l.toArray();
  if (c) {
    Arrays.sort(a, c);
  } else {
    Arrays.sort(a);
  }
  var i = l.iterator();
  for (var pos = 0, alen = a.length; pos < alen; pos++) {
    i.next();
    i.set(a[pos]);
  }
};
Collections.singletonList = function singletonList(o) {
  var arrayList = new ArrayList();
  arrayList.add(o);
  return arrayList;
};
var BoundablePair = function BoundablePair2() {
  this._boundable1 = null;
  this._boundable2 = null;
  this._distance = null;
  this._itemDistance = null;
  var boundable1 = arguments[0];
  var boundable2 = arguments[1];
  var itemDistance = arguments[2];
  this._boundable1 = boundable1;
  this._boundable2 = boundable2;
  this._itemDistance = itemDistance;
  this._distance = this.distance();
};
BoundablePair.prototype.expandToQueue = function expandToQueue(priQ, minDistance) {
  var isComp1 = BoundablePair.isComposite(this._boundable1);
  var isComp2 = BoundablePair.isComposite(this._boundable2);
  if (isComp1 && isComp2) {
    if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
      this.expand(this._boundable1, this._boundable2, priQ, minDistance);
      return null;
    } else {
      this.expand(this._boundable2, this._boundable1, priQ, minDistance);
      return null;
    }
  } else if (isComp1) {
    this.expand(this._boundable1, this._boundable2, priQ, minDistance);
    return null;
  } else if (isComp2) {
    this.expand(this._boundable2, this._boundable1, priQ, minDistance);
    return null;
  }
  throw new IllegalArgumentException("neither boundable is composite");
};
BoundablePair.prototype.isLeaves = function isLeaves() {
  return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
};
BoundablePair.prototype.compareTo = function compareTo9(o) {
  var nd = o;
  if (this._distance < nd._distance) {
    return -1;
  }
  if (this._distance > nd._distance) {
    return 1;
  }
  return 0;
};
BoundablePair.prototype.expand = function expand(bndComposite, bndOther, priQ, minDistance) {
  var this$1 = this;
  var children = bndComposite.getChildBoundables();
  for (var i = children.iterator(); i.hasNext(); ) {
    var child = i.next();
    var bp = new BoundablePair(child, bndOther, this$1._itemDistance);
    if (bp.getDistance() < minDistance) {
      priQ.add(bp);
    }
  }
};
BoundablePair.prototype.getBoundable = function getBoundable(i) {
  if (i === 0) {
    return this._boundable1;
  }
  return this._boundable2;
};
BoundablePair.prototype.getDistance = function getDistance() {
  return this._distance;
};
BoundablePair.prototype.distance = function distance4() {
  if (this.isLeaves()) {
    return this._itemDistance.distance(this._boundable1, this._boundable2);
  }
  return this._boundable1.getBounds().distance(this._boundable2.getBounds());
};
BoundablePair.prototype.interfaces_ = function interfaces_67() {
  return [Comparable];
};
BoundablePair.prototype.getClass = function getClass66() {
  return BoundablePair;
};
BoundablePair.area = function area2(b) {
  return b.getBounds().getArea();
};
BoundablePair.isComposite = function isComposite(item) {
  return item instanceof AbstractNode;
};
var AbstractSTRtree = function AbstractSTRtree2() {
  this._root = null;
  this._built = false;
  this._itemBoundables = new ArrayList();
  this._nodeCapacity = null;
  if (arguments.length === 0) {
    var nodeCapacity = AbstractSTRtree2.DEFAULT_NODE_CAPACITY;
    this._nodeCapacity = nodeCapacity;
  } else if (arguments.length === 1) {
    var nodeCapacity$1 = arguments[0];
    Assert.isTrue(nodeCapacity$1 > 1, "Node capacity must be greater than 1");
    this._nodeCapacity = nodeCapacity$1;
  }
};
var staticAccessors$23 = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
AbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity() {
  return this._nodeCapacity;
};
AbstractSTRtree.prototype.lastNode = function lastNode(nodes) {
  return nodes.get(nodes.size() - 1);
};
AbstractSTRtree.prototype.size = function size7() {
  var this$1 = this;
  if (arguments.length === 0) {
    if (this.isEmpty()) {
      return 0;
    }
    this.build();
    return this.size(this._root);
  } else if (arguments.length === 1) {
    var node = arguments[0];
    var size11 = 0;
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (childBoundable instanceof AbstractNode) {
        size11 += this$1.size(childBoundable);
      } else if (childBoundable instanceof ItemBoundable) {
        size11 += 1;
      }
    }
    return size11;
  }
};
AbstractSTRtree.prototype.removeItem = function removeItem(node, item) {
  var childToRemove = null;
  for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
    var childBoundable = i.next();
    if (childBoundable instanceof ItemBoundable) {
      if (childBoundable.getItem() === item) {
        childToRemove = childBoundable;
      }
    }
  }
  if (childToRemove !== null) {
    node.getChildBoundables().remove(childToRemove);
    return true;
  }
  return false;
};
AbstractSTRtree.prototype.itemsTree = function itemsTree() {
  var this$1 = this;
  if (arguments.length === 0) {
    this.build();
    var valuesTree = this.itemsTree(this._root);
    if (valuesTree === null) {
      return new ArrayList();
    }
    return valuesTree;
  } else if (arguments.length === 1) {
    var node = arguments[0];
    var valuesTreeForNode = new ArrayList();
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (childBoundable instanceof AbstractNode) {
        var valuesTreeForChild = this$1.itemsTree(childBoundable);
        if (valuesTreeForChild !== null) {
          valuesTreeForNode.add(valuesTreeForChild);
        }
      } else if (childBoundable instanceof ItemBoundable) {
        valuesTreeForNode.add(childBoundable.getItem());
      } else {
        Assert.shouldNeverReachHere();
      }
    }
    if (valuesTreeForNode.size() <= 0) {
      return null;
    }
    return valuesTreeForNode;
  }
};
AbstractSTRtree.prototype.insert = function insert3(bounds, item) {
  Assert.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built.");
  this._itemBoundables.add(new ItemBoundable(bounds, item));
};
AbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel() {
  var this$1 = this;
  if (arguments.length === 1) {
    var level = arguments[0];
    var boundables = new ArrayList();
    this.boundablesAtLevel(level, this._root, boundables);
    return boundables;
  } else if (arguments.length === 3) {
    var level$1 = arguments[0];
    var top = arguments[1];
    var boundables$1 = arguments[2];
    Assert.isTrue(level$1 > -2);
    if (top.getLevel() === level$1) {
      boundables$1.add(top);
      return null;
    }
    for (var i = top.getChildBoundables().iterator(); i.hasNext(); ) {
      var boundable = i.next();
      if (boundable instanceof AbstractNode) {
        this$1.boundablesAtLevel(level$1, boundable, boundables$1);
      } else {
        Assert.isTrue(boundable instanceof ItemBoundable);
        if (level$1 === -1) {
          boundables$1.add(boundable);
        }
      }
    }
    return null;
  }
};
AbstractSTRtree.prototype.query = function query2() {
  var this$1 = this;
  if (arguments.length === 1) {
    var searchBounds = arguments[0];
    this.build();
    var matches = new ArrayList();
    if (this.isEmpty()) {
      return matches;
    }
    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
      this.query(searchBounds, this._root, matches);
    }
    return matches;
  } else if (arguments.length === 2) {
    var searchBounds$1 = arguments[0];
    var visitor = arguments[1];
    this.build();
    if (this.isEmpty()) {
      return null;
    }
    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {
      this.query(searchBounds$1, this._root, visitor);
    }
  } else if (arguments.length === 3) {
    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
      var searchBounds$2 = arguments[0];
      var node = arguments[1];
      var visitor$1 = arguments[2];
      var childBoundables = node.getChildBoundables();
      for (var i = 0; i < childBoundables.size(); i++) {
        var childBoundable = childBoundables.get(i);
        if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {
          continue;
        }
        if (childBoundable instanceof AbstractNode) {
          this$1.query(searchBounds$2, childBoundable, visitor$1);
        } else if (childBoundable instanceof ItemBoundable) {
          visitor$1.visitItem(childBoundable.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
      var searchBounds$3 = arguments[0];
      var node$1 = arguments[1];
      var matches$1 = arguments[2];
      var childBoundables$1 = node$1.getChildBoundables();
      for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {
        var childBoundable$1 = childBoundables$1.get(i$1);
        if (!this$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {
          continue;
        }
        if (childBoundable$1 instanceof AbstractNode) {
          this$1.query(searchBounds$3, childBoundable$1, matches$1);
        } else if (childBoundable$1 instanceof ItemBoundable) {
          matches$1.add(childBoundable$1.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
    }
  }
};
AbstractSTRtree.prototype.build = function build() {
  if (this._built) {
    return null;
  }
  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
  this._itemBoundables = null;
  this._built = true;
};
AbstractSTRtree.prototype.getRoot = function getRoot() {
  this.build();
  return this._root;
};
AbstractSTRtree.prototype.remove = function remove4() {
  var this$1 = this;
  if (arguments.length === 2) {
    var searchBounds = arguments[0];
    var item = arguments[1];
    this.build();
    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
      return this.remove(searchBounds, this._root, item);
    }
    return false;
  } else if (arguments.length === 3) {
    var searchBounds$1 = arguments[0];
    var node = arguments[1];
    var item$1 = arguments[2];
    var found = this.removeItem(node, item$1);
    if (found) {
      return true;
    }
    var childToPrune = null;
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {
        continue;
      }
      if (childBoundable instanceof AbstractNode) {
        found = this$1.remove(searchBounds$1, childBoundable, item$1);
        if (found) {
          childToPrune = childBoundable;
          break;
        }
      }
    }
    if (childToPrune !== null) {
      if (childToPrune.getChildBoundables().isEmpty()) {
        node.getChildBoundables().remove(childToPrune);
      }
    }
    return found;
  }
};
AbstractSTRtree.prototype.createHigherLevels = function createHigherLevels(boundablesOfALevel, level) {
  Assert.isTrue(!boundablesOfALevel.isEmpty());
  var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
  if (parentBoundables.size() === 1) {
    return parentBoundables.get(0);
  }
  return this.createHigherLevels(parentBoundables, level + 1);
};
AbstractSTRtree.prototype.depth = function depth() {
  var this$1 = this;
  if (arguments.length === 0) {
    if (this.isEmpty()) {
      return 0;
    }
    this.build();
    return this.depth(this._root);
  } else if (arguments.length === 1) {
    var node = arguments[0];
    var maxChildDepth = 0;
    for (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (childBoundable instanceof AbstractNode) {
        var childDepth = this$1.depth(childBoundable);
        if (childDepth > maxChildDepth) {
          maxChildDepth = childDepth;
        }
      }
    }
    return maxChildDepth + 1;
  }
};
AbstractSTRtree.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {
  var this$1 = this;
  Assert.isTrue(!childBoundables.isEmpty());
  var parentBoundables = new ArrayList();
  parentBoundables.add(this.createNode(newLevel));
  var sortedChildBoundables = new ArrayList(childBoundables);
  Collections.sort(sortedChildBoundables, this.getComparator());
  for (var i = sortedChildBoundables.iterator(); i.hasNext(); ) {
    var childBoundable = i.next();
    if (this$1.lastNode(parentBoundables).getChildBoundables().size() === this$1.getNodeCapacity()) {
      parentBoundables.add(this$1.createNode(newLevel));
    }
    this$1.lastNode(parentBoundables).addChildBoundable(childBoundable);
  }
  return parentBoundables;
};
AbstractSTRtree.prototype.isEmpty = function isEmpty5() {
  if (!this._built) {
    return this._itemBoundables.isEmpty();
  }
  return this._root.isEmpty();
};
AbstractSTRtree.prototype.interfaces_ = function interfaces_68() {
  return [Serializable];
};
AbstractSTRtree.prototype.getClass = function getClass67() {
  return AbstractSTRtree;
};
AbstractSTRtree.compareDoubles = function compareDoubles(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};
staticAccessors$23.IntersectsOp.get = function() {
  return IntersectsOp;
};
staticAccessors$23.serialVersionUID.get = function() {
  return -3886435814360241e3;
};
staticAccessors$23.DEFAULT_NODE_CAPACITY.get = function() {
  return 10;
};
Object.defineProperties(AbstractSTRtree, staticAccessors$23);
var IntersectsOp = function IntersectsOp2() {
};
var ItemDistance = function ItemDistance2() {
};
ItemDistance.prototype.distance = function distance5(item1, item2) {
};
ItemDistance.prototype.interfaces_ = function interfaces_69() {
  return [];
};
ItemDistance.prototype.getClass = function getClass68() {
  return ItemDistance;
};
var STRtree = function(AbstractSTRtree$$1) {
  function STRtree2(nodeCapacity) {
    nodeCapacity = nodeCapacity || STRtree2.DEFAULT_NODE_CAPACITY;
    AbstractSTRtree$$1.call(this, nodeCapacity);
  }
  if (AbstractSTRtree$$1)
    STRtree2.__proto__ = AbstractSTRtree$$1;
  STRtree2.prototype = Object.create(AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype);
  STRtree2.prototype.constructor = STRtree2;
  var staticAccessors2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
  STRtree2.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
    var this$1 = this;
    Assert.isTrue(verticalSlices.length > 0);
    var parentBoundables = new ArrayList();
    for (var i = 0; i < verticalSlices.length; i++) {
      parentBoundables.addAll(this$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
    }
    return parentBoundables;
  };
  STRtree2.prototype.createNode = function createNode2(level) {
    return new STRtreeNode(level);
  };
  STRtree2.prototype.size = function size11() {
    if (arguments.length === 0) {
      return AbstractSTRtree$$1.prototype.size.call(this);
    } else {
      return AbstractSTRtree$$1.prototype.size.apply(this, arguments);
    }
  };
  STRtree2.prototype.insert = function insert5() {
    if (arguments.length === 2) {
      var itemEnv = arguments[0];
      var item = arguments[1];
      if (itemEnv.isNull()) {
        return null;
      }
      AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);
    } else {
      return AbstractSTRtree$$1.prototype.insert.apply(this, arguments);
    }
  };
  STRtree2.prototype.getIntersectsOp = function getIntersectsOp() {
    return STRtree2.intersectsOp;
  };
  STRtree2.prototype.verticalSlices = function verticalSlices(childBoundables, sliceCount) {
    var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
    var slices = new Array(sliceCount).fill(null);
    var i = childBoundables.iterator();
    for (var j = 0; j < sliceCount; j++) {
      slices[j] = new ArrayList();
      var boundablesAddedToSlice = 0;
      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
        var childBoundable = i.next();
        slices[j].add(childBoundable);
        boundablesAddedToSlice++;
      }
    }
    return slices;
  };
  STRtree2.prototype.query = function query5() {
    if (arguments.length === 1) {
      var searchEnv = arguments[0];
      return AbstractSTRtree$$1.prototype.query.call(this, searchEnv);
    } else if (arguments.length === 2) {
      var searchEnv$1 = arguments[0];
      var visitor = arguments[1];
      AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);
    } else if (arguments.length === 3) {
      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        var searchBounds = arguments[0];
        var node = arguments[1];
        var visitor$1 = arguments[2];
        AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);
      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        var searchBounds$1 = arguments[0];
        var node$1 = arguments[1];
        var matches = arguments[2];
        AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);
      }
    }
  };
  STRtree2.prototype.getComparator = function getComparator() {
    return STRtree2.yComparator;
  };
  STRtree2.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
    return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel);
  };
  STRtree2.prototype.remove = function remove6() {
    if (arguments.length === 2) {
      var itemEnv = arguments[0];
      var item = arguments[1];
      return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item);
    } else {
      return AbstractSTRtree$$1.prototype.remove.apply(this, arguments);
    }
  };
  STRtree2.prototype.depth = function depth2() {
    if (arguments.length === 0) {
      return AbstractSTRtree$$1.prototype.depth.call(this);
    } else {
      return AbstractSTRtree$$1.prototype.depth.apply(this, arguments);
    }
  };
  STRtree2.prototype.createParentBoundables = function createParentBoundables2(childBoundables, newLevel) {
    Assert.isTrue(!childBoundables.isEmpty());
    var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
    var sortedChildBoundables = new ArrayList(childBoundables);
    Collections.sort(sortedChildBoundables, STRtree2.xComparator);
    var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
  };
  STRtree2.prototype.nearestNeighbour = function nearestNeighbour() {
    if (arguments.length === 1) {
      if (hasInterface(arguments[0], ItemDistance)) {
        var itemDist = arguments[0];
        var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
        return this.nearestNeighbour(bp);
      } else if (arguments[0] instanceof BoundablePair) {
        var initBndPair = arguments[0];
        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof STRtree2 && hasInterface(arguments[1], ItemDistance)) {
        var tree = arguments[0];
        var itemDist$1 = arguments[1];
        var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);
        return this.nearestNeighbour(bp$1);
      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === "number") {
        var initBndPair$1 = arguments[0];
        var maxDistance = arguments[1];
        var distanceLowerBound = maxDistance;
        var minPair = null;
        var priQ = new PriorityQueue();
        priQ.add(initBndPair$1);
        while (!priQ.isEmpty() && distanceLowerBound > 0) {
          var bndPair = priQ.poll();
          var currentDistance = bndPair.getDistance();
          if (currentDistance >= distanceLowerBound) {
            break;
          }
          if (bndPair.isLeaves()) {
            distanceLowerBound = currentDistance;
            minPair = bndPair;
          } else {
            bndPair.expandToQueue(priQ, distanceLowerBound);
          }
        }
        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];
      }
    } else if (arguments.length === 3) {
      var env = arguments[0];
      var item = arguments[1];
      var itemDist$2 = arguments[2];
      var bnd = new ItemBoundable(env, item);
      var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);
      return this.nearestNeighbour(bp$2)[0];
    }
  };
  STRtree2.prototype.interfaces_ = function interfaces_170() {
    return [SpatialIndex, Serializable];
  };
  STRtree2.prototype.getClass = function getClass169() {
    return STRtree2;
  };
  STRtree2.centreX = function centreX(e) {
    return STRtree2.avg(e.getMinX(), e.getMaxX());
  };
  STRtree2.avg = function avg(a, b) {
    return (a + b) / 2;
  };
  STRtree2.centreY = function centreY(e) {
    return STRtree2.avg(e.getMinY(), e.getMaxY());
  };
  staticAccessors2.STRtreeNode.get = function() {
    return STRtreeNode;
  };
  staticAccessors2.serialVersionUID.get = function() {
    return 259274702368956900;
  };
  staticAccessors2.xComparator.get = function() {
    return {
      interfaces_: function() {
        return [Comparator];
      },
      compare: function(o1, o2) {
        return AbstractSTRtree$$1.compareDoubles(STRtree2.centreX(o1.getBounds()), STRtree2.centreX(o2.getBounds()));
      }
    };
  };
  staticAccessors2.yComparator.get = function() {
    return {
      interfaces_: function() {
        return [Comparator];
      },
      compare: function(o1, o2) {
        return AbstractSTRtree$$1.compareDoubles(STRtree2.centreY(o1.getBounds()), STRtree2.centreY(o2.getBounds()));
      }
    };
  };
  staticAccessors2.intersectsOp.get = function() {
    return {
      interfaces_: function() {
        return [AbstractSTRtree$$1.IntersectsOp];
      },
      intersects: function(aBounds, bBounds) {
        return aBounds.intersects(bBounds);
      }
    };
  };
  staticAccessors2.DEFAULT_NODE_CAPACITY.get = function() {
    return 10;
  };
  Object.defineProperties(STRtree2, staticAccessors2);
  return STRtree2;
}(AbstractSTRtree);
var STRtreeNode = function(AbstractNode$$1) {
  function STRtreeNode2() {
    var level = arguments[0];
    AbstractNode$$1.call(this, level);
  }
  if (AbstractNode$$1)
    STRtreeNode2.__proto__ = AbstractNode$$1;
  STRtreeNode2.prototype = Object.create(AbstractNode$$1 && AbstractNode$$1.prototype);
  STRtreeNode2.prototype.constructor = STRtreeNode2;
  STRtreeNode2.prototype.computeBounds = function computeBounds() {
    var bounds = null;
    for (var i = this.getChildBoundables().iterator(); i.hasNext(); ) {
      var childBoundable = i.next();
      if (bounds === null) {
        bounds = new Envelope(childBoundable.getBounds());
      } else {
        bounds.expandToInclude(childBoundable.getBounds());
      }
    }
    return bounds;
  };
  STRtreeNode2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  STRtreeNode2.prototype.getClass = function getClass169() {
    return STRtreeNode2;
  };
  return STRtreeNode2;
}(AbstractNode);
var SegmentPointComparator = function SegmentPointComparator2() {
};
SegmentPointComparator.prototype.interfaces_ = function interfaces_70() {
  return [];
};
SegmentPointComparator.prototype.getClass = function getClass69() {
  return SegmentPointComparator;
};
SegmentPointComparator.relativeSign = function relativeSign(x0, x1) {
  if (x0 < x1) {
    return -1;
  }
  if (x0 > x1) {
    return 1;
  }
  return 0;
};
SegmentPointComparator.compare = function compare7(octant2, p0, p1) {
  if (p0.equals2D(p1)) {
    return 0;
  }
  var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
  var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
  switch (octant2) {
    case 0:
      return SegmentPointComparator.compareValue(xSign, ySign);
    case 1:
      return SegmentPointComparator.compareValue(ySign, xSign);
    case 2:
      return SegmentPointComparator.compareValue(ySign, -xSign);
    case 3:
      return SegmentPointComparator.compareValue(-xSign, ySign);
    case 4:
      return SegmentPointComparator.compareValue(-xSign, -ySign);
    case 5:
      return SegmentPointComparator.compareValue(-ySign, -xSign);
    case 6:
      return SegmentPointComparator.compareValue(-ySign, xSign);
    case 7:
      return SegmentPointComparator.compareValue(xSign, -ySign);
    default:
  }
  Assert.shouldNeverReachHere("invalid octant value");
  return 0;
};
SegmentPointComparator.compareValue = function compareValue(compareSign0, compareSign1) {
  if (compareSign0 < 0) {
    return -1;
  }
  if (compareSign0 > 0) {
    return 1;
  }
  if (compareSign1 < 0) {
    return -1;
  }
  if (compareSign1 > 0) {
    return 1;
  }
  return 0;
};
var SegmentNode = function SegmentNode2() {
  this._segString = null;
  this.coord = null;
  this.segmentIndex = null;
  this._segmentOctant = null;
  this._isInterior = null;
  var segString = arguments[0];
  var coord = arguments[1];
  var segmentIndex = arguments[2];
  var segmentOctant = arguments[3];
  this._segString = segString;
  this.coord = new Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this._segmentOctant = segmentOctant;
  this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
};
SegmentNode.prototype.getCoordinate = function getCoordinate7() {
  return this.coord;
};
SegmentNode.prototype.print = function print3(out) {
  out.print(this.coord);
  out.print(" seg # = " + this.segmentIndex);
};
SegmentNode.prototype.compareTo = function compareTo10(obj) {
  var other = obj;
  if (this.segmentIndex < other.segmentIndex) {
    return -1;
  }
  if (this.segmentIndex > other.segmentIndex) {
    return 1;
  }
  if (this.coord.equals2D(other.coord)) {
    return 0;
  }
  return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);
};
SegmentNode.prototype.isEndPoint = function isEndPoint2(maxSegmentIndex) {
  if (this.segmentIndex === 0 && !this._isInterior) {
    return true;
  }
  if (this.segmentIndex === maxSegmentIndex) {
    return true;
  }
  return false;
};
SegmentNode.prototype.isInterior = function isInterior() {
  return this._isInterior;
};
SegmentNode.prototype.interfaces_ = function interfaces_71() {
  return [Comparable];
};
SegmentNode.prototype.getClass = function getClass70() {
  return SegmentNode;
};
var SegmentNodeList = function SegmentNodeList2() {
  this._nodeMap = new TreeMap();
  this._edge = null;
  var edge = arguments[0];
  this._edge = edge;
};
SegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates() {
  var this$1 = this;
  var coordList = new CoordinateList();
  this.addEndpoints();
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    this$1.addEdgeCoordinates(eiPrev, ei, coordList);
    eiPrev = ei;
  }
  return coordList.toCoordinateArray();
};
SegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes() {
  var this$1 = this;
  var collapsedVertexIndexes = new ArrayList();
  this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
  this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
  for (var it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {
    var vertexIndex = it.next().intValue();
    this$1.add(this$1._edge.getCoordinate(vertexIndex), vertexIndex);
  }
};
SegmentNodeList.prototype.print = function print4(out) {
  out.println("Intersections:");
  for (var it = this.iterator(); it.hasNext(); ) {
    var ei = it.next();
    ei.print(out);
  }
};
SegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices(collapsedVertexIndexes) {
  var this$1 = this;
  for (var i = 0; i < this._edge.size() - 2; i++) {
    var p0 = this$1._edge.getCoordinate(i);
    var p2 = this$1._edge.getCoordinate(i + 2);
    if (p0.equals2D(p2)) {
      collapsedVertexIndexes.add(new Integer(i + 1));
    }
  }
};
SegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates(ei0, ei1, coordList) {
  var this$1 = this;
  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
  coordList.add(new Coordinate(ei0.coord), false);
  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
    coordList.add(this$1._edge.getCoordinate(i));
  }
  if (useIntPt1) {
    coordList.add(new Coordinate(ei1.coord));
  }
};
SegmentNodeList.prototype.iterator = function iterator3() {
  return this._nodeMap.values().iterator();
};
SegmentNodeList.prototype.addSplitEdges = function addSplitEdges(edgeList) {
  var this$1 = this;
  this.addEndpoints();
  this.addCollapsedNodes();
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var newEdge = this$1.createSplitEdge(eiPrev, ei);
    edgeList.add(newEdge);
    eiPrev = ei;
  }
};
SegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
  if (!ei0.coord.equals2D(ei1.coord)) {
    return false;
  }
  var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
  if (!ei1.isInterior()) {
    numVerticesBetween--;
  }
  if (numVerticesBetween === 1) {
    collapsedVertexIndex[0] = ei0.segmentIndex + 1;
    return true;
  }
  return false;
};
SegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
  var this$1 = this;
  var collapsedVertexIndex = new Array(1).fill(null);
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var isCollapsed = this$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
    if (isCollapsed) {
      collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));
    }
    eiPrev = ei;
  }
};
SegmentNodeList.prototype.getEdge = function getEdge3() {
  return this._edge;
};
SegmentNodeList.prototype.addEndpoints = function addEndpoints() {
  var maxSegIndex = this._edge.size() - 1;
  this.add(this._edge.getCoordinate(0), 0);
  this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
};
SegmentNodeList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {
  var this$1 = this;
  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
  if (!useIntPt1) {
    npts--;
  }
  var pts = new Array(npts).fill(null);
  var ipt = 0;
  pts[ipt++] = new Coordinate(ei0.coord);
  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
    pts[ipt++] = this$1._edge.getCoordinate(i);
  }
  if (useIntPt1) {
    pts[ipt] = new Coordinate(ei1.coord);
  }
  return new NodedSegmentString(pts, this._edge.getData());
};
SegmentNodeList.prototype.add = function add9(intPt, segmentIndex) {
  var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
  var ei = this._nodeMap.get(eiNew);
  if (ei !== null) {
    Assert.isTrue(ei.coord.equals2D(intPt), "Found equal nodes with different coordinates");
    return ei;
  }
  this._nodeMap.put(eiNew, eiNew);
  return eiNew;
};
SegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness(splitEdges) {
  var edgePts = this._edge.getCoordinates();
  var split0 = splitEdges.get(0);
  var pt0 = split0.getCoordinate(0);
  if (!pt0.equals2D(edgePts[0])) {
    throw new RuntimeException("bad split edge start point at " + pt0);
  }
  var splitn = splitEdges.get(splitEdges.size() - 1);
  var splitnPts = splitn.getCoordinates();
  var ptn = splitnPts[splitnPts.length - 1];
  if (!ptn.equals2D(edgePts[edgePts.length - 1])) {
    throw new RuntimeException("bad split edge end point at " + ptn);
  }
};
SegmentNodeList.prototype.interfaces_ = function interfaces_72() {
  return [];
};
SegmentNodeList.prototype.getClass = function getClass71() {
  return SegmentNodeList;
};
var Octant = function Octant2() {
};
Octant.prototype.interfaces_ = function interfaces_73() {
  return [];
};
Octant.prototype.getClass = function getClass72() {
  return Octant;
};
Octant.octant = function octant() {
  if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
    var dx = arguments[0];
    var dy = arguments[1];
    if (dx === 0 && dy === 0) {
      throw new IllegalArgumentException("Cannot compute the octant for point ( " + dx + ", " + dy + " )");
    }
    var adx = Math.abs(dx);
    var ady = Math.abs(dy);
    if (dx >= 0) {
      if (dy >= 0) {
        if (adx >= ady) {
          return 0;
        } else {
          return 1;
        }
      } else {
        if (adx >= ady) {
          return 7;
        } else {
          return 6;
        }
      }
    } else {
      if (dy >= 0) {
        if (adx >= ady) {
          return 3;
        } else {
          return 2;
        }
      } else {
        if (adx >= ady) {
          return 4;
        } else {
          return 5;
        }
      }
    }
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    var dx$1 = p1.x - p0.x;
    var dy$1 = p1.y - p0.y;
    if (dx$1 === 0 && dy$1 === 0) {
      throw new IllegalArgumentException("Cannot compute the octant for two identical points " + p0);
    }
    return Octant.octant(dx$1, dy$1);
  }
};
var SegmentString = function SegmentString2() {
};
SegmentString.prototype.getCoordinates = function getCoordinates() {
};
SegmentString.prototype.size = function size8() {
};
SegmentString.prototype.getCoordinate = function getCoordinate8(i) {
};
SegmentString.prototype.isClosed = function isClosed() {
};
SegmentString.prototype.setData = function setData(data) {
};
SegmentString.prototype.getData = function getData() {
};
SegmentString.prototype.interfaces_ = function interfaces_74() {
  return [];
};
SegmentString.prototype.getClass = function getClass73() {
  return SegmentString;
};
var NodableSegmentString = function NodableSegmentString2() {
};
NodableSegmentString.prototype.addIntersection = function addIntersection(intPt, segmentIndex) {
};
NodableSegmentString.prototype.interfaces_ = function interfaces_75() {
  return [SegmentString];
};
NodableSegmentString.prototype.getClass = function getClass74() {
  return NodableSegmentString;
};
var NodedSegmentString = function NodedSegmentString2() {
  this._nodeList = new SegmentNodeList(this);
  this._pts = null;
  this._data = null;
  var pts = arguments[0];
  var data = arguments[1];
  this._pts = pts;
  this._data = data;
};
NodedSegmentString.prototype.getCoordinates = function getCoordinates2() {
  return this._pts;
};
NodedSegmentString.prototype.size = function size9() {
  return this._pts.length;
};
NodedSegmentString.prototype.getCoordinate = function getCoordinate9(i) {
  return this._pts[i];
};
NodedSegmentString.prototype.isClosed = function isClosed2() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
NodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index2) {
  if (index2 === this._pts.length - 1) {
    return -1;
  }
  return this.safeOctant(this.getCoordinate(index2), this.getCoordinate(index2 + 1));
};
NodedSegmentString.prototype.setData = function setData2(data) {
  this._data = data;
};
NodedSegmentString.prototype.safeOctant = function safeOctant(p0, p1) {
  if (p0.equals2D(p1)) {
    return 0;
  }
  return Octant.octant(p0, p1);
};
NodedSegmentString.prototype.getData = function getData2() {
  return this._data;
};
NodedSegmentString.prototype.addIntersection = function addIntersection2() {
  if (arguments.length === 2) {
    var intPt$1 = arguments[0];
    var segmentIndex = arguments[1];
    this.addIntersectionNode(intPt$1, segmentIndex);
  } else if (arguments.length === 4) {
    var li = arguments[0];
    var segmentIndex$1 = arguments[1];
    var intIndex = arguments[3];
    var intPt = new Coordinate(li.getIntersection(intIndex));
    this.addIntersection(intPt, segmentIndex$1);
  }
};
NodedSegmentString.prototype.toString = function toString14() {
  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
};
NodedSegmentString.prototype.getNodeList = function getNodeList() {
  return this._nodeList;
};
NodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode(intPt, segmentIndex) {
  var normalizedSegmentIndex = segmentIndex;
  var nextSegIndex = normalizedSegmentIndex + 1;
  if (nextSegIndex < this._pts.length) {
    var nextPt = this._pts[nextSegIndex];
    if (intPt.equals2D(nextPt)) {
      normalizedSegmentIndex = nextSegIndex;
    }
  }
  var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
  return ei;
};
NodedSegmentString.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {
  var this$1 = this;
  for (var i = 0; i < li.getIntersectionNum(); i++) {
    this$1.addIntersection(li, segmentIndex, geomIndex, i);
  }
};
NodedSegmentString.prototype.interfaces_ = function interfaces_76() {
  return [NodableSegmentString];
};
NodedSegmentString.prototype.getClass = function getClass75() {
  return NodedSegmentString;
};
NodedSegmentString.getNodedSubstrings = function getNodedSubstrings() {
  if (arguments.length === 1) {
    var segStrings = arguments[0];
    var resultEdgelist = new ArrayList();
    NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
    return resultEdgelist;
  } else if (arguments.length === 2) {
    var segStrings$1 = arguments[0];
    var resultEdgelist$1 = arguments[1];
    for (var i = segStrings$1.iterator(); i.hasNext(); ) {
      var ss = i.next();
      ss.getNodeList().addSplitEdges(resultEdgelist$1);
    }
  }
};
var LineSegment = function LineSegment2() {
  this.p0 = null;
  this.p1 = null;
  if (arguments.length === 0) {
    this.p0 = new Coordinate();
    this.p1 = new Coordinate();
  } else if (arguments.length === 1) {
    var ls = arguments[0];
    this.p0 = new Coordinate(ls.p0);
    this.p1 = new Coordinate(ls.p1);
  } else if (arguments.length === 2) {
    this.p0 = arguments[0];
    this.p1 = arguments[1];
  } else if (arguments.length === 4) {
    var x0 = arguments[0];
    var y0 = arguments[1];
    var x1 = arguments[2];
    var y1 = arguments[3];
    this.p0 = new Coordinate(x0, y0);
    this.p1 = new Coordinate(x1, y1);
  }
};
var staticAccessors$24 = { serialVersionUID: { configurable: true } };
LineSegment.prototype.minX = function minX() {
  return Math.min(this.p0.x, this.p1.x);
};
LineSegment.prototype.orientationIndex = function orientationIndex5() {
  if (arguments[0] instanceof LineSegment) {
    var seg = arguments[0];
    var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
    var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
    if (orient0 >= 0 && orient1 >= 0) {
      return Math.max(orient0, orient1);
    }
    if (orient0 <= 0 && orient1 <= 0) {
      return Math.max(orient0, orient1);
    }
    return 0;
  } else if (arguments[0] instanceof Coordinate) {
    var p = arguments[0];
    return CGAlgorithms.orientationIndex(this.p0, this.p1, p);
  }
};
LineSegment.prototype.toGeometry = function toGeometry2(geomFactory) {
  return geomFactory.createLineString([this.p0, this.p1]);
};
LineSegment.prototype.isVertical = function isVertical() {
  return this.p0.x === this.p1.x;
};
LineSegment.prototype.equals = function equals9(o) {
  if (!(o instanceof LineSegment)) {
    return false;
  }
  var other = o;
  return this.p0.equals(other.p0) && this.p1.equals(other.p1);
};
LineSegment.prototype.intersection = function intersection9(line) {
  var li = new RobustLineIntersector();
  li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
  if (li.hasIntersection()) {
    return li.getIntersection(0);
  }
  return null;
};
LineSegment.prototype.project = function project() {
  if (arguments[0] instanceof Coordinate) {
    var p = arguments[0];
    if (p.equals(this.p0) || p.equals(this.p1)) {
      return new Coordinate(p);
    }
    var r = this.projectionFactor(p);
    var coord = new Coordinate();
    coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
    coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
    return coord;
  } else if (arguments[0] instanceof LineSegment) {
    var seg = arguments[0];
    var pf0 = this.projectionFactor(seg.p0);
    var pf1 = this.projectionFactor(seg.p1);
    if (pf0 >= 1 && pf1 >= 1) {
      return null;
    }
    if (pf0 <= 0 && pf1 <= 0) {
      return null;
    }
    var newp0 = this.project(seg.p0);
    if (pf0 < 0) {
      newp0 = this.p0;
    }
    if (pf0 > 1) {
      newp0 = this.p1;
    }
    var newp1 = this.project(seg.p1);
    if (pf1 < 0) {
      newp1 = this.p0;
    }
    if (pf1 > 1) {
      newp1 = this.p1;
    }
    return new LineSegment(newp0, newp1);
  }
};
LineSegment.prototype.normalize = function normalize3() {
  if (this.p1.compareTo(this.p0) < 0) {
    this.reverse();
  }
};
LineSegment.prototype.angle = function angle2() {
  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
};
LineSegment.prototype.getCoordinate = function getCoordinate10(i) {
  if (i === 0) {
    return this.p0;
  }
  return this.p1;
};
LineSegment.prototype.distancePerpendicular = function distancePerpendicular(p) {
  return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);
};
LineSegment.prototype.minY = function minY() {
  return Math.min(this.p0.y, this.p1.y);
};
LineSegment.prototype.midPoint = function midPoint() {
  return LineSegment.midPoint(this.p0, this.p1);
};
LineSegment.prototype.projectionFactor = function projectionFactor(p) {
  if (p.equals(this.p0)) {
    return 0;
  }
  if (p.equals(this.p1)) {
    return 1;
  }
  var dx = this.p1.x - this.p0.x;
  var dy = this.p1.y - this.p0.y;
  var len = dx * dx + dy * dy;
  if (len <= 0) {
    return Double.NaN;
  }
  var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
  return r;
};
LineSegment.prototype.closestPoints = function closestPoints(line) {
  var intPt = this.intersection(line);
  if (intPt !== null) {
    return [intPt, intPt];
  }
  var closestPt = new Array(2).fill(null);
  var minDistance = Double.MAX_VALUE;
  var dist = null;
  var close00 = this.closestPoint(line.p0);
  minDistance = close00.distance(line.p0);
  closestPt[0] = close00;
  closestPt[1] = line.p0;
  var close01 = this.closestPoint(line.p1);
  dist = close01.distance(line.p1);
  if (dist < minDistance) {
    minDistance = dist;
    closestPt[0] = close01;
    closestPt[1] = line.p1;
  }
  var close10 = line.closestPoint(this.p0);
  dist = close10.distance(this.p0);
  if (dist < minDistance) {
    minDistance = dist;
    closestPt[0] = this.p0;
    closestPt[1] = close10;
  }
  var close11 = line.closestPoint(this.p1);
  dist = close11.distance(this.p1);
  if (dist < minDistance) {
    minDistance = dist;
    closestPt[0] = this.p1;
    closestPt[1] = close11;
  }
  return closestPt;
};
LineSegment.prototype.closestPoint = function closestPoint(p) {
  var factor = this.projectionFactor(p);
  if (factor > 0 && factor < 1) {
    return this.project(p);
  }
  var dist0 = this.p0.distance(p);
  var dist1 = this.p1.distance(p);
  if (dist0 < dist1) {
    return this.p0;
  }
  return this.p1;
};
LineSegment.prototype.maxX = function maxX() {
  return Math.max(this.p0.x, this.p1.x);
};
LineSegment.prototype.getLength = function getLength2() {
  return this.p0.distance(this.p1);
};
LineSegment.prototype.compareTo = function compareTo11(o) {
  var other = o;
  var comp0 = this.p0.compareTo(other.p0);
  if (comp0 !== 0) {
    return comp0;
  }
  return this.p1.compareTo(other.p1);
};
LineSegment.prototype.reverse = function reverse4() {
  var temp = this.p0;
  this.p0 = this.p1;
  this.p1 = temp;
};
LineSegment.prototype.equalsTopo = function equalsTopo(other) {
  return this.p0.equals(other.p0) && (this.p1.equals(other.p1) || this.p0.equals(other.p1)) && this.p1.equals(other.p0);
};
LineSegment.prototype.lineIntersection = function lineIntersection(line) {
  try {
    var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
    return intPt;
  } catch (ex) {
    if (ex instanceof NotRepresentableException) {
    } else {
      throw ex;
    }
  } finally {
  }
  return null;
};
LineSegment.prototype.maxY = function maxY() {
  return Math.max(this.p0.y, this.p1.y);
};
LineSegment.prototype.pointAlongOffset = function pointAlongOffset(segmentLengthFraction, offsetDistance) {
  var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
  var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
  var dx = this.p1.x - this.p0.x;
  var dy = this.p1.y - this.p0.y;
  var len = Math.sqrt(dx * dx + dy * dy);
  var ux = 0;
  var uy = 0;
  if (offsetDistance !== 0) {
    if (len <= 0) {
      throw new Error("Cannot compute offset from zero-length line segment");
    }
    ux = offsetDistance * dx / len;
    uy = offsetDistance * dy / len;
  }
  var offsetx = segx - uy;
  var offsety = segy + ux;
  var coord = new Coordinate(offsetx, offsety);
  return coord;
};
LineSegment.prototype.setCoordinates = function setCoordinates() {
  if (arguments.length === 1) {
    var ls = arguments[0];
    this.setCoordinates(ls.p0, ls.p1);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    this.p0.x = p0.x;
    this.p0.y = p0.y;
    this.p1.x = p1.x;
    this.p1.y = p1.y;
  }
};
LineSegment.prototype.segmentFraction = function segmentFraction(inputPt) {
  var segFrac = this.projectionFactor(inputPt);
  if (segFrac < 0) {
    segFrac = 0;
  } else if (segFrac > 1 || Double.isNaN(segFrac)) {
    segFrac = 1;
  }
  return segFrac;
};
LineSegment.prototype.toString = function toString15() {
  return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
};
LineSegment.prototype.isHorizontal = function isHorizontal() {
  return this.p0.y === this.p1.y;
};
LineSegment.prototype.distance = function distance6() {
  if (arguments[0] instanceof LineSegment) {
    var ls = arguments[0];
    return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);
  } else if (arguments[0] instanceof Coordinate) {
    var p = arguments[0];
    return CGAlgorithms.distancePointLine(p, this.p0, this.p1);
  }
};
LineSegment.prototype.pointAlong = function pointAlong(segmentLengthFraction) {
  var coord = new Coordinate();
  coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
  coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
  return coord;
};
LineSegment.prototype.hashCode = function hashCode5() {
  var bits0 = Double.doubleToLongBits(this.p0.x);
  bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;
  var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
  var bits1 = Double.doubleToLongBits(this.p1.x);
  bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;
  var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
  return hash0 ^ hash1;
};
LineSegment.prototype.interfaces_ = function interfaces_77() {
  return [Comparable, Serializable];
};
LineSegment.prototype.getClass = function getClass76() {
  return LineSegment;
};
LineSegment.midPoint = function midPoint2(p0, p1) {
  return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
};
staticAccessors$24.serialVersionUID.get = function() {
  return 3252005833466256400;
};
Object.defineProperties(LineSegment, staticAccessors$24);
var MonotoneChainOverlapAction = function MonotoneChainOverlapAction2() {
  this.tempEnv1 = new Envelope();
  this.tempEnv2 = new Envelope();
  this._overlapSeg1 = new LineSegment();
  this._overlapSeg2 = new LineSegment();
};
MonotoneChainOverlapAction.prototype.overlap = function overlap() {
  if (arguments.length === 2) {
  } else if (arguments.length === 4) {
    var mc1 = arguments[0];
    var start1 = arguments[1];
    var mc2 = arguments[2];
    var start2 = arguments[3];
    mc1.getLineSegment(start1, this._overlapSeg1);
    mc2.getLineSegment(start2, this._overlapSeg2);
    this.overlap(this._overlapSeg1, this._overlapSeg2);
  }
};
MonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_78() {
  return [];
};
MonotoneChainOverlapAction.prototype.getClass = function getClass77() {
  return MonotoneChainOverlapAction;
};
var MonotoneChain = function MonotoneChain2() {
  this._pts = null;
  this._start = null;
  this._end = null;
  this._env = null;
  this._context = null;
  this._id = null;
  var pts = arguments[0];
  var start = arguments[1];
  var end = arguments[2];
  var context = arguments[3];
  this._pts = pts;
  this._start = start;
  this._end = end;
  this._context = context;
};
MonotoneChain.prototype.getLineSegment = function getLineSegment(index2, ls) {
  ls.p0 = this._pts[index2];
  ls.p1 = this._pts[index2 + 1];
};
MonotoneChain.prototype.computeSelect = function computeSelect(searchEnv, start0, end0, mcs) {
  var p0 = this._pts[start0];
  var p1 = this._pts[end0];
  mcs.tempEnv1.init(p0, p1);
  if (end0 - start0 === 1) {
    mcs.select(this, start0);
    return null;
  }
  if (!searchEnv.intersects(mcs.tempEnv1)) {
    return null;
  }
  var mid = Math.trunc((start0 + end0) / 2);
  if (start0 < mid) {
    this.computeSelect(searchEnv, start0, mid, mcs);
  }
  if (mid < end0) {
    this.computeSelect(searchEnv, mid, end0, mcs);
  }
};
MonotoneChain.prototype.getCoordinates = function getCoordinates3() {
  var this$1 = this;
  var coord = new Array(this._end - this._start + 1).fill(null);
  var index2 = 0;
  for (var i = this._start; i <= this._end; i++) {
    coord[index2++] = this$1._pts[i];
  }
  return coord;
};
MonotoneChain.prototype.computeOverlaps = function computeOverlaps(mc, mco) {
  this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
};
MonotoneChain.prototype.setId = function setId(id) {
  this._id = id;
};
MonotoneChain.prototype.select = function select(searchEnv, mcs) {
  this.computeSelect(searchEnv, this._start, this._end, mcs);
};
MonotoneChain.prototype.getEnvelope = function getEnvelope3() {
  if (this._env === null) {
    var p0 = this._pts[this._start];
    var p1 = this._pts[this._end];
    this._env = new Envelope(p0, p1);
  }
  return this._env;
};
MonotoneChain.prototype.getEndIndex = function getEndIndex() {
  return this._end;
};
MonotoneChain.prototype.getStartIndex = function getStartIndex() {
  return this._start;
};
MonotoneChain.prototype.getContext = function getContext() {
  return this._context;
};
MonotoneChain.prototype.getId = function getId() {
  return this._id;
};
MonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {
  var p002 = this._pts[start0];
  var p012 = this._pts[end0];
  var p102 = mc._pts[start1];
  var p112 = mc._pts[end1];
  if (end0 - start0 === 1 && end1 - start1 === 1) {
    mco.overlap(this, start0, mc, start1);
    return null;
  }
  mco.tempEnv1.init(p002, p012);
  mco.tempEnv2.init(p102, p112);
  if (!mco.tempEnv1.intersects(mco.tempEnv2)) {
    return null;
  }
  var mid0 = Math.trunc((start0 + end0) / 2);
  var mid1 = Math.trunc((start1 + end1) / 2);
  if (start0 < mid0) {
    if (start1 < mid1) {
      this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);
    }
    if (mid1 < end1) {
      this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);
    }
  }
  if (mid0 < end0) {
    if (start1 < mid1) {
      this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);
    }
    if (mid1 < end1) {
      this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);
    }
  }
};
MonotoneChain.prototype.interfaces_ = function interfaces_79() {
  return [];
};
MonotoneChain.prototype.getClass = function getClass78() {
  return MonotoneChain;
};
var MonotoneChainBuilder = function MonotoneChainBuilder2() {
};
MonotoneChainBuilder.prototype.interfaces_ = function interfaces_80() {
  return [];
};
MonotoneChainBuilder.prototype.getClass = function getClass79() {
  return MonotoneChainBuilder;
};
MonotoneChainBuilder.getChainStartIndices = function getChainStartIndices(pts) {
  var start = 0;
  var startIndexList = new ArrayList();
  startIndexList.add(new Integer(start));
  do {
    var last = MonotoneChainBuilder.findChainEnd(pts, start);
    startIndexList.add(new Integer(last));
    start = last;
  } while (start < pts.length - 1);
  var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
  return startIndex;
};
MonotoneChainBuilder.findChainEnd = function findChainEnd(pts, start) {
  var safeStart = start;
  while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
    safeStart++;
  }
  if (safeStart >= pts.length - 1) {
    return pts.length - 1;
  }
  var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
  var last = start + 1;
  while (last < pts.length) {
    if (!pts[last - 1].equals2D(pts[last])) {
      var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
      if (quad !== chainQuad) {
        break;
      }
    }
    last++;
  }
  return last - 1;
};
MonotoneChainBuilder.getChains = function getChains() {
  if (arguments.length === 1) {
    var pts = arguments[0];
    return MonotoneChainBuilder.getChains(pts, null);
  } else if (arguments.length === 2) {
    var pts$1 = arguments[0];
    var context = arguments[1];
    var mcList = new ArrayList();
    var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);
    for (var i = 0; i < startIndex.length - 1; i++) {
      var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);
      mcList.add(mc);
    }
    return mcList;
  }
};
MonotoneChainBuilder.toIntArray = function toIntArray(list) {
  var array = new Array(list.size()).fill(null);
  for (var i = 0; i < array.length; i++) {
    array[i] = list.get(i).intValue();
  }
  return array;
};
var Noder = function Noder2() {
};
Noder.prototype.computeNodes = function computeNodes(segStrings) {
};
Noder.prototype.getNodedSubstrings = function getNodedSubstrings2() {
};
Noder.prototype.interfaces_ = function interfaces_81() {
  return [];
};
Noder.prototype.getClass = function getClass80() {
  return Noder;
};
var SinglePassNoder = function SinglePassNoder2() {
  this._segInt = null;
  if (arguments.length === 0) {
  } else if (arguments.length === 1) {
    var segInt = arguments[0];
    this.setSegmentIntersector(segInt);
  }
};
SinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector(segInt) {
  this._segInt = segInt;
};
SinglePassNoder.prototype.interfaces_ = function interfaces_82() {
  return [Noder];
};
SinglePassNoder.prototype.getClass = function getClass81() {
  return SinglePassNoder;
};
var MCIndexNoder = function(SinglePassNoder$$1) {
  function MCIndexNoder2(si) {
    if (si) {
      SinglePassNoder$$1.call(this, si);
    } else {
      SinglePassNoder$$1.call(this);
    }
    this._monoChains = new ArrayList();
    this._index = new STRtree();
    this._idCounter = 0;
    this._nodedSegStrings = null;
    this._nOverlaps = 0;
  }
  if (SinglePassNoder$$1)
    MCIndexNoder2.__proto__ = SinglePassNoder$$1;
  MCIndexNoder2.prototype = Object.create(SinglePassNoder$$1 && SinglePassNoder$$1.prototype);
  MCIndexNoder2.prototype.constructor = MCIndexNoder2;
  var staticAccessors2 = { SegmentOverlapAction: { configurable: true } };
  MCIndexNoder2.prototype.getMonotoneChains = function getMonotoneChains() {
    return this._monoChains;
  };
  MCIndexNoder2.prototype.getNodedSubstrings = function getNodedSubstrings5() {
    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
  };
  MCIndexNoder2.prototype.getIndex = function getIndex() {
    return this._index;
  };
  MCIndexNoder2.prototype.add = function add16(segStr) {
    var this$1 = this;
    var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
    for (var i = segChains.iterator(); i.hasNext(); ) {
      var mc = i.next();
      mc.setId(this$1._idCounter++);
      this$1._index.insert(mc.getEnvelope(), mc);
      this$1._monoChains.add(mc);
    }
  };
  MCIndexNoder2.prototype.computeNodes = function computeNodes4(inputSegStrings) {
    var this$1 = this;
    this._nodedSegStrings = inputSegStrings;
    for (var i = inputSegStrings.iterator(); i.hasNext(); ) {
      this$1.add(i.next());
    }
    this.intersectChains();
  };
  MCIndexNoder2.prototype.intersectChains = function intersectChains() {
    var this$1 = this;
    var overlapAction = new SegmentOverlapAction(this._segInt);
    for (var i = this._monoChains.iterator(); i.hasNext(); ) {
      var queryChain = i.next();
      var overlapChains = this$1._index.query(queryChain.getEnvelope());
      for (var j = overlapChains.iterator(); j.hasNext(); ) {
        var testChain = j.next();
        if (testChain.getId() > queryChain.getId()) {
          queryChain.computeOverlaps(testChain, overlapAction);
          this$1._nOverlaps++;
        }
        if (this$1._segInt.isDone()) {
          return null;
        }
      }
    }
  };
  MCIndexNoder2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  MCIndexNoder2.prototype.getClass = function getClass169() {
    return MCIndexNoder2;
  };
  staticAccessors2.SegmentOverlapAction.get = function() {
    return SegmentOverlapAction;
  };
  Object.defineProperties(MCIndexNoder2, staticAccessors2);
  return MCIndexNoder2;
}(SinglePassNoder);
var SegmentOverlapAction = function(MonotoneChainOverlapAction$$1) {
  function SegmentOverlapAction2() {
    MonotoneChainOverlapAction$$1.call(this);
    this._si = null;
    var si = arguments[0];
    this._si = si;
  }
  if (MonotoneChainOverlapAction$$1)
    SegmentOverlapAction2.__proto__ = MonotoneChainOverlapAction$$1;
  SegmentOverlapAction2.prototype = Object.create(MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype);
  SegmentOverlapAction2.prototype.constructor = SegmentOverlapAction2;
  SegmentOverlapAction2.prototype.overlap = function overlap2() {
    if (arguments.length === 4) {
      var mc1 = arguments[0];
      var start1 = arguments[1];
      var mc2 = arguments[2];
      var start2 = arguments[3];
      var ss1 = mc1.getContext();
      var ss2 = mc2.getContext();
      this._si.processIntersections(ss1, start1, ss2, start2);
    } else {
      return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments);
    }
  };
  SegmentOverlapAction2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  SegmentOverlapAction2.prototype.getClass = function getClass169() {
    return SegmentOverlapAction2;
  };
  return SegmentOverlapAction2;
}(MonotoneChainOverlapAction);
var BufferParameters = function BufferParameters2() {
  this._quadrantSegments = BufferParameters2.DEFAULT_QUADRANT_SEGMENTS;
  this._endCapStyle = BufferParameters2.CAP_ROUND;
  this._joinStyle = BufferParameters2.JOIN_ROUND;
  this._mitreLimit = BufferParameters2.DEFAULT_MITRE_LIMIT;
  this._isSingleSided = false;
  this._simplifyFactor = BufferParameters2.DEFAULT_SIMPLIFY_FACTOR;
  if (arguments.length === 0) {
  } else if (arguments.length === 1) {
    var quadrantSegments = arguments[0];
    this.setQuadrantSegments(quadrantSegments);
  } else if (arguments.length === 2) {
    var quadrantSegments$1 = arguments[0];
    var endCapStyle = arguments[1];
    this.setQuadrantSegments(quadrantSegments$1);
    this.setEndCapStyle(endCapStyle);
  } else if (arguments.length === 4) {
    var quadrantSegments$2 = arguments[0];
    var endCapStyle$1 = arguments[1];
    var joinStyle = arguments[2];
    var mitreLimit = arguments[3];
    this.setQuadrantSegments(quadrantSegments$2);
    this.setEndCapStyle(endCapStyle$1);
    this.setJoinStyle(joinStyle);
    this.setMitreLimit(mitreLimit);
  }
};
var staticAccessors$25 = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
BufferParameters.prototype.getEndCapStyle = function getEndCapStyle() {
  return this._endCapStyle;
};
BufferParameters.prototype.isSingleSided = function isSingleSided() {
  return this._isSingleSided;
};
BufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments(quadSegs) {
  this._quadrantSegments = quadSegs;
  if (this._quadrantSegments === 0) {
    this._joinStyle = BufferParameters.JOIN_BEVEL;
  }
  if (this._quadrantSegments < 0) {
    this._joinStyle = BufferParameters.JOIN_MITRE;
    this._mitreLimit = Math.abs(this._quadrantSegments);
  }
  if (quadSegs <= 0) {
    this._quadrantSegments = 1;
  }
  if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
  }
};
BufferParameters.prototype.getJoinStyle = function getJoinStyle() {
  return this._joinStyle;
};
BufferParameters.prototype.setJoinStyle = function setJoinStyle(joinStyle) {
  this._joinStyle = joinStyle;
};
BufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor(simplifyFactor) {
  this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
};
BufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor() {
  return this._simplifyFactor;
};
BufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments() {
  return this._quadrantSegments;
};
BufferParameters.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {
  this._endCapStyle = endCapStyle;
};
BufferParameters.prototype.getMitreLimit = function getMitreLimit() {
  return this._mitreLimit;
};
BufferParameters.prototype.setMitreLimit = function setMitreLimit(mitreLimit) {
  this._mitreLimit = mitreLimit;
};
BufferParameters.prototype.setSingleSided = function setSingleSided(isSingleSided2) {
  this._isSingleSided = isSingleSided2;
};
BufferParameters.prototype.interfaces_ = function interfaces_83() {
  return [];
};
BufferParameters.prototype.getClass = function getClass82() {
  return BufferParameters;
};
BufferParameters.bufferDistanceError = function bufferDistanceError(quadSegs) {
  var alpha = Math.PI / 2 / quadSegs;
  return 1 - Math.cos(alpha / 2);
};
staticAccessors$25.CAP_ROUND.get = function() {
  return 1;
};
staticAccessors$25.CAP_FLAT.get = function() {
  return 2;
};
staticAccessors$25.CAP_SQUARE.get = function() {
  return 3;
};
staticAccessors$25.JOIN_ROUND.get = function() {
  return 1;
};
staticAccessors$25.JOIN_MITRE.get = function() {
  return 2;
};
staticAccessors$25.JOIN_BEVEL.get = function() {
  return 3;
};
staticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function() {
  return 8;
};
staticAccessors$25.DEFAULT_MITRE_LIMIT.get = function() {
  return 5;
};
staticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function() {
  return 0.01;
};
Object.defineProperties(BufferParameters, staticAccessors$25);
var BufferInputLineSimplifier = function BufferInputLineSimplifier2(inputLine) {
  this._distanceTol = null;
  this._isDeleted = null;
  this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;
  this._inputLine = inputLine || null;
};
var staticAccessors$26 = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
BufferInputLineSimplifier.prototype.isDeletable = function isDeletable(i0, i1, i2, distanceTol) {
  var p0 = this._inputLine[i0];
  var p1 = this._inputLine[i1];
  var p2 = this._inputLine[i2];
  if (!this.isConcave(p0, p1, p2)) {
    return false;
  }
  if (!this.isShallow(p0, p1, p2, distanceTol)) {
    return false;
  }
  return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
};
BufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities() {
  var this$1 = this;
  var index2 = 1;
  var midIndex = this.findNextNonDeletedIndex(index2);
  var lastIndex = this.findNextNonDeletedIndex(midIndex);
  var isChanged = false;
  while (lastIndex < this._inputLine.length) {
    var isMiddleVertexDeleted = false;
    if (this$1.isDeletable(index2, midIndex, lastIndex, this$1._distanceTol)) {
      this$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
      isMiddleVertexDeleted = true;
      isChanged = true;
    }
    if (isMiddleVertexDeleted) {
      index2 = lastIndex;
    } else {
      index2 = midIndex;
    }
    midIndex = this$1.findNextNonDeletedIndex(index2);
    lastIndex = this$1.findNextNonDeletedIndex(midIndex);
  }
  return isChanged;
};
BufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity(p0, p1, p2, distanceTol) {
  var orientation2 = CGAlgorithms.computeOrientation(p0, p1, p2);
  var isAngleToSimplify = orientation2 === this._angleOrientation;
  if (!isAngleToSimplify) {
    return false;
  }
  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
  return dist < distanceTol;
};
BufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled(p0, p2, i0, i2, distanceTol) {
  var this$1 = this;
  var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
  if (inc <= 0) {
    inc = 1;
  }
  for (var i = i0; i < i2; i += inc) {
    if (!this$1.isShallow(p0, p2, this$1._inputLine[i], distanceTol)) {
      return false;
    }
  }
  return true;
};
BufferInputLineSimplifier.prototype.isConcave = function isConcave(p0, p1, p2) {
  var orientation2 = CGAlgorithms.computeOrientation(p0, p1, p2);
  var isConcave2 = orientation2 === this._angleOrientation;
  return isConcave2;
};
BufferInputLineSimplifier.prototype.simplify = function simplify2(distanceTol) {
  var this$1 = this;
  this._distanceTol = Math.abs(distanceTol);
  if (distanceTol < 0) {
    this._angleOrientation = CGAlgorithms.CLOCKWISE;
  }
  this._isDeleted = new Array(this._inputLine.length).fill(null);
  var isChanged = false;
  do {
    isChanged = this$1.deleteShallowConcavities();
  } while (isChanged);
  return this.collapseLine();
};
BufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex(index2) {
  var next3 = index2 + 1;
  while (next3 < this._inputLine.length && this._isDeleted[next3] === BufferInputLineSimplifier.DELETE) {
    next3++;
  }
  return next3;
};
BufferInputLineSimplifier.prototype.isShallow = function isShallow(p0, p1, p2, distanceTol) {
  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
  return dist < distanceTol;
};
BufferInputLineSimplifier.prototype.collapseLine = function collapseLine() {
  var this$1 = this;
  var coordList = new CoordinateList();
  for (var i = 0; i < this._inputLine.length; i++) {
    if (this$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) {
      coordList.add(this$1._inputLine[i]);
    }
  }
  return coordList.toCoordinateArray();
};
BufferInputLineSimplifier.prototype.interfaces_ = function interfaces_84() {
  return [];
};
BufferInputLineSimplifier.prototype.getClass = function getClass83() {
  return BufferInputLineSimplifier;
};
BufferInputLineSimplifier.simplify = function simplify3(inputLine, distanceTol) {
  var simp = new BufferInputLineSimplifier(inputLine);
  return simp.simplify(distanceTol);
};
staticAccessors$26.INIT.get = function() {
  return 0;
};
staticAccessors$26.DELETE.get = function() {
  return 1;
};
staticAccessors$26.KEEP.get = function() {
  return 1;
};
staticAccessors$26.NUM_PTS_TO_CHECK.get = function() {
  return 10;
};
Object.defineProperties(BufferInputLineSimplifier, staticAccessors$26);
var OffsetSegmentString = function OffsetSegmentString2() {
  this._ptList = null;
  this._precisionModel = null;
  this._minimimVertexDistance = 0;
  this._ptList = new ArrayList();
};
var staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };
OffsetSegmentString.prototype.getCoordinates = function getCoordinates4() {
  var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
  return coord;
};
OffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel2(precisionModel) {
  this._precisionModel = precisionModel;
};
OffsetSegmentString.prototype.addPt = function addPt(pt) {
  var bufPt = new Coordinate(pt);
  this._precisionModel.makePrecise(bufPt);
  if (this.isRedundant(bufPt)) {
    return null;
  }
  this._ptList.add(bufPt);
};
OffsetSegmentString.prototype.revere = function revere() {
};
OffsetSegmentString.prototype.addPts = function addPts(pt, isForward) {
  var this$1 = this;
  if (isForward) {
    for (var i = 0; i < pt.length; i++) {
      this$1.addPt(pt[i]);
    }
  } else {
    for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {
      this$1.addPt(pt[i$1]);
    }
  }
};
OffsetSegmentString.prototype.isRedundant = function isRedundant(pt) {
  if (this._ptList.size() < 1) {
    return false;
  }
  var lastPt = this._ptList.get(this._ptList.size() - 1);
  var ptDist = pt.distance(lastPt);
  if (ptDist < this._minimimVertexDistance) {
    return true;
  }
  return false;
};
OffsetSegmentString.prototype.toString = function toString16() {
  var fact = new GeometryFactory();
  var line = fact.createLineString(this.getCoordinates());
  return line.toString();
};
OffsetSegmentString.prototype.closeRing = function closeRing() {
  if (this._ptList.size() < 1) {
    return null;
  }
  var startPt = new Coordinate(this._ptList.get(0));
  var lastPt = this._ptList.get(this._ptList.size() - 1);
  if (startPt.equals(lastPt)) {
    return null;
  }
  this._ptList.add(startPt);
};
OffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance(minimimVertexDistance) {
  this._minimimVertexDistance = minimimVertexDistance;
};
OffsetSegmentString.prototype.interfaces_ = function interfaces_85() {
  return [];
};
OffsetSegmentString.prototype.getClass = function getClass84() {
  return OffsetSegmentString;
};
staticAccessors$28.COORDINATE_ARRAY_TYPE.get = function() {
  return new Array(0).fill(null);
};
Object.defineProperties(OffsetSegmentString, staticAccessors$28);
var Angle = function Angle2() {
};
var staticAccessors$29 = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
Angle.prototype.interfaces_ = function interfaces_86() {
  return [];
};
Angle.prototype.getClass = function getClass85() {
  return Angle;
};
Angle.toDegrees = function toDegrees(radians) {
  return radians * 180 / Math.PI;
};
Angle.normalize = function normalize4(angle4) {
  while (angle4 > Math.PI) {
    angle4 -= Angle.PI_TIMES_2;
  }
  while (angle4 <= -Math.PI) {
    angle4 += Angle.PI_TIMES_2;
  }
  return angle4;
};
Angle.angle = function angle3() {
  if (arguments.length === 1) {
    var p = arguments[0];
    return Math.atan2(p.y, p.x);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    var dx = p1.x - p0.x;
    var dy = p1.y - p0.y;
    return Math.atan2(dy, dx);
  }
};
Angle.isAcute = function isAcute(p0, p1, p2) {
  var dx0 = p0.x - p1.x;
  var dy0 = p0.y - p1.y;
  var dx1 = p2.x - p1.x;
  var dy1 = p2.y - p1.y;
  var dotprod = dx0 * dx1 + dy0 * dy1;
  return dotprod > 0;
};
Angle.isObtuse = function isObtuse(p0, p1, p2) {
  var dx0 = p0.x - p1.x;
  var dy0 = p0.y - p1.y;
  var dx1 = p2.x - p1.x;
  var dy1 = p2.y - p1.y;
  var dotprod = dx0 * dx1 + dy0 * dy1;
  return dotprod < 0;
};
Angle.interiorAngle = function interiorAngle(p0, p1, p2) {
  var anglePrev = Angle.angle(p1, p0);
  var angleNext = Angle.angle(p1, p2);
  return Math.abs(angleNext - anglePrev);
};
Angle.normalizePositive = function normalizePositive(angle4) {
  if (angle4 < 0) {
    while (angle4 < 0) {
      angle4 += Angle.PI_TIMES_2;
    }
    if (angle4 >= Angle.PI_TIMES_2) {
      angle4 = 0;
    }
  } else {
    while (angle4 >= Angle.PI_TIMES_2) {
      angle4 -= Angle.PI_TIMES_2;
    }
    if (angle4 < 0) {
      angle4 = 0;
    }
  }
  return angle4;
};
Angle.angleBetween = function angleBetween(tip1, tail, tip2) {
  var a1 = Angle.angle(tail, tip1);
  var a2 = Angle.angle(tail, tip2);
  return Angle.diff(a1, a2);
};
Angle.diff = function diff(ang1, ang2) {
  var delAngle = null;
  if (ang1 < ang2) {
    delAngle = ang2 - ang1;
  } else {
    delAngle = ang1 - ang2;
  }
  if (delAngle > Math.PI) {
    delAngle = 2 * Math.PI - delAngle;
  }
  return delAngle;
};
Angle.toRadians = function toRadians(angleDegrees) {
  return angleDegrees * Math.PI / 180;
};
Angle.getTurn = function getTurn(ang1, ang2) {
  var crossproduct = Math.sin(ang2 - ang1);
  if (crossproduct > 0) {
    return Angle.COUNTERCLOCKWISE;
  }
  if (crossproduct < 0) {
    return Angle.CLOCKWISE;
  }
  return Angle.NONE;
};
Angle.angleBetweenOriented = function angleBetweenOriented(tip1, tail, tip2) {
  var a1 = Angle.angle(tail, tip1);
  var a2 = Angle.angle(tail, tip2);
  var angDel = a2 - a1;
  if (angDel <= -Math.PI) {
    return angDel + Angle.PI_TIMES_2;
  }
  if (angDel > Math.PI) {
    return angDel - Angle.PI_TIMES_2;
  }
  return angDel;
};
staticAccessors$29.PI_TIMES_2.get = function() {
  return 2 * Math.PI;
};
staticAccessors$29.PI_OVER_2.get = function() {
  return Math.PI / 2;
};
staticAccessors$29.PI_OVER_4.get = function() {
  return Math.PI / 4;
};
staticAccessors$29.COUNTERCLOCKWISE.get = function() {
  return CGAlgorithms.COUNTERCLOCKWISE;
};
staticAccessors$29.CLOCKWISE.get = function() {
  return CGAlgorithms.CLOCKWISE;
};
staticAccessors$29.NONE.get = function() {
  return CGAlgorithms.COLLINEAR;
};
Object.defineProperties(Angle, staticAccessors$29);
var OffsetSegmentGenerator = function OffsetSegmentGenerator2() {
  this._maxCurveSegmentError = 0;
  this._filletAngleQuantum = null;
  this._closingSegLengthFactor = 1;
  this._segList = null;
  this._distance = 0;
  this._precisionModel = null;
  this._bufParams = null;
  this._li = null;
  this._s0 = null;
  this._s1 = null;
  this._s2 = null;
  this._seg0 = new LineSegment();
  this._seg1 = new LineSegment();
  this._offset0 = new LineSegment();
  this._offset1 = new LineSegment();
  this._side = 0;
  this._hasNarrowConcaveAngle = false;
  var precisionModel = arguments[0];
  var bufParams = arguments[1];
  var distance11 = arguments[2];
  this._precisionModel = precisionModel;
  this._bufParams = bufParams;
  this._li = new RobustLineIntersector();
  this._filletAngleQuantum = Math.PI / 2 / bufParams.getQuadrantSegments();
  if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) {
    this._closingSegLengthFactor = OffsetSegmentGenerator2.MAX_CLOSING_SEG_LEN_FACTOR;
  }
  this.init(distance11);
};
var staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
OffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment(p, addStartPoint) {
  this._s0 = this._s1;
  this._s1 = this._s2;
  this._s2 = p;
  this._seg0.setCoordinates(this._s0, this._s1);
  this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
  this._seg1.setCoordinates(this._s1, this._s2);
  this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
  if (this._s1.equals(this._s2)) {
    return null;
  }
  var orientation2 = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);
  var outsideTurn = orientation2 === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation2 === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;
  if (orientation2 === 0) {
    this.addCollinear(addStartPoint);
  } else if (outsideTurn) {
    this.addOutsideTurn(orientation2, addStartPoint);
  } else {
    this.addInsideTurn(orientation2, addStartPoint);
  }
};
OffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap(p0, p1) {
  var seg = new LineSegment(p0, p1);
  var offsetL = new LineSegment();
  this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
  var offsetR = new LineSegment();
  this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  var angle4 = Math.atan2(dy, dx);
  switch (this._bufParams.getEndCapStyle()) {
    case BufferParameters.CAP_ROUND:
      this._segList.addPt(offsetL.p1);
      this.addFilletArc(p1, angle4 + Math.PI / 2, angle4 - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);
      this._segList.addPt(offsetR.p1);
      break;
    case BufferParameters.CAP_FLAT:
      this._segList.addPt(offsetL.p1);
      this._segList.addPt(offsetR.p1);
      break;
    case BufferParameters.CAP_SQUARE:
      var squareCapSideOffset = new Coordinate();
      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle4);
      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle4);
      var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
      var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
      this._segList.addPt(squareCapLOffset);
      this._segList.addPt(squareCapROffset);
      break;
    default:
  }
};
OffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates5() {
  var pts = this._segList.getCoordinates();
  return pts;
};
OffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin(p, offset0, offset1, distance11) {
  var isMitreWithinLimit = true;
  var intPt = null;
  try {
    intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
    var mitreRatio = distance11 <= 0 ? 1 : intPt.distance(p) / Math.abs(distance11);
    if (mitreRatio > this._bufParams.getMitreLimit()) {
      isMitreWithinLimit = false;
    }
  } catch (ex) {
    if (ex instanceof NotRepresentableException) {
      intPt = new Coordinate(0, 0);
      isMitreWithinLimit = false;
    } else {
      throw ex;
    }
  } finally {
  }
  if (isMitreWithinLimit) {
    this._segList.addPt(intPt);
  } else {
    this.addLimitedMitreJoin(offset0, offset1, distance11, this._bufParams.getMitreLimit());
  }
};
OffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner(p, p0, p1, direction, radius) {
  var dx0 = p0.x - p.x;
  var dy0 = p0.y - p.y;
  var startAngle = Math.atan2(dy0, dx0);
  var dx1 = p1.x - p.x;
  var dy1 = p1.y - p.y;
  var endAngle = Math.atan2(dy1, dx1);
  if (direction === CGAlgorithms.CLOCKWISE) {
    if (startAngle <= endAngle) {
      startAngle += 2 * Math.PI;
    }
  } else {
    if (startAngle >= endAngle) {
      startAngle -= 2 * Math.PI;
    }
  }
  this._segList.addPt(p0);
  this.addFilletArc(p, startAngle, endAngle, direction, radius);
  this._segList.addPt(p1);
};
OffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn(orientation2, addStartPoint) {
  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
    this._segList.addPt(this._offset0.p1);
    return null;
  }
  if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
    this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
  } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
    this.addBevelJoin(this._offset0, this._offset1);
  } else {
    if (addStartPoint) {
      this._segList.addPt(this._offset0.p1);
    }
    this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation2, this._distance);
    this._segList.addPt(this._offset1.p0);
  }
};
OffsetSegmentGenerator.prototype.createSquare = function createSquare(p) {
  this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
  this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
  this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
  this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
  this._segList.closeRing();
};
OffsetSegmentGenerator.prototype.addSegments = function addSegments(pt, isForward) {
  this._segList.addPts(pt, isForward);
};
OffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment() {
  this._segList.addPt(this._offset1.p0);
};
OffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment() {
  this._segList.addPt(this._offset1.p1);
};
OffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments(s1, s2, side) {
  this._s1 = s1;
  this._s2 = s2;
  this._side = side;
  this._seg1.setCoordinates(s1, s2);
  this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
};
OffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin(offset0, offset1, distance11, mitreLimit) {
  var basePt = this._seg0.p1;
  var ang0 = Angle.angle(basePt, this._seg0.p0);
  var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
  var angDiffHalf = angDiff / 2;
  var midAng = Angle.normalize(ang0 + angDiffHalf);
  var mitreMidAng = Angle.normalize(midAng + Math.PI);
  var mitreDist = mitreLimit * distance11;
  var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
  var bevelHalfLen = distance11 - bevelDelta;
  var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
  var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
  var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
  var mitreMidLine = new LineSegment(basePt, bevelMidPt);
  var bevelEndLeft = mitreMidLine.pointAlongOffset(1, bevelHalfLen);
  var bevelEndRight = mitreMidLine.pointAlongOffset(1, -bevelHalfLen);
  if (this._side === Position.LEFT) {
    this._segList.addPt(bevelEndLeft);
    this._segList.addPt(bevelEndRight);
  } else {
    this._segList.addPt(bevelEndRight);
    this._segList.addPt(bevelEndLeft);
  }
};
OffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment(seg, side, distance11, offset) {
  var sideSign = side === Position.LEFT ? 1 : -1;
  var dx = seg.p1.x - seg.p0.x;
  var dy = seg.p1.y - seg.p0.y;
  var len = Math.sqrt(dx * dx + dy * dy);
  var ux = sideSign * distance11 * dx / len;
  var uy = sideSign * distance11 * dy / len;
  offset.p0.x = seg.p0.x - uy;
  offset.p0.y = seg.p0.y + ux;
  offset.p1.x = seg.p1.x - uy;
  offset.p1.y = seg.p1.y + ux;
};
OffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc(p, startAngle, endAngle, direction, radius) {
  var this$1 = this;
  var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;
  var totalAngle = Math.abs(startAngle - endAngle);
  var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
  if (nSegs < 1) {
    return null;
  }
  var initAngle = 0;
  var currAngleInc = totalAngle / nSegs;
  var currAngle = initAngle;
  var pt = new Coordinate();
  while (currAngle < totalAngle) {
    var angle4 = startAngle + directionFactor * currAngle;
    pt.x = p.x + radius * Math.cos(angle4);
    pt.y = p.y + radius * Math.sin(angle4);
    this$1._segList.addPt(pt);
    currAngle += currAngleInc;
  }
};
OffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn(orientation2, addStartPoint) {
  this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
  if (this._li.hasIntersection()) {
    this._segList.addPt(this._li.getIntersection(0));
  } else {
    this._hasNarrowConcaveAngle = true;
    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
      this._segList.addPt(this._offset0.p1);
    } else {
      this._segList.addPt(this._offset0.p1);
      if (this._closingSegLengthFactor > 0) {
        var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
        this._segList.addPt(mid0);
        var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
        this._segList.addPt(mid1);
      } else {
        this._segList.addPt(this._s1);
      }
      this._segList.addPt(this._offset1.p0);
    }
  }
};
OffsetSegmentGenerator.prototype.createCircle = function createCircle(p) {
  var pt = new Coordinate(p.x + this._distance, p.y);
  this._segList.addPt(pt);
  this.addFilletArc(p, 0, 2 * Math.PI, -1, this._distance);
  this._segList.closeRing();
};
OffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin(offset0, offset1) {
  this._segList.addPt(offset0.p1);
  this._segList.addPt(offset1.p0);
};
OffsetSegmentGenerator.prototype.init = function init5(distance11) {
  this._distance = distance11;
  this._maxCurveSegmentError = distance11 * (1 - Math.cos(this._filletAngleQuantum / 2));
  this._segList = new OffsetSegmentString();
  this._segList.setPrecisionModel(this._precisionModel);
  this._segList.setMinimumVertexDistance(distance11 * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
};
OffsetSegmentGenerator.prototype.addCollinear = function addCollinear(addStartPoint) {
  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
  var numInt = this._li.getIntersectionNum();
  if (numInt >= 2) {
    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
      if (addStartPoint) {
        this._segList.addPt(this._offset0.p1);
      }
      this._segList.addPt(this._offset1.p0);
    } else {
      this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);
    }
  }
};
OffsetSegmentGenerator.prototype.closeRing = function closeRing2() {
  this._segList.closeRing();
};
OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle() {
  return this._hasNarrowConcaveAngle;
};
OffsetSegmentGenerator.prototype.interfaces_ = function interfaces_87() {
  return [];
};
OffsetSegmentGenerator.prototype.getClass = function getClass86() {
  return OffsetSegmentGenerator;
};
staticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
  return 1e-3;
};
staticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-3;
};
staticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-6;
};
staticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
  return 80;
};
Object.defineProperties(OffsetSegmentGenerator, staticAccessors$27);
var OffsetCurveBuilder = function OffsetCurveBuilder2() {
  this._distance = 0;
  this._precisionModel = null;
  this._bufParams = null;
  var precisionModel = arguments[0];
  var bufParams = arguments[1];
  this._precisionModel = precisionModel;
  this._bufParams = bufParams;
};
OffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve(inputPts, distance11) {
  this._distance = distance11;
  if (distance11 === 0) {
    return null;
  }
  var isRightSide = distance11 < 0;
  var posDistance = Math.abs(distance11);
  var segGen = this.getSegGen(posDistance);
  if (inputPts.length <= 1) {
    this.computePointCurve(inputPts[0], segGen);
  } else {
    this.computeOffsetCurve(inputPts, isRightSide, segGen);
  }
  var curvePts = segGen.getCoordinates();
  if (isRightSide) {
    CoordinateArrays.reverse(curvePts);
  }
  return curvePts;
};
OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  if (isRightSide) {
    segGen.addSegments(inputPts, true);
    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
    var n2 = simp2.length - 1;
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
  } else {
    segGen.addSegments(inputPts, false);
    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
    var n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i$1 = 2; i$1 <= n1; i$1++) {
      segGen.addNextSegment(simp1[i$1], true);
    }
  }
  segGen.addLastSegment();
  segGen.closeRing();
};
OffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve(inputPts, side, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  if (side === Position.RIGHT) {
    distTol = -distTol;
  }
  var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
  var n = simp.length - 1;
  segGen.initSideSegments(simp[n - 1], simp[0], side);
  for (var i = 1; i <= n; i++) {
    var addStartPoint = i !== 1;
    segGen.addNextSegment(simp[i], addStartPoint);
  }
  segGen.closeRing();
};
OffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve(inputPts, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
  var n1 = simp1.length - 1;
  segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
  for (var i = 2; i <= n1; i++) {
    segGen.addNextSegment(simp1[i], true);
  }
  segGen.addLastSegment();
  segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
  var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
  var n2 = simp2.length - 1;
  segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
  for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {
    segGen.addNextSegment(simp2[i$1], true);
  }
  segGen.addLastSegment();
  segGen.addLineEndCap(simp2[1], simp2[0]);
  segGen.closeRing();
};
OffsetCurveBuilder.prototype.computePointCurve = function computePointCurve(pt, segGen) {
  switch (this._bufParams.getEndCapStyle()) {
    case BufferParameters.CAP_ROUND:
      segGen.createCircle(pt);
      break;
    case BufferParameters.CAP_SQUARE:
      segGen.createSquare(pt);
      break;
    default:
  }
};
OffsetCurveBuilder.prototype.getLineCurve = function getLineCurve(inputPts, distance11) {
  this._distance = distance11;
  if (distance11 < 0 && !this._bufParams.isSingleSided()) {
    return null;
  }
  if (distance11 === 0) {
    return null;
  }
  var posDistance = Math.abs(distance11);
  var segGen = this.getSegGen(posDistance);
  if (inputPts.length <= 1) {
    this.computePointCurve(inputPts[0], segGen);
  } else {
    if (this._bufParams.isSingleSided()) {
      var isRightSide = distance11 < 0;
      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
    } else {
      this.computeLineBufferCurve(inputPts, segGen);
    }
  }
  var lineCoord = segGen.getCoordinates();
  return lineCoord;
};
OffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters() {
  return this._bufParams;
};
OffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance(bufDistance) {
  return bufDistance * this._bufParams.getSimplifyFactor();
};
OffsetCurveBuilder.prototype.getRingCurve = function getRingCurve(inputPts, side, distance11) {
  this._distance = distance11;
  if (inputPts.length <= 2) {
    return this.getLineCurve(inputPts, distance11);
  }
  if (distance11 === 0) {
    return OffsetCurveBuilder.copyCoordinates(inputPts);
  }
  var segGen = this.getSegGen(distance11);
  this.computeRingBufferCurve(inputPts, side, segGen);
  return segGen.getCoordinates();
};
OffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve(inputPts, isRightSide, segGen) {
  var distTol = this.simplifyTolerance(this._distance);
  if (isRightSide) {
    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
    var n2 = simp2.length - 1;
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
  } else {
    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
    var n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
    segGen.addFirstSegment();
    for (var i$1 = 2; i$1 <= n1; i$1++) {
      segGen.addNextSegment(simp1[i$1], true);
    }
  }
  segGen.addLastSegment();
};
OffsetCurveBuilder.prototype.getSegGen = function getSegGen(distance11) {
  return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance11);
};
OffsetCurveBuilder.prototype.interfaces_ = function interfaces_88() {
  return [];
};
OffsetCurveBuilder.prototype.getClass = function getClass87() {
  return OffsetCurveBuilder;
};
OffsetCurveBuilder.copyCoordinates = function copyCoordinates(pts) {
  var copy7 = new Array(pts.length).fill(null);
  for (var i = 0; i < copy7.length; i++) {
    copy7[i] = new Coordinate(pts[i]);
  }
  return copy7;
};
var SubgraphDepthLocater = function SubgraphDepthLocater2() {
  this._subgraphs = null;
  this._seg = new LineSegment();
  this._cga = new CGAlgorithms();
  var subgraphs = arguments[0];
  this._subgraphs = subgraphs;
};
var staticAccessors$30 = { DepthSegment: { configurable: true } };
SubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments() {
  var this$1 = this;
  if (arguments.length === 1) {
    var stabbingRayLeftPt = arguments[0];
    var stabbedSegments = new ArrayList();
    for (var i = this._subgraphs.iterator(); i.hasNext(); ) {
      var bsg = i.next();
      var env = bsg.getEnvelope();
      if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) {
        continue;
      }
      this$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
    }
    return stabbedSegments;
  } else if (arguments.length === 3) {
    if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {
      var stabbingRayLeftPt$1 = arguments[0];
      var dirEdge = arguments[1];
      var stabbedSegments$1 = arguments[2];
      var pts = dirEdge.getEdge().getCoordinates();
      for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {
        this$1._seg.p0 = pts[i$1];
        this$1._seg.p1 = pts[i$1 + 1];
        if (this$1._seg.p0.y > this$1._seg.p1.y) {
          this$1._seg.reverse();
        }
        var maxx = Math.max(this$1._seg.p0.x, this$1._seg.p1.x);
        if (maxx < stabbingRayLeftPt$1.x) {
          continue;
        }
        if (this$1._seg.isHorizontal()) {
          continue;
        }
        if (stabbingRayLeftPt$1.y < this$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1._seg.p1.y) {
          continue;
        }
        if (CGAlgorithms.computeOrientation(this$1._seg.p0, this$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) {
          continue;
        }
        var depth2 = dirEdge.getDepth(Position.LEFT);
        if (!this$1._seg.p0.equals(pts[i$1])) {
          depth2 = dirEdge.getDepth(Position.RIGHT);
        }
        var ds = new DepthSegment(this$1._seg, depth2);
        stabbedSegments$1.add(ds);
      }
    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {
      var stabbingRayLeftPt$2 = arguments[0];
      var dirEdges = arguments[1];
      var stabbedSegments$2 = arguments[2];
      for (var i$2 = dirEdges.iterator(); i$2.hasNext(); ) {
        var de = i$2.next();
        if (!de.isForward()) {
          continue;
        }
        this$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);
      }
    }
  }
};
SubgraphDepthLocater.prototype.getDepth = function getDepth(p) {
  var stabbedSegments = this.findStabbedSegments(p);
  if (stabbedSegments.size() === 0) {
    return 0;
  }
  var ds = Collections.min(stabbedSegments);
  return ds._leftDepth;
};
SubgraphDepthLocater.prototype.interfaces_ = function interfaces_89() {
  return [];
};
SubgraphDepthLocater.prototype.getClass = function getClass88() {
  return SubgraphDepthLocater;
};
staticAccessors$30.DepthSegment.get = function() {
  return DepthSegment;
};
Object.defineProperties(SubgraphDepthLocater, staticAccessors$30);
var DepthSegment = function DepthSegment2() {
  this._upwardSeg = null;
  this._leftDepth = null;
  var seg = arguments[0];
  var depth2 = arguments[1];
  this._upwardSeg = new LineSegment(seg);
  this._leftDepth = depth2;
};
DepthSegment.prototype.compareTo = function compareTo12(obj) {
  var other = obj;
  if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) {
    return 1;
  }
  if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) {
    return -1;
  }
  var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
  if (orientIndex !== 0) {
    return orientIndex;
  }
  orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
  if (orientIndex !== 0) {
    return orientIndex;
  }
  return this._upwardSeg.compareTo(other._upwardSeg);
};
DepthSegment.prototype.compareX = function compareX(seg0, seg1) {
  var compare0 = seg0.p0.compareTo(seg1.p0);
  if (compare0 !== 0) {
    return compare0;
  }
  return seg0.p1.compareTo(seg1.p1);
};
DepthSegment.prototype.toString = function toString17() {
  return this._upwardSeg.toString();
};
DepthSegment.prototype.interfaces_ = function interfaces_90() {
  return [Comparable];
};
DepthSegment.prototype.getClass = function getClass89() {
  return DepthSegment;
};
var Triangle2 = function Triangle3(p0, p1, p2) {
  this.p0 = p0 || null;
  this.p1 = p1 || null;
  this.p2 = p2 || null;
};
Triangle2.prototype.area = function area3() {
  return Triangle2.area(this.p0, this.p1, this.p2);
};
Triangle2.prototype.signedArea = function signedArea2() {
  return Triangle2.signedArea(this.p0, this.p1, this.p2);
};
Triangle2.prototype.interpolateZ = function interpolateZ(p) {
  if (p === null) {
    throw new IllegalArgumentException("Supplied point is null.");
  }
  return Triangle2.interpolateZ(p, this.p0, this.p1, this.p2);
};
Triangle2.prototype.longestSideLength = function longestSideLength() {
  return Triangle2.longestSideLength(this.p0, this.p1, this.p2);
};
Triangle2.prototype.isAcute = function isAcute2() {
  return Triangle2.isAcute(this.p0, this.p1, this.p2);
};
Triangle2.prototype.circumcentre = function circumcentre() {
  return Triangle2.circumcentre(this.p0, this.p1, this.p2);
};
Triangle2.prototype.area3D = function area3D() {
  return Triangle2.area3D(this.p0, this.p1, this.p2);
};
Triangle2.prototype.centroid = function centroid2() {
  return Triangle2.centroid(this.p0, this.p1, this.p2);
};
Triangle2.prototype.inCentre = function inCentre() {
  return Triangle2.inCentre(this.p0, this.p1, this.p2);
};
Triangle2.prototype.interfaces_ = function interfaces_91() {
  return [];
};
Triangle2.prototype.getClass = function getClass90() {
  return Triangle2;
};
Triangle2.area = function area4(a, b, c) {
  return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
};
Triangle2.signedArea = function signedArea3(a, b, c) {
  return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
};
Triangle2.det = function det(m00, m01, m10, m11) {
  return m00 * m11 - m01 * m10;
};
Triangle2.interpolateZ = function interpolateZ2(p, v0, v1, v2) {
  var x0 = v0.x;
  var y0 = v0.y;
  var a = v1.x - x0;
  var b = v2.x - x0;
  var c = v1.y - y0;
  var d = v2.y - y0;
  var det2 = a * d - b * c;
  var dx = p.x - x0;
  var dy = p.y - y0;
  var t = (d * dx - b * dy) / det2;
  var u = (-c * dx + a * dy) / det2;
  var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
  return z;
};
Triangle2.longestSideLength = function longestSideLength2(a, b, c) {
  var lenAB = a.distance(b);
  var lenBC = b.distance(c);
  var lenCA = c.distance(a);
  var maxLen = lenAB;
  if (lenBC > maxLen) {
    maxLen = lenBC;
  }
  if (lenCA > maxLen) {
    maxLen = lenCA;
  }
  return maxLen;
};
Triangle2.isAcute = function isAcute3(a, b, c) {
  if (!Angle.isAcute(a, b, c)) {
    return false;
  }
  if (!Angle.isAcute(b, c, a)) {
    return false;
  }
  if (!Angle.isAcute(c, a, b)) {
    return false;
  }
  return true;
};
Triangle2.circumcentre = function circumcentre2(a, b, c) {
  var cx = c.x;
  var cy = c.y;
  var ax = a.x - cx;
  var ay = a.y - cy;
  var bx = b.x - cx;
  var by = b.y - cy;
  var denom = 2 * Triangle2.det(ax, ay, bx, by);
  var numx = Triangle2.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
  var numy = Triangle2.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
  var ccx = cx - numx / denom;
  var ccy = cy + numy / denom;
  return new Coordinate(ccx, ccy);
};
Triangle2.perpendicularBisector = function perpendicularBisector(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var l1 = new HCoordinate(a.x + dx / 2, a.y + dy / 2, 1);
  var l2 = new HCoordinate(a.x - dy + dx / 2, a.y + dx + dy / 2, 1);
  return new HCoordinate(l1, l2);
};
Triangle2.angleBisector = function angleBisector(a, b, c) {
  var len0 = b.distance(a);
  var len2 = b.distance(c);
  var frac = len0 / (len0 + len2);
  var dx = c.x - a.x;
  var dy = c.y - a.y;
  var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
  return splitPt;
};
Triangle2.area3D = function area3D2(a, b, c) {
  var ux = b.x - a.x;
  var uy = b.y - a.y;
  var uz = b.z - a.z;
  var vx = c.x - a.x;
  var vy = c.y - a.y;
  var vz = c.z - a.z;
  var crossx = uy * vz - uz * vy;
  var crossy = uz * vx - ux * vz;
  var crossz = ux * vy - uy * vx;
  var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
  var area3D3 = Math.sqrt(absSq) / 2;
  return area3D3;
};
Triangle2.centroid = function centroid3(a, b, c) {
  var x2 = (a.x + b.x + c.x) / 3;
  var y2 = (a.y + b.y + c.y) / 3;
  return new Coordinate(x2, y2);
};
Triangle2.inCentre = function inCentre2(a, b, c) {
  var len0 = b.distance(c);
  var len1 = a.distance(c);
  var len2 = a.distance(b);
  var circum = len0 + len1 + len2;
  var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
  var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
  return new Coordinate(inCentreX, inCentreY);
};
var OffsetCurveSetBuilder = function OffsetCurveSetBuilder2() {
  this._inputGeom = null;
  this._distance = null;
  this._curveBuilder = null;
  this._curveList = new ArrayList();
  var inputGeom = arguments[0];
  var distance11 = arguments[1];
  var curveBuilder = arguments[2];
  this._inputGeom = inputGeom;
  this._distance = distance11;
  this._curveBuilder = curveBuilder;
};
OffsetCurveSetBuilder.prototype.addPoint = function addPoint(p) {
  if (this._distance <= 0) {
    return null;
  }
  var coord = p.getCoordinates();
  var curve = this._curveBuilder.getLineCurve(coord, this._distance);
  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
};
OffsetCurveSetBuilder.prototype.addPolygon = function addPolygon(p) {
  var this$1 = this;
  var offsetDistance = this._distance;
  var offsetSide = Position.LEFT;
  if (this._distance < 0) {
    offsetDistance = -this._distance;
    offsetSide = Position.RIGHT;
  }
  var shell = p.getExteriorRing();
  var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
  if (this._distance < 0 && this.isErodedCompletely(shell, this._distance)) {
    return null;
  }
  if (this._distance <= 0 && shellCoord.length < 3) {
    return null;
  }
  this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
  for (var i = 0; i < p.getNumInteriorRing(); i++) {
    var hole = p.getInteriorRingN(i);
    var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
    if (this$1._distance > 0 && this$1.isErodedCompletely(hole, -this$1._distance)) {
      continue;
    }
    this$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
  }
};
OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely(triangleCoord, bufferDistance) {
  var tri = new Triangle2(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
  var inCentre3 = tri.inCentre();
  var distToCentre = CGAlgorithms.distancePointLine(inCentre3, tri.p0, tri.p1);
  return distToCentre < Math.abs(bufferDistance);
};
OffsetCurveSetBuilder.prototype.addLineString = function addLineString(line) {
  if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) {
    return null;
  }
  var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
  var curve = this._curveBuilder.getLineCurve(coord, this._distance);
  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
};
OffsetCurveSetBuilder.prototype.addCurve = function addCurve(coord, leftLoc, rightLoc) {
  if (coord === null || coord.length < 2) {
    return null;
  }
  var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
  this._curveList.add(e);
};
OffsetCurveSetBuilder.prototype.getCurves = function getCurves() {
  this.add(this._inputGeom);
  return this._curveList;
};
OffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
  if (offsetDistance === 0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) {
    return null;
  }
  var leftLoc = cwLeftLoc;
  var rightLoc = cwRightLoc;
  if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {
    leftLoc = cwRightLoc;
    rightLoc = cwLeftLoc;
    side = Position.opposite(side);
  }
  var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
  this.addCurve(curve, leftLoc, rightLoc);
};
OffsetCurveSetBuilder.prototype.add = function add10(g) {
  if (g.isEmpty()) {
    return null;
  }
  if (g instanceof Polygon) {
    this.addPolygon(g);
  } else if (g instanceof LineString2) {
    this.addLineString(g);
  } else if (g instanceof Point) {
    this.addPoint(g);
  } else if (g instanceof MultiPoint) {
    this.addCollection(g);
  } else if (g instanceof MultiLineString) {
    this.addCollection(g);
  } else if (g instanceof MultiPolygon) {
    this.addCollection(g);
  } else if (g instanceof GeometryCollection) {
    this.addCollection(g);
  }
};
OffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely(ring, bufferDistance) {
  var ringCoord = ring.getCoordinates();
  if (ringCoord.length < 4) {
    return bufferDistance < 0;
  }
  if (ringCoord.length === 4) {
    return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
  }
  var env = ring.getEnvelopeInternal();
  var envMinDimension = Math.min(env.getHeight(), env.getWidth());
  if (bufferDistance < 0 && 2 * Math.abs(bufferDistance) > envMinDimension) {
    return true;
  }
  return false;
};
OffsetCurveSetBuilder.prototype.addCollection = function addCollection(gc) {
  var this$1 = this;
  for (var i = 0; i < gc.getNumGeometries(); i++) {
    var g = gc.getGeometryN(i);
    this$1.add(g);
  }
};
OffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_92() {
  return [];
};
OffsetCurveSetBuilder.prototype.getClass = function getClass91() {
  return OffsetCurveSetBuilder;
};
var PointOnGeometryLocator = function PointOnGeometryLocator2() {
};
PointOnGeometryLocator.prototype.locate = function locate(p) {
};
PointOnGeometryLocator.prototype.interfaces_ = function interfaces_93() {
  return [];
};
PointOnGeometryLocator.prototype.getClass = function getClass92() {
  return PointOnGeometryLocator;
};
var GeometryCollectionIterator = function GeometryCollectionIterator2() {
  this._parent = null;
  this._atStart = null;
  this._max = null;
  this._index = null;
  this._subcollectionIterator = null;
  var parent = arguments[0];
  this._parent = parent;
  this._atStart = true;
  this._index = 0;
  this._max = parent.getNumGeometries();
};
GeometryCollectionIterator.prototype.next = function next2() {
  if (this._atStart) {
    this._atStart = false;
    if (GeometryCollectionIterator.isAtomic(this._parent)) {
      this._index++;
    }
    return this._parent;
  }
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext()) {
      return this._subcollectionIterator.next();
    } else {
      this._subcollectionIterator = null;
    }
  }
  if (this._index >= this._max) {
    throw new NoSuchElementException();
  }
  var obj = this._parent.getGeometryN(this._index++);
  if (obj instanceof GeometryCollection) {
    this._subcollectionIterator = new GeometryCollectionIterator(obj);
    return this._subcollectionIterator.next();
  }
  return obj;
};
GeometryCollectionIterator.prototype.remove = function remove5() {
  throw new Error(this.getClass().getName());
};
GeometryCollectionIterator.prototype.hasNext = function hasNext2() {
  if (this._atStart) {
    return true;
  }
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext()) {
      return true;
    }
    this._subcollectionIterator = null;
  }
  if (this._index >= this._max) {
    return false;
  }
  return true;
};
GeometryCollectionIterator.prototype.interfaces_ = function interfaces_94() {
  return [Iterator];
};
GeometryCollectionIterator.prototype.getClass = function getClass93() {
  return GeometryCollectionIterator;
};
GeometryCollectionIterator.isAtomic = function isAtomic(geom) {
  return !(geom instanceof GeometryCollection);
};
var SimplePointInAreaLocator = function SimplePointInAreaLocator2() {
  this._geom = null;
  var geom = arguments[0];
  this._geom = geom;
};
SimplePointInAreaLocator.prototype.locate = function locate2(p) {
  return SimplePointInAreaLocator.locate(p, this._geom);
};
SimplePointInAreaLocator.prototype.interfaces_ = function interfaces_95() {
  return [PointOnGeometryLocator];
};
SimplePointInAreaLocator.prototype.getClass = function getClass94() {
  return SimplePointInAreaLocator;
};
SimplePointInAreaLocator.isPointInRing = function isPointInRing2(p, ring) {
  if (!ring.getEnvelopeInternal().intersects(p)) {
    return false;
  }
  return CGAlgorithms.isPointInRing(p, ring.getCoordinates());
};
SimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon(p, poly) {
  if (poly.isEmpty()) {
    return false;
  }
  var shell = poly.getExteriorRing();
  if (!SimplePointInAreaLocator.isPointInRing(p, shell)) {
    return false;
  }
  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
    var hole = poly.getInteriorRingN(i);
    if (SimplePointInAreaLocator.isPointInRing(p, hole)) {
      return false;
    }
  }
  return true;
};
SimplePointInAreaLocator.containsPoint = function containsPoint3(p, geom) {
  if (geom instanceof Polygon) {
    return SimplePointInAreaLocator.containsPointInPolygon(p, geom);
  } else if (geom instanceof GeometryCollection) {
    var geomi = new GeometryCollectionIterator(geom);
    while (geomi.hasNext()) {
      var g2 = geomi.next();
      if (g2 !== geom) {
        if (SimplePointInAreaLocator.containsPoint(p, g2)) {
          return true;
        }
      }
    }
  }
  return false;
};
SimplePointInAreaLocator.locate = function locate3(p, geom) {
  if (geom.isEmpty()) {
    return Location.EXTERIOR;
  }
  if (SimplePointInAreaLocator.containsPoint(p, geom)) {
    return Location.INTERIOR;
  }
  return Location.EXTERIOR;
};
var EdgeEndStar = function EdgeEndStar2() {
  this._edgeMap = new TreeMap();
  this._edgeList = null;
  this._ptInAreaLocation = [Location.NONE, Location.NONE];
};
EdgeEndStar.prototype.getNextCW = function getNextCW(ee) {
  this.getEdges();
  var i = this._edgeList.indexOf(ee);
  var iNextCW = i - 1;
  if (i === 0) {
    iNextCW = this._edgeList.size() - 1;
  }
  return this._edgeList.get(iNextCW);
};
EdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels(geomIndex) {
  var startLoc = Location.NONE;
  for (var it = this.iterator(); it.hasNext(); ) {
    var e = it.next();
    var label = e.getLabel();
    if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) {
      startLoc = label.getLocation(geomIndex, Position.LEFT);
    }
  }
  if (startLoc === Location.NONE) {
    return null;
  }
  var currLoc = startLoc;
  for (var it$1 = this.iterator(); it$1.hasNext(); ) {
    var e$1 = it$1.next();
    var label$1 = e$1.getLabel();
    if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) {
      label$1.setLocation(geomIndex, Position.ON, currLoc);
    }
    if (label$1.isArea(geomIndex)) {
      var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);
      var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);
      if (rightLoc !== Location.NONE) {
        if (rightLoc !== currLoc) {
          throw new TopologyException("side location conflict", e$1.getCoordinate());
        }
        if (leftLoc === Location.NONE) {
          Assert.shouldNeverReachHere("found single null side (at " + e$1.getCoordinate() + ")");
        }
        currLoc = leftLoc;
      } else {
        Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, "found single null side");
        label$1.setLocation(geomIndex, Position.RIGHT, currLoc);
        label$1.setLocation(geomIndex, Position.LEFT, currLoc);
      }
    }
  }
};
EdgeEndStar.prototype.getCoordinate = function getCoordinate11() {
  var it = this.iterator();
  if (!it.hasNext()) {
    return null;
  }
  var e = it.next();
  return e.getCoordinate();
};
EdgeEndStar.prototype.print = function print5(out) {
  System.out.println("EdgeEndStar:   " + this.getCoordinate());
  for (var it = this.iterator(); it.hasNext(); ) {
    var e = it.next();
    e.print(out);
  }
};
EdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent(geomGraph) {
  this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
  return this.checkAreaLabelsConsistent(0);
};
EdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent(geomIndex) {
  var edges2 = this.getEdges();
  if (edges2.size() <= 0) {
    return true;
  }
  var lastEdgeIndex = edges2.size() - 1;
  var startLabel = edges2.get(lastEdgeIndex).getLabel();
  var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
  Assert.isTrue(startLoc !== Location.NONE, "Found unlabelled area edge");
  var currLoc = startLoc;
  for (var it = this.iterator(); it.hasNext(); ) {
    var e = it.next();
    var label = e.getLabel();
    Assert.isTrue(label.isArea(geomIndex), "Found non-area edge");
    var leftLoc = label.getLocation(geomIndex, Position.LEFT);
    var rightLoc = label.getLocation(geomIndex, Position.RIGHT);
    if (leftLoc === rightLoc) {
      return false;
    }
    if (rightLoc !== currLoc) {
      return false;
    }
    currLoc = leftLoc;
  }
  return true;
};
EdgeEndStar.prototype.findIndex = function findIndex(eSearch) {
  var this$1 = this;
  this.iterator();
  for (var i = 0; i < this._edgeList.size(); i++) {
    var e = this$1._edgeList.get(i);
    if (e === eSearch) {
      return i;
    }
  }
  return -1;
};
EdgeEndStar.prototype.iterator = function iterator4() {
  return this.getEdges().iterator();
};
EdgeEndStar.prototype.getEdges = function getEdges2() {
  if (this._edgeList === null) {
    this._edgeList = new ArrayList(this._edgeMap.values());
  }
  return this._edgeList;
};
EdgeEndStar.prototype.getLocation = function getLocation3(geomIndex, p, geom) {
  if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
    this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
  }
  return this._ptInAreaLocation[geomIndex];
};
EdgeEndStar.prototype.toString = function toString18() {
  var buf = new StringBuffer();
  buf.append("EdgeEndStar:   " + this.getCoordinate());
  buf.append("\n");
  for (var it = this.iterator(); it.hasNext(); ) {
    var e = it.next();
    buf.append(e);
    buf.append("\n");
  }
  return buf.toString();
};
EdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels(boundaryNodeRule) {
  for (var it = this.iterator(); it.hasNext(); ) {
    var ee = it.next();
    ee.computeLabel(boundaryNodeRule);
  }
};
EdgeEndStar.prototype.computeLabelling = function computeLabelling(geomGraph) {
  var this$1 = this;
  this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
  this.propagateSideLabels(0);
  this.propagateSideLabels(1);
  var hasDimensionalCollapseEdge = [false, false];
  for (var it = this.iterator(); it.hasNext(); ) {
    var e = it.next();
    var label = e.getLabel();
    for (var geomi = 0; geomi < 2; geomi++) {
      if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) {
        hasDimensionalCollapseEdge[geomi] = true;
      }
    }
  }
  for (var it$1 = this.iterator(); it$1.hasNext(); ) {
    var e$1 = it$1.next();
    var label$1 = e$1.getLabel();
    for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {
      if (label$1.isAnyNull(geomi$1)) {
        var loc = Location.NONE;
        if (hasDimensionalCollapseEdge[geomi$1]) {
          loc = Location.EXTERIOR;
        } else {
          var p = e$1.getCoordinate();
          loc = this$1.getLocation(geomi$1, p, geomGraph);
        }
        label$1.setAllLocationsIfNull(geomi$1, loc);
      }
    }
  }
};
EdgeEndStar.prototype.getDegree = function getDegree() {
  return this._edgeMap.size();
};
EdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd(e, obj) {
  this._edgeMap.put(e, obj);
  this._edgeList = null;
};
EdgeEndStar.prototype.interfaces_ = function interfaces_96() {
  return [];
};
EdgeEndStar.prototype.getClass = function getClass95() {
  return EdgeEndStar;
};
var DirectedEdgeStar = function(EdgeEndStar$$1) {
  function DirectedEdgeStar2() {
    EdgeEndStar$$1.call(this);
    this._resultAreaEdgeList = null;
    this._label = null;
    this._SCANNING_FOR_INCOMING = 1;
    this._LINKING_TO_OUTGOING = 2;
  }
  if (EdgeEndStar$$1)
    DirectedEdgeStar2.__proto__ = EdgeEndStar$$1;
  DirectedEdgeStar2.prototype = Object.create(EdgeEndStar$$1 && EdgeEndStar$$1.prototype);
  DirectedEdgeStar2.prototype.constructor = DirectedEdgeStar2;
  DirectedEdgeStar2.prototype.linkResultDirectedEdges = function linkResultDirectedEdges3() {
    var this$1 = this;
    this.getResultAreaEdges();
    var firstOut = null;
    var incoming = null;
    var state = this._SCANNING_FOR_INCOMING;
    for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
      var nextOut = this$1._resultAreaEdgeList.get(i);
      var nextIn = nextOut.getSym();
      if (!nextOut.getLabel().isArea()) {
        continue;
      }
      if (firstOut === null && nextOut.isInResult()) {
        firstOut = nextOut;
      }
      switch (state) {
        case this$1._SCANNING_FOR_INCOMING:
          if (!nextIn.isInResult()) {
            continue;
          }
          incoming = nextIn;
          state = this$1._LINKING_TO_OUTGOING;
          break;
        case this$1._LINKING_TO_OUTGOING:
          if (!nextOut.isInResult()) {
            continue;
          }
          incoming.setNext(nextOut);
          state = this$1._SCANNING_FOR_INCOMING;
          break;
        default:
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      if (firstOut === null) {
        throw new TopologyException("no outgoing dirEdge found", this.getCoordinate());
      }
      Assert.isTrue(firstOut.isInResult(), "unable to link last incoming dirEdge");
      incoming.setNext(firstOut);
    }
  };
  DirectedEdgeStar2.prototype.insert = function insert5(ee) {
    var de = ee;
    this.insertEdgeEnd(de, de);
  };
  DirectedEdgeStar2.prototype.getRightmostEdge = function getRightmostEdge() {
    var edges2 = this.getEdges();
    var size11 = edges2.size();
    if (size11 < 1) {
      return null;
    }
    var de0 = edges2.get(0);
    if (size11 === 1) {
      return de0;
    }
    var deLast = edges2.get(size11 - 1);
    var quad0 = de0.getQuadrant();
    var quad1 = deLast.getQuadrant();
    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) {
      return de0;
    } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) {
      return deLast;
    } else {
      if (de0.getDy() !== 0) {
        return de0;
      } else if (deLast.getDy() !== 0) {
        return deLast;
      }
    }
    Assert.shouldNeverReachHere("found two horizontal edges incident on node");
    return null;
  };
  DirectedEdgeStar2.prototype.print = function print9(out) {
    System.out.println("DirectedEdgeStar: " + this.getCoordinate());
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      out.print("out ");
      de.print(out);
      out.println();
      out.print("in ");
      de.getSym().print(out);
      out.println();
    }
  };
  DirectedEdgeStar2.prototype.getResultAreaEdges = function getResultAreaEdges() {
    var this$1 = this;
    if (this._resultAreaEdgeList !== null) {
      return this._resultAreaEdgeList;
    }
    this._resultAreaEdgeList = new ArrayList();
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      if (de.isInResult() || de.getSym().isInResult()) {
        this$1._resultAreaEdgeList.add(de);
      }
    }
    return this._resultAreaEdgeList;
  };
  DirectedEdgeStar2.prototype.updateLabelling = function updateLabelling(nodeLabel) {
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      var label = de.getLabel();
      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
    }
  };
  DirectedEdgeStar2.prototype.linkAllDirectedEdges = function linkAllDirectedEdges2() {
    var this$1 = this;
    this.getEdges();
    var prevOut = null;
    var firstIn = null;
    for (var i = this._edgeList.size() - 1; i >= 0; i--) {
      var nextOut = this$1._edgeList.get(i);
      var nextIn = nextOut.getSym();
      if (firstIn === null) {
        firstIn = nextIn;
      }
      if (prevOut !== null) {
        nextIn.setNext(prevOut);
      }
      prevOut = nextOut;
    }
    firstIn.setNext(prevOut);
  };
  DirectedEdgeStar2.prototype.computeDepths = function computeDepths2() {
    var this$1 = this;
    if (arguments.length === 1) {
      var de = arguments[0];
      var edgeIndex = this.findIndex(de);
      var startDepth = de.getDepth(Position.LEFT);
      var targetLastDepth = de.getDepth(Position.RIGHT);
      var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
      var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
      if (lastDepth !== targetLastDepth) {
        throw new TopologyException("depth mismatch at " + de.getCoordinate());
      }
    } else if (arguments.length === 3) {
      var startIndex = arguments[0];
      var endIndex = arguments[1];
      var startDepth$1 = arguments[2];
      var currDepth = startDepth$1;
      for (var i = startIndex; i < endIndex; i++) {
        var nextDe = this$1._edgeList.get(i);
        nextDe.setEdgeDepths(Position.RIGHT, currDepth);
        currDepth = nextDe.getDepth(Position.LEFT);
      }
      return currDepth;
    }
  };
  DirectedEdgeStar2.prototype.mergeSymLabels = function mergeSymLabels() {
    for (var it = this.iterator(); it.hasNext(); ) {
      var de = it.next();
      var label = de.getLabel();
      label.merge(de.getSym().getLabel());
    }
  };
  DirectedEdgeStar2.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges(er) {
    var this$1 = this;
    var firstOut = null;
    var incoming = null;
    var state = this._SCANNING_FOR_INCOMING;
    for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
      var nextOut = this$1._resultAreaEdgeList.get(i);
      var nextIn = nextOut.getSym();
      if (firstOut === null && nextOut.getEdgeRing() === er) {
        firstOut = nextOut;
      }
      switch (state) {
        case this$1._SCANNING_FOR_INCOMING:
          if (nextIn.getEdgeRing() !== er) {
            continue;
          }
          incoming = nextIn;
          state = this$1._LINKING_TO_OUTGOING;
          break;
        case this$1._LINKING_TO_OUTGOING:
          if (nextOut.getEdgeRing() !== er) {
            continue;
          }
          incoming.setNextMin(nextOut);
          state = this$1._SCANNING_FOR_INCOMING;
          break;
        default:
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      Assert.isTrue(firstOut !== null, "found null for first outgoing dirEdge");
      Assert.isTrue(firstOut.getEdgeRing() === er, "unable to link last incoming dirEdge");
      incoming.setNextMin(firstOut);
    }
  };
  DirectedEdgeStar2.prototype.getOutgoingDegree = function getOutgoingDegree() {
    if (arguments.length === 0) {
      var degree = 0;
      for (var it = this.iterator(); it.hasNext(); ) {
        var de = it.next();
        if (de.isInResult()) {
          degree++;
        }
      }
      return degree;
    } else if (arguments.length === 1) {
      var er = arguments[0];
      var degree$1 = 0;
      for (var it$1 = this.iterator(); it$1.hasNext(); ) {
        var de$1 = it$1.next();
        if (de$1.getEdgeRing() === er) {
          degree$1++;
        }
      }
      return degree$1;
    }
  };
  DirectedEdgeStar2.prototype.getLabel = function getLabel4() {
    return this._label;
  };
  DirectedEdgeStar2.prototype.findCoveredLineEdges = function findCoveredLineEdges2() {
    var startLoc = Location.NONE;
    for (var it = this.iterator(); it.hasNext(); ) {
      var nextOut = it.next();
      var nextIn = nextOut.getSym();
      if (!nextOut.isLineEdge()) {
        if (nextOut.isInResult()) {
          startLoc = Location.INTERIOR;
          break;
        }
        if (nextIn.isInResult()) {
          startLoc = Location.EXTERIOR;
          break;
        }
      }
    }
    if (startLoc === Location.NONE) {
      return null;
    }
    var currLoc = startLoc;
    for (var it$1 = this.iterator(); it$1.hasNext(); ) {
      var nextOut$1 = it$1.next();
      var nextIn$1 = nextOut$1.getSym();
      if (nextOut$1.isLineEdge()) {
        nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);
      } else {
        if (nextOut$1.isInResult()) {
          currLoc = Location.EXTERIOR;
        }
        if (nextIn$1.isInResult()) {
          currLoc = Location.INTERIOR;
        }
      }
    }
  };
  DirectedEdgeStar2.prototype.computeLabelling = function computeLabelling2(geom) {
    var this$1 = this;
    EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);
    this._label = new Label(Location.NONE);
    for (var it = this.iterator(); it.hasNext(); ) {
      var ee = it.next();
      var e = ee.getEdge();
      var eLabel = e.getLabel();
      for (var i = 0; i < 2; i++) {
        var eLoc = eLabel.getLocation(i);
        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) {
          this$1._label.setLocation(i, Location.INTERIOR);
        }
      }
    }
  };
  DirectedEdgeStar2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  DirectedEdgeStar2.prototype.getClass = function getClass169() {
    return DirectedEdgeStar2;
  };
  return DirectedEdgeStar2;
}(EdgeEndStar);
var OverlayNodeFactory = function(NodeFactory$$1) {
  function OverlayNodeFactory2() {
    NodeFactory$$1.apply(this, arguments);
  }
  if (NodeFactory$$1)
    OverlayNodeFactory2.__proto__ = NodeFactory$$1;
  OverlayNodeFactory2.prototype = Object.create(NodeFactory$$1 && NodeFactory$$1.prototype);
  OverlayNodeFactory2.prototype.constructor = OverlayNodeFactory2;
  OverlayNodeFactory2.prototype.createNode = function createNode2(coord) {
    return new Node5(coord, new DirectedEdgeStar());
  };
  OverlayNodeFactory2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  OverlayNodeFactory2.prototype.getClass = function getClass169() {
    return OverlayNodeFactory2;
  };
  return OverlayNodeFactory2;
}(NodeFactory);
var OrientedCoordinateArray = function OrientedCoordinateArray2() {
  this._pts = null;
  this._orientation = null;
  var pts = arguments[0];
  this._pts = pts;
  this._orientation = OrientedCoordinateArray2.orientation(pts);
};
OrientedCoordinateArray.prototype.compareTo = function compareTo13(o1) {
  var oca = o1;
  var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
  return comp;
};
OrientedCoordinateArray.prototype.interfaces_ = function interfaces_97() {
  return [Comparable];
};
OrientedCoordinateArray.prototype.getClass = function getClass96() {
  return OrientedCoordinateArray;
};
OrientedCoordinateArray.orientation = function orientation(pts) {
  return CoordinateArrays.increasingDirection(pts) === 1;
};
OrientedCoordinateArray.compareOriented = function compareOriented(pts1, orientation1, pts2, orientation2) {
  var dir1 = orientation1 ? 1 : -1;
  var dir2 = orientation2 ? 1 : -1;
  var limit1 = orientation1 ? pts1.length : -1;
  var limit2 = orientation2 ? pts2.length : -1;
  var i1 = orientation1 ? 0 : pts1.length - 1;
  var i2 = orientation2 ? 0 : pts2.length - 1;
  while (true) {
    var compPt = pts1[i1].compareTo(pts2[i2]);
    if (compPt !== 0) {
      return compPt;
    }
    i1 += dir1;
    i2 += dir2;
    var done1 = i1 === limit1;
    var done2 = i2 === limit2;
    if (done1 && !done2) {
      return -1;
    }
    if (!done1 && done2) {
      return 1;
    }
    if (done1 && done2) {
      return 0;
    }
  }
};
var EdgeList = function EdgeList2() {
  this._edges = new ArrayList();
  this._ocaMap = new TreeMap();
};
EdgeList.prototype.print = function print6(out) {
  var this$1 = this;
  out.print("MULTILINESTRING ( ");
  for (var j = 0; j < this._edges.size(); j++) {
    var e = this$1._edges.get(j);
    if (j > 0) {
      out.print(",");
    }
    out.print("(");
    var pts = e.getCoordinates();
    for (var i = 0; i < pts.length; i++) {
      if (i > 0) {
        out.print(",");
      }
      out.print(pts[i].x + " " + pts[i].y);
    }
    out.println(")");
  }
  out.print(")  ");
};
EdgeList.prototype.addAll = function addAll2(edgeColl) {
  var this$1 = this;
  for (var i = edgeColl.iterator(); i.hasNext(); ) {
    this$1.add(i.next());
  }
};
EdgeList.prototype.findEdgeIndex = function findEdgeIndex(e) {
  var this$1 = this;
  for (var i = 0; i < this._edges.size(); i++) {
    if (this$1._edges.get(i).equals(e)) {
      return i;
    }
  }
  return -1;
};
EdgeList.prototype.iterator = function iterator5() {
  return this._edges.iterator();
};
EdgeList.prototype.getEdges = function getEdges3() {
  return this._edges;
};
EdgeList.prototype.get = function get3(i) {
  return this._edges.get(i);
};
EdgeList.prototype.findEqualEdge = function findEqualEdge(e) {
  var oca = new OrientedCoordinateArray(e.getCoordinates());
  var matchEdge = this._ocaMap.get(oca);
  return matchEdge;
};
EdgeList.prototype.add = function add11(e) {
  this._edges.add(e);
  var oca = new OrientedCoordinateArray(e.getCoordinates());
  this._ocaMap.put(oca, e);
};
EdgeList.prototype.interfaces_ = function interfaces_98() {
  return [];
};
EdgeList.prototype.getClass = function getClass97() {
  return EdgeList;
};
var SegmentIntersector = function SegmentIntersector2() {
};
SegmentIntersector.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {
};
SegmentIntersector.prototype.isDone = function isDone2() {
};
SegmentIntersector.prototype.interfaces_ = function interfaces_99() {
  return [];
};
SegmentIntersector.prototype.getClass = function getClass98() {
  return SegmentIntersector;
};
var IntersectionAdder = function IntersectionAdder2() {
  this._hasIntersection = false;
  this._hasProper = false;
  this._hasProperInterior = false;
  this._hasInterior = false;
  this._properIntersectionPoint = null;
  this._li = null;
  this._isSelfIntersection = null;
  this.numIntersections = 0;
  this.numInteriorIntersections = 0;
  this.numProperIntersections = 0;
  this.numTests = 0;
  var li = arguments[0];
  this._li = li;
};
IntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1) {
    if (this._li.getIntersectionNum() === 1) {
      if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) {
        return true;
      }
      if (e0.isClosed()) {
        var maxSegIndex = e0.size() - 1;
        if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
          return true;
        }
      }
    }
  }
  return false;
};
IntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {
  return this._properIntersectionPoint;
};
IntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {
  return this._hasProperInterior;
};
IntersectionAdder.prototype.getLineIntersector = function getLineIntersector() {
  return this._li;
};
IntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection() {
  return this._hasProper;
};
IntersectionAdder.prototype.processIntersections = function processIntersections2(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  this.numTests++;
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    this.numIntersections++;
    if (this._li.isInteriorIntersection()) {
      this.numInteriorIntersections++;
      this._hasInterior = true;
    }
    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
      this._hasIntersection = true;
      e0.addIntersections(this._li, segIndex0, 0);
      e1.addIntersections(this._li, segIndex1, 1);
      if (this._li.isProper()) {
        this.numProperIntersections++;
        this._hasProper = true;
        this._hasProperInterior = true;
      }
    }
  }
};
IntersectionAdder.prototype.hasIntersection = function hasIntersection2() {
  return this._hasIntersection;
};
IntersectionAdder.prototype.isDone = function isDone3() {
  return false;
};
IntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection() {
  return this._hasInterior;
};
IntersectionAdder.prototype.interfaces_ = function interfaces_100() {
  return [SegmentIntersector];
};
IntersectionAdder.prototype.getClass = function getClass99() {
  return IntersectionAdder;
};
IntersectionAdder.isAdjacentSegments = function isAdjacentSegments(i1, i2) {
  return Math.abs(i1 - i2) === 1;
};
var EdgeIntersection = function EdgeIntersection2() {
  this.coord = null;
  this.segmentIndex = null;
  this.dist = null;
  var coord = arguments[0];
  var segmentIndex = arguments[1];
  var dist = arguments[2];
  this.coord = new Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this.dist = dist;
};
EdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex() {
  return this.segmentIndex;
};
EdgeIntersection.prototype.getCoordinate = function getCoordinate12() {
  return this.coord;
};
EdgeIntersection.prototype.print = function print7(out) {
  out.print(this.coord);
  out.print(" seg # = " + this.segmentIndex);
  out.println(" dist = " + this.dist);
};
EdgeIntersection.prototype.compareTo = function compareTo14(obj) {
  var other = obj;
  return this.compare(other.segmentIndex, other.dist);
};
EdgeIntersection.prototype.isEndPoint = function isEndPoint3(maxSegmentIndex) {
  if (this.segmentIndex === 0 && this.dist === 0) {
    return true;
  }
  if (this.segmentIndex === maxSegmentIndex) {
    return true;
  }
  return false;
};
EdgeIntersection.prototype.toString = function toString19() {
  return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
};
EdgeIntersection.prototype.getDistance = function getDistance2() {
  return this.dist;
};
EdgeIntersection.prototype.compare = function compare8(segmentIndex, dist) {
  if (this.segmentIndex < segmentIndex) {
    return -1;
  }
  if (this.segmentIndex > segmentIndex) {
    return 1;
  }
  if (this.dist < dist) {
    return -1;
  }
  if (this.dist > dist) {
    return 1;
  }
  return 0;
};
EdgeIntersection.prototype.interfaces_ = function interfaces_101() {
  return [Comparable];
};
EdgeIntersection.prototype.getClass = function getClass100() {
  return EdgeIntersection;
};
var EdgeIntersectionList = function EdgeIntersectionList2() {
  this._nodeMap = new TreeMap();
  this.edge = null;
  var edge = arguments[0];
  this.edge = edge;
};
EdgeIntersectionList.prototype.print = function print8(out) {
  out.println("Intersections:");
  for (var it = this.iterator(); it.hasNext(); ) {
    var ei = it.next();
    ei.print(out);
  }
};
EdgeIntersectionList.prototype.iterator = function iterator6() {
  return this._nodeMap.values().iterator();
};
EdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges2(edgeList) {
  var this$1 = this;
  this.addEndpoints();
  var it = this.iterator();
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var newEdge = this$1.createSplitEdge(eiPrev, ei);
    edgeList.add(newEdge);
    eiPrev = ei;
  }
};
EdgeIntersectionList.prototype.addEndpoints = function addEndpoints2() {
  var maxSegIndex = this.edge.pts.length - 1;
  this.add(this.edge.pts[0], 0, 0);
  this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0);
};
EdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge2(ei0, ei1) {
  var this$1 = this;
  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
  var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
  var useIntPt1 = ei1.dist > 0 || !ei1.coord.equals2D(lastSegStartPt);
  if (!useIntPt1) {
    npts--;
  }
  var pts = new Array(npts).fill(null);
  var ipt = 0;
  pts[ipt++] = new Coordinate(ei0.coord);
  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
    pts[ipt++] = this$1.edge.pts[i];
  }
  if (useIntPt1) {
    pts[ipt] = ei1.coord;
  }
  return new Edge2(pts, new Label(this.edge._label));
};
EdgeIntersectionList.prototype.add = function add12(intPt, segmentIndex, dist) {
  var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
  var ei = this._nodeMap.get(eiNew);
  if (ei !== null) {
    return ei;
  }
  this._nodeMap.put(eiNew, eiNew);
  return eiNew;
};
EdgeIntersectionList.prototype.isIntersection = function isIntersection2(pt) {
  for (var it = this.iterator(); it.hasNext(); ) {
    var ei = it.next();
    if (ei.coord.equals(pt)) {
      return true;
    }
  }
  return false;
};
EdgeIntersectionList.prototype.interfaces_ = function interfaces_102() {
  return [];
};
EdgeIntersectionList.prototype.getClass = function getClass101() {
  return EdgeIntersectionList;
};
var MonotoneChainIndexer = function MonotoneChainIndexer2() {
};
MonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices2(pts) {
  var this$1 = this;
  var start = 0;
  var startIndexList = new ArrayList();
  startIndexList.add(new Integer(start));
  do {
    var last = this$1.findChainEnd(pts, start);
    startIndexList.add(new Integer(last));
    start = last;
  } while (start < pts.length - 1);
  var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
  return startIndex;
};
MonotoneChainIndexer.prototype.findChainEnd = function findChainEnd2(pts, start) {
  var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
  var last = start + 1;
  while (last < pts.length) {
    var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
    if (quad !== chainQuad) {
      break;
    }
    last++;
  }
  return last - 1;
};
MonotoneChainIndexer.prototype.interfaces_ = function interfaces_103() {
  return [];
};
MonotoneChainIndexer.prototype.getClass = function getClass102() {
  return MonotoneChainIndexer;
};
MonotoneChainIndexer.toIntArray = function toIntArray2(list) {
  var array = new Array(list.size()).fill(null);
  for (var i = 0; i < array.length; i++) {
    array[i] = list.get(i).intValue();
  }
  return array;
};
var MonotoneChainEdge = function MonotoneChainEdge2() {
  this.e = null;
  this.pts = null;
  this.startIndex = null;
  this.env1 = new Envelope();
  this.env2 = new Envelope();
  var e = arguments[0];
  this.e = e;
  this.pts = e.getCoordinates();
  var mcb = new MonotoneChainIndexer();
  this.startIndex = mcb.getChainStartIndices(this.pts);
};
MonotoneChainEdge.prototype.getCoordinates = function getCoordinates6() {
  return this.pts;
};
MonotoneChainEdge.prototype.getMaxX = function getMaxX2(chainIndex) {
  var x1 = this.pts[this.startIndex[chainIndex]].x;
  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
  return x1 > x2 ? x1 : x2;
};
MonotoneChainEdge.prototype.getMinX = function getMinX2(chainIndex) {
  var x1 = this.pts[this.startIndex[chainIndex]].x;
  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
  return x1 < x2 ? x1 : x2;
};
MonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain() {
  if (arguments.length === 4) {
    var chainIndex0 = arguments[0];
    var mce = arguments[1];
    var chainIndex1 = arguments[2];
    var si = arguments[3];
    this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
  } else if (arguments.length === 6) {
    var start0 = arguments[0];
    var end0 = arguments[1];
    var mce$1 = arguments[2];
    var start1 = arguments[3];
    var end1 = arguments[4];
    var ei = arguments[5];
    var p002 = this.pts[start0];
    var p012 = this.pts[end0];
    var p102 = mce$1.pts[start1];
    var p112 = mce$1.pts[end1];
    if (end0 - start0 === 1 && end1 - start1 === 1) {
      ei.addIntersections(this.e, start0, mce$1.e, start1);
      return null;
    }
    this.env1.init(p002, p012);
    this.env2.init(p102, p112);
    if (!this.env1.intersects(this.env2)) {
      return null;
    }
    var mid0 = Math.trunc((start0 + end0) / 2);
    var mid1 = Math.trunc((start1 + end1) / 2);
    if (start0 < mid0) {
      if (start1 < mid1) {
        this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei);
      }
      if (mid1 < end1) {
        this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei);
      }
    }
    if (mid0 < end0) {
      if (start1 < mid1) {
        this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei);
      }
      if (mid1 < end1) {
        this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei);
      }
    }
  }
};
MonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes() {
  return this.startIndex;
};
MonotoneChainEdge.prototype.computeIntersects = function computeIntersects(mce, si) {
  var this$1 = this;
  for (var i = 0; i < this.startIndex.length - 1; i++) {
    for (var j = 0; j < mce.startIndex.length - 1; j++) {
      this$1.computeIntersectsForChain(i, mce, j, si);
    }
  }
};
MonotoneChainEdge.prototype.interfaces_ = function interfaces_104() {
  return [];
};
MonotoneChainEdge.prototype.getClass = function getClass103() {
  return MonotoneChainEdge;
};
var Depth = function Depth2() {
  var this$1 = this;
  this._depth = Array(2).fill().map(function() {
    return Array(3);
  });
  for (var i = 0; i < 2; i++) {
    for (var j = 0; j < 3; j++) {
      this$1._depth[i][j] = Depth2.NULL_VALUE;
    }
  }
};
var staticAccessors$31 = { NULL_VALUE: { configurable: true } };
Depth.prototype.getDepth = function getDepth2(geomIndex, posIndex) {
  return this._depth[geomIndex][posIndex];
};
Depth.prototype.setDepth = function setDepth(geomIndex, posIndex, depthValue) {
  this._depth[geomIndex][posIndex] = depthValue;
};
Depth.prototype.isNull = function isNull4() {
  var this$1 = this;
  if (arguments.length === 0) {
    for (var i = 0; i < 2; i++) {
      for (var j = 0; j < 3; j++) {
        if (this$1._depth[i][j] !== Depth.NULL_VALUE) {
          return false;
        }
      }
    }
    return true;
  } else if (arguments.length === 1) {
    var geomIndex = arguments[0];
    return this._depth[geomIndex][1] === Depth.NULL_VALUE;
  } else if (arguments.length === 2) {
    var geomIndex$1 = arguments[0];
    var posIndex = arguments[1];
    return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE;
  }
};
Depth.prototype.normalize = function normalize5() {
  var this$1 = this;
  for (var i = 0; i < 2; i++) {
    if (!this$1.isNull(i)) {
      var minDepth = this$1._depth[i][1];
      if (this$1._depth[i][2] < minDepth) {
        minDepth = this$1._depth[i][2];
      }
      if (minDepth < 0) {
        minDepth = 0;
      }
      for (var j = 1; j < 3; j++) {
        var newValue = 0;
        if (this$1._depth[i][j] > minDepth) {
          newValue = 1;
        }
        this$1._depth[i][j] = newValue;
      }
    }
  }
};
Depth.prototype.getDelta = function getDelta(geomIndex) {
  return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];
};
Depth.prototype.getLocation = function getLocation4(geomIndex, posIndex) {
  if (this._depth[geomIndex][posIndex] <= 0) {
    return Location.EXTERIOR;
  }
  return Location.INTERIOR;
};
Depth.prototype.toString = function toString20() {
  return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
};
Depth.prototype.add = function add13() {
  var this$1 = this;
  if (arguments.length === 1) {
    var lbl = arguments[0];
    for (var i = 0; i < 2; i++) {
      for (var j = 1; j < 3; j++) {
        var loc = lbl.getLocation(i, j);
        if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
          if (this$1.isNull(i, j)) {
            this$1._depth[i][j] = Depth.depthAtLocation(loc);
          } else {
            this$1._depth[i][j] += Depth.depthAtLocation(loc);
          }
        }
      }
    }
  } else if (arguments.length === 3) {
    var geomIndex = arguments[0];
    var posIndex = arguments[1];
    var location = arguments[2];
    if (location === Location.INTERIOR) {
      this._depth[geomIndex][posIndex]++;
    }
  }
};
Depth.prototype.interfaces_ = function interfaces_105() {
  return [];
};
Depth.prototype.getClass = function getClass104() {
  return Depth;
};
Depth.depthAtLocation = function depthAtLocation(location) {
  if (location === Location.EXTERIOR) {
    return 0;
  }
  if (location === Location.INTERIOR) {
    return 1;
  }
  return Depth.NULL_VALUE;
};
staticAccessors$31.NULL_VALUE.get = function() {
  return -1;
};
Object.defineProperties(Depth, staticAccessors$31);
var Edge2 = function(GraphComponent$$1) {
  function Edge3() {
    GraphComponent$$1.call(this);
    this.pts = null;
    this._env = null;
    this.eiList = new EdgeIntersectionList(this);
    this._name = null;
    this._mce = null;
    this._isIsolated = true;
    this._depth = new Depth();
    this._depthDelta = 0;
    if (arguments.length === 1) {
      var pts = arguments[0];
      Edge3.call(this, pts, null);
    } else if (arguments.length === 2) {
      var pts$1 = arguments[0];
      var label = arguments[1];
      this.pts = pts$1;
      this._label = label;
    }
  }
  if (GraphComponent$$1)
    Edge3.__proto__ = GraphComponent$$1;
  Edge3.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);
  Edge3.prototype.constructor = Edge3;
  Edge3.prototype.getDepth = function getDepth3() {
    return this._depth;
  };
  Edge3.prototype.getCollapsedEdge = function getCollapsedEdge() {
    var newPts = new Array(2).fill(null);
    newPts[0] = this.pts[0];
    newPts[1] = this.pts[1];
    var newe = new Edge3(newPts, Label.toLineLabel(this._label));
    return newe;
  };
  Edge3.prototype.isIsolated = function isIsolated2() {
    return this._isIsolated;
  };
  Edge3.prototype.getCoordinates = function getCoordinates11() {
    return this.pts;
  };
  Edge3.prototype.setIsolated = function setIsolated(isIsolated2) {
    this._isIsolated = isIsolated2;
  };
  Edge3.prototype.setName = function setName(name) {
    this._name = name;
  };
  Edge3.prototype.equals = function equals10(o) {
    var this$1 = this;
    if (!(o instanceof Edge3)) {
      return false;
    }
    var e = o;
    if (this.pts.length !== e.pts.length) {
      return false;
    }
    var isEqualForward = true;
    var isEqualReverse = true;
    var iRev = this.pts.length;
    for (var i = 0; i < this.pts.length; i++) {
      if (!this$1.pts[i].equals2D(e.pts[i])) {
        isEqualForward = false;
      }
      if (!this$1.pts[i].equals2D(e.pts[--iRev])) {
        isEqualReverse = false;
      }
      if (!isEqualForward && !isEqualReverse) {
        return false;
      }
    }
    return true;
  };
  Edge3.prototype.getCoordinate = function getCoordinate18() {
    if (arguments.length === 0) {
      if (this.pts.length > 0) {
        return this.pts[0];
      }
      return null;
    } else if (arguments.length === 1) {
      var i = arguments[0];
      return this.pts[i];
    }
  };
  Edge3.prototype.print = function print9(out) {
    var this$1 = this;
    out.print("edge " + this._name + ": ");
    out.print("LINESTRING (");
    for (var i = 0; i < this.pts.length; i++) {
      if (i > 0) {
        out.print(",");
      }
      out.print(this$1.pts[i].x + " " + this$1.pts[i].y);
    }
    out.print(")  " + this._label + " " + this._depthDelta);
  };
  Edge3.prototype.computeIM = function computeIM(im) {
    Edge3.updateIM(this._label, im);
  };
  Edge3.prototype.isCollapsed = function isCollapsed() {
    if (!this._label.isArea()) {
      return false;
    }
    if (this.pts.length !== 3) {
      return false;
    }
    if (this.pts[0].equals(this.pts[2])) {
      return true;
    }
    return false;
  };
  Edge3.prototype.isClosed = function isClosed5() {
    return this.pts[0].equals(this.pts[this.pts.length - 1]);
  };
  Edge3.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex() {
    return this.pts.length - 1;
  };
  Edge3.prototype.getDepthDelta = function getDepthDelta() {
    return this._depthDelta;
  };
  Edge3.prototype.getNumPoints = function getNumPoints() {
    return this.pts.length;
  };
  Edge3.prototype.printReverse = function printReverse(out) {
    var this$1 = this;
    out.print("edge " + this._name + ": ");
    for (var i = this.pts.length - 1; i >= 0; i--) {
      out.print(this$1.pts[i] + " ");
    }
    out.println("");
  };
  Edge3.prototype.getMonotoneChainEdge = function getMonotoneChainEdge() {
    if (this._mce === null) {
      this._mce = new MonotoneChainEdge(this);
    }
    return this._mce;
  };
  Edge3.prototype.getEnvelope = function getEnvelope4() {
    var this$1 = this;
    if (this._env === null) {
      this._env = new Envelope();
      for (var i = 0; i < this.pts.length; i++) {
        this$1._env.expandToInclude(this$1.pts[i]);
      }
    }
    return this._env;
  };
  Edge3.prototype.addIntersection = function addIntersection3(li, segmentIndex, geomIndex, intIndex) {
    var intPt = new Coordinate(li.getIntersection(intIndex));
    var normalizedSegmentIndex = segmentIndex;
    var dist = li.getEdgeDistance(geomIndex, intIndex);
    var nextSegIndex = normalizedSegmentIndex + 1;
    if (nextSegIndex < this.pts.length) {
      var nextPt = this.pts[nextSegIndex];
      if (intPt.equals2D(nextPt)) {
        normalizedSegmentIndex = nextSegIndex;
        dist = 0;
      }
    }
    this.eiList.add(intPt, normalizedSegmentIndex, dist);
  };
  Edge3.prototype.toString = function toString25() {
    var this$1 = this;
    var buf = new StringBuffer();
    buf.append("edge " + this._name + ": ");
    buf.append("LINESTRING (");
    for (var i = 0; i < this.pts.length; i++) {
      if (i > 0) {
        buf.append(",");
      }
      buf.append(this$1.pts[i].x + " " + this$1.pts[i].y);
    }
    buf.append(")  " + this._label + " " + this._depthDelta);
    return buf.toString();
  };
  Edge3.prototype.isPointwiseEqual = function isPointwiseEqual(e) {
    var this$1 = this;
    if (this.pts.length !== e.pts.length) {
      return false;
    }
    for (var i = 0; i < this.pts.length; i++) {
      if (!this$1.pts[i].equals2D(e.pts[i])) {
        return false;
      }
    }
    return true;
  };
  Edge3.prototype.setDepthDelta = function setDepthDelta(depthDelta2) {
    this._depthDelta = depthDelta2;
  };
  Edge3.prototype.getEdgeIntersectionList = function getEdgeIntersectionList() {
    return this.eiList;
  };
  Edge3.prototype.addIntersections = function addIntersections3(li, segmentIndex, geomIndex) {
    var this$1 = this;
    for (var i = 0; i < li.getIntersectionNum(); i++) {
      this$1.addIntersection(li, segmentIndex, geomIndex, i);
    }
  };
  Edge3.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  Edge3.prototype.getClass = function getClass169() {
    return Edge3;
  };
  Edge3.updateIM = function updateIM2() {
    if (arguments.length === 2) {
      var label = arguments[0];
      var im = arguments[1];
      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
      if (label.isArea()) {
        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
      }
    } else {
      return GraphComponent$$1.prototype.updateIM.apply(this, arguments);
    }
  };
  return Edge3;
}(GraphComponent);
var BufferBuilder = function BufferBuilder2(bufParams) {
  this._workingPrecisionModel = null;
  this._workingNoder = null;
  this._geomFact = null;
  this._graph = null;
  this._edgeList = new EdgeList();
  this._bufParams = bufParams || null;
};
BufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel(pm) {
  this._workingPrecisionModel = pm;
};
BufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge(e) {
  var existingEdge = this._edgeList.findEqualEdge(e);
  if (existingEdge !== null) {
    var existingLabel = existingEdge.getLabel();
    var labelToMerge = e.getLabel();
    if (!existingEdge.isPointwiseEqual(e)) {
      labelToMerge = new Label(e.getLabel());
      labelToMerge.flip();
    }
    existingLabel.merge(labelToMerge);
    var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
    var existingDelta = existingEdge.getDepthDelta();
    var newDelta = existingDelta + mergeDelta;
    existingEdge.setDepthDelta(newDelta);
  } else {
    this._edgeList.add(e);
    e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
  }
};
BufferBuilder.prototype.buildSubgraphs = function buildSubgraphs(subgraphList, polyBuilder) {
  var processedGraphs = new ArrayList();
  for (var i = subgraphList.iterator(); i.hasNext(); ) {
    var subgraph = i.next();
    var p = subgraph.getRightmostCoordinate();
    var locater = new SubgraphDepthLocater(processedGraphs);
    var outsideDepth = locater.getDepth(p);
    subgraph.computeDepth(outsideDepth);
    subgraph.findResultEdges();
    processedGraphs.add(subgraph);
    polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
  }
};
BufferBuilder.prototype.createSubgraphs = function createSubgraphs(graph) {
  var subgraphList = new ArrayList();
  for (var i = graph.getNodes().iterator(); i.hasNext(); ) {
    var node = i.next();
    if (!node.isVisited()) {
      var subgraph = new BufferSubgraph();
      subgraph.create(node);
      subgraphList.add(subgraph);
    }
  }
  Collections.sort(subgraphList, Collections.reverseOrder());
  return subgraphList;
};
BufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry() {
  var emptyGeom = this._geomFact.createPolygon();
  return emptyGeom;
};
BufferBuilder.prototype.getNoder = function getNoder(precisionModel) {
  if (this._workingNoder !== null) {
    return this._workingNoder;
  }
  var noder = new MCIndexNoder();
  var li = new RobustLineIntersector();
  li.setPrecisionModel(precisionModel);
  noder.setSegmentIntersector(new IntersectionAdder(li));
  return noder;
};
BufferBuilder.prototype.buffer = function buffer2(g, distance11) {
  var precisionModel = this._workingPrecisionModel;
  if (precisionModel === null) {
    precisionModel = g.getPrecisionModel();
  }
  this._geomFact = g.getFactory();
  var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
  var curveSetBuilder = new OffsetCurveSetBuilder(g, distance11, curveBuilder);
  var bufferSegStrList = curveSetBuilder.getCurves();
  if (bufferSegStrList.size() <= 0) {
    return this.createEmptyResultGeometry();
  }
  this.computeNodedEdges(bufferSegStrList, precisionModel);
  this._graph = new PlanarGraph(new OverlayNodeFactory());
  this._graph.addEdges(this._edgeList.getEdges());
  var subgraphList = this.createSubgraphs(this._graph);
  var polyBuilder = new PolygonBuilder(this._geomFact);
  this.buildSubgraphs(subgraphList, polyBuilder);
  var resultPolyList = polyBuilder.getPolygons();
  if (resultPolyList.size() <= 0) {
    return this.createEmptyResultGeometry();
  }
  var resultGeom = this._geomFact.buildGeometry(resultPolyList);
  return resultGeom;
};
BufferBuilder.prototype.computeNodedEdges = function computeNodedEdges(bufferSegStrList, precisionModel) {
  var this$1 = this;
  var noder = this.getNoder(precisionModel);
  noder.computeNodes(bufferSegStrList);
  var nodedSegStrings = noder.getNodedSubstrings();
  for (var i = nodedSegStrings.iterator(); i.hasNext(); ) {
    var segStr = i.next();
    var pts = segStr.getCoordinates();
    if (pts.length === 2 && pts[0].equals2D(pts[1])) {
      continue;
    }
    var oldLabel = segStr.getData();
    var edge = new Edge2(segStr.getCoordinates(), new Label(oldLabel));
    this$1.insertUniqueEdge(edge);
  }
};
BufferBuilder.prototype.setNoder = function setNoder(noder) {
  this._workingNoder = noder;
};
BufferBuilder.prototype.interfaces_ = function interfaces_106() {
  return [];
};
BufferBuilder.prototype.getClass = function getClass105() {
  return BufferBuilder;
};
BufferBuilder.depthDelta = function depthDelta(label) {
  var lLoc = label.getLocation(0, Position.LEFT);
  var rLoc = label.getLocation(0, Position.RIGHT);
  if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) {
    return 1;
  } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) {
    return -1;
  }
  return 0;
};
BufferBuilder.convertSegStrings = function convertSegStrings(it) {
  var fact = new GeometryFactory();
  var lines = new ArrayList();
  while (it.hasNext()) {
    var ss = it.next();
    var line = fact.createLineString(ss.getCoordinates());
    lines.add(line);
  }
  return fact.buildGeometry(lines);
};
var ScaledNoder = function ScaledNoder2() {
  this._noder = null;
  this._scaleFactor = null;
  this._offsetX = null;
  this._offsetY = null;
  this._isScaled = false;
  if (arguments.length === 2) {
    var noder = arguments[0];
    var scaleFactor = arguments[1];
    this._noder = noder;
    this._scaleFactor = scaleFactor;
    this._offsetX = 0;
    this._offsetY = 0;
    this._isScaled = !this.isIntegerPrecision();
  } else if (arguments.length === 4) {
    var noder$1 = arguments[0];
    var scaleFactor$1 = arguments[1];
    var offsetX = arguments[2];
    var offsetY = arguments[3];
    this._noder = noder$1;
    this._scaleFactor = scaleFactor$1;
    this._offsetX = offsetX;
    this._offsetY = offsetY;
    this._isScaled = !this.isIntegerPrecision();
  }
};
ScaledNoder.prototype.rescale = function rescale() {
  var this$1 = this;
  if (hasInterface(arguments[0], Collection)) {
    var segStrings = arguments[0];
    for (var i = segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      this$1.rescale(ss.getCoordinates());
    }
  } else if (arguments[0] instanceof Array) {
    var pts = arguments[0];
    for (var i$1 = 0; i$1 < pts.length; i$1++) {
      pts[i$1].x = pts[i$1].x / this$1._scaleFactor + this$1._offsetX;
      pts[i$1].y = pts[i$1].y / this$1._scaleFactor + this$1._offsetY;
    }
    if (pts.length === 2 && pts[0].equals2D(pts[1])) {
      System.out.println(pts);
    }
  }
};
ScaledNoder.prototype.scale = function scale2() {
  var this$1 = this;
  if (hasInterface(arguments[0], Collection)) {
    var segStrings = arguments[0];
    var nodedSegmentStrings = new ArrayList();
    for (var i = segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      nodedSegmentStrings.add(new NodedSegmentString(this$1.scale(ss.getCoordinates()), ss.getData()));
    }
    return nodedSegmentStrings;
  } else if (arguments[0] instanceof Array) {
    var pts = arguments[0];
    var roundPts = new Array(pts.length).fill(null);
    for (var i$1 = 0; i$1 < pts.length; i$1++) {
      roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1._offsetX) * this$1._scaleFactor), Math.round((pts[i$1].y - this$1._offsetY) * this$1._scaleFactor), pts[i$1].z);
    }
    var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
    return roundPtsNoDup;
  }
};
ScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision() {
  return this._scaleFactor === 1;
};
ScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings3() {
  var splitSS = this._noder.getNodedSubstrings();
  if (this._isScaled) {
    this.rescale(splitSS);
  }
  return splitSS;
};
ScaledNoder.prototype.computeNodes = function computeNodes2(inputSegStrings) {
  var intSegStrings = inputSegStrings;
  if (this._isScaled) {
    intSegStrings = this.scale(inputSegStrings);
  }
  this._noder.computeNodes(intSegStrings);
};
ScaledNoder.prototype.interfaces_ = function interfaces_107() {
  return [Noder];
};
ScaledNoder.prototype.getClass = function getClass106() {
  return ScaledNoder;
};
var NodingValidator = function NodingValidator2() {
  this._li = new RobustLineIntersector();
  this._segStrings = null;
  var segStrings = arguments[0];
  this._segStrings = segStrings;
};
var staticAccessors$33 = { fact: { configurable: true } };
NodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections() {
  var this$1 = this;
  if (arguments.length === 0) {
    for (var i = this._segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      var pts = ss.getCoordinates();
      this$1.checkEndPtVertexIntersections(pts[0], this$1._segStrings);
      this$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1._segStrings);
    }
  } else if (arguments.length === 2) {
    var testPt = arguments[0];
    var segStrings = arguments[1];
    for (var i$1 = segStrings.iterator(); i$1.hasNext(); ) {
      var ss$1 = i$1.next();
      var pts$1 = ss$1.getCoordinates();
      for (var j = 1; j < pts$1.length - 1; j++) {
        if (pts$1[j].equals(testPt)) {
          throw new RuntimeException("found endpt/interior pt intersection at index " + j + " :pt " + testPt);
        }
      }
    }
  }
};
NodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {
  var this$1 = this;
  if (arguments.length === 0) {
    for (var i = this._segStrings.iterator(); i.hasNext(); ) {
      var ss0 = i.next();
      for (var j = this._segStrings.iterator(); j.hasNext(); ) {
        var ss1 = j.next();
        this$1.checkInteriorIntersections(ss0, ss1);
      }
    }
  } else if (arguments.length === 2) {
    var ss0$1 = arguments[0];
    var ss1$1 = arguments[1];
    var pts0 = ss0$1.getCoordinates();
    var pts1 = ss1$1.getCoordinates();
    for (var i0 = 0; i0 < pts0.length - 1; i0++) {
      for (var i1 = 0; i1 < pts1.length - 1; i1++) {
        this$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);
      }
    }
  } else if (arguments.length === 4) {
    var e0 = arguments[0];
    var segIndex0 = arguments[1];
    var e1 = arguments[2];
    var segIndex1 = arguments[3];
    if (e0 === e1 && segIndex0 === segIndex1) {
      return null;
    }
    var p002 = e0.getCoordinates()[segIndex0];
    var p012 = e0.getCoordinates()[segIndex0 + 1];
    var p102 = e1.getCoordinates()[segIndex1];
    var p112 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p002, p012, p102, p112);
    if (this._li.hasIntersection()) {
      if (this._li.isProper() || this.hasInteriorIntersection(this._li, p002, p012) || this.hasInteriorIntersection(this._li, p102, p112)) {
        throw new RuntimeException("found non-noded intersection at " + p002 + "-" + p012 + " and " + p102 + "-" + p112);
      }
    }
  }
};
NodingValidator.prototype.checkValid = function checkValid() {
  this.checkEndPtVertexIntersections();
  this.checkInteriorIntersections();
  this.checkCollapses();
};
NodingValidator.prototype.checkCollapses = function checkCollapses() {
  var this$1 = this;
  if (arguments.length === 0) {
    for (var i = this._segStrings.iterator(); i.hasNext(); ) {
      var ss = i.next();
      this$1.checkCollapses(ss);
    }
  } else if (arguments.length === 1) {
    var ss$1 = arguments[0];
    var pts = ss$1.getCoordinates();
    for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {
      this$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);
    }
  }
};
NodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection2(li, p0, p1) {
  for (var i = 0; i < li.getIntersectionNum(); i++) {
    var intPt = li.getIntersection(i);
    if (!(intPt.equals(p0) || intPt.equals(p1))) {
      return true;
    }
  }
  return false;
};
NodingValidator.prototype.checkCollapse = function checkCollapse(p0, p1, p2) {
  if (p0.equals(p2)) {
    throw new RuntimeException("found non-noded collapse at " + NodingValidator.fact.createLineString([p0, p1, p2]));
  }
};
NodingValidator.prototype.interfaces_ = function interfaces_108() {
  return [];
};
NodingValidator.prototype.getClass = function getClass107() {
  return NodingValidator;
};
staticAccessors$33.fact.get = function() {
  return new GeometryFactory();
};
Object.defineProperties(NodingValidator, staticAccessors$33);
var HotPixel = function HotPixel2() {
  this._li = null;
  this._pt = null;
  this._originalPt = null;
  this._ptScaled = null;
  this._p0Scaled = null;
  this._p1Scaled = null;
  this._scaleFactor = null;
  this._minx = null;
  this._maxx = null;
  this._miny = null;
  this._maxy = null;
  this._corner = new Array(4).fill(null);
  this._safeEnv = null;
  var pt = arguments[0];
  var scaleFactor = arguments[1];
  var li = arguments[2];
  this._originalPt = pt;
  this._pt = pt;
  this._scaleFactor = scaleFactor;
  this._li = li;
  if (scaleFactor <= 0) {
    throw new IllegalArgumentException("Scale factor must be non-zero");
  }
  if (scaleFactor !== 1) {
    this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
    this._p0Scaled = new Coordinate();
    this._p1Scaled = new Coordinate();
  }
  this.initCorners(this._pt);
};
var staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
HotPixel.prototype.intersectsScaled = function intersectsScaled(p0, p1) {
  var segMinx = Math.min(p0.x, p1.x);
  var segMaxx = Math.max(p0.x, p1.x);
  var segMiny = Math.min(p0.y, p1.y);
  var segMaxy = Math.max(p0.y, p1.y);
  var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
  if (isOutsidePixelEnv) {
    return false;
  }
  var intersects7 = this.intersectsToleranceSquare(p0, p1);
  Assert.isTrue(!(isOutsidePixelEnv && intersects7), "Found bad envelope test");
  return intersects7;
};
HotPixel.prototype.initCorners = function initCorners(pt) {
  var tolerance = 0.5;
  this._minx = pt.x - tolerance;
  this._maxx = pt.x + tolerance;
  this._miny = pt.y - tolerance;
  this._maxy = pt.y + tolerance;
  this._corner[0] = new Coordinate(this._maxx, this._maxy);
  this._corner[1] = new Coordinate(this._minx, this._maxy);
  this._corner[2] = new Coordinate(this._minx, this._miny);
  this._corner[3] = new Coordinate(this._maxx, this._miny);
};
HotPixel.prototype.intersects = function intersects4(p0, p1) {
  if (this._scaleFactor === 1) {
    return this.intersectsScaled(p0, p1);
  }
  this.copyScaled(p0, this._p0Scaled);
  this.copyScaled(p1, this._p1Scaled);
  return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
};
HotPixel.prototype.scale = function scale3(val) {
  return Math.round(val * this._scaleFactor);
};
HotPixel.prototype.getCoordinate = function getCoordinate13() {
  return this._originalPt;
};
HotPixel.prototype.copyScaled = function copyScaled(p, pScaled) {
  pScaled.x = this.scale(p.x);
  pScaled.y = this.scale(p.y);
};
HotPixel.prototype.getSafeEnvelope = function getSafeEnvelope() {
  if (this._safeEnv === null) {
    var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
    this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
  }
  return this._safeEnv;
};
HotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure(p0, p1) {
  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
  if (this._li.hasIntersection()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
  if (this._li.hasIntersection()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
  if (this._li.hasIntersection()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
  if (this._li.hasIntersection()) {
    return true;
  }
  return false;
};
HotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare(p0, p1) {
  var intersectsLeft = false;
  var intersectsBottom = false;
  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
  if (this._li.isProper()) {
    return true;
  }
  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
  if (this._li.isProper()) {
    return true;
  }
  if (this._li.hasIntersection()) {
    intersectsLeft = true;
  }
  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
  if (this._li.isProper()) {
    return true;
  }
  if (this._li.hasIntersection()) {
    intersectsBottom = true;
  }
  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
  if (this._li.isProper()) {
    return true;
  }
  if (intersectsLeft && intersectsBottom) {
    return true;
  }
  if (p0.equals(this._pt)) {
    return true;
  }
  if (p1.equals(this._pt)) {
    return true;
  }
  return false;
};
HotPixel.prototype.addSnappedNode = function addSnappedNode(segStr, segIndex) {
  var p0 = segStr.getCoordinate(segIndex);
  var p1 = segStr.getCoordinate(segIndex + 1);
  if (this.intersects(p0, p1)) {
    segStr.addIntersection(this.getCoordinate(), segIndex);
    return true;
  }
  return false;
};
HotPixel.prototype.interfaces_ = function interfaces_109() {
  return [];
};
HotPixel.prototype.getClass = function getClass108() {
  return HotPixel;
};
staticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function() {
  return 0.75;
};
Object.defineProperties(HotPixel, staticAccessors$34);
var MonotoneChainSelectAction = function MonotoneChainSelectAction2() {
  this.tempEnv1 = new Envelope();
  this.selectedSegment = new LineSegment();
};
MonotoneChainSelectAction.prototype.select = function select2() {
  if (arguments.length === 1) {
  } else if (arguments.length === 2) {
    var mc = arguments[0];
    var startIndex = arguments[1];
    mc.getLineSegment(startIndex, this.selectedSegment);
    this.select(this.selectedSegment);
  }
};
MonotoneChainSelectAction.prototype.interfaces_ = function interfaces_110() {
  return [];
};
MonotoneChainSelectAction.prototype.getClass = function getClass109() {
  return MonotoneChainSelectAction;
};
var MCIndexPointSnapper = function MCIndexPointSnapper2() {
  this._index = null;
  var index2 = arguments[0];
  this._index = index2;
};
var staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };
MCIndexPointSnapper.prototype.snap = function snap() {
  if (arguments.length === 1) {
    var hotPixel = arguments[0];
    return this.snap(hotPixel, null, -1);
  } else if (arguments.length === 3) {
    var hotPixel$1 = arguments[0];
    var parentEdge = arguments[1];
    var hotPixelVertexIndex = arguments[2];
    var pixelEnv = hotPixel$1.getSafeEnvelope();
    var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);
    this._index.query(pixelEnv, {
      interfaces_: function() {
        return [ItemVisitor];
      },
      visitItem: function(item) {
        var testChain = item;
        testChain.select(pixelEnv, hotPixelSnapAction);
      }
    });
    return hotPixelSnapAction.isNodeAdded();
  }
};
MCIndexPointSnapper.prototype.interfaces_ = function interfaces_111() {
  return [];
};
MCIndexPointSnapper.prototype.getClass = function getClass110() {
  return MCIndexPointSnapper;
};
staticAccessors$35.HotPixelSnapAction.get = function() {
  return HotPixelSnapAction;
};
Object.defineProperties(MCIndexPointSnapper, staticAccessors$35);
var HotPixelSnapAction = function(MonotoneChainSelectAction$$1) {
  function HotPixelSnapAction2() {
    MonotoneChainSelectAction$$1.call(this);
    this._hotPixel = null;
    this._parentEdge = null;
    this._hotPixelVertexIndex = null;
    this._isNodeAdded = false;
    var hotPixel = arguments[0];
    var parentEdge = arguments[1];
    var hotPixelVertexIndex = arguments[2];
    this._hotPixel = hotPixel;
    this._parentEdge = parentEdge;
    this._hotPixelVertexIndex = hotPixelVertexIndex;
  }
  if (MonotoneChainSelectAction$$1)
    HotPixelSnapAction2.__proto__ = MonotoneChainSelectAction$$1;
  HotPixelSnapAction2.prototype = Object.create(MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype);
  HotPixelSnapAction2.prototype.constructor = HotPixelSnapAction2;
  HotPixelSnapAction2.prototype.isNodeAdded = function isNodeAdded() {
    return this._isNodeAdded;
  };
  HotPixelSnapAction2.prototype.select = function select3() {
    if (arguments.length === 2) {
      var mc = arguments[0];
      var startIndex = arguments[1];
      var ss = mc.getContext();
      if (this._parentEdge !== null) {
        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) {
          return null;
        }
      }
      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
    } else {
      return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments);
    }
  };
  HotPixelSnapAction2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  HotPixelSnapAction2.prototype.getClass = function getClass169() {
    return HotPixelSnapAction2;
  };
  return HotPixelSnapAction2;
}(MonotoneChainSelectAction);
var InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder2() {
  this._li = null;
  this._interiorIntersections = null;
  var li = arguments[0];
  this._li = li;
  this._interiorIntersections = new ArrayList();
};
InteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections3(e0, segIndex0, e1, segIndex1) {
  var this$1 = this;
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    if (this._li.isInteriorIntersection()) {
      for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
        this$1._interiorIntersections.add(this$1._li.getIntersection(intIndex));
      }
      e0.addIntersections(this._li, segIndex0, 0);
      e1.addIntersections(this._li, segIndex1, 1);
    }
  }
};
InteriorIntersectionFinderAdder.prototype.isDone = function isDone4() {
  return false;
};
InteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections() {
  return this._interiorIntersections;
};
InteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_112() {
  return [SegmentIntersector];
};
InteriorIntersectionFinderAdder.prototype.getClass = function getClass111() {
  return InteriorIntersectionFinderAdder;
};
var MCIndexSnapRounder = function MCIndexSnapRounder2() {
  this._pm = null;
  this._li = null;
  this._scaleFactor = null;
  this._noder = null;
  this._pointSnapper = null;
  this._nodedSegStrings = null;
  var pm = arguments[0];
  this._pm = pm;
  this._li = new RobustLineIntersector();
  this._li.setPrecisionModel(pm);
  this._scaleFactor = pm.getScale();
};
MCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness(inputSegmentStrings) {
  var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
  var nv = new NodingValidator(resultSegStrings);
  try {
    nv.checkValid();
  } catch (ex) {
    if (ex instanceof Exception) {
      ex.printStackTrace();
    } else {
      throw ex;
    }
  } finally {
  }
};
MCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings4() {
  return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
};
MCIndexSnapRounder.prototype.snapRound = function snapRound(segStrings, li) {
  var intersections = this.findInteriorIntersections(segStrings, li);
  this.computeIntersectionSnaps(intersections);
  this.computeVertexSnaps(segStrings);
};
MCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections(segStrings, li) {
  var intFinderAdder = new InteriorIntersectionFinderAdder(li);
  this._noder.setSegmentIntersector(intFinderAdder);
  this._noder.computeNodes(segStrings);
  return intFinderAdder.getInteriorIntersections();
};
MCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps() {
  var this$1 = this;
  if (hasInterface(arguments[0], Collection)) {
    var edges2 = arguments[0];
    for (var i0 = edges2.iterator(); i0.hasNext(); ) {
      var edge0 = i0.next();
      this$1.computeVertexSnaps(edge0);
    }
  } else if (arguments[0] instanceof NodedSegmentString) {
    var e = arguments[0];
    var pts0 = e.getCoordinates();
    for (var i = 0; i < pts0.length; i++) {
      var hotPixel = new HotPixel(pts0[i], this$1._scaleFactor, this$1._li);
      var isNodeAdded = this$1._pointSnapper.snap(hotPixel, e, i);
      if (isNodeAdded) {
        e.addIntersection(pts0[i], i);
      }
    }
  }
};
MCIndexSnapRounder.prototype.computeNodes = function computeNodes3(inputSegmentStrings) {
  this._nodedSegStrings = inputSegmentStrings;
  this._noder = new MCIndexNoder();
  this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
  this.snapRound(inputSegmentStrings, this._li);
};
MCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps(snapPts) {
  var this$1 = this;
  for (var it = snapPts.iterator(); it.hasNext(); ) {
    var snapPt = it.next();
    var hotPixel = new HotPixel(snapPt, this$1._scaleFactor, this$1._li);
    this$1._pointSnapper.snap(hotPixel);
  }
};
MCIndexSnapRounder.prototype.interfaces_ = function interfaces_113() {
  return [Noder];
};
MCIndexSnapRounder.prototype.getClass = function getClass112() {
  return MCIndexSnapRounder;
};
var BufferOp = function BufferOp2() {
  this._argGeom = null;
  this._distance = null;
  this._bufParams = new BufferParameters();
  this._resultGeometry = null;
  this._saveException = null;
  if (arguments.length === 1) {
    var g = arguments[0];
    this._argGeom = g;
  } else if (arguments.length === 2) {
    var g$1 = arguments[0];
    var bufParams = arguments[1];
    this._argGeom = g$1;
    this._bufParams = bufParams;
  }
};
var staticAccessors$32 = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
BufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision(fixedPM) {
  var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1)), fixedPM.getScale());
  var bufBuilder = new BufferBuilder(this._bufParams);
  bufBuilder.setWorkingPrecisionModel(fixedPM);
  bufBuilder.setNoder(noder);
  this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
};
BufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision() {
  var this$1 = this;
  if (arguments.length === 0) {
    for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
      try {
        this$1.bufferReducedPrecision(precDigits);
      } catch (ex) {
        if (ex instanceof TopologyException) {
          this$1._saveException = ex;
        } else {
          throw ex;
        }
      } finally {
      }
      if (this$1._resultGeometry !== null) {
        return null;
      }
    }
    throw this._saveException;
  } else if (arguments.length === 1) {
    var precisionDigits = arguments[0];
    var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
    var fixedPM = new PrecisionModel(sizeBasedScaleFactor);
    this.bufferFixedPrecision(fixedPM);
  }
};
BufferOp.prototype.computeGeometry = function computeGeometry() {
  this.bufferOriginalPrecision();
  if (this._resultGeometry !== null) {
    return null;
  }
  var argPM = this._argGeom.getFactory().getPrecisionModel();
  if (argPM.getType() === PrecisionModel.FIXED) {
    this.bufferFixedPrecision(argPM);
  } else {
    this.bufferReducedPrecision();
  }
};
BufferOp.prototype.setQuadrantSegments = function setQuadrantSegments2(quadrantSegments) {
  this._bufParams.setQuadrantSegments(quadrantSegments);
};
BufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision() {
  try {
    var bufBuilder = new BufferBuilder(this._bufParams);
    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
  } catch (ex) {
    if (ex instanceof RuntimeException) {
      this._saveException = ex;
    } else {
      throw ex;
    }
  } finally {
  }
};
BufferOp.prototype.getResultGeometry = function getResultGeometry(distance11) {
  this._distance = distance11;
  this.computeGeometry();
  return this._resultGeometry;
};
BufferOp.prototype.setEndCapStyle = function setEndCapStyle2(endCapStyle) {
  this._bufParams.setEndCapStyle(endCapStyle);
};
BufferOp.prototype.interfaces_ = function interfaces_114() {
  return [];
};
BufferOp.prototype.getClass = function getClass113() {
  return BufferOp;
};
BufferOp.bufferOp = function bufferOp() {
  if (arguments.length === 2) {
    var g = arguments[0];
    var distance11 = arguments[1];
    var gBuf = new BufferOp(g);
    var geomBuf = gBuf.getResultGeometry(distance11);
    return geomBuf;
  } else if (arguments.length === 3) {
    if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === "number")) {
      var g$1 = arguments[0];
      var distance$1 = arguments[1];
      var quadrantSegments = arguments[2];
      var bufOp = new BufferOp(g$1);
      bufOp.setQuadrantSegments(quadrantSegments);
      var geomBuf$1 = bufOp.getResultGeometry(distance$1);
      return geomBuf$1;
    } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === "number")) {
      var g$2 = arguments[0];
      var distance$2 = arguments[1];
      var params = arguments[2];
      var bufOp$1 = new BufferOp(g$2, params);
      var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);
      return geomBuf$2;
    }
  } else if (arguments.length === 4) {
    var g$3 = arguments[0];
    var distance$3 = arguments[1];
    var quadrantSegments$1 = arguments[2];
    var endCapStyle = arguments[3];
    var bufOp$2 = new BufferOp(g$3);
    bufOp$2.setQuadrantSegments(quadrantSegments$1);
    bufOp$2.setEndCapStyle(endCapStyle);
    var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);
    return geomBuf$3;
  }
};
BufferOp.precisionScaleFactor = function precisionScaleFactor(g, distance11, maxPrecisionDigits) {
  var env = g.getEnvelopeInternal();
  var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
  var expandByDistance = distance11 > 0 ? distance11 : 0;
  var bufEnvMax = envMax + 2 * expandByDistance;
  var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1);
  var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
  var scaleFactor = Math.pow(10, minUnitLog10);
  return scaleFactor;
};
staticAccessors$32.CAP_ROUND.get = function() {
  return BufferParameters.CAP_ROUND;
};
staticAccessors$32.CAP_BUTT.get = function() {
  return BufferParameters.CAP_FLAT;
};
staticAccessors$32.CAP_FLAT.get = function() {
  return BufferParameters.CAP_FLAT;
};
staticAccessors$32.CAP_SQUARE.get = function() {
  return BufferParameters.CAP_SQUARE;
};
staticAccessors$32.MAX_PRECISION_DIGITS.get = function() {
  return 12;
};
Object.defineProperties(BufferOp, staticAccessors$32);
var PointPairDistance = function PointPairDistance2() {
  this._pt = [new Coordinate(), new Coordinate()];
  this._distance = Double.NaN;
  this._isNull = true;
};
PointPairDistance.prototype.getCoordinates = function getCoordinates7() {
  return this._pt;
};
PointPairDistance.prototype.getCoordinate = function getCoordinate14(i) {
  return this._pt[i];
};
PointPairDistance.prototype.setMinimum = function setMinimum() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist = p0.distance(p1);
    if (dist < this._distance) {
      this.initialize(p0, p1, dist);
    }
  }
};
PointPairDistance.prototype.initialize = function initialize() {
  if (arguments.length === 0) {
    this._isNull = true;
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    this._pt[0].setCoordinate(p0);
    this._pt[1].setCoordinate(p1);
    this._distance = p0.distance(p1);
    this._isNull = false;
  } else if (arguments.length === 3) {
    var p0$1 = arguments[0];
    var p1$1 = arguments[1];
    var distance11 = arguments[2];
    this._pt[0].setCoordinate(p0$1);
    this._pt[1].setCoordinate(p1$1);
    this._distance = distance11;
    this._isNull = false;
  }
};
PointPairDistance.prototype.getDistance = function getDistance3() {
  return this._distance;
};
PointPairDistance.prototype.setMaximum = function setMaximum() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist = p0.distance(p1);
    if (dist > this._distance) {
      this.initialize(p0, p1, dist);
    }
  }
};
PointPairDistance.prototype.interfaces_ = function interfaces_115() {
  return [];
};
PointPairDistance.prototype.getClass = function getClass114() {
  return PointPairDistance;
};
var DistanceToPointFinder = function DistanceToPointFinder2() {
};
DistanceToPointFinder.prototype.interfaces_ = function interfaces_116() {
  return [];
};
DistanceToPointFinder.prototype.getClass = function getClass115() {
  return DistanceToPointFinder;
};
DistanceToPointFinder.computeDistance = function computeDistance() {
  if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString2 && arguments[1] instanceof Coordinate)) {
    var line = arguments[0];
    var pt = arguments[1];
    var ptDist = arguments[2];
    var coords = line.getCoordinates();
    var tempSegment = new LineSegment();
    for (var i = 0; i < coords.length - 1; i++) {
      tempSegment.setCoordinates(coords[i], coords[i + 1]);
      var closestPt = tempSegment.closestPoint(pt);
      ptDist.setMinimum(closestPt, pt);
    }
  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
    var poly = arguments[0];
    var pt$1 = arguments[1];
    var ptDist$1 = arguments[2];
    DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
      DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
    }
  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
    var geom = arguments[0];
    var pt$2 = arguments[1];
    var ptDist$2 = arguments[2];
    if (geom instanceof LineString2) {
      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof Polygon) {
      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof GeometryCollection) {
      var gc = geom;
      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
        var g = gc.getGeometryN(i$2);
        DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);
      }
    } else {
      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
    }
  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
    var segment = arguments[0];
    var pt$3 = arguments[1];
    var ptDist$3 = arguments[2];
    var closestPt$1 = segment.closestPoint(pt$3);
    ptDist$3.setMinimum(closestPt$1, pt$3);
  }
};
var BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder2(inputGeom) {
  this._maxPtDist = new PointPairDistance();
  this._inputGeom = inputGeom || null;
};
var staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
BufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance(curve) {
  var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);
  curve.apply(distFilter);
  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
};
BufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance(curve) {
  var distFilter = new MaxPointDistanceFilter(this._inputGeom);
  curve.apply(distFilter);
  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
};
BufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance(bufferCurve) {
  this.computeMaxVertexDistance(bufferCurve);
  this.computeMaxMidpointDistance(bufferCurve);
  return this._maxPtDist.getDistance();
};
BufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints() {
  return this._maxPtDist;
};
BufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_117() {
  return [];
};
BufferCurveMaximumDistanceFinder.prototype.getClass = function getClass116() {
  return BufferCurveMaximumDistanceFinder;
};
staticAccessors$36.MaxPointDistanceFilter.get = function() {
  return MaxPointDistanceFilter;
};
staticAccessors$36.MaxMidpointDistanceFilter.get = function() {
  return MaxMidpointDistanceFilter;
};
Object.defineProperties(BufferCurveMaximumDistanceFinder, staticAccessors$36);
var MaxPointDistanceFilter = function MaxPointDistanceFilter2(geom) {
  this._maxPtDist = new PointPairDistance();
  this._minPtDist = new PointPairDistance();
  this._geom = geom || null;
};
MaxPointDistanceFilter.prototype.filter = function filter6(pt) {
  this._minPtDist.initialize();
  DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);
  this._maxPtDist.setMaximum(this._minPtDist);
};
MaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {
  return this._maxPtDist;
};
MaxPointDistanceFilter.prototype.interfaces_ = function interfaces_118() {
  return [CoordinateFilter];
};
MaxPointDistanceFilter.prototype.getClass = function getClass117() {
  return MaxPointDistanceFilter;
};
var MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter2(geom) {
  this._maxPtDist = new PointPairDistance();
  this._minPtDist = new PointPairDistance();
  this._geom = geom || null;
};
MaxMidpointDistanceFilter.prototype.filter = function filter7(seq, index2) {
  if (index2 === 0) {
    return null;
  }
  var p0 = seq.getCoordinate(index2 - 1);
  var p1 = seq.getCoordinate(index2);
  var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
  this._minPtDist.initialize();
  DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);
  this._maxPtDist.setMaximum(this._minPtDist);
};
MaxMidpointDistanceFilter.prototype.isDone = function isDone5() {
  return false;
};
MaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged2() {
  return false;
};
MaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance2() {
  return this._maxPtDist;
};
MaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_119() {
  return [CoordinateSequenceFilter];
};
MaxMidpointDistanceFilter.prototype.getClass = function getClass118() {
  return MaxMidpointDistanceFilter;
};
var PolygonExtracter = function PolygonExtracter2(comps) {
  this._comps = comps || null;
};
PolygonExtracter.prototype.filter = function filter8(geom) {
  if (geom instanceof Polygon) {
    this._comps.add(geom);
  }
};
PolygonExtracter.prototype.interfaces_ = function interfaces_120() {
  return [GeometryFilter];
};
PolygonExtracter.prototype.getClass = function getClass119() {
  return PolygonExtracter;
};
PolygonExtracter.getPolygons = function getPolygons2() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    return PolygonExtracter.getPolygons(geom, new ArrayList());
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var list = arguments[1];
    if (geom$1 instanceof Polygon) {
      list.add(geom$1);
    } else if (geom$1 instanceof GeometryCollection) {
      geom$1.apply(new PolygonExtracter(list));
    }
    return list;
  }
};
var LinearComponentExtracter = function LinearComponentExtracter2() {
  this._lines = null;
  this._isForcedToLineString = false;
  if (arguments.length === 1) {
    var lines = arguments[0];
    this._lines = lines;
  } else if (arguments.length === 2) {
    var lines$1 = arguments[0];
    var isForcedToLineString = arguments[1];
    this._lines = lines$1;
    this._isForcedToLineString = isForcedToLineString;
  }
};
LinearComponentExtracter.prototype.filter = function filter9(geom) {
  if (this._isForcedToLineString && geom instanceof LinearRing) {
    var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
    this._lines.add(line);
    return null;
  }
  if (geom instanceof LineString2) {
    this._lines.add(geom);
  }
};
LinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString(isForcedToLineString) {
  this._isForcedToLineString = isForcedToLineString;
};
LinearComponentExtracter.prototype.interfaces_ = function interfaces_121() {
  return [GeometryComponentFilter];
};
LinearComponentExtracter.prototype.getClass = function getClass120() {
  return LinearComponentExtracter;
};
LinearComponentExtracter.getGeometry = function getGeometry() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var forceToLineString = arguments[1];
    return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString));
  }
};
LinearComponentExtracter.getLines = function getLines() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    return LinearComponentExtracter.getLines(geom, false);
  } else if (arguments.length === 2) {
    if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
      var geoms = arguments[0];
      var lines$1 = arguments[1];
      for (var i = geoms.iterator(); i.hasNext(); ) {
        var g = i.next();
        LinearComponentExtracter.getLines(g, lines$1);
      }
      return lines$1;
    } else if (arguments[0] instanceof Geometry && typeof arguments[1] === "boolean") {
      var geom$1 = arguments[0];
      var forceToLineString = arguments[1];
      var lines = new ArrayList();
      geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));
      return lines;
    } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
      var geom$2 = arguments[0];
      var lines$2 = arguments[1];
      if (geom$2 instanceof LineString2) {
        lines$2.add(geom$2);
      } else {
        geom$2.apply(new LinearComponentExtracter(lines$2));
      }
      return lines$2;
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === "boolean" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {
      var geoms$1 = arguments[0];
      var lines$3 = arguments[1];
      var forceToLineString$1 = arguments[2];
      for (var i$1 = geoms$1.iterator(); i$1.hasNext(); ) {
        var g$1 = i$1.next();
        LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);
      }
      return lines$3;
    } else if (typeof arguments[2] === "boolean" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {
      var geom$3 = arguments[0];
      var lines$4 = arguments[1];
      var forceToLineString$2 = arguments[2];
      geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));
      return lines$4;
    }
  }
};
var PointLocator = function PointLocator2() {
  this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
  this._isIn = null;
  this._numBoundaries = null;
  if (arguments.length === 0) {
  } else if (arguments.length === 1) {
    var boundaryRule = arguments[0];
    if (boundaryRule === null) {
      throw new IllegalArgumentException("Rule must be non-null");
    }
    this._boundaryRule = boundaryRule;
  }
};
PointLocator.prototype.locateInternal = function locateInternal() {
  var this$1 = this;
  if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {
    var p = arguments[0];
    var poly = arguments[1];
    if (poly.isEmpty()) {
      return Location.EXTERIOR;
    }
    var shell = poly.getExteriorRing();
    var shellLoc = this.locateInPolygonRing(p, shell);
    if (shellLoc === Location.EXTERIOR) {
      return Location.EXTERIOR;
    }
    if (shellLoc === Location.BOUNDARY) {
      return Location.BOUNDARY;
    }
    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
      var hole = poly.getInteriorRingN(i);
      var holeLoc = this$1.locateInPolygonRing(p, hole);
      if (holeLoc === Location.INTERIOR) {
        return Location.EXTERIOR;
      }
      if (holeLoc === Location.BOUNDARY) {
        return Location.BOUNDARY;
      }
    }
    return Location.INTERIOR;
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString2) {
    var p$1 = arguments[0];
    var l = arguments[1];
    if (!l.getEnvelopeInternal().intersects(p$1)) {
      return Location.EXTERIOR;
    }
    var pt = l.getCoordinates();
    if (!l.isClosed()) {
      if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {
        return Location.BOUNDARY;
      }
    }
    if (CGAlgorithms.isOnLine(p$1, pt)) {
      return Location.INTERIOR;
    }
    return Location.EXTERIOR;
  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {
    var p$2 = arguments[0];
    var pt$1 = arguments[1];
    var ptCoord = pt$1.getCoordinate();
    if (ptCoord.equals2D(p$2)) {
      return Location.INTERIOR;
    }
    return Location.EXTERIOR;
  }
};
PointLocator.prototype.locateInPolygonRing = function locateInPolygonRing(p, ring) {
  if (!ring.getEnvelopeInternal().intersects(p)) {
    return Location.EXTERIOR;
  }
  return CGAlgorithms.locatePointInRing(p, ring.getCoordinates());
};
PointLocator.prototype.intersects = function intersects5(p, geom) {
  return this.locate(p, geom) !== Location.EXTERIOR;
};
PointLocator.prototype.updateLocationInfo = function updateLocationInfo(loc) {
  if (loc === Location.INTERIOR) {
    this._isIn = true;
  }
  if (loc === Location.BOUNDARY) {
    this._numBoundaries++;
  }
};
PointLocator.prototype.computeLocation = function computeLocation(p, geom) {
  var this$1 = this;
  if (geom instanceof Point) {
    this.updateLocationInfo(this.locateInternal(p, geom));
  }
  if (geom instanceof LineString2) {
    this.updateLocationInfo(this.locateInternal(p, geom));
  } else if (geom instanceof Polygon) {
    this.updateLocationInfo(this.locateInternal(p, geom));
  } else if (geom instanceof MultiLineString) {
    var ml = geom;
    for (var i = 0; i < ml.getNumGeometries(); i++) {
      var l = ml.getGeometryN(i);
      this$1.updateLocationInfo(this$1.locateInternal(p, l));
    }
  } else if (geom instanceof MultiPolygon) {
    var mpoly = geom;
    for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {
      var poly = mpoly.getGeometryN(i$1);
      this$1.updateLocationInfo(this$1.locateInternal(p, poly));
    }
  } else if (geom instanceof GeometryCollection) {
    var geomi = new GeometryCollectionIterator(geom);
    while (geomi.hasNext()) {
      var g2 = geomi.next();
      if (g2 !== geom) {
        this$1.computeLocation(p, g2);
      }
    }
  }
};
PointLocator.prototype.locate = function locate4(p, geom) {
  if (geom.isEmpty()) {
    return Location.EXTERIOR;
  }
  if (geom instanceof LineString2) {
    return this.locateInternal(p, geom);
  } else if (geom instanceof Polygon) {
    return this.locateInternal(p, geom);
  }
  this._isIn = false;
  this._numBoundaries = 0;
  this.computeLocation(p, geom);
  if (this._boundaryRule.isInBoundary(this._numBoundaries)) {
    return Location.BOUNDARY;
  }
  if (this._numBoundaries > 0 || this._isIn) {
    return Location.INTERIOR;
  }
  return Location.EXTERIOR;
};
PointLocator.prototype.interfaces_ = function interfaces_122() {
  return [];
};
PointLocator.prototype.getClass = function getClass121() {
  return PointLocator;
};
var GeometryLocation = function GeometryLocation2() {
  this._component = null;
  this._segIndex = null;
  this._pt = null;
  if (arguments.length === 2) {
    var component = arguments[0];
    var pt = arguments[1];
    GeometryLocation2.call(this, component, GeometryLocation2.INSIDE_AREA, pt);
  } else if (arguments.length === 3) {
    var component$1 = arguments[0];
    var segIndex = arguments[1];
    var pt$1 = arguments[2];
    this._component = component$1;
    this._segIndex = segIndex;
    this._pt = pt$1;
  }
};
var staticAccessors$38 = { INSIDE_AREA: { configurable: true } };
GeometryLocation.prototype.isInsideArea = function isInsideArea() {
  return this._segIndex === GeometryLocation.INSIDE_AREA;
};
GeometryLocation.prototype.getCoordinate = function getCoordinate15() {
  return this._pt;
};
GeometryLocation.prototype.getGeometryComponent = function getGeometryComponent() {
  return this._component;
};
GeometryLocation.prototype.getSegmentIndex = function getSegmentIndex2() {
  return this._segIndex;
};
GeometryLocation.prototype.interfaces_ = function interfaces_123() {
  return [];
};
GeometryLocation.prototype.getClass = function getClass122() {
  return GeometryLocation;
};
staticAccessors$38.INSIDE_AREA.get = function() {
  return -1;
};
Object.defineProperties(GeometryLocation, staticAccessors$38);
var PointExtracter = function PointExtracter2(pts) {
  this._pts = pts || null;
};
PointExtracter.prototype.filter = function filter10(geom) {
  if (geom instanceof Point) {
    this._pts.add(geom);
  }
};
PointExtracter.prototype.interfaces_ = function interfaces_124() {
  return [GeometryFilter];
};
PointExtracter.prototype.getClass = function getClass123() {
  return PointExtracter;
};
PointExtracter.getPoints = function getPoints() {
  if (arguments.length === 1) {
    var geom = arguments[0];
    if (geom instanceof Point) {
      return Collections.singletonList(geom);
    }
    return PointExtracter.getPoints(geom, new ArrayList());
  } else if (arguments.length === 2) {
    var geom$1 = arguments[0];
    var list = arguments[1];
    if (geom$1 instanceof Point) {
      list.add(geom$1);
    } else if (geom$1 instanceof GeometryCollection) {
      geom$1.apply(new PointExtracter(list));
    }
    return list;
  }
};
var ConnectedElementLocationFilter = function ConnectedElementLocationFilter2() {
  this._locations = null;
  var locations = arguments[0];
  this._locations = locations;
};
ConnectedElementLocationFilter.prototype.filter = function filter11(geom) {
  if (geom instanceof Point || geom instanceof LineString2 || geom instanceof Polygon) {
    this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));
  }
};
ConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_125() {
  return [GeometryFilter];
};
ConnectedElementLocationFilter.prototype.getClass = function getClass124() {
  return ConnectedElementLocationFilter;
};
ConnectedElementLocationFilter.getLocations = function getLocations2(geom) {
  var locations = new ArrayList();
  geom.apply(new ConnectedElementLocationFilter(locations));
  return locations;
};
var DistanceOp = function DistanceOp2() {
  this._geom = null;
  this._terminateDistance = 0;
  this._ptLocator = new PointLocator();
  this._minDistanceLocation = null;
  this._minDistance = Double.MAX_VALUE;
  if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    this._geom = [g0, g1];
    this._terminateDistance = 0;
  } else if (arguments.length === 3) {
    var g0$1 = arguments[0];
    var g1$1 = arguments[1];
    var terminateDistance = arguments[2];
    this._geom = new Array(2).fill(null);
    this._geom[0] = g0$1;
    this._geom[1] = g1$1;
    this._terminateDistance = terminateDistance;
  }
};
DistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance() {
  var this$1 = this;
  if (arguments.length === 0) {
    var locPtPoly = new Array(2).fill(null);
    this.computeContainmentDistance(0, locPtPoly);
    if (this._minDistance <= this._terminateDistance) {
      return null;
    }
    this.computeContainmentDistance(1, locPtPoly);
  } else if (arguments.length === 2) {
    var polyGeomIndex = arguments[0];
    var locPtPoly$1 = arguments[1];
    var locationsIndex = 1 - polyGeomIndex;
    var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);
    if (polys.size() > 0) {
      var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);
      this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);
      if (this._minDistance <= this._terminateDistance) {
        this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];
        this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];
        return null;
      }
    }
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
      var locs = arguments[0];
      var polys$1 = arguments[1];
      var locPtPoly$2 = arguments[2];
      for (var i = 0; i < locs.size(); i++) {
        var loc = locs.get(i);
        for (var j = 0; j < polys$1.size(); j++) {
          this$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);
          if (this$1._minDistance <= this$1._terminateDistance) {
            return null;
          }
        }
      }
    } else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {
      var ptLoc = arguments[0];
      var poly = arguments[1];
      var locPtPoly$3 = arguments[2];
      var pt = ptLoc.getCoordinate();
      if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {
        this._minDistance = 0;
        locPtPoly$3[0] = ptLoc;
        locPtPoly$3[1] = new GeometryLocation(poly, pt);
        return null;
      }
    }
  }
};
DistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints(lines, points2, locGeom) {
  var this$1 = this;
  for (var i = 0; i < lines.size(); i++) {
    var line = lines.get(i);
    for (var j = 0; j < points2.size(); j++) {
      var pt = points2.get(j);
      this$1.computeMinDistance(line, pt, locGeom);
      if (this$1._minDistance <= this$1._terminateDistance) {
        return null;
      }
    }
  }
};
DistanceOp.prototype.computeFacetDistance = function computeFacetDistance() {
  var locGeom = new Array(2).fill(null);
  var lines0 = LinearComponentExtracter.getLines(this._geom[0]);
  var lines1 = LinearComponentExtracter.getLines(this._geom[1]);
  var pts0 = PointExtracter.getPoints(this._geom[0]);
  var pts1 = PointExtracter.getPoints(this._geom[1]);
  this.computeMinDistanceLines(lines0, lines1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this._minDistance <= this._terminateDistance) {
    return null;
  }
  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this._minDistance <= this._terminateDistance) {
    return null;
  }
  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
  this.updateMinDistance(locGeom, true);
  if (this._minDistance <= this._terminateDistance) {
    return null;
  }
  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistancePoints(pts0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
};
DistanceOp.prototype.nearestLocations = function nearestLocations() {
  this.computeMinDistance();
  return this._minDistanceLocation;
};
DistanceOp.prototype.updateMinDistance = function updateMinDistance(locGeom, flip4) {
  if (locGeom[0] === null) {
    return null;
  }
  if (flip4) {
    this._minDistanceLocation[0] = locGeom[1];
    this._minDistanceLocation[1] = locGeom[0];
  } else {
    this._minDistanceLocation[0] = locGeom[0];
    this._minDistanceLocation[1] = locGeom[1];
  }
};
DistanceOp.prototype.nearestPoints = function nearestPoints() {
  this.computeMinDistance();
  var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
  return nearestPts;
};
DistanceOp.prototype.computeMinDistance = function computeMinDistance() {
  var this$1 = this;
  if (arguments.length === 0) {
    if (this._minDistanceLocation !== null) {
      return null;
    }
    this._minDistanceLocation = new Array(2).fill(null);
    this.computeContainmentDistance();
    if (this._minDistance <= this._terminateDistance) {
      return null;
    }
    this.computeFacetDistance();
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && (arguments[0] instanceof LineString2 && arguments[1] instanceof Point)) {
      var line = arguments[0];
      var pt = arguments[1];
      var locGeom = arguments[2];
      if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) {
        return null;
      }
      var coord0 = line.getCoordinates();
      var coord = pt.getCoordinate();
      for (var i = 0; i < coord0.length - 1; i++) {
        var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
        if (dist < this$1._minDistance) {
          this$1._minDistance = dist;
          var seg = new LineSegment(coord0[i], coord0[i + 1]);
          var segClosestPoint = seg.closestPoint(coord);
          locGeom[0] = new GeometryLocation(line, i, segClosestPoint);
          locGeom[1] = new GeometryLocation(pt, 0, coord);
        }
        if (this$1._minDistance <= this$1._terminateDistance) {
          return null;
        }
      }
    } else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString2 && arguments[1] instanceof LineString2)) {
      var line0 = arguments[0];
      var line1 = arguments[1];
      var locGeom$1 = arguments[2];
      if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) {
        return null;
      }
      var coord0$1 = line0.getCoordinates();
      var coord1 = line1.getCoordinates();
      for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {
        for (var j = 0; j < coord1.length - 1; j++) {
          var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);
          if (dist$1 < this$1._minDistance) {
            this$1._minDistance = dist$1;
            var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);
            var seg1 = new LineSegment(coord1[j], coord1[j + 1]);
            var closestPt = seg0.closestPoints(seg1);
            locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);
            locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);
          }
          if (this$1._minDistance <= this$1._terminateDistance) {
            return null;
          }
        }
      }
    }
  }
};
DistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints(points0, points1, locGeom) {
  var this$1 = this;
  for (var i = 0; i < points0.size(); i++) {
    var pt0 = points0.get(i);
    for (var j = 0; j < points1.size(); j++) {
      var pt1 = points1.get(j);
      var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
      if (dist < this$1._minDistance) {
        this$1._minDistance = dist;
        locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());
        locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());
      }
      if (this$1._minDistance <= this$1._terminateDistance) {
        return null;
      }
    }
  }
};
DistanceOp.prototype.distance = function distance7() {
  if (this._geom[0] === null || this._geom[1] === null) {
    throw new IllegalArgumentException("null geometries are not supported");
  }
  if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) {
    return 0;
  }
  this.computeMinDistance();
  return this._minDistance;
};
DistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines(lines0, lines1, locGeom) {
  var this$1 = this;
  for (var i = 0; i < lines0.size(); i++) {
    var line0 = lines0.get(i);
    for (var j = 0; j < lines1.size(); j++) {
      var line1 = lines1.get(j);
      this$1.computeMinDistance(line0, line1, locGeom);
      if (this$1._minDistance <= this$1._terminateDistance) {
        return null;
      }
    }
  }
};
DistanceOp.prototype.interfaces_ = function interfaces_126() {
  return [];
};
DistanceOp.prototype.getClass = function getClass125() {
  return DistanceOp;
};
DistanceOp.distance = function distance8(g0, g1) {
  var distOp = new DistanceOp(g0, g1);
  return distOp.distance();
};
DistanceOp.isWithinDistance = function isWithinDistance(g0, g1, distance11) {
  var distOp = new DistanceOp(g0, g1, distance11);
  return distOp.distance() <= distance11;
};
DistanceOp.nearestPoints = function nearestPoints2(g0, g1) {
  var distOp = new DistanceOp(g0, g1);
  return distOp.nearestPoints();
};
var PointPairDistance$2 = function PointPairDistance3() {
  this._pt = [new Coordinate(), new Coordinate()];
  this._distance = Double.NaN;
  this._isNull = true;
};
PointPairDistance$2.prototype.getCoordinates = function getCoordinates8() {
  return this._pt;
};
PointPairDistance$2.prototype.getCoordinate = function getCoordinate16(i) {
  return this._pt[i];
};
PointPairDistance$2.prototype.setMinimum = function setMinimum2() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist = p0.distance(p1);
    if (dist < this._distance) {
      this.initialize(p0, p1, dist);
    }
  }
};
PointPairDistance$2.prototype.initialize = function initialize2() {
  if (arguments.length === 0) {
    this._isNull = true;
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    this._pt[0].setCoordinate(p0);
    this._pt[1].setCoordinate(p1);
    this._distance = p0.distance(p1);
    this._isNull = false;
  } else if (arguments.length === 3) {
    var p0$1 = arguments[0];
    var p1$1 = arguments[1];
    var distance11 = arguments[2];
    this._pt[0].setCoordinate(p0$1);
    this._pt[1].setCoordinate(p1$1);
    this._distance = distance11;
    this._isNull = false;
  }
};
PointPairDistance$2.prototype.toString = function toString21() {
  return WKTWriter.toLineString(this._pt[0], this._pt[1]);
};
PointPairDistance$2.prototype.getDistance = function getDistance4() {
  return this._distance;
};
PointPairDistance$2.prototype.setMaximum = function setMaximum2() {
  if (arguments.length === 1) {
    var ptDist = arguments[0];
    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
  } else if (arguments.length === 2) {
    var p0 = arguments[0];
    var p1 = arguments[1];
    if (this._isNull) {
      this.initialize(p0, p1);
      return null;
    }
    var dist = p0.distance(p1);
    if (dist > this._distance) {
      this.initialize(p0, p1, dist);
    }
  }
};
PointPairDistance$2.prototype.interfaces_ = function interfaces_127() {
  return [];
};
PointPairDistance$2.prototype.getClass = function getClass126() {
  return PointPairDistance$2;
};
var DistanceToPoint = function DistanceToPoint2() {
};
DistanceToPoint.prototype.interfaces_ = function interfaces_128() {
  return [];
};
DistanceToPoint.prototype.getClass = function getClass127() {
  return DistanceToPoint;
};
DistanceToPoint.computeDistance = function computeDistance2() {
  if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString2 && arguments[1] instanceof Coordinate)) {
    var line = arguments[0];
    var pt = arguments[1];
    var ptDist = arguments[2];
    var tempSegment = new LineSegment();
    var coords = line.getCoordinates();
    for (var i = 0; i < coords.length - 1; i++) {
      tempSegment.setCoordinates(coords[i], coords[i + 1]);
      var closestPt = tempSegment.closestPoint(pt);
      ptDist.setMinimum(closestPt, pt);
    }
  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {
    var poly = arguments[0];
    var pt$1 = arguments[1];
    var ptDist$1 = arguments[2];
    DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);
    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {
      DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);
    }
  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {
    var geom = arguments[0];
    var pt$2 = arguments[1];
    var ptDist$2 = arguments[2];
    if (geom instanceof LineString2) {
      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof Polygon) {
      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);
    } else if (geom instanceof GeometryCollection) {
      var gc = geom;
      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {
        var g = gc.getGeometryN(i$2);
        DistanceToPoint.computeDistance(g, pt$2, ptDist$2);
      }
    } else {
      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);
    }
  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {
    var segment = arguments[0];
    var pt$3 = arguments[1];
    var ptDist$3 = arguments[2];
    var closestPt$1 = segment.closestPoint(pt$3);
    ptDist$3.setMinimum(closestPt$1, pt$3);
  }
};
var DiscreteHausdorffDistance = function DiscreteHausdorffDistance2() {
  this._g0 = null;
  this._g1 = null;
  this._ptDist = new PointPairDistance$2();
  this._densifyFrac = 0;
  var g0 = arguments[0];
  var g1 = arguments[1];
  this._g0 = g0;
  this._g1 = g1;
};
var staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
DiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates9() {
  return this._ptDist.getCoordinates();
};
DiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction(densifyFrac) {
  if (densifyFrac > 1 || densifyFrac <= 0) {
    throw new IllegalArgumentException("Fraction is not in range (0.0 - 1.0]");
  }
  this._densifyFrac = densifyFrac;
};
DiscreteHausdorffDistance.prototype.compute = function compute(g0, g1) {
  this.computeOrientedDistance(g0, g1, this._ptDist);
  this.computeOrientedDistance(g1, g0, this._ptDist);
};
DiscreteHausdorffDistance.prototype.distance = function distance9() {
  this.compute(this._g0, this._g1);
  return this._ptDist.getDistance();
};
DiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance(discreteGeom, geom, ptDist) {
  var distFilter = new MaxPointDistanceFilter$1(geom);
  discreteGeom.apply(distFilter);
  ptDist.setMaximum(distFilter.getMaxPointDistance());
  if (this._densifyFrac > 0) {
    var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);
    discreteGeom.apply(fracFilter);
    ptDist.setMaximum(fracFilter.getMaxPointDistance());
  }
};
DiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance() {
  this.computeOrientedDistance(this._g0, this._g1, this._ptDist);
  return this._ptDist.getDistance();
};
DiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_129() {
  return [];
};
DiscreteHausdorffDistance.prototype.getClass = function getClass128() {
  return DiscreteHausdorffDistance;
};
DiscreteHausdorffDistance.distance = function distance10() {
  if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    var dist = new DiscreteHausdorffDistance(g0, g1);
    return dist.distance();
  } else if (arguments.length === 3) {
    var g0$1 = arguments[0];
    var g1$1 = arguments[1];
    var densifyFrac = arguments[2];
    var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);
    dist$1.setDensifyFraction(densifyFrac);
    return dist$1.distance();
  }
};
staticAccessors$39.MaxPointDistanceFilter.get = function() {
  return MaxPointDistanceFilter$1;
};
staticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function() {
  return MaxDensifiedByFractionDistanceFilter;
};
Object.defineProperties(DiscreteHausdorffDistance, staticAccessors$39);
var MaxPointDistanceFilter$1 = function MaxPointDistanceFilter3() {
  this._maxPtDist = new PointPairDistance$2();
  this._minPtDist = new PointPairDistance$2();
  this._euclideanDist = new DistanceToPoint();
  this._geom = null;
  var geom = arguments[0];
  this._geom = geom;
};
MaxPointDistanceFilter$1.prototype.filter = function filter12(pt) {
  this._minPtDist.initialize();
  DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
  this._maxPtDist.setMaximum(this._minPtDist);
};
MaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance3() {
  return this._maxPtDist;
};
MaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_130() {
  return [CoordinateFilter];
};
MaxPointDistanceFilter$1.prototype.getClass = function getClass129() {
  return MaxPointDistanceFilter$1;
};
var MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter2() {
  this._maxPtDist = new PointPairDistance$2();
  this._minPtDist = new PointPairDistance$2();
  this._geom = null;
  this._numSubSegs = 0;
  var geom = arguments[0];
  var fraction = arguments[1];
  this._geom = geom;
  this._numSubSegs = Math.trunc(Math.round(1 / fraction));
};
MaxDensifiedByFractionDistanceFilter.prototype.filter = function filter13(seq, index2) {
  var this$1 = this;
  if (index2 === 0) {
    return null;
  }
  var p0 = seq.getCoordinate(index2 - 1);
  var p1 = seq.getCoordinate(index2);
  var delx = (p1.x - p0.x) / this._numSubSegs;
  var dely = (p1.y - p0.y) / this._numSubSegs;
  for (var i = 0; i < this._numSubSegs; i++) {
    var x2 = p0.x + i * delx;
    var y2 = p0.y + i * dely;
    var pt = new Coordinate(x2, y2);
    this$1._minPtDist.initialize();
    DistanceToPoint.computeDistance(this$1._geom, pt, this$1._minPtDist);
    this$1._maxPtDist.setMaximum(this$1._minPtDist);
  }
};
MaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone6() {
  return false;
};
MaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged3() {
  return false;
};
MaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance4() {
  return this._maxPtDist;
};
MaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_131() {
  return [CoordinateSequenceFilter];
};
MaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass130() {
  return MaxDensifiedByFractionDistanceFilter;
};
var BufferDistanceValidator = function BufferDistanceValidator2(input, bufDistance, result) {
  this._minValidDistance = null;
  this._maxValidDistance = null;
  this._minDistanceFound = null;
  this._maxDistanceFound = null;
  this._isValid = true;
  this._errMsg = null;
  this._errorLocation = null;
  this._errorIndicator = null;
  this._input = input || null;
  this._bufDistance = bufDistance || null;
  this._result = result || null;
};
var staticAccessors$37 = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
BufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance(input, bufCurve, maxDist) {
  var haus = new DiscreteHausdorffDistance(bufCurve, input);
  haus.setDensifyFraction(0.25);
  this._maxDistanceFound = haus.orientedDistance();
  if (this._maxDistanceFound > maxDist) {
    this._isValid = false;
    var pts = haus.getCoordinates();
    this._errorLocation = pts[1];
    this._errorIndicator = input.getFactory().createLineString(pts);
    this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + WKTWriter.toLineString(pts[0], pts[1]) + ")";
  }
};
BufferDistanceValidator.prototype.isValid = function isValid() {
  var posDistance = Math.abs(this._bufDistance);
  var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;
  this._minValidDistance = posDistance - distDelta;
  this._maxValidDistance = posDistance + distDelta;
  if (this._input.isEmpty() || this._result.isEmpty()) {
    return true;
  }
  if (this._bufDistance > 0) {
    this.checkPositiveValid();
  } else {
    this.checkNegativeValid();
  }
  if (BufferDistanceValidator.VERBOSE) {
    System.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1));
  }
  return this._isValid;
};
BufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid() {
  if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {
    return null;
  }
  var inputCurve = this.getPolygonLines(this._input);
  this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);
  if (!this._isValid) {
    return null;
  }
  this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);
};
BufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator() {
  return this._errorIndicator;
};
BufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance(g1, g2, minDist) {
  var distOp = new DistanceOp(g1, g2, minDist);
  this._minDistanceFound = distOp.distance();
  if (this._minDistanceFound < minDist) {
    this._isValid = false;
    var pts = distOp.nearestPoints();
    this._errorLocation = distOp.nearestPoints()[1];
    this._errorIndicator = g1.getFactory().createLineString(pts);
    this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + WKTWriter.toLineString(pts[0], pts[1]) + " )";
  }
};
BufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid() {
  var bufCurve = this._result.getBoundary();
  this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);
  if (!this._isValid) {
    return null;
  }
  this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);
};
BufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation() {
  return this._errorLocation;
};
BufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines(g) {
  var lines = new ArrayList();
  var lineExtracter = new LinearComponentExtracter(lines);
  var polys = PolygonExtracter.getPolygons(g);
  for (var i = polys.iterator(); i.hasNext(); ) {
    var poly = i.next();
    poly.apply(lineExtracter);
  }
  return g.getFactory().buildGeometry(lines);
};
BufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage() {
  return this._errMsg;
};
BufferDistanceValidator.prototype.interfaces_ = function interfaces_132() {
  return [];
};
BufferDistanceValidator.prototype.getClass = function getClass131() {
  return BufferDistanceValidator;
};
staticAccessors$37.VERBOSE.get = function() {
  return false;
};
staticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(BufferDistanceValidator, staticAccessors$37);
var BufferResultValidator = function BufferResultValidator2(input, distance11, result) {
  this._isValid = true;
  this._errorMsg = null;
  this._errorLocation = null;
  this._errorIndicator = null;
  this._input = input || null;
  this._distance = distance11 || null;
  this._result = result || null;
};
var staticAccessors$40 = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
BufferResultValidator.prototype.isValid = function isValid2() {
  this.checkPolygonal();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkExpectedEmpty();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkEnvelope();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkArea();
  if (!this._isValid) {
    return this._isValid;
  }
  this.checkDistance();
  return this._isValid;
};
BufferResultValidator.prototype.checkEnvelope = function checkEnvelope() {
  if (this._distance < 0) {
    return null;
  }
  var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;
  if (padding === 0) {
    padding = 1e-3;
  }
  var expectedEnv = new Envelope(this._input.getEnvelopeInternal());
  expectedEnv.expandBy(this._distance);
  var bufEnv = new Envelope(this._result.getEnvelopeInternal());
  bufEnv.expandBy(padding);
  if (!bufEnv.contains(expectedEnv)) {
    this._isValid = false;
    this._errorMsg = "Buffer envelope is incorrect";
    this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);
  }
  this.report("Envelope");
};
BufferResultValidator.prototype.checkDistance = function checkDistance() {
  var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);
  if (!distValid.isValid()) {
    this._isValid = false;
    this._errorMsg = distValid.getErrorMessage();
    this._errorLocation = distValid.getErrorLocation();
    this._errorIndicator = distValid.getErrorIndicator();
  }
  this.report("Distance");
};
BufferResultValidator.prototype.checkArea = function checkArea() {
  var inputArea = this._input.getArea();
  var resultArea = this._result.getArea();
  if (this._distance > 0 && inputArea > resultArea) {
    this._isValid = false;
    this._errorMsg = "Area of positive buffer is smaller than input";
    this._errorIndicator = this._result;
  }
  if (this._distance < 0 && inputArea < resultArea) {
    this._isValid = false;
    this._errorMsg = "Area of negative buffer is larger than input";
    this._errorIndicator = this._result;
  }
  this.report("Area");
};
BufferResultValidator.prototype.checkPolygonal = function checkPolygonal() {
  if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) {
    this._isValid = false;
  }
  this._errorMsg = "Result is not polygonal";
  this._errorIndicator = this._result;
  this.report("Polygonal");
};
BufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator2() {
  return this._errorIndicator;
};
BufferResultValidator.prototype.getErrorLocation = function getErrorLocation2() {
  return this._errorLocation;
};
BufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty() {
  if (this._input.getDimension() >= 2) {
    return null;
  }
  if (this._distance > 0) {
    return null;
  }
  if (!this._result.isEmpty()) {
    this._isValid = false;
    this._errorMsg = "Result is non-empty";
    this._errorIndicator = this._result;
  }
  this.report("ExpectedEmpty");
};
BufferResultValidator.prototype.report = function report(checkName) {
  if (!BufferResultValidator.VERBOSE) {
    return null;
  }
  System.out.println("Check " + checkName + ": " + (this._isValid ? "passed" : "FAILED"));
};
BufferResultValidator.prototype.getErrorMessage = function getErrorMessage2() {
  return this._errorMsg;
};
BufferResultValidator.prototype.interfaces_ = function interfaces_133() {
  return [];
};
BufferResultValidator.prototype.getClass = function getClass132() {
  return BufferResultValidator;
};
BufferResultValidator.isValidMsg = function isValidMsg(g, distance11, result) {
  var validator = new BufferResultValidator(g, distance11, result);
  if (!validator.isValid()) {
    return validator.getErrorMessage();
  }
  return null;
};
BufferResultValidator.isValid = function isValid3(g, distance11, result) {
  var validator = new BufferResultValidator(g, distance11, result);
  if (validator.isValid()) {
    return true;
  }
  return false;
};
staticAccessors$40.VERBOSE.get = function() {
  return false;
};
staticAccessors$40.MAX_ENV_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(BufferResultValidator, staticAccessors$40);
var BasicSegmentString = function BasicSegmentString2() {
  this._pts = null;
  this._data = null;
  var pts = arguments[0];
  var data = arguments[1];
  this._pts = pts;
  this._data = data;
};
BasicSegmentString.prototype.getCoordinates = function getCoordinates10() {
  return this._pts;
};
BasicSegmentString.prototype.size = function size10() {
  return this._pts.length;
};
BasicSegmentString.prototype.getCoordinate = function getCoordinate17(i) {
  return this._pts[i];
};
BasicSegmentString.prototype.isClosed = function isClosed3() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
BasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant2(index2) {
  if (index2 === this._pts.length - 1) {
    return -1;
  }
  return Octant.octant(this.getCoordinate(index2), this.getCoordinate(index2 + 1));
};
BasicSegmentString.prototype.setData = function setData3(data) {
  this._data = data;
};
BasicSegmentString.prototype.getData = function getData3() {
  return this._data;
};
BasicSegmentString.prototype.toString = function toString22() {
  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
};
BasicSegmentString.prototype.interfaces_ = function interfaces_134() {
  return [SegmentString];
};
BasicSegmentString.prototype.getClass = function getClass133() {
  return BasicSegmentString;
};
var InteriorIntersectionFinder = function InteriorIntersectionFinder2() {
  this._findAllIntersections = false;
  this._isCheckEndSegmentsOnly = false;
  this._li = null;
  this._interiorIntersection = null;
  this._intSegments = null;
  this._intersections = new ArrayList();
  this._intersectionCount = 0;
  this._keepIntersections = true;
  var li = arguments[0];
  this._li = li;
  this._interiorIntersection = null;
};
InteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection() {
  return this._interiorIntersection;
};
InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
  this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
};
InteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments() {
  return this._intSegments;
};
InteriorIntersectionFinder.prototype.count = function count() {
  return this._intersectionCount;
};
InteriorIntersectionFinder.prototype.getIntersections = function getIntersections() {
  return this._intersections;
};
InteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {
  this._findAllIntersections = findAllIntersections;
};
InteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections(keepIntersections) {
  this._keepIntersections = keepIntersections;
};
InteriorIntersectionFinder.prototype.processIntersections = function processIntersections4(e0, segIndex0, e1, segIndex1) {
  if (!this._findAllIntersections && this.hasIntersection()) {
    return null;
  }
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  if (this._isCheckEndSegmentsOnly) {
    var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
    if (!isEndSegPresent) {
      return null;
    }
  }
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    if (this._li.isInteriorIntersection()) {
      this._intSegments = new Array(4).fill(null);
      this._intSegments[0] = p002;
      this._intSegments[1] = p012;
      this._intSegments[2] = p102;
      this._intSegments[3] = p112;
      this._interiorIntersection = this._li.getIntersection(0);
      if (this._keepIntersections) {
        this._intersections.add(this._interiorIntersection);
      }
      this._intersectionCount++;
    }
  }
};
InteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment(segStr, index2) {
  if (index2 === 0) {
    return true;
  }
  if (index2 >= segStr.size() - 2) {
    return true;
  }
  return false;
};
InteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection3() {
  return this._interiorIntersection !== null;
};
InteriorIntersectionFinder.prototype.isDone = function isDone7() {
  if (this._findAllIntersections) {
    return false;
  }
  return this._interiorIntersection !== null;
};
InteriorIntersectionFinder.prototype.interfaces_ = function interfaces_135() {
  return [SegmentIntersector];
};
InteriorIntersectionFinder.prototype.getClass = function getClass134() {
  return InteriorIntersectionFinder;
};
InteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder(li) {
  var finder = new InteriorIntersectionFinder(li);
  finder.setFindAllIntersections(true);
  return finder;
};
InteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder(li) {
  return new InteriorIntersectionFinder(li);
};
InteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter(li) {
  var finder = new InteriorIntersectionFinder(li);
  finder.setFindAllIntersections(true);
  finder.setKeepIntersections(false);
  return finder;
};
var FastNodingValidator = function FastNodingValidator2() {
  this._li = new RobustLineIntersector();
  this._segStrings = null;
  this._findAllIntersections = false;
  this._segInt = null;
  this._isValid = true;
  var segStrings = arguments[0];
  this._segStrings = segStrings;
};
FastNodingValidator.prototype.execute = function execute() {
  if (this._segInt !== null) {
    return null;
  }
  this.checkInteriorIntersections();
};
FastNodingValidator.prototype.getIntersections = function getIntersections2() {
  return this._segInt.getIntersections();
};
FastNodingValidator.prototype.isValid = function isValid4() {
  this.execute();
  return this._isValid;
};
FastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections2(findAllIntersections) {
  this._findAllIntersections = findAllIntersections;
};
FastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections2() {
  this._isValid = true;
  this._segInt = new InteriorIntersectionFinder(this._li);
  this._segInt.setFindAllIntersections(this._findAllIntersections);
  var noder = new MCIndexNoder();
  noder.setSegmentIntersector(this._segInt);
  noder.computeNodes(this._segStrings);
  if (this._segInt.hasIntersection()) {
    this._isValid = false;
    return null;
  }
};
FastNodingValidator.prototype.checkValid = function checkValid2() {
  this.execute();
  if (!this._isValid) {
    throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());
  }
};
FastNodingValidator.prototype.getErrorMessage = function getErrorMessage3() {
  if (this._isValid) {
    return "no intersections found";
  }
  var intSegs = this._segInt.getIntersectionSegments();
  return "found non-noded intersection between " + WKTWriter.toLineString(intSegs[0], intSegs[1]) + " and " + WKTWriter.toLineString(intSegs[2], intSegs[3]);
};
FastNodingValidator.prototype.interfaces_ = function interfaces_136() {
  return [];
};
FastNodingValidator.prototype.getClass = function getClass135() {
  return FastNodingValidator;
};
FastNodingValidator.computeIntersections = function computeIntersections(segStrings) {
  var nv = new FastNodingValidator(segStrings);
  nv.setFindAllIntersections(true);
  nv.isValid();
  return nv.getIntersections();
};
var EdgeNodingValidator = function EdgeNodingValidator2() {
  this._nv = null;
  var edges2 = arguments[0];
  this._nv = new FastNodingValidator(EdgeNodingValidator2.toSegmentStrings(edges2));
};
EdgeNodingValidator.prototype.checkValid = function checkValid3() {
  this._nv.checkValid();
};
EdgeNodingValidator.prototype.interfaces_ = function interfaces_137() {
  return [];
};
EdgeNodingValidator.prototype.getClass = function getClass136() {
  return EdgeNodingValidator;
};
EdgeNodingValidator.toSegmentStrings = function toSegmentStrings(edges2) {
  var segStrings = new ArrayList();
  for (var i = edges2.iterator(); i.hasNext(); ) {
    var e = i.next();
    segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
  }
  return segStrings;
};
EdgeNodingValidator.checkValid = function checkValid4(edges2) {
  var validator = new EdgeNodingValidator(edges2);
  validator.checkValid();
};
var GeometryCollectionMapper = function GeometryCollectionMapper2(mapOp) {
  this._mapOp = mapOp;
};
GeometryCollectionMapper.prototype.map = function map(gc) {
  var this$1 = this;
  var mapped = new ArrayList();
  for (var i = 0; i < gc.getNumGeometries(); i++) {
    var g = this$1._mapOp.map(gc.getGeometryN(i));
    if (!g.isEmpty()) {
      mapped.add(g);
    }
  }
  return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));
};
GeometryCollectionMapper.prototype.interfaces_ = function interfaces_138() {
  return [];
};
GeometryCollectionMapper.prototype.getClass = function getClass137() {
  return GeometryCollectionMapper;
};
GeometryCollectionMapper.map = function map2(gc, op) {
  var mapper = new GeometryCollectionMapper(op);
  return mapper.map(gc);
};
var LineBuilder = function LineBuilder2() {
  this._op = null;
  this._geometryFactory = null;
  this._ptLocator = null;
  this._lineEdgesList = new ArrayList();
  this._resultLineList = new ArrayList();
  var op = arguments[0];
  var geometryFactory = arguments[1];
  var ptLocator = arguments[2];
  this._op = op;
  this._geometryFactory = geometryFactory;
  this._ptLocator = ptLocator;
};
LineBuilder.prototype.collectLines = function collectLines(opCode) {
  var this$1 = this;
  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
    var de = it.next();
    this$1.collectLineEdge(de, opCode, this$1._lineEdgesList);
    this$1.collectBoundaryTouchEdge(de, opCode, this$1._lineEdgesList);
  }
};
LineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine(e, targetIndex) {
  var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
  e.getLabel().setLocation(targetIndex, loc);
};
LineBuilder.prototype.build = function build2(opCode) {
  this.findCoveredLineEdges();
  this.collectLines(opCode);
  this.buildLines(opCode);
  return this._resultLineList;
};
LineBuilder.prototype.collectLineEdge = function collectLineEdge(de, opCode, edges2) {
  var label = de.getLabel();
  var e = de.getEdge();
  if (de.isLineEdge()) {
    if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {
      edges2.add(e);
      de.setVisitedEdge(true);
    }
  }
};
LineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges() {
  var this$1 = this;
  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
    var node = nodeit.next();
    node.getEdges().findCoveredLineEdges();
  }
  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {
    var de = it.next();
    var e = de.getEdge();
    if (de.isLineEdge() && !e.isCoveredSet()) {
      var isCovered2 = this$1._op.isCoveredByA(de.getCoordinate());
      e.setCovered(isCovered2);
    }
  }
};
LineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines(edgesList) {
  var this$1 = this;
  for (var it = edgesList.iterator(); it.hasNext(); ) {
    var e = it.next();
    var label = e.getLabel();
    if (e.isIsolated()) {
      if (label.isNull(0)) {
        this$1.labelIsolatedLine(e, 0);
      } else {
        this$1.labelIsolatedLine(e, 1);
      }
    }
  }
};
LineBuilder.prototype.buildLines = function buildLines(opCode) {
  var this$1 = this;
  for (var it = this._lineEdgesList.iterator(); it.hasNext(); ) {
    var e = it.next();
    var line = this$1._geometryFactory.createLineString(e.getCoordinates());
    this$1._resultLineList.add(line);
    e.setInResult(true);
  }
};
LineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge(de, opCode, edges2) {
  var label = de.getLabel();
  if (de.isLineEdge()) {
    return null;
  }
  if (de.isVisited()) {
    return null;
  }
  if (de.isInteriorAreaEdge()) {
    return null;
  }
  if (de.getEdge().isInResult()) {
    return null;
  }
  Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
  if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
    edges2.add(de.getEdge());
    de.setVisitedEdge(true);
  }
};
LineBuilder.prototype.interfaces_ = function interfaces_139() {
  return [];
};
LineBuilder.prototype.getClass = function getClass138() {
  return LineBuilder;
};
var PointBuilder = function PointBuilder2() {
  this._op = null;
  this._geometryFactory = null;
  this._resultPointList = new ArrayList();
  var op = arguments[0];
  var geometryFactory = arguments[1];
  this._op = op;
  this._geometryFactory = geometryFactory;
};
PointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint(n) {
  var coord = n.getCoordinate();
  if (!this._op.isCoveredByLA(coord)) {
    var pt = this._geometryFactory.createPoint(coord);
    this._resultPointList.add(pt);
  }
};
PointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes(opCode) {
  var this$1 = this;
  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {
    var n = nodeit.next();
    if (n.isInResult()) {
      continue;
    }
    if (n.isIncidentEdgeInResult()) {
      continue;
    }
    if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
      var label = n.getLabel();
      if (OverlayOp.isResultOfOp(label, opCode)) {
        this$1.filterCoveredNodeToPoint(n);
      }
    }
  }
};
PointBuilder.prototype.build = function build3(opCode) {
  this.extractNonCoveredResultNodes(opCode);
  return this._resultPointList;
};
PointBuilder.prototype.interfaces_ = function interfaces_140() {
  return [];
};
PointBuilder.prototype.getClass = function getClass139() {
  return PointBuilder;
};
var GeometryTransformer = function GeometryTransformer2() {
  this._inputGeom = null;
  this._factory = null;
  this._pruneEmptyGeometry = true;
  this._preserveGeometryCollectionType = true;
  this._preserveCollections = false;
  this._preserveType = false;
};
GeometryTransformer.prototype.transformPoint = function transformPoint(geom, parent) {
  return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
};
GeometryTransformer.prototype.transformPolygon = function transformPolygon(geom, parent) {
  var this$1 = this;
  var isAllValidLinearRings = true;
  var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
  if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) {
    isAllValidLinearRings = false;
  }
  var holes = new ArrayList();
  for (var i = 0; i < geom.getNumInteriorRing(); i++) {
    var hole = this$1.transformLinearRing(geom.getInteriorRingN(i), geom);
    if (hole === null || hole.isEmpty()) {
      continue;
    }
    if (!(hole instanceof LinearRing)) {
      isAllValidLinearRings = false;
    }
    holes.add(hole);
  }
  if (isAllValidLinearRings) {
    return this._factory.createPolygon(shell, holes.toArray([]));
  } else {
    var components = new ArrayList();
    if (shell !== null) {
      components.add(shell);
    }
    components.addAll(holes);
    return this._factory.buildGeometry(components);
  }
};
GeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence(coords) {
  return this._factory.getCoordinateSequenceFactory().create(coords);
};
GeometryTransformer.prototype.getInputGeometry = function getInputGeometry() {
  return this._inputGeom;
};
GeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString(geom, parent) {
  var this$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1.transformLineString(geom.getGeometryN(i), geom);
    if (transformGeom === null) {
      continue;
    }
    if (transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.transformCoordinates = function transformCoordinates(coords, parent) {
  return this.copy(coords);
};
GeometryTransformer.prototype.transformLineString = function transformLineString(geom, parent) {
  return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
};
GeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint(geom, parent) {
  var this$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1.transformPoint(geom.getGeometryN(i), geom);
    if (transformGeom === null) {
      continue;
    }
    if (transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon(geom, parent) {
  var this$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1.transformPolygon(geom.getGeometryN(i), geom);
    if (transformGeom === null) {
      continue;
    }
    if (transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.copy = function copy6(seq) {
  return seq.copy();
};
GeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection(geom, parent) {
  var this$1 = this;
  var transGeomList = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var transformGeom = this$1.transform(geom.getGeometryN(i));
    if (transformGeom === null) {
      continue;
    }
    if (this$1._pruneEmptyGeometry && transformGeom.isEmpty()) {
      continue;
    }
    transGeomList.add(transformGeom);
  }
  if (this._preserveGeometryCollectionType) {
    return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));
  }
  return this._factory.buildGeometry(transGeomList);
};
GeometryTransformer.prototype.transform = function transform(inputGeom) {
  this._inputGeom = inputGeom;
  this._factory = inputGeom.getFactory();
  if (inputGeom instanceof Point) {
    return this.transformPoint(inputGeom, null);
  }
  if (inputGeom instanceof MultiPoint) {
    return this.transformMultiPoint(inputGeom, null);
  }
  if (inputGeom instanceof LinearRing) {
    return this.transformLinearRing(inputGeom, null);
  }
  if (inputGeom instanceof LineString2) {
    return this.transformLineString(inputGeom, null);
  }
  if (inputGeom instanceof MultiLineString) {
    return this.transformMultiLineString(inputGeom, null);
  }
  if (inputGeom instanceof Polygon) {
    return this.transformPolygon(inputGeom, null);
  }
  if (inputGeom instanceof MultiPolygon) {
    return this.transformMultiPolygon(inputGeom, null);
  }
  if (inputGeom instanceof GeometryCollection) {
    return this.transformGeometryCollection(inputGeom, null);
  }
  throw new IllegalArgumentException("Unknown Geometry subtype: " + inputGeom.getClass().getName());
};
GeometryTransformer.prototype.transformLinearRing = function transformLinearRing(geom, parent) {
  var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
  if (seq === null) {
    return this._factory.createLinearRing(null);
  }
  var seqSize = seq.size();
  if (seqSize > 0 && seqSize < 4 && !this._preserveType) {
    return this._factory.createLineString(seq);
  }
  return this._factory.createLinearRing(seq);
};
GeometryTransformer.prototype.interfaces_ = function interfaces_141() {
  return [];
};
GeometryTransformer.prototype.getClass = function getClass140() {
  return GeometryTransformer;
};
var LineStringSnapper = function LineStringSnapper2() {
  this._snapTolerance = 0;
  this._srcPts = null;
  this._seg = new LineSegment();
  this._allowSnappingToSourceVertices = false;
  this._isClosed = false;
  if (arguments[0] instanceof LineString2 && typeof arguments[1] === "number") {
    var srcLine = arguments[0];
    var snapTolerance = arguments[1];
    LineStringSnapper2.call(this, srcLine.getCoordinates(), snapTolerance);
  } else if (arguments[0] instanceof Array && typeof arguments[1] === "number") {
    var srcPts = arguments[0];
    var snapTolerance$1 = arguments[1];
    this._srcPts = srcPts;
    this._isClosed = LineStringSnapper2.isClosed(srcPts);
    this._snapTolerance = snapTolerance$1;
  }
};
LineStringSnapper.prototype.snapVertices = function snapVertices(srcCoords, snapPts) {
  var this$1 = this;
  var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
  for (var i = 0; i < end; i++) {
    var srcPt = srcCoords.get(i);
    var snapVert = this$1.findSnapForVertex(srcPt, snapPts);
    if (snapVert !== null) {
      srcCoords.set(i, new Coordinate(snapVert));
      if (i === 0 && this$1._isClosed) {
        srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));
      }
    }
  }
};
LineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex(pt, snapPts) {
  var this$1 = this;
  for (var i = 0; i < snapPts.length; i++) {
    if (pt.equals2D(snapPts[i])) {
      return null;
    }
    if (pt.distance(snapPts[i]) < this$1._snapTolerance) {
      return snapPts[i];
    }
  }
  return null;
};
LineStringSnapper.prototype.snapTo = function snapTo(snapPts) {
  var coordList = new CoordinateList(this._srcPts);
  this.snapVertices(coordList, snapPts);
  this.snapSegments(coordList, snapPts);
  var newPts = coordList.toCoordinateArray();
  return newPts;
};
LineStringSnapper.prototype.snapSegments = function snapSegments(srcCoords, snapPts) {
  var this$1 = this;
  if (snapPts.length === 0) {
    return null;
  }
  var distinctPtCount = snapPts.length;
  if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) {
    distinctPtCount = snapPts.length - 1;
  }
  for (var i = 0; i < distinctPtCount; i++) {
    var snapPt = snapPts[i];
    var index2 = this$1.findSegmentIndexToSnap(snapPt, srcCoords);
    if (index2 >= 0) {
      srcCoords.add(index2 + 1, new Coordinate(snapPt), false);
    }
  }
};
LineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap(snapPt, srcCoords) {
  var this$1 = this;
  var minDist = Double.MAX_VALUE;
  var snapIndex = -1;
  for (var i = 0; i < srcCoords.size() - 1; i++) {
    this$1._seg.p0 = srcCoords.get(i);
    this$1._seg.p1 = srcCoords.get(i + 1);
    if (this$1._seg.p0.equals2D(snapPt) || this$1._seg.p1.equals2D(snapPt)) {
      if (this$1._allowSnappingToSourceVertices) {
        continue;
      } else {
        return -1;
      }
    }
    var dist = this$1._seg.distance(snapPt);
    if (dist < this$1._snapTolerance && dist < minDist) {
      minDist = dist;
      snapIndex = i;
    }
  }
  return snapIndex;
};
LineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
  this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
};
LineStringSnapper.prototype.interfaces_ = function interfaces_142() {
  return [];
};
LineStringSnapper.prototype.getClass = function getClass141() {
  return LineStringSnapper;
};
LineStringSnapper.isClosed = function isClosed4(pts) {
  if (pts.length <= 1) {
    return false;
  }
  return pts[0].equals2D(pts[pts.length - 1]);
};
var GeometrySnapper = function GeometrySnapper2(srcGeom) {
  this._srcGeom = srcGeom || null;
};
var staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };
GeometrySnapper.prototype.snapTo = function snapTo2(snapGeom, snapTolerance) {
  var snapPts = this.extractTargetCoordinates(snapGeom);
  var snapTrans = new SnapTransformer(snapTolerance, snapPts);
  return snapTrans.transform(this._srcGeom);
};
GeometrySnapper.prototype.snapToSelf = function snapToSelf(snapTolerance, cleanResult) {
  var snapPts = this.extractTargetCoordinates(this._srcGeom);
  var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
  var snappedGeom = snapTrans.transform(this._srcGeom);
  var result = snappedGeom;
  if (cleanResult && hasInterface(result, Polygonal)) {
    result = snappedGeom.buffer(0);
  }
  return result;
};
GeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance(ringPts) {
  var minSegLen = this.computeMinimumSegmentLength(ringPts);
  var snapTol = minSegLen / 10;
  return snapTol;
};
GeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates(g) {
  var ptSet = new TreeSet();
  var pts = g.getCoordinates();
  for (var i = 0; i < pts.length; i++) {
    ptSet.add(pts[i]);
  }
  return ptSet.toArray(new Array(0).fill(null));
};
GeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength(pts) {
  var minSegLen = Double.MAX_VALUE;
  for (var i = 0; i < pts.length - 1; i++) {
    var segLen = pts[i].distance(pts[i + 1]);
    if (segLen < minSegLen) {
      minSegLen = segLen;
    }
  }
  return minSegLen;
};
GeometrySnapper.prototype.interfaces_ = function interfaces_143() {
  return [];
};
GeometrySnapper.prototype.getClass = function getClass142() {
  return GeometrySnapper;
};
GeometrySnapper.snap = function snap2(g0, g1, snapTolerance) {
  var snapGeom = new Array(2).fill(null);
  var snapper0 = new GeometrySnapper(g0);
  snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
  var snapper1 = new GeometrySnapper(g1);
  snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
  return snapGeom;
};
GeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance() {
  if (arguments.length === 1) {
    var g = arguments[0];
    var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
    var pm = g.getPrecisionModel();
    if (pm.getType() === PrecisionModel.FIXED) {
      var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
      if (fixedSnapTol > snapTolerance) {
        snapTolerance = fixedSnapTol;
      }
    }
    return snapTolerance;
  } else if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
  }
};
GeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance(g) {
  var env = g.getEnvelopeInternal();
  var minDimension = Math.min(env.getHeight(), env.getWidth());
  var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
  return snapTol;
};
GeometrySnapper.snapToSelf = function snapToSelf2(geom, snapTolerance, cleanResult) {
  var snapper0 = new GeometrySnapper(geom);
  return snapper0.snapToSelf(snapTolerance, cleanResult);
};
staticAccessors$41.SNAP_PRECISION_FACTOR.get = function() {
  return 1e-9;
};
Object.defineProperties(GeometrySnapper, staticAccessors$41);
var SnapTransformer = function(GeometryTransformer$$1) {
  function SnapTransformer2(snapTolerance, snapPts, isSelfSnap) {
    GeometryTransformer$$1.call(this);
    this._snapTolerance = snapTolerance || null;
    this._snapPts = snapPts || null;
    this._isSelfSnap = isSelfSnap !== void 0 ? isSelfSnap : false;
  }
  if (GeometryTransformer$$1)
    SnapTransformer2.__proto__ = GeometryTransformer$$1;
  SnapTransformer2.prototype = Object.create(GeometryTransformer$$1 && GeometryTransformer$$1.prototype);
  SnapTransformer2.prototype.constructor = SnapTransformer2;
  SnapTransformer2.prototype.snapLine = function snapLine(srcPts, snapPts) {
    var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
    snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
    return snapper.snapTo(snapPts);
  };
  SnapTransformer2.prototype.transformCoordinates = function transformCoordinates2(coords, parent) {
    var srcPts = coords.toCoordinateArray();
    var newPts = this.snapLine(srcPts, this._snapPts);
    return this._factory.getCoordinateSequenceFactory().create(newPts);
  };
  SnapTransformer2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  SnapTransformer2.prototype.getClass = function getClass169() {
    return SnapTransformer2;
  };
  return SnapTransformer2;
}(GeometryTransformer);
var CommonBits = function CommonBits2() {
  this._isFirst = true;
  this._commonMantissaBitsCount = 53;
  this._commonBits = 0;
  this._commonSignExp = null;
};
CommonBits.prototype.getCommon = function getCommon() {
  return Double.longBitsToDouble(this._commonBits);
};
CommonBits.prototype.add = function add14(num) {
  var numBits = Double.doubleToLongBits(num);
  if (this._isFirst) {
    this._commonBits = numBits;
    this._commonSignExp = CommonBits.signExpBits(this._commonBits);
    this._isFirst = false;
    return null;
  }
  var numSignExp = CommonBits.signExpBits(numBits);
  if (numSignExp !== this._commonSignExp) {
    this._commonBits = 0;
    return null;
  }
  this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
  this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
};
CommonBits.prototype.toString = function toString23() {
  if (arguments.length === 1) {
    var bits = arguments[0];
    var x2 = Double.longBitsToDouble(bits);
    var numStr = Double.toBinaryString(bits);
    var padStr = "0000000000000000000000000000000000000000000000000000000000000000" + numStr;
    var bitStr = padStr.substring(padStr.length - 64);
    var str = bitStr.substring(0, 1) + "  " + bitStr.substring(1, 12) + "(exp) " + bitStr.substring(12) + " [ " + x2 + " ]";
    return str;
  }
};
CommonBits.prototype.interfaces_ = function interfaces_144() {
  return [];
};
CommonBits.prototype.getClass = function getClass143() {
  return CommonBits;
};
CommonBits.getBit = function getBit(bits, i) {
  var mask2 = 1 << i;
  return (bits & mask2) !== 0 ? 1 : 0;
};
CommonBits.signExpBits = function signExpBits(num) {
  return num >> 52;
};
CommonBits.zeroLowerBits = function zeroLowerBits(bits, nBits) {
  var invMask = (1 << nBits) - 1;
  var mask2 = ~invMask;
  var zeroed = bits & mask2;
  return zeroed;
};
CommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits(num1, num2) {
  var count2 = 0;
  for (var i = 52; i >= 0; i--) {
    if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) {
      return count2;
    }
    count2++;
  }
  return 52;
};
var CommonBitsRemover = function CommonBitsRemover2() {
  this._commonCoord = null;
  this._ccFilter = new CommonCoordinateFilter();
};
var staticAccessors$42 = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
CommonBitsRemover.prototype.addCommonBits = function addCommonBits(geom) {
  var trans = new Translater(this._commonCoord);
  geom.apply(trans);
  geom.geometryChanged();
};
CommonBitsRemover.prototype.removeCommonBits = function removeCommonBits(geom) {
  if (this._commonCoord.x === 0 && this._commonCoord.y === 0) {
    return geom;
  }
  var invCoord = new Coordinate(this._commonCoord);
  invCoord.x = -invCoord.x;
  invCoord.y = -invCoord.y;
  var trans = new Translater(invCoord);
  geom.apply(trans);
  geom.geometryChanged();
  return geom;
};
CommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate() {
  return this._commonCoord;
};
CommonBitsRemover.prototype.add = function add15(geom) {
  geom.apply(this._ccFilter);
  this._commonCoord = this._ccFilter.getCommonCoordinate();
};
CommonBitsRemover.prototype.interfaces_ = function interfaces_145() {
  return [];
};
CommonBitsRemover.prototype.getClass = function getClass144() {
  return CommonBitsRemover;
};
staticAccessors$42.CommonCoordinateFilter.get = function() {
  return CommonCoordinateFilter;
};
staticAccessors$42.Translater.get = function() {
  return Translater;
};
Object.defineProperties(CommonBitsRemover, staticAccessors$42);
var CommonCoordinateFilter = function CommonCoordinateFilter2() {
  this._commonBitsX = new CommonBits();
  this._commonBitsY = new CommonBits();
};
CommonCoordinateFilter.prototype.filter = function filter14(coord) {
  this._commonBitsX.add(coord.x);
  this._commonBitsY.add(coord.y);
};
CommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate2() {
  return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
};
CommonCoordinateFilter.prototype.interfaces_ = function interfaces_146() {
  return [CoordinateFilter];
};
CommonCoordinateFilter.prototype.getClass = function getClass145() {
  return CommonCoordinateFilter;
};
var Translater = function Translater2() {
  this.trans = null;
  var trans = arguments[0];
  this.trans = trans;
};
Translater.prototype.filter = function filter15(seq, i) {
  var xp = seq.getOrdinate(i, 0) + this.trans.x;
  var yp = seq.getOrdinate(i, 1) + this.trans.y;
  seq.setOrdinate(i, 0, xp);
  seq.setOrdinate(i, 1, yp);
};
Translater.prototype.isDone = function isDone8() {
  return false;
};
Translater.prototype.isGeometryChanged = function isGeometryChanged4() {
  return true;
};
Translater.prototype.interfaces_ = function interfaces_147() {
  return [CoordinateSequenceFilter];
};
Translater.prototype.getClass = function getClass146() {
  return Translater;
};
var SnapOverlayOp = function SnapOverlayOp2(g1, g2) {
  this._geom = new Array(2).fill(null);
  this._snapTolerance = null;
  this._cbr = null;
  this._geom[0] = g1;
  this._geom[1] = g2;
  this.computeSnapTolerance();
};
SnapOverlayOp.prototype.selfSnap = function selfSnap(geom) {
  var snapper0 = new GeometrySnapper(geom);
  var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
  return snapGeom;
};
SnapOverlayOp.prototype.removeCommonBits = function removeCommonBits2(geom) {
  this._cbr = new CommonBitsRemover();
  this._cbr.add(geom[0]);
  this._cbr.add(geom[1]);
  var remGeom = new Array(2).fill(null);
  remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
  remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
  return remGeom;
};
SnapOverlayOp.prototype.prepareResult = function prepareResult(geom) {
  this._cbr.addCommonBits(geom);
  return geom;
};
SnapOverlayOp.prototype.getResultGeometry = function getResultGeometry2(opCode) {
  var prepGeom = this.snap(this._geom);
  var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
  return this.prepareResult(result);
};
SnapOverlayOp.prototype.checkValid = function checkValid5(g) {
  if (!g.isValid()) {
    System.out.println("Snapped geometry is invalid");
  }
};
SnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance2() {
  this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
};
SnapOverlayOp.prototype.snap = function snap3(geom) {
  var remGeom = this.removeCommonBits(geom);
  var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
  return snapGeom;
};
SnapOverlayOp.prototype.interfaces_ = function interfaces_148() {
  return [];
};
SnapOverlayOp.prototype.getClass = function getClass147() {
  return SnapOverlayOp;
};
SnapOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {
  var op = new SnapOverlayOp(g0, g1);
  return op.getResultGeometry(opCode);
};
SnapOverlayOp.union = function union3(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
};
SnapOverlayOp.intersection = function intersection10(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
};
SnapOverlayOp.symDifference = function symDifference(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
};
SnapOverlayOp.difference = function difference4(g0, g1) {
  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
};
var SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp2(g1, g2) {
  this._geom = new Array(2).fill(null);
  this._geom[0] = g1;
  this._geom[1] = g2;
};
SnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry3(opCode) {
  var result = null;
  var isSuccess = false;
  var savedException = null;
  try {
    result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
    var isValid7 = true;
    if (isValid7) {
      isSuccess = true;
    }
  } catch (ex) {
    if (ex instanceof RuntimeException) {
      savedException = ex;
    } else {
      throw ex;
    }
  } finally {
  }
  if (!isSuccess) {
    try {
      result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
    } catch (ex) {
      if (ex instanceof RuntimeException) {
        throw savedException;
      } else {
        throw ex;
      }
    } finally {
    }
  }
  return result;
};
SnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_149() {
  return [];
};
SnapIfNeededOverlayOp.prototype.getClass = function getClass148() {
  return SnapIfNeededOverlayOp;
};
SnapIfNeededOverlayOp.overlayOp = function overlayOp2(g0, g1, opCode) {
  var op = new SnapIfNeededOverlayOp(g0, g1);
  return op.getResultGeometry(opCode);
};
SnapIfNeededOverlayOp.union = function union4(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
};
SnapIfNeededOverlayOp.intersection = function intersection11(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
};
SnapIfNeededOverlayOp.symDifference = function symDifference2(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
};
SnapIfNeededOverlayOp.difference = function difference5(g0, g1) {
  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
};
var MonotoneChain$2 = function MonotoneChain3() {
  this.mce = null;
  this.chainIndex = null;
  var mce = arguments[0];
  var chainIndex = arguments[1];
  this.mce = mce;
  this.chainIndex = chainIndex;
};
MonotoneChain$2.prototype.computeIntersections = function computeIntersections2(mc, si) {
  this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
};
MonotoneChain$2.prototype.interfaces_ = function interfaces_150() {
  return [];
};
MonotoneChain$2.prototype.getClass = function getClass149() {
  return MonotoneChain$2;
};
var SweepLineEvent = function SweepLineEvent2() {
  this._label = null;
  this._xValue = null;
  this._eventType = null;
  this._insertEvent = null;
  this._deleteEventIndex = null;
  this._obj = null;
  if (arguments.length === 2) {
    var x2 = arguments[0];
    var insertEvent = arguments[1];
    this._eventType = SweepLineEvent2.DELETE;
    this._xValue = x2;
    this._insertEvent = insertEvent;
  } else if (arguments.length === 3) {
    var label = arguments[0];
    var x$1 = arguments[1];
    var obj = arguments[2];
    this._eventType = SweepLineEvent2.INSERT;
    this._label = label;
    this._xValue = x$1;
    this._obj = obj;
  }
};
var staticAccessors$43 = { INSERT: { configurable: true }, DELETE: { configurable: true } };
SweepLineEvent.prototype.isDelete = function isDelete() {
  return this._eventType === SweepLineEvent.DELETE;
};
SweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex(deleteEventIndex) {
  this._deleteEventIndex = deleteEventIndex;
};
SweepLineEvent.prototype.getObject = function getObject() {
  return this._obj;
};
SweepLineEvent.prototype.compareTo = function compareTo15(o) {
  var pe = o;
  if (this._xValue < pe._xValue) {
    return -1;
  }
  if (this._xValue > pe._xValue) {
    return 1;
  }
  if (this._eventType < pe._eventType) {
    return -1;
  }
  if (this._eventType > pe._eventType) {
    return 1;
  }
  return 0;
};
SweepLineEvent.prototype.getInsertEvent = function getInsertEvent() {
  return this._insertEvent;
};
SweepLineEvent.prototype.isInsert = function isInsert() {
  return this._eventType === SweepLineEvent.INSERT;
};
SweepLineEvent.prototype.isSameLabel = function isSameLabel(ev) {
  if (this._label === null) {
    return false;
  }
  return this._label === ev._label;
};
SweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex() {
  return this._deleteEventIndex;
};
SweepLineEvent.prototype.interfaces_ = function interfaces_151() {
  return [Comparable];
};
SweepLineEvent.prototype.getClass = function getClass150() {
  return SweepLineEvent;
};
staticAccessors$43.INSERT.get = function() {
  return 1;
};
staticAccessors$43.DELETE.get = function() {
  return 2;
};
Object.defineProperties(SweepLineEvent, staticAccessors$43);
var EdgeSetIntersector = function EdgeSetIntersector2() {
};
EdgeSetIntersector.prototype.interfaces_ = function interfaces_152() {
  return [];
};
EdgeSetIntersector.prototype.getClass = function getClass151() {
  return EdgeSetIntersector;
};
var SegmentIntersector$2 = function SegmentIntersector3() {
  this._hasIntersection = false;
  this._hasProper = false;
  this._hasProperInterior = false;
  this._properIntersectionPoint = null;
  this._li = null;
  this._includeProper = null;
  this._recordIsolated = null;
  this._isSelfIntersection = null;
  this._numIntersections = 0;
  this.numTests = 0;
  this._bdyNodes = null;
  this._isDone = false;
  this._isDoneWhenProperInt = false;
  var li = arguments[0];
  var includeProper = arguments[1];
  var recordIsolated = arguments[2];
  this._li = li;
  this._includeProper = includeProper;
  this._recordIsolated = recordIsolated;
};
SegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection2(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1) {
    if (this._li.getIntersectionNum() === 1) {
      if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) {
        return true;
      }
      if (e0.isClosed()) {
        var maxSegIndex = e0.getNumPoints() - 1;
        if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
          return true;
        }
      }
    }
  }
  return false;
};
SegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint2() {
  return this._properIntersectionPoint;
};
SegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt(isDoneWhenProperInt) {
  this._isDoneWhenProperInt = isDoneWhenProperInt;
};
SegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection2() {
  return this._hasProperInterior;
};
SegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal(li, bdyNodes) {
  for (var i = bdyNodes.iterator(); i.hasNext(); ) {
    var node = i.next();
    var pt = node.getCoordinate();
    if (li.isIntersection(pt)) {
      return true;
    }
  }
  return false;
};
SegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection2() {
  return this._hasProper;
};
SegmentIntersector$2.prototype.hasIntersection = function hasIntersection4() {
  return this._hasIntersection;
};
SegmentIntersector$2.prototype.isDone = function isDone9() {
  return this._isDone;
};
SegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint(li, bdyNodes) {
  if (bdyNodes === null) {
    return false;
  }
  if (this.isBoundaryPointInternal(li, bdyNodes[0])) {
    return true;
  }
  if (this.isBoundaryPointInternal(li, bdyNodes[1])) {
    return true;
  }
  return false;
};
SegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes(bdyNodes0, bdyNodes1) {
  this._bdyNodes = new Array(2).fill(null);
  this._bdyNodes[0] = bdyNodes0;
  this._bdyNodes[1] = bdyNodes1;
};
SegmentIntersector$2.prototype.addIntersections = function addIntersections2(e0, segIndex0, e1, segIndex1) {
  if (e0 === e1 && segIndex0 === segIndex1) {
    return null;
  }
  this.numTests++;
  var p002 = e0.getCoordinates()[segIndex0];
  var p012 = e0.getCoordinates()[segIndex0 + 1];
  var p102 = e1.getCoordinates()[segIndex1];
  var p112 = e1.getCoordinates()[segIndex1 + 1];
  this._li.computeIntersection(p002, p012, p102, p112);
  if (this._li.hasIntersection()) {
    if (this._recordIsolated) {
      e0.setIsolated(false);
      e1.setIsolated(false);
    }
    this._numIntersections++;
    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
      this._hasIntersection = true;
      if (this._includeProper || !this._li.isProper()) {
        e0.addIntersections(this._li, segIndex0, 0);
        e1.addIntersections(this._li, segIndex1, 1);
      }
      if (this._li.isProper()) {
        this._properIntersectionPoint = this._li.getIntersection(0).copy();
        this._hasProper = true;
        if (this._isDoneWhenProperInt) {
          this._isDone = true;
        }
        if (!this.isBoundaryPoint(this._li, this._bdyNodes)) {
          this._hasProperInterior = true;
        }
      }
    }
  }
};
SegmentIntersector$2.prototype.interfaces_ = function interfaces_153() {
  return [];
};
SegmentIntersector$2.prototype.getClass = function getClass152() {
  return SegmentIntersector$2;
};
SegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments2(i1, i2) {
  return Math.abs(i1 - i2) === 1;
};
var SimpleMCSweepLineIntersector = function(EdgeSetIntersector$$1) {
  function SimpleMCSweepLineIntersector2() {
    EdgeSetIntersector$$1.call(this);
    this.events = new ArrayList();
    this.nOverlaps = null;
  }
  if (EdgeSetIntersector$$1)
    SimpleMCSweepLineIntersector2.__proto__ = EdgeSetIntersector$$1;
  SimpleMCSweepLineIntersector2.prototype = Object.create(EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype);
  SimpleMCSweepLineIntersector2.prototype.constructor = SimpleMCSweepLineIntersector2;
  SimpleMCSweepLineIntersector2.prototype.prepareEvents = function prepareEvents() {
    var this$1 = this;
    Collections.sort(this.events);
    for (var i = 0; i < this.events.size(); i++) {
      var ev = this$1.events.get(i);
      if (ev.isDelete()) {
        ev.getInsertEvent().setDeleteEventIndex(i);
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.computeIntersections = function computeIntersections3() {
    var this$1 = this;
    if (arguments.length === 1) {
      var si = arguments[0];
      this.nOverlaps = 0;
      this.prepareEvents();
      for (var i = 0; i < this.events.size(); i++) {
        var ev = this$1.events.get(i);
        if (ev.isInsert()) {
          this$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
        }
        if (si.isDone()) {
          break;
        }
      }
    } else if (arguments.length === 3) {
      if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
        var edges0 = arguments[0];
        var edges1 = arguments[1];
        var si$1 = arguments[2];
        this.addEdges(edges0, edges0);
        this.addEdges(edges1, edges1);
        this.computeIntersections(si$1);
      } else if (typeof arguments[2] === "boolean" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {
        var edges2 = arguments[0];
        var si$2 = arguments[1];
        var testAllSegments = arguments[2];
        if (testAllSegments) {
          this.addEdges(edges2, null);
        } else {
          this.addEdges(edges2);
        }
        this.computeIntersections(si$2);
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.addEdge = function addEdge(edge, edgeSet) {
    var this$1 = this;
    var mce = edge.getMonotoneChainEdge();
    var startIndex = mce.getStartIndexes();
    for (var i = 0; i < startIndex.length - 1; i++) {
      var mc = new MonotoneChain$2(mce, i);
      var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
      this$1.events.add(insertEvent);
      this$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
    }
  };
  SimpleMCSweepLineIntersector2.prototype.processOverlaps = function processOverlaps(start, end, ev0, si) {
    var this$1 = this;
    var mc0 = ev0.getObject();
    for (var i = start; i < end; i++) {
      var ev1 = this$1.events.get(i);
      if (ev1.isInsert()) {
        var mc1 = ev1.getObject();
        if (!ev0.isSameLabel(ev1)) {
          mc0.computeIntersections(mc1, si);
          this$1.nOverlaps++;
        }
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.addEdges = function addEdges2() {
    var this$1 = this;
    if (arguments.length === 1) {
      var edges2 = arguments[0];
      for (var i = edges2.iterator(); i.hasNext(); ) {
        var edge = i.next();
        this$1.addEdge(edge, edge);
      }
    } else if (arguments.length === 2) {
      var edges$1 = arguments[0];
      var edgeSet = arguments[1];
      for (var i$1 = edges$1.iterator(); i$1.hasNext(); ) {
        var edge$1 = i$1.next();
        this$1.addEdge(edge$1, edgeSet);
      }
    }
  };
  SimpleMCSweepLineIntersector2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  SimpleMCSweepLineIntersector2.prototype.getClass = function getClass169() {
    return SimpleMCSweepLineIntersector2;
  };
  return SimpleMCSweepLineIntersector2;
}(EdgeSetIntersector);
var IntervalRTreeNode = function IntervalRTreeNode2() {
  this._min = Double.POSITIVE_INFINITY;
  this._max = Double.NEGATIVE_INFINITY;
};
var staticAccessors$45 = { NodeComparator: { configurable: true } };
IntervalRTreeNode.prototype.getMin = function getMin() {
  return this._min;
};
IntervalRTreeNode.prototype.intersects = function intersects6(queryMin, queryMax) {
  if (this._min > queryMax || this._max < queryMin) {
    return false;
  }
  return true;
};
IntervalRTreeNode.prototype.getMax = function getMax() {
  return this._max;
};
IntervalRTreeNode.prototype.toString = function toString24() {
  return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));
};
IntervalRTreeNode.prototype.interfaces_ = function interfaces_154() {
  return [];
};
IntervalRTreeNode.prototype.getClass = function getClass153() {
  return IntervalRTreeNode;
};
staticAccessors$45.NodeComparator.get = function() {
  return NodeComparator;
};
Object.defineProperties(IntervalRTreeNode, staticAccessors$45);
var NodeComparator = function NodeComparator2() {
};
NodeComparator.prototype.compare = function compare9(o1, o2) {
  var n1 = o1;
  var n2 = o2;
  var mid1 = (n1._min + n1._max) / 2;
  var mid2 = (n2._min + n2._max) / 2;
  if (mid1 < mid2) {
    return -1;
  }
  if (mid1 > mid2) {
    return 1;
  }
  return 0;
};
NodeComparator.prototype.interfaces_ = function interfaces_155() {
  return [Comparator];
};
NodeComparator.prototype.getClass = function getClass154() {
  return NodeComparator;
};
var IntervalRTreeLeafNode = function(IntervalRTreeNode$$1) {
  function IntervalRTreeLeafNode2() {
    IntervalRTreeNode$$1.call(this);
    this._item = null;
    var min4 = arguments[0];
    var max3 = arguments[1];
    var item = arguments[2];
    this._min = min4;
    this._max = max3;
    this._item = item;
  }
  if (IntervalRTreeNode$$1)
    IntervalRTreeLeafNode2.__proto__ = IntervalRTreeNode$$1;
  IntervalRTreeLeafNode2.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
  IntervalRTreeLeafNode2.prototype.constructor = IntervalRTreeLeafNode2;
  IntervalRTreeLeafNode2.prototype.query = function query5(queryMin, queryMax, visitor) {
    if (!this.intersects(queryMin, queryMax)) {
      return null;
    }
    visitor.visitItem(this._item);
  };
  IntervalRTreeLeafNode2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  IntervalRTreeLeafNode2.prototype.getClass = function getClass169() {
    return IntervalRTreeLeafNode2;
  };
  return IntervalRTreeLeafNode2;
}(IntervalRTreeNode);
var IntervalRTreeBranchNode = function(IntervalRTreeNode$$1) {
  function IntervalRTreeBranchNode2() {
    IntervalRTreeNode$$1.call(this);
    this._node1 = null;
    this._node2 = null;
    var n1 = arguments[0];
    var n2 = arguments[1];
    this._node1 = n1;
    this._node2 = n2;
    this.buildExtent(this._node1, this._node2);
  }
  if (IntervalRTreeNode$$1)
    IntervalRTreeBranchNode2.__proto__ = IntervalRTreeNode$$1;
  IntervalRTreeBranchNode2.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);
  IntervalRTreeBranchNode2.prototype.constructor = IntervalRTreeBranchNode2;
  IntervalRTreeBranchNode2.prototype.buildExtent = function buildExtent(n1, n2) {
    this._min = Math.min(n1._min, n2._min);
    this._max = Math.max(n1._max, n2._max);
  };
  IntervalRTreeBranchNode2.prototype.query = function query5(queryMin, queryMax, visitor) {
    if (!this.intersects(queryMin, queryMax)) {
      return null;
    }
    if (this._node1 !== null) {
      this._node1.query(queryMin, queryMax, visitor);
    }
    if (this._node2 !== null) {
      this._node2.query(queryMin, queryMax, visitor);
    }
  };
  IntervalRTreeBranchNode2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  IntervalRTreeBranchNode2.prototype.getClass = function getClass169() {
    return IntervalRTreeBranchNode2;
  };
  return IntervalRTreeBranchNode2;
}(IntervalRTreeNode);
var SortedPackedIntervalRTree = function SortedPackedIntervalRTree2() {
  this._leaves = new ArrayList();
  this._root = null;
  this._level = 0;
};
SortedPackedIntervalRTree.prototype.buildTree = function buildTree() {
  var this$1 = this;
  Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
  var src = this._leaves;
  var temp = null;
  var dest = new ArrayList();
  while (true) {
    this$1.buildLevel(src, dest);
    if (dest.size() === 1) {
      return dest.get(0);
    }
    temp = src;
    src = dest;
    dest = temp;
  }
};
SortedPackedIntervalRTree.prototype.insert = function insert4(min4, max3, item) {
  if (this._root !== null) {
    throw new Error("Index cannot be added to once it has been queried");
  }
  this._leaves.add(new IntervalRTreeLeafNode(min4, max3, item));
};
SortedPackedIntervalRTree.prototype.query = function query3(min4, max3, visitor) {
  this.init();
  this._root.query(min4, max3, visitor);
};
SortedPackedIntervalRTree.prototype.buildRoot = function buildRoot() {
  if (this._root !== null) {
    return null;
  }
  this._root = this.buildTree();
};
SortedPackedIntervalRTree.prototype.printNode = function printNode(node) {
  System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
};
SortedPackedIntervalRTree.prototype.init = function init6() {
  if (this._root !== null) {
    return null;
  }
  this.buildRoot();
};
SortedPackedIntervalRTree.prototype.buildLevel = function buildLevel(src, dest) {
  this._level++;
  dest.clear();
  for (var i = 0; i < src.size(); i += 2) {
    var n1 = src.get(i);
    var n2 = i + 1 < src.size() ? src.get(i) : null;
    if (n2 === null) {
      dest.add(n1);
    } else {
      var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));
      dest.add(node);
    }
  }
};
SortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_156() {
  return [];
};
SortedPackedIntervalRTree.prototype.getClass = function getClass155() {
  return SortedPackedIntervalRTree;
};
var ArrayListVisitor = function ArrayListVisitor2() {
  this._items = new ArrayList();
};
ArrayListVisitor.prototype.visitItem = function visitItem2(item) {
  this._items.add(item);
};
ArrayListVisitor.prototype.getItems = function getItems() {
  return this._items;
};
ArrayListVisitor.prototype.interfaces_ = function interfaces_157() {
  return [ItemVisitor];
};
ArrayListVisitor.prototype.getClass = function getClass156() {
  return ArrayListVisitor;
};
var IndexedPointInAreaLocator = function IndexedPointInAreaLocator2() {
  this._index = null;
  var g = arguments[0];
  if (!hasInterface(g, Polygonal)) {
    throw new IllegalArgumentException("Argument must be Polygonal");
  }
  this._index = new IntervalIndexedGeometry(g);
};
var staticAccessors$44 = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
IndexedPointInAreaLocator.prototype.locate = function locate5(p) {
  var rcc = new RayCrossingCounter(p);
  var visitor = new SegmentVisitor(rcc);
  this._index.query(p.y, p.y, visitor);
  return rcc.getLocation();
};
IndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_158() {
  return [PointOnGeometryLocator];
};
IndexedPointInAreaLocator.prototype.getClass = function getClass157() {
  return IndexedPointInAreaLocator;
};
staticAccessors$44.SegmentVisitor.get = function() {
  return SegmentVisitor;
};
staticAccessors$44.IntervalIndexedGeometry.get = function() {
  return IntervalIndexedGeometry;
};
Object.defineProperties(IndexedPointInAreaLocator, staticAccessors$44);
var SegmentVisitor = function SegmentVisitor2() {
  this._counter = null;
  var counter = arguments[0];
  this._counter = counter;
};
SegmentVisitor.prototype.visitItem = function visitItem3(item) {
  var seg = item;
  this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
};
SegmentVisitor.prototype.interfaces_ = function interfaces_159() {
  return [ItemVisitor];
};
SegmentVisitor.prototype.getClass = function getClass158() {
  return SegmentVisitor;
};
var IntervalIndexedGeometry = function IntervalIndexedGeometry2() {
  this._index = new SortedPackedIntervalRTree();
  var geom = arguments[0];
  this.init(geom);
};
IntervalIndexedGeometry.prototype.init = function init7(geom) {
  var this$1 = this;
  var lines = LinearComponentExtracter.getLines(geom);
  for (var i = lines.iterator(); i.hasNext(); ) {
    var line = i.next();
    var pts = line.getCoordinates();
    this$1.addLine(pts);
  }
};
IntervalIndexedGeometry.prototype.addLine = function addLine(pts) {
  var this$1 = this;
  for (var i = 1; i < pts.length; i++) {
    var seg = new LineSegment(pts[i - 1], pts[i]);
    var min4 = Math.min(seg.p0.y, seg.p1.y);
    var max3 = Math.max(seg.p0.y, seg.p1.y);
    this$1._index.insert(min4, max3, seg);
  }
};
IntervalIndexedGeometry.prototype.query = function query4() {
  if (arguments.length === 2) {
    var min4 = arguments[0];
    var max3 = arguments[1];
    var visitor = new ArrayListVisitor();
    this._index.query(min4, max3, visitor);
    return visitor.getItems();
  } else if (arguments.length === 3) {
    var min$1 = arguments[0];
    var max$1 = arguments[1];
    var visitor$1 = arguments[2];
    this._index.query(min$1, max$1, visitor$1);
  }
};
IntervalIndexedGeometry.prototype.interfaces_ = function interfaces_160() {
  return [];
};
IntervalIndexedGeometry.prototype.getClass = function getClass159() {
  return IntervalIndexedGeometry;
};
var GeometryGraph = function(PlanarGraph$$1) {
  function GeometryGraph2() {
    PlanarGraph$$1.call(this);
    this._parentGeom = null;
    this._lineEdgeMap = new HashMap();
    this._boundaryNodeRule = null;
    this._useBoundaryDeterminationRule = true;
    this._argIndex = null;
    this._boundaryNodes = null;
    this._hasTooFewPoints = false;
    this._invalidPoint = null;
    this._areaPtLocator = null;
    this._ptLocator = new PointLocator();
    if (arguments.length === 2) {
      var argIndex = arguments[0];
      var parentGeom = arguments[1];
      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
      this._argIndex = argIndex;
      this._parentGeom = parentGeom;
      this._boundaryNodeRule = boundaryNodeRule;
      if (parentGeom !== null) {
        this.add(parentGeom);
      }
    } else if (arguments.length === 3) {
      var argIndex$1 = arguments[0];
      var parentGeom$1 = arguments[1];
      var boundaryNodeRule$1 = arguments[2];
      this._argIndex = argIndex$1;
      this._parentGeom = parentGeom$1;
      this._boundaryNodeRule = boundaryNodeRule$1;
      if (parentGeom$1 !== null) {
        this.add(parentGeom$1);
      }
    }
  }
  if (PlanarGraph$$1)
    GeometryGraph2.__proto__ = PlanarGraph$$1;
  GeometryGraph2.prototype = Object.create(PlanarGraph$$1 && PlanarGraph$$1.prototype);
  GeometryGraph2.prototype.constructor = GeometryGraph2;
  GeometryGraph2.prototype.insertBoundaryPoint = function insertBoundaryPoint(argIndex, coord) {
    var n = this._nodes.addNode(coord);
    var lbl = n.getLabel();
    var boundaryCount = 1;
    var loc = Location.NONE;
    loc = lbl.getLocation(argIndex, Position.ON);
    if (loc === Location.BOUNDARY) {
      boundaryCount++;
    }
    var newLoc = GeometryGraph2.determineBoundary(this._boundaryNodeRule, boundaryCount);
    lbl.setLocation(argIndex, newLoc);
  };
  GeometryGraph2.prototype.computeSelfNodes = function computeSelfNodes() {
    if (arguments.length === 2) {
      var li = arguments[0];
      var computeRingSelfNodes = arguments[1];
      return this.computeSelfNodes(li, computeRingSelfNodes, false);
    } else if (arguments.length === 3) {
      var li$1 = arguments[0];
      var computeRingSelfNodes$1 = arguments[1];
      var isDoneIfProperInt = arguments[2];
      var si = new SegmentIntersector$2(li$1, true, false);
      si.setIsDoneIfProperInt(isDoneIfProperInt);
      var esi = this.createEdgeSetIntersector();
      var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;
      var computeAllSegments = computeRingSelfNodes$1 || !isRings;
      esi.computeIntersections(this._edges, si, computeAllSegments);
      this.addSelfIntersectionNodes(this._argIndex);
      return si;
    }
  };
  GeometryGraph2.prototype.computeSplitEdges = function computeSplitEdges(edgelist) {
    for (var i = this._edges.iterator(); i.hasNext(); ) {
      var e = i.next();
      e.eiList.addSplitEdges(edgelist);
    }
  };
  GeometryGraph2.prototype.computeEdgeIntersections = function computeEdgeIntersections(g, li, includeProper) {
    var si = new SegmentIntersector$2(li, includeProper, true);
    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
    var esi = this.createEdgeSetIntersector();
    esi.computeIntersections(this._edges, g._edges, si);
    return si;
  };
  GeometryGraph2.prototype.getGeometry = function getGeometry3() {
    return this._parentGeom;
  };
  GeometryGraph2.prototype.getBoundaryNodeRule = function getBoundaryNodeRule() {
    return this._boundaryNodeRule;
  };
  GeometryGraph2.prototype.hasTooFewPoints = function hasTooFewPoints() {
    return this._hasTooFewPoints;
  };
  GeometryGraph2.prototype.addPoint = function addPoint2() {
    if (arguments[0] instanceof Point) {
      var p = arguments[0];
      var coord = p.getCoordinate();
      this.insertPoint(this._argIndex, coord, Location.INTERIOR);
    } else if (arguments[0] instanceof Coordinate) {
      var pt = arguments[0];
      this.insertPoint(this._argIndex, pt, Location.INTERIOR);
    }
  };
  GeometryGraph2.prototype.addPolygon = function addPolygon2(p) {
    var this$1 = this;
    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
    for (var i = 0; i < p.getNumInteriorRing(); i++) {
      var hole = p.getInteriorRingN(i);
      this$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
    }
  };
  GeometryGraph2.prototype.addEdge = function addEdge(e) {
    this.insertEdge(e);
    var coord = e.getCoordinates();
    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
    this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
  };
  GeometryGraph2.prototype.addLineString = function addLineString2(line) {
    var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
    if (coord.length < 2) {
      this._hasTooFewPoints = true;
      this._invalidPoint = coord[0];
      return null;
    }
    var e = new Edge2(coord, new Label(this._argIndex, Location.INTERIOR));
    this._lineEdgeMap.put(line, e);
    this.insertEdge(e);
    Assert.isTrue(coord.length >= 2, "found LineString with single point");
    this.insertBoundaryPoint(this._argIndex, coord[0]);
    this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
  };
  GeometryGraph2.prototype.getInvalidPoint = function getInvalidPoint() {
    return this._invalidPoint;
  };
  GeometryGraph2.prototype.getBoundaryPoints = function getBoundaryPoints() {
    var coll = this.getBoundaryNodes();
    var pts = new Array(coll.size()).fill(null);
    var i = 0;
    for (var it = coll.iterator(); it.hasNext(); ) {
      var node = it.next();
      pts[i++] = node.getCoordinate().copy();
    }
    return pts;
  };
  GeometryGraph2.prototype.getBoundaryNodes = function getBoundaryNodes2() {
    if (this._boundaryNodes === null) {
      this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
    }
    return this._boundaryNodes;
  };
  GeometryGraph2.prototype.addSelfIntersectionNode = function addSelfIntersectionNode(argIndex, coord, loc) {
    if (this.isBoundaryNode(argIndex, coord)) {
      return null;
    }
    if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) {
      this.insertBoundaryPoint(argIndex, coord);
    } else {
      this.insertPoint(argIndex, coord, loc);
    }
  };
  GeometryGraph2.prototype.addPolygonRing = function addPolygonRing2(lr, cwLeft, cwRight) {
    if (lr.isEmpty()) {
      return null;
    }
    var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
    if (coord.length < 4) {
      this._hasTooFewPoints = true;
      this._invalidPoint = coord[0];
      return null;
    }
    var left = cwLeft;
    var right = cwRight;
    if (CGAlgorithms.isCCW(coord)) {
      left = cwRight;
      right = cwLeft;
    }
    var e = new Edge2(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
    this._lineEdgeMap.put(lr, e);
    this.insertEdge(e);
    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
  };
  GeometryGraph2.prototype.insertPoint = function insertPoint(argIndex, coord, onLocation) {
    var n = this._nodes.addNode(coord);
    var lbl = n.getLabel();
    if (lbl === null) {
      n._label = new Label(argIndex, onLocation);
    } else {
      lbl.setLocation(argIndex, onLocation);
    }
  };
  GeometryGraph2.prototype.createEdgeSetIntersector = function createEdgeSetIntersector() {
    return new SimpleMCSweepLineIntersector();
  };
  GeometryGraph2.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes(argIndex) {
    var this$1 = this;
    for (var i = this._edges.iterator(); i.hasNext(); ) {
      var e = i.next();
      var eLoc = e.getLabel().getLocation(argIndex);
      for (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {
        var ei = eiIt.next();
        this$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
      }
    }
  };
  GeometryGraph2.prototype.add = function add16() {
    if (arguments.length === 1) {
      var g = arguments[0];
      if (g.isEmpty()) {
        return null;
      }
      if (g instanceof MultiPolygon) {
        this._useBoundaryDeterminationRule = false;
      }
      if (g instanceof Polygon) {
        this.addPolygon(g);
      } else if (g instanceof LineString2) {
        this.addLineString(g);
      } else if (g instanceof Point) {
        this.addPoint(g);
      } else if (g instanceof MultiPoint) {
        this.addCollection(g);
      } else if (g instanceof MultiLineString) {
        this.addCollection(g);
      } else if (g instanceof MultiPolygon) {
        this.addCollection(g);
      } else if (g instanceof GeometryCollection) {
        this.addCollection(g);
      } else {
        throw new Error(g.getClass().getName());
      }
    } else {
      return PlanarGraph$$1.prototype.add.apply(this, arguments);
    }
  };
  GeometryGraph2.prototype.addCollection = function addCollection2(gc) {
    var this$1 = this;
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      var g = gc.getGeometryN(i);
      this$1.add(g);
    }
  };
  GeometryGraph2.prototype.locate = function locate6(pt) {
    if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
      if (this._areaPtLocator === null) {
        this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
      }
      return this._areaPtLocator.locate(pt);
    }
    return this._ptLocator.locate(pt, this._parentGeom);
  };
  GeometryGraph2.prototype.findEdge = function findEdge3() {
    if (arguments.length === 1) {
      var line = arguments[0];
      return this._lineEdgeMap.get(line);
    } else {
      return PlanarGraph$$1.prototype.findEdge.apply(this, arguments);
    }
  };
  GeometryGraph2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  GeometryGraph2.prototype.getClass = function getClass169() {
    return GeometryGraph2;
  };
  GeometryGraph2.determineBoundary = function determineBoundary(boundaryNodeRule, boundaryCount) {
    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;
  };
  return GeometryGraph2;
}(PlanarGraph);
var GeometryGraphOp = function GeometryGraphOp2() {
  this._li = new RobustLineIntersector();
  this._resultPrecisionModel = null;
  this._arg = null;
  if (arguments.length === 1) {
    var g0 = arguments[0];
    this.setComputationPrecision(g0.getPrecisionModel());
    this._arg = new Array(1).fill(null);
    this._arg[0] = new GeometryGraph(0, g0);
  } else if (arguments.length === 2) {
    var g0$1 = arguments[0];
    var g1 = arguments[1];
    var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
    if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) {
      this.setComputationPrecision(g0$1.getPrecisionModel());
    } else {
      this.setComputationPrecision(g1.getPrecisionModel());
    }
    this._arg = new Array(2).fill(null);
    this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);
    this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
  } else if (arguments.length === 3) {
    var g0$2 = arguments[0];
    var g1$1 = arguments[1];
    var boundaryNodeRule$1 = arguments[2];
    if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) {
      this.setComputationPrecision(g0$2.getPrecisionModel());
    } else {
      this.setComputationPrecision(g1$1.getPrecisionModel());
    }
    this._arg = new Array(2).fill(null);
    this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);
    this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);
  }
};
GeometryGraphOp.prototype.getArgGeometry = function getArgGeometry(i) {
  return this._arg[i].getGeometry();
};
GeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision(pm) {
  this._resultPrecisionModel = pm;
  this._li.setPrecisionModel(this._resultPrecisionModel);
};
GeometryGraphOp.prototype.interfaces_ = function interfaces_161() {
  return [];
};
GeometryGraphOp.prototype.getClass = function getClass160() {
  return GeometryGraphOp;
};
var GeometryMapper = function GeometryMapper2() {
};
GeometryMapper.prototype.interfaces_ = function interfaces_162() {
  return [];
};
GeometryMapper.prototype.getClass = function getClass161() {
  return GeometryMapper;
};
GeometryMapper.map = function map3() {
  if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {
    var geom = arguments[0];
    var op = arguments[1];
    var mapped = new ArrayList();
    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var g = op.map(geom.getGeometryN(i));
      if (g !== null) {
        mapped.add(g);
      }
    }
    return geom.getFactory().buildGeometry(mapped);
  } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {
    var geoms = arguments[0];
    var op$1 = arguments[1];
    var mapped$1 = new ArrayList();
    for (var i$1 = geoms.iterator(); i$1.hasNext(); ) {
      var g$1 = i$1.next();
      var gr = op$1.map(g$1);
      if (gr !== null) {
        mapped$1.add(gr);
      }
    }
    return mapped$1;
  }
};
GeometryMapper.MapOp = function MapOp() {
};
var OverlayOp = function(GeometryGraphOp3) {
  function OverlayOp2() {
    var g0 = arguments[0];
    var g1 = arguments[1];
    GeometryGraphOp3.call(this, g0, g1);
    this._ptLocator = new PointLocator();
    this._geomFact = null;
    this._resultGeom = null;
    this._graph = null;
    this._edgeList = new EdgeList();
    this._resultPolyList = new ArrayList();
    this._resultLineList = new ArrayList();
    this._resultPointList = new ArrayList();
    this._graph = new PlanarGraph(new OverlayNodeFactory());
    this._geomFact = g0.getFactory();
  }
  if (GeometryGraphOp3)
    OverlayOp2.__proto__ = GeometryGraphOp3;
  OverlayOp2.prototype = Object.create(GeometryGraphOp3 && GeometryGraphOp3.prototype);
  OverlayOp2.prototype.constructor = OverlayOp2;
  OverlayOp2.prototype.insertUniqueEdge = function insertUniqueEdge2(e) {
    var existingEdge = this._edgeList.findEqualEdge(e);
    if (existingEdge !== null) {
      var existingLabel = existingEdge.getLabel();
      var labelToMerge = e.getLabel();
      if (!existingEdge.isPointwiseEqual(e)) {
        labelToMerge = new Label(e.getLabel());
        labelToMerge.flip();
      }
      var depth2 = existingEdge.getDepth();
      if (depth2.isNull()) {
        depth2.add(existingLabel);
      }
      depth2.add(labelToMerge);
      existingLabel.merge(labelToMerge);
    } else {
      this._edgeList.add(e);
    }
  };
  OverlayOp2.prototype.getGraph = function getGraph() {
    return this._graph;
  };
  OverlayOp2.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges() {
    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
      var de = it.next();
      var sym = de.getSym();
      if (de.isInResult() && sym.isInResult()) {
        de.setInResult(false);
        sym.setInResult(false);
      }
    }
  };
  OverlayOp2.prototype.isCoveredByLA = function isCoveredByLA(coord) {
    if (this.isCovered(coord, this._resultLineList)) {
      return true;
    }
    if (this.isCovered(coord, this._resultPolyList)) {
      return true;
    }
    return false;
  };
  OverlayOp2.prototype.computeGeometry = function computeGeometry2(resultPointList, resultLineList, resultPolyList, opcode) {
    var geomList = new ArrayList();
    geomList.addAll(resultPointList);
    geomList.addAll(resultLineList);
    geomList.addAll(resultPolyList);
    if (geomList.isEmpty()) {
      return OverlayOp2.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
    }
    return this._geomFact.buildGeometry(geomList);
  };
  OverlayOp2.prototype.mergeSymLabels = function mergeSymLabels() {
    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
      var node = nodeit.next();
      node.getEdges().mergeSymLabels();
    }
  };
  OverlayOp2.prototype.isCovered = function isCovered2(coord, geomList) {
    var this$1 = this;
    for (var it = geomList.iterator(); it.hasNext(); ) {
      var geom = it.next();
      var loc = this$1._ptLocator.locate(coord, geom);
      if (loc !== Location.EXTERIOR) {
        return true;
      }
    }
    return false;
  };
  OverlayOp2.prototype.replaceCollapsedEdges = function replaceCollapsedEdges() {
    var newEdges = new ArrayList();
    for (var it = this._edgeList.iterator(); it.hasNext(); ) {
      var e = it.next();
      if (e.isCollapsed()) {
        it.remove();
        newEdges.add(e.getCollapsedEdge());
      }
    }
    this._edgeList.addAll(newEdges);
  };
  OverlayOp2.prototype.updateNodeLabelling = function updateNodeLabelling() {
    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
      var node = nodeit.next();
      var lbl = node.getEdges().getLabel();
      node.getLabel().merge(lbl);
    }
  };
  OverlayOp2.prototype.getResultGeometry = function getResultGeometry4(overlayOpCode) {
    this.computeOverlay(overlayOpCode);
    return this._resultGeom;
  };
  OverlayOp2.prototype.insertUniqueEdges = function insertUniqueEdges(edges2) {
    var this$1 = this;
    for (var i = edges2.iterator(); i.hasNext(); ) {
      var e = i.next();
      this$1.insertUniqueEdge(e);
    }
  };
  OverlayOp2.prototype.computeOverlay = function computeOverlay(opCode) {
    this.copyPoints(0);
    this.copyPoints(1);
    this._arg[0].computeSelfNodes(this._li, false);
    this._arg[1].computeSelfNodes(this._li, false);
    this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
    var baseSplitEdges = new ArrayList();
    this._arg[0].computeSplitEdges(baseSplitEdges);
    this._arg[1].computeSplitEdges(baseSplitEdges);
    this.insertUniqueEdges(baseSplitEdges);
    this.computeLabelsFromDepths();
    this.replaceCollapsedEdges();
    EdgeNodingValidator.checkValid(this._edgeList.getEdges());
    this._graph.addEdges(this._edgeList.getEdges());
    this.computeLabelling();
    this.labelIncompleteNodes();
    this.findResultAreaEdges(opCode);
    this.cancelDuplicateResultEdges();
    var polyBuilder = new PolygonBuilder(this._geomFact);
    polyBuilder.add(this._graph);
    this._resultPolyList = polyBuilder.getPolygons();
    var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
    this._resultLineList = lineBuilder.build(opCode);
    var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
    this._resultPointList = pointBuilder.build(opCode);
    this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
  };
  OverlayOp2.prototype.labelIncompleteNode = function labelIncompleteNode(n, targetIndex) {
    var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
    n.getLabel().setLocation(targetIndex, loc);
  };
  OverlayOp2.prototype.copyPoints = function copyPoints(argIndex) {
    var this$1 = this;
    for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext(); ) {
      var graphNode = i.next();
      var newNode = this$1._graph.addNode(graphNode.getCoordinate());
      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
    }
  };
  OverlayOp2.prototype.findResultAreaEdges = function findResultAreaEdges(opCode) {
    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext(); ) {
      var de = it.next();
      var label = de.getLabel();
      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp2.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
        de.setInResult(true);
      }
    }
  };
  OverlayOp2.prototype.computeLabelsFromDepths = function computeLabelsFromDepths() {
    for (var it = this._edgeList.iterator(); it.hasNext(); ) {
      var e = it.next();
      var lbl = e.getLabel();
      var depth2 = e.getDepth();
      if (!depth2.isNull()) {
        depth2.normalize();
        for (var i = 0; i < 2; i++) {
          if (!lbl.isNull(i) && lbl.isArea() && !depth2.isNull(i)) {
            if (depth2.getDelta(i) === 0) {
              lbl.toLine(i);
            } else {
              Assert.isTrue(!depth2.isNull(i, Position.LEFT), "depth of LEFT side has not been initialized");
              lbl.setLocation(i, Position.LEFT, depth2.getLocation(i, Position.LEFT));
              Assert.isTrue(!depth2.isNull(i, Position.RIGHT), "depth of RIGHT side has not been initialized");
              lbl.setLocation(i, Position.RIGHT, depth2.getLocation(i, Position.RIGHT));
            }
          }
        }
      }
    }
  };
  OverlayOp2.prototype.computeLabelling = function computeLabelling2() {
    var this$1 = this;
    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext(); ) {
      var node = nodeit.next();
      node.getEdges().computeLabelling(this$1._arg);
    }
    this.mergeSymLabels();
    this.updateNodeLabelling();
  };
  OverlayOp2.prototype.labelIncompleteNodes = function labelIncompleteNodes() {
    var this$1 = this;
    for (var ni = this._graph.getNodes().iterator(); ni.hasNext(); ) {
      var n = ni.next();
      var label = n.getLabel();
      if (n.isIsolated()) {
        if (label.isNull(0)) {
          this$1.labelIncompleteNode(n, 0);
        } else {
          this$1.labelIncompleteNode(n, 1);
        }
      }
      n.getEdges().updateLabelling(label);
    }
  };
  OverlayOp2.prototype.isCoveredByA = function isCoveredByA(coord) {
    if (this.isCovered(coord, this._resultPolyList)) {
      return true;
    }
    return false;
  };
  OverlayOp2.prototype.interfaces_ = function interfaces_170() {
    return [];
  };
  OverlayOp2.prototype.getClass = function getClass169() {
    return OverlayOp2;
  };
  return OverlayOp2;
}(GeometryGraphOp);
OverlayOp.overlayOp = function(geom0, geom1, opCode) {
  var gov = new OverlayOp(geom0, geom1);
  var geomOv = gov.getResultGeometry(opCode);
  return geomOv;
};
OverlayOp.intersection = function(g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());
  }
  if (g.isGeometryCollection()) {
    var g2 = other;
    return GeometryCollectionMapper.map(g, {
      interfaces_: function() {
        return [GeometryMapper.MapOp];
      },
      map: function(g3) {
        return g3.intersection(g2);
      }
    });
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);
};
OverlayOp.symDifference = function(g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    if (g.isEmpty() && other.isEmpty()) {
      return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());
    }
    if (g.isEmpty()) {
      return other.copy();
    }
    if (other.isEmpty()) {
      return g.copy();
    }
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);
};
OverlayOp.resultDimension = function(opCode, g0, g1) {
  var dim0 = g0.getDimension();
  var dim1 = g1.getDimension();
  var resultDimension = -1;
  switch (opCode) {
    case OverlayOp.INTERSECTION:
      resultDimension = Math.min(dim0, dim1);
      break;
    case OverlayOp.UNION:
      resultDimension = Math.max(dim0, dim1);
      break;
    case OverlayOp.DIFFERENCE:
      resultDimension = dim0;
      break;
    case OverlayOp.SYMDIFFERENCE:
      resultDimension = Math.max(dim0, dim1);
      break;
    default:
  }
  return resultDimension;
};
OverlayOp.createEmptyResult = function(overlayOpCode, a, b, geomFact) {
  var result = null;
  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
    case -1:
      result = geomFact.createGeometryCollection(new Array(0).fill(null));
      break;
    case 0:
      result = geomFact.createPoint();
      break;
    case 1:
      result = geomFact.createLineString();
      break;
    case 2:
      result = geomFact.createPolygon();
      break;
    default:
  }
  return result;
};
OverlayOp.difference = function(g, other) {
  if (g.isEmpty()) {
    return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());
  }
  if (other.isEmpty()) {
    return g.copy();
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);
};
OverlayOp.isResultOfOp = function() {
  if (arguments.length === 2) {
    var label = arguments[0];
    var opCode = arguments[1];
    var loc0 = label.getLocation(0);
    var loc1 = label.getLocation(1);
    return OverlayOp.isResultOfOp(loc0, loc1, opCode);
  } else if (arguments.length === 3) {
    var loc0$1 = arguments[0];
    var loc1$1 = arguments[1];
    var overlayOpCode = arguments[2];
    if (loc0$1 === Location.BOUNDARY) {
      loc0$1 = Location.INTERIOR;
    }
    if (loc1$1 === Location.BOUNDARY) {
      loc1$1 = Location.INTERIOR;
    }
    switch (overlayOpCode) {
      case OverlayOp.INTERSECTION:
        return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR;
      case OverlayOp.UNION:
        return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR;
      case OverlayOp.DIFFERENCE:
        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR;
      case OverlayOp.SYMDIFFERENCE:
        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR || loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR;
      default:
    }
    return false;
  }
};
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;
var FuzzyPointLocator = function FuzzyPointLocator2() {
  this._g = null;
  this._boundaryDistanceTolerance = null;
  this._linework = null;
  this._ptLocator = new PointLocator();
  this._seg = new LineSegment();
  var g = arguments[0];
  var boundaryDistanceTolerance = arguments[1];
  this._g = g;
  this._boundaryDistanceTolerance = boundaryDistanceTolerance;
  this._linework = this.extractLinework(g);
};
FuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary(pt) {
  var this$1 = this;
  for (var i = 0; i < this._linework.getNumGeometries(); i++) {
    var line = this$1._linework.getGeometryN(i);
    var seq = line.getCoordinateSequence();
    for (var j = 0; j < seq.size() - 1; j++) {
      seq.getCoordinate(j, this$1._seg.p0);
      seq.getCoordinate(j + 1, this$1._seg.p1);
      var dist = this$1._seg.distance(pt);
      if (dist <= this$1._boundaryDistanceTolerance) {
        return true;
      }
    }
  }
  return false;
};
FuzzyPointLocator.prototype.getLocation = function getLocation5(pt) {
  if (this.isWithinToleranceOfBoundary(pt)) {
    return Location.BOUNDARY;
  }
  return this._ptLocator.locate(pt, this._g);
};
FuzzyPointLocator.prototype.extractLinework = function extractLinework(g) {
  var extracter = new PolygonalLineworkExtracter();
  g.apply(extracter);
  var linework = extracter.getLinework();
  var lines = GeometryFactory.toLineStringArray(linework);
  return g.getFactory().createMultiLineString(lines);
};
FuzzyPointLocator.prototype.interfaces_ = function interfaces_163() {
  return [];
};
FuzzyPointLocator.prototype.getClass = function getClass162() {
  return FuzzyPointLocator;
};
var PolygonalLineworkExtracter = function PolygonalLineworkExtracter2() {
  this._linework = null;
  this._linework = new ArrayList();
};
PolygonalLineworkExtracter.prototype.getLinework = function getLinework() {
  return this._linework;
};
PolygonalLineworkExtracter.prototype.filter = function filter16(g) {
  var this$1 = this;
  if (g instanceof Polygon) {
    var poly = g;
    this._linework.add(poly.getExteriorRing());
    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
      this$1._linework.add(poly.getInteriorRingN(i));
    }
  }
};
PolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_164() {
  return [GeometryFilter];
};
PolygonalLineworkExtracter.prototype.getClass = function getClass163() {
  return PolygonalLineworkExtracter;
};
var OffsetPointGenerator = function OffsetPointGenerator2() {
  this._g = null;
  this._doLeft = true;
  this._doRight = true;
  var g = arguments[0];
  this._g = g;
};
OffsetPointGenerator.prototype.extractPoints = function extractPoints(line, offsetDistance, offsetPts) {
  var this$1 = this;
  var pts = line.getCoordinates();
  for (var i = 0; i < pts.length - 1; i++) {
    this$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);
  }
};
OffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate(doLeft, doRight) {
  this._doLeft = doLeft;
  this._doRight = doRight;
};
OffsetPointGenerator.prototype.getPoints = function getPoints2(offsetDistance) {
  var this$1 = this;
  var offsetPts = new ArrayList();
  var lines = LinearComponentExtracter.getLines(this._g);
  for (var i = lines.iterator(); i.hasNext(); ) {
    var line = i.next();
    this$1.extractPoints(line, offsetDistance, offsetPts);
  }
  return offsetPts;
};
OffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints(p0, p1, offsetDistance, offsetPts) {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  var len = Math.sqrt(dx * dx + dy * dy);
  var ux = offsetDistance * dx / len;
  var uy = offsetDistance * dy / len;
  var midX = (p1.x + p0.x) / 2;
  var midY = (p1.y + p0.y) / 2;
  if (this._doLeft) {
    var offsetLeft = new Coordinate(midX - uy, midY + ux);
    offsetPts.add(offsetLeft);
  }
  if (this._doRight) {
    var offsetRight = new Coordinate(midX + uy, midY - ux);
    offsetPts.add(offsetRight);
  }
};
OffsetPointGenerator.prototype.interfaces_ = function interfaces_165() {
  return [];
};
OffsetPointGenerator.prototype.getClass = function getClass164() {
  return OffsetPointGenerator;
};
var OverlayResultValidator = function OverlayResultValidator2() {
  this._geom = null;
  this._locFinder = null;
  this._location = new Array(3).fill(null);
  this._invalidLocation = null;
  this._boundaryDistanceTolerance = OverlayResultValidator2.TOLERANCE;
  this._testCoords = new ArrayList();
  var a = arguments[0];
  var b = arguments[1];
  var result = arguments[2];
  this._boundaryDistanceTolerance = OverlayResultValidator2.computeBoundaryDistanceTolerance(a, b);
  this._geom = [a, b, result];
  this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];
};
var staticAccessors$46 = { TOLERANCE: { configurable: true } };
OverlayResultValidator.prototype.reportResult = function reportResult(overlayOp3, location, expectedInterior) {
  System.out.println("Overlay result invalid - A:" + Location.toLocationSymbol(location[0]) + " B:" + Location.toLocationSymbol(location[1]) + " expected:" + (expectedInterior ? "i" : "e") + " actual:" + Location.toLocationSymbol(location[2]));
};
OverlayResultValidator.prototype.isValid = function isValid5(overlayOp3) {
  this.addTestPts(this._geom[0]);
  this.addTestPts(this._geom[1]);
  var isValid7 = this.checkValid(overlayOp3);
  return isValid7;
};
OverlayResultValidator.prototype.checkValid = function checkValid6() {
  var this$1 = this;
  if (arguments.length === 1) {
    var overlayOp3 = arguments[0];
    for (var i = 0; i < this._testCoords.size(); i++) {
      var pt = this$1._testCoords.get(i);
      if (!this$1.checkValid(overlayOp3, pt)) {
        this$1._invalidLocation = pt;
        return false;
      }
    }
    return true;
  } else if (arguments.length === 2) {
    var overlayOp$1 = arguments[0];
    var pt$1 = arguments[1];
    this._location[0] = this._locFinder[0].getLocation(pt$1);
    this._location[1] = this._locFinder[1].getLocation(pt$1);
    this._location[2] = this._locFinder[2].getLocation(pt$1);
    if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) {
      return true;
    }
    return this.isValidResult(overlayOp$1, this._location);
  }
};
OverlayResultValidator.prototype.addTestPts = function addTestPts(g) {
  var ptGen = new OffsetPointGenerator(g);
  this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));
};
OverlayResultValidator.prototype.isValidResult = function isValidResult(overlayOp3, location) {
  var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp3);
  var resultInInterior = location[2] === Location.INTERIOR;
  var isValid7 = !(expectedInterior ^ resultInInterior);
  if (!isValid7) {
    this.reportResult(overlayOp3, location, expectedInterior);
  }
  return isValid7;
};
OverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation() {
  return this._invalidLocation;
};
OverlayResultValidator.prototype.interfaces_ = function interfaces_166() {
  return [];
};
OverlayResultValidator.prototype.getClass = function getClass165() {
  return OverlayResultValidator;
};
OverlayResultValidator.hasLocation = function hasLocation(location, loc) {
  for (var i = 0; i < 3; i++) {
    if (location[i] === loc) {
      return true;
    }
  }
  return false;
};
OverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance(g0, g1) {
  return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1));
};
OverlayResultValidator.isValid = function isValid6(a, b, overlayOp3, result) {
  var validator = new OverlayResultValidator(a, b, result);
  return validator.isValid(overlayOp3);
};
staticAccessors$46.TOLERANCE.get = function() {
  return 1e-6;
};
Object.defineProperties(OverlayResultValidator, staticAccessors$46);
var GeometryCombiner = function GeometryCombiner2(geoms) {
  this._geomFactory = null;
  this._skipEmpty = false;
  this._inputGeoms = null;
  this._geomFactory = GeometryCombiner2.extractFactory(geoms);
  this._inputGeoms = geoms;
};
GeometryCombiner.prototype.extractElements = function extractElements(geom, elems) {
  var this$1 = this;
  if (geom === null) {
    return null;
  }
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var elemGeom = geom.getGeometryN(i);
    if (this$1._skipEmpty && elemGeom.isEmpty()) {
      continue;
    }
    elems.add(elemGeom);
  }
};
GeometryCombiner.prototype.combine = function combine2() {
  var this$1 = this;
  var elems = new ArrayList();
  for (var i = this._inputGeoms.iterator(); i.hasNext(); ) {
    var g = i.next();
    this$1.extractElements(g, elems);
  }
  if (elems.size() === 0) {
    if (this._geomFactory !== null) {
      return this._geomFactory.createGeometryCollection(null);
    }
    return null;
  }
  return this._geomFactory.buildGeometry(elems);
};
GeometryCombiner.prototype.interfaces_ = function interfaces_167() {
  return [];
};
GeometryCombiner.prototype.getClass = function getClass166() {
  return GeometryCombiner;
};
GeometryCombiner.combine = function combine3() {
  if (arguments.length === 1) {
    var geoms = arguments[0];
    var combiner = new GeometryCombiner(geoms);
    return combiner.combine();
  } else if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
    return combiner$1.combine();
  } else if (arguments.length === 3) {
    var g0$1 = arguments[0];
    var g1$1 = arguments[1];
    var g2 = arguments[2];
    var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));
    return combiner$2.combine();
  }
};
GeometryCombiner.extractFactory = function extractFactory(geoms) {
  if (geoms.isEmpty()) {
    return null;
  }
  return geoms.iterator().next().getFactory();
};
GeometryCombiner.createList = function createList2() {
  if (arguments.length === 2) {
    var obj0 = arguments[0];
    var obj1 = arguments[1];
    var list = new ArrayList();
    list.add(obj0);
    list.add(obj1);
    return list;
  } else if (arguments.length === 3) {
    var obj0$1 = arguments[0];
    var obj1$1 = arguments[1];
    var obj2 = arguments[2];
    var list$1 = new ArrayList();
    list$1.add(obj0$1);
    list$1.add(obj1$1);
    list$1.add(obj2);
    return list$1;
  }
};
var CascadedPolygonUnion = function CascadedPolygonUnion2() {
  this._inputPolys = null;
  this._geomFactory = null;
  var polys = arguments[0];
  this._inputPolys = polys;
  if (this._inputPolys === null) {
    this._inputPolys = new ArrayList();
  }
};
var staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };
CascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries(geomTree) {
  var this$1 = this;
  var geoms = new ArrayList();
  for (var i = geomTree.iterator(); i.hasNext(); ) {
    var o = i.next();
    var geom = null;
    if (hasInterface(o, List)) {
      geom = this$1.unionTree(o);
    } else if (o instanceof Geometry) {
      geom = o;
    }
    geoms.add(geom);
  }
  return geoms;
};
CascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope(env, geom, disjointGeoms) {
  var intersectingGeoms = new ArrayList();
  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var elem = geom.getGeometryN(i);
    if (elem.getEnvelopeInternal().intersects(env)) {
      intersectingGeoms.add(elem);
    } else {
      disjointGeoms.add(elem);
    }
  }
  return this._geomFactory.buildGeometry(intersectingGeoms);
};
CascadedPolygonUnion.prototype.unionOptimized = function unionOptimized(g0, g1) {
  var g0Env = g0.getEnvelopeInternal();
  var g1Env = g1.getEnvelopeInternal();
  if (!g0Env.intersects(g1Env)) {
    var combo = GeometryCombiner.combine(g0, g1);
    return combo;
  }
  if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) {
    return this.unionActual(g0, g1);
  }
  var commonEnv = g0Env.intersection(g1Env);
  return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);
};
CascadedPolygonUnion.prototype.union = function union5() {
  if (this._inputPolys === null) {
    throw new Error("union() method cannot be called twice");
  }
  if (this._inputPolys.isEmpty()) {
    return null;
  }
  this._geomFactory = this._inputPolys.iterator().next().getFactory();
  var index2 = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
  for (var i = this._inputPolys.iterator(); i.hasNext(); ) {
    var item = i.next();
    index2.insert(item.getEnvelopeInternal(), item);
  }
  this._inputPolys = null;
  var itemTree = index2.itemsTree();
  var unionAll = this.unionTree(itemTree);
  return unionAll;
};
CascadedPolygonUnion.prototype.binaryUnion = function binaryUnion() {
  if (arguments.length === 1) {
    var geoms = arguments[0];
    return this.binaryUnion(geoms, 0, geoms.size());
  } else if (arguments.length === 3) {
    var geoms$1 = arguments[0];
    var start = arguments[1];
    var end = arguments[2];
    if (end - start <= 1) {
      var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);
      return this.unionSafe(g0, null);
    } else if (end - start === 2) {
      return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1));
    } else {
      var mid = Math.trunc((end + start) / 2);
      var g0$1 = this.binaryUnion(geoms$1, start, mid);
      var g1 = this.binaryUnion(geoms$1, mid, end);
      return this.unionSafe(g0$1, g1);
    }
  }
};
CascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion(geoms) {
  var union9 = null;
  for (var i = geoms.iterator(); i.hasNext(); ) {
    var g = i.next();
    if (union9 === null) {
      union9 = g.copy();
    } else {
      union9 = union9.union(g);
    }
  }
  return union9;
};
CascadedPolygonUnion.prototype.unionSafe = function unionSafe(g0, g1) {
  if (g0 === null && g1 === null) {
    return null;
  }
  if (g0 === null) {
    return g1.copy();
  }
  if (g1 === null) {
    return g0.copy();
  }
  return this.unionOptimized(g0, g1);
};
CascadedPolygonUnion.prototype.unionActual = function unionActual(g0, g1) {
  return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));
};
CascadedPolygonUnion.prototype.unionTree = function unionTree(geomTree) {
  var geoms = this.reduceToGeometries(geomTree);
  var union9 = this.binaryUnion(geoms);
  return union9;
};
CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection(g0, g1, common) {
  var disjointPolys = new ArrayList();
  var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
  var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
  var union9 = this.unionActual(g0Int, g1Int);
  disjointPolys.add(union9);
  var overallUnion = GeometryCombiner.combine(disjointPolys);
  return overallUnion;
};
CascadedPolygonUnion.prototype.bufferUnion = function bufferUnion() {
  if (arguments.length === 1) {
    var geoms = arguments[0];
    var factory = geoms.get(0).getFactory();
    var gColl = factory.buildGeometry(geoms);
    var unionAll = gColl.buffer(0);
    return unionAll;
  } else if (arguments.length === 2) {
    var g0 = arguments[0];
    var g1 = arguments[1];
    var factory$1 = g0.getFactory();
    var gColl$1 = factory$1.createGeometryCollection([g0, g1]);
    var unionAll$1 = gColl$1.buffer(0);
    return unionAll$1;
  }
};
CascadedPolygonUnion.prototype.interfaces_ = function interfaces_168() {
  return [];
};
CascadedPolygonUnion.prototype.getClass = function getClass167() {
  return CascadedPolygonUnion;
};
CascadedPolygonUnion.restrictToPolygons = function restrictToPolygons(g) {
  if (hasInterface(g, Polygonal)) {
    return g;
  }
  var polygons2 = PolygonExtracter.getPolygons(g);
  if (polygons2.size() === 1) {
    return polygons2.get(0);
  }
  return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons2));
};
CascadedPolygonUnion.getGeometry = function getGeometry2(list, index2) {
  if (index2 >= list.size()) {
    return null;
  }
  return list.get(index2);
};
CascadedPolygonUnion.union = function union6(polys) {
  var op = new CascadedPolygonUnion(polys);
  return op.union();
};
staticAccessors$47.STRTREE_NODE_CAPACITY.get = function() {
  return 4;
};
Object.defineProperties(CascadedPolygonUnion, staticAccessors$47);
var UnionOp = function UnionOp2() {
};
UnionOp.prototype.interfaces_ = function interfaces_169() {
  return [];
};
UnionOp.prototype.getClass = function getClass168() {
  return UnionOp;
};
UnionOp.union = function union7(g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    if (g.isEmpty() && other.isEmpty()) {
      return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());
    }
    if (g.isEmpty()) {
      return other.copy();
    }
    if (other.isEmpty()) {
      return g.copy();
    }
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);
};

// node_modules/@turf/buffer/dist/es/index.js
init_d3_geo();
function buffer3(geojson, radius, options) {
  options = options || {};
  var units = options.units || "kilometers";
  var steps = options.steps || 8;
  if (!geojson)
    throw new Error("geojson is required");
  if (typeof options !== "object")
    throw new Error("options must be an object");
  if (typeof steps !== "number")
    throw new Error("steps must be an number");
  if (radius === void 0)
    throw new Error("radius is required");
  if (steps <= 0)
    throw new Error("steps must be greater than 0");
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry2) {
        var buffered = bufferFeature(geometry2, radius, units, steps);
        if (buffered)
          results.push(buffered);
      });
      return featureCollection(results);
    case "FeatureCollection":
      featureEach(geojson, function(feature2) {
        var multiBuffered = bufferFeature(feature2, radius, units, steps);
        if (multiBuffered) {
          featureEach(multiBuffered, function(buffered) {
            if (buffered)
              results.push(buffered);
          });
        }
      });
      return featureCollection(results);
  }
  return bufferFeature(geojson, radius, units, steps);
}
function bufferFeature(geojson, radius, units, steps) {
  var properties = geojson.properties || {};
  var geometry2 = geojson.type === "Feature" ? geojson.geometry : geojson;
  if (geometry2.type === "GeometryCollection") {
    var results = [];
    geomEach(geojson, function(geometry3) {
      var buffered2 = bufferFeature(geometry3, radius, units, steps);
      if (buffered2)
        results.push(buffered2);
    });
    return featureCollection(results);
  }
  var projection = defineProjection(geometry2);
  var projected = {
    type: geometry2.type,
    coordinates: projectCoords(geometry2.coordinates, projection)
  };
  var reader = new GeoJSONReader();
  var geom = reader.read(projected);
  var distance11 = radiansToLength(lengthToRadians(radius, units), "meters");
  var buffered = BufferOp.bufferOp(geom, distance11, steps);
  var writer = new GeoJSONWriter();
  buffered = writer.write(buffered);
  if (coordsIsNaN(buffered.coordinates))
    return void 0;
  var result = {
    type: buffered.type,
    coordinates: unprojectCoords(buffered.coordinates, projection)
  };
  return feature(result, properties);
}
function coordsIsNaN(coords) {
  if (Array.isArray(coords[0]))
    return coordsIsNaN(coords[0]);
  return isNaN(coords[0]);
}
function projectCoords(coords, proj) {
  if (typeof coords[0] !== "object")
    return proj(coords);
  return coords.map(function(coord) {
    return projectCoords(coord, proj);
  });
}
function unprojectCoords(coords, proj) {
  if (typeof coords[0] !== "object")
    return proj.invert(coords);
  return coords.map(function(coord) {
    return unprojectCoords(coord, proj);
  });
}
function defineProjection(geojson) {
  var coords = es_default18(geojson).geometry.coordinates;
  var rotation = [-coords[0], -coords[1]];
  return azimuthalEquidistant_default().rotate(rotation).scale(earthRadius);
}
var es_default73 = buffer3;

// node_modules/@turf/union/dist/es/index.js
function union8(poly1, poly2, options) {
  if (options === void 0) {
    options = {};
  }
  var geom1 = getGeom(poly1);
  var geom2 = getGeom(poly2);
  var unioned = polygon_clipping_esm_default.union(geom1.coordinates, geom2.coordinates);
  if (unioned.length === 0)
    return null;
  if (unioned.length === 1)
    return polygon(unioned[0], options.properties);
  else
    return multiPolygon(unioned, options.properties);
}
var es_default74 = union8;

// node_modules/@turf/intersect/dist/es/index.js
function intersect3(poly1, poly2, options) {
  if (options === void 0) {
    options = {};
  }
  var geom1 = getGeom(poly1);
  var geom2 = getGeom(poly2);
  var intersection12 = polygon_clipping_esm_default.intersection(geom1.coordinates, geom2.coordinates);
  if (intersection12.length === 0)
    return null;
  if (intersection12.length === 1)
    return polygon(intersection12[0], options.properties);
  return multiPolygon(intersection12, options.properties);
}

// node_modules/@turf/dissolve/dist/es/index.js
function dissolve2(fc, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var propertyName = options.propertyName;
  collectionOf(fc, "Polygon", "dissolve");
  var outFeatures = [];
  if (!options.propertyName) {
    return es_default39(
      multiPolygon(
        polygon_clipping_esm_default.union.apply(
          null,
          fc.features.map(function(f) {
            return f.geometry.coordinates;
          })
        )
      )
    );
  } else {
    var uniquePropertyVals = {};
    featureEach(fc, function(feature2) {
      if (!Object.prototype.hasOwnProperty.call(
        uniquePropertyVals,
        feature2.properties[propertyName]
      )) {
        uniquePropertyVals[feature2.properties[propertyName]] = [];
      }
      uniquePropertyVals[feature2.properties[propertyName]].push(feature2);
    });
    var vals = Object.keys(uniquePropertyVals);
    for (var i = 0; i < vals.length; i++) {
      var mp = multiPolygon(
        polygon_clipping_esm_default.union.apply(
          null,
          uniquePropertyVals[vals[i]].map(function(f) {
            return f.geometry.coordinates;
          })
        )
      );
      mp.properties[propertyName] = vals[i];
      outFeatures.push(mp);
    }
  }
  return es_default39(featureCollection(outFeatures));
}
var es_default75 = dissolve2;

// node_modules/@turf/hex-grid/dist/es/index.js
function hexGrid(bbox3, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  var clonedProperties = JSON.stringify(options.properties || {});
  var west = bbox3[0], south = bbox3[1], east = bbox3[2], north = bbox3[3];
  var centerY = (south + north) / 2;
  var centerX = (west + east) / 2;
  var xFraction = cellSide * 2 / es_default4([west, centerY], [east, centerY], options);
  var cellWidth = xFraction * (east - west);
  var yFraction = cellSide * 2 / es_default4([centerX, south], [centerX, north], options);
  var cellHeight = yFraction * (north - south);
  var radius = cellWidth / 2;
  var hex_width = radius * 2;
  var hex_height = Math.sqrt(3) / 2 * cellHeight;
  var box_width = east - west;
  var box_height = north - south;
  var x_interval = 3 / 4 * hex_width;
  var y_interval = hex_height;
  var x_span = (box_width - hex_width) / (hex_width - radius / 2);
  var x_count = Math.floor(x_span);
  var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;
  var y_count = Math.floor((box_height - hex_height) / hex_height);
  var y_adjust = (box_height - y_count * hex_height) / 2;
  var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
  if (hasOffsetY) {
    y_adjust -= hex_height / 4;
  }
  var cosines = [];
  var sines = [];
  for (var i = 0; i < 6; i++) {
    var angle4 = 2 * Math.PI / 6 * i;
    cosines.push(Math.cos(angle4));
    sines.push(Math.sin(angle4));
  }
  var results = [];
  for (var x2 = 0; x2 <= x_count; x2++) {
    for (var y2 = 0; y2 <= y_count; y2++) {
      var isOdd = x2 % 2 === 1;
      if (y2 === 0 && isOdd)
        continue;
      if (y2 === 0 && hasOffsetY)
        continue;
      var center_x = x2 * x_interval + west - x_adjust;
      var center_y = y2 * y_interval + south + y_adjust;
      if (isOdd) {
        center_y -= hex_height / 2;
      }
      if (options.triangles === true) {
        hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function(triangle) {
          if (options.mask) {
            if (intersect3(options.mask, triangle))
              results.push(triangle);
          } else {
            results.push(triangle);
          }
        });
      } else {
        var hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
        if (options.mask) {
          if (intersect3(options.mask, hex))
            results.push(hex);
        } else {
          results.push(hex);
        }
      }
    }
  }
  return featureCollection(results);
}
function hexagon(center2, rx, ry, properties, cosines, sines) {
  var vertices = [];
  for (var i = 0; i < 6; i++) {
    var x2 = center2[0] + rx * cosines[i];
    var y2 = center2[1] + ry * sines[i];
    vertices.push([x2, y2]);
  }
  vertices.push(vertices[0].slice());
  return polygon([vertices], properties);
}
function hexTriangles(center2, rx, ry, properties, cosines, sines) {
  var triangles = [];
  for (var i = 0; i < 6; i++) {
    var vertices = [];
    vertices.push(center2);
    vertices.push([center2[0] + rx * cosines[i], center2[1] + ry * sines[i]]);
    vertices.push([
      center2[0] + rx * cosines[(i + 1) % 6],
      center2[1] + ry * sines[(i + 1) % 6]
    ]);
    vertices.push(center2);
    triangles.push(polygon([vertices], properties));
  }
  return triangles;
}
var es_default76 = hexGrid;

// node_modules/@turf/mask/dist/es/index.js
function mask(polygon4, mask2) {
  var maskPolygon = createMask(mask2);
  var polygonOuters = null;
  if (polygon4.type === "FeatureCollection")
    polygonOuters = unionFc(polygon4);
  else
    polygonOuters = createGeomFromPolygonClippingOutput(
      polygon_clipping_esm_default.union(polygon4.geometry.coordinates)
    );
  polygonOuters.geometry.coordinates.forEach(function(contour) {
    maskPolygon.geometry.coordinates.push(contour[0]);
  });
  return maskPolygon;
}
function unionFc(fc) {
  var unioned = fc.features.length === 2 ? polygon_clipping_esm_default.union(
    fc.features[0].geometry.coordinates,
    fc.features[1].geometry.coordinates
  ) : polygon_clipping_esm_default.union.apply(
    polygon_clipping_esm_default,
    fc.features.map(function(f) {
      return f.geometry.coordinates;
    })
  );
  return createGeomFromPolygonClippingOutput(unioned);
}
function createGeomFromPolygonClippingOutput(unioned) {
  return multiPolygon(unioned);
}
function createMask(mask2) {
  var world = [
    [
      [180, 90],
      [-180, 90],
      [-180, -90],
      [180, -90],
      [180, 90]
    ]
  ];
  var coordinates = mask2 && mask2.geometry.coordinates || world;
  return polygon(coordinates);
}
var es_default77 = mask;

// node_modules/@turf/rectangle-grid/dist/es/index.js
function rectangleGrid(bbox3, cellWidth, cellHeight, options) {
  if (options === void 0) {
    options = {};
  }
  var results = [];
  var west = bbox3[0];
  var south = bbox3[1];
  var east = bbox3[2];
  var north = bbox3[3];
  var xFraction = cellWidth / es_default4([west, south], [east, south], options);
  var cellWidthDeg = xFraction * (east - west);
  var yFraction = cellHeight / es_default4([west, south], [west, north], options);
  var cellHeightDeg = yFraction * (north - south);
  var bboxWidth = east - west;
  var bboxHeight = north - south;
  var columns = Math.floor(bboxWidth / cellWidthDeg);
  var rows = Math.floor(bboxHeight / cellHeightDeg);
  var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
  var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
  var currentX = west + deltaX;
  for (var column = 0; column < columns; column++) {
    var currentY = south + deltaY;
    for (var row = 0; row < rows; row++) {
      var cellPoly = polygon([
        [
          [currentX, currentY],
          [currentX, currentY + cellHeightDeg],
          [currentX + cellWidthDeg, currentY + cellHeightDeg],
          [currentX + cellWidthDeg, currentY],
          [currentX, currentY]
        ]
      ], options.properties);
      if (options.mask) {
        if (booleanIntersects(options.mask, cellPoly)) {
          results.push(cellPoly);
        }
      } else {
        results.push(cellPoly);
      }
      currentY += cellHeightDeg;
    }
    currentX += cellWidthDeg;
  }
  return featureCollection(results);
}
var es_default78 = rectangleGrid;

// node_modules/@turf/square-grid/dist/es/index.js
function squareGrid(bbox3, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  return es_default78(bbox3, cellSide, cellSide, options);
}

// node_modules/@turf/triangle-grid/dist/es/index.js
function triangleGrid(bbox3, cellSide, options) {
  if (options === void 0) {
    options = {};
  }
  var results = [];
  var xFraction = cellSide / es_default4([bbox3[0], bbox3[1]], [bbox3[2], bbox3[1]], options);
  var cellWidth = xFraction * (bbox3[2] - bbox3[0]);
  var yFraction = cellSide / es_default4([bbox3[0], bbox3[1]], [bbox3[0], bbox3[3]], options);
  var cellHeight = yFraction * (bbox3[3] - bbox3[1]);
  var xi = 0;
  var currentX = bbox3[0];
  while (currentX <= bbox3[2]) {
    var yi = 0;
    var currentY = bbox3[1];
    while (currentY <= bbox3[3]) {
      var cellTriangle1 = null;
      var cellTriangle2 = null;
      if (xi % 2 === 0 && yi % 2 === 0) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY + cellHeight]
          ]
        ], options.properties);
      } else if (xi % 2 === 0 && yi % 2 === 1) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX, currentY]
          ]
        ], options.properties);
      } else if (yi % 2 === 0 && xi % 2 === 1) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
      } else if (yi % 2 === 1 && xi % 2 === 1) {
        cellTriangle1 = polygon([
          [
            [currentX, currentY],
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY]
          ]
        ], options.properties);
        cellTriangle2 = polygon([
          [
            [currentX, currentY + cellHeight],
            [currentX + cellWidth, currentY + cellHeight],
            [currentX + cellWidth, currentY],
            [currentX, currentY + cellHeight]
          ]
        ], options.properties);
      }
      if (options.mask) {
        if (intersect3(options.mask, cellTriangle1))
          results.push(cellTriangle1);
        if (intersect3(options.mask, cellTriangle2))
          results.push(cellTriangle2);
      } else {
        results.push(cellTriangle1);
        results.push(cellTriangle2);
      }
      currentY += cellHeight;
      yi++;
    }
    xi++;
    currentX += cellWidth;
  }
  return featureCollection(results);
}
var es_default79 = triangleGrid;

// node_modules/@turf/interpolate/dist/es/index.js
function interpolate(points2, cellSize, options) {
  options = options || {};
  if (typeof options !== "object")
    throw new Error("options is invalid");
  var gridType = options.gridType;
  var property = options.property;
  var weight = options.weight;
  if (!points2)
    throw new Error("points is required");
  collectionOf(points2, "Point", "input must contain Points");
  if (!cellSize)
    throw new Error("cellSize is required");
  if (weight !== void 0 && typeof weight !== "number")
    throw new Error("weight must be a number");
  property = property || "elevation";
  gridType = gridType || "square";
  weight = weight || 1;
  var box = es_default(points2);
  var grid;
  switch (gridType) {
    case "point":
    case "points":
      grid = es_default37(box, cellSize, options);
      break;
    case "square":
    case "squares":
      grid = squareGrid(box, cellSize, options);
      break;
    case "hex":
    case "hexes":
      grid = es_default76(box, cellSize, options);
      break;
    case "triangle":
    case "triangles":
      grid = es_default79(box, cellSize, options);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var results = [];
  featureEach(grid, function(gridFeature) {
    var zw = 0;
    var sw = 0;
    featureEach(points2, function(point4) {
      var gridPoint = gridType === "point" ? gridFeature : es_default19(gridFeature);
      var d = es_default4(gridPoint, point4, options);
      var zValue;
      if (property !== void 0)
        zValue = point4.properties[property];
      if (zValue === void 0)
        zValue = point4.geometry.coordinates[2];
      if (zValue === void 0)
        throw new Error("zValue is missing");
      if (d === 0)
        zw = zValue;
      var w = 1 / Math.pow(d, weight);
      sw += w;
      zw += w * zValue;
    });
    var newFeature = es_default5(gridFeature);
    newFeature.properties[property] = zw / sw;
    results.push(newFeature);
  });
  return featureCollection(results);
}
var es_default80 = interpolate;
export {
  along,
  es_default69 as angle,
  applyFilter,
  area,
  areaFactors,
  es_default as bbox,
  bboxClip,
  bboxPolygon,
  bearing,
  bearingToAzimuth as bearingToAngle,
  bearingToAzimuth,
  es_default11 as bezier,
  es_default11 as bezierSpline,
  booleanClockwise,
  booleanContains,
  es_default58 as booleanCrosses,
  es_default57 as booleanDisjoint,
  es_default59 as booleanEqual,
  booleanIntersects,
  booleanOverlap,
  es_default62 as booleanParallel,
  booleanPointInPolygon,
  es_default35 as booleanPointOnLine,
  es_default36 as booleanWithin,
  es_default73 as buffer,
  es_default18 as center,
  es_default66 as centerMean,
  es_default67 as centerMedian,
  es_default20 as centerOfMass,
  es_default19 as centroid,
  es_default16 as circle,
  es_default9 as cleanCoords,
  es_default5 as clone,
  clusterEach,
  clusterReduce,
  es_exports6 as clusters,
  es_default60 as clustersDbscan,
  es_default61 as clustersKmeans,
  es_default7 as collect,
  collectionOf,
  es_default21 as combine,
  es_default6 as concave,
  containsNumber,
  convertArea,
  convertLength as convertDistance,
  convertLength,
  convex,
  coordAll,
  coordEach,
  coordReduce,
  createBins,
  degreesToRadians as degrees2radians,
  degreesToRadians,
  destination,
  es_default72 as difference,
  es_default75 as dissolve,
  es_default4 as distance,
  lengthToDegrees as distanceToDegrees,
  lengthToRadians as distanceToRadians,
  distanceWeight,
  earthRadius,
  es_default65 as ellipse,
  es_default14 as envelope,
  es_default22 as explode,
  factors,
  feature,
  featureCollection,
  featureEach,
  featureOf,
  featureReduce,
  filterProperties,
  findPoint,
  findSegment,
  es_default39 as flatten,
  flattenEach,
  flattenReduce,
  es_default8 as flip,
  geojsonType,
  geomEach,
  geomReduce,
  geometry,
  geometryCollection,
  getCluster,
  getCoord,
  getCoords,
  getGeom,
  getType,
  es_default42 as greatCircle,
  es_exports as helpers,
  es_default76 as hexGrid,
  booleanPointInPolygon as inside,
  es_default80 as interpolate,
  intersect3 as intersect,
  es_exports3 as invariant,
  isNumber,
  isObject,
  es_default52 as isobands,
  es_default2 as isolines,
  kinks,
  length,
  lengthToDegrees,
  lengthToRadians,
  lineArc,
  es_default40 as lineChunk,
  length as lineDistance,
  lineEach,
  es_default26 as lineIntersect,
  es_default56 as lineOffset,
  es_default46 as lineOverlap,
  lineReduce,
  es_default25 as lineSegment,
  es_default33 as lineSlice,
  es_default34 as lineSliceAlong,
  es_default43 as lineSplit,
  lineString,
  es_default45 as lineStringToPolygon,
  lineStrings,
  es_default45 as lineToPolygon,
  es_default77 as mask,
  es_exports2 as meta,
  es_default17 as midpoint,
  es_default71 as moranIndex,
  multiLineString,
  multiPoint,
  multiPolygon,
  es_default24 as nearest,
  es_default24 as nearestPoint,
  es_default27 as nearestPointOnLine,
  es_default30 as nearestPointToLine,
  es_default31 as planepoint,
  point,
  es_default37 as pointGrid,
  es_default32 as pointOnFeature,
  es_default27 as pointOnLine,
  es_default32 as pointOnSurface,
  es_default29 as pointToLineDistance,
  points,
  es_default3 as pointsWithinPolygon,
  polygon,
  es_default70 as polygonSmooth,
  es_default50 as polygonTangents,
  es_default44 as polygonToLine,
  es_default44 as polygonToLineString,
  polygonize,
  polygons,
  es_exports4 as projection,
  propEach,
  propReduce,
  propertiesContainsFilter,
  radiansToDegrees as radians2degrees,
  radiansToDegrees,
  radiansToLength as radiansToDistance,
  radiansToLength,
  es_exports5 as random,
  randomLineString,
  randomPoint,
  randomPolygon,
  randomPosition,
  es_default51 as rewind,
  es_default48 as rhumbBearing,
  es_default49 as rhumbDestination,
  es_default28 as rhumbDistance,
  round,
  es_default13 as sample,
  es_default47 as sector,
  segmentEach,
  segmentReduce,
  es_default63 as shortestPath,
  es_default10 as simplify,
  es_default15 as square,
  squareGrid,
  es_default68 as standardDeviationalEllipse,
  es_default12 as tag,
  es_default23 as tesselate,
  tin,
  toMercator,
  toWgs84,
  es_default53 as transformRotate,
  es_default54 as transformScale,
  es_default55 as transformTranslate,
  es_default79 as triangleGrid,
  es_default38 as truncate,
  es_default74 as union,
  unitsFactors,
  es_default41 as unkinkPolygon,
  validateBBox,
  validateId,
  es_default64 as voronoi,
  es_default3 as within
};
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@turf/isolines/dist/es/index.js:
  (**
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)

@turf/isobands/dist/es/index.js:
  (*!
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)

splaytree/dist/splay.esm.js:
  (**
   * splaytree v3.1.2
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@turf_turf.js.map
