import {
  Deck,
  Layer,
  View,
  init_esm12 as init_esm
} from "./chunk-T5R6RA5R.js";
import "./chunk-YAGFDRXW.js";
import {
  require_react
} from "./chunk-6CE3F7YD.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@deck.gl/react/dist/esm/deckgl.js
var import_react5 = __toESM(require_react());
init_esm();

// node_modules/@deck.gl/react/dist/esm/utils/use-isomorphic-layout-effect.js
var import_react = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
var use_isomorphic_layout_effect_default = useIsomorphicLayoutEffect;

// node_modules/@deck.gl/react/dist/esm/utils/extract-jsx-layers.js
var React = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/@deck.gl/react/dist/esm/utils/inherits-from.js
function inheritsFrom(Type, ParentType) {
  while (Type) {
    if (Type === ParentType) {
      return true;
    }
    Type = Object.getPrototypeOf(Type);
  }
  return false;
}

// node_modules/@deck.gl/react/dist/esm/utils/extract-jsx-layers.js
init_esm();

// node_modules/@deck.gl/react/dist/esm/utils/evaluate-children.js
var import_react2 = __toESM(require_react());
var MAP_STYLE = {
  position: "absolute",
  zIndex: -1
};
function evaluateChildren(children, childProps) {
  if (typeof children === "function") {
    return children(childProps);
  }
  if (Array.isArray(children)) {
    return children.map((child) => evaluateChildren(child, childProps));
  }
  if (isComponent(children)) {
    if (isReactMap(children)) {
      childProps.style = MAP_STYLE;
      return (0, import_react2.cloneElement)(children, childProps);
    }
    if (needsDeckGLViewProps(children)) {
      return (0, import_react2.cloneElement)(children, childProps);
    }
  }
  return children;
}
function isComponent(child) {
  return child && typeof child === "object" && "type" in child || false;
}
function isReactMap(child) {
  const componentClass = child.type;
  const componentProps = componentClass && componentClass.defaultProps;
  return componentProps && componentProps.mapStyle;
}
function needsDeckGLViewProps(child) {
  const componentClass = child.type;
  return componentClass && componentClass.deckGLViewProps;
}

// node_modules/@deck.gl/react/dist/esm/utils/extract-jsx-layers.js
function wrapInView(node) {
  if (typeof node === "function") {
    return (0, import_react3.createElement)(View, {}, node);
  }
  if (Array.isArray(node)) {
    return node.map(wrapInView);
  }
  if (isComponent(node)) {
    if (node.type === React.Fragment) {
      return wrapInView(node.props.children);
    }
    if (inheritsFrom(node.type, View)) {
      return node;
    }
  }
  return node;
}
function extractJSXLayers({
  children,
  layers = [],
  views = null
}) {
  const reactChildren = [];
  const jsxLayers = [];
  const jsxViews = {};
  React.Children.forEach(wrapInView(children), (reactElement) => {
    if (isComponent(reactElement)) {
      const ElementType = reactElement.type;
      if (inheritsFrom(ElementType, Layer)) {
        const layer = createLayer(ElementType, reactElement.props);
        jsxLayers.push(layer);
      } else {
        reactChildren.push(reactElement);
      }
      if (inheritsFrom(ElementType, View) && ElementType !== View && reactElement.props.id) {
        const view = new ElementType(reactElement.props);
        jsxViews[view.id] = view;
      }
    } else if (reactElement) {
      reactChildren.push(reactElement);
    }
  });
  if (Object.keys(jsxViews).length > 0) {
    if (Array.isArray(views)) {
      views.forEach((view) => {
        jsxViews[view.id] = view;
      });
    } else if (views) {
      jsxViews[views.id] = views;
    }
    views = Object.values(jsxViews);
  }
  layers = jsxLayers.length > 0 ? [...jsxLayers, ...layers] : layers;
  return {
    layers,
    children: reactChildren,
    views
  };
}
function createLayer(LayerType, reactProps) {
  const props = {};
  const defaultProps = LayerType.defaultProps || {};
  for (const key in reactProps) {
    if (defaultProps[key] !== reactProps[key]) {
      props[key] = reactProps[key];
    }
  }
  return new LayerType(props);
}

// node_modules/@deck.gl/react/dist/esm/utils/position-children-under-views.js
var import_react4 = __toESM(require_react());
init_esm();
function positionChildrenUnderViews({
  children,
  deck,
  ContextProvider
}) {
  const {
    viewManager
  } = deck || {};
  if (!viewManager || !viewManager.views.length) {
    return [];
  }
  const views = {};
  const defaultViewId = viewManager.views[0].id;
  for (const child of children) {
    let viewId = defaultViewId;
    let viewChildren = child;
    if (isComponent(child) && inheritsFrom(child.type, View)) {
      viewId = child.props.id || defaultViewId;
      viewChildren = child.props.children;
    }
    const viewport = viewManager.getViewport(viewId);
    const viewState = viewManager.getViewState(viewId);
    if (viewport) {
      viewState.padding = viewport.padding;
      const {
        x,
        y,
        width,
        height
      } = viewport;
      viewChildren = evaluateChildren(viewChildren, {
        x,
        y,
        width,
        height,
        viewport,
        viewState
      });
      if (!views[viewId]) {
        views[viewId] = {
          viewport,
          children: []
        };
      }
      views[viewId].children.push(viewChildren);
    }
  }
  return Object.keys(views).map((viewId) => {
    const {
      viewport,
      children: viewChildren
    } = views[viewId];
    const {
      x,
      y,
      width,
      height
    } = viewport;
    const style = {
      position: "absolute",
      left: x,
      top: y,
      width,
      height
    };
    const key = "view-".concat(viewId);
    const viewElement = (0, import_react4.createElement)("div", {
      key,
      id: key,
      style
    }, ...viewChildren);
    if (ContextProvider) {
      const contextValue = {
        viewport,
        container: deck.canvas.offsetParent,
        eventManager: deck.eventManager,
        onViewStateChange: (params) => {
          params.viewId = viewId;
          deck._onViewStateChange(params);
        }
      };
      return (0, import_react4.createElement)(ContextProvider, {
        key,
        value: contextValue
      }, viewElement);
    }
    return viewElement;
  });
}

// node_modules/@deck.gl/react/dist/esm/utils/extract-styles.js
var CANVAS_ONLY_STYLES = {
  mixBlendMode: null
};
function extractStyles({
  width,
  height,
  style
}) {
  const containerStyle = {
    position: "absolute",
    zIndex: 0,
    left: 0,
    top: 0,
    width,
    height
  };
  const canvasStyle = {
    left: 0,
    top: 0
  };
  if (style) {
    for (const key in style) {
      if (key in CANVAS_ONLY_STYLES) {
        canvasStyle[key] = style[key];
      } else {
        containerStyle[key] = style[key];
      }
    }
  }
  return {
    containerStyle,
    canvasStyle
  };
}

// node_modules/@deck.gl/react/dist/esm/deckgl.js
function getRefHandles(thisRef) {
  return {
    get deck() {
      return thisRef.deck;
    },
    pickObject: (opts) => thisRef.deck.pickObject(opts),
    pickMultipleObjects: (opts) => thisRef.deck.pickMultipleObjects(opts),
    pickObjects: (opts) => thisRef.deck.pickObjects(opts)
  };
}
function redrawDeck(thisRef) {
  if (thisRef.redrawReason) {
    thisRef.deck._drawLayers(thisRef.redrawReason);
    thisRef.redrawReason = null;
  }
}
function createDeckInstance(thisRef, DeckClass, props) {
  const deck = new DeckClass({
    ...props,
    _customRender: (redrawReason) => {
      thisRef.redrawReason = redrawReason;
      const viewports = deck.getViewports();
      if (thisRef.lastRenderedViewports !== viewports) {
        thisRef.forceUpdate();
      } else {
        redrawDeck(thisRef);
      }
    }
  });
  return deck;
}
var DeckGL = (0, import_react5.forwardRef)((props, ref) => {
  const [version, setVersion] = (0, import_react5.useState)(0);
  const _thisRef = (0, import_react5.useRef)({
    control: null,
    version,
    forceUpdate: () => setVersion((v) => v + 1)
  });
  const thisRef = _thisRef.current;
  const containerRef = (0, import_react5.useRef)(null);
  const canvasRef = (0, import_react5.useRef)(null);
  const jsxProps = (0, import_react5.useMemo)(() => extractJSXLayers(props), [props.layers, props.views, props.children]);
  let inRender = true;
  const handleViewStateChange = (params) => {
    var _props$onViewStateCha;
    if (inRender && props.viewState) {
      thisRef.viewStateUpdateRequested = params;
      return null;
    }
    thisRef.viewStateUpdateRequested = null;
    return (_props$onViewStateCha = props.onViewStateChange) === null || _props$onViewStateCha === void 0 ? void 0 : _props$onViewStateCha.call(props, params);
  };
  const handleInteractionStateChange = (params) => {
    if (inRender) {
      thisRef.interactionStateUpdateRequested = params;
    } else {
      var _props$onInteractionS;
      thisRef.interactionStateUpdateRequested = null;
      (_props$onInteractionS = props.onInteractionStateChange) === null || _props$onInteractionS === void 0 ? void 0 : _props$onInteractionS.call(props, params);
    }
  };
  const deckProps = (0, import_react5.useMemo)(() => {
    const forwardProps = {
      ...props,
      style: null,
      width: "100%",
      height: "100%",
      parent: containerRef.current,
      canvas: canvasRef.current,
      layers: jsxProps.layers,
      views: jsxProps.views,
      onViewStateChange: handleViewStateChange,
      onInteractionStateChange: handleInteractionStateChange
    };
    delete forwardProps._customRender;
    if (thisRef.deck) {
      thisRef.deck.setProps(forwardProps);
    }
    return forwardProps;
  }, [props]);
  (0, import_react5.useEffect)(() => {
    const DeckClass = props.Deck || Deck;
    thisRef.deck = createDeckInstance(thisRef, DeckClass, {
      ...deckProps,
      parent: containerRef.current,
      canvas: canvasRef.current
    });
    return () => {
      var _thisRef$deck;
      return (_thisRef$deck = thisRef.deck) === null || _thisRef$deck === void 0 ? void 0 : _thisRef$deck.finalize();
    };
  }, []);
  use_isomorphic_layout_effect_default(() => {
    redrawDeck(thisRef);
    const {
      viewStateUpdateRequested,
      interactionStateUpdateRequested
    } = thisRef;
    if (viewStateUpdateRequested) {
      handleViewStateChange(viewStateUpdateRequested);
    }
    if (interactionStateUpdateRequested) {
      handleInteractionStateChange(interactionStateUpdateRequested);
    }
  });
  (0, import_react5.useImperativeHandle)(ref, () => getRefHandles(thisRef), []);
  const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : void 0;
  const {
    ContextProvider,
    width,
    height,
    id,
    style
  } = props;
  const {
    containerStyle,
    canvasStyle
  } = (0, import_react5.useMemo)(() => extractStyles({
    width,
    height,
    style
  }), [width, height, style]);
  if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || thisRef.version !== version) {
    thisRef.lastRenderedViewports = currentViewports;
    thisRef.version = version;
    const childrenUnderViews = positionChildrenUnderViews({
      children: jsxProps.children,
      deck: thisRef.deck,
      ContextProvider
    });
    const canvas = (0, import_react5.createElement)("canvas", {
      key: "canvas",
      id: id || "deckgl-overlay",
      ref: canvasRef,
      style: canvasStyle
    });
    thisRef.control = (0, import_react5.createElement)("div", {
      id: "".concat(id || "deckgl", "-wrapper"),
      ref: containerRef,
      style: containerStyle
    }, [canvas, childrenUnderViews]);
  }
  inRender = false;
  return thisRef.control;
});
DeckGL.defaultProps = Deck.defaultProps;
var deckgl_default = DeckGL;
export {
  deckgl_default as DeckGL,
  deckgl_default as default
};
//# sourceMappingURL=@deck__gl_react.js.map
