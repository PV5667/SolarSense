import {
  ARRAY_TYPE,
  EPSILON,
  _defineProperty,
  add,
  add2,
  addMetersToLngLat,
  altitudeToFovy,
  angle,
  create,
  cross,
  determinant,
  dot,
  dot2,
  fitBounds,
  flyToViewport,
  fovyToAltitude,
  fromQuat,
  fromValues,
  frustum,
  getBounds,
  getDistanceScales,
  getFlyToDuration,
  getMeterZoom,
  getProjectionParameters,
  getViewMatrix,
  init_common,
  init_defineProperty,
  init_esm,
  init_mat4,
  init_vec2,
  init_vec3,
  init_vec4,
  invert,
  len,
  length,
  length2,
  lerp,
  lerp2,
  lngLatToWorld,
  lookAt,
  multiply,
  negate,
  normalize,
  normalize2,
  normalizeViewportProps,
  ortho,
  perspective,
  pixelsToWorld,
  rotate,
  rotateX,
  rotateX2,
  rotateY,
  rotateY2,
  rotateZ,
  rotateZ2,
  scale,
  scale2,
  sqrLen,
  squaredLength,
  sub,
  transformMat2,
  transformMat2d,
  transformMat3,
  transformMat32,
  transformMat4,
  transformMat42,
  transformMat43,
  transformQuat,
  transformQuat2,
  translate,
  transpose,
  unitsPerMeter,
  worldToLngLat,
  worldToPixels
} from "./chunk-YAGFDRXW.js";
import {
  __commonJS,
  __esm,
  __export,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}
var init_assert = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js"() {
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
var globals, self_, window_, global_, document_, isBrowser, matches, nodeVersion;
var init_globals = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js"() {
    globals = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_ = globals.self || globals.window || globals.global || {};
    window_ = globals.window || globals.self || globals.global || {};
    global_ = globals.global || globals.self || globals.window || {};
    document_ = globals.document || {};
    isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
    matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
    nodeVersion = matches && parseFloat(matches[1]) || 0;
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js
var VERSION;
var init_version = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"() {
    VERSION = true ? "3.3.3" : DEFAULT_VERSION;
    if (false) {
      console.error("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
    }
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}
var init_assert2 = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js"() {
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
var globals2, self_2, window_2, global_2, document_2, isBrowser2, isWorker, isMobile, matches2, nodeVersion2;
var init_globals2 = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js"() {
    globals2 = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_2 = globals2.self || globals2.window || globals2.global || {};
    window_2 = globals2.window || globals2.self || globals2.global || {};
    global_2 = globals2.global || globals2.self || globals2.window || {};
    document_2 = globals2.document || {};
    isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
    isWorker = typeof importScripts === "function";
    isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
    matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
    nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js
var WorkerJob;
var init_worker_job = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js"() {
    init_defineProperty();
    init_assert2();
    WorkerJob = class {
      constructor(jobName, workerThread) {
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "workerThread", void 0);
        _defineProperty(this, "isRunning", true);
        _defineProperty(this, "result", void 0);
        _defineProperty(this, "_resolve", () => {
        });
        _defineProperty(this, "_reject", () => {
        });
        this.name = jobName;
        this.workerThread = workerThread;
        this.result = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      postMessage(type, payload) {
        this.workerThread.postMessage({
          source: "loaders.gl",
          type,
          payload
        });
      }
      done(value) {
        assert2(this.isRunning);
        this.isRunning = false;
        this._resolve(value);
      }
      error(error2) {
        assert2(this.isRunning);
        this.isRunning = false;
        this._reject(error2);
      }
    };
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js
var Worker2;
var init_worker_threads_browser = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js"() {
    Worker2 = class {
      terminate() {
      }
    };
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js
function getLoadableWorkerURL(props) {
  assert2(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert2(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: "application/javascript"
  });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}
var workerURLCache;
var init_get_loadable_worker_url = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js"() {
    init_assert2();
    workerURLCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js
function getTransferList(object) {
  let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  let transfers = arguments.length > 2 ? arguments[2] : void 0;
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
var init_get_transfer_list = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"() {
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js
var NOOP, WorkerThread;
var init_worker_thread = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js"() {
    init_defineProperty();
    init_worker_threads_browser();
    init_globals2();
    init_assert2();
    init_get_loadable_worker_url();
    init_get_transfer_list();
    NOOP = () => {
    };
    WorkerThread = class {
      static isSupported() {
        return typeof Worker !== "undefined" && isBrowser2 || typeof Worker2 !== "undefined" && !isBrowser2;
      }
      constructor(props) {
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "source", void 0);
        _defineProperty(this, "url", void 0);
        _defineProperty(this, "terminated", false);
        _defineProperty(this, "worker", void 0);
        _defineProperty(this, "onMessage", void 0);
        _defineProperty(this, "onError", void 0);
        _defineProperty(this, "_loadableURL", "");
        const {
          name,
          source,
          url
        } = props;
        assert2(source || url);
        this.name = name;
        this.source = source;
        this.url = url;
        this.onMessage = NOOP;
        this.onError = (error2) => console.log(error2);
        this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
      }
      destroy() {
        this.onMessage = NOOP;
        this.onError = NOOP;
        this.worker.terminate();
        this.terminated = true;
      }
      get isRunning() {
        return Boolean(this.onMessage);
      }
      postMessage(data, transferList) {
        transferList = transferList || getTransferList(data);
        this.worker.postMessage(data, transferList);
      }
      _getErrorFromErrorEvent(event) {
        let message = "Failed to load ";
        message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
        if (event.message) {
          message += "".concat(event.message, " in ");
        }
        if (event.lineno) {
          message += ":".concat(event.lineno, ":").concat(event.colno);
        }
        return new Error(message);
      }
      _createBrowserWorker() {
        this._loadableURL = getLoadableWorkerURL({
          source: this.source,
          url: this.url
        });
        const worker = new Worker(this._loadableURL, {
          name: this.name
        });
        worker.onmessage = (event) => {
          if (!event.data) {
            this.onError(new Error("No data received"));
          } else {
            this.onMessage(event.data);
          }
        };
        worker.onerror = (error2) => {
          this.onError(this._getErrorFromErrorEvent(error2));
          this.terminated = true;
        };
        worker.onmessageerror = (event) => console.error(event);
        return worker;
      }
      _createNodeWorker() {
        let worker;
        if (this.url) {
          const absolute = this.url.includes(":/") || this.url.startsWith("/");
          const url = absolute ? this.url : "./".concat(this.url);
          worker = new Worker2(url, {
            eval: false
          });
        } else if (this.source) {
          worker = new Worker2(this.source, {
            eval: true
          });
        } else {
          throw new Error("no worker");
        }
        worker.on("message", (data) => {
          this.onMessage(data);
        });
        worker.on("error", (error2) => {
          this.onError(error2);
        });
        worker.on("exit", (code) => {
        });
        return worker;
      }
    };
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js
var WorkerPool;
var init_worker_pool = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js"() {
    init_defineProperty();
    init_globals2();
    init_worker_thread();
    init_worker_job();
    WorkerPool = class {
      static isSupported() {
        return WorkerThread.isSupported();
      }
      constructor(props) {
        _defineProperty(this, "name", "unnamed");
        _defineProperty(this, "source", void 0);
        _defineProperty(this, "url", void 0);
        _defineProperty(this, "maxConcurrency", 1);
        _defineProperty(this, "maxMobileConcurrency", 1);
        _defineProperty(this, "onDebug", () => {
        });
        _defineProperty(this, "reuseWorkers", true);
        _defineProperty(this, "props", {});
        _defineProperty(this, "jobQueue", []);
        _defineProperty(this, "idleQueue", []);
        _defineProperty(this, "count", 0);
        _defineProperty(this, "isDestroyed", false);
        this.source = props.source;
        this.url = props.url;
        this.setProps(props);
      }
      destroy() {
        this.idleQueue.forEach((worker) => worker.destroy());
        this.isDestroyed = true;
      }
      setProps(props) {
        this.props = {
          ...this.props,
          ...props
        };
        if (props.name !== void 0) {
          this.name = props.name;
        }
        if (props.maxConcurrency !== void 0) {
          this.maxConcurrency = props.maxConcurrency;
        }
        if (props.maxMobileConcurrency !== void 0) {
          this.maxMobileConcurrency = props.maxMobileConcurrency;
        }
        if (props.reuseWorkers !== void 0) {
          this.reuseWorkers = props.reuseWorkers;
        }
        if (props.onDebug !== void 0) {
          this.onDebug = props.onDebug;
        }
      }
      async startJob(name) {
        let onMessage2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (job, type, data) => job.done(data);
        let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (job, error2) => job.error(error2);
        const startPromise = new Promise((onStart) => {
          this.jobQueue.push({
            name,
            onMessage: onMessage2,
            onError,
            onStart
          });
          return this;
        });
        this._startQueuedJob();
        return await startPromise;
      }
      async _startQueuedJob() {
        if (!this.jobQueue.length) {
          return;
        }
        const workerThread = this._getAvailableWorker();
        if (!workerThread) {
          return;
        }
        const queuedJob = this.jobQueue.shift();
        if (queuedJob) {
          this.onDebug({
            message: "Starting job",
            name: queuedJob.name,
            workerThread,
            backlog: this.jobQueue.length
          });
          const job = new WorkerJob(queuedJob.name, workerThread);
          workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
          workerThread.onError = (error2) => queuedJob.onError(job, error2);
          queuedJob.onStart(job);
          try {
            await job.result;
          } finally {
            this.returnWorkerToQueue(workerThread);
          }
        }
      }
      returnWorkerToQueue(worker) {
        const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
        if (shouldDestroyWorker) {
          worker.destroy();
          this.count--;
        } else {
          this.idleQueue.push(worker);
        }
        if (!this.isDestroyed) {
          this._startQueuedJob();
        }
      }
      _getAvailableWorker() {
        if (this.idleQueue.length > 0) {
          return this.idleQueue.shift() || null;
        }
        if (this.count < this._getMaxConcurrency()) {
          this.count++;
          const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
          return new WorkerThread({
            name,
            source: this.source,
            url: this.url
          });
        }
        return null;
      }
      _getMaxConcurrency() {
        return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
      }
    };
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS, WorkerFarm;
var init_worker_farm = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js"() {
    init_defineProperty();
    init_worker_pool();
    init_worker_thread();
    DEFAULT_PROPS = {
      maxConcurrency: 3,
      maxMobileConcurrency: 1,
      reuseWorkers: true,
      onDebug: () => {
      }
    };
    WorkerFarm = class {
      static isSupported() {
        return WorkerThread.isSupported();
      }
      static getWorkerFarm() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
        WorkerFarm._workerFarm.setProps(props);
        return WorkerFarm._workerFarm;
      }
      constructor(props) {
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "workerPools", /* @__PURE__ */ new Map());
        this.props = {
          ...DEFAULT_PROPS
        };
        this.setProps(props);
        this.workerPools = /* @__PURE__ */ new Map();
      }
      destroy() {
        for (const workerPool of this.workerPools.values()) {
          workerPool.destroy();
        }
        this.workerPools = /* @__PURE__ */ new Map();
      }
      setProps(props) {
        this.props = {
          ...this.props,
          ...props
        };
        for (const workerPool of this.workerPools.values()) {
          workerPool.setProps(this._getWorkerPoolProps());
        }
      }
      getWorkerPool(options) {
        const {
          name,
          source,
          url
        } = options;
        let workerPool = this.workerPools.get(name);
        if (!workerPool) {
          workerPool = new WorkerPool({
            name,
            source,
            url
          });
          workerPool.setProps(this._getWorkerPoolProps());
          this.workerPools.set(name, workerPool);
        }
        return workerPool;
      }
      _getWorkerPoolProps() {
        return {
          maxConcurrency: this.props.maxConcurrency,
          maxMobileConcurrency: this.props.maxMobileConcurrency,
          reuseWorkers: this.props.reuseWorkers,
          onDebug: this.props.onDebug
        };
      }
    };
    _defineProperty(WorkerFarm, "_workerFarm", void 0);
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js
function getParentPort() {
  let parentPort;
  try {
    eval("globalThis.parentPort = require('worker_threads').parentPort");
    parentPort = globalThis.parentPort;
  } catch {
  }
  return parentPort;
}
function isKnownMessage(message) {
  const {
    type,
    data
  } = message;
  return type === "message" && data && typeof data.source === "string" && data.source.startsWith("loaders.gl");
}
var onMessageWrapperMap, WorkerBody;
var init_worker_body = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js"() {
    init_get_transfer_list();
    onMessageWrapperMap = /* @__PURE__ */ new Map();
    WorkerBody = class {
      static inWorkerThread() {
        return typeof self !== "undefined" || Boolean(getParentPort());
      }
      static set onmessage(onMessage2) {
        function handleMessage(message) {
          const parentPort3 = getParentPort();
          const {
            type,
            payload
          } = parentPort3 ? message : message.data;
          onMessage2(type, payload);
        }
        const parentPort2 = getParentPort();
        if (parentPort2) {
          parentPort2.on("message", handleMessage);
          parentPort2.on("exit", () => console.debug("Node worker closing"));
        } else {
          globalThis.onmessage = handleMessage;
        }
      }
      static addEventListener(onMessage2) {
        let onMessageWrapper = onMessageWrapperMap.get(onMessage2);
        if (!onMessageWrapper) {
          onMessageWrapper = (message) => {
            if (!isKnownMessage(message)) {
              return;
            }
            const parentPort3 = getParentPort();
            const {
              type,
              payload
            } = parentPort3 ? message : message.data;
            onMessage2(type, payload);
          };
        }
        const parentPort2 = getParentPort();
        if (parentPort2) {
          console.error("not implemented");
        } else {
          globalThis.addEventListener("message", onMessageWrapper);
        }
      }
      static removeEventListener(onMessage2) {
        const onMessageWrapper = onMessageWrapperMap.get(onMessage2);
        onMessageWrapperMap.delete(onMessage2);
        const parentPort2 = getParentPort();
        if (parentPort2) {
          console.error("not implemented");
        } else {
          globalThis.removeEventListener("message", onMessageWrapper);
        }
      }
      static postMessage(type, payload) {
        const data = {
          source: "loaders.gl",
          type,
          payload
        };
        const transferList = getTransferList(payload);
        const parentPort2 = getParentPort();
        if (parentPort2) {
          parentPort2.postMessage(data, transferList);
        } else {
          globalThis.postMessage(data, transferList);
        }
      }
    };
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js
function getWorkerURL(worker) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const workerOptions = options[worker.id] || {};
  const workerFile = "".concat(worker.id, "-worker.js");
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }
  if (!url) {
    let version = worker.version;
    if (version === "latest") {
      version = NPM_TAG;
    }
    const versionTag = version ? "@".concat(version) : "";
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }
  assert2(url);
  return url;
}
var NPM_TAG;
var init_get_worker_url = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js"() {
    init_assert2();
    init_version();
    NPM_TAG = "latest";
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js
var init_process_on_worker = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js"() {
    init_worker_farm();
    init_get_worker_url();
    init_get_transfer_list();
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js
var _Symbol$asyncIterator, AsyncQueue;
var init_async_queue = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js"() {
    init_defineProperty();
    _Symbol$asyncIterator = Symbol.asyncIterator;
    AsyncQueue = class {
      constructor() {
        _defineProperty(this, "_values", void 0);
        _defineProperty(this, "_settlers", void 0);
        _defineProperty(this, "_closed", void 0);
        this._values = [];
        this._settlers = [];
        this._closed = false;
      }
      [_Symbol$asyncIterator]() {
        return this;
      }
      push(value) {
        return this.enqueue(value);
      }
      enqueue(value) {
        if (this._closed) {
          throw new Error("Closed");
        }
        if (this._settlers.length > 0) {
          if (this._values.length > 0) {
            throw new Error("Illegal internal state");
          }
          const settler = this._settlers.shift();
          if (value instanceof Error) {
            settler.reject(value);
          } else {
            settler.resolve({
              value
            });
          }
        } else {
          this._values.push(value);
        }
      }
      close() {
        while (this._settlers.length > 0) {
          const settler = this._settlers.shift();
          settler.resolve({
            done: true
          });
        }
        this._closed = true;
      }
      next() {
        if (this._values.length > 0) {
          const value = this._values.shift();
          if (value instanceof Error) {
            return Promise.reject(value);
          }
          return Promise.resolve({
            done: false,
            value
          });
        }
        if (this._closed) {
          if (this._settlers.length > 0) {
            throw new Error("Illegal internal state");
          }
          return Promise.resolve({
            done: true,
            value: void 0
          });
        }
        return new Promise((resolve, reject) => {
          this._settlers.push({
            resolve,
            reject
          });
        });
      }
    };
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js
var init_create_worker = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js"() {
    init_async_queue();
    init_worker_body();
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker) {
  let coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION;
  assert2(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}
var init_validate_worker_version = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js"() {
    init_assert2();
    init_version();
  }
});

// (disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node
var require_require_utils = __commonJS({
  "(disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node"() {
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js
async function loadLibrary(libraryUrl) {
  let moduleName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }
  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith("http")) {
    return library;
  }
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }
  if (!isBrowser2) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }
  if (options.CDN) {
    assert2(options.CDN.startsWith("http"));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION2, "/dist/libs/").concat(library);
  }
  if (isWorker) {
    return "../src/libs/".concat(library);
  }
  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith("wasm")) {
    const response2 = await fetch(libraryUrl);
    return await response2.arrayBuffer();
  }
  if (!isBrowser2) {
    try {
      return node && void 0 && await (void 0)(libraryUrl);
    } catch {
      return null;
    }
  }
  if (isWorker) {
    return importScripts(libraryUrl);
  }
  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!isBrowser2) {
    return void 0 && (void 0)(scriptSource, id);
  }
  if (isWorker) {
    eval.call(global_2, scriptSource);
    return null;
  }
  const script = document.createElement("script");
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e2) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}
var node, VERSION2, loadLibraryPromises;
var init_library_utils = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js"() {
    init_globals2();
    node = __toESM(require_require_utils());
    init_assert2();
    init_version();
    VERSION2 = true ? "3.3.3" : LATEST;
    loadLibraryPromises = {};
  }
});

// (disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/child-process-proxy
var require_child_process_proxy = __commonJS({
  "(disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/child-process-proxy"() {
  }
});

// node_modules/@loaders.gl/worker-utils/dist/esm/index.js
var import_child_process_proxy;
var init_esm2 = __esm({
  "node_modules/@loaders.gl/worker-utils/dist/esm/index.js"() {
    init_version();
    init_assert2();
    init_globals2();
    init_worker_job();
    init_worker_thread();
    init_worker_farm();
    init_worker_pool();
    init_worker_body();
    init_process_on_worker();
    init_create_worker();
    init_get_worker_url();
    init_validate_worker_version();
    init_get_transfer_list();
    init_library_utils();
    init_async_queue();
    import_child_process_proxy = __toESM(require_child_process_proxy());
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js
var init_create_loader_worker = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js"() {
    init_esm2();
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser2 && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob(
    "process-on-worker",
    onMessage.bind(null, parseOnMainThread)
  );
  job.postMessage("process", {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const {
        id,
        input,
        options
      } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", {
          id,
          result
        });
      } catch (error2) {
        const message = error2 instanceof Error ? error2.message : "unknown error";
        job.postMessage("error", {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(type));
  }
}
var init_parse_with_worker = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js"() {
    init_esm2();
    init_esm2();
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js
var init_encode_with_worker = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js"() {
    init_esm2();
    init_globals();
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
function getFirstCharacters(data) {
  let length4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  if (typeof data === "string") {
    return data.slice(0, length4);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length4);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length4);
  }
  return "";
}
function getMagicString(arrayBuffer2, byteOffset, length4) {
  if (arrayBuffer2.byteLength <= byteOffset + length4) {
    return "";
  }
  const dataView = new DataView(arrayBuffer2);
  let magic = "";
  for (let i = 0; i < length4; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
var init_get_first_characters = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js"() {
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error('Failed to parse JSON from data starting with "'.concat(getFirstCharacters(string), '"'));
  }
}
var init_parse_json = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js"() {
    init_get_first_characters();
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array12 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array12.length; ++i) {
    if (array12[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length4, typedArray) => length4 + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }
  const arrays = typedArrays;
  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }
  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
  const result = new TypedArrayConstructor(sumLength);
  let offset = 0;
  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
}
function sliceArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
  const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer2).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer2).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
var init_array_buffer_utils = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js"() {
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
function padToNBytes(byteLength, padding) {
  assert(byteLength >= 0);
  assert(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
var init_memory_copy_utils = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js"() {
    init_assert();
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/dataview-copy-utils.js
var init_dataview_copy_utils = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/dataview-copy-utils.js"() {
    init_memory_copy_utils();
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js
var init_text_iterators = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js"() {
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}
var init_async_iteration = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js"() {
    init_array_buffer_utils();
  }
});

// node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== "undefined" && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== "undefined" && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
var init_hi_res_timestamp = __esm({
  "node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"() {
  }
});

// node_modules/@probe.gl/stats/dist/esm/lib/stat.js
var Stat;
var init_stat = __esm({
  "node_modules/@probe.gl/stats/dist/esm/lib/stat.js"() {
    init_defineProperty();
    init_hi_res_timestamp();
    Stat = class {
      constructor(name, type) {
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "sampleSize", 1);
        _defineProperty(this, "time", void 0);
        _defineProperty(this, "count", void 0);
        _defineProperty(this, "samples", void 0);
        _defineProperty(this, "lastTiming", void 0);
        _defineProperty(this, "lastSampleTime", void 0);
        _defineProperty(this, "lastSampleCount", void 0);
        _defineProperty(this, "_count", 0);
        _defineProperty(this, "_time", 0);
        _defineProperty(this, "_samples", 0);
        _defineProperty(this, "_startTime", 0);
        _defineProperty(this, "_timerPending", false);
        this.name = name;
        this.type = type;
        this.reset();
      }
      setSampleSize(samples) {
        this.sampleSize = samples;
        return this;
      }
      incrementCount() {
        this.addCount(1);
        return this;
      }
      decrementCount() {
        this.subtractCount(1);
        return this;
      }
      addCount(value) {
        this._count += value;
        this._samples++;
        this._checkSampling();
        return this;
      }
      subtractCount(value) {
        this._count -= value;
        this._samples++;
        this._checkSampling();
        return this;
      }
      addTime(time) {
        this._time += time;
        this.lastTiming = time;
        this._samples++;
        this._checkSampling();
        return this;
      }
      timeStart() {
        this._startTime = getHiResTimestamp();
        this._timerPending = true;
        return this;
      }
      timeEnd() {
        if (!this._timerPending) {
          return this;
        }
        this.addTime(getHiResTimestamp() - this._startTime);
        this._timerPending = false;
        this._checkSampling();
        return this;
      }
      getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
      }
      getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
      }
      getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
      }
      getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
      }
      getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
      }
      getHz() {
        return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
      }
      reset() {
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        return this;
      }
      _checkSampling() {
        if (this._samples === this.sampleSize) {
          this.lastSampleTime = this._time;
          this.lastSampleCount = this._count;
          this.count += this._count;
          this.time += this._time;
          this.samples += this._samples;
          this._time = 0;
          this._count = 0;
          this._samples = 0;
        }
      }
    };
  }
});

// node_modules/@probe.gl/stats/dist/esm/lib/stats.js
var Stats;
var init_stats = __esm({
  "node_modules/@probe.gl/stats/dist/esm/lib/stats.js"() {
    init_defineProperty();
    init_stat();
    Stats = class {
      constructor(options) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "stats", {});
        this.id = options.id;
        this.stats = {};
        this._initializeStats(options.stats);
        Object.seal(this);
      }
      get(name) {
        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
        return this._getOrCreate({
          name,
          type
        });
      }
      get size() {
        return Object.keys(this.stats).length;
      }
      reset() {
        for (const key in this.stats) {
          this.stats[key].reset();
        }
        return this;
      }
      forEach(fn) {
        for (const key in this.stats) {
          fn(this.stats[key]);
        }
      }
      getTable() {
        const table = {};
        this.forEach((stat2) => {
          table[stat2.name] = {
            time: stat2.time || 0,
            count: stat2.count || 0,
            average: stat2.getAverageTime() || 0,
            hz: stat2.getHz() || 0
          };
        });
        return table;
      }
      _initializeStats() {
        let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        stats.forEach((stat2) => this._getOrCreate(stat2));
      }
      _getOrCreate(stat2) {
        if (!stat2 || !stat2.name) {
          return null;
        }
        const {
          name,
          type
        } = stat2;
        if (!this.stats[name]) {
          if (stat2 instanceof Stat) {
            this.stats[name] = stat2;
          } else {
            this.stats[name] = new Stat(name, type);
          }
        }
        return this.stats[name];
      }
    };
  }
});

// node_modules/@probe.gl/stats/dist/esm/index.js
var init_esm3 = __esm({
  "node_modules/@probe.gl/stats/dist/esm/index.js"() {
    init_stats();
    init_stat();
    init_hi_res_timestamp();
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
var STAT_QUEUED_REQUESTS, STAT_ACTIVE_REQUESTS, STAT_CANCELLED_REQUESTS, STAT_QUEUED_REQUESTS_EVER, STAT_ACTIVE_REQUESTS_EVER, DEFAULT_PROPS2, RequestScheduler;
var init_request_scheduler = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js"() {
    init_defineProperty();
    init_esm3();
    STAT_QUEUED_REQUESTS = "Queued Requests";
    STAT_ACTIVE_REQUESTS = "Active Requests";
    STAT_CANCELLED_REQUESTS = "Cancelled Requests";
    STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
    STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
    DEFAULT_PROPS2 = {
      id: "request-scheduler",
      throttleRequests: true,
      maxRequests: 6
    };
    RequestScheduler = class {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "stats", void 0);
        _defineProperty(this, "activeRequestCount", 0);
        _defineProperty(this, "requestQueue", []);
        _defineProperty(this, "requestMap", /* @__PURE__ */ new Map());
        _defineProperty(this, "deferredUpdate", null);
        this.props = {
          ...DEFAULT_PROPS2,
          ...props
        };
        this.stats = new Stats({
          id: this.props.id
        });
        this.stats.get(STAT_QUEUED_REQUESTS);
        this.stats.get(STAT_ACTIVE_REQUESTS);
        this.stats.get(STAT_CANCELLED_REQUESTS);
        this.stats.get(STAT_QUEUED_REQUESTS_EVER);
        this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
      }
      scheduleRequest(handle) {
        let getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
        if (!this.props.throttleRequests) {
          return Promise.resolve({
            done: () => {
            }
          });
        }
        if (this.requestMap.has(handle)) {
          return this.requestMap.get(handle);
        }
        const request = {
          handle,
          priority: 0,
          getPriority
        };
        const promise = new Promise((resolve) => {
          request.resolve = resolve;
          return request;
        });
        this.requestQueue.push(request);
        this.requestMap.set(handle, promise);
        this._issueNewRequests();
        return promise;
      }
      _issueRequest(request) {
        const {
          handle,
          resolve
        } = request;
        let isDone = false;
        const done = () => {
          if (!isDone) {
            isDone = true;
            this.requestMap.delete(handle);
            this.activeRequestCount--;
            this._issueNewRequests();
          }
        };
        this.activeRequestCount++;
        return resolve ? resolve({
          done
        }) : Promise.resolve({
          done
        });
      }
      _issueNewRequests() {
        if (!this.deferredUpdate) {
          this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
        }
      }
      _issueNewRequestsAsync() {
        this.deferredUpdate = null;
        const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
        if (freeSlots === 0) {
          return;
        }
        this._updateAllRequests();
        for (let i = 0; i < freeSlots; ++i) {
          const request = this.requestQueue.shift();
          if (request) {
            this._issueRequest(request);
          }
        }
      }
      _updateAllRequests() {
        const requestQueue = this.requestQueue;
        for (let i = 0; i < requestQueue.length; ++i) {
          const request = requestQueue[i];
          if (!this._updateRequest(request)) {
            requestQueue.splice(i, 1);
            this.requestMap.delete(request.handle);
            i--;
          }
        }
        requestQueue.sort((a, b) => a.priority - b.priority);
      }
      _updateRequest(request) {
        request.priority = request.getPriority(request.handle);
        if (request.priority < 0) {
          request.resolve(null);
          return false;
        }
        return true;
      }
    };
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
function resolvePath(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = "".concat(pathPrefix).concat(filename2);
  }
  return filename2;
}
var pathPrefix, fileAliases;
var init_file_aliases = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js"() {
    pathPrefix = "";
    fileAliases = {};
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js
var init_json_loader = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js"() {
  }
});

// (disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer
var require_buffer = __commonJS({
  "(disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer"() {
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer2(data) {
  if (isBuffer(data)) {
    return (void 0)(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}
var node2;
var init_memory_conversion_utils = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js"() {
    node2 = __toESM(require_buffer());
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js
var init_promisify = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js"() {
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
var path_exports = {};
__export(path_exports, {
  dirname: () => dirname,
  filename: () => filename,
  join: () => join
});
function filename(url) {
  const slashIndex = url && url.lastIndexOf("/");
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url && url.lastIndexOf("/");
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), "");
    }
    return part;
  });
  return parts.join(separator);
}
var init_path = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js"() {
  }
});

// (disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs
var require_fs = __commonJS({
  "(disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs"() {
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/stream.js
var import_stream, Transform, isSupported;
var init_stream = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/stream.js"() {
    import_stream = __toESM(require_stream());
    isSupported = Boolean(import_stream.default);
    try {
      Transform = import_stream.default.Transform;
    } catch {
    }
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/readable-file.js
var init_readable_file = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/readable-file.js"() {
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/writable-file.js
var fs;
var init_writable_file = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/writable-file.js"() {
    init_esm4();
    fs = __toESM(require_fs());
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js
var fs2;
var init_node_filesystem = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js"() {
    fs2 = __toESM(require_fs());
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/index.js
var fs3;
var init_esm4 = __esm({
  "node_modules/@loaders.gl/loader-utils/dist/esm/index.js"() {
    init_assert();
    init_globals();
    init_create_loader_worker();
    init_parse_with_worker();
    init_encode_with_worker();
    init_parse_json();
    init_array_buffer_utils();
    init_memory_copy_utils();
    init_dataview_copy_utils();
    init_get_first_characters();
    init_text_iterators();
    init_async_iteration();
    init_request_scheduler();
    init_file_aliases();
    init_file_aliases();
    init_json_loader();
    init_memory_conversion_utils();
    init_promisify();
    init_path();
    fs3 = __toESM(require_fs());
    init_stream();
    init_readable_file();
    init_writable_file();
    init_node_filesystem();
  }
});

// node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
var isBoolean, isFunction, isObject, isPureObject, isIterable, isAsyncIterable, isResponse, isBlob, isBuffer2, isReadableDOMStream, isReadableNodeStream, isReadableStream;
var init_is_type = __esm({
  "node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"() {
    isBoolean = (x) => typeof x === "boolean";
    isFunction = (x) => typeof x === "function";
    isObject = (x) => x !== null && typeof x === "object";
    isPureObject = (x) => isObject(x) && x.constructor === {}.constructor;
    isIterable = (x) => x && typeof x[Symbol.iterator] === "function";
    isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === "function";
    isResponse = (x) => typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
    isBlob = (x) => typeof Blob !== "undefined" && x instanceof Blob;
    isBuffer2 = (x) => x && typeof x === "object" && x.isBuffer;
    isReadableDOMStream = (x) => typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
    isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
    isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
function parseMIMEType(mimeString) {
  const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches3) {
    return matches3[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches3 = DATA_URL_PATTERN.exec(url);
  if (matches3) {
    return matches3[1];
  }
  return "";
}
var DATA_URL_PATTERN, MIME_TYPE_PATTERN;
var init_mime_type_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js"() {
    DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
    MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
function getResourceUrlAndType(resource) {
  if (isResponse(resource)) {
    const url = stripQueryString(resource.url || "");
    const contentTypeHeader = resource.headers.get("content-type") || "";
    return {
      url,
      type: parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(url)
    };
  }
  if (isBlob(resource)) {
    return {
      url: stripQueryString(resource.name || ""),
      type: resource.type || ""
    };
  }
  if (typeof resource === "string") {
    return {
      url: stripQueryString(resource),
      type: parseMIMETypeFromURL(resource)
    };
  }
  return {
    url: "",
    type: ""
  };
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    return resource.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    return resource.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}
var QUERY_STRING_PATTERN;
var init_resource_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"() {
    init_is_type();
    init_mime_type_utils();
    QUERY_STRING_PATTERN = /\?.*/;
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const {
    url,
    type
  } = getResourceUrlAndType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, "url", {
    value: url
  });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}
async function getResponseError(response) {
  let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
  try {
    const contentType = response.headers.get("Content-Type");
    let text = response.statusText;
    if (contentType.includes("application/json")) {
      text += " ".concat(await response.text());
    }
    message += text;
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
  } catch (error2) {
  }
  return message;
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (event) => {
        var _event$target;
        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return "data:base64,".concat(base64);
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
var init_response_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"() {
    init_is_type();
    init_resource_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
async function fetchFile(url, options) {
  if (typeof url === "string") {
    url = resolvePath(url);
    let fetchOptions = options;
    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== "function") {
      fetchOptions = options.fetch;
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(url);
}
var init_fetch_file = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js"() {
    init_esm4();
    init_response_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js
var init_read_array_buffer = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js"() {
    init_esm4();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js
var init_read_file = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js"() {
    init_esm4();
    init_esm4();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js
var init_write_file = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js"() {
    init_esm4();
    init_esm4();
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
  const userAgent2 = mockUserAgent || realUserAgent;
  if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
    return true;
  }
  return false;
}
var init_is_electron = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/is-electron.js"() {
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
function isBrowser3() {
  const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
  return !isNode || isElectron();
}
var init_is_browser = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/is-browser.js"() {
    init_is_electron();
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/globals.js
var globals3, self_3, window_3, document_3, process_;
var init_globals3 = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/globals.js"() {
    globals3 = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document,
      process: typeof process === "object" && process
    };
    self_3 = globals3.self || globals3.window || globals3.global;
    window_3 = globals3.window || globals3.self || globals3.global;
    document_3 = globals3.document || {};
    process_ = globals3.process || {};
  }
});

// node_modules/@probe.gl/env/dist/esm/utils/globals.js
var VERSION3, isBrowser4;
var init_globals4 = __esm({
  "node_modules/@probe.gl/env/dist/esm/utils/globals.js"() {
    init_is_browser();
    init_globals3();
    VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
    isBrowser4 = isBrowser3();
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !isBrowser3()) {
    return "Node";
  }
  if (isElectron(mockUserAgent)) {
    return "Electron";
  }
  const navigator_ = typeof navigator !== "undefined" ? navigator : {};
  const userAgent2 = mockUserAgent || navigator_.userAgent || "";
  if (userAgent2.indexOf("Edge") > -1) {
    return "Edge";
  }
  const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
  const isTrident = userAgent2.indexOf("Trident/") !== -1;
  if (isMSIE || isTrident) {
    return "IE";
  }
  if (window2.chrome) {
    return "Chrome";
  }
  if (window2.safari) {
    return "Safari";
  }
  if (window2.mozInnerScreenX) {
    return "Firefox";
  }
  return "Unknown";
}
var window2;
var init_get_browser = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/get-browser.js"() {
    init_is_browser();
    init_is_electron();
    window2 = globalThis;
  }
});

// node_modules/@probe.gl/env/dist/esm/utils/assert.js
var init_assert3 = __esm({
  "node_modules/@probe.gl/env/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@probe.gl/env/dist/esm/index.js
var init_esm5 = __esm({
  "node_modules/@probe.gl/env/dist/esm/index.js"() {
    init_globals4();
    init_globals3();
    init_is_browser();
    init_get_browser();
    init_is_electron();
    init_assert3();
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e2) {
    return null;
  }
}
var LocalStorage;
var init_local_storage = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/local-storage.js"() {
    init_defineProperty();
    LocalStorage = class {
      constructor(id, defaultConfig) {
        let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
        _defineProperty(this, "storage", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "config", void 0);
        this.storage = getStorage(type);
        this.id = id;
        this.config = defaultConfig;
        this._loadConfiguration();
      }
      getConfiguration() {
        return this.config;
      }
      setConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
          const serialized = JSON.stringify(this.config);
          this.storage.setItem(this.id, serialized);
        }
      }
      _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
          const serializedConfiguration = this.storage.getItem(this.id);
          configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
      }
    };
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1e3) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1e3).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const padLength = Math.max(length4 - string.length, 0);
  return "".concat(" ".repeat(padLength)).concat(string);
}
function formatImage(image, message, scale5) {
  let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  if (image.width > maxWidth) {
    scale5 = Math.min(scale5, maxWidth / image.width);
  }
  const width = image.width * scale5;
  const height = image.height * scale5;
  const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
  return ["".concat(message, " %c+"), style];
}
var init_formatters = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/formatters.js"() {
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/color.js
function getColor(color) {
  return typeof color === "string" ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}
function addColor(string, color, background) {
  if (!isBrowser3 && typeof string === "string") {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}
var COLOR;
var init_color = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/color.js"() {
    init_esm5();
    (function(COLOR2) {
      COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
      COLOR2[COLOR2["RED"] = 31] = "RED";
      COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
      COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
      COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
      COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
      COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
      COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
      COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
      COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
      COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
      COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
      COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
      COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
      COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
      COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
    })(COLOR || (COLOR = {}));
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/autobind.js
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  for (const key of propNames) {
    if (typeof obj[key] === "function") {
      if (!predefined.find((name) => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}
var init_autobind = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/autobind.js"() {
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var init_assert4 = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp2() {
  let timestamp;
  if (isBrowser3 && "performance" in window_3) {
    var _window$performance, _window$performance$n;
    timestamp = window_3 === null || window_3 === void 0 ? void 0 : (_window$performance = window_3.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ("hrtime" in process_) {
    var _process$hrtime;
    const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
var init_hi_res_timestamp2 = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js"() {
    init_esm5();
  }
});

// node_modules/@probe.gl/log/dist/esm/log.js
function noop() {
}
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert4(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message !== void 0) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert4(messageType === "string" || messageType === "object");
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = addColor(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = "",
    scale: scale5 = 1
  } = _ref2;
  console.warn("removed");
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = "",
    scale: scale5 = 1
  } = _ref3;
  if (typeof image === "string") {
    const img = new Image();
    img.onload = () => {
      const args = formatImage(img, message, scale5);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || "";
  if (element.toLowerCase() === "img") {
    console.log(...formatImage(image, message, scale5));
    return noop;
  }
  if (element.toLowerCase() === "canvas") {
    const img = new Image();
    img.onload = () => console.log(...formatImage(img, message, scale5));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}
var originalConsole, DEFAULT_SETTINGS, cache, ONCE, Log;
var init_log = __esm({
  "node_modules/@probe.gl/log/dist/esm/log.js"() {
    init_defineProperty();
    init_esm5();
    init_local_storage();
    init_formatters();
    init_color();
    init_autobind();
    init_assert4();
    init_hi_res_timestamp2();
    originalConsole = {
      debug: isBrowser3 ? console.debug || console.log : console.log,
      log: console.log,
      info: console.info,
      warn: console.warn,
      error: console.error
    };
    DEFAULT_SETTINGS = {
      enabled: true,
      level: 0
    };
    cache = {};
    ONCE = {
      once: true
    };
    Log = class {
      constructor() {
        let {
          id
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          id: ""
        };
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "VERSION", VERSION3);
        _defineProperty(this, "_startTs", getHiResTimestamp2());
        _defineProperty(this, "_deltaTs", getHiResTimestamp2());
        _defineProperty(this, "_storage", void 0);
        _defineProperty(this, "userData", {});
        _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
        this.id = id;
        this.userData = {};
        this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
        this.timeStamp("".concat(this.id, " started"));
        autobind(this);
        Object.seal(this);
      }
      set level(newLevel) {
        this.setLevel(newLevel);
      }
      get level() {
        return this.getLevel();
      }
      isEnabled() {
        return this._storage.config.enabled;
      }
      getLevel() {
        return this._storage.config.level;
      }
      getTotal() {
        return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
      }
      getDelta() {
        return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
      }
      set priority(newPriority) {
        this.level = newPriority;
      }
      get priority() {
        return this.level;
      }
      getPriority() {
        return this.level;
      }
      enable() {
        let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this._storage.setConfiguration({
          enabled
        });
        return this;
      }
      setLevel(level) {
        this._storage.setConfiguration({
          level
        });
        return this;
      }
      get(setting) {
        return this._storage.config[setting];
      }
      set(setting, value) {
        this._storage.setConfiguration({
          [setting]: value
        });
      }
      settings() {
        if (console.table) {
          console.table(this._storage.config);
        } else {
          console.log(this._storage.config);
        }
      }
      assert(condition, message) {
        assert4(condition, message);
      }
      warn(message) {
        return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
      }
      error(message) {
        return this._getLogFunction(0, message, originalConsole.error, arguments);
      }
      deprecated(oldUsage, newUsage) {
        return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
      }
      removed(oldUsage, newUsage) {
        return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
      }
      probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
          time: true,
          once: true
        });
      }
      log(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
      }
      info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
      }
      once(logLevel, message) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
      }
      table(logLevel, table, columns) {
        if (table) {
          return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
            tag: getTableHeader(table)
          });
        }
        return noop;
      }
      image(_ref) {
        let {
          logLevel,
          priority,
          image,
          message = "",
          scale: scale5 = 1
        } = _ref;
        if (!this._shouldLog(logLevel || priority)) {
          return noop;
        }
        return isBrowser3 ? logImageInBrowser({
          image,
          message,
          scale: scale5
        }) : logImageInNode({
          image,
          message,
          scale: scale5
        });
      }
      time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
      }
      timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
      }
      timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || noop);
      }
      group(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          collapsed: false
        };
        const options = normalizeArguments({
          logLevel,
          message,
          opts
        });
        const {
          collapsed
        } = opts;
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
      }
      groupCollapsed(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.group(logLevel, message, Object.assign({}, opts, {
          collapsed: true
        }));
      }
      groupEnd(logLevel) {
        return this._getLogFunction(logLevel, "", console.groupEnd || noop);
      }
      withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
          func();
        } finally {
          this.groupEnd(logLevel)();
        }
      }
      trace() {
        if (console.trace) {
          console.trace();
        }
      }
      _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
      }
      _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
          opts = normalizeArguments({
            logLevel,
            message,
            args,
            opts
          });
          method = method || opts.method;
          assert4(method);
          opts.total = this.getTotal();
          opts.delta = this.getDelta();
          this._deltaTs = getHiResTimestamp2();
          const tag = opts.tag || opts.message;
          if (opts.once) {
            if (!cache[tag]) {
              cache[tag] = getHiResTimestamp2();
            } else {
              return noop;
            }
          }
          message = decorateMessage(this.id, opts.message, opts);
          return method.bind(console, message, ...opts.args);
        }
        return noop;
      }
    };
    _defineProperty(Log, "VERSION", VERSION3);
  }
});

// node_modules/@probe.gl/log/dist/esm/init.js
var init_init = __esm({
  "node_modules/@probe.gl/log/dist/esm/init.js"() {
    globalThis.probe = {};
  }
});

// node_modules/@probe.gl/log/dist/esm/index.js
var esm_default;
var init_esm6 = __esm({
  "node_modules/@probe.gl/log/dist/esm/index.js"() {
    init_log();
    init_log();
    init_color();
    init_color();
    init_formatters();
    init_autobind();
    init_local_storage();
    init_hi_res_timestamp2();
    init_init();
    esm_default = new Log({
      id: "@probe.gl/log"
    });
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
var probeLog, NullLog, ConsoleLog;
var init_loggers = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js"() {
    init_defineProperty();
    init_esm6();
    probeLog = new Log({
      id: "loaders.gl"
    });
    NullLog = class {
      log() {
        return () => {
        };
      }
      info() {
        return () => {
        };
      }
      warn() {
        return () => {
        };
      }
      error() {
        return () => {
        };
      }
    };
    ConsoleLog = class {
      constructor() {
        _defineProperty(this, "console", void 0);
        this.console = console;
      }
      log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.console.log.bind(this.console, ...args);
      }
      info() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this.console.info.bind(this.console, ...args);
      }
      warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this.console.warn.bind(this.console, ...args);
      }
      error() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return this.console.error.bind(this.console, ...args);
      }
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js
var DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS;
var init_option_defaults = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js"() {
    init_esm4();
    init_loggers();
    DEFAULT_LOADER_OPTIONS = {
      fetch: null,
      mimeType: void 0,
      nothrow: false,
      log: new ConsoleLog(),
      CDN: "https://unpkg.com/@loaders.gl",
      worker: true,
      maxConcurrency: 3,
      maxMobileConcurrency: 1,
      reuseWorkers: isBrowser,
      _nodeWorkers: false,
      _workerType: "",
      limit: 0,
      _limitMB: 0,
      batchSize: "auto",
      batchDebounceMs: 0,
      metadata: false,
      transforms: []
    };
    REMOVED_LOADER_OPTIONS = {
      throws: "nothrow",
      dataType: "(no longer used)",
      uri: "baseUri",
      method: "fetch.method",
      headers: "fetch.headers",
      body: "fetch.body",
      mode: "fetch.mode",
      credentials: "fetch.credentials",
      cache: "fetch.cache",
      redirect: "fetch.redirect",
      referrer: "fetch.referrer",
      referrerPolicy: "fetch.referrerPolicy",
      integrity: "fetch.integrity",
      keepalive: "fetch.keepalive",
      signal: "fetch.signal"
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const fetchOptions = options || globalOptions;
  if (typeof fetchOptions.fetch === "function") {
    return fetchOptions.fetch;
  }
  if (isObject(fetchOptions.fetch)) {
    return (url) => fetchFile(url, fetchOptions);
  }
  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }
  return fetchFile;
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix = id ? "".concat(id, ".") : "";
  for (const key in options) {
    const isSubOptions = !id && isObject(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = {
    ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}
var getGlobalLoaderOptions;
var init_option_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"() {
    init_is_type();
    init_fetch_file();
    init_loggers();
    init_option_defaults();
    getGlobalLoaderOptions = () => {
      const state = getGlobalLoaderState();
      state.globalOptions = state.globalOptions || {
        ...DEFAULT_LOADER_OPTIONS
      };
      return state.globalOptions;
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js
var init_loader_options = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js"() {
    init_option_utils();
    init_option_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
  var _loader;
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  var _loader2, _loader3;
  assert(loader, "null loader");
  assert(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {
        ...loader.options,
        ...options
      }
    };
  }
  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}
var init_normalize_loader = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js"() {
    init_esm4();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = normalizeLoader(loader);
    if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
var getGlobalLoaderRegistry;
var init_register_loaders = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js"() {
    init_normalize_loader();
    init_option_utils();
    getGlobalLoaderRegistry = () => {
      const state = getGlobalLoaderState();
      state.loaderRegistry = state.loaderRegistry || [];
      return state.loaderRegistry;
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js
var log;
var init_log2 = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js"() {
    init_esm6();
    log = new Log({
      id: "loaders.gl"
    });
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
async function selectLoader(data) {
  let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, {
    ...options,
    nothrow: true
  }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data) {
  let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const {
    url,
    type
  } = getResourceUrlAndType(data);
  const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = "";
  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? "matched url ".concat(testUrl) : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? "matched MIME type ".concat(type) : "");
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters2(data)) : "");
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
  if (reason) {
    var _loader;
    log.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const {
    url,
    type
  } = getResourceUrlAndType(data);
  let message = "No valid loader found (";
  message += url ? "".concat(path_exports.filename(url), ", ") : "no url provided, ";
  message += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
  const firstCharacters = data ? getFirstCharacters2(data) : "";
  message += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
  message += ")";
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
    if (mimeType === "application/x.".concat(loader.id)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === "string") {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data, loader);
    case "string":
      const magic = getMagicString2(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters2(data) {
  let length4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  if (typeof data === "string") {
    return data.slice(0, length4);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString2(data.buffer, data.byteOffset, length4);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString2(data, byteOffset, length4);
  }
  return "";
}
function getMagicString2(arrayBuffer2, byteOffset, length4) {
  if (arrayBuffer2.byteLength < byteOffset + length4) {
    return "";
  }
  const dataView = new DataView(arrayBuffer2);
  let magic = "";
  for (let i = 0; i < length4; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
var EXT_PATTERN;
var init_select_loader = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js"() {
    init_esm4();
    init_normalize_loader();
    init_log2();
    init_resource_utils();
    init_register_loaders();
    init_is_type();
    EXT_PATTERN = /\.([^.]+)$/;
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js
function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}
var DEFAULT_CHUNK_SIZE;
var init_make_string_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js"() {
    DEFAULT_CHUNK_SIZE = 256 * 1024;
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js
function* makeArrayBufferIterator(arrayBuffer2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    chunkSize = DEFAULT_CHUNK_SIZE2
  } = options;
  let byteOffset = 0;
  while (byteOffset < arrayBuffer2.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}
var DEFAULT_CHUNK_SIZE2;
var init_make_array_buffer_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js"() {
    DEFAULT_CHUNK_SIZE2 = 256 * 1024;
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE3;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}
var DEFAULT_CHUNK_SIZE3;
var init_make_blob_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js"() {
    DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js
function makeStreamIterator(stream2, options) {
  return isBrowser ? makeBrowserStreamIterator(stream2, options) : makeNodeStreamIterator(stream2, options);
}
async function* makeBrowserStreamIterator(stream2, options) {
  const reader = stream2.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const {
        done,
        value
      } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer2(value);
    }
  } catch (error2) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream2, options) {
  for await (const chunk of stream2) {
    yield toArrayBuffer2(chunk);
  }
}
var init_make_stream_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js"() {
    init_esm4();
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js
function makeIterator(data, options) {
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data, options);
  }
  if (isResponse(data)) {
    const response = data;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}
var init_make_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js"() {
    init_make_string_iterator();
    init_make_array_buffer_iterator();
    init_make_blob_iterator();
    init_make_stream_iterator();
    init_is_type();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (isBuffer2(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer2 = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer2);
    }
    return arrayBuffer2;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data);
    }
    let arrayBuffer2 = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
      arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer2;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if (isBlob(data)) {
    data = await makeResponse(data);
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data)) {
    data = makeIterator(data, options);
  }
  if (isIterable(data) || isAsyncIterable(data)) {
    return concatenateArrayBuffersAsync(data);
  }
  throw new Error(ERR_DATA);
}
var ERR_DATA;
var init_get_data = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js"() {
    init_esm4();
    init_is_type();
    init_make_iterator();
    init_response_utils();
    ERR_DATA = "Cannot convert supplied data type";
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js
function getLoaderContext(context, options) {
  let previousContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (previousContext) {
    return previousContext;
  }
  const resolvedContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (!Array.isArray(resolvedContext.loaders)) {
    resolvedContext.loaders = null;
  }
  return resolvedContext;
}
function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}
var init_loader_context = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js"() {
    init_option_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
async function parse(data, loaders, options, context) {
  assert2(!context || typeof context === "object");
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data = await data;
  options = options || {};
  const {
    url
  } = getResourceUrlAndType(data);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext({
    url,
    parse,
    loaders: candidateLoaders
  }, options, context);
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  validateWorkerVersion(loader);
  if (isResponse(data)) {
    const response = data;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }
  data = await getArrayBufferOrStringFromData(data, loader, options);
  if (loader.parseTextSync && typeof data === "string") {
    options.dataType = "text";
    return loader.parseTextSync(data, options, context, loader);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data, options, context, parse);
  }
  if (loader.parseText && typeof data === "string") {
    return await loader.parseText(data, options, context, loader);
  }
  if (loader.parse) {
    return await loader.parse(data, options, context, loader);
  }
  assert2(!loader.parseSync);
  throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}
var init_parse = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"() {
    init_esm2();
    init_esm4();
    init_normalize_loader();
    init_is_type();
    init_option_utils();
    init_get_data();
    init_loader_context();
    init_resource_utils();
    init_select_loader();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js
var init_parse_sync = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js"() {
    init_esm4();
    init_select_loader();
    init_normalize_loader();
    init_option_utils();
    init_get_data();
    init_loader_context();
    init_resource_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js
var init_parse_in_batches = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js"() {
    init_esm4();
    init_normalize_loader();
    init_option_utils();
    init_loader_context();
    init_get_data();
    init_resource_utils();
    init_select_loader();
    init_parse();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
async function load(url, loaders, options, context) {
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  const fetch2 = getFetchFunction(options);
  let data = url;
  if (typeof url === "string") {
    data = await fetch2(url);
  }
  if (isBlob(url)) {
    data = await fetch2(url);
  }
  return await parse(data, loaders, options);
}
var init_load = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/load.js"() {
    init_is_type();
    init_normalize_loader();
    init_option_utils();
    init_parse();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js
var init_load_in_batches = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js"() {
    init_normalize_loader();
    init_option_utils();
    init_parse_in_batches();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js
var init_encode = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js"() {
    init_esm4();
    init_esm2();
    init_esm4();
    init_esm4();
    init_write_file();
    init_fetch_file();
    init_loader_options();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/save.js
var init_save = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/save.js"() {
    init_encode();
    init_write_file();
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js
var init_make_dom_stream = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js"() {
  }
});

// node_modules/@loaders.gl/core/dist/esm/null-loader.js
var init_null_loader = __esm({
  "node_modules/@loaders.gl/core/dist/esm/null-loader.js"() {
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js
var init_fetch_progress = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js"() {
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js
var init_browser_filesystem = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js"() {
    init_defineProperty();
  }
});

// node_modules/@loaders.gl/core/dist/esm/index.js
var init_esm7 = __esm({
  "node_modules/@loaders.gl/core/dist/esm/index.js"() {
    init_fetch_file();
    init_read_array_buffer();
    init_read_file();
    init_write_file();
    init_loader_options();
    init_register_loaders();
    init_select_loader();
    init_parse();
    init_parse_sync();
    init_parse_in_batches();
    init_load();
    init_load_in_batches();
    init_encode();
    init_save();
    init_esm4();
    init_esm4();
    init_make_iterator();
    init_make_dom_stream();
    init_null_loader();
    init_esm4();
    init_fetch_progress();
    init_browser_filesystem();
    init_register_loaders();
    init_esm4();
    init_esm4();
    init_esm4();
    init_esm4();
    init_is_type();
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js
var VERSION4;
var init_version2 = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js"() {
    VERSION4 = true ? "3.3.3" : "latest";
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
var _parseImageNode, IMAGE_SUPPORTED, IMAGE_BITMAP_SUPPORTED, NODE_IMAGE_SUPPORTED, DATA_SUPPORTED;
var init_image_type = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js"() {
    init_esm4();
    ({
      _parseImageNode
    } = globalThis);
    IMAGE_SUPPORTED = typeof Image !== "undefined";
    IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
    NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
    DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}
var init_parsed_image_api = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js"() {
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer2, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer2);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error2) {
      throw new Error(error2.message);
    }
    const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }
  return getBlob(arrayBuffer2, url);
}
function getBlob(arrayBuffer2, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer2)]);
}
var SVG_DATA_URL_PATTERN, SVG_URL_PATTERN;
var init_svg_utils = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js"() {
    SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
    SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
async function parseToImage(arrayBuffer2, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
  const URL2 = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL2.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = (err) => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
    } catch (error2) {
      reject(error2);
    }
  });
}
var init_parse_to_image = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js"() {
    init_svg_utils();
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
async function parseToImageBitmap(arrayBuffer2, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer2, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer2, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob) {
  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error2) {
      console.warn(error2);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}
var EMPTY_OBJECT, imagebitmapOptionsSupported;
var init_parse_to_image_bitmap = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js"() {
    init_svg_utils();
    init_parse_to_image();
    EMPTY_OBJECT = {};
    imagebitmapOptionsSupported = true;
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const {
    tableMarkers,
    sofMarkers
  } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504; i < 65520; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
  return {
    tableMarkers,
    sofMarkers
  };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}
var BIG_ENDIAN, LITTLE_ENDIAN;
var init_binary_image_api = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"() {
    BIG_ENDIAN = false;
    LITTLE_ENDIAN = true;
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
async function parseToNodeImage(arrayBuffer2, options) {
  const {
    mimeType
  } = getBinaryImageMetadata(arrayBuffer2) || {};
  const _parseImageNode2 = globalThis._parseImageNode;
  assert(_parseImageNode2);
  return await _parseImageNode2(arrayBuffer2, mimeType);
}
var init_parse_to_node_image = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js"() {
    init_esm4();
    init_binary_image_api();
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
async function parseImage(arrayBuffer2, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const {
    url
  } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer2, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer2, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer2, options);
      break;
    default:
      assert(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}
var init_parse_image = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js"() {
    init_esm4();
    init_image_type();
    init_parsed_image_api();
    init_parse_to_image();
    init_parse_to_image_bitmap();
    init_parse_to_node_image();
  }
});

// node_modules/@loaders.gl/images/dist/esm/image-loader.js
var EXTENSIONS, MIME_TYPES, DEFAULT_IMAGE_LOADER_OPTIONS, ImageLoader;
var init_image_loader = __esm({
  "node_modules/@loaders.gl/images/dist/esm/image-loader.js"() {
    init_version2();
    init_parse_image();
    init_binary_image_api();
    EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
    MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
    DEFAULT_IMAGE_LOADER_OPTIONS = {
      image: {
        type: "auto",
        decode: true
      }
    };
    ImageLoader = {
      id: "image",
      module: "images",
      name: "Images",
      version: VERSION4,
      mimeTypes: MIME_TYPES,
      extensions: EXTENSIONS,
      parse: parseImage,
      tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
      options: DEFAULT_IMAGE_LOADER_OPTIONS
    };
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js
var _encodeImageNode;
var init_encode_image = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js"() {
    init_parsed_image_api();
    ({
      _encodeImageNode
    } = globalThis);
  }
});

// node_modules/@loaders.gl/images/dist/esm/image-writer.js
var init_image_writer = __esm({
  "node_modules/@loaders.gl/images/dist/esm/image-writer.js"() {
    init_version2();
    init_encode_image();
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js
function _isImageFormatSupported(mimeType) {
  if (mimeTypeSupported[mimeType] === void 0) {
    mimeTypeSupported[mimeType] = checkFormatSupport(mimeType);
  }
  return mimeTypeSupported[mimeType];
}
function checkFormatSupport(mimeType) {
  switch (mimeType) {
    case "image/webp":
      return checkWebPSupport();
    case "image/svg":
      return isBrowser;
    default:
      if (!isBrowser) {
        const {
          _parseImageNode: _parseImageNode2
        } = globalThis;
        return Boolean(_parseImageNode2) && NODE_FORMAT_SUPPORT.includes(mimeType);
      }
      return true;
  }
}
function checkWebPSupport() {
  if (!isBrowser) {
    return false;
  }
  try {
    const element = document.createElement("canvas");
    return element.toDataURL("image/webp").indexOf("data:image/webp") === 0;
  } catch {
    return false;
  }
}
var NODE_FORMAT_SUPPORT, mimeTypeSupported;
var init_image_format = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js"() {
    init_esm4();
    NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
    mimeTypeSupported = {};
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js
var init_generate_url = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js"() {
    init_esm4();
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js
var init_async_deep_map = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js"() {
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js
var init_deep_load = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js"() {
    init_async_deep_map();
  }
});

// node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js
var init_load_image = __esm({
  "node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js"() {
    init_esm4();
    init_parse_image();
    init_parsed_image_api();
    init_generate_url();
    init_deep_load();
  }
});

// node_modules/@loaders.gl/images/dist/esm/index.js
var init_esm8 = __esm({
  "node_modules/@loaders.gl/images/dist/esm/index.js"() {
    init_image_loader();
    init_image_writer();
    init_binary_image_api();
    init_image_type();
    init_parsed_image_api();
    init_image_format();
    init_load_image();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/log.js
var log_default;
var init_log3 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/log.js"() {
    init_esm6();
    log_default = new Log({
      id: "deck"
    });
  }
});

// node_modules/@deck.gl/core/dist/esm/debug/loggers.js
var logState, LOG_LEVEL_MAJOR_UPDATE, LOG_LEVEL_MINOR_UPDATE, LOG_LEVEL_UPDATE_DETAIL, LOG_LEVEL_INFO, LOG_LEVEL_DRAW, getLoggers;
var init_loggers2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/debug/loggers.js"() {
    logState = {
      attributeUpdateStart: -1,
      attributeManagerUpdateStart: -1,
      attributeUpdateMessages: []
    };
    LOG_LEVEL_MAJOR_UPDATE = 1;
    LOG_LEVEL_MINOR_UPDATE = 2;
    LOG_LEVEL_UPDATE_DETAIL = 3;
    LOG_LEVEL_INFO = 4;
    LOG_LEVEL_DRAW = 2;
    getLoggers = (log4) => ({
      "layer.changeFlag": (layer, key, flags) => {
        log4.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
      },
      "layer.initialize": (layer) => {
        log4.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
      },
      "layer.update": (layer, needsUpdate) => {
        if (needsUpdate) {
          const flags = layer.getChangeFlags();
          log4.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter((key) => flags[key]).join(", ")))();
        } else {
          log4.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
        }
      },
      "layer.matched": (layer, changed) => {
        if (changed) {
          log4.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
        }
      },
      "layer.finalize": (layer) => {
        log4.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
      },
      "compositeLayer.renderLayers": (layer, updated, subLayers) => {
        if (updated) {
          log4.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
        } else {
          log4.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
        }
      },
      "layerManager.setLayers": (layerManager, updated, layers) => {
        if (updated) {
          log4.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
        }
      },
      "layerManager.activateViewport": (layerManager, viewport) => {
        log4.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
      },
      "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
        log4.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
      },
      "attributeManager.updateStart": (attributeManager) => {
        logState.attributeUpdateMessages.length = 0;
        logState.attributeManagerUpdateStart = Date.now();
      },
      "attributeManager.updateEnd": (attributeManager, numInstances) => {
        const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
        log4.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
        for (const updateMessage of logState.attributeUpdateMessages) {
          log4.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
        }
        log4.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
      },
      "attribute.updateStart": (attribute) => {
        logState.attributeUpdateStart = Date.now();
      },
      "attribute.allocate": (attribute, numInstances) => {
        const message = "".concat(attribute.id, " allocated ").concat(numInstances);
        logState.attributeUpdateMessages.push(message);
      },
      "attribute.updateEnd": (attribute, numInstances) => {
        const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
        const message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
        logState.attributeUpdateMessages.push(message);
      },
      "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
        const {
          pass,
          redrawReason,
          stats
        } = opts;
        for (const status of renderStats) {
          const {
            totalCount,
            visibleCount,
            compositeCount,
            pickableCount
          } = status;
          const primitiveCount = totalCount - compositeCount;
          const hiddenCount = primitiveCount - visibleCount;
          log4.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
          if (stats) {
            stats.get("Redraw Layers").add(visibleCount);
          }
        }
      }
    });
  }
});

// node_modules/@deck.gl/core/dist/esm/debug/index.js
function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (log_default.level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}
var loggers;
var init_debug = __esm({
  "node_modules/@deck.gl/core/dist/esm/debug/index.js"() {
    init_log3();
    init_loggers2();
    loggers = {};
    if (true) {
      loggers = getLoggers(log_default);
    }
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/json-loader.js
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var json_loader_default;
var init_json_loader2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/json-loader.js"() {
    json_loader_default = {
      id: "JSON",
      name: "JSON",
      module: "",
      version: "",
      options: {},
      extensions: ["json", "geojson"],
      mimeTypes: ["application/json", "application/geo+json"],
      testText: isJSON,
      parseTextSync: JSON.parse
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/init.js
function checkVersion() {
  const version = true ? "8.9.12" : globalThis.DECK_VERSION || "untranspiled source";
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;
  if (existingVersion && existingVersion !== version) {
    throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
  }
  if (!existingVersion) {
    log_default.log(1, "deck.gl ".concat(version))();
    globalThis.deck = {
      ...globalThis.deck,
      VERSION: version,
      version,
      log: log_default,
      _registerLoggers: register
    };
    registerLoaders([json_loader_default, [ImageLoader, {
      imagebitmap: {
        premultiplyAlpha: "none"
      }
    }]]);
  }
  return version;
}
var VERSION5;
var init_init2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/init.js"() {
    init_esm7();
    init_esm8();
    init_log3();
    init_debug();
    init_json_loader2();
    VERSION5 = checkVersion();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/constants.js
var COORDINATE_SYSTEM, PROJECTION_MODE, UNIT, EVENTS, OPERATION;
var init_constants = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/constants.js"() {
    init_log3();
    COORDINATE_SYSTEM = {
      DEFAULT: -1,
      LNGLAT: 1,
      METER_OFFSETS: 2,
      LNGLAT_OFFSETS: 3,
      CARTESIAN: 0
    };
    Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
      get: () => {
        log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
        return 0;
      }
    });
    PROJECTION_MODE = {
      WEB_MERCATOR: 1,
      GLOBE: 2,
      WEB_MERCATOR_AUTO_OFFSET: 4,
      IDENTITY: 0
    };
    UNIT = {
      common: 0,
      meters: 1,
      pixels: 2
    };
    EVENTS = {
      click: {
        handler: "onClick"
      },
      panstart: {
        handler: "onDragStart"
      },
      panmove: {
        handler: "onDrag"
      },
      panend: {
        handler: "onDragEnd"
      }
    };
    OPERATION = {
      DRAW: "draw",
      MASK: "mask",
      TERRAIN: "terrain"
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/log.js
var log2;
var init_log4 = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/log.js"() {
    init_esm6();
    log2 = new Log({
      id: "luma.gl"
    });
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(message || "luma.gl: assertion failed.");
  }
}
var init_assert5 = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}
function assertWebGLContext(gl) {
  assert5(isWebGL(gl), ERR_CONTEXT);
  return gl;
}
function assertWebGL2Context(gl) {
  assert5(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}
var ERR_CONTEXT, ERR_WEBGL2;
var init_webgl_checks = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"() {
    init_assert5();
    ERR_CONTEXT = "Invalid WebGLRenderingContext";
    ERR_WEBGL2 = "Requires WebGL2";
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
function error(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}
function log3(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}
function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;
  if (opt_msg !== void 0) {
    error(opt_msg);
  }
}
function wrapGLError(gl) {
  const f = gl.getError;
  gl.getError = function getError() {
    let err;
    do {
      err = f.apply(gl);
      if (err !== 0) {
        glErrorShadow[err] = true;
      }
    } while (err !== 0);
    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }
    return 0;
  };
}
function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === "function") {
    return;
  }
  const original_getSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];
    if (list.indexOf("OES_vertex_array_object") < 0) {
      list.push("OES_vertex_array_object");
    }
    return list;
  };
  const original_getExtension = gl.getExtension;
  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);
    if (ext) {
      return ext;
    }
    if (name !== "OES_vertex_array_object") {
      return null;
    }
    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }
    return this.__OESVertexArrayObject;
  };
}
var glErrorShadow, WebGLVertexArrayObjectOES, OESVertexArrayObject;
var init_polyfill_vertex_array_object = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js"() {
    glErrorShadow = {};
    WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
      const gl = ext.gl;
      this.ext = ext;
      this.isAlive = true;
      this.hasBeenBound = false;
      this.elementArrayBuffer = null;
      this.attribs = new Array(ext.maxVertexAttribs);
      for (let n = 0; n < this.attribs.length; n++) {
        const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
        this.attribs[n] = attrib;
      }
      this.maxAttrib = 0;
    };
    WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
      this.enabled = false;
      this.buffer = null;
      this.size = 4;
      this.type = 5126;
      this.normalized = false;
      this.stride = 16;
      this.offset = 0;
      this.cached = "";
      this.recache();
    };
    WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
      this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
    };
    OESVertexArrayObject = function OESVertexArrayObject2(gl) {
      const self2 = this;
      this.gl = gl;
      wrapGLError(gl);
      const original = this.original = {
        getParameter: gl.getParameter,
        enableVertexAttribArray: gl.enableVertexAttribArray,
        disableVertexAttribArray: gl.disableVertexAttribArray,
        bindBuffer: gl.bindBuffer,
        getVertexAttrib: gl.getVertexAttrib,
        vertexAttribPointer: gl.vertexAttribPointer
      };
      gl.getParameter = function getParameter(pname) {
        if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
          if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
            return null;
          }
          return self2.currentVertexArrayObject;
        }
        return original.getParameter.apply(this, arguments);
      };
      gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
        const vao = self2.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = true;
        return original.enableVertexAttribArray.apply(this, arguments);
      };
      gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
        const vao = self2.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = false;
        return original.disableVertexAttribArray.apply(this, arguments);
      };
      gl.bindBuffer = function bindBuffer(target, buffer) {
        switch (target) {
          case 34962:
            self2.currentArrayBuffer = buffer;
            break;
          case 34963:
            self2.currentVertexArrayObject.elementArrayBuffer = buffer;
            break;
          default:
        }
        return original.bindBuffer.apply(this, arguments);
      };
      gl.getVertexAttrib = function getVertexAttrib(index, pname) {
        const vao = self2.currentVertexArrayObject;
        const attrib = vao.attribs[index];
        switch (pname) {
          case 34975:
            return attrib.buffer;
          case 34338:
            return attrib.enabled;
          case 34339:
            return attrib.size;
          case 34340:
            return attrib.stride;
          case 34341:
            return attrib.type;
          case 34922:
            return attrib.normalized;
          default:
            return original.getVertexAttrib.apply(this, arguments);
        }
      };
      gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
        const vao = self2.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, indx);
        const attrib = vao.attribs[indx];
        attrib.buffer = self2.currentArrayBuffer;
        attrib.size = size;
        attrib.type = type;
        attrib.normalized = normalized;
        attrib.stride = stride;
        attrib.offset = offset;
        attrib.recache();
        return original.vertexAttribPointer.apply(this, arguments);
      };
      if (gl.instrumentExtension) {
        gl.instrumentExtension(this, "OES_vertex_array_object");
      }
      if (gl.canvas) {
        gl.canvas.addEventListener("webglcontextrestored", () => {
          log3("OESVertexArrayObject emulation library context restored");
          self2.reset_();
        }, true);
      }
      this.reset_();
    };
    OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
    OESVertexArrayObject.prototype.reset_ = function reset_() {
      const contextWasLost = this.vertexArrayObjects !== void 0;
      if (contextWasLost) {
        for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
          this.vertexArrayObjects.isAlive = false;
        }
      }
      const gl = this.gl;
      this.maxVertexAttribs = gl.getParameter(34921);
      this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
      this.currentVertexArrayObject = null;
      this.currentArrayBuffer = null;
      this.vertexArrayObjects = [this.defaultVertexArrayObject];
      this.bindVertexArrayOES(null);
    };
    OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
      const arrayObject = new WebGLVertexArrayObjectOES(this);
      this.vertexArrayObjects.push(arrayObject);
      return arrayObject;
    };
    OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
      arrayObject.isAlive = false;
      this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
      if (this.currentVertexArrayObject === arrayObject) {
        this.bindVertexArrayOES(null);
      }
    };
    OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
      if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
        if (arrayObject.hasBeenBound && arrayObject.ext === this) {
          return true;
        }
      }
      return false;
    };
    OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
      const gl = this.gl;
      if (arrayObject && !arrayObject.isAlive) {
        synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
        return;
      }
      const original = this.original;
      const oldVAO = this.currentVertexArrayObject;
      this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
      this.currentVertexArrayObject.hasBeenBound = true;
      const newVAO = this.currentVertexArrayObject;
      if (oldVAO === newVAO) {
        return;
      }
      if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
        original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
      }
      let currentBinding = this.currentArrayBuffer;
      const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
      for (let n = 0; n <= maxAttrib; n++) {
        const attrib = newVAO.attribs[n];
        const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
        if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
          if (attrib.enabled) {
            original.enableVertexAttribArray.call(gl, n);
          } else {
            original.disableVertexAttribArray.call(gl, n);
          }
        }
        if (attrib.enabled) {
          let bufferChanged = false;
          if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
            if (currentBinding !== attrib.buffer) {
              original.bindBuffer.call(gl, 34962, attrib.buffer);
              currentBinding = attrib.buffer;
            }
            bufferChanged = true;
          }
          if (bufferChanged || attrib.cached !== oldAttrib.cached) {
            original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
          }
        }
      }
      if (this.currentArrayBuffer !== currentBinding) {
        original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
      }
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== void 0 ? value : originalGetParameter(pname);
  return result;
}
var OES_element_index, WEBGL_draw_buffers, EXT_disjoint_timer_query, EXT_disjoint_timer_query_webgl2, EXT_texture_filter_anisotropic, WEBGL_debug_renderer_info, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, GL_DONT_CARE, GL_GPU_DISJOINT_EXT, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, GL_UNMASKED_VENDOR_WEBGL, GL_UNMASKED_RENDERER_WEBGL, getWebGL2ValueOrZero, WEBGL_PARAMETERS;
var init_get_parameter_polyfill = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js"() {
    init_webgl_checks();
    OES_element_index = "OES_element_index";
    WEBGL_draw_buffers = "WEBGL_draw_buffers";
    EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
    EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
    EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
    WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
    GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
    GL_DONT_CARE = 4352;
    GL_GPU_DISJOINT_EXT = 36795;
    GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
    GL_UNMASKED_VENDOR_WEBGL = 37445;
    GL_UNMASKED_RENDERER_WEBGL = 37446;
    getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
    WEBGL_PARAMETERS = {
      [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
      [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
      [35977]: getWebGL2ValueOrZero,
      [32937]: getWebGL2ValueOrZero,
      [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
        const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
        return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
      },
      [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
        const ext = gl.getExtension(WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
      },
      [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
        const ext = gl.getExtension(WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
      },
      [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
        const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
        return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
      },
      [32883]: getWebGL2ValueOrZero,
      [35071]: getWebGL2ValueOrZero,
      [37447]: getWebGL2ValueOrZero,
      [36063]: (gl, getParameter) => {
        if (!isWebGL2(gl)) {
          const ext = gl.getExtension(WEBGL_draw_buffers);
          return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
        }
        return void 0;
      },
      [35379]: getWebGL2ValueOrZero,
      [35374]: getWebGL2ValueOrZero,
      [35377]: getWebGL2ValueOrZero,
      [34852]: (gl) => {
        if (!isWebGL2(gl)) {
          const ext = gl.getExtension(WEBGL_draw_buffers);
          return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
        }
        return void 0;
      },
      [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
      [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
      [33e3]: (gl) => 16777216,
      [37157]: getWebGL2ValueOrZero,
      [35373]: getWebGL2ValueOrZero,
      [35657]: getWebGL2ValueOrZero,
      [36183]: getWebGL2ValueOrZero,
      [37137]: getWebGL2ValueOrZero,
      [34045]: getWebGL2ValueOrZero,
      [35978]: getWebGL2ValueOrZero,
      [35979]: getWebGL2ValueOrZero,
      [35968]: getWebGL2ValueOrZero,
      [35376]: getWebGL2ValueOrZero,
      [35375]: getWebGL2ValueOrZero,
      [35659]: getWebGL2ValueOrZero,
      [37154]: getWebGL2ValueOrZero,
      [35371]: getWebGL2ValueOrZero,
      [35658]: getWebGL2ValueOrZero,
      [35076]: getWebGL2ValueOrZero,
      [35077]: getWebGL2ValueOrZero,
      [35380]: getWebGL2ValueOrZero
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
function getExtensionData(gl, extension) {
  return {
    webgl2: isWebGL2(gl),
    ext: gl.getExtension(extension)
  };
}
var OES_vertex_array_object, ANGLE_instanced_arrays, WEBGL_draw_buffers2, EXT_disjoint_timer_query2, EXT_texture_filter_anisotropic2, ERR_VAO_NOT_SUPPORTED, WEBGL2_CONTEXT_POLYFILLS, WEBGL2_CONTEXT_OVERRIDES;
var init_polyfill_table = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js"() {
    init_assert5();
    init_webgl_checks();
    init_get_parameter_polyfill();
    OES_vertex_array_object = "OES_vertex_array_object";
    ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
    WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
    EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
    EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
    ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
    WEBGL2_CONTEXT_POLYFILLS = {
      [OES_vertex_array_object]: {
        meta: {
          suffix: "OES"
        },
        createVertexArray: () => {
          assert5(false, ERR_VAO_NOT_SUPPORTED);
        },
        deleteVertexArray: () => {
        },
        bindVertexArray: () => {
        },
        isVertexArray: () => false
      },
      [ANGLE_instanced_arrays]: {
        meta: {
          suffix: "ANGLE"
        },
        vertexAttribDivisor(location, divisor) {
          assert5(divisor === 0, "WebGL instanced rendering not supported");
        },
        drawElementsInstanced: () => {
        },
        drawArraysInstanced: () => {
        }
      },
      [WEBGL_draw_buffers2]: {
        meta: {
          suffix: "WEBGL"
        },
        drawBuffers: () => {
          assert5(false);
        }
      },
      [EXT_disjoint_timer_query2]: {
        meta: {
          suffix: "EXT"
        },
        createQuery: () => {
          assert5(false);
        },
        deleteQuery: () => {
          assert5(false);
        },
        beginQuery: () => {
          assert5(false);
        },
        endQuery: () => {
        },
        getQuery(handle, pname) {
          return this.getQueryObject(handle, pname);
        },
        getQueryParameter(handle, pname) {
          return this.getQueryObject(handle, pname);
        },
        getQueryObject: () => {
        }
      }
    };
    WEBGL2_CONTEXT_OVERRIDES = {
      readBuffer: (gl, originalFunc, attachment) => {
        if (isWebGL2(gl)) {
          originalFunc(attachment);
        } else {
        }
      },
      getVertexAttrib: (gl, originalFunc, location, pname) => {
        const {
          webgl2,
          ext
        } = getExtensionData(gl, ANGLE_instanced_arrays);
        let result;
        switch (pname) {
          case 35069:
            result = !webgl2 ? false : void 0;
            break;
          case 35070:
            result = !webgl2 && !ext ? 0 : void 0;
            break;
          default:
        }
        return result !== void 0 ? result : originalFunc(location, pname);
      },
      getProgramParameter: (gl, originalFunc, program, pname) => {
        if (!isWebGL2(gl)) {
          switch (pname) {
            case 35967:
              return 35981;
            case 35971:
              return 0;
            case 35382:
              return 0;
            default:
          }
        }
        return originalFunc(program, pname);
      },
      getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
        if (!isWebGL2(gl)) {
          switch (pname) {
            case 32937:
              return new Int32Array([0]);
            default:
          }
        }
        return gl.getInternalformatParameter(target, format, pname);
      },
      getTexParameter(gl, originalFunc, target, pname) {
        switch (pname) {
          case 34046:
            const {
              extensions
            } = gl.luma;
            const ext = extensions[EXT_texture_filter_anisotropic2];
            pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
            break;
          default:
        }
        return originalFunc(target, pname);
      },
      getParameter: getParameterPolyfill,
      hint(gl, originalFunc, pname, value) {
        return originalFunc(pname, value);
      }
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  const {
    luma
  } = gl;
  if (!luma.polyfilled) {
    polyfillVertexArrayObject(gl);
    initializeExtensions(gl);
    installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: luma,
      target2: gl
    });
    luma.polyfilled = true;
  }
  return gl;
}
function initializeExtensions(gl) {
  gl.luma.extensions = {};
  const EXTENSIONS2 = gl.getSupportedExtensions() || [];
  for (const extension of EXTENSIONS2) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}
function installOverrides(gl, _ref) {
  let {
    target,
    target2
  } = _ref;
  Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
    if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
      };
      const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}
function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== "overrides") {
      polyfillExtension(gl, {
        extension,
        target: gl.luma,
        target2: gl
      });
    }
  }
}
function polyfillExtension(gl, _ref2) {
  let {
    extension,
    target,
    target2
  } = _ref2;
  const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
  assert5(defaults);
  const {
    meta = {}
  } = defaults;
  const {
    suffix = ""
  } = meta;
  const ext = gl.getExtension(extension);
  for (const key of Object.keys(defaults)) {
    const extKey = "".concat(key).concat(suffix);
    let polyfill = null;
    if (key === "meta") {
    } else if (typeof gl[key] === "function") {
    } else if (ext && typeof ext[extKey] === "function") {
      polyfill = function() {
        return ext[extKey](...arguments);
      };
    } else if (typeof defaults[key] === "function") {
      polyfill = defaults[key].bind(target);
    }
    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}
var init_polyfill_context = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js"() {
    init_polyfill_vertex_array_object();
    init_assert5();
    init_polyfill_table();
    globalThis.polyfillContext = polyfillContext;
  }
});

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}
function getValue(glEnum, values, cache2) {
  return values[glEnum] !== void 0 ? values[glEnum] : cache2[glEnum];
}
var GL_PARAMETER_DEFAULTS, enable, hint, pixelStorei, drawFramebuffer, readFramebuffer, GL_PARAMETER_SETTERS, GL_COMPOSITE_PARAMETER_SETTERS, GL_HOOKED_SETTERS, isEnabled, GL_PARAMETER_GETTERS;
var init_webgl_parameter_tables = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js"() {
    init_webgl_checks();
    GL_PARAMETER_DEFAULTS = {
      [3042]: false,
      [32773]: new Float32Array([0, 0, 0, 0]),
      [32777]: 32774,
      [34877]: 32774,
      [32969]: 1,
      [32968]: 0,
      [32971]: 1,
      [32970]: 0,
      [3106]: new Float32Array([0, 0, 0, 0]),
      [3107]: [true, true, true, true],
      [2884]: false,
      [2885]: 1029,
      [2929]: false,
      [2931]: 1,
      [2932]: 513,
      [2928]: new Float32Array([0, 1]),
      [2930]: true,
      [3024]: true,
      [36006]: null,
      [2886]: 2305,
      [33170]: 4352,
      [2849]: 1,
      [32823]: false,
      [32824]: 0,
      [10752]: 0,
      [32938]: 1,
      [32939]: false,
      [3089]: false,
      [3088]: new Int32Array([0, 0, 1024, 1024]),
      [2960]: false,
      [2961]: 0,
      [2968]: 4294967295,
      [36005]: 4294967295,
      [2962]: 519,
      [2967]: 0,
      [2963]: 4294967295,
      [34816]: 519,
      [36003]: 0,
      [36004]: 4294967295,
      [2964]: 7680,
      [2965]: 7680,
      [2966]: 7680,
      [34817]: 7680,
      [34818]: 7680,
      [34819]: 7680,
      [2978]: [0, 0, 1024, 1024],
      [3333]: 4,
      [3317]: 4,
      [37440]: false,
      [37441]: false,
      [37443]: 37444,
      [35723]: 4352,
      [36010]: null,
      [35977]: false,
      [3330]: 0,
      [3332]: 0,
      [3331]: 0,
      [3314]: 0,
      [32878]: 0,
      [3316]: 0,
      [3315]: 0,
      [32877]: 0
    };
    enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
    hint = (gl, value, key) => gl.hint(key, value);
    pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
    drawFramebuffer = (gl, value) => {
      const target = isWebGL2(gl) ? 36009 : 36160;
      return gl.bindFramebuffer(target, value);
    };
    readFramebuffer = (gl, value) => {
      return gl.bindFramebuffer(36008, value);
    };
    GL_PARAMETER_SETTERS = {
      [3042]: enable,
      [32773]: (gl, value) => gl.blendColor(...value),
      [32777]: "blendEquation",
      [34877]: "blendEquation",
      [32969]: "blendFunc",
      [32968]: "blendFunc",
      [32971]: "blendFunc",
      [32970]: "blendFunc",
      [3106]: (gl, value) => gl.clearColor(...value),
      [3107]: (gl, value) => gl.colorMask(...value),
      [2884]: enable,
      [2885]: (gl, value) => gl.cullFace(value),
      [2929]: enable,
      [2931]: (gl, value) => gl.clearDepth(value),
      [2932]: (gl, value) => gl.depthFunc(value),
      [2928]: (gl, value) => gl.depthRange(...value),
      [2930]: (gl, value) => gl.depthMask(value),
      [3024]: enable,
      [35723]: hint,
      [36006]: drawFramebuffer,
      [2886]: (gl, value) => gl.frontFace(value),
      [33170]: hint,
      [2849]: (gl, value) => gl.lineWidth(value),
      [32823]: enable,
      [32824]: "polygonOffset",
      [10752]: "polygonOffset",
      [35977]: enable,
      [32938]: "sampleCoverage",
      [32939]: "sampleCoverage",
      [3089]: enable,
      [3088]: (gl, value) => gl.scissor(...value),
      [2960]: enable,
      [2961]: (gl, value) => gl.clearStencil(value),
      [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
      [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
      [2962]: "stencilFuncFront",
      [2967]: "stencilFuncFront",
      [2963]: "stencilFuncFront",
      [34816]: "stencilFuncBack",
      [36003]: "stencilFuncBack",
      [36004]: "stencilFuncBack",
      [2964]: "stencilOpFront",
      [2965]: "stencilOpFront",
      [2966]: "stencilOpFront",
      [34817]: "stencilOpBack",
      [34818]: "stencilOpBack",
      [34819]: "stencilOpBack",
      [2978]: (gl, value) => gl.viewport(...value),
      [3333]: pixelStorei,
      [3317]: pixelStorei,
      [37440]: pixelStorei,
      [37441]: pixelStorei,
      [37443]: pixelStorei,
      [3330]: pixelStorei,
      [3332]: pixelStorei,
      [3331]: pixelStorei,
      [36010]: readFramebuffer,
      [3314]: pixelStorei,
      [32878]: pixelStorei,
      [3316]: pixelStorei,
      [3315]: pixelStorei,
      [32877]: pixelStorei,
      framebuffer: (gl, framebuffer) => {
        const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
        return gl.bindFramebuffer(36160, handle);
      },
      blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
      blendColor: (gl, value) => gl.blendColor(...value),
      blendEquation: (gl, args) => {
        args = isArray(args) ? args : [args, args];
        gl.blendEquationSeparate(...args);
      },
      blendFunc: (gl, args) => {
        args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
        gl.blendFuncSeparate(...args);
      },
      clearColor: (gl, value) => gl.clearColor(...value),
      clearDepth: (gl, value) => gl.clearDepth(value),
      clearStencil: (gl, value) => gl.clearStencil(value),
      colorMask: (gl, value) => gl.colorMask(...value),
      cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
      cullFace: (gl, value) => gl.cullFace(value),
      depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
      depthFunc: (gl, value) => gl.depthFunc(value),
      depthMask: (gl, value) => gl.depthMask(value),
      depthRange: (gl, value) => gl.depthRange(...value),
      dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
      derivativeHint: (gl, value) => {
        gl.hint(35723, value);
      },
      frontFace: (gl, value) => gl.frontFace(value),
      mipmapHint: (gl, value) => gl.hint(33170, value),
      lineWidth: (gl, value) => gl.lineWidth(value),
      polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
      polygonOffset: (gl, value) => gl.polygonOffset(...value),
      sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
      scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
      scissor: (gl, value) => gl.scissor(...value),
      stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
      stencilMask: (gl, value) => {
        value = isArray(value) ? value : [value, value];
        const [mask, backMask] = value;
        gl.stencilMaskSeparate(1028, mask);
        gl.stencilMaskSeparate(1029, backMask);
      },
      stencilFunc: (gl, args) => {
        args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
        const [func, ref, mask, backFunc, backRef, backMask] = args;
        gl.stencilFuncSeparate(1028, func, ref, mask);
        gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
      },
      stencilOp: (gl, args) => {
        args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
        const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
        gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
        gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
      },
      viewport: (gl, value) => gl.viewport(...value)
    };
    GL_COMPOSITE_PARAMETER_SETTERS = {
      blendEquation: (gl, values, cache2) => gl.blendEquationSeparate(getValue(32777, values, cache2), getValue(34877, values, cache2)),
      blendFunc: (gl, values, cache2) => gl.blendFuncSeparate(getValue(32969, values, cache2), getValue(32968, values, cache2), getValue(32971, values, cache2), getValue(32970, values, cache2)),
      polygonOffset: (gl, values, cache2) => gl.polygonOffset(getValue(32824, values, cache2), getValue(10752, values, cache2)),
      sampleCoverage: (gl, values, cache2) => gl.sampleCoverage(getValue(32938, values, cache2), getValue(32939, values, cache2)),
      stencilFuncFront: (gl, values, cache2) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache2), getValue(2967, values, cache2), getValue(2963, values, cache2)),
      stencilFuncBack: (gl, values, cache2) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache2), getValue(36003, values, cache2), getValue(36004, values, cache2)),
      stencilOpFront: (gl, values, cache2) => gl.stencilOpSeparate(1028, getValue(2964, values, cache2), getValue(2965, values, cache2), getValue(2966, values, cache2)),
      stencilOpBack: (gl, values, cache2) => gl.stencilOpSeparate(1029, getValue(34817, values, cache2), getValue(34818, values, cache2), getValue(34819, values, cache2))
    };
    GL_HOOKED_SETTERS = {
      enable: (update, capability) => update({
        [capability]: true
      }),
      disable: (update, capability) => update({
        [capability]: false
      }),
      pixelStorei: (update, pname, value) => update({
        [pname]: value
      }),
      hint: (update, pname, hint2) => update({
        [pname]: hint2
      }),
      bindFramebuffer: (update, target, framebuffer) => {
        switch (target) {
          case 36160:
            return update({
              [36006]: framebuffer,
              [36010]: framebuffer
            });
          case 36009:
            return update({
              [36006]: framebuffer
            });
          case 36008:
            return update({
              [36010]: framebuffer
            });
          default:
            return null;
        }
      },
      blendColor: (update, r, g, b, a) => update({
        [32773]: new Float32Array([r, g, b, a])
      }),
      blendEquation: (update, mode) => update({
        [32777]: mode,
        [34877]: mode
      }),
      blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
        [32777]: modeRGB,
        [34877]: modeAlpha
      }),
      blendFunc: (update, src, dst) => update({
        [32969]: src,
        [32968]: dst,
        [32971]: src,
        [32970]: dst
      }),
      blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
        [32969]: srcRGB,
        [32968]: dstRGB,
        [32971]: srcAlpha,
        [32970]: dstAlpha
      }),
      clearColor: (update, r, g, b, a) => update({
        [3106]: new Float32Array([r, g, b, a])
      }),
      clearDepth: (update, depth) => update({
        [2931]: depth
      }),
      clearStencil: (update, s) => update({
        [2961]: s
      }),
      colorMask: (update, r, g, b, a) => update({
        [3107]: [r, g, b, a]
      }),
      cullFace: (update, mode) => update({
        [2885]: mode
      }),
      depthFunc: (update, func) => update({
        [2932]: func
      }),
      depthRange: (update, zNear, zFar) => update({
        [2928]: new Float32Array([zNear, zFar])
      }),
      depthMask: (update, mask) => update({
        [2930]: mask
      }),
      frontFace: (update, face) => update({
        [2886]: face
      }),
      lineWidth: (update, width) => update({
        [2849]: width
      }),
      polygonOffset: (update, factor, units) => update({
        [32824]: factor,
        [10752]: units
      }),
      sampleCoverage: (update, value, invert4) => update({
        [32938]: value,
        [32939]: invert4
      }),
      scissor: (update, x, y, width, height) => update({
        [3088]: new Int32Array([x, y, width, height])
      }),
      stencilMask: (update, mask) => update({
        [2968]: mask,
        [36005]: mask
      }),
      stencilMaskSeparate: (update, face, mask) => update({
        [face === 1028 ? 2968 : 36005]: mask
      }),
      stencilFunc: (update, func, ref, mask) => update({
        [2962]: func,
        [2967]: ref,
        [2963]: mask,
        [34816]: func,
        [36003]: ref,
        [36004]: mask
      }),
      stencilFuncSeparate: (update, face, func, ref, mask) => update({
        [face === 1028 ? 2962 : 34816]: func,
        [face === 1028 ? 2967 : 36003]: ref,
        [face === 1028 ? 2963 : 36004]: mask
      }),
      stencilOp: (update, fail, zfail, zpass) => update({
        [2964]: fail,
        [2965]: zfail,
        [2966]: zpass,
        [34817]: fail,
        [34818]: zfail,
        [34819]: zpass
      }),
      stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
        [face === 1028 ? 2964 : 34817]: fail,
        [face === 1028 ? 2965 : 34818]: zfail,
        [face === 1028 ? 2966 : 34819]: zpass
      }),
      viewport: (update, x, y, width, height) => update({
        [2978]: [x, y, width, height]
      })
    };
    isEnabled = (gl, key) => gl.isEnabled(key);
    GL_PARAMETER_GETTERS = {
      [3042]: isEnabled,
      [2884]: isEnabled,
      [2929]: isEnabled,
      [3024]: isEnabled,
      [32823]: isEnabled,
      [32926]: isEnabled,
      [32928]: isEnabled,
      [3089]: isEnabled,
      [2960]: isEnabled,
      [35977]: isEnabled
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var init_utils = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"() {
  }
});

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get() {
    const pname = arguments.length <= 0 ? void 0 : arguments[0];
    if (!(pname in gl.state.cache)) {
      return originalGetterFunc(...arguments);
    }
    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
  };
  Object.defineProperty(gl[functionName], "name", {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set2() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    const {
      valueChanged,
      oldValue
    } = setter(gl.state._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], "name", {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}
function trackContextState(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    enable: enable2 = true,
    copyState
  } = options;
  assert5(copyState !== void 0);
  if (!gl.state) {
    const {
      polyfillContext: polyfillContext2
    } = globalThis;
    if (polyfillContext2) {
      polyfillContext2(gl);
    }
    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, "getParameter");
    installGetterOverride(gl, "isEnabled");
  }
  gl.state.enable = enable2;
  return gl;
}
function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }
  gl.state.push();
}
function popContextState(gl) {
  assert5(gl.state);
  gl.state.pop();
}
var GLState;
var init_track_context_state = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js"() {
    init_webgl_parameter_tables();
    init_unified_parameter_api();
    init_assert5();
    init_utils();
    GLState = class {
      constructor(gl) {
        let {
          copyState = false,
          log: log4 = () => {
          }
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.program = null;
        this.stateStack = [];
        this.enable = true;
        this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
        this.log = log4;
        this._updateCache = this._updateCache.bind(this);
        Object.seal(this);
      }
      push() {
        let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.stateStack.push({});
      }
      pop() {
        assert5(this.stateStack.length > 0);
        const oldValues = this.stateStack[this.stateStack.length - 1];
        setParameters(this.gl, oldValues);
        this.stateStack.pop();
      }
      _updateCache(values) {
        let valueChanged = false;
        let oldValue;
        const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
        for (const key in values) {
          assert5(key !== void 0);
          const value = values[key];
          const cached = this.cache[key];
          if (!deepArrayEqual(value, cached)) {
            valueChanged = true;
            oldValue = cached;
            if (oldValues && !(key in oldValues)) {
              oldValues[key] = cached;
            }
            this.cache[key] = value;
          }
        }
        return {
          valueChanged,
          oldValue
        };
      }
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
function setParameters(gl, values) {
  assert5(isWebGL(gl), "setParameters requires a WebGL context");
  if (isObjectEmpty(values)) {
    return;
  }
  const compositeSetters = {};
  for (const key in values) {
    const glConstant = Number(key);
    const setter = GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === "string") {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }
  const cache2 = gl.state && gl.state.cache;
  if (cache2) {
    for (const key in compositeSetters) {
      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, values, cache2);
    }
  }
}
function getParameters(gl, parameters) {
  parameters = parameters || GL_PARAMETER_DEFAULTS;
  if (typeof parameters === "number") {
    const key = parameters;
    const getter = GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetParameters(gl) {
  setParameters(gl, GL_PARAMETER_DEFAULTS);
}
function withParameters(gl, parameters, func) {
  if (isObjectEmpty(parameters)) {
    return func(gl);
  }
  const {
    nocatch = true
  } = parameters;
  pushContextState(gl);
  setParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    popContextState(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      popContextState(gl);
    }
  }
  return value;
}
var init_unified_parameter_api = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js"() {
    init_webgl_parameter_tables();
    init_track_context_state();
    init_assert5();
    init_webgl_checks();
    init_utils();
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js
function cssToDeviceRatio(gl) {
  const {
    luma
  } = gl;
  if (gl.canvas && luma) {
    const cachedSize = luma.canvasSizeInfo;
    const clientWidth = "clientWidth" in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }
  return 1;
}
function cssToDevicePixels(gl, cssPixel) {
  let yInvert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }
  return useDevicePixels ? windowRatio : 1;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);
  let t = scaleX(pixel[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}
function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}
function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}
var init_device_pixels = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js"() {
  }
});

// node_modules/@luma.gl/gltools/dist/esm/context/context.js
function createGLContext() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  assert5(isBrowser5, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    width,
    height
  } = options;
  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }
    console.error(message);
    return null;
  }
  options.onError = onError;
  let gl;
  const {
    canvas
  } = options;
  const targetCanvas = getCanvas({
    canvas,
    width,
    height,
    onError
  });
  gl = createBrowserContext(targetCanvas, options);
  if (!gl) {
    return null;
  }
  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}
function instrumentGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!gl || gl._instrumented) {
    return gl;
  }
  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    manageState,
    debug: debug2
  } = options;
  if (manageState) {
    trackContextState(gl, {
      copyState: false,
      log: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return log2.log(1, ...args)();
      }
    });
  }
  if (isBrowser5 && debug2) {
    if (!globalThis.makeDebugContext) {
      log2.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = globalThis.makeDebugContext(gl, options);
      log2.level = Math.max(log2.level, 1);
    }
  }
  gl._instrumented = true;
  return gl;
}
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}
function resizeGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (gl.canvas) {
    const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }
  const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}
function createBrowserContext(canvas, options) {
  const {
    onError
  } = options;
  let errorMessage = null;
  const onCreateError = (error2) => errorMessage = error2.statusMessage || errorMessage;
  canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
  const {
    webgl1 = true,
    webgl2 = true
  } = options;
  let gl = null;
  if (webgl2) {
    gl = gl || canvas.getContext("webgl2", options);
    gl = gl || canvas.getContext("experimental-webgl2", options);
  }
  if (webgl1) {
    gl = gl || canvas.getContext("webgl", options);
    gl = gl || canvas.getContext("experimental-webgl", options);
  }
  canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
  }
  if (options.onContextLost) {
    canvas.addEventListener("webglcontextlost", options.onContextLost, false);
  }
  if (options.onContextRestored) {
    canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
  }
  return gl;
}
function getCanvas(_ref) {
  let {
    canvas,
    width = 800,
    height = 600,
    onError
  } = _ref;
  let targetCanvas;
  if (typeof canvas === "string") {
    const isPageLoaded = isPage && document.readyState === "complete";
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }
    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement("canvas");
    targetCanvas.id = "lumagl-canvas";
    targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
    targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }
  return targetCanvas;
}
function logInfo(gl) {
  const webGL = isWebGL2(gl) ? "WebGL2" : "WebGL1";
  const info = getContextDebugInfo(gl);
  const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
  const debug2 = gl.debug ? " debug" : "";
  log2.info(1, "".concat(webGL).concat(debug2, " context ").concat(driver))();
}
function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return 2;
  }
  return 1;
}
function setDevicePixelRatio(gl, devicePixelRatio, options) {
  let clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
  if (!clientWidth || !clientHeight) {
    log2.log(1, "Canvas clientWidth/clientHeight is 0")();
    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;
  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;
    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      log2.warn("Device pixel ratio clamped")();
      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }
    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}
var isBrowser5, isPage, CONTEXT_DEFAULTS;
var init_context = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/context/context.js"() {
    init_esm5();
    init_track_context_state();
    init_log4();
    init_assert5();
    init_device_pixels();
    init_webgl_checks();
    isBrowser5 = isBrowser3();
    isPage = isBrowser5 && typeof document !== "undefined";
    CONTEXT_DEFAULTS = {
      webgl2: true,
      webgl1: true,
      throwOnError: true,
      manageState: true,
      canvas: null,
      debug: false,
      width: 800,
      height: 600
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/index.js
var init_esm9 = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/index.js"() {
    init_log4();
    init_webgl_checks();
    init_polyfill_context();
    init_unified_parameter_api();
    init_track_context_state();
    init_context();
    init_device_pixels();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/init.js
var VERSION6, STARTUP_MESSAGE, StatsManager, lumaStats, init_default;
var init_init3 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/init.js"() {
    init_esm9();
    init_esm3();
    init_esm5();
    VERSION6 = true ? "8.5.20" : "untranspiled source";
    STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
    StatsManager = class {
      constructor() {
        this.stats = /* @__PURE__ */ new Map();
      }
      get(name) {
        if (!this.stats.has(name)) {
          this.stats.set(name, new Stats({
            id: name
          }));
        }
        return this.stats.get(name);
      }
    };
    lumaStats = new StatsManager();
    if (globalThis.luma && globalThis.luma.VERSION !== VERSION6) {
      throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION6));
    }
    if (!globalThis.luma) {
      if (isBrowser3()) {
        log2.log(1, "luma.gl ".concat(VERSION6, " - ").concat(STARTUP_MESSAGE))();
      }
      globalThis.luma = globalThis.luma || {
        VERSION: VERSION6,
        version: VERSION6,
        log: log2,
        stats: lumaStats,
        globals: {
          modules: {},
          nodeIO: {}
        }
      };
    }
    init_default = globalThis.luma;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js
function requestAnimationFrame2(callback) {
  return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
}
function cancelAnimationFrame(timerId) {
  return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
var init_request_animation_frame = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
function assert6(condition, message) {
  if (!condition) {
    throw new Error(message || "luma.gl: assertion failed.");
  }
}
var init_assert6 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
function getKeyValue(gl, name) {
  if (typeof name !== "string") {
    return name;
  }
  const number = Number(name);
  if (!isNaN(number)) {
    return number;
  }
  name = name.replace(/^.*\./, "");
  const value = gl[name];
  assert6(value !== void 0, "Accessing undefined constant GL.".concat(name));
  return value;
}
function getKey(gl, value) {
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }
  return String(value);
}
var init_constants_to_keys = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js"() {
    init_assert6();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
function uid() {
  let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  uidCounters[id] = uidCounters[id] || 1;
  const count2 = uidCounters[id]++;
  return "".concat(id, "-").concat(count2);
}
function isPowerOfTwo(n) {
  assert6(typeof n === "number", "Input must be a number");
  return n && (n & n - 1) === 0;
}
function isObjectEmpty2(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}
var uidCounters;
var init_utils2 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"() {
    init_assert6();
    uidCounters = {};
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
function stubRemovedMethods(instance, className, version, methodNames) {
  const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
  const prototype = Object.getPrototypeOf(instance);
  methodNames.forEach((methodName) => {
    if (prototype.methodName) {
      return;
    }
    prototype[methodName] = () => {
      log2.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
      throw new Error(methodName);
    };
  });
}
var init_stub_methods = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"() {
    init_esm9();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
var ERR_RESOURCE_METHOD_UNDEFINED, Resource;
var init_resource = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/resource.js"() {
    init_esm9();
    init_init3();
    init_constants_to_keys();
    init_assert6();
    init_utils2();
    init_stub_methods();
    ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
    Resource = class {
      get [Symbol.toStringTag]() {
        return "Resource";
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGLContext(gl);
        const {
          id,
          userData = {}
        } = opts;
        this.gl = gl;
        this.gl2 = gl;
        this.id = id || uid(this[Symbol.toStringTag]);
        this.userData = userData;
        this._bound = false;
        this._handle = opts.handle;
        if (this._handle === void 0) {
          this._handle = this._createHandle();
        }
        this.byteLength = 0;
        this._addStats();
      }
      toString() {
        return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
      }
      get handle() {
        return this._handle;
      }
      delete() {
        let {
          deleteChildren = false
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const children = this._handle && this._deleteHandle(this._handle);
        if (this._handle) {
          this._removeStats();
        }
        this._handle = null;
        if (children && deleteChildren) {
          children.filter(Boolean).forEach((child) => child.delete());
        }
        return this;
      }
      bind() {
        let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
        if (typeof funcOrHandle !== "function") {
          this._bindHandle(funcOrHandle);
          return this;
        }
        let value;
        if (!this._bound) {
          this._bindHandle(this.handle);
          this._bound = true;
          value = funcOrHandle();
          this._bound = false;
          this._bindHandle(null);
        } else {
          value = funcOrHandle();
        }
        return value;
      }
      unbind() {
        this.bind(null);
      }
      getParameter(pname) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        pname = getKeyValue(this.gl, pname);
        assert6(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
          const isWebgl2 = isWebGL2(this.gl);
          const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (!parameterAvailable) {
            const webgl1Default = parameter.webgl1;
            const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
            const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
            return defaultValue;
          }
        }
        return this._getParameter(pname, opts);
      }
      getParameters() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          parameters,
          keys
        } = options;
        const PARAMETERS = this.constructor.PARAMETERS || {};
        const isWebgl2 = isWebGL2(this.gl);
        const values = {};
        const parameterKeys = parameters || Object.keys(PARAMETERS);
        for (const pname of parameterKeys) {
          const parameter = PARAMETERS[pname];
          const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (parameterAvailable) {
            const key = keys ? getKey(this.gl, pname) : pname;
            values[key] = this.getParameter(pname, options);
            if (keys && parameter.type === "GLenum") {
              values[key] = getKey(this.gl, values[key]);
            }
          }
        }
        return values;
      }
      setParameter(pname, value) {
        pname = getKeyValue(this.gl, pname);
        assert6(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
          const isWebgl2 = isWebGL2(this.gl);
          const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (!parameterAvailable) {
            throw new Error("Parameter not available on this platform");
          }
          if (parameter.type === "GLenum") {
            value = getKeyValue(value);
          }
        }
        this._setParameter(pname, value);
        return this;
      }
      setParameters(parameters) {
        for (const pname in parameters) {
          this.setParameter(pname, parameters[pname]);
        }
        return this;
      }
      stubRemovedMethods(className, version, methodNames) {
        return stubRemovedMethods(this, className, version, methodNames);
      }
      initialize(opts) {
      }
      _createHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _deleteHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _bindHandle(handle) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _getOptsFromHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _getParameter(pname, opts) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _setParameter(pname, value) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _context() {
        this.gl.luma = this.gl.luma || {};
        return this.gl.luma;
      }
      _addStats() {
        const name = this[Symbol.toStringTag];
        const stats = lumaStats.get("Resource Counts");
        stats.get("Resources Created").incrementCount();
        stats.get("".concat(name, "s Created")).incrementCount();
        stats.get("".concat(name, "s Active")).incrementCount();
      }
      _removeStats() {
        const name = this[Symbol.toStringTag];
        const stats = lumaStats.get("Resource Counts");
        stats.get("".concat(name, "s Active")).decrementCount();
      }
      _trackAllocatedMemory(bytes) {
        let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
        this._trackAllocatedMemoryForContext(bytes, name);
        this._trackAllocatedMemoryForContext(bytes, name, this.gl.canvas && this.gl.canvas.id);
        this.byteLength = bytes;
      }
      _trackAllocatedMemoryForContext(bytes) {
        let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
        let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        const stats = lumaStats.get("Memory Usage".concat(id));
        stats.get("GPU Memory").addCount(bytes);
        stats.get("".concat(name, " Memory")).addCount(bytes);
      }
      _trackDeallocatedMemory() {
        let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
        this._trackDeallocatedMemoryForContext(name);
        this._trackDeallocatedMemoryForContext(name, this.gl.canvas && this.gl.canvas.id);
        this.byteLength = 0;
      }
      _trackDeallocatedMemoryForContext() {
        let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
        let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const stats = lumaStats.get("Memory Usage".concat(id));
        stats.get("GPU Memory").subtractCount(this.byteLength);
        stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType) {
  let {
    clamped = true
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function flipRows(_ref) {
  let {
    data,
    width,
    height,
    bytesPerPixel = 4,
    temp
  } = _ref;
  const bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);
  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}
function scalePixels2(_ref2) {
  let {
    data,
    width,
    height
  } = _ref2;
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);
  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }
  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
var ERR_TYPE_DEDUCTION;
var init_typed_array_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js"() {
    ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
function checkProps(className, props, propChecks) {
  const {
    removedProps = {},
    deprecatedProps = {},
    replacedProps = {}
  } = propChecks;
  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
      log2.removed("".concat(className, ".").concat(propName), replacement)();
    }
  }
  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      log2.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
    }
  }
  let newProps = null;
  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];
      log2.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }
  return newProps || props;
}
var init_check_props = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"() {
    init_esm9();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
var DEFAULT_ACCESSOR_VALUES, PROP_CHECKS, Accessor;
var init_accessor = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js"() {
    init_typed_array_utils();
    init_assert6();
    init_check_props();
    DEFAULT_ACCESSOR_VALUES = {
      offset: 0,
      stride: 0,
      type: 5126,
      size: 1,
      divisor: 0,
      normalized: false,
      integer: false
    };
    PROP_CHECKS = {
      deprecatedProps: {
        instanced: "divisor",
        isInstanced: "divisor"
      }
    };
    Accessor = class {
      static getBytesPerElement(accessor) {
        const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT;
      }
      static getBytesPerVertex(accessor) {
        assert6(accessor.size);
        const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT * accessor.size;
      }
      static resolve() {
        for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
          accessors[_key] = arguments[_key];
        }
        return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
      }
      constructor() {
        for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          accessors[_key2] = arguments[_key2];
        }
        accessors.forEach((accessor) => this._assign(accessor));
        Object.freeze(this);
      }
      toString() {
        return JSON.stringify(this);
      }
      get BYTES_PER_ELEMENT() {
        return Accessor.getBytesPerElement(this);
      }
      get BYTES_PER_VERTEX() {
        return Accessor.getBytesPerVertex(this);
      }
      _assign() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        props = checkProps("Accessor", props, PROP_CHECKS);
        if (props.type !== void 0) {
          this.type = props.type;
          if (props.type === 5124 || props.type === 5125) {
            this.integer = true;
          }
        }
        if (props.size !== void 0) {
          this.size = props.size;
        }
        if (props.offset !== void 0) {
          this.offset = props.offset;
        }
        if (props.stride !== void 0) {
          this.stride = props.stride;
        }
        if (props.normalized !== void 0) {
          this.normalized = props.normalized;
        }
        if (props.integer !== void 0) {
          this.integer = props.integer;
        }
        if (props.divisor !== void 0) {
          this.divisor = props.divisor;
        }
        if (props.buffer !== void 0) {
          this.buffer = props.buffer;
        }
        if (props.index !== void 0) {
          if (typeof props.index === "boolean") {
            this.index = props.index ? 1 : 0;
          } else {
            this.index = props.index;
          }
        }
        if (props.instanced !== void 0) {
          this.divisor = props.instanced ? 1 : 0;
        }
        if (props.isInstanced !== void 0) {
          this.divisor = props.isInstanced ? 1 : 0;
        }
        return this;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
var DEBUG_DATA_LENGTH, DEPRECATED_PROPS, PROP_CHECKS_INITIALIZE, PROP_CHECKS_SET_PROPS, Buffer2;
var init_buffer = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js"() {
    init_resource();
    init_accessor();
    init_typed_array_utils();
    init_esm9();
    init_assert6();
    init_check_props();
    DEBUG_DATA_LENGTH = 10;
    DEPRECATED_PROPS = {
      offset: "accessor.offset",
      stride: "accessor.stride",
      type: "accessor.type",
      size: "accessor.size",
      divisor: "accessor.divisor",
      normalized: "accessor.normalized",
      integer: "accessor.integer",
      instanced: "accessor.divisor",
      isInstanced: "accessor.divisor"
    };
    PROP_CHECKS_INITIALIZE = {
      removedProps: {},
      replacedProps: {
        bytes: "byteLength"
      },
      deprecatedProps: DEPRECATED_PROPS
    };
    PROP_CHECKS_SET_PROPS = {
      removedProps: DEPRECATED_PROPS
    };
    Buffer2 = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Buffer";
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
        this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
        this.initialize(props);
        Object.seal(this);
      }
      getElementCount() {
        let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
      }
      getVertexCount() {
        let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (ArrayBuffer.isView(props)) {
          props = {
            data: props
          };
        }
        if (Number.isFinite(props)) {
          props = {
            byteLength: props
          };
        }
        props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
        this.usage = props.usage || 35044;
        this.debugData = null;
        this.setAccessor(Object.assign({}, props, props.accessor));
        if (props.data) {
          this._setData(props.data, props.offset, props.byteLength);
        } else {
          this._setByteLength(props.byteLength || 0);
        }
        return this;
      }
      setProps(props) {
        props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
        if ("accessor" in props) {
          this.setAccessor(props.accessor);
        }
        return this;
      }
      setAccessor(accessor) {
        accessor = Object.assign({}, accessor);
        delete accessor.buffer;
        this.accessor = new Accessor(accessor);
        return this;
      }
      reallocate(byteLength) {
        if (byteLength > this.byteLength) {
          this._setByteLength(byteLength);
          return true;
        }
        this.bytesUsed = byteLength;
        return false;
      }
      setData(props) {
        return this.initialize(props);
      }
      subData(props) {
        if (ArrayBuffer.isView(props)) {
          props = {
            data: props
          };
        }
        const {
          data,
          offset = 0,
          srcOffset = 0
        } = props;
        const byteLength = props.byteLength || props.length;
        assert6(data);
        const target = this.gl.webgl2 ? 36663 : this.target;
        this.gl.bindBuffer(target, this.handle);
        if (srcOffset !== 0 || byteLength !== void 0) {
          assertWebGL2Context(this.gl);
          this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
        } else {
          this.gl.bufferSubData(target, offset, data);
        }
        this.gl.bindBuffer(target, null);
        this.debugData = null;
        this._inferType(data);
        return this;
      }
      copyData(_ref) {
        let {
          sourceBuffer,
          readOffset = 0,
          writeOffset = 0,
          size
        } = _ref;
        const {
          gl
        } = this;
        assertWebGL2Context(gl);
        gl.bindBuffer(36662, sourceBuffer.handle);
        gl.bindBuffer(36663, this.handle);
        gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
        gl.bindBuffer(36662, null);
        gl.bindBuffer(36663, null);
        this.debugData = null;
        return this;
      }
      getData() {
        let {
          dstData = null,
          srcByteOffset = 0,
          dstOffset = 0,
          length: length4 = 0
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        assertWebGL2Context(this.gl);
        const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
          clamped: false
        });
        const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
        const dstElementOffset = dstOffset;
        let dstAvailableElementCount;
        let dstElementCount;
        if (dstData) {
          dstElementCount = dstData.length;
          dstAvailableElementCount = dstElementCount - dstElementOffset;
        } else {
          dstAvailableElementCount = Math.min(sourceAvailableElementCount, length4 || sourceAvailableElementCount);
          dstElementCount = dstElementOffset + dstAvailableElementCount;
        }
        const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
        length4 = length4 || copyElementCount;
        assert6(length4 <= copyElementCount);
        dstData = dstData || new ArrayType(dstElementCount);
        this.gl.bindBuffer(36662, this.handle);
        this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length4);
        this.gl.bindBuffer(36662, null);
        return dstData;
      }
      bind() {
        let {
          target = this.target,
          index = this.accessor && this.accessor.index,
          offset = 0,
          size
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (target === 35345 || target === 35982) {
          if (size !== void 0) {
            this.gl.bindBufferRange(target, index, this.handle, offset, size);
          } else {
            assert6(offset === 0);
            this.gl.bindBufferBase(target, index, this.handle);
          }
        } else {
          this.gl.bindBuffer(target, this.handle);
        }
        return this;
      }
      unbind() {
        let {
          target = this.target,
          index = this.accessor && this.accessor.index
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const isIndexedBuffer = target === 35345 || target === 35982;
        if (isIndexedBuffer) {
          this.gl.bindBufferBase(target, index, null);
        } else {
          this.gl.bindBuffer(target, null);
        }
        return this;
      }
      getDebugData() {
        if (!this.debugData) {
          this.debugData = this.getData({
            length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
          });
          return {
            data: this.debugData,
            changed: true
          };
        }
        return {
          data: this.debugData,
          changed: false
        };
      }
      invalidateDebugData() {
        this.debugData = null;
      }
      _setData(data) {
        let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
        assert6(ArrayBuffer.isView(data));
        this._trackDeallocatedMemory();
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, byteLength, this.usage);
        this.gl.bufferSubData(target, offset, data);
        this.gl.bindBuffer(target, null);
        this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        const type = getGLTypeFromTypedArray(data);
        assert6(type);
        this.setAccessor(new Accessor(this.accessor, {
          type
        }));
        return this;
      }
      _setByteLength(byteLength) {
        let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
        assert6(byteLength >= 0);
        this._trackDeallocatedMemory();
        let data = byteLength;
        if (byteLength === 0) {
          data = new Float32Array(0);
        }
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, data, usage);
        this.gl.bindBuffer(target, null);
        this.usage = usage;
        this.debugData = null;
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        return this;
      }
      _getTarget() {
        return this.gl.webgl2 ? 36663 : this.target;
      }
      _getAvailableElementCount(srcByteOffset) {
        const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
          clamped: false
        });
        const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
        return this.getElementCount() - sourceElementOffset;
      }
      _inferType(data) {
        if (!this.accessor.type) {
          this.setAccessor(new Accessor(this.accessor, {
            type: getGLTypeFromTypedArray(data)
          }));
        }
      }
      _createHandle() {
        return this.gl.createBuffer();
      }
      _deleteHandle() {
        this.gl.deleteBuffer(this.handle);
        this._trackDeallocatedMemory();
      }
      _getParameter(pname) {
        this.gl.bindBuffer(this.target, this.handle);
        const value = this.gl.getBufferParameter(this.target, pname);
        this.gl.bindBuffer(this.target, null);
        return value;
      }
      get type() {
        log2.deprecated("Buffer.type", "Buffer.accessor.type")();
        return this.accessor.type;
      }
      get bytes() {
        log2.deprecated("Buffer.bytes", "Buffer.byteLength")();
        return this.byteLength;
      }
      setByteLength(byteLength) {
        log2.deprecated("setByteLength", "reallocate")();
        return this.reallocate(byteLength);
      }
      updateAccessor(opts) {
        log2.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
        this.accessor = new Accessor(this.accessor, opts);
        return this;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  if (!info) {
    return false;
  }
  if (info.gl1 === void 0 && info.gl2 === void 0) {
    return true;
  }
  const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === "string" ? gl.getExtension(value) : value;
}
function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension("OES_texture_float_linear");
    case 5131:
      return gl.getExtension("OES_texture_half_float_linear");
    default:
      return true;
  }
}
var TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES;
var init_texture_formats = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js"() {
    init_esm9();
    TEXTURE_FORMATS = {
      [6407]: {
        dataFormat: 6407,
        types: [5121, 33635]
      },
      [6408]: {
        dataFormat: 6408,
        types: [5121, 32819, 32820]
      },
      [6406]: {
        dataFormat: 6406,
        types: [5121]
      },
      [6409]: {
        dataFormat: 6409,
        types: [5121]
      },
      [6410]: {
        dataFormat: 6410,
        types: [5121]
      },
      [33326]: {
        dataFormat: 6403,
        types: [5126],
        gl2: true
      },
      [33328]: {
        dataFormat: 33319,
        types: [5126],
        gl2: true
      },
      [34837]: {
        dataFormat: 6407,
        types: [5126],
        gl2: true
      },
      [34836]: {
        dataFormat: 6408,
        types: [5126],
        gl2: true
      }
    };
    DATA_FORMAT_CHANNELS = {
      [6403]: 1,
      [36244]: 1,
      [33319]: 2,
      [33320]: 2,
      [6407]: 3,
      [36248]: 3,
      [6408]: 4,
      [36249]: 4,
      [6402]: 1,
      [34041]: 1,
      [6406]: 1,
      [6409]: 1,
      [6410]: 2
    };
    TYPE_SIZES = {
      [5126]: 4,
      [5125]: 4,
      [5124]: 4,
      [5123]: 2,
      [5122]: 2,
      [5131]: 2,
      [5120]: 1,
      [5121]: 1
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
var NPOT_MIN_FILTERS, WebGLBuffer, Texture;
var init_texture = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture.js"() {
    init_esm9();
    init_resource();
    init_buffer();
    init_texture_formats();
    init_assert6();
    init_utils2();
    NPOT_MIN_FILTERS = [9729, 9728];
    WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
    };
    Texture = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Texture";
      }
      static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          format,
          linearFiltering
        } = opts;
        let supported = true;
        if (format) {
          supported = supported && isFormatSupported(gl, format);
          supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
        }
        return supported;
      }
      constructor(gl, props) {
        const {
          id = uid("texture"),
          handle,
          target
        } = props;
        super(gl, {
          id,
          handle
        });
        this.target = target;
        this.textureUnit = void 0;
        this.loaded = false;
        this.width = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.format = void 0;
        this.type = void 0;
        this.dataFormat = void 0;
        this.border = void 0;
        this.textureUnit = void 0;
        this.mipmaps = void 0;
      }
      toString() {
        return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let data = props.data;
        if (data instanceof Promise) {
          data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
            pixels: resolvedImageData,
            data: resolvedImageData
          })));
          return this;
        }
        const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
        if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
          this._video = null;
          data.addEventListener("loadeddata", () => this.initialize(props));
          return this;
        }
        const {
          pixels = null,
          format = 6408,
          border = 0,
          recreate = false,
          parameters = {},
          pixelStore = {},
          textureUnit = void 0
        } = props;
        if (!data) {
          data = pixels;
        }
        let {
          width,
          height,
          dataFormat,
          type,
          compressed = false,
          mipmaps = true
        } = props;
        const {
          depth = 0
        } = props;
        ({
          width,
          height,
          compressed,
          dataFormat,
          type
        } = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        }));
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.format = format;
        this.type = type;
        this.dataFormat = dataFormat;
        this.border = border;
        this.textureUnit = textureUnit;
        if (Number.isFinite(this.textureUnit)) {
          this.gl.activeTexture(33984 + this.textureUnit);
          this.gl.bindTexture(this.target, this.handle);
        }
        if (mipmaps && this._isNPOT()) {
          log2.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
          mipmaps = false;
          this._updateForNPOT(parameters);
        }
        this.mipmaps = mipmaps;
        this.setImageData({
          data,
          width,
          height,
          depth,
          format,
          type,
          dataFormat,
          border,
          mipmaps,
          parameters: pixelStore,
          compressed
        });
        if (mipmaps) {
          this.generateMipmap();
        }
        this.setParameters(parameters);
        if (recreate) {
          this.data = data;
        }
        if (isVideo) {
          this._video = {
            video: data,
            parameters,
            lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
          };
        }
        return this;
      }
      update() {
        if (this._video) {
          const {
            video,
            parameters,
            lastTime
          } = this._video;
          if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
            return;
          }
          this.setSubImageData({
            data: video,
            parameters
          });
          if (this.mipmaps) {
            this.generateMipmap();
          }
          this._video.lastTime = video.currentTime;
        }
      }
      resize(_ref) {
        let {
          height,
          width,
          mipmaps = false
        } = _ref;
        if (width !== this.width || height !== this.height) {
          return this.initialize({
            width,
            height,
            format: this.format,
            type: this.type,
            dataFormat: this.dataFormat,
            border: this.border,
            mipmaps
          });
        }
        return this;
      }
      generateMipmap() {
        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._isNPOT()) {
          log2.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
          return this;
        }
        this.mipmaps = true;
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, params, () => {
          this.gl.generateMipmap(this.target);
        });
        this.gl.bindTexture(this.target, null);
        return this;
      }
      setImageData(options) {
        this._trackDeallocatedMemory("Texture");
        const {
          target = this.target,
          pixels = null,
          level = 0,
          format = this.format,
          border = this.border,
          offset = 0,
          parameters = {}
        } = options;
        let {
          data = null,
          type = this.type,
          width = this.width,
          height = this.height,
          dataFormat = this.dataFormat,
          compressed = false
        } = options;
        if (!data) {
          data = pixels;
        }
        ({
          type,
          dataFormat,
          compressed,
          width,
          height
        } = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        }));
        const {
          gl
        } = this;
        gl.bindTexture(this.target, this.handle);
        let dataType = null;
        ({
          data,
          dataType
        } = this._getDataType({
          data,
          compressed
        }));
        let gl2;
        let compressedTextureSize = 0;
        withParameters(this.gl, parameters, () => {
          switch (dataType) {
            case "null":
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
              break;
            case "typed-array":
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
              break;
            case "buffer":
              gl2 = assertWebGL2Context(gl);
              gl2.bindBuffer(35052, data.handle || data);
              gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
              gl2.bindBuffer(35052, null);
              break;
            case "browser-object":
              if (isWebGL2(gl)) {
                gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
              } else {
                gl.texImage2D(target, level, format, dataFormat, type, data);
              }
              break;
            case "compressed":
              for (const [levelIndex, levelData] of data.entries()) {
                gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
                compressedTextureSize += levelData.levelSize;
              }
              break;
            default:
              assert6(false, "Unknown image data type");
          }
        });
        if (dataType === "compressed") {
          this._trackAllocatedMemory(compressedTextureSize, "Texture");
        } else if (data && data.byteLength) {
          this._trackAllocatedMemory(data.byteLength, "Texture");
        } else {
          const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
          const channelSize = TYPE_SIZES[this.type] || 1;
          this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
      }
      setSubImageData(_ref2) {
        let {
          target = this.target,
          pixels = null,
          data = null,
          x = 0,
          y = 0,
          width = this.width,
          height = this.height,
          level = 0,
          format = this.format,
          type = this.type,
          dataFormat = this.dataFormat,
          compressed = false,
          offset = 0,
          border = this.border,
          parameters = {}
        } = _ref2;
        ({
          type,
          dataFormat,
          compressed,
          width,
          height
        } = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        }));
        assert6(this.depth === 0, "texSubImage not supported for 3D textures");
        if (!data) {
          data = pixels;
        }
        if (data && data.data) {
          const ndarray = data;
          data = ndarray.data;
          width = ndarray.shape[0];
          height = ndarray.shape[1];
        }
        if (data instanceof Buffer2) {
          data = data.handle;
        }
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, parameters, () => {
          if (compressed) {
            this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
          } else if (data === null) {
            this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
          } else if (ArrayBuffer.isView(data)) {
            this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
          } else if (data instanceof WebGLBuffer) {
            const gl2 = assertWebGL2Context(this.gl);
            gl2.bindBuffer(35052, data);
            gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
          } else if (isWebGL2(this.gl)) {
            const gl2 = assertWebGL2Context(this.gl);
            gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
          } else {
            this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
          }
        });
        this.gl.bindTexture(this.target, null);
      }
      copyFramebuffer() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
      }
      getActiveUnit() {
        return this.gl.getParameter(34016) - 33984;
      }
      bind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
        const {
          gl
        } = this;
        if (textureUnit !== void 0) {
          this.textureUnit = textureUnit;
          gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, this.handle);
        return textureUnit;
      }
      unbind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
        const {
          gl
        } = this;
        if (textureUnit !== void 0) {
          this.textureUnit = textureUnit;
          gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, null);
        return textureUnit;
      }
      _getDataType(_ref3) {
        let {
          data,
          compressed = false
        } = _ref3;
        if (compressed) {
          return {
            data,
            dataType: "compressed"
          };
        }
        if (data === null) {
          return {
            data,
            dataType: "null"
          };
        }
        if (ArrayBuffer.isView(data)) {
          return {
            data,
            dataType: "typed-array"
          };
        }
        if (data instanceof Buffer2) {
          return {
            data: data.handle,
            dataType: "buffer"
          };
        }
        if (data instanceof WebGLBuffer) {
          return {
            data,
            dataType: "buffer"
          };
        }
        return {
          data,
          dataType: "browser-object"
        };
      }
      _deduceParameters(opts) {
        const {
          format,
          data
        } = opts;
        let {
          width,
          height,
          dataFormat,
          type,
          compressed
        } = opts;
        const textureFormat = TEXTURE_FORMATS[format];
        dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
        type = type || textureFormat && textureFormat.types[0];
        compressed = compressed || textureFormat && textureFormat.compressed;
        ({
          width,
          height
        } = this._deduceImageSize(data, width, height));
        return {
          dataFormat,
          type,
          compressed,
          width,
          height,
          format,
          data
        };
      }
      _deduceImageSize(data, width, height) {
        let size;
        if (typeof ImageData !== "undefined" && data instanceof ImageData) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
          size = {
            width: data.naturalWidth,
            height: data.naturalHeight
          };
        } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
          size = {
            width: data.videoWidth,
            height: data.videoHeight
          };
        } else if (!data) {
          size = {
            width: width >= 0 ? width : 1,
            height: height >= 0 ? height : 1
          };
        } else {
          size = {
            width,
            height
          };
        }
        assert6(size, "Could not deduced texture size");
        assert6(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
        assert6(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
        return size;
      }
      _createHandle() {
        return this.gl.createTexture();
      }
      _deleteHandle() {
        this.gl.deleteTexture(this.handle);
        this._trackDeallocatedMemory("Texture");
      }
      _getParameter(pname) {
        switch (pname) {
          case 4096:
            return this.width;
          case 4097:
            return this.height;
          default:
            this.gl.bindTexture(this.target, this.handle);
            const value = this.gl.getTexParameter(this.target, pname);
            this.gl.bindTexture(this.target, null);
            return value;
        }
      }
      _setParameter(pname, param) {
        this.gl.bindTexture(this.target, this.handle);
        param = this._getNPOTParam(pname, param);
        switch (pname) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.handle, pname, param);
            break;
          case 4096:
          case 4097:
            assert6(false);
            break;
          default:
            this.gl.texParameteri(this.target, pname, param);
            break;
        }
        this.gl.bindTexture(this.target, null);
        return this;
      }
      _isNPOT() {
        if (isWebGL2(this.gl)) {
          return false;
        }
        if (!this.width || !this.height) {
          return false;
        }
        return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
      }
      _updateForNPOT(parameters) {
        if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
          parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
        }
        if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
          parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
        }
        if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
          parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
        }
      }
      _getNPOTParam(pname, param) {
        if (this._isNPOT()) {
          switch (pname) {
            case 10241:
              if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
                param = 9729;
              }
              break;
            case 10242:
            case 10243:
              if (param !== 33071) {
                param = 33071;
              }
              break;
            default:
              break;
          }
        }
        return param;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
function loadImage2(url, opts) {
  assert6(typeof url === "string");
  url = pathPrefix2 + url;
  return new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
      image.crossOrigin = opts && opts.crossOrigin || "anonymous";
      image.src = url;
    } catch (error2) {
      reject(error2);
    }
  });
}
var pathPrefix2;
var init_load_file = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js"() {
    init_assert6();
    pathPrefix2 = "";
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
var Texture2D;
var init_texture_2d = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js"() {
    init_esm9();
    init_texture();
    init_load_file();
    Texture2D = class extends Texture {
      get [Symbol.toStringTag]() {
        return "Texture2D";
      }
      static isSupported(gl, opts) {
        return Texture.isSupported(gl, opts);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGLContext(gl);
        if (props instanceof Promise || typeof props === "string") {
          props = {
            data: props
          };
        }
        if (typeof props.data === "string") {
          props = Object.assign({}, props, {
            data: loadImage2(props.data)
          });
        }
        super(gl, Object.assign({}, props, {
          target: 3553
        }));
        this.initialize(props);
        Object.seal(this);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js
var FACES, TextureCube;
var init_texture_cube = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js"() {
    init_esm9();
    init_texture();
    FACES = [34069, 34070, 34071, 34072, 34073, 34074];
    TextureCube = class extends Texture {
      get [Symbol.toStringTag]() {
        return "TextureCube";
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGLContext(gl);
        super(gl, Object.assign({}, props, {
          target: 34067
        }));
        this.initialize(props);
        Object.seal(this);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          mipmaps = true,
          parameters = {}
        } = props;
        this.opts = props;
        this.setCubeMapImageData(props).then(() => {
          this.loaded = true;
          if (mipmaps) {
            this.generateMipmap(props);
          }
          this.setParameters(parameters);
        });
        return this;
      }
      subImage(_ref) {
        let {
          face,
          data,
          x = 0,
          y = 0,
          mipmapLevel = 0
        } = _ref;
        return this._subImage({
          target: face,
          data,
          x,
          y,
          mipmapLevel
        });
      }
      async setCubeMapImageData(_ref2) {
        let {
          width,
          height,
          pixels,
          data,
          border = 0,
          format = 6408,
          type = 5121
        } = _ref2;
        const {
          gl
        } = this;
        const imageDataMap = pixels || data;
        const resolvedFaces = await Promise.all(FACES.map((face) => {
          const facePixels = imageDataMap[face];
          return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
        }));
        this.bind();
        FACES.forEach((face, index) => {
          if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
            log2.warn("".concat(this.id, " has mipmap and multiple LODs."))();
          }
          resolvedFaces[index].forEach((image, lodLevel) => {
            if (width && height) {
              gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
            } else {
              gl.texImage2D(face, lodLevel, format, format, type, image);
            }
          });
        });
        this.unbind();
      }
      setImageDataForFace(options) {
        const {
          face,
          width,
          height,
          pixels,
          data,
          border = 0,
          format = 6408,
          type = 5121
        } = options;
        const {
          gl
        } = this;
        const imageData = pixels || data;
        this.bind();
        if (imageData instanceof Promise) {
          imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
            face,
            data: resolvedImageData,
            pixels: resolvedImageData
          })));
        } else if (this.width || this.height) {
          gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
        } else {
          gl.texImage2D(face, 0, format, format, type, imageData);
        }
        return this;
      }
    };
    TextureCube.FACES = FACES;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js
var Texture3D;
var init_texture_3d = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js"() {
    init_esm9();
    init_texture();
    init_texture_formats();
    init_buffer();
    Texture3D = class extends Texture {
      get [Symbol.toStringTag]() {
        return "Texture3D";
      }
      static isSupported(gl) {
        return isWebGL2(gl);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGL2Context(gl);
        props = Object.assign({
          depth: 1
        }, props, {
          target: 32879,
          unpackFlipY: false
        });
        super(gl, props);
        this.initialize(props);
        Object.seal(this);
      }
      setImageData(_ref) {
        let {
          level = 0,
          dataFormat = 6408,
          width,
          height,
          depth = 1,
          border = 0,
          format,
          type = 5121,
          offset = 0,
          data,
          parameters = {}
        } = _ref;
        this._trackDeallocatedMemory("Texture");
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, parameters, () => {
          if (ArrayBuffer.isView(data)) {
            this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
          }
          if (data instanceof Buffer2) {
            this.gl.bindBuffer(35052, data.handle);
            this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
          }
        });
        if (data && data.byteLength) {
          this._trackAllocatedMemory(data.byteLength, "Texture");
        } else {
          const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
          const channelSize = TYPE_SIZES[this.type] || 1;
          this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
var EXT_FLOAT_WEBGL2, renderbuffer_formats_default;
var init_renderbuffer_formats = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js"() {
    EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
    renderbuffer_formats_default = {
      [33189]: {
        bpp: 2
      },
      [33190]: {
        gl2: true,
        bpp: 3
      },
      [36012]: {
        gl2: true,
        bpp: 4
      },
      [36168]: {
        bpp: 1
      },
      [34041]: {
        bpp: 4
      },
      [35056]: {
        gl2: true,
        bpp: 4
      },
      [36013]: {
        gl2: true,
        bpp: 5
      },
      [32854]: {
        bpp: 2
      },
      [36194]: {
        bpp: 2
      },
      [32855]: {
        bpp: 2
      },
      [33321]: {
        gl2: true,
        bpp: 1
      },
      [33330]: {
        gl2: true,
        bpp: 1
      },
      [33329]: {
        gl2: true,
        bpp: 1
      },
      [33332]: {
        gl2: true,
        bpp: 2
      },
      [33331]: {
        gl2: true,
        bpp: 2
      },
      [33334]: {
        gl2: true,
        bpp: 4
      },
      [33333]: {
        gl2: true,
        bpp: 4
      },
      [33323]: {
        gl2: true,
        bpp: 2
      },
      [33336]: {
        gl2: true,
        bpp: 2
      },
      [33335]: {
        gl2: true,
        bpp: 2
      },
      [33338]: {
        gl2: true,
        bpp: 4
      },
      [33337]: {
        gl2: true,
        bpp: 4
      },
      [33340]: {
        gl2: true,
        bpp: 8
      },
      [33339]: {
        gl2: true,
        bpp: 8
      },
      [32849]: {
        gl2: true,
        bpp: 3
      },
      [32856]: {
        gl2: true,
        bpp: 4
      },
      [32857]: {
        gl2: true,
        bpp: 4
      },
      [36220]: {
        gl2: true,
        bpp: 4
      },
      [36238]: {
        gl2: true,
        bpp: 4
      },
      [36975]: {
        gl2: true,
        bpp: 4
      },
      [36214]: {
        gl2: true,
        bpp: 8
      },
      [36232]: {
        gl2: true,
        bpp: 8
      },
      [36226]: {
        gl2: true,
        bpp: 16
      },
      [36208]: {
        gl2: true,
        bpp: 16
      },
      [33325]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 2
      },
      [33327]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 4
      },
      [34842]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 8
      },
      [33326]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 4
      },
      [33328]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 8
      },
      [34836]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 16
      },
      [35898]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 4
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
function isFormatSupported2(gl, format, formats) {
  const info = formats[format];
  if (!info) {
    return false;
  }
  const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
  if (typeof value === "string") {
    return gl.getExtension(value);
  }
  return value;
}
var Renderbuffer;
var init_renderbuffer = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js"() {
    init_resource();
    init_renderbuffer_formats();
    init_esm9();
    init_assert6();
    Renderbuffer = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Renderbuffer";
      }
      static isSupported(gl) {
        let {
          format
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          format: null
        };
        return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
      }
      static getSamplesForFormat(gl, _ref) {
        let {
          format
        } = _ref;
        return gl.getInternalformatParameter(36161, format, 32937);
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, opts);
        this.initialize(opts);
        Object.seal(this);
      }
      initialize(_ref2) {
        let {
          format,
          width = 1,
          height = 1,
          samples = 0
        } = _ref2;
        assert6(format, "Needs format");
        this._trackDeallocatedMemory();
        this.gl.bindRenderbuffer(36161, this.handle);
        if (samples !== 0 && isWebGL2(this.gl)) {
          this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
        } else {
          this.gl.renderbufferStorage(36161, format, width, height);
        }
        this.format = format;
        this.width = width;
        this.height = height;
        this.samples = samples;
        this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
        return this;
      }
      resize(_ref3) {
        let {
          width,
          height
        } = _ref3;
        if (width !== this.width || height !== this.height) {
          return this.initialize({
            width,
            height,
            format: this.format,
            samples: this.samples
          });
        }
        return this;
      }
      _createHandle() {
        return this.gl.createRenderbuffer();
      }
      _deleteHandle() {
        this.gl.deleteRenderbuffer(this.handle);
        this._trackDeallocatedMemory();
      }
      _bindHandle(handle) {
        this.gl.bindRenderbuffer(36161, handle);
      }
      _syncHandle(handle) {
        this.format = this.getParameter(36164);
        this.width = this.getParameter(36162);
        this.height = this.getParameter(36163);
        this.samples = this.getParameter(36011);
      }
      _getParameter(pname) {
        this.gl.bindRenderbuffer(36161, this.handle);
        const value = this.gl.getRenderbufferParameter(36161, pname);
        return value;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
function clear(gl) {
  let {
    framebuffer = null,
    color = null,
    depth = null,
    stencil = null
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const parameters = {};
  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }
  let clearFlags = 0;
  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;
    if (color !== true) {
      parameters.clearColor = color;
    }
  }
  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }
  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }
  assert6(clearFlags !== 0, ERR_ARGUMENTS);
  withParameters(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}
function clearBuffer(gl) {
  let {
    framebuffer = null,
    buffer = GL_COLOR,
    drawBuffer = 0,
    value = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  assertWebGL2Context(gl);
  withParameters(gl, {
    framebuffer
  }, () => {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;
          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;
          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }
        break;
      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;
      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;
      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;
      default:
        assert6(false, ERR_ARGUMENTS);
    }
  });
}
var GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, GL_COLOR_BUFFER_BIT, GL_COLOR, GL_DEPTH, GL_STENCIL, GL_DEPTH_STENCIL, ERR_ARGUMENTS;
var init_clear = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/clear.js"() {
    init_esm9();
    init_assert6();
    GL_DEPTH_BUFFER_BIT = 256;
    GL_STENCIL_BUFFER_BIT = 1024;
    GL_COLOR_BUFFER_BIT = 16384;
    GL_COLOR = 6144;
    GL_DEPTH = 6145;
    GL_STENCIL = 6146;
    GL_DEPTH_STENCIL = 34041;
    ERR_ARGUMENTS = "clear: bad arguments";
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      assert6(false);
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      assert6(false);
      return 0;
  }
}
var init_format_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js"() {
    init_assert6();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
function readPixelsToArray(source) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408
  } = options;
  let {
    sourceAttachment = 36064,
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert6(framebuffer);
  const {
    gl,
    handle,
    attachments
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }
  assert6(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || getGLTypeFromTypedArray(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function readPixelsToBuffer(source, _ref) {
  let {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408,
    target = null,
    targetByteOffset = 0,
    sourceWidth,
    sourceHeight,
    sourceType
  } = _ref;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert6(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const gl2 = assertWebGL2Context(framebuffer.gl);
  sourceType = sourceType || (target ? target.type : 5121);
  if (!target) {
    const components = glFormatToComponents(sourceFormat);
    const byteCount = glTypeToBytes(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new Buffer2(gl2, {
      byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }
  target.bind({
    target: 35051
  });
  withParameters(gl2, {
    framebuffer
  }, () => {
    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function copyToDataUrl(source) {
  let {
    sourceAttachment = 36064,
    targetMaxHeight = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let data = readPixelsToArray(source, {
    sourceAttachment
  });
  let {
    width,
    height
  } = source;
  while (height > targetMaxHeight) {
    ({
      data,
      width,
      height
    } = scalePixels2({
      data,
      width,
      height
    }));
  }
  flipRows({
    data,
    width,
    height
  });
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext("2d");
  const imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}
function copyToTexture(source, target) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options;
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert6(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  const isSubCopy = typeof targetX !== "undefined" || typeof targetY !== "undefined" || typeof targetZ !== "undefined";
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(36160, handle);
  assert6(target);
  let texture = null;
  if (target instanceof Texture) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }
  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        const gl2 = assertWebGL2Context(gl);
        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;
      default:
    }
  }
  if (texture) {
    texture.unbind();
  }
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return texture;
}
function getFramebuffer(source) {
  if (!(source instanceof Framebuffer)) {
    return {
      framebuffer: toFramebuffer(source),
      deleteFramebuffer: true
    };
  }
  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}
function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || 5121;
  const ArrayType = getTypedArrayFromGLType(type, {
    clamped: false
  });
  const components = glFormatToComponents(format);
  return new ArrayType(width * height * components);
}
var init_copy_and_blit = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js"() {
    init_buffer();
    init_framebuffer();
    init_texture();
    init_esm9();
    init_typed_array_utils();
    init_typed_array_utils();
    init_format_utils();
    init_texture_utils();
    init_assert6();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js
var webgl_limits_table_default;
var init_webgl_limits_table = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js"() {
    webgl_limits_table_default = {
      [33902]: {
        gl1: new Float32Array([1, 1])
      },
      [33901]: {
        gl1: new Float32Array([1, 1])
      },
      [3379]: {
        gl1: 64,
        gl2: 2048
      },
      [34076]: {
        gl1: 16
      },
      [34930]: {
        gl1: 8
      },
      [35661]: {
        gl1: 8
      },
      [35660]: {
        gl1: 0
      },
      [34024]: {
        gl1: 1
      },
      [36348]: {
        gl1: 8
      },
      [34921]: {
        gl1: 8
      },
      [36347]: {
        gl1: 128
      },
      [36349]: {
        gl1: 16
      },
      [3386]: {
        gl1: new Int32Array([0, 0])
      },
      [32883]: {
        gl1: 0,
        gl2: 256
      },
      [35071]: {
        gl1: 0,
        gl2: 256
      },
      [37447]: {
        gl1: 0,
        gl2: 0
      },
      [36063]: {
        gl1: 0,
        gl2: 4
      },
      [35379]: {
        gl1: 0,
        gl2: 0
      },
      [35374]: {
        gl1: 0,
        gl2: 0
      },
      [35377]: {
        gl1: 0,
        gl2: 0
      },
      [34852]: {
        gl1: 0,
        gl2: 4
      },
      [36203]: {
        gl1: 0,
        gl2: 0
      },
      [33001]: {
        gl1: 0,
        gl2: 0
      },
      [33e3]: {
        gl1: 0,
        gl2: 0
      },
      [37157]: {
        gl1: 0,
        gl2: 0
      },
      [35373]: {
        gl1: 0,
        gl2: 0
      },
      [35657]: {
        gl1: 0,
        gl2: 0
      },
      [36183]: {
        gl1: 0,
        gl2: 0
      },
      [37137]: {
        gl1: 0,
        gl2: 0
      },
      [34045]: {
        gl1: 0,
        gl2: 0
      },
      [35978]: {
        gl1: 0,
        gl2: 0
      },
      [35979]: {
        gl1: 0,
        gl2: 0
      },
      [35968]: {
        gl1: 0,
        gl2: 0
      },
      [35376]: {
        gl1: 0,
        gl2: 0
      },
      [35375]: {
        gl1: 0,
        gl2: 0
      },
      [35659]: {
        gl1: 0,
        gl2: 0
      },
      [37154]: {
        gl1: 0,
        gl2: 0
      },
      [35371]: {
        gl1: 0,
        gl2: 0
      },
      [35658]: {
        gl1: 0,
        gl2: 0
      },
      [35076]: {
        gl1: 0,
        gl2: -8,
        negative: true
      },
      [35077]: {
        gl1: 0,
        gl2: 7
      },
      [35380]: {
        gl1: 0,
        gl2: 0
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/limits.js
var init_limits = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/limits.js"() {
    init_webgl_limits_table();
    init_esm9();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
function checkFloat32ColorAttachment(gl) {
  const testTexture = new Texture2D(gl, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  });
  const testFb = new Framebuffer(gl, {
    id: "test-framebuffer",
    check: false,
    attachments: {
      [36064]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  return status === 36053;
}
var FEATURES, webgl_features_table_default;
var init_webgl_features_table = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js"() {
    init_framebuffer();
    init_texture_2d();
    FEATURES = {
      WEBGL2: "WEBGL2",
      VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
      TIMER_QUERY: "TIMER_QUERY",
      INSTANCED_RENDERING: "INSTANCED_RENDERING",
      MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
      ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
      BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
      FLOAT_BLEND: "FLOAT_BLEND",
      COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
      TEXTURE_DEPTH: "TEXTURE_DEPTH",
      TEXTURE_FLOAT: "TEXTURE_FLOAT",
      TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
      TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
      TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
      TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
      COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
      COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
      COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
      GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
      GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
      GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
      GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
    };
    webgl_features_table_default = {
      [FEATURES.WEBGL2]: [false, true],
      [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
      [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
      [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
      [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
      [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
      [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
      [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
      [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
      [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
      [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
      [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
      [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
      [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
      [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
      [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
      [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
      [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
      [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
      [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
      [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
      [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/features.js
function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every((feature) => {
    return isFeatureSupported(gl, feature);
  });
}
function getFeatures(gl) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  for (const cap in webgl_features_table_default) {
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }
  return gl.luma.caps;
}
function isFeatureSupported(gl, cap) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  if (gl.luma.caps[cap] === void 0) {
    gl.luma.caps[cap] = queryFeature(gl, cap);
  }
  if (!gl.luma.caps[cap]) {
    log2.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
  }
  return gl.luma.caps[cap];
}
function queryFeature(gl, cap) {
  const feature = webgl_features_table_default[cap];
  assert6(feature, cap);
  let isSupported2;
  const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  if (typeof featureDefinition === "function") {
    isSupported2 = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported2 = true;
    for (const extension of featureDefinition) {
      isSupported2 = isSupported2 && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === "string") {
    isSupported2 = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === "boolean") {
    isSupported2 = featureDefinition;
  } else {
    assert6(false);
  }
  return isSupported2;
}
var LOG_UNSUPPORTED_FEATURE;
var init_features = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/features.js"() {
    init_webgl_features_table();
    init_esm9();
    init_assert6();
    LOG_UNSUPPORTED_FEATURE = 2;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js
var init_check_old_ie = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js
var init_check_glsl_extension = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js"() {
    init_check_old_ie();
    init_webgl_features_table();
    init_assert6();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/index.js
var init_features2 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/index.js"() {
    init_limits();
    init_webgl_features_table();
    init_features();
    init_check_glsl_extension();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}
var ERR_MULTIPLE_RENDERTARGETS, Framebuffer, FRAMEBUFFER_ATTACHMENT_PARAMETERS;
var init_framebuffer = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js"() {
    init_esm9();
    init_resource();
    init_texture_2d();
    init_renderbuffer();
    init_clear();
    init_copy_and_blit();
    init_features2();
    init_constants_to_keys();
    init_assert6();
    ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
    Framebuffer = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Framebuffer";
      }
      static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          colorBufferFloat,
          colorBufferHalfFloat
        } = options;
        let supported = true;
        if (colorBufferFloat) {
          supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
        }
        if (colorBufferHalfFloat) {
          supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
        }
        return supported;
      }
      static getDefaultFramebuffer(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
          id: "default-framebuffer",
          handle: null,
          attachments: {}
        });
        return gl.luma.defaultFramebuffer;
      }
      get MAX_COLOR_ATTACHMENTS() {
        const gl2 = assertWebGL2Context(this.gl);
        return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
      }
      get MAX_DRAW_BUFFERS() {
        const gl2 = assertWebGL2Context(this.gl);
        return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, opts);
        this.width = null;
        this.height = null;
        this.attachments = {};
        this.readBuffer = 36064;
        this.drawBuffers = [36064];
        this.ownResources = [];
        this.initialize(opts);
        Object.seal(this);
      }
      get color() {
        return this.attachments[36064] || null;
      }
      get texture() {
        return this.attachments[36064] || null;
      }
      get depth() {
        return this.attachments[36096] || this.attachments[33306] || null;
      }
      get stencil() {
        return this.attachments[36128] || this.attachments[33306] || null;
      }
      initialize(_ref) {
        let {
          width = 1,
          height = 1,
          attachments = null,
          color = true,
          depth = true,
          stencil = false,
          check = true,
          readBuffer = void 0,
          drawBuffers = void 0
        } = _ref;
        assert6(width >= 0 && height >= 0, "Width and height need to be integers");
        this.width = width;
        this.height = height;
        if (attachments) {
          for (const attachment in attachments) {
            const target = attachments[attachment];
            const object = Array.isArray(target) ? target[0] : target;
            object.resize({
              width,
              height
            });
          }
        } else {
          attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
        }
        this.update({
          clearAttachments: true,
          attachments,
          readBuffer,
          drawBuffers
        });
        if (attachments && check) {
          this.checkStatus();
        }
      }
      delete() {
        for (const resource of this.ownResources) {
          resource.delete();
        }
        super.delete();
        return this;
      }
      update(_ref2) {
        let {
          attachments = {},
          readBuffer,
          drawBuffers,
          clearAttachments = false,
          resizeAttachments = true
        } = _ref2;
        this.attach(attachments, {
          clearAttachments,
          resizeAttachments
        });
        const {
          gl
        } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        if (readBuffer) {
          this._setReadBuffer(readBuffer);
        }
        if (drawBuffers) {
          this._setDrawBuffers(drawBuffers);
        }
        gl.bindFramebuffer(36160, prevHandle || null);
        return this;
      }
      resize() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let {
          width,
          height
        } = options;
        if (this.handle === null) {
          assert6(width === void 0 && height === void 0);
          this.width = this.gl.drawingBufferWidth;
          this.height = this.gl.drawingBufferHeight;
          return this;
        }
        if (width === void 0) {
          width = this.gl.drawingBufferWidth;
        }
        if (height === void 0) {
          height = this.gl.drawingBufferHeight;
        }
        if (width !== this.width && height !== this.height) {
          log2.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
        }
        for (const attachmentPoint in this.attachments) {
          this.attachments[attachmentPoint].resize({
            width,
            height
          });
        }
        this.width = width;
        this.height = height;
        return this;
      }
      attach(attachments) {
        let {
          clearAttachments = false,
          resizeAttachments = true
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const newAttachments = {};
        if (clearAttachments) {
          Object.keys(this.attachments).forEach((key) => {
            newAttachments[key] = null;
          });
        }
        Object.assign(newAttachments, attachments);
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        for (const key in newAttachments) {
          assert6(key !== void 0, "Misspelled framebuffer binding point?");
          const attachment = Number(key);
          const descriptor = newAttachments[attachment];
          let object = descriptor;
          if (!object) {
            this._unattach(attachment);
          } else if (object instanceof Renderbuffer) {
            this._attachRenderbuffer({
              attachment,
              renderbuffer: object
            });
          } else if (Array.isArray(descriptor)) {
            const [texture, layer = 0, level = 0] = descriptor;
            object = texture;
            this._attachTexture({
              attachment,
              texture,
              layer,
              level
            });
          } else {
            this._attachTexture({
              attachment,
              texture: object,
              layer: 0,
              level: 0
            });
          }
          if (resizeAttachments && object) {
            object.resize({
              width: this.width,
              height: this.height
            });
          }
        }
        this.gl.bindFramebuffer(36160, prevHandle || null);
        Object.assign(this.attachments, attachments);
        Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
          delete this.attachments[key];
        });
      }
      checkStatus() {
        const {
          gl
        } = this;
        const status = this.getStatus();
        if (status !== 36053) {
          throw new Error(_getFrameBufferStatus(status));
        }
        return this;
      }
      getStatus() {
        const {
          gl
        } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        const status = gl.checkFramebufferStatus(36160);
        gl.bindFramebuffer(36160, prevHandle || null);
        return status;
      }
      clear() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          color,
          depth,
          stencil,
          drawBuffers = []
        } = options;
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        if (color || depth || stencil) {
          clear(this.gl, {
            color,
            depth,
            stencil
          });
        }
        drawBuffers.forEach((value, drawBuffer) => {
          clearBuffer(this.gl, {
            drawBuffer,
            value
          });
        });
        this.gl.bindFramebuffer(36160, prevHandle || null);
        return this;
      }
      readPixels() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
        return null;
      }
      readPixelsToBuffer() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
        return null;
      }
      copyToDataUrl() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
        return null;
      }
      copyToImage() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
        return null;
      }
      copyToTexture() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
      }
      blit() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
        return null;
      }
      invalidate(_ref3) {
        let {
          attachments = [],
          x = 0,
          y = 0,
          width,
          height
        } = _ref3;
        const gl2 = assertWebGL2Context(this.gl);
        const prevHandle = gl2.bindFramebuffer(36008, this.handle);
        const invalidateAll = x === 0 && y === 0 && width === void 0 && height === void 0;
        if (invalidateAll) {
          gl2.invalidateFramebuffer(36008, attachments);
        } else {
          gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
        }
        gl2.bindFramebuffer(36008, prevHandle);
        return this;
      }
      getAttachmentParameter(attachment, pname, keys) {
        let value = this._getAttachmentParameterFallback(pname);
        if (value === null) {
          this.gl.bindFramebuffer(36160, this.handle);
          value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
          this.gl.bindFramebuffer(36160, null);
        }
        if (keys && value > 1e3) {
          value = getKey(this.gl, value);
        }
        return value;
      }
      getAttachmentParameters() {
        let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
        let keys = arguments.length > 1 ? arguments[1] : void 0;
        let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
        const values = {};
        for (const pname of parameters) {
          const key = keys ? getKey(this.gl, pname) : pname;
          values[key] = this.getAttachmentParameter(attachment, pname, keys);
        }
        return values;
      }
      getParameters() {
        let keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        const attachments = Object.keys(this.attachments);
        const parameters = {};
        for (const attachmentName of attachments) {
          const attachment = Number(attachmentName);
          const key = keys ? getKey(this.gl, attachment) : attachment;
          parameters[key] = this.getAttachmentParameters(attachment, keys);
        }
        return parameters;
      }
      show() {
        if (typeof window !== "undefined") {
          window.open(copyToDataUrl(this), "luma-debug-texture");
        }
        return this;
      }
      log() {
        let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (logLevel > log2.level || typeof window === "undefined") {
          return this;
        }
        message = message || "Framebuffer ".concat(this.id);
        const image = copyToDataUrl(this, {
          targetMaxHeight: 100
        });
        log2.image({
          logLevel,
          message,
          image
        }, message)();
        return this;
      }
      bind() {
        let {
          target = 36160
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.gl.bindFramebuffer(target, this.handle);
        return this;
      }
      unbind() {
        let {
          target = 36160
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.gl.bindFramebuffer(target, null);
        return this;
      }
      _createDefaultAttachments(color, depth, stencil, width, height) {
        let defaultAttachments = null;
        if (color) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[36064] = new Texture2D(this.gl, {
            id: "".concat(this.id, "-color0"),
            pixels: null,
            format: 6408,
            type: 5121,
            width,
            height,
            mipmaps: false,
            parameters: {
              [10241]: 9729,
              [10240]: 9729,
              [10242]: 33071,
              [10243]: 33071
            }
          });
          this.ownResources.push(defaultAttachments[36064]);
        }
        if (depth && stencil) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[33306] = new Renderbuffer(this.gl, {
            id: "".concat(this.id, "-depth-stencil"),
            format: 35056,
            width,
            height: 111
          });
          this.ownResources.push(defaultAttachments[33306]);
        } else if (depth) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[36096] = new Renderbuffer(this.gl, {
            id: "".concat(this.id, "-depth"),
            format: 33189,
            width,
            height
          });
          this.ownResources.push(defaultAttachments[36096]);
        } else if (stencil) {
          assert6(false);
        }
        return defaultAttachments;
      }
      _unattach(attachment) {
        const oldAttachment = this.attachments[attachment];
        if (!oldAttachment) {
          return;
        }
        if (oldAttachment instanceof Renderbuffer) {
          this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
        } else {
          this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
        }
        delete this.attachments[attachment];
      }
      _attachRenderbuffer(_ref4) {
        let {
          attachment = 36064,
          renderbuffer
        } = _ref4;
        const {
          gl
        } = this;
        gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
        this.attachments[attachment] = renderbuffer;
      }
      _attachTexture(_ref5) {
        let {
          attachment = 36064,
          texture,
          layer,
          level
        } = _ref5;
        const {
          gl
        } = this;
        gl.bindTexture(texture.target, texture.handle);
        switch (texture.target) {
          case 35866:
          case 32879:
            const gl2 = assertWebGL2Context(gl);
            gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
            break;
          case 34067:
            const face = mapIndexToCubeMapFace(layer);
            gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
            break;
          case 3553:
            gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
            break;
          default:
            assert6(false, "Illegal texture type");
        }
        gl.bindTexture(texture.target, null);
        this.attachments[attachment] = texture;
      }
      _setReadBuffer(readBuffer) {
        const gl2 = getWebGL2Context(this.gl);
        if (gl2) {
          gl2.readBuffer(readBuffer);
        } else {
          assert6(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
        }
        this.readBuffer = readBuffer;
      }
      _setDrawBuffers(drawBuffers) {
        const {
          gl
        } = this;
        const gl2 = assertWebGL2Context(gl);
        if (gl2) {
          gl2.drawBuffers(drawBuffers);
        } else {
          const ext = gl.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ext.drawBuffersWEBGL(drawBuffers);
          } else {
            assert6(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
          }
        }
        this.drawBuffers = drawBuffers;
      }
      _getAttachmentParameterFallback(pname) {
        const caps = getFeatures(this.gl);
        switch (pname) {
          case 36052:
            return !caps.WEBGL2 ? 0 : null;
          case 33298:
          case 33299:
          case 33300:
          case 33301:
          case 33302:
          case 33303:
            return !caps.WEBGL2 ? 8 : null;
          case 33297:
            return !caps.WEBGL2 ? 5125 : null;
          case 33296:
            return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
          default:
            return null;
        }
      }
      _createHandle() {
        return this.gl.createFramebuffer();
      }
      _deleteHandle() {
        this.gl.deleteFramebuffer(this.handle);
      }
      _bindHandle(handle) {
        return this.gl.bindFramebuffer(36160, handle);
      }
    };
    FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
    Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
function cloneTextureFrom(refTexture, overrides) {
  assert6(refTexture instanceof Texture2D || refTexture instanceof TextureCube || refTexture instanceof Texture3D);
  const TextureType = refTexture.constructor;
  const {
    gl,
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  } = refTexture;
  const textureOptions = Object.assign({
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}
function toFramebuffer(texture, opts) {
  const {
    gl,
    width,
    height,
    id
  } = texture;
  const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width,
    height,
    attachments: {
      [36064]: texture
    }
  }));
  return framebuffer;
}
var init_texture_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js"() {
    init_texture_2d();
    init_texture_cube();
    init_texture_3d();
    init_framebuffer();
    init_assert6();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
function getShaderName(shader) {
  let defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
var init_get_shader_name = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return "fragment";
    case GL_VERTEX_SHADER:
      return "vertex";
    default:
      return "unknown type";
  }
}
var GL_FRAGMENT_SHADER, GL_VERTEX_SHADER;
var init_get_shader_type_name = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"() {
    GL_FRAGMENT_SHADER = 35632;
    GL_VERTEX_SHADER = 35633;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};
  const name = shaderName || getShaderName(src) || "(unnamed)";
  const shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name);
  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];
    if (errorString.length <= 1) {
      continue;
    }
    const segments = errorString.split(":");
    const type = segments[0];
    const line = parseInt(segments[2], 10);
    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }
    if (type !== "WARNING") {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }
  const lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}
function formatErrors(errors, lines) {
  let message = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }
    message += "".concat(line, "\n");
    if (errors[i + 1]) {
      const error2 = errors[i + 1];
      const segments = error2.split(":", 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error2.substring(segments.join(":").length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }
  return message;
}
function addLineNumbers(string) {
  let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  let delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start - 1).length;
  return lines.map((line, i) => {
    const lineNumber = String(i + start);
    const digits = lineNumber.length;
    const prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}
function padLeft(string, digits) {
  let result = "";
  for (let i = 0; i < digits; ++i) {
    result += " ";
  }
  return "".concat(result).concat(string);
}
var init_format_glsl_error = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js"() {
    init_get_shader_name();
    init_get_shader_type_name();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js
function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);
  if (words.length >= 2 && words[0] === "#version") {
    const v = parseInt(words[1], 10);
    if (Number.isFinite(v)) {
      version = v;
    }
  }
  return version;
}
var init_get_shader_version = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js
var init_glsl_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js"() {
    init_format_glsl_error();
    init_get_shader_name();
    init_get_shader_version();
    init_get_shader_type_name();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
var ERR_SOURCE, Shader, VertexShader, FragmentShader;
var init_shader = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/shader.js"() {
    init_esm9();
    init_glsl_utils();
    init_assert6();
    init_utils2();
    init_resource();
    ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
    Shader = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Shader";
      }
      static getTypeName(shaderType) {
        switch (shaderType) {
          case 35633:
            return "vertex-shader";
          case 35632:
            return "fragment-shader";
          default:
            assert6(false);
            return "unknown";
        }
      }
      constructor(gl, props) {
        assertWebGLContext(gl);
        assert6(typeof props.source === "string", ERR_SOURCE);
        const id = getShaderName(props.source, null) || props.id || uid("unnamed ".concat(Shader.getTypeName(props.shaderType)));
        super(gl, {
          id
        });
        this.shaderType = props.shaderType;
        this.source = props.source;
        this.initialize(props);
      }
      initialize(_ref) {
        let {
          source
        } = _ref;
        const shaderName = getShaderName(source, null);
        if (shaderName) {
          this.id = uid(shaderName);
        }
        this._compile(source);
      }
      getParameter(pname) {
        return this.gl.getShaderParameter(this.handle, pname);
      }
      toString() {
        return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
      }
      getName() {
        return getShaderName(this.source) || "unnamed-shader";
      }
      getSource() {
        return this.gl.getShaderSource(this.handle);
      }
      getTranslatedSource() {
        const extension = this.gl.getExtension("WEBGL_debug_shaders");
        return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
      }
      _compile() {
        let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
        if (!source.startsWith("#version ")) {
          source = "#version 100\n".concat(source);
        }
        this.source = source;
        this.gl.shaderSource(this.handle, this.source);
        this.gl.compileShader(this.handle);
        const compileStatus = this.getParameter(35713);
        if (!compileStatus) {
          const infoLog = this.gl.getShaderInfoLog(this.handle);
          const {
            shaderName,
            errors,
            warnings
          } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);
          log2.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
          log2.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
          throw new Error("GLSL compilation errors in ".concat(shaderName));
        }
      }
      _deleteHandle() {
        this.gl.deleteShader(this.handle);
      }
      _getOptsFromHandle() {
        return {
          type: this.getParameter(35663),
          source: this.getSource()
        };
      }
    };
    VertexShader = class extends Shader {
      get [Symbol.toStringTag]() {
        return "VertexShader";
      }
      constructor(gl, props) {
        if (typeof props === "string") {
          props = {
            source: props
          };
        }
        super(gl, Object.assign({}, props, {
          shaderType: 35633
        }));
      }
      _createHandle() {
        return this.gl.createShader(35633);
      }
    };
    FragmentShader = class extends Shader {
      get [Symbol.toStringTag]() {
        return "FragmentShader";
      }
      constructor(gl, props) {
        if (typeof props === "string") {
          props = {
            source: props
          };
        }
        super(gl, Object.assign({}, props, {
          shaderType: 35632
        }));
      }
      _createHandle() {
        return this.gl.createShader(35632);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
function toTypedArray(value, uniformLength, Type, cache2) {
  if (uniformLength === 1 && typeof value === "boolean") {
    value = value ? 1 : 0;
  }
  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }
  const length4 = value.length;
  if (length4 % uniformLength) {
    log2.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
  }
  if (value instanceof Type) {
    return value;
  }
  let result = cache2[length4];
  if (!result) {
    result = new Type(length4);
    cache2[length4] = result;
  }
  for (let i = 0; i < length4; i++) {
    result[i] = value[i];
  }
  return result;
}
function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}
function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}
function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}
function getUniformSetter(gl, location, info) {
  const setter = UNIFORM_SETTERS[info.type];
  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }
  return setter().bind(null, gl, location);
}
function parseUniformName(name) {
  if (name[name.length - 1] !== "]") {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches3 = name.match(UNIFORM_NAME_REGEXP);
  if (!matches3 || matches3.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }
  return {
    name: matches3[1],
    length: matches3[2] || 1,
    isArray: Boolean(matches3[2])
  };
}
function checkUniformValues(uniforms3, source, uniformMap) {
  for (const uniformName in uniforms3) {
    const value = uniforms3[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? "".concat(source, " ") : "";
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }
  return true;
}
function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }
  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof Texture) {
    return true;
  } else if (value instanceof Renderbuffer) {
    return true;
  } else if (value instanceof Framebuffer) {
    return Boolean(value.texture);
  }
  return false;
}
function copyUniform(uniforms3, key, value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    if (uniforms3[key]) {
      const dest = uniforms3[key];
      for (let i = 0, len2 = value.length; i < len2; ++i) {
        dest[i] = value[i];
      }
    } else {
      uniforms3[key] = value.slice();
    }
  } else {
    uniforms3[key] = value;
  }
}
function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }
  const checkLength = Math.min(value.length, 16);
  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }
  return true;
}
function getSamplerSetter() {
  let cache2 = null;
  return (gl, location, value) => {
    const update = cache2 !== value;
    if (update) {
      gl.uniform1i(location, value);
      cache2 = value;
    }
    return update;
  };
}
function getArraySetter(functionName, toArray, size, uniformSetter) {
  let cache2 = null;
  let cacheLength = null;
  return (gl, location, value) => {
    const arrayValue = toArray(value, size);
    const length4 = arrayValue.length;
    let update = false;
    if (cache2 === null) {
      cache2 = new Float32Array(length4);
      cacheLength = length4;
      update = true;
    } else {
      assert6(cacheLength === length4, "Uniform length cannot change.");
      for (let i = 0; i < length4; ++i) {
        if (arrayValue[i] !== cache2[i]) {
          update = true;
          break;
        }
      }
    }
    if (update) {
      uniformSetter(gl, functionName, location, arrayValue);
      cache2.set(arrayValue);
    }
    return update;
  };
}
function setVectorUniform(gl, functionName, location, value) {
  gl[functionName](location, value);
}
function setMatrixUniform(gl, functionName, location, value) {
  gl[functionName](location, false, value);
}
var UNIFORM_SETTERS, FLOAT_ARRAY, INT_ARRAY, UINT_ARRAY, array1;
var init_uniforms = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js"() {
    init_esm9();
    init_framebuffer();
    init_renderbuffer();
    init_texture();
    init_assert6();
    UNIFORM_SETTERS = {
      [5126]: getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform),
      [35664]: getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform),
      [35665]: getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform),
      [35666]: getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform),
      [5124]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
      [35667]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
      [35668]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
      [35669]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
      [35670]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
      [35671]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
      [35672]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
      [35673]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
      [35674]: getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform),
      [35675]: getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform),
      [35676]: getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform),
      [35678]: getSamplerSetter,
      [35680]: getSamplerSetter,
      [5125]: getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform),
      [36294]: getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform),
      [36295]: getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform),
      [36296]: getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform),
      [35685]: getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform),
      [35686]: getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform),
      [35687]: getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform),
      [35688]: getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform),
      [35689]: getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform),
      [35690]: getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform),
      [35678]: getSamplerSetter,
      [35680]: getSamplerSetter,
      [35679]: getSamplerSetter,
      [35682]: getSamplerSetter,
      [36289]: getSamplerSetter,
      [36292]: getSamplerSetter,
      [36293]: getSamplerSetter,
      [36298]: getSamplerSetter,
      [36299]: getSamplerSetter,
      [36300]: getSamplerSetter,
      [36303]: getSamplerSetter,
      [36306]: getSamplerSetter,
      [36307]: getSamplerSetter,
      [36308]: getSamplerSetter,
      [36311]: getSamplerSetter
    };
    FLOAT_ARRAY = {};
    INT_ARRAY = {};
    UINT_ARRAY = {};
    array1 = [0];
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;
    case GL_LINES:
      return GL_LINES;
    case GL_LINE_STRIP:
      return GL_LINES;
    case GL_LINE_LOOP:
      return GL_LINES;
    case GL_TRIANGLES:
      return GL_TRIANGLES;
    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;
    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;
    default:
      assert6(false);
      return 0;
  }
}
function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
  if (!typeAndSize) {
    return null;
  }
  const [type, components] = typeAndSize;
  return {
    type,
    components
  };
}
function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;
    default:
  }
  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
    if (compType === type && compComponents === components) {
      return {
        glType,
        name
      };
    }
  }
  return null;
}
var GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_POINTS, GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_FLOAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_INT, GL_INT_VEC2, GL_INT_VEC3, GL_INT_VEC4, GL_UNSIGNED_INT, GL_UNSIGNED_INT_VEC2, GL_UNSIGNED_INT_VEC3, GL_UNSIGNED_INT_VEC4, GL_BOOL, GL_BOOL_VEC2, GL_BOOL_VEC3, GL_BOOL_VEC4, GL_FLOAT_MAT2, GL_FLOAT_MAT3, GL_FLOAT_MAT4, GL_FLOAT_MAT2x3, GL_FLOAT_MAT2x4, GL_FLOAT_MAT3x2, GL_FLOAT_MAT3x4, GL_FLOAT_MAT4x2, GL_FLOAT_MAT4x3, COMPOSITE_GL_TYPES;
var init_attribute_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"() {
    init_assert6();
    GL_BYTE = 5120;
    GL_UNSIGNED_BYTE = 5121;
    GL_SHORT = 5122;
    GL_UNSIGNED_SHORT = 5123;
    GL_POINTS = 0;
    GL_LINES = 1;
    GL_LINE_LOOP = 2;
    GL_LINE_STRIP = 3;
    GL_TRIANGLES = 4;
    GL_TRIANGLE_STRIP = 5;
    GL_TRIANGLE_FAN = 6;
    GL_FLOAT = 5126;
    GL_FLOAT_VEC2 = 35664;
    GL_FLOAT_VEC3 = 35665;
    GL_FLOAT_VEC4 = 35666;
    GL_INT = 5124;
    GL_INT_VEC2 = 35667;
    GL_INT_VEC3 = 35668;
    GL_INT_VEC4 = 35669;
    GL_UNSIGNED_INT = 5125;
    GL_UNSIGNED_INT_VEC2 = 36294;
    GL_UNSIGNED_INT_VEC3 = 36295;
    GL_UNSIGNED_INT_VEC4 = 36296;
    GL_BOOL = 35670;
    GL_BOOL_VEC2 = 35671;
    GL_BOOL_VEC3 = 35672;
    GL_BOOL_VEC4 = 35673;
    GL_FLOAT_MAT2 = 35674;
    GL_FLOAT_MAT3 = 35675;
    GL_FLOAT_MAT4 = 35676;
    GL_FLOAT_MAT2x3 = 35685;
    GL_FLOAT_MAT2x4 = 35686;
    GL_FLOAT_MAT3x2 = 35687;
    GL_FLOAT_MAT3x4 = 35688;
    GL_FLOAT_MAT4x2 = 35689;
    GL_FLOAT_MAT4x3 = 35690;
    COMPOSITE_GL_TYPES = {
      [GL_FLOAT]: [GL_FLOAT, 1, "float"],
      [GL_FLOAT_VEC2]: [GL_FLOAT, 2, "vec2"],
      [GL_FLOAT_VEC3]: [GL_FLOAT, 3, "vec3"],
      [GL_FLOAT_VEC4]: [GL_FLOAT, 4, "vec4"],
      [GL_INT]: [GL_INT, 1, "int"],
      [GL_INT_VEC2]: [GL_INT, 2, "ivec2"],
      [GL_INT_VEC3]: [GL_INT, 3, "ivec3"],
      [GL_INT_VEC4]: [GL_INT, 4, "ivec4"],
      [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, "uint"],
      [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, "uvec2"],
      [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, "uvec3"],
      [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, "uvec4"],
      [GL_BOOL]: [GL_FLOAT, 1, "bool"],
      [GL_BOOL_VEC2]: [GL_FLOAT, 2, "bvec2"],
      [GL_BOOL_VEC3]: [GL_FLOAT, 3, "bvec3"],
      [GL_BOOL_VEC4]: [GL_FLOAT, 4, "bvec4"],
      [GL_FLOAT_MAT2]: [GL_FLOAT, 8, "mat2"],
      [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, "mat2x3"],
      [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, "mat2x4"],
      [GL_FLOAT_MAT3]: [GL_FLOAT, 12, "mat3"],
      [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, "mat3x2"],
      [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, "mat3x4"],
      [GL_FLOAT_MAT4]: [GL_FLOAT, 16, "mat4"],
      [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, "mat4x2"],
      [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, "mat4x3"]
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
var ProgramConfiguration;
var init_program_configuration = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js"() {
    init_accessor();
    init_esm9();
    init_attribute_utils();
    ProgramConfiguration = class {
      constructor(program) {
        this.id = program.id;
        this.attributeInfos = [];
        this.attributeInfosByName = {};
        this.attributeInfosByLocation = [];
        this.varyingInfos = [];
        this.varyingInfosByName = {};
        Object.seal(this);
        this._readAttributesFromProgram(program);
        this._readVaryingsFromProgram(program);
      }
      getAttributeInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return this.attributeInfosByLocation[location];
        }
        return this.attributeInfosByName[locationOrName] || null;
      }
      getAttributeLocation(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.location : -1;
      }
      getAttributeAccessor(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.accessor : null;
      }
      getVaryingInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return this.varyingInfos[location];
        }
        return this.varyingInfosByName[locationOrName] || null;
      }
      getVaryingIndex(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.location : -1;
      }
      getVaryingAccessor(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.accessor : null;
      }
      _readAttributesFromProgram(program) {
        const {
          gl
        } = program;
        const count2 = gl.getProgramParameter(program.handle, 35721);
        for (let index = 0; index < count2; index++) {
          const {
            name,
            type,
            size
          } = gl.getActiveAttrib(program.handle, index);
          const location = gl.getAttribLocation(program.handle, name);
          if (location >= 0) {
            this._addAttribute(location, name, type, size);
          }
        }
        this.attributeInfos.sort((a, b) => a.location - b.location);
      }
      _readVaryingsFromProgram(program) {
        const {
          gl
        } = program;
        if (!isWebGL2(gl)) {
          return;
        }
        const count2 = gl.getProgramParameter(program.handle, 35971);
        for (let location = 0; location < count2; location++) {
          const {
            name,
            type,
            size
          } = gl.getTransformFeedbackVarying(program.handle, location);
          this._addVarying(location, name, type, size);
        }
        this.varyingInfos.sort((a, b) => a.location - b.location);
      }
      _addAttribute(location, name, compositeType, size) {
        const {
          type,
          components
        } = decomposeCompositeGLType(compositeType);
        const accessor = {
          type,
          size: size * components
        };
        this._inferProperties(location, name, accessor);
        const attributeInfo = {
          location,
          name,
          accessor: new Accessor(accessor)
        };
        this.attributeInfos.push(attributeInfo);
        this.attributeInfosByLocation[location] = attributeInfo;
        this.attributeInfosByName[attributeInfo.name] = attributeInfo;
      }
      _inferProperties(location, name, accessor) {
        if (/instance/i.test(name)) {
          accessor.divisor = 1;
        }
      }
      _addVarying(location, name, compositeType, size) {
        const {
          type,
          components
        } = decomposeCompositeGLType(compositeType);
        const accessor = new Accessor({
          type,
          size: size * components
        });
        const varying = {
          location,
          name,
          accessor
        };
        this.varyingInfos.push(varying);
        this.varyingInfosByName[varying.name] = varying;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/program.js
var LOG_PROGRAM_PERF_PRIORITY, GL_SEPARATE_ATTRIBS, V6_DEPRECATED_METHODS, Program;
var init_program = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/program.js"() {
    init_resource();
    init_texture();
    init_framebuffer();
    init_uniforms();
    init_shader();
    init_program_configuration();
    init_uniforms();
    init_esm9();
    init_constants_to_keys();
    init_attribute_utils();
    init_assert6();
    init_utils2();
    LOG_PROGRAM_PERF_PRIORITY = 4;
    GL_SEPARATE_ATTRIBS = 35981;
    V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
    Program = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Program";
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
        this._isCached = false;
        this.initialize(props);
        Object.seal(this);
        this._setId(props.id);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          hash,
          vs: vs9,
          fs: fs9,
          varyings,
          bufferMode = GL_SEPARATE_ATTRIBS
        } = props;
        this.hash = hash || "";
        this.vs = typeof vs9 === "string" ? new VertexShader(this.gl, {
          id: "".concat(props.id, "-vs"),
          source: vs9
        }) : vs9;
        this.fs = typeof fs9 === "string" ? new FragmentShader(this.gl, {
          id: "".concat(props.id, "-fs"),
          source: fs9
        }) : fs9;
        assert6(this.vs instanceof VertexShader);
        assert6(this.fs instanceof FragmentShader);
        this.uniforms = {};
        this._textureUniforms = {};
        if (varyings && varyings.length > 0) {
          assertWebGL2Context(this.gl);
          this.varyings = varyings;
          this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
        }
        this._compileAndLink();
        this._readUniformLocationsFromLinkedProgram();
        this.configuration = new ProgramConfiguration(this);
        return this.setProps(props);
      }
      delete() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._isCached) {
          return this;
        }
        return super.delete(options);
      }
      setProps(props) {
        if ("uniforms" in props) {
          this.setUniforms(props.uniforms);
        }
        return this;
      }
      draw(_ref) {
        let {
          logPriority,
          drawMode = 4,
          vertexCount,
          offset = 0,
          start,
          end,
          isIndexed = false,
          indexType = 5123,
          instanceCount = 0,
          isInstanced = instanceCount > 0,
          vertexArray = null,
          transformFeedback,
          framebuffer,
          parameters = {},
          uniforms: uniforms3,
          samplers
        } = _ref;
        if (uniforms3 || samplers) {
          log2.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
          this.setUniforms(uniforms3 || {});
        }
        if (log2.priority >= logPriority) {
          const fb = framebuffer ? framebuffer.id : "default";
          const message = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
          log2.log(logPriority, message)();
        }
        assert6(vertexArray);
        this.gl.useProgram(this.handle);
        if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
          return false;
        }
        vertexArray.bindForDraw(vertexCount, instanceCount, () => {
          if (framebuffer !== void 0) {
            parameters = Object.assign({}, parameters, {
              framebuffer
            });
          }
          if (transformFeedback) {
            const primitiveMode = getPrimitiveDrawMode(drawMode);
            transformFeedback.begin(primitiveMode);
          }
          this._bindTextures();
          withParameters(this.gl, parameters, () => {
            if (isIndexed && isInstanced) {
              this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
            } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {
              this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
            } else if (isIndexed) {
              this.gl.drawElements(drawMode, vertexCount, indexType, offset);
            } else if (isInstanced) {
              this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
            } else {
              this.gl.drawArrays(drawMode, offset, vertexCount);
            }
          });
          if (transformFeedback) {
            transformFeedback.end();
          }
        });
        return true;
      }
      setUniforms() {
        let uniforms3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (log2.priority >= 2) {
          checkUniformValues(uniforms3, this.id, this._uniformSetters);
        }
        this.gl.useProgram(this.handle);
        for (const uniformName in uniforms3) {
          const uniform = uniforms3[uniformName];
          const uniformSetter = this._uniformSetters[uniformName];
          if (uniformSetter) {
            let value = uniform;
            let textureUpdate = false;
            if (value instanceof Framebuffer) {
              value = value.texture;
            }
            if (value instanceof Texture) {
              textureUpdate = this.uniforms[uniformName] !== uniform;
              if (textureUpdate) {
                if (uniformSetter.textureIndex === void 0) {
                  uniformSetter.textureIndex = this._textureIndexCounter++;
                }
                const texture = value;
                const {
                  textureIndex
                } = uniformSetter;
                texture.bind(textureIndex);
                value = textureIndex;
                this._textureUniforms[uniformName] = texture;
              } else {
                value = uniformSetter.textureIndex;
              }
            } else if (this._textureUniforms[uniformName]) {
              delete this._textureUniforms[uniformName];
            }
            if (uniformSetter(value) || textureUpdate) {
              copyUniform(this.uniforms, uniformName, uniform);
            }
          }
        }
        return this;
      }
      _areTexturesRenderable() {
        let texturesRenderable = true;
        for (const uniformName in this._textureUniforms) {
          const texture = this._textureUniforms[uniformName];
          texture.update();
          texturesRenderable = texturesRenderable && texture.loaded;
        }
        return texturesRenderable;
      }
      _bindTextures() {
        for (const uniformName in this._textureUniforms) {
          const textureIndex = this._uniformSetters[uniformName].textureIndex;
          this._textureUniforms[uniformName].bind(textureIndex);
        }
      }
      _createHandle() {
        return this.gl.createProgram();
      }
      _deleteHandle() {
        this.gl.deleteProgram(this.handle);
      }
      _getOptionsFromHandle(handle) {
        const shaderHandles = this.gl.getAttachedShaders(handle);
        const opts = {};
        for (const shaderHandle of shaderHandles) {
          const type = this.gl.getShaderParameter(this.handle, 35663);
          switch (type) {
            case 35633:
              opts.vs = new VertexShader({
                handle: shaderHandle
              });
              break;
            case 35632:
              opts.fs = new FragmentShader({
                handle: shaderHandle
              });
              break;
            default:
          }
        }
        return opts;
      }
      _getParameter(pname) {
        return this.gl.getProgramParameter(this.handle, pname);
      }
      _setId(id) {
        if (!id) {
          const programName = this._getName();
          this.id = uid(programName);
        }
      }
      _getName() {
        let programName = this.vs.getName() || this.fs.getName();
        programName = programName.replace(/shader/i, "");
        programName = programName ? "".concat(programName, "-program") : "program";
        return programName;
      }
      _compileAndLink() {
        const {
          gl
        } = this;
        gl.attachShader(this.handle, this.vs.handle);
        gl.attachShader(this.handle, this.fs.handle);
        log2.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        gl.linkProgram(this.handle);
        log2.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        if (gl.debug || log2.level > 0) {
          const linked = gl.getProgramParameter(this.handle, 35714);
          if (!linked) {
            throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
          }
          gl.validateProgram(this.handle);
          const validated = gl.getProgramParameter(this.handle, 35715);
          if (!validated) {
            throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
          }
        }
      }
      _readUniformLocationsFromLinkedProgram() {
        const {
          gl
        } = this;
        this._uniformSetters = {};
        this._uniformCount = this._getParameter(35718);
        for (let i = 0; i < this._uniformCount; i++) {
          const info = this.gl.getActiveUniform(this.handle, i);
          const {
            name
          } = parseUniformName(info.name);
          let location = gl.getUniformLocation(this.handle, name);
          this._uniformSetters[name] = getUniformSetter(gl, location, info);
          if (info.size > 1) {
            for (let l = 0; l < info.size; l++) {
              location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
              this._uniformSetters["".concat(name, "[").concat(l, "]")] = getUniformSetter(gl, location, info);
            }
          }
        }
        this._textureIndexCounter = 0;
      }
      getActiveUniforms(uniformIndices, pname) {
        return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
      }
      getUniformBlockIndex(blockName) {
        return this.gl2.getUniformBlockIndex(this.handle, blockName);
      }
      getActiveUniformBlockParameter(blockIndex, pname) {
        return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
      }
      uniformBlockBinding(blockIndex, blockBinding) {
        this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/query.js
var GL_QUERY_RESULT, GL_QUERY_RESULT_AVAILABLE, GL_TIME_ELAPSED_EXT, GL_GPU_DISJOINT_EXT2, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, Query;
var init_query = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/query.js"() {
    init_resource();
    init_features2();
    init_esm9();
    init_assert6();
    GL_QUERY_RESULT = 34918;
    GL_QUERY_RESULT_AVAILABLE = 34919;
    GL_TIME_ELAPSED_EXT = 35007;
    GL_GPU_DISJOINT_EXT2 = 36795;
    GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
    GL_ANY_SAMPLES_PASSED = 35887;
    GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
    Query = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Query";
      }
      static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        const webgl2 = isWebGL2(gl);
        const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);
        let supported = webgl2 || hasTimerQuery;
        for (const key of opts) {
          switch (key) {
            case "queries":
              supported = supported && webgl2;
              break;
            case "timers":
              supported = supported && hasTimerQuery;
              break;
            default:
              assert6(false);
          }
        }
        return supported;
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, opts);
        this.target = null;
        this._queryPending = false;
        this._pollingPromise = null;
        Object.seal(this);
      }
      beginTimeElapsedQuery() {
        return this.begin(GL_TIME_ELAPSED_EXT);
      }
      beginOcclusionQuery() {
        let {
          conservative = false
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
      }
      beginTransformFeedbackQuery() {
        return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
      }
      begin(target) {
        if (this._queryPending) {
          return this;
        }
        this.target = target;
        this.gl2.beginQuery(this.target, this.handle);
        return this;
      }
      end() {
        if (this._queryPending) {
          return this;
        }
        if (this.target) {
          this.gl2.endQuery(this.target);
          this.target = null;
          this._queryPending = true;
        }
        return this;
      }
      isResultAvailable() {
        if (!this._queryPending) {
          return false;
        }
        const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
        if (resultAvailable) {
          this._queryPending = false;
        }
        return resultAvailable;
      }
      isTimerDisjoint() {
        return this.gl2.getParameter(GL_GPU_DISJOINT_EXT2);
      }
      getResult() {
        return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
      }
      getTimerMilliseconds() {
        return this.getResult() / 1e6;
      }
      createPoll() {
        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
        if (this._pollingPromise) {
          return this._pollingPromise;
        }
        let counter2 = 0;
        this._pollingPromise = new Promise((resolve, reject) => {
          const poll = () => {
            if (this.isResultAvailable()) {
              resolve(this.getResult());
              this._pollingPromise = null;
            } else if (counter2++ > limit) {
              reject("Timed out");
              this._pollingPromise = null;
            } else {
              requestAnimationFrame(poll);
            }
          };
          requestAnimationFrame(poll);
        });
        return this._pollingPromise;
      }
      _createHandle() {
        return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
      }
      _deleteHandle() {
        this.gl2.deleteQuery(this.handle);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
var TransformFeedback;
var init_transform_feedback = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js"() {
    init_esm9();
    init_resource();
    init_buffer();
    init_utils2();
    TransformFeedback = class extends Resource {
      get [Symbol.toStringTag]() {
        return "TransformFeedback";
      }
      static isSupported(gl) {
        return isWebGL2(gl);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGL2Context(gl);
        super(gl, props);
        this.initialize(props);
        this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
        Object.seal(this);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.buffers = {};
        this.unused = {};
        this.configuration = null;
        this.bindOnUse = true;
        if (!isObjectEmpty2(this.buffers)) {
          this.bind(() => this._unbindBuffers());
        }
        this.setProps(props);
        return this;
      }
      setProps(props) {
        if ("program" in props) {
          this.configuration = props.program && props.program.configuration;
        }
        if ("configuration" in props) {
          this.configuration = props.configuration;
        }
        if ("bindOnUse" in props) {
          props = props.bindOnUse;
        }
        if ("buffers" in props) {
          this.setBuffers(props.buffers);
        }
      }
      setBuffers() {
        let buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.bind(() => {
          for (const bufferName in buffers) {
            this.setBuffer(bufferName, buffers[bufferName]);
          }
        });
        return this;
      }
      setBuffer(locationOrName, bufferOrParams) {
        const location = this._getVaryingIndex(locationOrName);
        const {
          buffer,
          byteSize,
          byteOffset
        } = this._getBufferParams(bufferOrParams);
        if (location < 0) {
          this.unused[locationOrName] = buffer;
          log2.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
          return this;
        }
        this.buffers[location] = bufferOrParams;
        if (!this.bindOnUse) {
          this._bindBuffer(location, buffer, byteOffset, byteSize);
        }
        return this;
      }
      begin() {
        let primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        this.gl.bindTransformFeedback(36386, this.handle);
        this._bindBuffers();
        this.gl.beginTransformFeedback(primitiveMode);
        return this;
      }
      end() {
        this.gl.endTransformFeedback();
        this._unbindBuffers();
        this.gl.bindTransformFeedback(36386, null);
        return this;
      }
      _getBufferParams(bufferOrParams) {
        let byteOffset;
        let byteSize;
        let buffer;
        if (bufferOrParams instanceof Buffer2 === false) {
          buffer = bufferOrParams.buffer;
          byteSize = bufferOrParams.byteSize;
          byteOffset = bufferOrParams.byteOffset;
        } else {
          buffer = bufferOrParams;
        }
        if (byteOffset !== void 0 || byteSize !== void 0) {
          byteOffset = byteOffset || 0;
          byteSize = byteSize || buffer.byteLength - byteOffset;
        }
        return {
          buffer,
          byteOffset,
          byteSize
        };
      }
      _getVaryingInfo(locationOrName) {
        return this.configuration && this.configuration.getVaryingInfo(locationOrName);
      }
      _getVaryingIndex(locationOrName) {
        if (this.configuration) {
          return this.configuration.getVaryingInfo(locationOrName).location;
        }
        const location = Number(locationOrName);
        return Number.isFinite(location) ? location : -1;
      }
      _bindBuffers() {
        if (this.bindOnUse) {
          for (const bufferIndex in this.buffers) {
            const {
              buffer,
              byteSize,
              byteOffset
            } = this._getBufferParams(this.buffers[bufferIndex]);
            this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
          }
        }
      }
      _unbindBuffers() {
        if (this.bindOnUse) {
          for (const bufferIndex in this.buffers) {
            this._bindBuffer(bufferIndex, null);
          }
        }
      }
      _bindBuffer(index, buffer) {
        let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        let byteSize = arguments.length > 3 ? arguments[3] : void 0;
        const handle = buffer && buffer.handle;
        if (!handle || byteSize === void 0) {
          this.gl.bindBufferBase(35982, index, handle);
        } else {
          this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
        }
        return this;
      }
      _createHandle() {
        return this.gl.createTransformFeedback();
      }
      _deleteHandle() {
        this.gl.deleteTransformFeedback(this.handle);
      }
      _bindHandle(handle) {
        this.gl.bindTransformFeedback(36386, this.handle);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type, length4) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length4);
  return new Type(scratchArrayBuffer, 0, length4);
}
function fillArray(_ref) {
  let {
    target,
    source,
    start = 0,
    count: count2 = 1
  } = _ref;
  const length4 = source.length;
  const total = count2 * length4;
  let copied = 0;
  for (let i = start; copied < length4; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
var arrayBuffer;
var init_array_utils_flat = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js"() {
    arrayBuffer = null;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
var ERR_ELEMENTS, VertexArrayObject;
var init_vertex_array_object = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js"() {
    init_resource();
    init_buffer();
    init_esm9();
    init_array_utils_flat();
    init_assert6();
    init_esm5();
    ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
    VertexArrayObject = class extends Resource {
      get [Symbol.toStringTag]() {
        return "VertexArrayObject";
      }
      static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (options.constantAttributeZero) {
          return isWebGL2(gl) || getBrowser() === "Chrome";
        }
        return true;
      }
      static getDefaultArray(gl) {
        gl.luma = gl.luma || {};
        if (!gl.luma.defaultVertexArray) {
          gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
            handle: null,
            isDefaultArray: true
          });
        }
        return gl.luma.defaultVertexArray;
      }
      static getMaxAttributes(gl) {
        VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
        return VertexArrayObject.MAX_ATTRIBUTES;
      }
      static setConstant(gl, location, array) {
        switch (array.constructor) {
          case Float32Array:
            VertexArrayObject._setConstantFloatArray(gl, location, array);
            break;
          case Int32Array:
            VertexArrayObject._setConstantIntArray(gl, location, array);
            break;
          case Uint32Array:
            VertexArrayObject._setConstantUintArray(gl, location, array);
            break;
          default:
            assert6(false);
        }
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        super(gl, Object.assign({}, opts, {
          id
        }));
        this.buffer = null;
        this.bufferValue = null;
        this.isDefaultArray = opts.isDefaultArray || false;
        this.gl2 = gl;
        this.initialize(opts);
        Object.seal(this);
      }
      delete() {
        super.delete();
        if (this.buffer) {
          this.buffer.delete();
        }
        return this;
      }
      get MAX_ATTRIBUTES() {
        return VertexArrayObject.getMaxAttributes(this.gl);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return this.setProps(props);
      }
      setProps(props) {
        return this;
      }
      setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assert6(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
        this.bind(() => {
          this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
        });
        return this;
      }
      setBuffer(location, buffer, accessor) {
        if (buffer.target === 34963) {
          return this.setElementBuffer(buffer, accessor);
        }
        const {
          size,
          type,
          stride,
          offset,
          normalized,
          integer,
          divisor
        } = accessor;
        const {
          gl,
          gl2
        } = this;
        location = Number(location);
        this.bind(() => {
          gl.bindBuffer(34962, buffer.handle);
          if (integer) {
            assert6(isWebGL2(gl));
            gl2.vertexAttribIPointer(location, size, type, stride, offset);
          } else {
            gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
          }
          gl.enableVertexAttribArray(location);
          gl2.vertexAttribDivisor(location, divisor || 0);
        });
        return this;
      }
      enable(location) {
        let enable2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        const disablingAttributeZero = !enable2 && location === 0 && !VertexArrayObject.isSupported(this.gl, {
          constantAttributeZero: true
        });
        if (!disablingAttributeZero) {
          location = Number(location);
          this.bind(() => enable2 ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
        }
        return this;
      }
      getConstantBuffer(elementCount, value) {
        const constantValue = this._normalizeConstantArrayValue(value);
        const byteLength = constantValue.byteLength * elementCount;
        const length4 = constantValue.length * elementCount;
        let updateNeeded = !this.buffer;
        this.buffer = this.buffer || new Buffer2(this.gl, byteLength);
        updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
        updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
        if (updateNeeded) {
          const typedArray = getScratchArray(value.constructor, length4);
          fillArray({
            target: typedArray,
            source: constantValue,
            start: 0,
            count: length4
          });
          this.buffer.subData(typedArray);
          this.bufferValue = value;
        }
        return this.buffer;
      }
      _normalizeConstantArrayValue(arrayValue) {
        if (Array.isArray(arrayValue)) {
          return new Float32Array(arrayValue);
        }
        return arrayValue;
      }
      _compareConstantArrayValues(v1, v2) {
        if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
          return false;
        }
        for (let i = 0; i < v1.length; ++i) {
          if (v1[i] !== v2[i]) {
            return false;
          }
        }
        return true;
      }
      static _setConstantFloatArray(gl, location, array) {
        switch (array.length) {
          case 1:
            gl.vertexAttrib1fv(location, array);
            break;
          case 2:
            gl.vertexAttrib2fv(location, array);
            break;
          case 3:
            gl.vertexAttrib3fv(location, array);
            break;
          case 4:
            gl.vertexAttrib4fv(location, array);
            break;
          default:
            assert6(false);
        }
      }
      static _setConstantIntArray(gl, location, array) {
        assert6(isWebGL2(gl));
        switch (array.length) {
          case 1:
            gl.vertexAttribI1iv(location, array);
            break;
          case 2:
            gl.vertexAttribI2iv(location, array);
            break;
          case 3:
            gl.vertexAttribI3iv(location, array);
            break;
          case 4:
            gl.vertexAttribI4iv(location, array);
            break;
          default:
            assert6(false);
        }
      }
      static _setConstantUintArray(gl, location, array) {
        assert6(isWebGL2(gl));
        switch (array.length) {
          case 1:
            gl.vertexAttribI1uiv(location, array);
            break;
          case 2:
            gl.vertexAttribI2uiv(location, array);
            break;
          case 3:
            gl.vertexAttribI3uiv(location, array);
            break;
          case 4:
            gl.vertexAttribI4uiv(location, array);
            break;
          default:
            assert6(false);
        }
      }
      _createHandle() {
        const gl2 = this.gl;
        return gl2.createVertexArray();
      }
      _deleteHandle(handle) {
        this.gl2.deleteVertexArray(handle);
        return [this.elements];
      }
      _bindHandle(handle) {
        this.gl2.bindVertexArray(handle);
      }
      _getParameter(pname, _ref) {
        let {
          location
        } = _ref;
        assert6(Number.isFinite(location));
        return this.bind(() => {
          switch (pname) {
            case 34373:
              return this.gl.getVertexAttribOffset(location, pname);
            default:
              return this.gl.getVertexAttrib(location, pname);
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
var ERR_ATTRIBUTE_TYPE, MULTI_LOCATION_ATTRIBUTE_REGEXP, DEPRECATIONS_V6, VertexArray;
var init_vertex_array = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js"() {
    init_esm9();
    init_accessor();
    init_buffer();
    init_vertex_array_object();
    init_assert6();
    init_stub_methods();
    ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
    MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
    DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
    VertexArray = class {
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        this.id = id;
        this.gl = gl;
        this.configuration = null;
        this.elements = null;
        this.elementsAccessor = null;
        this.values = null;
        this.accessors = null;
        this.unused = null;
        this.drawParams = null;
        this.buffer = null;
        this.attributes = {};
        this.vertexArrayObject = new VertexArrayObject(gl);
        stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
        this.initialize(opts);
        Object.seal(this);
      }
      delete() {
        if (this.buffer) {
          this.buffer.delete();
        }
        this.vertexArrayObject.delete();
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.reset();
        this.configuration = null;
        this.bindOnUse = false;
        return this.setProps(props);
      }
      reset() {
        this.elements = null;
        this.elementsAccessor = null;
        const {
          MAX_ATTRIBUTES
        } = this.vertexArrayObject;
        this.values = new Array(MAX_ATTRIBUTES).fill(null);
        this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
        this.unused = {};
        this.drawParams = null;
        return this;
      }
      setProps(props) {
        if ("program" in props) {
          this.configuration = props.program && props.program.configuration;
        }
        if ("configuration" in props) {
          this.configuration = props.configuration;
        }
        if ("attributes" in props) {
          this.setAttributes(props.attributes);
        }
        if ("elements" in props) {
          this.setElementBuffer(props.elements);
        }
        if ("bindOnUse" in props) {
          props = props.bindOnUse;
        }
        return this;
      }
      clearDrawParams() {
        this.drawParams = null;
      }
      getDrawParams() {
        this.drawParams = this.drawParams || this._updateDrawParams();
        return this.drawParams;
      }
      setAttributes(attributes) {
        Object.assign(this.attributes, attributes);
        this.vertexArrayObject.bind(() => {
          for (const locationOrName in attributes) {
            const value = attributes[locationOrName];
            this._setAttribute(locationOrName, value);
          }
          this.gl.bindBuffer(34962, null);
        });
        return this;
      }
      setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.elements = elementBuffer;
        this.elementsAccessor = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
        return this;
      }
      setBuffer(locationOrName, buffer) {
        let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (buffer.target === 34963) {
          return this.setElementBuffer(buffer, appAccessor);
        }
        const {
          location,
          accessor
        } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
        if (location >= 0) {
          this.values[location] = buffer;
          this.accessors[location] = accessor;
          this.clearDrawParams();
          this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
        return this;
      }
      setConstant(locationOrName, arrayValue) {
        let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const {
          location,
          accessor
        } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
          size: arrayValue.length
        }, appAccessor));
        if (location >= 0) {
          arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
          this.values[location] = arrayValue;
          this.accessors[location] = accessor;
          this.clearDrawParams();
          this.vertexArrayObject.enable(location, false);
        }
        return this;
      }
      unbindBuffers() {
        this.vertexArrayObject.bind(() => {
          if (this.elements) {
            this.vertexArrayObject.setElementBuffer(null);
          }
          this.buffer = this.buffer || new Buffer2(this.gl, {
            accessor: {
              size: 4
            }
          });
          for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
            if (this.values[location] instanceof Buffer2) {
              this.gl.disableVertexAttribArray(location);
              this.gl.bindBuffer(34962, this.buffer.handle);
              this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
            }
          }
        });
        return this;
      }
      bindBuffers() {
        this.vertexArrayObject.bind(() => {
          if (this.elements) {
            this.setElementBuffer(this.elements);
          }
          for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
            const buffer = this.values[location];
            if (buffer instanceof Buffer2) {
              this.setBuffer(location, buffer);
            }
          }
        });
        return this;
      }
      bindForDraw(vertexCount, instanceCount, func) {
        let value;
        this.vertexArrayObject.bind(() => {
          this._setConstantAttributes(vertexCount, instanceCount);
          value = func();
        });
        return value;
      }
      _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
        const INVALID_RESULT = {
          location: -1,
          accessor: null
        };
        const {
          location,
          name
        } = this._getAttributeIndex(locationOrName);
        if (!Number.isFinite(location) || location < 0) {
          this.unused[locationOrName] = value;
          log2.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
          return INVALID_RESULT;
        }
        const accessInfo = this._getAttributeInfo(name || location);
        if (!accessInfo) {
          return INVALID_RESULT;
        }
        const currentAccessor = this.accessors[location] || {};
        const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
        const {
          size,
          type
        } = accessor;
        assert6(Number.isFinite(size) && Number.isFinite(type));
        return {
          location,
          accessor
        };
      }
      _getAttributeInfo(attributeName) {
        return this.configuration && this.configuration.getAttributeInfo(attributeName);
      }
      _getAttributeIndex(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return {
            location
          };
        }
        const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
        const name = multiLocation ? multiLocation[1] : locationOrName;
        const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
        if (this.configuration) {
          return {
            location: this.configuration.getAttributeLocation(name) + locationOffset,
            name
          };
        }
        return {
          location: -1
        };
      }
      _setAttribute(locationOrName, value) {
        if (value instanceof Buffer2) {
          this.setBuffer(locationOrName, value);
        } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer2) {
          const buffer = value[0];
          const accessor = value[1];
          this.setBuffer(locationOrName, buffer, accessor);
        } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
          const constant = value;
          this.setConstant(locationOrName, constant);
        } else if (value.buffer instanceof Buffer2) {
          const accessor = value;
          this.setBuffer(locationOrName, accessor.buffer, accessor);
        } else {
          throw new Error(ERR_ATTRIBUTE_TYPE);
        }
      }
      _setConstantAttributes(vertexCount, instanceCount) {
        const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
        let constant = this.values[0];
        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttributeZero(constant, elementCount);
        }
        for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          constant = this.values[location];
          if (ArrayBuffer.isView(constant)) {
            this._setConstantAttribute(location, constant);
          }
        }
      }
      _setConstantAttributeZero(constant, elementCount) {
        if (VertexArrayObject.isSupported(this.gl, {
          constantAttributeZero: true
        })) {
          this._setConstantAttribute(0, constant);
          return;
        }
        const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
        this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
      }
      _setConstantAttribute(location, constant) {
        VertexArrayObject.setConstant(this.gl, location, constant);
      }
      _updateDrawParams() {
        const drawParams = {
          isIndexed: false,
          isInstanced: false,
          indexCount: Infinity,
          vertexCount: Infinity,
          instanceCount: Infinity
        };
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          this._updateDrawParamsForLocation(drawParams, location);
        }
        if (this.elements) {
          drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
          drawParams.isIndexed = true;
          drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
          drawParams.indexOffset = this.elementsAccessor.offset || 0;
        }
        if (drawParams.indexCount === Infinity) {
          drawParams.indexCount = 0;
        }
        if (drawParams.vertexCount === Infinity) {
          drawParams.vertexCount = 0;
        }
        if (drawParams.instanceCount === Infinity) {
          drawParams.instanceCount = 0;
        }
        return drawParams;
      }
      _updateDrawParamsForLocation(drawParams, location) {
        const value = this.values[location];
        const accessor = this.accessors[location];
        if (!value) {
          return;
        }
        const {
          divisor
        } = accessor;
        const isInstanced = divisor > 0;
        drawParams.isInstanced = drawParams.isInstanced || isInstanced;
        if (value instanceof Buffer2) {
          const buffer = value;
          if (isInstanced) {
            const instanceCount = buffer.getVertexCount(accessor);
            drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
          } else {
            const vertexCount = buffer.getVertexCount(accessor);
            drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
          }
        }
      }
      setElements() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        log2.deprecated("setElements", "setElementBuffer")();
        return this.setElementBuffer(elementBuffer, accessor);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js
var init_uniform_buffer_layout = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js"() {
    init_attribute_utils();
    init_assert6();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = "[";
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? " " : "");
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? "..." : "]";
  return "".concat(string).concat(terminator);
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const EPSILON4 = 1e-16;
  const {
    isInteger = false
  } = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON4) {
    return isInteger ? "0" : "0.";
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf(".0");
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
var init_format_value = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
function getDebugTableForUniforms(_ref) {
  let {
    header = "Uniforms",
    program,
    uniforms: uniforms3,
    undefinedOnly = false
  } = _ref;
  assert6(program);
  const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
  const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
  const uniformLocations = program._uniformSetters;
  const table = {};
  const uniformNames = Object.keys(uniformLocations).sort();
  let count2 = 0;
  for (const uniformName of uniformNames) {
    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms: uniforms3,
        uniformName,
        undefinedOnly
      })) {
        count2++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms: uniforms3,
        uniformName,
        undefinedOnly
      })) {
        count2++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({
        table,
        header,
        uniforms: uniforms3,
        uniformName,
        undefinedOnly
      })) {
        count2++;
      }
    }
  }
  let unusedCount = 0;
  const unusedTable = {};
  if (!undefinedOnly) {
    for (const uniformName in uniforms3) {
      const uniform = uniforms3[uniformName];
      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: "NOT USED: ".concat(uniform),
          [header]: formatValue(uniform)
        };
      }
    }
  }
  return {
    table,
    count: count2,
    unusedTable,
    unusedCount
  };
}
function addUniformToTable(_ref2) {
  let {
    table,
    header,
    uniforms: uniforms3,
    uniformName,
    undefinedOnly
  } = _ref2;
  const value = uniforms3[uniformName];
  const isDefined = isUniformDefined(value);
  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      [header]: isDefined ? formatValue(value) : "N/A",
      "Uniform Type": isDefined ? value : "NOT PROVIDED"
    };
    return true;
  }
  return false;
}
function isUniformDefined(value) {
  return value !== void 0 && value !== null;
}
var init_debug_uniforms = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js"() {
    init_assert6();
    init_format_value();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
function getDebugTableForVertexArray(_ref) {
  let {
    vertexArray,
    header = "Attributes"
  } = _ref;
  if (!vertexArray.configuration) {
    return {};
  }
  const table = {};
  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }
  const attributes = vertexArray.values;
  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);
    if (info) {
      let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      const accessor = vertexArray.accessors[info.location];
      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }
      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }
  return table;
}
function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {
    gl
  } = vertexArray;
  if (!attribute) {
    return {
      [header]: "null",
      "Format ": "N/A"
    };
  }
  let type = "NOT PROVIDED";
  let size = 1;
  let verts = 0;
  let bytes = 0;
  let isInteger;
  let marker;
  let value;
  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
  }
  if (attribute instanceof Buffer2) {
    const buffer = attribute;
    const {
      data,
      changed
    } = buffer.getDebugData();
    marker = changed ? "*" : "";
    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    let format;
    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }
    return {
      [header]: "".concat(marker).concat(formatValue(value, {
        size,
        isInteger
      })),
      "Format ": format
    };
  }
  value = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace("Array", "");
  isInteger = type.indexOf("nt") !== -1;
  return {
    [header]: "".concat(formatValue(value, {
      size,
      isInteger
    }), " (constant)"),
    "Format ": "".concat(size, "x").concat(type, " (constant)")
  };
}
function getGLSLDeclaration(name, accessor) {
  const {
    type,
    size
  } = accessor;
  const typeAndName = getCompositeGLType(type, size);
  return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}
var init_debug_vertex_array = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js"() {
    init_buffer();
    init_constants_to_keys();
    init_attribute_utils();
    init_format_value();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
function getDebugTableForProgramConfiguration(config2) {
  const table = {};
  const header = "Accessors for ".concat(config2.id);
  for (const attributeInfo of config2.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration2(attributeInfo);
      table["in ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(attributeInfo.accessor)
      };
    }
  }
  for (const varyingInfo of config2.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration2(varyingInfo);
      table["out ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(varyingInfo.accessor)
      };
    }
  }
  return table;
}
function getGLSLDeclaration2(attributeInfo) {
  const {
    type,
    size
  } = attributeInfo.accessor;
  const typeAndName = getCompositeGLType(type, size);
  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }
  return attributeInfo.name;
}
var init_debug_program_configuration = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js"() {
    init_attribute_utils();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/index.js
var init_esm10 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/index.js"() {
    init_init3();
    init_request_animation_frame();
    init_texture_utils();
    init_constants_to_keys();
    init_limits();
    init_webgl_features_table();
    init_features();
    init_check_glsl_extension();
    init_accessor();
    init_buffer();
    init_shader();
    init_program();
    init_framebuffer();
    init_renderbuffer();
    init_texture_2d();
    init_texture_cube();
    init_clear();
    init_copy_and_blit();
    init_query();
    init_texture_3d();
    init_transform_feedback();
    init_vertex_array_object();
    init_vertex_array();
    init_uniform_buffer_layout();
    init_load_file();
    init_get_shader_name();
    init_get_shader_version();
    init_esm9();
    init_assert6();
    init_utils2();
    init_uniforms();
    init_debug_uniforms();
    init_debug_vertex_array();
    init_debug_program_configuration();
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js
var isPage2, statIdCounter, AnimationLoop;
var init_animation_loop = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js"() {
    init_esm9();
    init_esm10();
    init_esm5();
    isPage2 = isBrowser3() && typeof document !== "undefined";
    statIdCounter = 0;
    AnimationLoop = class {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          onCreateContext = (opts) => createGLContext(opts),
          onAddHTML = null,
          onInitialize = () => {
          },
          onRender = () => {
          },
          onFinalize = () => {
          },
          onError,
          gl = null,
          glOptions = {},
          debug: debug2 = false,
          createFramebuffer = false,
          autoResizeViewport = true,
          autoResizeDrawingBuffer = true,
          stats = lumaStats.get("animation-loop-".concat(statIdCounter++))
        } = props;
        let {
          useDevicePixels = true
        } = props;
        if ("useDevicePixelRatio" in props) {
          log2.deprecated("useDevicePixelRatio", "useDevicePixels")();
          useDevicePixels = props.useDevicePixelRatio;
        }
        this.props = {
          onCreateContext,
          onAddHTML,
          onInitialize,
          onRender,
          onFinalize,
          onError,
          gl,
          glOptions,
          debug: debug2,
          createFramebuffer
        };
        this.gl = gl;
        this.needsRedraw = null;
        this.timeline = null;
        this.stats = stats;
        this.cpuTime = this.stats.get("CPU Time");
        this.gpuTime = this.stats.get("GPU Time");
        this.frameRate = this.stats.get("Frame Rate");
        this._initialized = false;
        this._running = false;
        this._animationFrameId = null;
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._cpuStartTime = 0;
        this.setProps({
          autoResizeViewport,
          autoResizeDrawingBuffer,
          useDevicePixels
        });
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this._pageLoadPromise = null;
        this._onMousemove = this._onMousemove.bind(this);
        this._onMouseleave = this._onMouseleave.bind(this);
      }
      delete() {
        this.stop();
        this._setDisplay(null);
      }
      setNeedsRedraw(reason) {
        assert6(typeof reason === "string");
        this.needsRedraw = this.needsRedraw || reason;
        return this;
      }
      setProps(props) {
        if ("autoResizeViewport" in props) {
          this.autoResizeViewport = props.autoResizeViewport;
        }
        if ("autoResizeDrawingBuffer" in props) {
          this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
        }
        if ("useDevicePixels" in props) {
          this.useDevicePixels = props.useDevicePixels;
        }
        return this;
      }
      start() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._running) {
          return this;
        }
        this._running = true;
        const startPromise = this._getPageLoadPromise().then(() => {
          if (!this._running || this._initialized) {
            return null;
          }
          this._createWebGLContext(opts);
          this._createFramebuffer();
          this._startEventHandling();
          this._initializeCallbackData();
          this._updateCallbackData();
          this._resizeCanvasDrawingBuffer();
          this._resizeViewport();
          this._gpuTimeQuery = Query.isSupported(this.gl, ["timers"]) ? new Query(this.gl) : null;
          this._initialized = true;
          return this.onInitialize(this.animationProps);
        }).then((appContext) => {
          if (this._running) {
            this._addCallbackData(appContext || {});
            if (appContext !== false) {
              this._startLoop();
            }
          }
        });
        if (this.props.onError) {
          startPromise.catch(this.props.onError);
        }
        return this;
      }
      redraw() {
        if (this.isContextLost()) {
          return this;
        }
        this._beginTimers();
        this._setupFrame();
        this._updateCallbackData();
        this._renderFrame(this.animationProps);
        this._clearNeedsRedraw();
        if (this.offScreen && this.gl.commit) {
          this.gl.commit();
        }
        if (this._resolveNextFrame) {
          this._resolveNextFrame(this);
          this._nextFramePromise = null;
          this._resolveNextFrame = null;
        }
        this._endTimers();
        return this;
      }
      stop() {
        if (this._running) {
          this._finalizeCallbackData();
          this._cancelAnimationFrame(this._animationFrameId);
          this._nextFramePromise = null;
          this._resolveNextFrame = null;
          this._animationFrameId = null;
          this._running = false;
        }
        return this;
      }
      attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
      }
      detachTimeline() {
        this.timeline = null;
      }
      waitForRender() {
        this.setNeedsRedraw("waitForRender");
        if (!this._nextFramePromise) {
          this._nextFramePromise = new Promise((resolve) => {
            this._resolveNextFrame = resolve;
          });
        }
        return this._nextFramePromise;
      }
      async toDataURL() {
        this.setNeedsRedraw("toDataURL");
        await this.waitForRender();
        return this.gl.canvas.toDataURL();
      }
      isContextLost() {
        return this.gl.isContextLost();
      }
      onCreateContext() {
        return this.props.onCreateContext(...arguments);
      }
      onInitialize() {
        return this.props.onInitialize(...arguments);
      }
      onRender() {
        return this.props.onRender(...arguments);
      }
      onFinalize() {
        return this.props.onFinalize(...arguments);
      }
      getHTMLControlValue(id) {
        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        const element = document.getElementById(id);
        return element ? Number(element.value) : defaultValue;
      }
      setViewParameters() {
        log2.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
        return this;
      }
      _startLoop() {
        const renderFrame = () => {
          if (!this._running) {
            return;
          }
          this.redraw();
          this._animationFrameId = this._requestAnimationFrame(renderFrame);
        };
        this._cancelAnimationFrame(this._animationFrameId);
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
      }
      _getPageLoadPromise() {
        if (!this._pageLoadPromise) {
          this._pageLoadPromise = isPage2 ? new Promise((resolve, reject) => {
            if (isPage2 && document.readyState === "complete") {
              resolve(document);
              return;
            }
            window.addEventListener("load", () => {
              resolve(document);
            });
          }) : Promise.resolve({});
        }
        return this._pageLoadPromise;
      }
      _setDisplay(display) {
        if (this.display) {
          this.display.delete();
          this.display.animationLoop = null;
        }
        if (display) {
          display.animationLoop = this;
        }
        this.display = display;
      }
      _cancelAnimationFrame(animationFrameId) {
        if (this.display && this.display.cancelAnimationFrame) {
          return this.display.cancelAnimationFrame(animationFrameId);
        }
        return cancelAnimationFrame(animationFrameId);
      }
      _requestAnimationFrame(renderFrameCallback) {
        if (this._running) {
          if (this.display && this.display.requestAnimationFrame) {
            return this.display.requestAnimationFrame(renderFrameCallback);
          }
          return requestAnimationFrame2(renderFrameCallback);
        }
        return void 0;
      }
      _renderFrame() {
        if (this.display) {
          this.display._renderFrame(...arguments);
          return;
        }
        this.onRender(...arguments);
      }
      _clearNeedsRedraw() {
        this.needsRedraw = null;
      }
      _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._resizeFramebuffer();
      }
      _initializeCallbackData() {
        this.animationProps = {
          gl: this.gl,
          stop: this.stop,
          canvas: this.gl.canvas,
          framebuffer: this.framebuffer,
          useDevicePixels: this.useDevicePixels,
          needsRedraw: null,
          startTime: Date.now(),
          engineTime: 0,
          tick: 0,
          tock: 0,
          time: 0,
          _timeline: this.timeline,
          _loop: this,
          _animationLoop: this,
          _mousePosition: null
        };
      }
      _updateCallbackData() {
        const {
          width,
          height,
          aspect
        } = this._getSizeAndAspect();
        if (width !== this.animationProps.width || height !== this.animationProps.height) {
          this.setNeedsRedraw("drawing buffer resized");
        }
        if (aspect !== this.animationProps.aspect) {
          this.setNeedsRedraw("drawing buffer aspect changed");
        }
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) {
          this.timeline.update(this.animationProps.engineTime);
        }
        this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
        this.animationProps.tock++;
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
        this.animationProps._offScreen = this.offScreen;
      }
      _finalizeCallbackData() {
        this.onFinalize(this.animationProps);
      }
      _addCallbackData(appContext) {
        if (typeof appContext === "object" && appContext !== null) {
          this.animationProps = Object.assign({}, this.animationProps, appContext);
        }
      }
      _createWebGLContext(opts) {
        this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
        opts = Object.assign({}, opts, this.props.glOptions);
        this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);
        if (!isWebGL(this.gl)) {
          throw new Error("AnimationLoop.onCreateContext - illegal context returned");
        }
        resetParameters(this.gl);
        this._createInfoDiv();
      }
      _createInfoDiv() {
        if (this.gl.canvas && this.props.onAddHTML) {
          const wrapperDiv = document.createElement("div");
          document.body.appendChild(wrapperDiv);
          wrapperDiv.style.position = "relative";
          const div = document.createElement("div");
          div.style.position = "absolute";
          div.style.left = "10px";
          div.style.bottom = "10px";
          div.style.width = "300px";
          div.style.background = "white";
          wrapperDiv.appendChild(this.gl.canvas);
          wrapperDiv.appendChild(div);
          const html = this.props.onAddHTML(div);
          if (html) {
            div.innerHTML = html;
          }
        }
      }
      _getSizeAndAspect() {
        const width = this.gl.drawingBufferWidth;
        const height = this.gl.drawingBufferHeight;
        let aspect = 1;
        const {
          canvas
        } = this.gl;
        if (canvas && canvas.clientHeight) {
          aspect = canvas.clientWidth / canvas.clientHeight;
        } else if (width > 0 && height > 0) {
          aspect = width / height;
        }
        return {
          width,
          height,
          aspect
        };
      }
      _resizeViewport() {
        if (this.autoResizeViewport) {
          this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        }
      }
      _resizeCanvasDrawingBuffer() {
        if (this.autoResizeDrawingBuffer) {
          resizeGLContext(this.gl, {
            useDevicePixels: this.useDevicePixels
          });
        }
      }
      _createFramebuffer() {
        if (this.props.createFramebuffer) {
          this.framebuffer = new Framebuffer(this.gl);
        }
      }
      _resizeFramebuffer() {
        if (this.framebuffer) {
          this.framebuffer.resize({
            width: this.gl.drawingBufferWidth,
            height: this.gl.drawingBufferHeight
          });
        }
      }
      _beginTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
          this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
        }
        if (this._gpuTimeQuery) {
          this._gpuTimeQuery.beginTimeElapsedQuery();
        }
        this.cpuTime.timeStart();
      }
      _endTimers() {
        this.cpuTime.timeEnd();
        if (this._gpuTimeQuery) {
          this._gpuTimeQuery.end();
        }
      }
      _startEventHandling() {
        const {
          canvas
        } = this.gl;
        if (canvas) {
          canvas.addEventListener("mousemove", this._onMousemove);
          canvas.addEventListener("mouseleave", this._onMouseleave);
        }
      }
      _onMousemove(e2) {
        this.animationProps._mousePosition = [e2.offsetX, e2.offsetY];
      }
      _onMouseleave(e2) {
        this.animationProps._mousePosition = null;
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
var VERTEX_SHADER, FRAGMENT_SHADER;
var init_constants2 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js"() {
    VERTEX_SHADER = "vs";
    FRAGMENT_SHADER = "fs";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
function assert7(condition, message) {
  if (!condition) {
    throw new Error(message || "shadertools: assertion failed.");
  }
}
var init_assert7 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/index.js
var init_utils3 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"() {
    init_assert7();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
function parsePropTypes(propDefs) {
  const propTypes = {};
  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }
  return propTypes;
}
function parsePropType(propDef) {
  let type = getTypeOf(propDef);
  if (type === "object") {
    if (!propDef) {
      return {
        type: "object",
        value: null
      };
    }
    if ("type" in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }
    if (!("value" in propDef)) {
      return {
        type: "object",
        value: propDef
      };
    }
    type = getTypeOf(propDef.value);
    return Object.assign({
      type
    }, propDef, TYPE_DEFINITIONS[type]);
  }
  return Object.assign({
    type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}
function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return "array";
  }
  return typeof value;
}
var TYPE_DEFINITIONS;
var init_prop_types = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js"() {
    TYPE_DEFINITIONS = {
      number: {
        validate(value, propType) {
          return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
        }
      },
      array: {
        validate(value, propType) {
          return Array.isArray(value) || ArrayBuffer.isView(value);
        }
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;
    if (module.uniforms && !module.getUniforms) {
      const shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }
  return module;
}
function normalizeInjections(injections) {
  const result = {
    vs: {},
    fs: {}
  };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = hook.slice(0, 2);
    if (typeof injection === "string") {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
var VERTEX_SHADER2, FRAGMENT_SHADER2, ShaderModule;
var init_shader_module = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js"() {
    init_utils3();
    init_prop_types();
    VERTEX_SHADER2 = "vs";
    FRAGMENT_SHADER2 = "fs";
    ShaderModule = class {
      constructor(_ref) {
        let {
          name,
          vs: vs9,
          fs: fs9,
          dependencies = [],
          uniforms: uniforms3,
          getUniforms: getUniforms8,
          deprecations = [],
          defines: defines2 = {},
          inject = {},
          vertexShader,
          fragmentShader
        } = _ref;
        assert7(typeof name === "string");
        this.name = name;
        this.vs = vs9 || vertexShader;
        this.fs = fs9 || fragmentShader;
        this.getModuleUniforms = getUniforms8;
        this.dependencies = dependencies;
        this.deprecations = this._parseDeprecationDefinitions(deprecations);
        this.defines = defines2;
        this.injections = normalizeInjections(inject);
        if (uniforms3) {
          this.uniforms = parsePropTypes(uniforms3);
        }
      }
      getModuleSource(type) {
        let moduleSource;
        switch (type) {
          case VERTEX_SHADER2:
            moduleSource = this.vs || "";
            break;
          case FRAGMENT_SHADER2:
            moduleSource = this.fs || "";
            break;
          default:
            assert7(false);
        }
        return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
      }
      getUniforms(opts, uniforms3) {
        if (this.getModuleUniforms) {
          return this.getModuleUniforms(opts, uniforms3);
        }
        if (this.uniforms) {
          return this._defaultGetUniforms(opts);
        }
        return {};
      }
      getDefines() {
        return this.defines;
      }
      checkDeprecations(shaderSource, log4) {
        this.deprecations.forEach((def) => {
          if (def.regex.test(shaderSource)) {
            if (def.deprecated) {
              log4.deprecated(def.old, def.new)();
            } else {
              log4.removed(def.old, def.new)();
            }
          }
        });
      }
      _parseDeprecationDefinitions(deprecations) {
        deprecations.forEach((def) => {
          switch (def.type) {
            case "function":
              def.regex = new RegExp("\\b".concat(def.old, "\\("));
              break;
            default:
              def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
          }
        });
        return deprecations;
      }
      _defaultGetUniforms() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const uniforms3 = {};
        const propTypes = this.uniforms;
        for (const key in propTypes) {
          const propDef = propTypes[key];
          if (key in opts && !propDef.private) {
            if (propDef.validate) {
              assert7(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
            }
            uniforms3[key] = opts[key];
          } else {
            uniforms3[key] = propDef.value;
          }
        }
        return uniforms3;
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
function resolveModules(modules) {
  return getShaderDependencies(instantiateModules(modules));
}
function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({
    modules,
    level: 0,
    moduleMap,
    moduleDepth
  });
  return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map((name) => moduleMap[name]);
}
function getDependencyGraph(_ref) {
  let {
    modules,
    level,
    moduleMap,
    moduleDepth
  } = _ref;
  if (level >= 5) {
    throw new Error("Possible loop in shader dependency graph");
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({
        modules: module.dependencies,
        level: level + 1,
        moduleMap,
        moduleDepth
      });
    }
  }
}
function instantiateModules(modules, seen) {
  return modules.map((module) => {
    if (module instanceof ShaderModule) {
      return module;
    }
    assert7(typeof module !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
    assert7(module.name, "shader module has no name");
    module = new ShaderModule(module);
    module.dependencies = instantiateModules(module.dependencies);
    return module;
  });
}
var init_resolve_modules = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js"() {
    init_shader_module();
    init_utils3();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
function isOldIE2() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
  const userAgent2 = opts.userAgent || navigator2.userAgent || "";
  const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
  const isTrident = userAgent2.indexOf("Trident/") !== -1;
  return isMSIE || isTrident;
}
var init_is_old_ie = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
function isWebGL22(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getContextInfo2(gl) {
  const info = gl.getExtension("WEBGL_debug_renderer_info");
  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}
function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return "NVIDIA";
  }
  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return "INTEL";
  }
  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return "AMD";
  }
  return "UNKNOWN GPU";
}
function canCompileGLGSExtension2(gl, cap) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const feature = WEBGL_FEATURES[cap];
  assert7(feature, cap);
  if (!isOldIE2(opts)) {
    return true;
  }
  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }
  const extensionName = feature[0];
  const behavior = opts.behavior || "enable";
  const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  assert7(feature, cap);
  const extensionName = isWebGL22(gl) ? feature[1] || feature[0] : feature[0];
  const value = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
  assert7(value === false || value === true);
  return value;
}
function hasFeatures2(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every((feature) => getFeature(gl, feature));
}
var GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION, WEBGL_FEATURES, FEATURES2, compiledGlslExtensions;
var init_webgl_info = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js"() {
    init_is_old_ie();
    init_assert7();
    GL_VENDOR = 7936;
    GL_RENDERER = 7937;
    GL_VERSION = 7938;
    GL_SHADING_LANGUAGE_VERSION = 35724;
    WEBGL_FEATURES = {
      GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
      GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
      GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
      GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
    };
    FEATURES2 = {};
    Object.keys(WEBGL_FEATURES).forEach((key) => {
      FEATURES2[key] = key;
    });
    compiledGlslExtensions = {};
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
function getPlatformShaderDefines(gl) {
  const debugInfo = getContextInfo2(gl);
  switch (debugInfo.gpuVendor.toLowerCase()) {
    case "nvidia":
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
    case "intel":
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    case "amd":
      return "#define AMD_GPU\n";
    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}
function getVersionDefines(gl, glslVersion, isFragment) {
  let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
  if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
    versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension2(gl, FEATURES2.GLSL_DERIVATIVES)) {
    versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension2(gl, FEATURES2.GLSL_FRAG_DATA, {
    behavior: "require"
  })) {
    versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
  }
  return versionDefines;
}
var init_platform_defines = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js"() {
    init_webgl_info();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
var MODULE_INJECTORS_VS, MODULE_INJECTORS_FS;
var init_module_injectors = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js"() {
    MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
    MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
function injectShader(source, type, inject) {
  let injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  const isVertex = type === VERTEX_SHADER;
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len2 = fragmentData.length; i < len2; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = "".concat(fragments.join("\n"), "\n");
    switch (key) {
      case "vs:#decl":
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "vs:#main-start":
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "vs:#main-end":
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      case "fs:#decl":
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "fs:#main-start":
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "fs:#main-end":
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      default:
        source = source.replace(key, (match) => match + fragmentString);
    }
  }
  source = source.replace(DECLARATION_INJECT_MARKER, "");
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[type]);
  }
  return source;
}
function combineInjects(injects) {
  const result = {};
  assert7(Array.isArray(injects) && injects.length > 1);
  injects.forEach((inject) => {
    for (const key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}
var MODULE_INJECTORS, DECLARATION_INJECT_MARKER, REGEX_START_OF_MAIN, REGEX_END_OF_MAIN, fragments;
var init_inject_shader = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js"() {
    init_module_injectors();
    init_constants2();
    init_utils3();
    MODULE_INJECTORS = {
      [VERTEX_SHADER]: MODULE_INJECTORS_VS,
      [FRAGMENT_SHADER]: MODULE_INJECTORS_FS
    };
    DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
    REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
    REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
    fragments = [];
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
function testVariable(qualifier) {
  return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
    case 100:
      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}
function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }
  return source;
}
function convertFragmentShaderTo300(source) {
  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
  } else {
    const outputName = "fragmentColor";
    source = source.replace(REGEX_START_OF_MAIN2, (match) => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
  }
  return source;
}
function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), ES100_FRAGMENT_OUTPUT_NAME);
  }
  return source;
}
var ES300_REPLACEMENTS, ES300_VERTEX_REPLACEMENTS, ES300_FRAGMENT_REPLACEMENTS, ES100_REPLACEMENTS, ES100_VERTEX_REPLACEMENTS, ES100_FRAGMENT_REPLACEMENTS, ES100_FRAGMENT_OUTPUT_NAME, ES300_FRAGMENT_OUTPUT_REGEX, REGEX_START_OF_MAIN2;
var init_transpile_shader = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js"() {
    ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
    ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("attribute"), "in $1"], [testVariable("varying"), "out $1"]];
    ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("varying"), "in $1"]];
    ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
    ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "attribute $1"], [testVariable("out"), "varying $1"]];
    ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "varying $1"]];
    ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
    ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
    REGEX_START_OF_MAIN2 = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
function assembleShaders(gl, opts) {
  const {
    vs: vs9,
    fs: fs9
  } = opts;
  const modules = resolveModules(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs9,
      type: VERTEX_SHADER,
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs9,
      type: FRAGMENT_SHADER,
      modules
    })),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShader(gl, _ref) {
  let {
    id,
    source,
    type,
    modules,
    defines: defines2 = {},
    hookFunctions = [],
    inject = {},
    transpileToGLSL100 = false,
    prologue = true,
    log: log4
  } = _ref;
  assert7(typeof source === "string", "shader source must be a string");
  const isVertex = type === VERTEX_SHADER;
  const sourceLines = source.split("\n");
  let glslVersion = 100;
  let versionLine = "";
  let coreSource = source;
  if (sourceLines[0].indexOf("#version ") === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join("\n");
  } else {
    versionLine = "#version ".concat(glslVersion);
  }
  const allDefines = {};
  modules.forEach((module) => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines2);
  let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
    id,
    source,
    type
  }), "\n").concat(getShaderType({
    type
  }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  const hookFunctionMap = normalizeHookFunctions(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log4) {
      module.checkDeprecations(coreSource, log4);
    }
    const moduleSource = module.getModuleSource(type, glslVersion);
    assembledSource += moduleSource;
    const injections = module.injections[type];
    for (const key in injections) {
      const match = key.match(/^(v|f)s:#([\w-]+)$/);
      if (match) {
        const name = match[2];
        const injectionType = name === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, type, declInjections);
  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, type, mainInjections);
  assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
  return assembledSource;
}
function assembleGetUniforms(modules) {
  return function getUniforms8(opts) {
    const uniforms3 = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms3);
      Object.assign(uniforms3, moduleUniforms);
    }
    return uniforms3;
  };
}
function getShaderType(_ref2) {
  let {
    type
  } = _ref2;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}
function getShaderName2(_ref3) {
  let {
    id,
    source,
    type
  } = _ref3;
  const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : "";
}
function getApplicationDefines() {
  let defines2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let count2 = 0;
  let sourceText = "";
  for (const define2 in defines2) {
    if (count2 === 0) {
      sourceText += "\n// APPLICATION DEFINES\n";
    }
    count2++;
    const value = defines2[define2];
    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define2.toUpperCase(), " ").concat(defines2[define2], "\n");
    }
  }
  if (count2 === 0) {
    sourceText += "\n";
  }
  return sourceText;
}
function getHookFunctions(hookFunctions, hookInjections) {
  let result = "";
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");
    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);
      for (const injection of injections) {
        result += "  ".concat(injection.injection, "\n");
      }
    }
    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }
    result += "}\n";
  }
  return result;
}
function normalizeHookFunctions(hookFunctions) {
  const result = {
    vs: {},
    fs: {}
  };
  hookFunctions.forEach((hook) => {
    let opts;
    if (typeof hook !== "string") {
      opts = hook;
      hook = opts.hook;
    } else {
      opts = {};
    }
    hook = hook.trim();
    const [stage, signature] = hook.split(":");
    const name = hook.replace(/\(.+/, "");
    result[stage][name] = Object.assign(opts, {
      signature
    });
  });
  return result;
}
var INJECT_SHADER_DECLARATIONS, SHADER_TYPE, FRAGMENT_SHADER_PROLOGUE;
var init_assemble_shaders = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js"() {
    init_constants2();
    init_resolve_modules();
    init_platform_defines();
    init_inject_shader();
    init_transpile_shader();
    init_utils3();
    INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
    SHADER_TYPE = {
      [VERTEX_SHADER]: "vertex",
      [FRAGMENT_SHADER]: "fragment"
    };
    FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, "").split(/\s+/);
  const [qualifier, type, definition] = words;
  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }
  const name = definition.split(";")[0];
  return {
    qualifier,
    type,
    name
  };
}
function getPassthroughFS() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    version = 100,
    input,
    inputType,
    output
  } = options;
  if (!input) {
    if (version === 300) {
      return FS300;
    } else if (version > 300) {
      return "#version ".concat(version, "\n").concat(FS_GLES);
    }
    return FS100;
  }
  const outputValue = convertToVec4(input, inputType);
  if (version >= 300) {
    return "#version ".concat(version, " ").concat(version === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }
  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function typeToChannelSuffix(type) {
  switch (type) {
    case "float":
      return "x";
    case "vec2":
      return "xy";
    case "vec3":
      return "xyz";
    case "vec4":
      return "xyzw";
    default:
      assert7(false);
      return null;
  }
}
function typeToChannelCount(type) {
  switch (type) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
    default:
      assert7(false);
      return null;
  }
}
function convertToVec4(variable, type) {
  switch (type) {
    case "float":
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
    case "vec2":
      return "vec4(".concat(variable, ", 0.0, 1.0)");
    case "vec3":
      return "vec4(".concat(variable, ", 1.0)");
    case "vec4":
      return variable;
    default:
      assert7(false);
      return null;
  }
}
var FS100, FS_GLES, FS300;
var init_shader_utils = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js"() {
    init_utils3();
    FS100 = "void main() {gl_FragColor = vec4(0);}";
    FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
    FS300 = "#version 300 es\n".concat(FS_GLES);
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js
var init_random = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js
var fp32shader, fp32;
var init_fp32 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js"() {
    fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
    fp32 = {
      name: "fp32",
      vs: fp32shader,
      fs: null
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js
function fp64ify(a) {
  let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const hiPart = Math.fround(a);
  const loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart(a) {
  return a - Math.fround(a);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}
var init_fp64_utils = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js
var fp64_arithmetic_glsl_default;
var init_fp64_arithmetic_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js"() {
    fp64_arithmetic_glsl_default = "uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js
var fp64_functions_glsl_default;
var init_fp64_functions_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js"() {
    fp64_functions_glsl_default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js
function getUniforms() {
  return CONST_UNIFORMS;
}
var CONST_UNIFORMS, fp64arithmetic, fp64;
var init_fp64 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js"() {
    init_fp64_utils();
    init_fp64_arithmetic_glsl();
    init_fp64_functions_glsl();
    CONST_UNIFORMS = {
      ONE: 1
    };
    fp64arithmetic = {
      name: "fp64-arithmetic",
      vs: fp64_arithmetic_glsl_default,
      fs: null,
      getUniforms,
      fp64ify,
      fp64LowPart,
      fp64ifyMatrix4
    };
    fp64 = {
      name: "fp64",
      vs: fp64_functions_glsl_default,
      fs: null,
      dependencies: [fp64arithmetic],
      fp64ify,
      fp64LowPart,
      fp64ifyMatrix4
    };
  }
});

// node_modules/@math.gl/core/dist/esm/lib/assert.js
function assert8(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
var init_assert8 = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/assert.js"() {
  }
});

// node_modules/@math.gl/core/dist/esm/lib/common.js
function configure(options) {
  for (const key in options) {
    assert8(key in config);
    config[key] = options[key];
  }
  return config;
}
function formatValue2(value, {
  precision = config.precision
} = {}) {
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
function isArray2(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function clone(array) {
  return "clone" in array ? array.clone() : array.slice();
}
function toRadians(degrees2) {
  return radians(degrees2);
}
function toDegrees(radians2) {
  return degrees(radians2);
}
function radians(degrees2, result) {
  return map(degrees2, (degrees3) => degrees3 * DEGREES_TO_RADIANS, result);
}
function degrees(radians2, result) {
  return map(radians2, (radians3) => radians3 * RADIANS_TO_DEGREES, result);
}
function sin(radians2, result) {
  return map(radians2, (angle2) => Math.sin(angle2), result);
}
function cos(radians2, result) {
  return map(radians2, (angle2) => Math.cos(angle2), result);
}
function tan(radians2, result) {
  return map(radians2, (angle2) => Math.tan(angle2), result);
}
function asin(radians2, result) {
  return map(radians2, (angle2) => Math.asin(angle2), result);
}
function acos(radians2, result) {
  return map(radians2, (angle2) => Math.acos(angle2), result);
}
function atan(radians2, result) {
  return map(radians2, (angle2) => Math.atan(angle2), result);
}
function clamp(value, min, max) {
  return map(value, (value2) => Math.max(min, Math.min(max, value2)));
}
function lerp3(a, b, t) {
  if (isArray2(a)) {
    return a.map((ai, i) => lerp3(ai, b[i], t));
  }
  return t * b + (1 - t) * a;
}
function equals(a, b, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a === b) {
      return true;
    }
    if (isArray2(a) && isArray2(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a && a.equals) {
      return a.equals(b);
    }
    if (b && b.equals) {
      return b.equals(a);
    }
    if (typeof a === "number" && typeof b === "number") {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function exactEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (a && typeof a === "object" && b && typeof b === "object") {
    if (a.constructor !== b.constructor) {
      return false;
    }
    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }
  if (isArray2(a) && isArray2(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function withEpsilon(epsilon, func) {
  const oldPrecision = config.EPSILON;
  config.EPSILON = epsilon;
  let value;
  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }
  return value;
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
  if (isArray2(value)) {
    const array = value;
    result = result || duplicateArray(array);
    for (let i = 0; i < result.length && i < array.length; ++i) {
      result[i] = func(value[i], i, result);
    }
    return result;
  }
  return func(value);
}
var RADIANS_TO_DEGREES, DEGREES_TO_RADIANS, config;
var init_common2 = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/common.js"() {
    init_assert8();
    RADIANS_TO_DEGREES = 1 / Math.PI * 180;
    DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
    config = {
      EPSILON: 1e-12,
      debug: false,
      precision: 4,
      printTypes: false,
      printDegrees: false,
      printRowMajor: true
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }
  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }
  return ExtendableBuiltin;
}
var MathArray;
var init_math_array = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/base/math-array.js"() {
    init_common2();
    MathArray = class extends _extendableBuiltin(Array) {
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(array, offset = 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = array[i + offset];
        }
        return this.check();
      }
      toArray(targetArray = [], offset = 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          targetArray[offset + i] = this[i];
        }
        return targetArray;
      }
      from(arrayOrObject) {
        return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
      }
      to(arrayOrObject) {
        if (arrayOrObject === this) {
          return this;
        }
        return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
      }
      toTarget(target) {
        return target ? this.to(target) : this;
      }
      toFloat32Array() {
        return new Float32Array(this);
      }
      toString() {
        return this.formatString(config);
      }
      formatString(opts) {
        let string = "";
        for (let i = 0; i < this.ELEMENTS; ++i) {
          string += (i > 0 ? ", " : "") + formatValue2(this[i], opts);
        }
        return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
      }
      equals(array) {
        if (!array || this.length !== array.length) {
          return false;
        }
        for (let i = 0; i < this.ELEMENTS; ++i) {
          if (!equals(this[i], array[i])) {
            return false;
          }
        }
        return true;
      }
      exactEquals(array) {
        if (!array || this.length !== array.length) {
          return false;
        }
        for (let i = 0; i < this.ELEMENTS; ++i) {
          if (this[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
      negate() {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = -this[i];
        }
        return this.check();
      }
      lerp(a, b, t) {
        if (t === void 0) {
          return this.lerp(this, a, b);
        }
        for (let i = 0; i < this.ELEMENTS; ++i) {
          const ai = a[i];
          this[i] = ai + t * (b[i] - ai);
        }
        return this.check();
      }
      min(vector) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(vector[i], this[i]);
        }
        return this.check();
      }
      max(vector) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.max(vector[i], this[i]);
        }
        return this.check();
      }
      clamp(minVector, maxVector) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
        }
        return this.check();
      }
      add(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] += vector[i];
          }
        }
        return this.check();
      }
      subtract(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] -= vector[i];
          }
        }
        return this.check();
      }
      scale(scale5) {
        if (typeof scale5 === "number") {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] *= scale5;
          }
        } else {
          for (let i = 0; i < this.ELEMENTS && i < scale5.length; ++i) {
            this[i] *= scale5[i];
          }
        }
        return this.check();
      }
      multiplyByScalar(scalar) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scalar;
        }
        return this.check();
      }
      check() {
        if (config.debug && !this.validate()) {
          throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
        }
        return this;
      }
      validate() {
        let valid = this.length === this.ELEMENTS;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          valid = valid && Number.isFinite(this[i]);
        }
        return valid;
      }
      sub(a) {
        return this.subtract(a);
      }
      setScalar(a) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = a;
        }
        return this.check();
      }
      addScalar(a) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] += a;
        }
        return this.check();
      }
      subScalar(a) {
        return this.addScalar(-a);
      }
      multiplyScalar(scalar) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scalar;
        }
        return this.check();
      }
      divideScalar(a) {
        return this.multiplyByScalar(1 / a);
      }
      clampScalar(min, max) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(Math.max(this[i], min), max);
        }
        return this.check();
      }
      get elements() {
        return this;
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/lib/validators.js
function validateVector(v, length4) {
  if (v.length !== length4) {
    return false;
  }
  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }
  return value;
}
function checkVector(v, length4, callerName = "") {
  if (config.debug && !validateVector(v, length4)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }
  return v;
}
var init_validators = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/validators.js"() {
    init_common2();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/base/vector.js
var Vector;
var init_vector = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/base/vector.js"() {
    init_math_array();
    init_validators();
    init_assert8();
    Vector = class extends MathArray {
      get x() {
        return this[0];
      }
      set x(value) {
        this[0] = checkNumber(value);
      }
      get y() {
        return this[1];
      }
      set y(value) {
        this[1] = checkNumber(value);
      }
      len() {
        return Math.sqrt(this.lengthSquared());
      }
      magnitude() {
        return this.len();
      }
      lengthSquared() {
        let length4 = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          length4 += this[i] * this[i];
        }
        return length4;
      }
      magnitudeSquared() {
        return this.lengthSquared();
      }
      distance(mathArray) {
        return Math.sqrt(this.distanceSquared(mathArray));
      }
      distanceSquared(mathArray) {
        let length4 = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          const dist = this[i] - mathArray[i];
          length4 += dist * dist;
        }
        return checkNumber(length4);
      }
      dot(mathArray) {
        let product = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          product += this[i] * mathArray[i];
        }
        return checkNumber(product);
      }
      normalize() {
        const length4 = this.magnitude();
        if (length4 !== 0) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] /= length4;
          }
        }
        return this.check();
      }
      multiply(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] *= vector[i];
          }
        }
        return this.check();
      }
      divide(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] /= vector[i];
          }
        }
        return this.check();
      }
      lengthSq() {
        return this.lengthSquared();
      }
      distanceTo(vector) {
        return this.distance(vector);
      }
      distanceToSquared(vector) {
        return this.distanceSquared(vector);
      }
      getComponent(i) {
        assert8(i >= 0 && i < this.ELEMENTS, "index is out of range");
        return checkNumber(this[i]);
      }
      setComponent(i, value) {
        assert8(i >= 0 && i < this.ELEMENTS, "index is out of range");
        this[i] = value;
        return this.check();
      }
      addVectors(a, b) {
        return this.copy(a).add(b);
      }
      subVectors(a, b) {
        return this.copy(a).subtract(b);
      }
      multiplyVectors(a, b) {
        return this.copy(a).multiply(b);
      }
      addScaledVector(a, b) {
        return this.add(new this.constructor(a).multiplyScalar(b));
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
function vec2_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const w = m[3] * x + m[7] * y || 1;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function vec4_transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}
var init_gl_matrix_extras = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"() {
  }
});

// node_modules/@math.gl/core/dist/esm/classes/vector2.js
var Vector2;
var init_vector2 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/vector2.js"() {
    init_vector();
    init_common2();
    init_validators();
    init_vec2();
    init_gl_matrix_extras();
    Vector2 = class extends Vector {
      constructor(x = 0, y = 0) {
        super(2);
        if (isArray2(x) && arguments.length === 1) {
          this.copy(x);
        } else {
          if (config.debug) {
            checkNumber(x);
            checkNumber(y);
          }
          this[0] = x;
          this[1] = y;
        }
      }
      set(x, y) {
        this[0] = x;
        this[1] = y;
        return this.check();
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        return this.check();
      }
      fromObject(object) {
        if (config.debug) {
          checkNumber(object.x);
          checkNumber(object.y);
        }
        this[0] = object.x;
        this[1] = object.y;
        return this.check();
      }
      toObject(object) {
        object.x = this[0];
        object.y = this[1];
        return object;
      }
      get ELEMENTS() {
        return 2;
      }
      horizontalAngle() {
        return Math.atan2(this.y, this.x);
      }
      verticalAngle() {
        return Math.atan2(this.x, this.y);
      }
      transform(matrix4) {
        return this.transformAsPoint(matrix4);
      }
      transformAsPoint(matrix4) {
        transformMat4(this, this, matrix4);
        return this.check();
      }
      transformAsVector(matrix4) {
        vec2_transformMat4AsVector(this, this, matrix4);
        return this.check();
      }
      transformByMatrix3(matrix3) {
        transformMat3(this, this, matrix3);
        return this.check();
      }
      transformByMatrix2x3(matrix2x3) {
        transformMat2d(this, this, matrix2x3);
        return this.check();
      }
      transformByMatrix2(matrix2) {
        transformMat2(this, this, matrix2);
        return this.check();
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/vector3.js
var ORIGIN, ZERO, Vector3;
var init_vector3 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/vector3.js"() {
    init_vector();
    init_common2();
    init_validators();
    init_vec3();
    init_gl_matrix_extras();
    ORIGIN = [0, 0, 0];
    Vector3 = class extends Vector {
      static get ZERO() {
        if (!ZERO) {
          ZERO = new Vector3(0, 0, 0);
          Object.freeze(ZERO);
        }
        return ZERO;
      }
      constructor(x = 0, y = 0, z = 0) {
        super(-0, -0, -0);
        if (arguments.length === 1 && isArray2(x)) {
          this.copy(x);
        } else {
          if (config.debug) {
            checkNumber(x);
            checkNumber(y);
            checkNumber(z);
          }
          this[0] = x;
          this[1] = y;
          this[2] = z;
        }
      }
      set(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this.check();
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        return this.check();
      }
      fromObject(object) {
        if (config.debug) {
          checkNumber(object.x);
          checkNumber(object.y);
          checkNumber(object.z);
        }
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        return this.check();
      }
      toObject(object) {
        object.x = this[0];
        object.y = this[1];
        object.z = this[2];
        return object;
      }
      get ELEMENTS() {
        return 3;
      }
      get z() {
        return this[2];
      }
      set z(value) {
        this[2] = checkNumber(value);
      }
      angle(vector) {
        return angle(this, vector);
      }
      cross(vector) {
        cross(this, this, vector);
        return this.check();
      }
      rotateX({
        radians: radians2,
        origin = ORIGIN
      }) {
        rotateX(this, this, origin, radians2);
        return this.check();
      }
      rotateY({
        radians: radians2,
        origin = ORIGIN
      }) {
        rotateY(this, this, origin, radians2);
        return this.check();
      }
      rotateZ({
        radians: radians2,
        origin = ORIGIN
      }) {
        rotateZ(this, this, origin, radians2);
        return this.check();
      }
      transform(matrix4) {
        return this.transformAsPoint(matrix4);
      }
      transformAsPoint(matrix4) {
        transformMat42(this, this, matrix4);
        return this.check();
      }
      transformAsVector(matrix4) {
        vec3_transformMat4AsVector(this, this, matrix4);
        return this.check();
      }
      transformByMatrix3(matrix3) {
        transformMat32(this, this, matrix3);
        return this.check();
      }
      transformByMatrix2(matrix2) {
        vec3_transformMat2(this, this, matrix2);
        return this.check();
      }
      transformByQuaternion(quaternion) {
        transformQuat(this, this, quaternion);
        return this.check();
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/vector4.js
var ZERO2, Vector4;
var init_vector4 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/vector4.js"() {
    init_vector();
    init_common2();
    init_validators();
    init_vec3();
    init_gl_matrix_extras();
    Vector4 = class extends Vector {
      static get ZERO() {
        if (!ZERO2) {
          ZERO2 = new Vector4(0, 0, 0, 0);
          Object.freeze(ZERO2);
        }
        return ZERO2;
      }
      constructor(x = 0, y = 0, z = 0, w = 0) {
        super(-0, -0, -0, -0);
        if (isArray2(x) && arguments.length === 1) {
          this.copy(x);
        } else {
          if (config.debug) {
            checkNumber(x);
            checkNumber(y);
            checkNumber(z);
            checkNumber(w);
          }
          this[0] = x;
          this[1] = y;
          this[2] = z;
          this[3] = w;
        }
      }
      set(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this.check();
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        return this.check();
      }
      fromObject(object) {
        if (config.debug) {
          checkNumber(object.x);
          checkNumber(object.y);
          checkNumber(object.z);
          checkNumber(object.w);
        }
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        this[3] = object.w;
        return this;
      }
      toObject(object) {
        object.x = this[0];
        object.y = this[1];
        object.z = this[2];
        object.w = this[3];
        return object;
      }
      get ELEMENTS() {
        return 4;
      }
      get z() {
        return this[2];
      }
      set z(value) {
        this[2] = checkNumber(value);
      }
      get w() {
        return this[3];
      }
      set w(value) {
        this[3] = checkNumber(value);
      }
      transform(matrix4) {
        transformMat42(this, this, matrix4);
        return this.check();
      }
      transformByMatrix3(matrix3) {
        vec4_transformMat3(this, this, matrix3);
        return this.check();
      }
      transformByMatrix2(matrix2) {
        vec4_transformMat2(this, this, matrix2);
        return this.check();
      }
      transformByQuaternion(quaternion) {
        transformQuat(this, this, quaternion);
        return this.check();
      }
      applyMatrix4(m) {
        m.transform(this, this);
        return this;
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
var Matrix;
var init_matrix = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/base/matrix.js"() {
    init_math_array();
    init_validators();
    init_common2();
    Matrix = class extends MathArray {
      toString() {
        let string = "[";
        if (config.printRowMajor) {
          string += "row-major:";
          for (let row = 0; row < this.RANK; ++row) {
            for (let col = 0; col < this.RANK; ++col) {
              string += " ".concat(this[col * this.RANK + row]);
            }
          }
        } else {
          string += "column-major:";
          for (let i = 0; i < this.ELEMENTS; ++i) {
            string += " ".concat(this[i]);
          }
        }
        string += "]";
        return string;
      }
      getElementIndex(row, col) {
        return col * this.RANK + row;
      }
      getElement(row, col) {
        return this[col * this.RANK + row];
      }
      setElement(row, col, value) {
        this[col * this.RANK + row] = checkNumber(value);
        return this;
      }
      getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
        const firstIndex = columnIndex * this.RANK;
        for (let i = 0; i < this.RANK; ++i) {
          result[i] = this[firstIndex + i];
        }
        return result;
      }
      setColumn(columnIndex, columnVector) {
        const firstIndex = columnIndex * this.RANK;
        for (let i = 0; i < this.RANK; ++i) {
          this[firstIndex + i] = columnVector[i];
        }
        return this;
      }
    };
  }
});

// node_modules/gl-matrix/esm/mat3.js
function create2() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate2(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate2(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale3(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromQuat2(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
var init_mat3 = __esm({
  "node_modules/gl-matrix/esm/mat3.js"() {
    init_common();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/matrix3.js
function getZeroMatrix() {
  if (!ZERO_MATRIX3) {
    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO_MATRIX3);
  }
  return ZERO_MATRIX3;
}
function getIdentityMatrix() {
  if (!IDENTITY_MATRIX3) {
    IDENTITY_MATRIX3 = new Matrix3();
    Object.freeze(IDENTITY_MATRIX3);
  }
  return IDENTITY_MATRIX3;
}
var INDICES, IDENTITY_MATRIX, Matrix3, ZERO_MATRIX3, IDENTITY_MATRIX3;
var init_matrix3 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/matrix3.js"() {
    init_matrix();
    init_validators();
    init_gl_matrix_extras();
    init_mat3();
    init_vec2();
    init_vec3();
    (function(INDICES3) {
      INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
      INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
      INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
      INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
      INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
      INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
      INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
      INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
      INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
    })(INDICES || (INDICES = {}));
    IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    Matrix3 = class extends Matrix {
      static get IDENTITY() {
        return getIdentityMatrix();
      }
      static get ZERO() {
        return getZeroMatrix();
      }
      get ELEMENTS() {
        return 9;
      }
      get RANK() {
        return 3;
      }
      get INDICES() {
        return INDICES;
      }
      constructor(array, ...args) {
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
        if (arguments.length === 1 && Array.isArray(array)) {
          this.copy(array);
        } else if (args.length > 0) {
          this.copy([array, ...args]);
        } else {
          this.identity();
        }
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        return this.check();
      }
      identity() {
        return this.copy(IDENTITY_MATRIX);
      }
      fromObject(object) {
        return this.check();
      }
      fromQuaternion(q) {
        fromQuat2(this, q);
        return this.check();
      }
      set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m01;
        this[4] = m11;
        this[5] = m21;
        this[6] = m02;
        this[7] = m12;
        this[8] = m22;
        return this.check();
      }
      setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m01;
        this[4] = m11;
        this[5] = m21;
        this[6] = m02;
        this[7] = m12;
        this[8] = m22;
        return this.check();
      }
      determinant() {
        return determinant2(this);
      }
      transpose() {
        transpose2(this, this);
        return this.check();
      }
      invert() {
        invert2(this, this);
        return this.check();
      }
      multiplyLeft(a) {
        multiply2(this, a, this);
        return this.check();
      }
      multiplyRight(a) {
        multiply2(this, this, a);
        return this.check();
      }
      rotate(radians2) {
        rotate2(this, this, radians2);
        return this.check();
      }
      scale(factor) {
        if (Array.isArray(factor)) {
          scale3(this, this, factor);
        } else {
          scale3(this, this, [factor, factor]);
        }
        return this.check();
      }
      translate(vec) {
        translate2(this, this, vec);
        return this.check();
      }
      transform(vector, result) {
        let out;
        switch (vector.length) {
          case 2:
            out = transformMat3(result || [-0, -0], vector, this);
            break;
          case 3:
            out = transformMat32(result || [-0, -0, -0], vector, this);
            break;
          case 4:
            out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(out, vector.length);
        return out;
      }
      transformVector(vector, result) {
        return this.transform(vector, result);
      }
      transformVector2(vector, result) {
        return this.transform(vector, result);
      }
      transformVector3(vector, result) {
        return this.transform(vector, result);
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/matrix4.js
function getZeroMatrix2() {
  if (!ZERO3) {
    ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO3);
  }
  return ZERO3;
}
function getIdentityMatrix2() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }
  return IDENTITY;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error("expected radians");
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}
var INDICES2, DEFAULT_FOVY, DEFAULT_ASPECT, DEFAULT_NEAR, DEFAULT_FAR, IDENTITY_MATRIX2, Matrix4, ZERO3, IDENTITY;
var init_matrix4 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/matrix4.js"() {
    init_matrix();
    init_validators();
    init_gl_matrix_extras();
    init_mat4();
    init_vec2();
    init_vec3();
    init_vec4();
    (function(INDICES3) {
      INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
      INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
      INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
      INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
      INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
      INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
      INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
      INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
      INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
      INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
      INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
      INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
      INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
      INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
      INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
      INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
    })(INDICES2 || (INDICES2 = {}));
    DEFAULT_FOVY = 45 * Math.PI / 180;
    DEFAULT_ASPECT = 1;
    DEFAULT_NEAR = 0.1;
    DEFAULT_FAR = 500;
    IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    Matrix4 = class extends Matrix {
      static get IDENTITY() {
        return getIdentityMatrix2();
      }
      static get ZERO() {
        return getZeroMatrix2();
      }
      get ELEMENTS() {
        return 16;
      }
      get RANK() {
        return 4;
      }
      get INDICES() {
        return INDICES2;
      }
      constructor(array) {
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
        if (arguments.length === 1 && Array.isArray(array)) {
          this.copy(array);
        } else {
          this.identity();
        }
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        this[9] = array[9];
        this[10] = array[10];
        this[11] = array[11];
        this[12] = array[12];
        this[13] = array[13];
        this[14] = array[14];
        this[15] = array[15];
        return this.check();
      }
      set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
      }
      setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
      }
      toRowMajor(result) {
        result[0] = this[0];
        result[1] = this[4];
        result[2] = this[8];
        result[3] = this[12];
        result[4] = this[1];
        result[5] = this[5];
        result[6] = this[9];
        result[7] = this[13];
        result[8] = this[2];
        result[9] = this[6];
        result[10] = this[10];
        result[11] = this[14];
        result[12] = this[3];
        result[13] = this[7];
        result[14] = this[11];
        result[15] = this[15];
        return result;
      }
      identity() {
        return this.copy(IDENTITY_MATRIX2);
      }
      fromObject(object) {
        return this.check();
      }
      fromQuaternion(quaternion) {
        fromQuat(this, quaternion);
        return this.check();
      }
      frustum(view) {
        const {
          left,
          right,
          bottom,
          top,
          near = DEFAULT_NEAR,
          far = DEFAULT_FAR
        } = view;
        if (far === Infinity) {
          computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
        } else {
          frustum(this, left, right, bottom, top, near, far);
        }
        return this.check();
      }
      lookAt(view) {
        const {
          eye,
          center = [0, 0, 0],
          up = [0, 1, 0]
        } = view;
        lookAt(this, eye, center, up);
        return this.check();
      }
      ortho(view) {
        const {
          left,
          right,
          bottom,
          top,
          near = DEFAULT_NEAR,
          far = DEFAULT_FAR
        } = view;
        ortho(this, left, right, bottom, top, near, far);
        return this.check();
      }
      orthographic(view) {
        const {
          fovy = DEFAULT_FOVY,
          aspect = DEFAULT_ASPECT,
          focalDistance = 1,
          near = DEFAULT_NEAR,
          far = DEFAULT_FAR
        } = view;
        checkRadians(fovy);
        const halfY = fovy / 2;
        const top = focalDistance * Math.tan(halfY);
        const right = top * aspect;
        return this.ortho({
          left: -right,
          right,
          bottom: -top,
          top,
          near,
          far
        });
      }
      perspective(view) {
        const {
          fovy = 45 * Math.PI / 180,
          aspect = 1,
          near = 0.1,
          far = 500
        } = view;
        checkRadians(fovy);
        perspective(this, fovy, aspect, near, far);
        return this.check();
      }
      determinant() {
        return determinant(this);
      }
      getScale(result = [-0, -0, -0]) {
        result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
        result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        return result;
      }
      getTranslation(result = [-0, -0, -0]) {
        result[0] = this[12];
        result[1] = this[13];
        result[2] = this[14];
        return result;
      }
      getRotation(result, scaleResult) {
        result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
        scaleResult = scaleResult || [-0, -0, -0];
        const scale5 = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale5[0];
        const inverseScale1 = 1 / scale5[1];
        const inverseScale2 = 1 / scale5[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = 0;
        result[4] = this[4] * inverseScale0;
        result[5] = this[5] * inverseScale1;
        result[6] = this[6] * inverseScale2;
        result[7] = 0;
        result[8] = this[8] * inverseScale0;
        result[9] = this[9] * inverseScale1;
        result[10] = this[10] * inverseScale2;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
      }
      getRotationMatrix3(result, scaleResult) {
        result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
        scaleResult = scaleResult || [-0, -0, -0];
        const scale5 = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale5[0];
        const inverseScale1 = 1 / scale5[1];
        const inverseScale2 = 1 / scale5[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = this[4] * inverseScale0;
        result[4] = this[5] * inverseScale1;
        result[5] = this[6] * inverseScale2;
        result[6] = this[8] * inverseScale0;
        result[7] = this[9] * inverseScale1;
        result[8] = this[10] * inverseScale2;
        return result;
      }
      transpose() {
        transpose(this, this);
        return this.check();
      }
      invert() {
        invert(this, this);
        return this.check();
      }
      multiplyLeft(a) {
        multiply(this, a, this);
        return this.check();
      }
      multiplyRight(a) {
        multiply(this, this, a);
        return this.check();
      }
      rotateX(radians2) {
        rotateX2(this, this, radians2);
        return this.check();
      }
      rotateY(radians2) {
        rotateY2(this, this, radians2);
        return this.check();
      }
      rotateZ(radians2) {
        rotateZ2(this, this, radians2);
        return this.check();
      }
      rotateXYZ(angleXYZ) {
        return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
      }
      rotateAxis(radians2, axis) {
        rotate(this, this, radians2, axis);
        return this.check();
      }
      scale(factor) {
        scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
        return this.check();
      }
      translate(vector) {
        translate(this, this, vector);
        return this.check();
      }
      transform(vector, result) {
        if (vector.length === 4) {
          result = transformMat43(result || [-0, -0, -0, -0], vector, this);
          checkVector(result, 4);
          return result;
        }
        return this.transformAsPoint(vector, result);
      }
      transformAsPoint(vector, result) {
        const {
          length: length4
        } = vector;
        let out;
        switch (length4) {
          case 2:
            out = transformMat4(result || [-0, -0], vector, this);
            break;
          case 3:
            out = transformMat42(result || [-0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(out, vector.length);
        return out;
      }
      transformAsVector(vector, result) {
        let out;
        switch (vector.length) {
          case 2:
            out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
            break;
          case 3:
            out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(out, vector.length);
        return out;
      }
      transformPoint(vector, result) {
        return this.transformAsPoint(vector, result);
      }
      transformVector(vector, result) {
        return this.transformAsPoint(vector, result);
      }
      transformDirection(vector, result) {
        return this.transformAsVector(vector, result);
      }
      makeRotationX(radians2) {
        return this.identity().rotateX(radians2);
      }
      makeTranslation(x, y, z) {
        return this.identity().translate([x, y, z]);
      }
    };
  }
});

// node_modules/gl-matrix/esm/quat.js
function create3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function multiply3(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert3(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot4 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot4 ? 1 / dot4 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var add3, scale4, dot3, lerp4, length3, squaredLength2, normalize3, rotationTo, sqlerp, setAxes;
var init_quat = __esm({
  "node_modules/gl-matrix/esm/quat.js"() {
    init_common();
    init_mat3();
    init_vec3();
    init_vec4();
    add3 = add2;
    scale4 = scale2;
    dot3 = dot2;
    lerp4 = lerp2;
    length3 = length2;
    squaredLength2 = squaredLength;
    normalize3 = normalize2;
    rotationTo = function() {
      var tmpvec3 = create();
      var xUnitVec3 = fromValues(1, 0, 0);
      var yUnitVec3 = fromValues(0, 1, 0);
      return function(out, a, b) {
        var dot4 = dot(a, b);
        if (dot4 < -0.999999) {
          cross(tmpvec3, xUnitVec3, a);
          if (len(tmpvec3) < 1e-6)
            cross(tmpvec3, yUnitVec3, a);
          normalize(tmpvec3, tmpvec3);
          setAxisAngle(out, tmpvec3, Math.PI);
          return out;
        } else if (dot4 > 0.999999) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        } else {
          cross(tmpvec3, a, b);
          out[0] = tmpvec3[0];
          out[1] = tmpvec3[1];
          out[2] = tmpvec3[2];
          out[3] = 1 + dot4;
          return normalize3(out, out);
        }
      };
    }();
    sqlerp = function() {
      var temp1 = create3();
      var temp2 = create3();
      return function(out, a, b, c, d, t) {
        slerp(temp1, a, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
      };
    }();
    setAxes = function() {
      var matr = create2();
      return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize3(out, fromMat3(out, matr));
      };
    }();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/quaternion.js
var IDENTITY_QUATERNION, Quaternion;
var init_quaternion = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/quaternion.js"() {
    init_math_array();
    init_validators();
    init_vector4();
    init_quat();
    init_vec4();
    IDENTITY_QUATERNION = [0, 0, 0, 1];
    Quaternion = class extends MathArray {
      constructor(x = 0, y = 0, z = 0, w = 1) {
        super(-0, -0, -0, -0);
        if (Array.isArray(x) && arguments.length === 1) {
          this.copy(x);
        } else {
          this.set(x, y, z, w);
        }
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        return this.check();
      }
      set(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this.check();
      }
      fromObject(object) {
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        this[3] = object.w;
        return this.check();
      }
      fromMatrix3(m) {
        fromMat3(this, m);
        return this.check();
      }
      fromAxisRotation(axis, rad) {
        setAxisAngle(this, axis, rad);
        return this.check();
      }
      identity() {
        identity(this);
        return this.check();
      }
      setAxisAngle(axis, rad) {
        return this.fromAxisRotation(axis, rad);
      }
      get ELEMENTS() {
        return 4;
      }
      get x() {
        return this[0];
      }
      set x(value) {
        this[0] = checkNumber(value);
      }
      get y() {
        return this[1];
      }
      set y(value) {
        this[1] = checkNumber(value);
      }
      get z() {
        return this[2];
      }
      set z(value) {
        this[2] = checkNumber(value);
      }
      get w() {
        return this[3];
      }
      set w(value) {
        this[3] = checkNumber(value);
      }
      len() {
        return length3(this);
      }
      lengthSquared() {
        return squaredLength2(this);
      }
      dot(a) {
        return dot3(this, a);
      }
      rotationTo(vectorA, vectorB) {
        rotationTo(this, vectorA, vectorB);
        return this.check();
      }
      add(a) {
        add3(this, this, a);
        return this.check();
      }
      calculateW() {
        calculateW(this, this);
        return this.check();
      }
      conjugate() {
        conjugate(this, this);
        return this.check();
      }
      invert() {
        invert3(this, this);
        return this.check();
      }
      lerp(a, b, t) {
        if (t === void 0) {
          return this.lerp(this, a, b);
        }
        lerp4(this, a, b, t);
        return this.check();
      }
      multiplyRight(a) {
        multiply3(this, this, a);
        return this.check();
      }
      multiplyLeft(a) {
        multiply3(this, a, this);
        return this.check();
      }
      normalize() {
        const length4 = this.len();
        const l = length4 > 0 ? 1 / length4 : 0;
        this[0] = this[0] * l;
        this[1] = this[1] * l;
        this[2] = this[2] * l;
        this[3] = this[3] * l;
        if (length4 === 0) {
          this[3] = 1;
        }
        return this.check();
      }
      rotateX(rad) {
        rotateX3(this, this, rad);
        return this.check();
      }
      rotateY(rad) {
        rotateY3(this, this, rad);
        return this.check();
      }
      rotateZ(rad) {
        rotateZ3(this, this, rad);
        return this.check();
      }
      scale(b) {
        scale4(this, this, b);
        return this.check();
      }
      slerp(arg0, arg1, arg2) {
        let start;
        let target;
        let ratio;
        switch (arguments.length) {
          case 1:
            ({
              start = IDENTITY_QUATERNION,
              target,
              ratio
            } = arg0);
            break;
          case 2:
            start = this;
            target = arg0;
            ratio = arg1;
            break;
          default:
            start = arg0;
            target = arg1;
            ratio = arg2;
        }
        slerp(this, start, target, ratio);
        return this.check();
      }
      transformVector4(vector, result = new Vector4()) {
        transformQuat2(result, vector, this);
        return checkVector(result, 4);
      }
      lengthSq() {
        return this.lengthSquared();
      }
      setFromAxisAngle(axis, rad) {
        return this.setAxisAngle(axis, rad);
      }
      premultiply(a) {
        return this.multiplyLeft(a);
      }
      multiply(a) {
        return this.multiplyRight(a);
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js
var EPSILON2, EARTH_RADIUS_METERS, SphericalCoordinates;
var init_spherical_coordinates = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js"() {
    init_defineProperty();
    init_vector3();
    init_common2();
    init_common2();
    init_vec3();
    EPSILON2 = 1e-6;
    EARTH_RADIUS_METERS = 6371e3;
    SphericalCoordinates = class {
      constructor({
        phi = 0,
        theta = 0,
        radius = 1,
        bearing,
        pitch,
        altitude,
        radiusScale = EARTH_RADIUS_METERS
      } = {}) {
        _defineProperty(this, "phi", void 0);
        _defineProperty(this, "theta", void 0);
        _defineProperty(this, "radius", void 0);
        _defineProperty(this, "radiusScale", void 0);
        this.phi = phi;
        this.theta = theta;
        this.radius = radius || altitude || 1;
        this.radiusScale = radiusScale || 1;
        if (bearing !== void 0) {
          this.bearing = bearing;
        }
        if (pitch !== void 0) {
          this.pitch = pitch;
        }
        this.check();
      }
      toString() {
        return this.formatString(config);
      }
      formatString({
        printTypes = false
      }) {
        const f = formatValue2;
        return "".concat(printTypes ? "Spherical" : "", "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
      }
      equals(other) {
        return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);
      }
      exactEquals(other) {
        return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
      }
      get bearing() {
        return 180 - degrees(this.phi);
      }
      set bearing(v) {
        this.phi = Math.PI - radians(v);
      }
      get pitch() {
        return degrees(this.theta);
      }
      set pitch(v) {
        this.theta = radians(v);
      }
      get longitude() {
        return degrees(this.phi);
      }
      get latitude() {
        return degrees(this.theta);
      }
      get lng() {
        return degrees(this.phi);
      }
      get lat() {
        return degrees(this.theta);
      }
      get z() {
        return (this.radius - 1) * this.radiusScale;
      }
      set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this.check();
      }
      clone() {
        return new SphericalCoordinates().copy(this);
      }
      copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this.check();
      }
      fromLngLatZ([lng, lat, z]) {
        this.radius = 1 + z / this.radiusScale;
        this.phi = radians(lat);
        this.theta = radians(lng);
        return this.check();
      }
      fromVector3(v) {
        this.radius = length(v);
        if (this.radius > 0) {
          this.theta = Math.atan2(v[0], v[1]);
          this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));
        }
        return this.check();
      }
      toVector3() {
        return new Vector3(0, 0, this.radius).rotateX({
          radians: this.theta
        }).rotateZ({
          radians: this.phi
        });
      }
      makeSafe() {
        this.phi = Math.max(EPSILON2, Math.min(Math.PI - EPSILON2, this.phi));
        return this;
      }
      check() {
        if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
          throw new Error("SphericalCoordinates: some fields set to invalid numbers");
        }
        return this;
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/euler.js
function validateOrder(value) {
  return value >= 0 && value < 6;
}
function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }
  return value;
}
var ERR_UNKNOWN_ORDER, ALMOST_ONE, RotationOrder, Euler;
var init_euler = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/euler.js"() {
    init_math_array();
    init_quaternion();
    init_common2();
    init_validators();
    ERR_UNKNOWN_ORDER = "Unknown Euler angle order";
    ALMOST_ONE = 0.99999;
    (function(RotationOrder2) {
      RotationOrder2[RotationOrder2["ZYX"] = 0] = "ZYX";
      RotationOrder2[RotationOrder2["YXZ"] = 1] = "YXZ";
      RotationOrder2[RotationOrder2["XZY"] = 2] = "XZY";
      RotationOrder2[RotationOrder2["ZXY"] = 3] = "ZXY";
      RotationOrder2[RotationOrder2["YZX"] = 4] = "YZX";
      RotationOrder2[RotationOrder2["XYZ"] = 5] = "XYZ";
    })(RotationOrder || (RotationOrder = {}));
    Euler = class extends MathArray {
      static get ZYX() {
        return RotationOrder.ZYX;
      }
      static get YXZ() {
        return RotationOrder.YXZ;
      }
      static get XZY() {
        return RotationOrder.XZY;
      }
      static get ZXY() {
        return RotationOrder.ZXY;
      }
      static get YZX() {
        return RotationOrder.YZX;
      }
      static get XYZ() {
        return RotationOrder.XYZ;
      }
      static get RollPitchYaw() {
        return RotationOrder.ZYX;
      }
      static get DefaultOrder() {
        return RotationOrder.ZYX;
      }
      static get RotationOrders() {
        return RotationOrder;
      }
      static rotationOrder(order) {
        return RotationOrder[order];
      }
      get ELEMENTS() {
        return 4;
      }
      constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
        super(-0, -0, -0, -0);
        if (arguments.length > 0 && Array.isArray(arguments[0])) {
          this.fromVector3(...arguments);
        } else {
          this.set(x, y, z, order);
        }
      }
      fromQuaternion(quaternion) {
        const [x, y, z, w] = quaternion;
        const ysqr = y * y;
        const t0 = -2 * (ysqr + z * z) + 1;
        const t1 = 2 * (x * y + w * z);
        let t2 = -2 * (x * z - w * y);
        const t3 = 2 * (y * z + w * x);
        const t4 = -2 * (x * x + ysqr) + 1;
        t2 = t2 > 1 ? 1 : t2;
        t2 = t2 < -1 ? -1 : t2;
        const roll = Math.atan2(t3, t4);
        const pitch = Math.asin(t2);
        const yaw = Math.atan2(t1, t0);
        return this.set(roll, pitch, yaw, Euler.RollPitchYaw);
      }
      fromObject(object) {
        throw new Error("not implemented");
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = Number.isFinite(array[3]) || this.order;
        return this.check();
      }
      set(x = 0, y = 0, z = 0, order) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = Number.isFinite(order) ? order : this[3];
        return this.check();
      }
      validate() {
        return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
      }
      toArray(array = [], offset = 0) {
        array[offset] = this[0];
        array[offset + 1] = this[1];
        array[offset + 2] = this[2];
        return array;
      }
      toArray4(array = [], offset = 0) {
        array[offset] = this[0];
        array[offset + 1] = this[1];
        array[offset + 2] = this[2];
        array[offset + 3] = this[3];
        return array;
      }
      toVector3(result = [-0, -0, -0]) {
        result[0] = this[0];
        result[1] = this[1];
        result[2] = this[2];
        return result;
      }
      get x() {
        return this[0];
      }
      set x(value) {
        this[0] = checkNumber(value);
      }
      get y() {
        return this[1];
      }
      set y(value) {
        this[1] = checkNumber(value);
      }
      get z() {
        return this[2];
      }
      set z(value) {
        this[2] = checkNumber(value);
      }
      get alpha() {
        return this[0];
      }
      set alpha(value) {
        this[0] = checkNumber(value);
      }
      get beta() {
        return this[1];
      }
      set beta(value) {
        this[1] = checkNumber(value);
      }
      get gamma() {
        return this[2];
      }
      set gamma(value) {
        this[2] = checkNumber(value);
      }
      get phi() {
        return this[0];
      }
      set phi(value) {
        this[0] = checkNumber(value);
      }
      get theta() {
        return this[1];
      }
      set theta(value) {
        this[1] = checkNumber(value);
      }
      get psi() {
        return this[2];
      }
      set psi(value) {
        this[2] = checkNumber(value);
      }
      get roll() {
        return this[0];
      }
      set roll(value) {
        this[0] = checkNumber(value);
      }
      get pitch() {
        return this[1];
      }
      set pitch(value) {
        this[1] = checkNumber(value);
      }
      get yaw() {
        return this[2];
      }
      set yaw(value) {
        this[2] = checkNumber(value);
      }
      get order() {
        return this[3];
      }
      set order(value) {
        this[3] = checkOrder(value);
      }
      fromVector3(v, order) {
        return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
      }
      fromArray(array, offset = 0) {
        this[0] = array[0 + offset];
        this[1] = array[1 + offset];
        this[2] = array[2 + offset];
        if (array[3] !== void 0) {
          this[3] = array[3];
        }
        return this.check();
      }
      fromRollPitchYaw(roll, pitch, yaw) {
        return this.set(roll, pitch, yaw, RotationOrder.ZYX);
      }
      fromRotationMatrix(m, order = Euler.DefaultOrder) {
        this._fromRotationMatrix(m, order);
        return this.check();
      }
      getRotationMatrix(m) {
        return this._getRotationMatrix(m);
      }
      getQuaternion() {
        const q = new Quaternion();
        switch (this[4]) {
          case RotationOrder.XYZ:
            return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);
          case RotationOrder.YXZ:
            return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);
          case RotationOrder.ZXY:
            return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);
          case RotationOrder.ZYX:
            return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);
          case RotationOrder.YZX:
            return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);
          case RotationOrder.XZY:
            return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);
          default:
            throw new Error(ERR_UNKNOWN_ORDER);
        }
      }
      _fromRotationMatrix(m, order = Euler.DefaultOrder) {
        const m11 = m[0], m12 = m[4], m13 = m[8];
        const m21 = m[1], m22 = m[5], m23 = m[9];
        const m31 = m[2], m32 = m[6], m33 = m[10];
        order = order || this[3];
        switch (order) {
          case Euler.XYZ:
            this[1] = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < ALMOST_ONE) {
              this[0] = Math.atan2(-m23, m33);
              this[2] = Math.atan2(-m12, m11);
            } else {
              this[0] = Math.atan2(m32, m22);
              this[2] = 0;
            }
            break;
          case Euler.YXZ:
            this[0] = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < ALMOST_ONE) {
              this[1] = Math.atan2(m13, m33);
              this[2] = Math.atan2(m21, m22);
            } else {
              this[1] = Math.atan2(-m31, m11);
              this[2] = 0;
            }
            break;
          case Euler.ZXY:
            this[0] = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < ALMOST_ONE) {
              this[1] = Math.atan2(-m31, m33);
              this[2] = Math.atan2(-m12, m22);
            } else {
              this[1] = 0;
              this[2] = Math.atan2(m21, m11);
            }
            break;
          case Euler.ZYX:
            this[1] = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < ALMOST_ONE) {
              this[0] = Math.atan2(m32, m33);
              this[2] = Math.atan2(m21, m11);
            } else {
              this[0] = 0;
              this[2] = Math.atan2(-m12, m22);
            }
            break;
          case Euler.YZX:
            this[2] = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < ALMOST_ONE) {
              this[0] = Math.atan2(-m23, m22);
              this[1] = Math.atan2(-m31, m11);
            } else {
              this[0] = 0;
              this[1] = Math.atan2(m13, m33);
            }
            break;
          case Euler.XZY:
            this[2] = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < ALMOST_ONE) {
              this[0] = Math.atan2(m32, m22);
              this[1] = Math.atan2(m13, m11);
            } else {
              this[0] = Math.atan2(-m23, m33);
              this[1] = 0;
            }
            break;
          default:
            throw new Error(ERR_UNKNOWN_ORDER);
        }
        this[3] = order;
        return this;
      }
      _getRotationMatrix(result) {
        const te = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
        const x = this.x, y = this.y, z = this.z;
        const a = Math.cos(x);
        const c = Math.cos(y);
        const e2 = Math.cos(z);
        const b = Math.sin(x);
        const d = Math.sin(y);
        const f = Math.sin(z);
        switch (this[3]) {
          case Euler.XYZ: {
            const ae = a * e2, af = a * f, be = b * e2, bf = b * f;
            te[0] = c * e2;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
            break;
          }
          case Euler.YXZ: {
            const ce = c * e2, cf = c * f, de = d * e2, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e2;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
            break;
          }
          case Euler.ZXY: {
            const ce = c * e2, cf = c * f, de = d * e2, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e2;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
            break;
          }
          case Euler.ZYX: {
            const ae = a * e2, af = a * f, be = b * e2, bf = b * f;
            te[0] = c * e2;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
            break;
          }
          case Euler.YZX: {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e2;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e2;
            te[9] = -b * e2;
            te[2] = -d * e2;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
            break;
          }
          case Euler.XZY: {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e2;
            te[4] = -f;
            te[8] = d * e2;
            te[1] = ac * f + bd;
            te[5] = a * e2;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e2;
            te[10] = bd * f + ac;
            break;
          }
          default:
            throw new Error(ERR_UNKNOWN_ORDER);
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return te;
      }
      toQuaternion() {
        const cy = Math.cos(this.yaw * 0.5);
        const sy = Math.sin(this.yaw * 0.5);
        const cr = Math.cos(this.roll * 0.5);
        const sr = Math.sin(this.roll * 0.5);
        const cp = Math.cos(this.pitch * 0.5);
        const sp = Math.sin(this.pitch * 0.5);
        const w = cy * cr * cp + sy * sr * sp;
        const x = cy * sr * cp - sy * cr * sp;
        const y = cy * cr * sp + sy * sr * cp;
        const z = sy * cr * cp - cy * sr * sp;
        return new Quaternion(x, y, z, w);
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/pose.js
var Pose;
var init_pose = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/pose.js"() {
    init_defineProperty();
    init_matrix4();
    init_vector3();
    init_euler();
    Pose = class {
      constructor({
        x = 0,
        y = 0,
        z = 0,
        roll = 0,
        pitch = 0,
        yaw = 0,
        position,
        orientation
      } = {}) {
        _defineProperty(this, "position", void 0);
        _defineProperty(this, "orientation", void 0);
        if (Array.isArray(position) && position.length === 3) {
          this.position = new Vector3(position);
        } else {
          this.position = new Vector3(x, y, z);
        }
        if (Array.isArray(orientation) && orientation.length === 4) {
          this.orientation = new Euler(orientation, orientation[3]);
        } else {
          this.orientation = new Euler(roll, pitch, yaw, Euler.RollPitchYaw);
        }
      }
      get x() {
        return this.position.x;
      }
      set x(value) {
        this.position.x = value;
      }
      get y() {
        return this.position.y;
      }
      set y(value) {
        this.position.y = value;
      }
      get z() {
        return this.position.z;
      }
      set z(value) {
        this.position.z = value;
      }
      get roll() {
        return this.orientation.roll;
      }
      set roll(value) {
        this.orientation.roll = value;
      }
      get pitch() {
        return this.orientation.pitch;
      }
      set pitch(value) {
        this.orientation.pitch = value;
      }
      get yaw() {
        return this.orientation.yaw;
      }
      set yaw(value) {
        this.orientation.yaw = value;
      }
      getPosition() {
        return this.position;
      }
      getOrientation() {
        return this.orientation;
      }
      equals(pose) {
        if (!pose) {
          return false;
        }
        return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
      }
      exactEquals(pose) {
        if (!pose) {
          return false;
        }
        return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
      }
      getTransformationMatrix() {
        const sr = Math.sin(this.roll);
        const sp = Math.sin(this.pitch);
        const sw = Math.sin(this.yaw);
        const cr = Math.cos(this.roll);
        const cp = Math.cos(this.pitch);
        const cw = Math.cos(this.yaw);
        return new Matrix4().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
      }
      getTransformationMatrixFromPose(pose) {
        return new Matrix4().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
      }
      getTransformationMatrixToPose(pose) {
        return new Matrix4().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/lib/math-utils.js
var math_utils_default;
var init_math_utils = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/math-utils.js"() {
    math_utils_default = {
      EPSILON1: 0.1,
      EPSILON2: 0.01,
      EPSILON3: 1e-3,
      EPSILON4: 1e-4,
      EPSILON5: 1e-5,
      EPSILON6: 1e-6,
      EPSILON7: 1e-7,
      EPSILON8: 1e-8,
      EPSILON9: 1e-9,
      EPSILON10: 1e-10,
      EPSILON11: 1e-11,
      EPSILON12: 1e-12,
      EPSILON13: 1e-13,
      EPSILON14: 1e-14,
      EPSILON15: 1e-15,
      EPSILON16: 1e-16,
      EPSILON17: 1e-17,
      EPSILON18: 1e-18,
      EPSILON19: 1e-19,
      EPSILON20: 1e-20,
      PI_OVER_TWO: Math.PI / 2,
      PI_OVER_FOUR: Math.PI / 4,
      PI_OVER_SIX: Math.PI / 6,
      TWO_PI: Math.PI * 2
    };
  }
});

// node_modules/@math.gl/core/dist/esm/index.js
var init_esm11 = __esm({
  "node_modules/@math.gl/core/dist/esm/index.js"() {
    init_vector2();
    init_vector3();
    init_vector4();
    init_matrix3();
    init_matrix4();
    init_quaternion();
    init_spherical_coordinates();
    init_pose();
    init_euler();
    init_math_utils();
    init_assert8();
    init_common2();
    init_spherical_coordinates();
    init_pose();
    init_euler();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js
function getUniforms2() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  let prevUniforms = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const uniforms3 = {};
  if (opts.modelMatrix !== void 0) {
    uniforms3.modelMatrix = opts.modelMatrix;
  }
  if (opts.viewMatrix !== void 0) {
    uniforms3.viewMatrix = opts.viewMatrix;
  }
  if (opts.projectionMatrix !== void 0) {
    uniforms3.projectionMatrix = opts.projectionMatrix;
  }
  if (opts.cameraPositionWorld !== void 0) {
    uniforms3.cameraPositionWorld = opts.cameraPositionWorld;
  }
  if (opts.projectionMatrix !== void 0 || opts.viewMatrix !== void 0) {
    uniforms3.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }
  return uniforms3;
}
var IDENTITY_MATRIX4, DEFAULT_MODULE_OPTIONS, common, vs, fs4, project;
var init_project = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js"() {
    init_esm11();
    IDENTITY_MATRIX4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    DEFAULT_MODULE_OPTIONS = {
      modelMatrix: IDENTITY_MATRIX4,
      viewMatrix: IDENTITY_MATRIX4,
      projectionMatrix: IDENTITY_MATRIX4,
      cameraPositionWorld: [0, 0, 0]
    };
    common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
    vs = "".concat(common, "\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
    fs4 = "\n".concat(common);
    project = {
      name: "project",
      getUniforms: getUniforms2,
      vs,
      fs: fs4
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js
var lights_glsl_default;
var init_lights_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js"() {
    lights_glsl_default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js
function convertColor() {
  let {
    color = [0, 0, 0],
    intensity = 1
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return color.map((component) => component * intensity / 255);
}
function getLightSourceUniforms(_ref) {
  let {
    ambientLight,
    pointLights = [],
    directionalLights = []
  } = _ref;
  const lightSourceUniforms = {};
  if (ambientLight) {
    lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
  } else {
    lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
  }
  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}
function getUniforms3() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS;
  if ("lightSources" in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }
    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }
  if ("lights" in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };
    for (const light of opts.lights || []) {
      switch (light.type) {
        case "ambient":
          lightSources.ambientLight = light;
          break;
        case "directional":
          lightSources.directionalLights.push(light);
          break;
        case "point":
          lightSources.pointLights.push(light);
          break;
        default:
      }
    }
    return getUniforms3({
      lightSources
    });
  }
  return {};
}
var INITIAL_MODULE_OPTIONS, lights;
var init_lights = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js"() {
    init_lights_glsl();
    INITIAL_MODULE_OPTIONS = {
      lightSources: {}
    };
    lights = {
      name: "lights",
      vs: lights_glsl_default,
      fs: lights_glsl_default,
      getUniforms: getUniforms3,
      defines: {
        MAX_LIGHTS: 3
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js
function getUniforms4() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS2;
  const uniforms3 = {};
  if (opts.lightDirection) {
    uniforms3.dirlight_uLightDirection = opts.lightDirection;
  }
  return uniforms3;
}
var DEFAULT_LIGHT_DIRECTION, DEFAULT_MODULE_OPTIONS2, vs2, fs5, dirlight;
var init_dirlight = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js"() {
    init_project();
    DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
    DEFAULT_MODULE_OPTIONS2 = {
      lightDirection: DEFAULT_LIGHT_DIRECTION
    };
    vs2 = null;
    fs5 = "uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
    dirlight = {
      name: "dirlight",
      vs: vs2,
      fs: fs5,
      getUniforms: getUniforms4,
      dependencies: [project]
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js
function getUniforms5() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS3;
  const uniforms3 = {};
  if (opts.pickingSelectedColor !== void 0) {
    if (!opts.pickingSelectedColor) {
      uniforms3.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms3.picking_uSelectedColorValid = 1;
      uniforms3.picking_uSelectedColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, (x) => x / 255);
    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }
    uniforms3.picking_uHighlightColor = color;
  }
  if (opts.pickingActive !== void 0) {
    uniforms3.picking_uActive = Boolean(opts.pickingActive);
    uniforms3.picking_uAttribute = Boolean(opts.pickingAttribute);
  }
  return uniforms3;
}
var DEFAULT_HIGHLIGHT_COLOR, DEFAULT_MODULE_OPTIONS3, vs3, fs6, picking;
var init_picking = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js"() {
    DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
    DEFAULT_MODULE_OPTIONS3 = {
      pickingSelectedColor: null,
      pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
      pickingActive: false,
      pickingAttribute: false
    };
    vs3 = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
    fs6 = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
    picking = {
      name: "picking",
      vs: vs3,
      fs: fs6,
      getUniforms: getUniforms5
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js
var phong_lighting_glsl_default;
var init_phong_lighting_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js"() {
    phong_lighting_glsl_default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js
function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map((x) => x / 255)
  };
}
function getUniforms6() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS2;
  if (!("material" in opts)) {
    return {};
  }
  const {
    material
  } = opts;
  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }
  return getMaterialUniforms(material);
}
var INITIAL_MODULE_OPTIONS2, gouraudLighting, phongLighting;
var init_phong_lighting = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js"() {
    init_lights();
    init_phong_lighting_glsl();
    INITIAL_MODULE_OPTIONS2 = {};
    gouraudLighting = {
      name: "gouraud-lighting",
      dependencies: [lights],
      vs: phong_lighting_glsl_default,
      defines: {
        LIGHTING_VERTEX: 1
      },
      getUniforms: getUniforms6
    };
    phongLighting = {
      name: "phong-lighting",
      dependencies: [lights],
      fs: phong_lighting_glsl_default,
      defines: {
        LIGHTING_FRAGMENT: 1
      },
      getUniforms: getUniforms6
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js
var pbr_vertex_glsl_default;
var init_pbr_vertex_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js"() {
    pbr_vertex_glsl_default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js
var pbr_fragment_glsl_default;
var init_pbr_fragment_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js"() {
    pbr_fragment_glsl_default = "#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js
var pbr;
var init_pbr = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js"() {
    init_lights();
    init_pbr_vertex_glsl();
    init_pbr_fragment_glsl();
    pbr = {
      name: "pbr",
      vs: pbr_vertex_glsl_default,
      fs: pbr_fragment_glsl_default,
      defines: {
        LIGHTING_FRAGMENT: 1
      },
      dependencies: [lights]
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js
var init_tiltshift = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js
var init_triangleblur = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js
var init_zoomblur = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js
var init_brightnesscontrast = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js
var init_denoise = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js
var init_huesaturation = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js
var init_noise = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js
var init_sepia = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js
var init_vibrance = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js
var init_vignette = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js
var uniforms;
var init_colorhalftone = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js"() {
    uniforms = {
      center: [0.5, 0.5],
      angle: {
        value: 1.1,
        softMin: 0,
        softMax: Math.PI / 2
      },
      size: {
        value: 4,
        min: 1,
        softMin: 3,
        softMax: 20
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js
var uniforms2;
var init_dotscreen = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js"() {
    uniforms2 = {
      center: [0.5, 0.5],
      angle: {
        value: 1.1,
        softMin: 0,
        softMax: Math.PI / 2
      },
      size: {
        value: 3,
        min: 1,
        softMin: 3,
        softMax: 20
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js
var init_edgework = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js
var init_hexagonalpixelate = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js
var init_ink = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js
var init_magnify = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js
var init_warp = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js
var init_bulgepinch = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js"() {
    init_warp();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js
var init_swirl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js"() {
    init_warp();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js
var init_fxaa = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js
var vs4, transform;
var init_transform = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js"() {
    vs4 = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
    transform = {
      name: "transform",
      vs: vs4,
      fs: null
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/index.js
var init_modules = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/index.js"() {
    init_random();
    init_fp32();
    init_fp64();
    init_project();
    init_lights();
    init_dirlight();
    init_picking();
    init_phong_lighting();
    init_pbr();
    init_tiltshift();
    init_triangleblur();
    init_zoomblur();
    init_brightnesscontrast();
    init_denoise();
    init_huesaturation();
    init_noise();
    init_sepia();
    init_vibrance();
    init_vignette();
    init_colorhalftone();
    init_dotscreen();
    init_edgework();
    init_hexagonalpixelate();
    init_ink();
    init_magnify();
    init_bulgepinch();
    init_swirl();
    init_warp();
    init_fxaa();
    init_transform();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/index.js
var init_esm12 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/index.js"() {
    init_assemble_shaders();
    init_inject_shader();
    init_shader_module();
    init_shader_utils();
    init_modules();
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
var ProgramManager;
var init_program_manager = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js"() {
    init_esm12();
    init_esm10();
    ProgramManager = class {
      static getDefaultProgramManager(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
        return gl.luma.defaultProgramManager;
      }
      constructor(gl) {
        this.gl = gl;
        this._programCache = {};
        this._getUniforms = {};
        this._registeredModules = {};
        this._hookFunctions = [];
        this._defaultModules = [];
        this._hashes = {};
        this._hashCounter = 0;
        this.stateHash = 0;
        this._useCounts = {};
      }
      addDefaultModule(module) {
        if (!this._defaultModules.find((m) => m.name === module.name)) {
          this._defaultModules.push(module);
        }
        this.stateHash++;
      }
      removeDefaultModule(module) {
        const moduleName = typeof module === "string" ? module : module.name;
        this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
        this.stateHash++;
      }
      addShaderHook(hook, opts) {
        if (opts) {
          hook = Object.assign(opts, {
            hook
          });
        }
        this._hookFunctions.push(hook);
        this.stateHash++;
      }
      get() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          vs: vs9 = "",
          fs: fs9 = "",
          defines: defines2 = {},
          inject = {},
          varyings = [],
          bufferMode = 35981,
          transpileToGLSL100 = false
        } = props;
        const modules = this._getModuleList(props.modules);
        const vsHash = this._getHash(vs9);
        const fsHash = this._getHash(fs9);
        const moduleHashes = modules.map((m) => this._getHash(m.name)).sort();
        const varyingHashes = varyings.map((v) => this._getHash(v));
        const defineKeys = Object.keys(defines2).sort();
        const injectKeys = Object.keys(inject).sort();
        const defineHashes = [];
        const injectHashes = [];
        for (const key of defineKeys) {
          defineHashes.push(this._getHash(key));
          defineHashes.push(this._getHash(defines2[key]));
        }
        for (const key of injectKeys) {
          injectHashes.push(this._getHash(key));
          injectHashes.push(this._getHash(inject[key]));
        }
        const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
        if (!this._programCache[hash]) {
          const assembled = assembleShaders(this.gl, {
            vs: vs9,
            fs: fs9,
            modules,
            inject,
            defines: defines2,
            hookFunctions: this._hookFunctions,
            transpileToGLSL100
          });
          this._programCache[hash] = new Program(this.gl, {
            hash,
            vs: assembled.vs,
            fs: assembled.fs,
            varyings,
            bufferMode
          });
          this._getUniforms[hash] = assembled.getUniforms || ((x) => {
          });
          this._useCounts[hash] = 0;
        }
        this._useCounts[hash]++;
        return this._programCache[hash];
      }
      getUniforms(program) {
        return this._getUniforms[program.hash] || null;
      }
      release(program) {
        const hash = program.hash;
        this._useCounts[hash]--;
        if (this._useCounts[hash] === 0) {
          this._programCache[hash].delete();
          delete this._programCache[hash];
          delete this._getUniforms[hash];
          delete this._useCounts[hash];
        }
      }
      _getHash(key) {
        if (this._hashes[key] === void 0) {
          this._hashes[key] = this._hashCounter++;
        }
        return this._hashes[key];
      }
      _getModuleList() {
        let appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        const modules = new Array(this._defaultModules.length + appModules.length);
        const seen = {};
        let count2 = 0;
        for (let i = 0, len2 = this._defaultModules.length; i < len2; ++i) {
          const module = this._defaultModules[i];
          const name = module.name;
          modules[count2++] = module;
          seen[name] = true;
        }
        for (let i = 0, len2 = appModules.length; i < len2; ++i) {
          const module = appModules[i];
          const name = module.name;
          if (!seen[name]) {
            modules[count2++] = module;
            seen[name] = true;
          }
        }
        modules.length = count2;
        return modules;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;
  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);
    if (name === "indices") {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      const accessor = {
        ...attribute
      };
      delete accessor.value;
      buffers[remappedName] = [new Buffer2(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }
  if (indices) {
    const data = indices.value || indices;
    assert6(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
    };
    buffers.indices = [new Buffer2(gl, {
      data,
      target: 34963
    }), accessor];
  }
  return buffers;
}
function mapAttributeName(name, options) {
  const {
    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
  } = options || {};
  return attributeMap && attributeMap[name] || name;
}
function inferAttributeAccessor(attributeName, attribute) {
  let category;
  switch (attributeName) {
    case "texCoords":
    case "texCoord1":
    case "texCoord2":
    case "texCoord3":
      category = "uvs";
      break;
    case "vertices":
    case "positions":
    case "normals":
    case "pickingColors":
      category = "vectors";
      break;
    default:
  }
  switch (category) {
    case "vectors":
      attribute.size = attribute.size || 3;
      break;
    case "uvs":
      attribute.size = attribute.size || 2;
      break;
    default:
  }
  assert6(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}
var GLTF_TO_LUMA_ATTRIBUTE_MAP;
var init_model_utils = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js"() {
    init_esm10();
    GLTF_TO_LUMA_ATTRIBUTE_MAP = {
      POSITION: "positions",
      NORMAL: "normals",
      COLOR_0: "colors",
      TEXCOORD_0: "texCoords",
      TEXCOORD_1: "texCoords1",
      TEXCOORD_2: "texCoords2"
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/model.js
var LOG_DRAW_PRIORITY, LOG_DRAW_TIMEOUT, ERR_MODEL_PARAMS, NOOP2, DRAW_PARAMS, Model;
var init_model = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/model.js"() {
    init_esm9();
    init_program_manager();
    init_esm10();
    init_esm10();
    init_model_utils();
    LOG_DRAW_PRIORITY = 2;
    LOG_DRAW_TIMEOUT = 1e4;
    ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
    NOOP2 = () => {
    };
    DRAW_PARAMS = {};
    Model = class {
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          id = uid("model")
        } = props;
        assert6(isWebGL(gl));
        this.id = id;
        this.gl = gl;
        this.id = props.id || uid("Model");
        this.lastLogTime = 0;
        this.animated = false;
        this.initialize(props);
      }
      initialize(props) {
        this.props = {};
        this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
        this._programManagerState = -1;
        this._managedProgram = false;
        const {
          program = null,
          vs: vs9,
          fs: fs9,
          modules,
          defines: defines2,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = props;
        this.programProps = {
          program,
          vs: vs9,
          fs: fs9,
          modules,
          defines: defines2,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        };
        this.program = null;
        this.vertexArray = null;
        this._programDirty = true;
        this.userData = {};
        this.needsRedraw = true;
        this._attributes = {};
        this.attributes = {};
        this.uniforms = {};
        this.pickable = true;
        this._checkProgram();
        this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
        this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
        this.vertexCount = props.vertexCount || 0;
        this.geometryBuffers = {};
        this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
        this._setModelProps(props);
        this.geometry = {};
        assert6(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
      }
      setProps(props) {
        this._setModelProps(props);
      }
      delete() {
        for (const key in this._attributes) {
          if (this._attributes[key] !== this.attributes[key]) {
            this._attributes[key].delete();
          }
        }
        if (this._managedProgram) {
          this.programManager.release(this.program);
          this._managedProgram = false;
        }
        this.vertexArray.delete();
        this._deleteGeometryBuffers();
      }
      getDrawMode() {
        return this.drawMode;
      }
      getVertexCount() {
        return this.vertexCount;
      }
      getInstanceCount() {
        return this.instanceCount;
      }
      getAttributes() {
        return this.attributes;
      }
      getProgram() {
        return this.program;
      }
      setProgram(props) {
        const {
          program,
          vs: vs9,
          fs: fs9,
          modules,
          defines: defines2,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = props;
        this.programProps = {
          program,
          vs: vs9,
          fs: fs9,
          modules,
          defines: defines2,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        };
        this._programDirty = true;
      }
      getUniforms() {
        return this.uniforms;
      }
      setDrawMode(drawMode) {
        this.drawMode = drawMode;
        return this;
      }
      setVertexCount(vertexCount) {
        assert6(Number.isFinite(vertexCount));
        this.vertexCount = vertexCount;
        return this;
      }
      setInstanceCount(instanceCount) {
        assert6(Number.isFinite(instanceCount));
        this.instanceCount = instanceCount;
        return this;
      }
      setGeometry(geometry) {
        this.drawMode = geometry.drawMode;
        this.vertexCount = geometry.getVertexCount();
        this._deleteGeometryBuffers();
        this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
        this.vertexArray.setAttributes(this.geometryBuffers);
        return this;
      }
      setAttributes() {
        let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (isObjectEmpty2(attributes)) {
          return this;
        }
        const normalizedAttributes = {};
        for (const name in attributes) {
          const attribute = attributes[name];
          normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
        }
        this.vertexArray.setAttributes(normalizedAttributes);
        return this;
      }
      setUniforms() {
        let uniforms3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Object.assign(this.uniforms, uniforms3);
        return this;
      }
      getModuleUniforms(opts) {
        this._checkProgram();
        const getUniforms8 = this.programManager.getUniforms(this.program);
        if (getUniforms8) {
          return getUniforms8(opts);
        }
        return {};
      }
      updateModuleSettings(opts) {
        const uniforms3 = this.getModuleUniforms(opts || {});
        return this.setUniforms(uniforms3);
      }
      clear(opts) {
        clear(this.program.gl, opts);
        return this;
      }
      draw() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._checkProgram();
        const {
          moduleSettings = null,
          framebuffer,
          uniforms: uniforms3 = {},
          attributes = {},
          transformFeedback = this.transformFeedback,
          parameters = {},
          vertexArray = this.vertexArray
        } = opts;
        this.setAttributes(attributes);
        this.updateModuleSettings(moduleSettings);
        this.setUniforms(uniforms3);
        let logPriority;
        if (log2.priority >= LOG_DRAW_PRIORITY) {
          logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
        }
        const drawParams = this.vertexArray.getDrawParams();
        const {
          isIndexed = drawParams.isIndexed,
          indexType = drawParams.indexType,
          indexOffset = drawParams.indexOffset,
          vertexArrayInstanced = drawParams.isInstanced
        } = this.props;
        if (vertexArrayInstanced && !this.isInstanced) {
          log2.warn("Found instanced attributes on non-instanced model", this.id)();
        }
        const {
          isInstanced,
          instanceCount
        } = this;
        const {
          onBeforeRender = NOOP2,
          onAfterRender = NOOP2
        } = this.props;
        onBeforeRender();
        this.program.setUniforms(this.uniforms);
        const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
          logPriority,
          uniforms: null,
          framebuffer,
          parameters,
          drawMode: this.getDrawMode(),
          vertexCount: this.getVertexCount(),
          vertexArray,
          transformFeedback,
          isIndexed,
          indexType,
          isInstanced,
          instanceCount,
          offset: isIndexed ? indexOffset : 0
        }));
        onAfterRender();
        if (log2.priority >= LOG_DRAW_PRIORITY) {
          this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
        }
        return didDraw;
      }
      transform() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          discard = true,
          feedbackBuffers,
          unbindModels = []
        } = opts;
        let {
          parameters
        } = opts;
        if (feedbackBuffers) {
          this._setFeedbackBuffers(feedbackBuffers);
        }
        if (discard) {
          parameters = Object.assign({}, parameters, {
            [35977]: discard
          });
        }
        unbindModels.forEach((model) => model.vertexArray.unbindBuffers());
        try {
          this.draw(Object.assign({}, opts, {
            parameters
          }));
        } finally {
          unbindModels.forEach((model) => model.vertexArray.bindBuffers());
        }
        return this;
      }
      render() {
        let uniforms3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log2.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
        return this.setUniforms(uniforms3).draw();
      }
      _setModelProps(props) {
        Object.assign(this.props, props);
        if ("uniforms" in props) {
          this.setUniforms(props.uniforms);
        }
        if ("pickable" in props) {
          this.pickable = props.pickable;
        }
        if ("instanceCount" in props) {
          this.instanceCount = props.instanceCount;
        }
        if ("geometry" in props) {
          this.setGeometry(props.geometry);
        }
        if ("attributes" in props) {
          this.setAttributes(props.attributes);
        }
        if ("_feedbackBuffers" in props) {
          this._setFeedbackBuffers(props._feedbackBuffers);
        }
      }
      _checkProgram() {
        const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
        if (!needsUpdate) {
          return;
        }
        let {
          program
        } = this.programProps;
        if (program) {
          this._managedProgram = false;
        } else {
          const {
            vs: vs9,
            fs: fs9,
            modules,
            inject,
            defines: defines2,
            varyings,
            bufferMode,
            transpileToGLSL100
          } = this.programProps;
          program = this.programManager.get({
            vs: vs9,
            fs: fs9,
            modules,
            inject,
            defines: defines2,
            varyings,
            bufferMode,
            transpileToGLSL100
          });
          if (this.program && this._managedProgram) {
            this.programManager.release(this.program);
          }
          this._programManagerState = this.programManager.stateHash;
          this._managedProgram = true;
        }
        assert6(program instanceof Program, "Model needs a program");
        this._programDirty = false;
        if (program === this.program) {
          return;
        }
        this.program = program;
        if (this.vertexArray) {
          this.vertexArray.setProps({
            program: this.program,
            attributes: this.vertexArray.attributes
          });
        } else {
          this.vertexArray = new VertexArray(this.gl, {
            program: this.program
          });
        }
        this.setUniforms(Object.assign({}, this.getModuleUniforms()));
      }
      _deleteGeometryBuffers() {
        for (const name in this.geometryBuffers) {
          const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
          if (buffer instanceof Buffer2) {
            buffer.delete();
          }
        }
      }
      _setAnimationProps(animationProps) {
        if (this.animated) {
          assert6(animationProps, "Model.draw(): animated uniforms but no animationProps");
        }
      }
      _setFeedbackBuffers() {
        let feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (isObjectEmpty2(feedbackBuffers)) {
          return this;
        }
        const {
          gl
        } = this.program;
        this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
          program: this.program
        });
        this.transformFeedback.setBuffers(feedbackBuffers);
        return this;
      }
      _logDrawCallStart(logLevel) {
        const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
        if (Date.now() - this.lastLogTime < logDrawTimeout) {
          return void 0;
        }
        this.lastLogTime = Date.now();
        log2.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
          collapsed: log2.level <= 2
        })();
        return logLevel;
      }
      _logDrawCallEnd(logLevel, vertexArray, uniforms3, framebuffer) {
        if (logLevel === void 0) {
          return;
        }
        const attributeTable = getDebugTableForVertexArray({
          vertexArray,
          header: "".concat(this.id, " attributes"),
          attributes: this._attributes
        });
        const {
          table: uniformTable,
          unusedTable,
          unusedCount
        } = getDebugTableForUniforms({
          header: "".concat(this.id, " uniforms"),
          program: this.program,
          uniforms: Object.assign({}, this.program.uniforms, uniforms3)
        });
        const {
          table: missingTable,
          count: missingCount
        } = getDebugTableForUniforms({
          header: "".concat(this.id, " uniforms"),
          program: this.program,
          uniforms: Object.assign({}, this.program.uniforms, uniforms3),
          undefinedOnly: true
        });
        if (missingCount > 0) {
          log2.log("MISSING UNIFORMS", Object.keys(missingTable))();
        }
        if (unusedCount > 0) {
          log2.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
        }
        const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
        log2.table(logLevel, attributeTable)();
        log2.table(logLevel, uniformTable)();
        log2.table(logLevel + 1, configTable)();
        if (framebuffer) {
          framebuffer.log({
            logLevel: LOG_DRAW_PRIORITY,
            message: "Rendered to ".concat(framebuffer.id)
          });
        }
        log2.groupEnd(LOG_DRAW_PRIORITY)();
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js
var BufferTransform;
var init_buffer_transform = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js"() {
    init_esm9();
    init_esm10();
    init_esm10();
    BufferTransform = class {
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.currentIndex = 0;
        this.feedbackMap = {};
        this.varyings = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
      }
      setupResources(opts) {
        for (const binding of this.bindings) {
          this._setupTransformFeedback(binding, opts);
        }
      }
      updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          varyings
        } = this;
        if (varyings.length > 0) {
          props = Object.assign({}, props, {
            varyings
          });
        }
        return props;
      }
      getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const binding = this.bindings[this.currentIndex];
        const {
          sourceBuffers,
          transformFeedback
        } = binding;
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        return {
          attributes,
          transformFeedback
        };
      }
      swap() {
        if (this.feedbackMap) {
          this.currentIndex = this._getNextIndex();
          return true;
        }
        return false;
      }
      update() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupBuffers(opts);
      }
      getBuffer(varyingName) {
        const {
          feedbackBuffers
        } = this.bindings[this.currentIndex];
        const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
        if (!bufferOrParams) {
          return null;
        }
        return bufferOrParams instanceof Buffer2 ? bufferOrParams : bufferOrParams.buffer;
      }
      getData() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          varyingName
        } = options;
        const buffer = this.getBuffer(varyingName);
        if (buffer) {
          return buffer.getData();
        }
        return null;
      }
      delete() {
        for (const name in this.resources) {
          this.resources[name].delete();
        }
      }
      _initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupBuffers(props);
        this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
        if (this.varyings.length > 0) {
          assert6(isWebGL2(this.gl));
        }
      }
      _getFeedbackBuffers(props) {
        const {
          sourceBuffers = {}
        } = props;
        const feedbackBuffers = {};
        if (this.bindings[this.currentIndex]) {
          Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
        }
        if (this.feedbackMap) {
          for (const sourceName in this.feedbackMap) {
            const feedbackName = this.feedbackMap[sourceName];
            if (sourceName in sourceBuffers) {
              feedbackBuffers[feedbackName] = sourceName;
            }
          }
        }
        Object.assign(feedbackBuffers, props.feedbackBuffers);
        for (const bufferName in feedbackBuffers) {
          const bufferOrRef = feedbackBuffers[bufferName];
          if (typeof bufferOrRef === "string") {
            const sourceBuffer = sourceBuffers[bufferOrRef];
            const {
              byteLength,
              usage,
              accessor
            } = sourceBuffer;
            feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
              byteLength,
              usage,
              accessor
            });
          }
        }
        return feedbackBuffers;
      }
      _setupBuffers() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceBuffers = null
        } = props;
        Object.assign(this.feedbackMap, props.feedbackMap);
        const feedbackBuffers = this._getFeedbackBuffers(props);
        this._updateBindings({
          sourceBuffers,
          feedbackBuffers
        });
      }
      _setupTransformFeedback(binding, _ref) {
        let {
          model
        } = _ref;
        const {
          program
        } = model;
        binding.transformFeedback = new TransformFeedback(this.gl, {
          program,
          buffers: binding.feedbackBuffers
        });
      }
      _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this.feedbackMap) {
          const {
            sourceBuffers,
            feedbackBuffers
          } = this._swapBuffers(this.bindings[this.currentIndex]);
          const nextIndex = this._getNextIndex();
          this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
            sourceBuffers,
            feedbackBuffers
          });
        }
      }
      _updateBinding(binding, opts) {
        if (!binding) {
          return {
            sourceBuffers: Object.assign({}, opts.sourceBuffers),
            feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
          };
        }
        Object.assign(binding.sourceBuffers, opts.sourceBuffers);
        Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
        if (binding.transformFeedback) {
          binding.transformFeedback.setBuffers(binding.feedbackBuffers);
        }
        return binding;
      }
      _swapBuffers(opts) {
        if (!this.feedbackMap) {
          return null;
        }
        const sourceBuffers = Object.assign({}, opts.sourceBuffers);
        const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
        for (const srcName in this.feedbackMap) {
          const dstName = this.feedbackMap[srcName];
          sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
          feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
          assert6(feedbackBuffers[dstName] instanceof Buffer2);
        }
        return {
          sourceBuffers,
          feedbackBuffers
        };
      }
      _createNewBuffer(name, opts) {
        const buffer = new Buffer2(this.gl, opts);
        if (this.resources[name]) {
          this.resources[name].delete();
        }
        this.resources[name] = buffer;
        return buffer;
      }
      _getNextIndex() {
        return (this.currentIndex + 1) % 2;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js
function updateForTextures(_ref) {
  let {
    vs: vs9,
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref;
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs9;
  let finalInject = {};
  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split("\n");
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);
        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = combineInjects([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }
      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });
    if (targetTextureVarying) {
      assert6(targetTexture);
      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      const inject = {
        "vs:#decl": uniformDeclaration,
        "vs:#main-start": posInstructions
      };
      finalInject = combineInjects([finalInject, inject]);
    }
    updatedVs = updateVsLines.join("\n");
  }
  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}
function getSizeUniforms(_ref2) {
  let {
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref2;
  const uniforms3 = {};
  let width;
  let height;
  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms3["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }
  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms3["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }
  return uniforms3;
}
function getAttributeDefinition(line) {
  return getQualifierDetails(line, ["attribute", "in"]);
}
function getSamplerDeclerations(textureName) {
  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}
function getVaryingType(line, varying) {
  const qualaiferDetails = getQualifierDetails(line, ["varying", "out"]);
  if (!qualaiferDetails) {
    return null;
  }
  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);
  if (!attributeData) {
    return null;
  }
  const {
    type,
    name
  } = attributeData;
  if (name && textureMap[name]) {
    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = typeToChannelSuffix(type);
    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    const inject = {
      "vs:#decl": uniformDeclerations,
      "vs:#main-start": sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }
  return null;
}
var SAMPLER_UNIFORM_PREFIX, SIZE_UNIFORM_PREFIX, VS_POS_VARIABLE;
var init_transform_shader_utils = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js"() {
    init_esm10();
    init_esm12();
    SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
    SIZE_UNIFORM_PREFIX = "transform_uSize_";
    VS_POS_VARIABLE = "transform_position";
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js
var SRC_TEX_PARAMETER_OVERRIDES, FS_OUTPUT_VARIABLE, TextureTransform;
var init_texture_transform = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js"() {
    init_esm10();
    init_esm12();
    init_transform_shader_utils();
    SRC_TEX_PARAMETER_OVERRIDES = {
      [10241]: 9728,
      [10240]: 9728,
      [10242]: 33071,
      [10243]: 33071
    };
    FS_OUTPUT_VARIABLE = "transform_output";
    TextureTransform = class {
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.id = this.currentIndex = 0;
        this._swapTexture = null;
        this.targetTextureVarying = null;
        this.targetTextureType = null;
        this.samplerTextureMap = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
      }
      updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const updatedModelProps = this._processVertexShader(props);
        return Object.assign({}, props, updatedModelProps);
      }
      getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceBuffers,
          sourceTextures,
          framebuffer,
          targetTexture
        } = this.bindings[this.currentIndex];
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        const uniforms3 = Object.assign({}, opts.uniforms);
        const parameters = Object.assign({}, opts.parameters);
        let discard = opts.discard;
        if (this.hasSourceTextures || this.hasTargetTexture) {
          attributes.transform_elementID = this.elementIDBuffer;
          for (const sampler in this.samplerTextureMap) {
            const textureName = this.samplerTextureMap[sampler];
            uniforms3[sampler] = sourceTextures[textureName];
          }
          this._setSourceTextureParameters();
          const sizeUniforms = getSizeUniforms({
            sourceTextureMap: sourceTextures,
            targetTextureVarying: this.targetTextureVarying,
            targetTexture
          });
          Object.assign(uniforms3, sizeUniforms);
        }
        if (this.hasTargetTexture) {
          discard = false;
          parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
        }
        return {
          attributes,
          framebuffer,
          uniforms: uniforms3,
          discard,
          parameters
        };
      }
      swap() {
        if (this._swapTexture) {
          this.currentIndex = this._getNextIndex();
          return true;
        }
        return false;
      }
      update() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupTextures(opts);
      }
      getTargetTexture() {
        const {
          targetTexture
        } = this.bindings[this.currentIndex];
        return targetTexture;
      }
      getData() {
        let {
          packed = false
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          framebuffer
        } = this.bindings[this.currentIndex];
        const pixels = readPixelsToArray(framebuffer);
        if (!packed) {
          return pixels;
        }
        const ArrayType = pixels.constructor;
        const channelCount = typeToChannelCount(this.targetTextureType);
        const packedPixels = new ArrayType(pixels.length * channelCount / 4);
        let packCount = 0;
        for (let i = 0; i < pixels.length; i += 4) {
          for (let j = 0; j < channelCount; j++) {
            packedPixels[packCount++] = pixels[i + j];
          }
        }
        return packedPixels;
      }
      getFramebuffer() {
        const currentResources = this.bindings[this.currentIndex];
        return currentResources.framebuffer;
      }
      delete() {
        if (this.ownTexture) {
          this.ownTexture.delete();
        }
        if (this.elementIDBuffer) {
          this.elementIDBuffer.delete();
        }
      }
      _initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          _targetTextureVarying,
          _swapTexture
        } = props;
        this._swapTexture = _swapTexture;
        this.targetTextureVarying = _targetTextureVarying;
        this.hasTargetTexture = _targetTextureVarying;
        this._setupTextures(props);
      }
      _createTargetTexture(props) {
        const {
          sourceTextures,
          textureOrReference
        } = props;
        if (textureOrReference instanceof Texture2D) {
          return textureOrReference;
        }
        const refTexture = sourceTextures[textureOrReference];
        if (!refTexture) {
          return null;
        }
        this._targetRefTexName = textureOrReference;
        return this._createNewTexture(refTexture);
      }
      _setupTextures() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceBuffers,
          _sourceTextures = {},
          _targetTexture
        } = props;
        const targetTexture = this._createTargetTexture({
          sourceTextures: _sourceTextures,
          textureOrReference: _targetTexture
        });
        this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
        this._updateBindings({
          sourceBuffers,
          sourceTextures: _sourceTextures,
          targetTexture
        });
        if ("elementCount" in props) {
          this._updateElementIDBuffer(props.elementCount);
        }
      }
      _updateElementIDBuffer(elementCount) {
        if (typeof elementCount !== "number" || this.elementCount >= elementCount) {
          return;
        }
        const elementIds = new Float32Array(elementCount);
        elementIds.forEach((_, index, array) => {
          array[index] = index;
        });
        if (!this.elementIDBuffer) {
          this.elementIDBuffer = new Buffer2(this.gl, {
            data: elementIds,
            accessor: {
              size: 1
            }
          });
        } else {
          this.elementIDBuffer.setData({
            data: elementIds
          });
        }
        this.elementCount = elementCount;
      }
      _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this._swapTexture) {
          const {
            sourceTextures,
            targetTexture
          } = this._swapTextures(this.bindings[this.currentIndex]);
          const nextIndex = this._getNextIndex();
          this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
            sourceTextures,
            targetTexture
          });
        }
      }
      _updateBinding(binding, opts) {
        const {
          sourceBuffers,
          sourceTextures,
          targetTexture
        } = opts;
        if (!binding) {
          binding = {
            sourceBuffers: {},
            sourceTextures: {},
            targetTexture: null
          };
        }
        Object.assign(binding.sourceTextures, sourceTextures);
        Object.assign(binding.sourceBuffers, sourceBuffers);
        if (targetTexture) {
          binding.targetTexture = targetTexture;
          const {
            width,
            height
          } = targetTexture;
          const {
            framebuffer
          } = binding;
          if (framebuffer) {
            framebuffer.update({
              attachments: {
                [36064]: targetTexture
              },
              resizeAttachments: false
            });
            framebuffer.resize({
              width,
              height
            });
          } else {
            binding.framebuffer = new Framebuffer(this.gl, {
              id: "transform-framebuffer",
              width,
              height,
              attachments: {
                [36064]: targetTexture
              }
            });
          }
        }
        return binding;
      }
      _setSourceTextureParameters() {
        const index = this.currentIndex;
        const {
          sourceTextures
        } = this.bindings[index];
        for (const name in sourceTextures) {
          sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
        }
      }
      _swapTextures(opts) {
        if (!this._swapTexture) {
          return null;
        }
        const sourceTextures = Object.assign({}, opts.sourceTextures);
        sourceTextures[this._swapTexture] = opts.targetTexture;
        const targetTexture = opts.sourceTextures[this._swapTexture];
        return {
          sourceTextures,
          targetTexture
        };
      }
      _createNewTexture(refTexture) {
        const texture = cloneTextureFrom(refTexture, {
          parameters: {
            [10241]: 9728,
            [10240]: 9728,
            [10242]: 33071,
            [10243]: 33071
          },
          pixelStore: {
            [37440]: false
          }
        });
        if (this.ownTexture) {
          this.ownTexture.delete();
        }
        this.ownTexture = texture;
        return texture;
      }
      _getNextIndex() {
        return (this.currentIndex + 1) % 2;
      }
      _processVertexShader() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceTextures,
          targetTexture
        } = this.bindings[this.currentIndex];
        const {
          vs: vs9,
          uniforms: uniforms3,
          targetTextureType,
          inject,
          samplerTextureMap
        } = updateForTextures({
          vs: props.vs,
          sourceTextureMap: sourceTextures,
          targetTextureVarying: this.targetTextureVarying,
          targetTexture
        });
        const combinedInject = combineInjects([props.inject || {}, inject]);
        this.targetTextureType = targetTextureType;
        this.samplerTextureMap = samplerTextureMap;
        const fs9 = props._fs || getPassthroughFS({
          version: getShaderVersion(vs9),
          input: this.targetTextureVarying,
          inputType: targetTextureType,
          output: FS_OUTPUT_VARIABLE
        });
        const modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;
        return {
          vs: vs9,
          fs: fs9,
          modules,
          uniforms: uniforms3,
          inject: combinedInject
        };
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/transform.js
function canCreateBufferTransform(props) {
  if (!isObjectEmpty2(props.feedbackBuffers) || !isObjectEmpty2(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }
  return false;
}
function canCreateTextureTransform(props) {
  if (!isObjectEmpty2(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }
  return false;
}
var Transform2;
var init_transform2 = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/transform.js"() {
    init_esm12();
    init_buffer_transform();
    init_texture_transform();
    init_esm9();
    init_esm10();
    init_model();
    Transform2 = class {
      static isSupported(gl) {
        return isWebGL2(gl);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.model = null;
        this.elementCount = 0;
        this.bufferTransform = null;
        this.textureTransform = null;
        this.elementIDBuffer = null;
        this._initialize(props);
        Object.seal(this);
      }
      delete() {
        const {
          model,
          bufferTransform,
          textureTransform
        } = this;
        if (model) {
          model.delete();
        }
        if (bufferTransform) {
          bufferTransform.delete();
        }
        if (textureTransform) {
          textureTransform.delete();
        }
      }
      run() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          clearRenderTarget = true
        } = opts;
        const updatedOpts = this._updateDrawOptions(opts);
        if (clearRenderTarget && updatedOpts.framebuffer) {
          updatedOpts.framebuffer.clear({
            color: true
          });
        }
        this.model.transform(updatedOpts);
      }
      swap() {
        let swapped = false;
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          swapped = swapped || resourceTransform.swap();
        }
        assert6(swapped, "Nothing to swap");
      }
      getBuffer() {
        let varyingName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
      }
      getData() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          const data = resourceTransform.getData(opts);
          if (data) {
            return data;
          }
        }
        return null;
      }
      getFramebuffer() {
        return this.textureTransform && this.textureTransform.getFramebuffer();
      }
      update() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if ("elementCount" in opts) {
          this.model.setVertexCount(opts.elementCount);
        }
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          resourceTransform.update(opts);
        }
      }
      _initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          gl
        } = this;
        this._buildResourceTransforms(gl, props);
        props = this._updateModelProps(props);
        this.model = new Model(gl, Object.assign({}, props, {
          fs: props.fs || getPassthroughFS({
            version: getShaderVersion(props.vs)
          }),
          id: props.id || "transform-model",
          drawMode: props.drawMode || 0,
          vertexCount: props.elementCount
        }));
        this.bufferTransform && this.bufferTransform.setupResources({
          model: this.model
        });
      }
      _updateModelProps(props) {
        let updatedProps = Object.assign({}, props);
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          updatedProps = resourceTransform.updateModelProps(updatedProps);
        }
        return updatedProps;
      }
      _buildResourceTransforms(gl, props) {
        if (canCreateBufferTransform(props)) {
          this.bufferTransform = new BufferTransform(gl, props);
        }
        if (canCreateTextureTransform(props)) {
          this.textureTransform = new TextureTransform(gl, props);
        }
        assert6(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
      }
      _updateDrawOptions(opts) {
        let updatedOpts = Object.assign({}, opts);
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
        }
        return updatedOpts;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js
var DRAW_MODE, Geometry;
var init_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js"() {
    init_esm10();
    DRAW_MODE = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };
    Geometry = class {
      static get DRAW_MODE() {
        return DRAW_MODE;
      }
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("geometry"),
          drawMode = DRAW_MODE.TRIANGLES,
          attributes = {},
          indices = null,
          vertexCount = null
        } = props;
        this.id = id;
        this.drawMode = drawMode | 0;
        this.attributes = {};
        this.userData = {};
        this._setAttributes(attributes, indices);
        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
      }
      get mode() {
        return this.drawMode;
      }
      getVertexCount() {
        return this.vertexCount;
      }
      getAttributes() {
        return this.indices ? {
          indices: this.indices,
          ...this.attributes
        } : this.attributes;
      }
      _print(attributeName) {
        return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
      }
      _setAttributes(attributes, indices) {
        if (indices) {
          this.indices = ArrayBuffer.isView(indices) ? {
            value: indices,
            size: 1
          } : indices;
        }
        for (const attributeName in attributes) {
          let attribute = attributes[attributeName];
          attribute = ArrayBuffer.isView(attribute) ? {
            value: attribute
          } : attribute;
          assert6(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
          if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
            attribute.size = 3;
          }
          if (attributeName === "indices") {
            assert6(!this.indices);
            this.indices = attribute;
          } else {
            this.attributes[attributeName] = attribute;
          }
        }
        if (this.indices && this.indices.isIndexed !== void 0) {
          this.indices = Object.assign({}, this.indices);
          delete this.indices.isIndexed;
        }
        return this;
      }
      _calculateVertexCount(attributes, indices) {
        if (indices) {
          return indices.value.length;
        }
        let vertexCount = Infinity;
        for (const attributeName in attributes) {
          const attribute = attributes[attributeName];
          const {
            value,
            size,
            constant
          } = attribute;
          if (!constant && value && size >= 1) {
            vertexCount = Math.min(vertexCount, value.length / size);
          }
        }
        assert6(Number.isFinite(vertexCount));
        return vertexCount;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js
function tesselateTruncatedCone(props) {
  const {
    bottomRadius = 0,
    topRadius = 0,
    height = 1,
    nradial = 10,
    nvertical = 10,
    verticalAxis = "y",
    topCap = false,
    bottomCap = false
  } = props;
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (nradial + 1) * (nvertical + 1 + extra);
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const msin = Math.sin;
  const mcos = Math.cos;
  const mpi = Math.PI;
  const cosSlant = mcos(slant);
  const sinSlant = msin(slant);
  const start = topCap ? -2 : 0;
  const end = nvertical + (bottomCap ? 2 : 0);
  const vertsAroundEdge = nradial + 1;
  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  const indexOffset = INDEX_OFFSETS[verticalAxis];
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  let i3 = 0;
  let i2 = 0;
  for (let i = start; i <= end; i++) {
    let v = i / nvertical;
    let y = height * v;
    let ringRadius;
    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }
    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let j = 0; j < vertsAroundEdge; j++) {
      const sin2 = msin(j * mpi * 2 / nradial);
      const cos2 = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin2 * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos2 * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin2 * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos2 * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }
  for (let i = 0; i < nvertical + extra; i++) {
    for (let j = 0; j < nradial; j++) {
      const index = (i * nradial + j) * 6;
      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;
      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
var INDEX_OFFSETS, TruncatedConeGeometry;
var init_truncated_cone_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js"() {
    init_geometry();
    init_esm10();
    INDEX_OFFSETS = {
      x: [2, 0, 1],
      y: [0, 1, 2],
      z: [1, 2, 0]
    };
    TruncatedConeGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("truncated-code-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselateTruncatedCone(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js
var ConeGeometry;
var init_cone_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js"() {
    init_truncated_cone_geometry();
    init_esm10();
    ConeGeometry = class extends TruncatedConeGeometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("cone-geometry"),
          radius = 1,
          cap = true
        } = props;
        super({
          ...props,
          id,
          topRadius: 0,
          topCap: Boolean(cap),
          bottomCap: Boolean(cap),
          bottomRadius: radius
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js
var CUBE_INDICES, CUBE_POSITIONS, CUBE_NORMALS, CUBE_TEX_COORDS, ATTRIBUTES, CubeGeometry;
var init_cube_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js"() {
    init_geometry();
    init_esm10();
    CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
    CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
    CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
    CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
    ATTRIBUTES = {
      POSITION: {
        size: 3,
        value: new Float32Array(CUBE_POSITIONS)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(CUBE_NORMALS)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(CUBE_TEX_COORDS)
      }
    };
    CubeGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("cube-geometry")
        } = props;
        super({
          ...props,
          id,
          indices: {
            size: 1,
            value: new Uint16Array(CUBE_INDICES)
          },
          attributes: {
            ...ATTRIBUTES,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js
var CylinderGeometry;
var init_cylinder_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js"() {
    init_truncated_cone_geometry();
    init_esm10();
    CylinderGeometry = class extends TruncatedConeGeometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("cylinder-geometry"),
          radius = 1
        } = props;
        super({
          ...props,
          id,
          bottomRadius: radius,
          topRadius: radius
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js
function tesselateIcosaHedron(props) {
  const {
    iterations = 0
  } = props;
  const PI = Math.PI;
  const PI2 = PI * 2;
  const positions = [...ICO_POSITIONS];
  let indices = [...ICO_INDICES];
  positions.push();
  indices.push();
  const getMiddlePoint = (() => {
    const pointMemo = {};
    return (i1, i2) => {
      i1 *= 3;
      i2 *= 3;
      const mini = i1 < i2 ? i1 : i2;
      const maxi = i1 > i2 ? i1 : i2;
      const key = "".concat(mini, "|").concat(maxi);
      if (key in pointMemo) {
        return pointMemo[key];
      }
      const x1 = positions[i1];
      const y1 = positions[i1 + 1];
      const z1 = positions[i1 + 2];
      const x2 = positions[i2];
      const y2 = positions[i2 + 1];
      const z2 = positions[i2 + 2];
      let xm = (x1 + x2) / 2;
      let ym = (y1 + y2) / 2;
      let zm = (z1 + z2) / 2;
      const len2 = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len2;
      ym /= len2;
      zm /= len2;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  })();
  for (let i = 0; i < iterations; i++) {
    const indices2 = [];
    for (let j = 0; j < indices.length; j += 3) {
      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }
    indices = indices2;
  }
  const normals = new Array(positions.length);
  const texCoords = new Array(positions.length / 3 * 2);
  const l = indices.length;
  for (let i = l - 3; i >= 0; i -= 3) {
    const i1 = indices[i + 0];
    const i2 = indices[i + 1];
    const i3 = indices[i + 2];
    const in1 = i1 * 3;
    const in2 = i2 * 3;
    const in3 = i3 * 3;
    const iu1 = i1 * 2;
    const iu2 = i2 * 2;
    const iu3 = i3 * 2;
    const x1 = positions[in1 + 0];
    const y1 = positions[in1 + 1];
    const z1 = positions[in1 + 2];
    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    const phi1 = Math.atan2(y1, x1) + PI;
    const v1 = theta1 / PI;
    const u1 = 1 - phi1 / PI2;
    const x2 = positions[in2 + 0];
    const y2 = positions[in2 + 1];
    const z2 = positions[in2 + 2];
    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    const phi2 = Math.atan2(y2, x2) + PI;
    const v2 = theta2 / PI;
    const u2 = 1 - phi2 / PI2;
    const x3 = positions[in3 + 0];
    const y3 = positions[in3 + 1];
    const z3 = positions[in3 + 2];
    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    const phi3 = Math.atan2(y3, x3) + PI;
    const v3 = theta3 / PI;
    const u3 = 1 - phi3 / PI2;
    const vec1 = [x3 - x2, y3 - y2, z3 - z2];
    const vec2 = [x1 - x2, y1 - y2, z1 - z2];
    const normal = new Vector3(vec1).cross(vec2).normalize();
    let newIndex;
    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }
    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }
  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}
var ICO_POSITIONS, ICO_INDICES, IcoSphereGeometry;
var init_ico_sphere_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js"() {
    init_esm11();
    init_geometry();
    init_esm10();
    ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
    ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];
    IcoSphereGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("ico-sphere-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselateIcosaHedron(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js
function unpackIndexedGeometry(geometry) {
  const {
    indices,
    attributes
  } = geometry;
  if (!indices) {
    return geometry;
  }
  const vertexCount = indices.value.length;
  const unpackedAttributes = {};
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const {
      constant,
      value,
      size
    } = attribute;
    if (constant || !size) {
      continue;
    }
    const unpackedValue = new value.constructor(vertexCount * size);
    for (let x = 0; x < vertexCount; ++x) {
      const index = indices.value[x];
      for (let i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value[index * size + i];
      }
    }
    unpackedAttributes[attributeName] = {
      size,
      value: unpackedValue
    };
  }
  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}
var init_geometry_utils = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js"() {
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js
function tesselatePlane(props) {
  const {
    type = "x,y",
    offset = 0,
    flipCull = false,
    unpack = false
  } = props;
  const coords = type.split(",");
  let c1len = props["".concat(coords[0], "len")] || 1;
  const c2len = props["".concat(coords[1], "len")] || 1;
  const subdivisions1 = props["n".concat(coords[0])] || 1;
  const subdivisions2 = props["n".concat(coords[1])] || 1;
  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  if (flipCull) {
    c1len = -c1len;
  }
  let i2 = 0;
  let i3 = 0;
  for (let z = 0; z <= subdivisions2; z++) {
    for (let x = 0; x <= subdivisions1; x++) {
      const u = x / subdivisions1;
      const v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;
      switch (type) {
        case "x,y":
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;
        case "x,z":
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;
        case "y,z":
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;
        default:
          throw new Error("PlaneGeometry: unknown type");
      }
      i2 += 2;
      i3 += 3;
    }
  }
  const numVertsAcross = subdivisions1 + 1;
  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);
  for (let z = 0; z < subdivisions2; z++) {
    for (let x = 0; x < subdivisions1; x++) {
      const index = (z * subdivisions1 + x) * 6;
      indices[index + 0] = (z + 0) * numVertsAcross + x;
      indices[index + 1] = (z + 1) * numVertsAcross + x;
      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;
      indices[index + 3] = (z + 1) * numVertsAcross + x;
      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;
      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;
    }
  }
  const geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? unpackIndexedGeometry(geometry) : geometry;
}
var PlaneGeometry;
var init_plane_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js"() {
    init_geometry();
    init_geometry_utils();
    init_esm10();
    PlaneGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("plane-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselatePlane(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js
function tesselateSphere(props) {
  const {
    nlat = 10,
    nlong = 10
  } = props;
  let {
    radius = 1
  } = props;
  const startLat = 0;
  const endLat = Math.PI;
  const latRange = endLat - startLat;
  const startLong = 0;
  const endLong = 2 * Math.PI;
  const longRange = endLong - startLong;
  const numVertices = (nlat + 1) * (nlong + 1);
  if (typeof radius === "number") {
    const value = radius;
    radius = (n1, n2, n3, u, v) => value;
  }
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  const IndexType = numVertices > 65535 ? Uint32Array : Uint16Array;
  const indices = new IndexType(nlat * nlong * 6);
  for (let y = 0; y <= nlat; y++) {
    for (let x = 0; x <= nlong; x++) {
      const u = x / nlong;
      const v = y / nlat;
      const index = x + y * (nlong + 1);
      const i2 = index * 2;
      const i3 = index * 3;
      const theta = longRange * u;
      const phi = latRange * v;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      const r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }
  const numVertsAround = nlong + 1;
  for (let x = 0; x < nlong; x++) {
    for (let y = 0; y < nlat; y++) {
      const index = (x * nlat + y) * 6;
      indices[index + 0] = y * numVertsAround + x;
      indices[index + 1] = y * numVertsAround + x + 1;
      indices[index + 2] = (y + 1) * numVertsAround + x;
      indices[index + 3] = (y + 1) * numVertsAround + x;
      indices[index + 4] = y * numVertsAround + x + 1;
      indices[index + 5] = (y + 1) * numVertsAround + x + 1;
    }
  }
  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
var SphereGeometry;
var init_sphere_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js"() {
    init_geometry();
    init_esm10();
    SphereGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("sphere-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselateSphere(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/animation/timeline.js
var channelHandles, animationHandles, Timeline;
var init_timeline = __esm({
  "node_modules/@luma.gl/engine/dist/esm/animation/timeline.js"() {
    channelHandles = 1;
    animationHandles = 1;
    Timeline = class {
      constructor() {
        this.time = 0;
        this.channels = /* @__PURE__ */ new Map();
        this.animations = /* @__PURE__ */ new Map();
        this.playing = false;
        this.lastEngineTime = -1;
      }
      addChannel(props) {
        const {
          delay = 0,
          duration = Number.POSITIVE_INFINITY,
          rate = 1,
          repeat = 1
        } = props;
        const handle = channelHandles++;
        const channel = {
          time: 0,
          delay,
          duration,
          rate,
          repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(handle, channel);
        return handle;
      }
      removeChannel(handle) {
        this.channels.delete(handle);
        for (const [animationHandle, animation] of this.animations) {
          if (animation.channel === handle) {
            this.detachAnimation(animationHandle);
          }
        }
      }
      isFinished(handle) {
        const channel = this.channels.get(handle);
        if (channel === void 0) {
          return false;
        }
        return this.time >= channel.delay + channel.duration * channel.repeat;
      }
      getTime(handle) {
        if (handle === void 0) {
          return this.time;
        }
        const channel = this.channels.get(handle);
        if (channel === void 0) {
          return -1;
        }
        return channel.time;
      }
      setTime(time) {
        this.time = Math.max(0, time);
        const channels = this.channels.values();
        for (const channel of channels) {
          this._setChannelTime(channel, this.time);
        }
        const animations = this.animations.values();
        for (const animationData of animations) {
          const {
            animation,
            channel
          } = animationData;
          animation.setTime(this.getTime(channel));
        }
      }
      play() {
        this.playing = true;
      }
      pause() {
        this.playing = false;
        this.lastEngineTime = -1;
      }
      reset() {
        this.setTime(0);
      }
      attachAnimation(animation, channelHandle) {
        const animationHandle = animationHandles++;
        this.animations.set(animationHandle, {
          animation,
          channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
      }
      detachAnimation(handle) {
        this.animations.delete(handle);
      }
      update(engineTime) {
        if (this.playing) {
          if (this.lastEngineTime === -1) {
            this.lastEngineTime = engineTime;
          }
          this.setTime(this.time + (engineTime - this.lastEngineTime));
          this.lastEngineTime = engineTime;
        }
      }
      _setChannelTime(channel, time) {
        const offsetTime = time - channel.delay;
        const totalDuration = channel.duration * channel.repeat;
        if (offsetTime >= totalDuration) {
          channel.time = channel.duration * channel.rate;
        } else {
          channel.time = Math.max(0, offsetTime) % channel.duration;
          channel.time *= channel.rate;
        }
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js
var init_key_frames = __esm({
  "node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js"() {
  }
});

// node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js
var CLIPSPACE_VERTEX_SHADER, POSITIONS, ClipSpace;
var init_clip_space = __esm({
  "node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js"() {
    init_model();
    init_geometry();
    CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
    POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
    ClipSpace = class extends Model {
      constructor(gl, opts) {
        const TEX_COORDS = POSITIONS.map((coord) => coord === -1 ? 0 : coord);
        super(gl, Object.assign({}, opts, {
          vs: CLIPSPACE_VERTEX_SHADER,
          geometry: new Geometry({
            drawMode: 5,
            vertexCount: 4,
            attributes: {
              aClipSpacePosition: {
                size: 2,
                value: new Float32Array(POSITIONS)
              },
              aTexCoord: {
                size: 2,
                value: new Float32Array(TEX_COORDS)
              },
              aCoordinate: {
                size: 2,
                value: new Float32Array(TEX_COORDS)
              }
            }
          })
        }));
        this.setVertexCount(4);
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/index.js
var init_esm13 = __esm({
  "node_modules/@luma.gl/engine/dist/esm/index.js"() {
    init_animation_loop();
    init_model();
    init_program_manager();
    init_transform2();
    init_geometry();
    init_cone_geometry();
    init_cube_geometry();
    init_cylinder_geometry();
    init_ico_sphere_geometry();
    init_plane_geometry();
    init_sphere_geometry();
    init_truncated_cone_geometry();
    init_timeline();
    init_key_frames();
    init_clip_space();
  }
});

// node_modules/@luma.gl/core/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AnimationLoop: () => AnimationLoop,
  Buffer: () => Buffer2,
  ClipSpace: () => ClipSpace,
  ConeGeometry: () => ConeGeometry,
  CubeGeometry: () => CubeGeometry,
  CylinderGeometry: () => CylinderGeometry,
  FEATURES: () => FEATURES,
  FragmentShader: () => FragmentShader,
  Framebuffer: () => Framebuffer,
  Geometry: () => Geometry,
  IcoSphereGeometry: () => IcoSphereGeometry,
  Model: () => Model,
  PlaneGeometry: () => PlaneGeometry,
  Program: () => Program,
  ProgramManager: () => ProgramManager,
  Renderbuffer: () => Renderbuffer,
  SphereGeometry: () => SphereGeometry,
  Texture2D: () => Texture2D,
  Texture3D: () => Texture3D,
  TextureCube: () => TextureCube,
  Timeline: () => Timeline,
  Transform: () => Transform2,
  TransformFeedback: () => TransformFeedback,
  TruncatedConeGeometry: () => TruncatedConeGeometry,
  VertexShader: () => VertexShader,
  assert: () => assert6,
  clear: () => clear,
  cloneTextureFrom: () => cloneTextureFrom,
  copyToTexture: () => copyToTexture,
  createGLContext: () => createGLContext,
  cssToDevicePixels: () => cssToDevicePixels,
  cssToDeviceRatio: () => cssToDeviceRatio,
  dirlight: () => dirlight,
  fp32: () => fp32,
  fp64: () => fp64,
  getParameters: () => getParameters,
  gouraudLighting: () => gouraudLighting,
  hasFeature: () => hasFeature,
  hasFeatures: () => hasFeatures,
  instrumentGLContext: () => instrumentGLContext,
  isWebGL: () => isWebGL,
  isWebGL2: () => isWebGL2,
  log: () => log2,
  lumaStats: () => lumaStats,
  normalizeShaderModule: () => normalizeShaderModule,
  pbr: () => pbr,
  phongLighting: () => phongLighting,
  picking: () => picking,
  project: () => project,
  readPixelsToArray: () => readPixelsToArray,
  readPixelsToBuffer: () => readPixelsToBuffer,
  resetParameters: () => resetParameters,
  setParameters: () => setParameters,
  uid: () => uid,
  withParameters: () => withParameters
});
var init_esm14 = __esm({
  "node_modules/@luma.gl/core/dist/esm/index.js"() {
    init_esm9();
    init_esm10();
    init_esm13();
    init_esm12();
    init_esm10();
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js
var DEFAULT_LIGHT_COLOR, DEFAULT_LIGHT_INTENSITY, idCount, AmbientLight;
var init_ambient_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js"() {
    init_defineProperty();
    DEFAULT_LIGHT_COLOR = [255, 255, 255];
    DEFAULT_LIGHT_INTENSITY = 1;
    idCount = 0;
    AmbientLight = class {
      constructor(props = {}) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "color", void 0);
        _defineProperty(this, "intensity", void 0);
        _defineProperty(this, "type", "ambient");
        const {
          color = DEFAULT_LIGHT_COLOR
        } = props;
        const {
          intensity = DEFAULT_LIGHT_INTENSITY
        } = props;
        this.id = props.id || "ambient-".concat(idCount++);
        this.color = color;
        this.intensity = intensity;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js
var DEFAULT_LIGHT_COLOR2, DEFAULT_LIGHT_INTENSITY2, DEFAULT_LIGHT_DIRECTION2, idCount2, DirectionalLight;
var init_directional_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js"() {
    init_defineProperty();
    init_esm11();
    DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
    DEFAULT_LIGHT_INTENSITY2 = 1;
    DEFAULT_LIGHT_DIRECTION2 = [0, 0, -1];
    idCount2 = 0;
    DirectionalLight = class {
      constructor(props = {}) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "color", void 0);
        _defineProperty(this, "intensity", void 0);
        _defineProperty(this, "type", "directional");
        _defineProperty(this, "direction", void 0);
        _defineProperty(this, "shadow", void 0);
        const {
          color = DEFAULT_LIGHT_COLOR2
        } = props;
        const {
          intensity = DEFAULT_LIGHT_INTENSITY2
        } = props;
        const {
          direction = DEFAULT_LIGHT_DIRECTION2
        } = props;
        const {
          _shadow = false
        } = props;
        this.id = props.id || "directional-".concat(idCount2++);
        this.color = color;
        this.intensity = intensity;
        this.type = "directional";
        this.direction = new Vector3(direction).normalize().toArray();
        this.shadow = _shadow;
      }
      getProjectedLight(opts) {
        return this;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/pass.js
var Pass;
var init_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/pass.js"() {
    init_defineProperty();
    Pass = class {
      constructor(gl, props = {
        id: "pass"
      }) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "props", void 0);
        const {
          id
        } = props;
        this.id = id;
        this.gl = gl;
        this.props = {
          ...props
        };
      }
      setProps(props) {
        Object.assign(this.props, props);
      }
      render(params) {
      }
      cleanup() {
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};
  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;
    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }
    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }
    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }
    layerIndices[layerId] = index;
    return index;
  };
  return resolveLayerIndex;
}
function getGLViewport(gl, {
  moduleParameters,
  target,
  viewport
}) {
  const useTarget = target && target.id !== "default-framebuffer";
  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || cssToDeviceRatio(gl);
  const height = useTarget ? target.height : gl.drawingBufferHeight;
  const dimensions = viewport;
  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}
function clearGLCanvas(gl, targetFramebuffer) {
  const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
  const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
  setParameters(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}
var LayersPass;
var init_layers_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js"() {
    init_defineProperty();
    init_pass();
    init_esm14();
    LayersPass = class extends Pass {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "_lastRenderIndex", -1);
      }
      render(options) {
        const gl = this.gl;
        setParameters(gl, {
          framebuffer: options.target
        });
        return this._drawLayers(options);
      }
      _drawLayers(options) {
        const {
          target,
          moduleParameters,
          viewports,
          views,
          onViewportActive,
          clearStack = true,
          clearCanvas = true
        } = options;
        options.pass = options.pass || "unknown";
        const gl = this.gl;
        if (clearCanvas) {
          clearGLCanvas(gl, target);
        }
        if (clearStack) {
          this._lastRenderIndex = -1;
        }
        const renderStats = [];
        for (const viewport of viewports) {
          const view = views && views[viewport.id];
          onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);
          const drawLayerParams = this._getDrawLayerParams(viewport, options);
          const subViewports = viewport.subViewports || [viewport];
          for (const subViewport of subViewports) {
            const stats = this._drawLayersInViewport(gl, {
              target,
              moduleParameters,
              viewport: subViewport,
              view,
              pass: options.pass,
              layers: options.layers
            }, drawLayerParams);
            renderStats.push(stats);
          }
        }
        return renderStats;
      }
      _getDrawLayerParams(viewport, {
        layers,
        pass,
        isPicking = false,
        layerFilter,
        cullRect,
        effects,
        moduleParameters
      }, evaluateShouldDrawOnly = false) {
        const drawLayerParams = [];
        const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
        const drawContext = {
          layer: layers[0],
          viewport,
          isPicking,
          renderPass: pass,
          cullRect
        };
        const layerFilterCache = {};
        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
          const layer = layers[layerIndex];
          const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
          const layerParam = {
            shouldDrawLayer
          };
          if (shouldDrawLayer && !evaluateShouldDrawOnly) {
            layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
            layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
            layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
          }
          drawLayerParams[layerIndex] = layerParam;
        }
        return drawLayerParams;
      }
      _drawLayersInViewport(gl, {
        layers,
        moduleParameters: globalModuleParameters,
        pass,
        target,
        viewport,
        view
      }, drawLayerParams) {
        const glViewport = getGLViewport(gl, {
          moduleParameters: globalModuleParameters,
          target,
          viewport
        });
        if (view && view.props.clear) {
          const clearOpts = view.props.clear === true ? {
            color: true,
            depth: true
          } : view.props.clear;
          withParameters(gl, {
            scissorTest: true,
            scissor: glViewport
          }, () => clear(gl, clearOpts));
        }
        const renderStatus = {
          totalCount: layers.length,
          visibleCount: 0,
          compositeCount: 0,
          pickableCount: 0
        };
        setParameters(gl, {
          viewport: glViewport
        });
        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
          const layer = layers[layerIndex];
          const {
            shouldDrawLayer,
            layerRenderIndex,
            moduleParameters,
            layerParameters
          } = drawLayerParams[layerIndex];
          if (shouldDrawLayer && layer.props.pickable) {
            renderStatus.pickableCount++;
          }
          if (layer.isComposite) {
            renderStatus.compositeCount++;
          } else if (shouldDrawLayer) {
            renderStatus.visibleCount++;
            this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
            moduleParameters.viewport = viewport;
            try {
              layer._drawLayer({
                moduleParameters,
                uniforms: {
                  layerIndex: layerRenderIndex
                },
                parameters: layerParameters
              });
            } catch (err) {
              layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
            }
          }
        }
        return renderStatus;
      }
      shouldDrawLayer(layer) {
        return true;
      }
      getModuleParameters(layer, effects) {
        return null;
      }
      getLayerParameters(layer, layerIndex, viewport) {
        return layer.props.parameters;
      }
      _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
        const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
        if (!shouldDrawLayer) {
          return false;
        }
        drawContext.layer = layer;
        let parent = layer.parent;
        while (parent) {
          if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
            return false;
          }
          drawContext.layer = parent;
          parent = parent.parent;
        }
        if (layerFilter) {
          const rootLayerId = drawContext.layer.id;
          if (!(rootLayerId in layerFilterCache)) {
            layerFilterCache[rootLayerId] = layerFilter(drawContext);
          }
          if (!layerFilterCache[rootLayerId]) {
            return false;
          }
        }
        layer.activateViewport(drawContext.viewport);
        return true;
      }
      _getModuleParameters(layer, effects, pass, overrides) {
        var _layer$internalState;
        const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
          autoWrapLongitude: layer.wrapLongitude,
          viewport: layer.context.viewport,
          mousePosition: layer.context.mousePosition,
          pickingActive: 0,
          devicePixelRatio: cssToDeviceRatio(this.gl)
        });
        if (effects) {
          for (const effect of effects) {
            var _effect$getModulePara;
            Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
          }
        }
        return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js
var ShadowPass;
var init_shadow_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js"() {
    init_defineProperty();
    init_layers_pass();
    init_esm14();
    ShadowPass = class extends LayersPass {
      constructor(gl, props) {
        super(gl, props);
        _defineProperty(this, "shadowMap", void 0);
        _defineProperty(this, "depthBuffer", void 0);
        _defineProperty(this, "fbo", void 0);
        this.shadowMap = new Texture2D(gl, {
          width: 1,
          height: 1,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.depthBuffer = new Renderbuffer(gl, {
          format: 33189,
          width: 1,
          height: 1
        });
        this.fbo = new Framebuffer(gl, {
          id: "shadowmap",
          width: 1,
          height: 1,
          attachments: {
            [36064]: this.shadowMap,
            [36096]: this.depthBuffer
          }
        });
      }
      render(params) {
        const target = this.fbo;
        withParameters(this.gl, {
          depthRange: [0, 1],
          depthTest: true,
          blend: false,
          clearColor: [1, 1, 1, 1]
        }, () => {
          const viewport = params.viewports[0];
          const pixelRatio = cssToDeviceRatio(this.gl);
          const width = viewport.width * pixelRatio;
          const height = viewport.height * pixelRatio;
          if (width !== target.width || height !== target.height) {
            target.resize({
              width,
              height
            });
          }
          super.render({
            ...params,
            target,
            pass: "shadow"
          });
        });
      }
      shouldDrawLayer(layer) {
        return layer.props.shadowEnabled !== false;
      }
      getModuleParameters() {
        return {
          drawToShadowMap: true
        };
      }
      delete() {
        if (this.fbo) {
          this.fbo.delete();
          this.fbo = null;
        }
        if (this.shadowMap) {
          this.shadowMap.delete();
          this.shadowMap = null;
        }
        if (this.depthBuffer) {
          this.depthBuffer.delete();
          this.depthBuffer = null;
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js
var defines, vs5, fs7, geometry_default;
var init_geometry2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js"() {
    defines = "#define SMOOTH_EDGE_RADIUS 0.5";
    vs5 = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
    fs7 = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
    geometry_default = {
      name: "geometry",
      vs: vs5,
      fs: fs7
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js
var COORDINATE_SYSTEM_GLSL_CONSTANTS, PROJECTION_MODE_GLSL_CONSTANTS, UNIT_GLSL_CONSTANTS, project_glsl_default;
var init_project_glsl = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js"() {
    init_constants();
    COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(COORDINATE_SYSTEM[key], ";")).join("");
    PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => "const int PROJECTION_MODE_".concat(key, " = ").concat(PROJECTION_MODE[key], ";")).join("");
    UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(UNIT[key], ";")).join("");
    project_glsl_default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/memoize.js
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a)) {
    const len2 = a.length;
    if (!b || b.length !== len2) {
      return false;
    }
    for (let i = 0; i < len2; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
var init_memoize = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/memoize.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }
  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
  }
  switch (viewport.projectionMode) {
    case PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }
      break;
    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;
    case PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;
    default:
      offsetMode = false;
  }
  return {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const {
    viewMatrixUncentered,
    projectionMatrix
  } = viewport;
  let {
    viewMatrix: viewMatrix2,
    viewProjectionMatrix
  } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
    originCommon[3] = 1;
    projectionCenter = transformMat43([], originCommon, viewProjectionMatrix);
    viewMatrix2 = viewMatrixUncentered || viewMatrix2;
    viewProjectionMatrix = multiply([], projectionMatrix, viewMatrix2);
    viewProjectionMatrix = multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }
  return {
    viewMatrix: viewMatrix2,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  const uniforms3 = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms3.project_uWrapLongitude = autoWrapLongitude;
  uniforms3.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX5;
  return uniforms3;
}
function calculateViewportUniforms({
  viewport,
  devicePixelRatio,
  coordinateSystem,
  coordinateOrigin
}) {
  const {
    projectionCenter,
    viewProjectionMatrix,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  const focalDistance = transformMat43([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms3 = {
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCommonOrigin: originCommon.slice(0, 3),
    project_uCenter: projectionCenter,
    project_uPseudoMeters: Boolean(viewport._pseudoMeters),
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: focalDistance,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uWrapLongitude: false,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uModelMatrix: IDENTITY_MATRIX5,
    project_uCameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms3.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms3.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case COORDINATE_SYSTEM.LNGLAT:
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms3.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }
        uniforms3.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms3.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      case COORDINATE_SYSTEM.CARTESIAN:
        uniforms3.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms3.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;
      default:
        break;
    }
  }
  return uniforms3;
}
var ZERO_VECTOR, VECTOR_TO_POINT_MATRIX, IDENTITY_MATRIX5, DEFAULT_PIXELS_PER_UNIT2, DEFAULT_COORDINATE_ORIGIN, getMemoizedViewportUniforms;
var init_viewport_uniforms = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"() {
    init_mat4();
    init_vec4();
    init_constants();
    init_memoize();
    ZERO_VECTOR = [0, 0, 0, 0];
    VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
    IDENTITY_MATRIX5 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
    DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
    getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js
function getUniforms7(opts = INITIAL_MODULE_OPTIONS3) {
  if ("viewport" in opts) {
    return getUniformsFromViewport(opts);
  }
  return {};
}
var INITIAL_MODULE_OPTIONS3, project_default;
var init_project2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"() {
    init_esm14();
    init_geometry2();
    init_project_glsl();
    init_viewport_uniforms();
    INITIAL_MODULE_OPTIONS3 = {};
    project_default = {
      name: "project",
      dependencies: [fp32, geometry_default],
      vs: project_glsl_default,
      getUniforms: getUniforms7
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x, y, z] = xyz;
  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);
  if (Number.isFinite(z)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition({
  viewport,
  center
}) {
  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({
  viewport,
  shadowMatrices
}) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? void 0 : 1;
  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map((pixel) => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix2 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
    const positions = corners.map((corner) => viewMatrix2.transform(corner));
    const projectionMatrix = new Matrix4().ortho({
      left: Math.min(...positions.map((position) => position[0])),
      right: Math.max(...positions.map((position) => position[0])),
      bottom: Math.min(...positions.map((position) => position[1])),
      top: Math.max(...positions.map((position) => position[1])),
      near: Math.min(...positions.map((position) => -position[2])),
      far: Math.max(...positions.map((position) => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }
  return projectionMatrices;
}
function createShadowUniforms(opts, context) {
  const {
    shadowEnabled = true
  } = opts;
  if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      shadow_uDrawShadowMap: false,
      shadow_uUseShadowMap: false
    };
  }
  const uniforms3 = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  const center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();
  for (let i = 0; i < opts.shadowMatrices.length; i++) {
    const viewProjectionMatrix = viewProjectionMatrices[i];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
    if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }
  for (let i = 0; i < viewProjectionMatrices.length; i++) {
    uniforms3["shadow_uViewProjectionMatrices[".concat(i, "]")] = viewProjectionMatrices[i];
    uniforms3["shadow_uProjectCenters[".concat(i, "]")] = projectCenters[i];
    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms3["shadow_uShadowMap".concat(i)] = opts.shadowMaps[i];
    } else {
      uniforms3["shadow_uShadowMap".concat(i)] = opts.dummyShadowMap;
    }
  }
  return uniforms3;
}
var vs6, fs8, getMemoizedViewportCenterPosition, getMemoizedViewProjectionMatrices, DEFAULT_SHADOW_COLOR, VECTOR_TO_POINT_MATRIX2, shadow_default;
var init_shadow = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js"() {
    init_constants();
    init_project2();
    init_esm11();
    init_memoize();
    init_esm();
    vs6 = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
    fs8 = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
    getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
    getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
    DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
    VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
    shadow_default = {
      name: "shadow",
      dependencies: [project_default],
      vs: vs6,
      fs: fs8,
      inject: {
        "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
        "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
      },
      getUniforms: (opts = {}, context = {}) => {
        if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
          return createShadowUniforms(opts, context);
        }
        return {};
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js
var DEFAULT_AMBIENT_LIGHT_PROPS, DEFAULT_DIRECTIONAL_LIGHT_PROPS, DEFAULT_SHADOW_COLOR2, LightingEffect;
var init_lighting_effect = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js"() {
    init_defineProperty();
    init_esm14();
    init_ambient_light();
    init_directional_light();
    init_esm11();
    init_shadow_pass();
    init_shadow();
    DEFAULT_AMBIENT_LIGHT_PROPS = {
      color: [255, 255, 255],
      intensity: 1
    };
    DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
      color: [255, 255, 255],
      intensity: 1,
      direction: [-1, 3, -1]
    }, {
      color: [255, 255, 255],
      intensity: 0.9,
      direction: [1, -8, -2.5]
    }];
    DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
    LightingEffect = class {
      constructor(props = {}) {
        _defineProperty(this, "id", "lighting-effect");
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "shadowColor", DEFAULT_SHADOW_COLOR2);
        _defineProperty(this, "shadow", void 0);
        _defineProperty(this, "ambientLight", void 0);
        _defineProperty(this, "directionalLights", void 0);
        _defineProperty(this, "pointLights", void 0);
        _defineProperty(this, "shadowPasses", []);
        _defineProperty(this, "shadowMaps", []);
        _defineProperty(this, "dummyShadowMap", null);
        _defineProperty(this, "programManager", void 0);
        _defineProperty(this, "shadowMatrices", void 0);
        this.setProps(props);
      }
      setProps(props) {
        this.ambientLight = null;
        this.directionalLights = [];
        this.pointLights = [];
        for (const key in props) {
          const lightSource = props[key];
          switch (lightSource.type) {
            case "ambient":
              this.ambientLight = lightSource;
              break;
            case "directional":
              this.directionalLights.push(lightSource);
              break;
            case "point":
              this.pointLights.push(lightSource);
              break;
            default:
          }
        }
        this._applyDefaultLights();
        this.shadow = this.directionalLights.some((light) => light.shadow);
        this.props = props;
      }
      preRender(gl, {
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views
      }) {
        if (!this.shadow)
          return;
        this.shadowMatrices = this._calculateMatrices();
        if (this.shadowPasses.length === 0) {
          this._createShadowPasses(gl);
        }
        if (!this.programManager) {
          this.programManager = ProgramManager.getDefaultProgramManager(gl);
          if (shadow_default) {
            this.programManager.addDefaultModule(shadow_default);
          }
        }
        if (!this.dummyShadowMap) {
          this.dummyShadowMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        for (let i = 0; i < this.shadowPasses.length; i++) {
          const shadowPass = this.shadowPasses[i];
          shadowPass.render({
            layers,
            layerFilter,
            viewports,
            onViewportActive,
            views,
            moduleParameters: {
              shadowLightId: i,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          });
        }
      }
      getModuleParameters(layer) {
        const parameters = this.shadow ? {
          shadowMaps: this.shadowMaps,
          dummyShadowMap: this.dummyShadowMap,
          shadowColor: this.shadowColor,
          shadowMatrices: this.shadowMatrices
        } : {};
        parameters.lightSources = {
          ambientLight: this.ambientLight,
          directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({
            layer
          })),
          pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({
            layer
          }))
        };
        return parameters;
      }
      cleanup() {
        for (const shadowPass of this.shadowPasses) {
          shadowPass.delete();
        }
        this.shadowPasses.length = 0;
        this.shadowMaps.length = 0;
        if (this.dummyShadowMap) {
          this.dummyShadowMap.delete();
          this.dummyShadowMap = null;
        }
        if (this.shadow && this.programManager) {
          this.programManager.removeDefaultModule(shadow_default);
          this.programManager = null;
        }
      }
      _calculateMatrices() {
        const lightMatrices = [];
        for (const light of this.directionalLights) {
          const viewMatrix2 = new Matrix4().lookAt({
            eye: new Vector3(light.direction).negate()
          });
          lightMatrices.push(viewMatrix2);
        }
        return lightMatrices;
      }
      _createShadowPasses(gl) {
        for (let i = 0; i < this.directionalLights.length; i++) {
          const shadowPass = new ShadowPass(gl);
          this.shadowPasses[i] = shadowPass;
          this.shadowMaps[i] = shadowPass.shadowMap;
        }
      }
      _applyDefaultLights() {
        const {
          ambientLight,
          pointLights,
          directionalLights
        } = this;
        if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
          this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
          this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js
var TypedArrayManager, typed_array_manager_default;
var init_typed_array_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js"() {
    init_defineProperty();
    TypedArrayManager = class {
      constructor(options = {}) {
        _defineProperty(this, "_pool", []);
        _defineProperty(this, "opts", {
          overAlloc: 2,
          poolSize: 100
        });
        this.setOptions(options);
      }
      setOptions(options) {
        Object.assign(this.opts, options);
      }
      allocate(typedArray, count2, {
        size = 1,
        type,
        padding = 0,
        copy: copy2 = false,
        initialize = false,
        maxCount
      }) {
        const Type = type || typedArray && typedArray.constructor || Float32Array;
        const newSize = count2 * size + padding;
        if (ArrayBuffer.isView(typedArray)) {
          if (newSize <= typedArray.length) {
            return typedArray;
          }
          if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
            return new Type(typedArray.buffer, 0, newSize);
          }
        }
        let maxSize = Infinity;
        if (maxCount) {
          maxSize = maxCount * size + padding;
        }
        const newArray = this._allocate(Type, newSize, initialize, maxSize);
        if (typedArray && copy2) {
          newArray.set(typedArray);
        } else if (!initialize) {
          newArray.fill(0, 0, 4);
        }
        this._release(typedArray);
        return newArray;
      }
      release(typedArray) {
        this._release(typedArray);
      }
      _allocate(Type, size, initialize, maxSize) {
        let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
        if (sizeToAllocate > maxSize) {
          sizeToAllocate = maxSize;
        }
        const pool = this._pool;
        const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
        const i = pool.findIndex((b) => b.byteLength >= byteLength);
        if (i >= 0) {
          const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
          if (initialize) {
            array.fill(0);
          }
          return array;
        }
        return new Type(sizeToAllocate);
      }
      _release(typedArray) {
        if (!ArrayBuffer.isView(typedArray)) {
          return;
        }
        const pool = this._pool;
        const {
          buffer
        } = typedArray;
        const {
          byteLength
        } = buffer;
        const i = pool.findIndex((b) => b.byteLength >= byteLength);
        if (i < 0) {
          pool.push(buffer);
        } else if (i > 0 || pool.length < this.opts.poolSize) {
          pool.splice(i, 0, buffer);
        }
        if (pool.length > this.opts.poolSize) {
          pool.shift();
        }
      }
    };
    typed_array_manager_default = new TypedArrayManager();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/math-utils.js
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
function getFrustumPlane(a, b, c, d) {
  scratchVector.set(a, b, c);
  const L = scratchVector.len();
  return {
    distance: d / L,
    normal: new Vector3(-a / L, -b / L, -c / L)
  };
}
function fp64LowPart2(x) {
  return x - Math.fround(x);
}
function toDoublePrecisionArray(typedArray, options) {
  const {
    size = 1,
    startIndex = 0
  } = options;
  const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
  const count2 = (endIndex - startIndex) / size;
  scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (let j = 0; j < size; j++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value;
      scratchArray[targetIndex + j + size] = fp64LowPart2(value);
    }
    targetIndex += size * 2;
  }
  return scratchArray.subarray(0, count2 * size * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;
  for (const bounds of boundsList) {
    if (!bounds)
      continue;
    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
        isMerged = true;
      }
      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }
  return mergedBounds;
}
var scratchVector, scratchArray;
var init_math_utils2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/math-utils.js"() {
    init_typed_array_manager();
    init_esm11();
    scratchVector = new Vector3();
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/viewport.js
function createProjectionMatrix({
  width,
  height,
  orthographic,
  fovyRadians,
  focalDistance,
  padding,
  near,
  far
}) {
  const aspect = width / height;
  const matrix = orthographic ? new Matrix4().orthographic({
    fovy: fovyRadians,
    aspect,
    focalDistance,
    near,
    far
  }) : new Matrix4().perspective({
    fovy: fovyRadians,
    aspect,
    near,
    far
  });
  if (padding) {
    const {
      left = 0,
      right = 0,
      top = 0,
      bottom = 0
    } = padding;
    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }
  return matrix;
}
var DEGREES_TO_RADIANS2, IDENTITY2, ZERO_VECTOR2, DEFAULT_DISTANCE_SCALES, Viewport;
var init_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/viewport.js"() {
    init_defineProperty();
    init_log3();
    init_math_utils2();
    init_esm11();
    init_mat4();
    init_esm();
    init_constants();
    DEGREES_TO_RADIANS2 = Math.PI / 180;
    IDENTITY2 = createMat4();
    ZERO_VECTOR2 = [0, 0, 0];
    DEFAULT_DISTANCE_SCALES = {
      unitsPerMeter: [1, 1, 1],
      metersPerUnit: [1, 1, 1]
    };
    Viewport = class {
      constructor(opts = {}) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "x", void 0);
        _defineProperty(this, "y", void 0);
        _defineProperty(this, "width", void 0);
        _defineProperty(this, "height", void 0);
        _defineProperty(this, "padding", void 0);
        _defineProperty(this, "isGeospatial", void 0);
        _defineProperty(this, "zoom", void 0);
        _defineProperty(this, "focalDistance", void 0);
        _defineProperty(this, "position", void 0);
        _defineProperty(this, "modelMatrix", void 0);
        _defineProperty(this, "distanceScales", void 0);
        _defineProperty(this, "scale", void 0);
        _defineProperty(this, "center", void 0);
        _defineProperty(this, "cameraPosition", void 0);
        _defineProperty(this, "projectionMatrix", void 0);
        _defineProperty(this, "viewMatrix", void 0);
        _defineProperty(this, "viewMatrixUncentered", void 0);
        _defineProperty(this, "viewMatrixInverse", void 0);
        _defineProperty(this, "viewProjectionMatrix", void 0);
        _defineProperty(this, "pixelProjectionMatrix", void 0);
        _defineProperty(this, "pixelUnprojectionMatrix", void 0);
        _defineProperty(this, "resolution", void 0);
        _defineProperty(this, "_frustumPlanes", {});
        this.id = opts.id || this.constructor.displayName || "viewport";
        this.x = opts.x || 0;
        this.y = opts.y || 0;
        this.width = opts.width || 1;
        this.height = opts.height || 1;
        this.zoom = opts.zoom || 0;
        this.padding = opts.padding;
        this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
        this.focalDistance = opts.focalDistance || 1;
        this.position = opts.position || ZERO_VECTOR2;
        this.modelMatrix = opts.modelMatrix || null;
        const {
          longitude,
          latitude
        } = opts;
        this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
        this._initProps(opts);
        this._initMatrices(opts);
        this.equals = this.equals.bind(this);
        this.project = this.project.bind(this);
        this.unproject = this.unproject.bind(this);
        this.projectPosition = this.projectPosition.bind(this);
        this.unprojectPosition = this.unprojectPosition.bind(this);
        this.projectFlat = this.projectFlat.bind(this);
        this.unprojectFlat = this.unprojectFlat.bind(this);
      }
      get subViewports() {
        return null;
      }
      get metersPerPixel() {
        return this.distanceScales.metersPerUnit[2] / this.scale;
      }
      get projectionMode() {
        if (this.isGeospatial) {
          return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
        }
        return PROJECTION_MODE.IDENTITY;
      }
      equals(viewport) {
        if (!(viewport instanceof Viewport)) {
          return false;
        }
        if (this === viewport) {
          return true;
        }
        return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
      }
      project(xyz, {
        topLeft = true
      } = {}) {
        const worldPosition = this.projectPosition(xyz);
        const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
        const [x, y] = coord;
        const y2 = topLeft ? y : this.height - y;
        return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
      }
      unproject(xyz, {
        topLeft = true,
        targetZ
      } = {}) {
        const [x, y, z] = xyz;
        const y2 = topLeft ? y : this.height - y;
        const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
        const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
        const [X, Y, Z] = this.unprojectPosition(coord);
        if (Number.isFinite(z)) {
          return [X, Y, Z];
        }
        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
      }
      projectPosition(xyz) {
        const [X, Y] = this.projectFlat(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
        return [X, Y, Z];
      }
      unprojectPosition(xyz) {
        const [X, Y] = this.unprojectFlat(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
        return [X, Y, Z];
      }
      projectFlat(xyz) {
        if (this.isGeospatial) {
          const result = lngLatToWorld(xyz);
          result[1] = clamp(result[1], -318, 830);
          return result;
        }
        return xyz;
      }
      unprojectFlat(xyz) {
        if (this.isGeospatial) {
          return worldToLngLat(xyz);
        }
        return xyz;
      }
      getBounds(options = {}) {
        const unprojectOption = {
          targetZ: options.z || 0
        };
        const topLeft = this.unproject([0, 0], unprojectOption);
        const topRight = this.unproject([this.width, 0], unprojectOption);
        const bottomLeft = this.unproject([0, this.height], unprojectOption);
        const bottomRight = this.unproject([this.width, this.height], unprojectOption);
        return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
      }
      getDistanceScales(coordinateOrigin) {
        if (coordinateOrigin) {
          return getDistanceScales({
            longitude: coordinateOrigin[0],
            latitude: coordinateOrigin[1],
            highPrecision: true
          });
        }
        return this.distanceScales;
      }
      containsPixel({
        x,
        y,
        width = 1,
        height = 1
      }) {
        return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
      }
      getFrustumPlanes() {
        if (this._frustumPlanes.near) {
          return this._frustumPlanes;
        }
        Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
        return this._frustumPlanes;
      }
      panByPosition(coords, pixel) {
        return null;
      }
      _initProps(opts) {
        const longitude = opts.longitude;
        const latitude = opts.latitude;
        if (this.isGeospatial) {
          if (!Number.isFinite(opts.zoom)) {
            this.zoom = getMeterZoom({
              latitude
            }) + Math.log2(this.focalDistance);
          }
          this.distanceScales = opts.distanceScales || getDistanceScales({
            latitude,
            longitude
          });
        }
        const scale5 = Math.pow(2, this.zoom);
        this.scale = scale5;
        const {
          position,
          modelMatrix
        } = opts;
        let meterOffset = ZERO_VECTOR2;
        if (position) {
          meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
        }
        if (this.isGeospatial) {
          const center = this.projectPosition([longitude, latitude, 0]);
          this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
        } else {
          this.center = this.projectPosition(meterOffset);
        }
      }
      _initMatrices(opts) {
        const {
          viewMatrix: viewMatrix2 = IDENTITY2,
          projectionMatrix = null,
          orthographic = false,
          fovyRadians,
          fovy = 75,
          near = 0.1,
          far = 1e3,
          padding = null,
          focalDistance = 1
        } = opts;
        this.viewMatrixUncentered = viewMatrix2;
        this.viewMatrix = new Matrix4().multiplyRight(viewMatrix2).translate(new Vector3(this.center).negate());
        this.projectionMatrix = projectionMatrix || createProjectionMatrix({
          width: this.width,
          height: this.height,
          orthographic,
          fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS2,
          focalDistance,
          padding,
          near,
          far
        });
        const vpm = createMat4();
        multiply(vpm, vpm, this.projectionMatrix);
        multiply(vpm, vpm, this.viewMatrix);
        this.viewProjectionMatrix = vpm;
        this.viewMatrixInverse = invert([], this.viewMatrix) || this.viewMatrix;
        this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
        const viewportMatrix = createMat4();
        const pixelProjectionMatrix = createMat4();
        scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
        translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
        multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
        this.pixelProjectionMatrix = pixelProjectionMatrix;
        this.pixelUnprojectionMatrix = invert(createMat4(), this.pixelProjectionMatrix);
        if (!this.pixelUnprojectionMatrix) {
          log_default.warn("Pixel project matrix not invertible")();
        }
      }
    };
    _defineProperty(Viewport, "displayName", "Viewport");
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js
var WebMercatorViewport;
var init_web_mercator_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js"() {
    init_defineProperty();
    init_viewport();
    init_esm();
    init_vec2();
    init_esm11();
    WebMercatorViewport = class extends Viewport {
      constructor(opts = {}) {
        const {
          latitude = 0,
          longitude = 0,
          zoom = 0,
          pitch = 0,
          bearing = 0,
          nearZMultiplier = 0.1,
          farZMultiplier = 1.01,
          orthographic = false,
          projectionMatrix,
          repeat = false,
          worldOffset = 0,
          position,
          padding,
          legacyMeterSizes = false
        } = opts;
        let {
          width,
          height,
          altitude = 1.5
        } = opts;
        const scale5 = Math.pow(2, zoom);
        width = width || 1;
        height = height || 1;
        let fovy;
        let projectionParameters = null;
        if (projectionMatrix) {
          altitude = projectionMatrix[5] / 2;
          fovy = altitudeToFovy(altitude);
        } else {
          if (opts.fovy) {
            fovy = opts.fovy;
            altitude = fovyToAltitude(fovy);
          } else {
            fovy = altitudeToFovy(altitude);
          }
          let offset;
          if (padding) {
            const {
              top = 0,
              bottom = 0
            } = padding;
            offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
          }
          projectionParameters = getProjectionParameters({
            width,
            height,
            scale: scale5,
            center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
            offset,
            pitch,
            fovy,
            nearZMultiplier,
            farZMultiplier
          });
        }
        let viewMatrixUncentered = getViewMatrix({
          height,
          pitch,
          bearing,
          scale: scale5,
          altitude
        });
        if (worldOffset) {
          const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
          viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
        }
        super({
          ...opts,
          width,
          height,
          viewMatrix: viewMatrixUncentered,
          longitude,
          latitude,
          zoom,
          ...projectionParameters,
          fovy,
          focalDistance: altitude
        });
        _defineProperty(this, "longitude", void 0);
        _defineProperty(this, "latitude", void 0);
        _defineProperty(this, "pitch", void 0);
        _defineProperty(this, "bearing", void 0);
        _defineProperty(this, "altitude", void 0);
        _defineProperty(this, "fovy", void 0);
        _defineProperty(this, "orthographic", void 0);
        _defineProperty(this, "_subViewports", void 0);
        _defineProperty(this, "_pseudoMeters", void 0);
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.orthographic = orthographic;
        this._subViewports = repeat ? [] : null;
        this._pseudoMeters = legacyMeterSizes;
        Object.freeze(this);
      }
      get subViewports() {
        if (this._subViewports && !this._subViewports.length) {
          const bounds = this.getBounds();
          const minOffset = Math.floor((bounds[0] + 180) / 360);
          const maxOffset = Math.ceil((bounds[2] - 180) / 360);
          for (let x = minOffset; x <= maxOffset; x++) {
            const offsetViewport = x ? new WebMercatorViewport({
              ...this,
              worldOffset: x
            }) : this;
            this._subViewports.push(offsetViewport);
          }
        }
        return this._subViewports;
      }
      projectPosition(xyz) {
        if (this._pseudoMeters) {
          return super.projectPosition(xyz);
        }
        const [X, Y] = this.projectFlat(xyz);
        const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
        return [X, Y, Z];
      }
      unprojectPosition(xyz) {
        if (this._pseudoMeters) {
          return super.unprojectPosition(xyz);
        }
        const [X, Y] = this.unprojectFlat(xyz);
        const Z = (xyz[2] || 0) / unitsPerMeter(Y);
        return [X, Y, Z];
      }
      addMetersToLngLat(lngLatZ, xyz) {
        return addMetersToLngLat(lngLatZ, xyz);
      }
      panByPosition(coords, pixel) {
        const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
        const toLocation = this.projectFlat(coords);
        const translate3 = add([], toLocation, negate([], fromLocation));
        const newCenter = add([], this.center, translate3);
        const [longitude, latitude] = this.unprojectFlat(newCenter);
        return {
          longitude,
          latitude
        };
      }
      getBounds(options = {}) {
        const corners = getBounds(this, options.z || 0);
        return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
      }
      fitBounds(bounds, options = {}) {
        const {
          width,
          height
        } = this;
        const {
          longitude,
          latitude,
          zoom
        } = fitBounds({
          width,
          height,
          bounds,
          ...options
        });
        return new WebMercatorViewport({
          width,
          height,
          longitude,
          latitude,
          zoom
        });
      }
    };
    _defineProperty(WebMercatorViewport, "displayName", "WebMercatorViewport");
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof WebMercatorViewport) {
    const [longitude, latitude, z = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p[2] = z * distanceScales.unitsPerMeter[2];
  }
  return p;
}
function normalizeParameters(opts) {
  const {
    viewport,
    modelMatrix,
    coordinateOrigin
  } = opts;
  let {
    coordinateSystem,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = opts;
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === void 0) {
    fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === void 0) {
    fromCoordinateOrigin = coordinateOrigin;
  }
  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}
function getWorldPosition(position, {
  viewport,
  modelMatrix,
  coordinateSystem,
  coordinateOrigin,
  offsetMode
}) {
  let [x, y, z = 0] = position;
  if (modelMatrix) {
    [x, y, z] = transformMat43([], [x, y, z, 1], modelMatrix);
  }
  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);
    case COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
  }
}
function projectPosition(position, params) {
  const {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = normalizeParameters(params);
  const {
    autoOffset = true
  } = params;
  const {
    geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2,
    shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2,
    offsetMode = false
  } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    sub(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}
var DEFAULT_COORDINATE_ORIGIN2;
var init_project_functions = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js"() {
    init_constants();
    init_viewport_uniforms();
    init_web_mercator_viewport();
    init_vec4();
    init_vec3();
    init_esm();
    DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js
function getAttenuation(props) {
  if (props.attenuation) {
    return props.attenuation;
  }
  if ("intensity" in props) {
    return [0, 0, props.intensity || 0];
  }
  return DEFAULT_ATTENUATION;
}
var DEFAULT_LIGHT_COLOR3, DEFAULT_LIGHT_INTENSITY3, DEFAULT_ATTENUATION, DEFAULT_LIGHT_POSITION, idCount3, PointLight;
var init_point_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js"() {
    init_defineProperty();
    init_project_functions();
    init_constants();
    DEFAULT_LIGHT_COLOR3 = [255, 255, 255];
    DEFAULT_LIGHT_INTENSITY3 = 1;
    DEFAULT_ATTENUATION = [0, 0, 1];
    DEFAULT_LIGHT_POSITION = [0, 0, 1];
    idCount3 = 0;
    PointLight = class {
      constructor(props = {}) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "color", void 0);
        _defineProperty(this, "intensity", void 0);
        _defineProperty(this, "type", "point");
        _defineProperty(this, "position", void 0);
        _defineProperty(this, "attenuation", void 0);
        _defineProperty(this, "projectedLight", void 0);
        const {
          color = DEFAULT_LIGHT_COLOR3
        } = props;
        const {
          intensity = DEFAULT_LIGHT_INTENSITY3
        } = props;
        const {
          position = DEFAULT_LIGHT_POSITION
        } = props;
        this.id = props.id || "point-".concat(idCount3++);
        this.color = color;
        this.intensity = intensity;
        this.type = "point";
        this.position = position;
        this.attenuation = getAttenuation(props);
        this.projectedLight = {
          ...this
        };
      }
      getProjectedLight({
        layer
      }) {
        const {
          projectedLight
        } = this;
        const viewport = layer.context.viewport;
        const {
          coordinateSystem,
          coordinateOrigin
        } = layer.props;
        const position = projectPosition(this.position, {
          viewport,
          coordinateSystem,
          coordinateOrigin,
          fromCoordinateSystem: viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
          fromCoordinateOrigin: [0, 0, 0]
        });
        projectedLight.color = this.color;
        projectedLight.intensity = this.intensity;
        projectedLight.position = position;
        return projectedLight;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js
var CameraLight;
var init_camera_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js"() {
    init_point_light();
    init_viewport_uniforms();
    CameraLight = class extends PointLight {
      getProjectedLight({
        layer
      }) {
        const {
          projectedLight
        } = this;
        const viewport = layer.context.viewport;
        const {
          coordinateSystem,
          coordinateOrigin,
          modelMatrix
        } = layer.props;
        const {
          project_uCameraPosition
        } = getUniformsFromViewport({
          viewport,
          modelMatrix,
          coordinateSystem,
          coordinateOrigin
        });
        projectedLight.color = this.color;
        projectedLight.intensity = this.intensity;
        projectedLight.position = project_uCameraPosition;
        return projectedLight;
      }
    };
  }
});

// node_modules/@math.gl/sun/dist/esm/suncalc.js
function getSunPosition(timestamp, latitude, longitude) {
  const longitudeWestInRadians = DEGREES_TO_RADIANS3 * -longitude;
  const phi = DEGREES_TO_RADIANS3 * latitude;
  const d = toDays(timestamp);
  const c = getSunCoords(d);
  const H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}
function getSunDirection(timestamp, latitude, longitude) {
  const {
    azimuth,
    altitude
  } = getSunPosition(timestamp, latitude, longitude);
  return [Math.sin(azimuth) * Math.cos(altitude), Math.cos(azimuth) * Math.cos(altitude), -Math.sin(altitude)];
}
function toJulianDay(timestamp) {
  const ts = typeof timestamp === "number" ? timestamp : timestamp.getTime();
  return ts / DAY_IN_MS - 0.5 + JD1970;
}
function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}
function getRightAscension(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}
function getDeclination(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}
function getAzimuth(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}
function getAltitude(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}
function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS3 * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}
function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS3 * (M0 + M1 * days);
}
function getEclipticLongitude(meanAnomaly) {
  const M = meanAnomaly;
  const C = DEGREES_TO_RADIANS3 * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 3e-4 * Math.sin(3 * M));
  const P = DEGREES_TO_RADIANS3 * 102.9372;
  return M + C + P + Math.PI;
}
function getSunCoords(dates) {
  const M = getSolarMeanAnomaly(dates);
  const L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}
var DEGREES_TO_RADIANS3, DAY_IN_MS, JD1970, JD2000, e, M0, M1, THETA0, THETA1;
var init_suncalc = __esm({
  "node_modules/@math.gl/sun/dist/esm/suncalc.js"() {
    DEGREES_TO_RADIANS3 = Math.PI / 180;
    DAY_IN_MS = 1e3 * 60 * 60 * 24;
    JD1970 = 2440588;
    JD2000 = 2451545;
    e = DEGREES_TO_RADIANS3 * 23.4397;
    M0 = 357.5291;
    M1 = 0.98560028;
    THETA0 = 280.147;
    THETA1 = 360.9856235;
  }
});

// node_modules/@math.gl/sun/dist/esm/index.js
var init_esm15 = __esm({
  "node_modules/@math.gl/sun/dist/esm/index.js"() {
    init_suncalc();
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js
var SunLight;
var init_sun_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js"() {
    init_defineProperty();
    init_directional_light();
    init_esm15();
    SunLight = class extends DirectionalLight {
      constructor(opts) {
        super(opts);
        _defineProperty(this, "timestamp", void 0);
        this.timestamp = opts.timestamp;
      }
      getProjectedLight({
        layer
      }) {
        const {
          viewport
        } = layer.context;
        const isGlobe = viewport.resolution && viewport.resolution > 0;
        if (isGlobe) {
          const [x, y, z] = getSunDirection(this.timestamp, 0, 0);
          this.direction = [x, -z, y];
        } else {
          const {
            latitude,
            longitude
          } = viewport;
          this.direction = getSunDirection(this.timestamp, latitude, longitude);
        }
        return this;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js
var ScreenPass;
var init_screen_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js"() {
    init_defineProperty();
    init_esm14();
    init_pass();
    ScreenPass = class extends Pass {
      constructor(gl, props) {
        super(gl, props);
        _defineProperty(this, "model", void 0);
        const {
          module,
          fs: fs9,
          id
        } = props;
        this.model = new ClipSpace(gl, {
          id,
          fs: fs9,
          modules: [module]
        });
      }
      render(params) {
        const gl = this.gl;
        setParameters(gl, {
          viewport: [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
        });
        withParameters(gl, {
          framebuffer: params.outputBuffer,
          clearColor: [0, 0, 0, 0]
        }, () => this._renderPass(gl, params));
      }
      delete() {
        this.model.delete();
        this.model = null;
      }
      _renderPass(gl, options) {
        const {
          inputBuffer
        } = options;
        clear(gl, {
          color: true
        });
        this.model.draw({
          moduleSettings: options.moduleSettings,
          uniforms: {
            texture: inputBuffer,
            texSize: [inputBuffer.width, inputBuffer.height]
          },
          parameters: {
            depthWrite: false,
            depthTest: false
          }
        });
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js
function createPasses(gl, module, id) {
  if (!module.passes) {
    const fs9 = getFragmentShaderForRenderPass(module);
    const pass = new ScreenPass(gl, {
      id,
      module,
      fs: fs9
    });
    return [pass];
  }
  return module.passes.map((pass, index) => {
    const fs9 = getFragmentShaderForRenderPass(module, pass);
    const idn = "".concat(id, "-").concat(index);
    return new ScreenPass(gl, {
      id: idn,
      module,
      fs: fs9
    });
  });
}
function getFragmentShaderForRenderPass(module, pass = module) {
  if (pass.filter) {
    const func = typeof pass.filter === "string" ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }
  if (pass.sampler) {
    const func = typeof pass.sampler === "string" ? pass.sampler : "".concat(module.name, "_sampleColor");
    return SAMPLER_FS_TEMPLATE(func);
  }
  return null;
}
var PostProcessEffect, FILTER_FS_TEMPLATE, SAMPLER_FS_TEMPLATE;
var init_post_process_effect = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js"() {
    init_defineProperty();
    init_screen_pass();
    init_esm14();
    PostProcessEffect = class {
      constructor(module, props = {}) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "module", void 0);
        _defineProperty(this, "passes", void 0);
        this.id = "".concat(module.name, "-pass");
        this.props = props;
        normalizeShaderModule(module);
        this.module = module;
      }
      setProps(props) {
        this.props = props;
      }
      preRender() {
      }
      postRender(gl, params) {
        const passes = this.passes || createPasses(gl, this.module, this.id);
        this.passes = passes;
        const {
          target
        } = params;
        let inputBuffer = params.inputBuffer;
        let outputBuffer = params.swapBuffer;
        for (let index = 0; index < this.passes.length; index++) {
          if (target && index === this.passes.length - 1) {
            outputBuffer = target;
          }
          this.passes[index].render({
            inputBuffer,
            outputBuffer,
            moduleSettings: this.props
          });
          const switchBuffer = outputBuffer;
          outputBuffer = inputBuffer;
          inputBuffer = switchBuffer;
        }
        return inputBuffer;
      }
      cleanup() {
        if (this.passes) {
          for (const pass of this.passes) {
            pass.delete();
          }
          this.passes = void 0;
        }
      }
    };
    FILTER_FS_TEMPLATE = (func) => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
    SAMPLER_FS_TEMPLATE = (func) => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js
function encodeColor(encoded, layer, viewport) {
  const {
    byLayer,
    byAlpha
  } = encoded;
  let a;
  let entry = byLayer.get(layer);
  if (entry) {
    entry.viewports.push(viewport);
    a = entry.a;
  } else {
    a = byLayer.size + 1;
    if (a <= 255) {
      entry = {
        a,
        layer,
        viewports: [viewport]
      };
      byLayer.set(layer, entry);
      byAlpha[a] = entry;
    } else {
      log_default.warn("Too many pickable layers, only picking the first 255")();
      a = 0;
    }
  }
  return [0, 0, 0, a / 255];
}
function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}
var PICKING_PARAMETERS, PickLayersPass;
var init_pick_layers_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js"() {
    init_defineProperty();
    init_layers_pass();
    init_esm14();
    init_log3();
    PICKING_PARAMETERS = {
      blendFunc: [1, 0, 32771, 0],
      blendEquation: 32774
    };
    PickLayersPass = class extends LayersPass {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "pickZ", void 0);
        _defineProperty(this, "_colorEncoderState", null);
      }
      render(props) {
        if ("pickingFBO" in props) {
          return this._drawPickingBuffer(props);
        }
        return super.render(props);
      }
      _drawPickingBuffer({
        layers,
        layerFilter,
        views,
        viewports,
        onViewportActive,
        pickingFBO,
        deviceRect: {
          x,
          y,
          width,
          height
        },
        cullRect,
        effects,
        pass = "picking",
        pickZ,
        moduleParameters
      }) {
        const gl = this.gl;
        this.pickZ = pickZ;
        const colorEncoderState = this._resetColorEncoder(pickZ);
        const renderStatus = withParameters(gl, {
          scissorTest: true,
          scissor: [x, y, width, height],
          clearColor: [0, 0, 0, 0],
          depthMask: true,
          depthTest: true,
          depthRange: [0, 1],
          colorMask: [true, true, true, true],
          ...PICKING_PARAMETERS,
          blend: !pickZ
        }, () => super.render({
          target: pickingFBO,
          layers,
          layerFilter,
          views,
          viewports,
          onViewportActive,
          cullRect,
          effects: effects === null || effects === void 0 ? void 0 : effects.filter((e2) => e2.useInPicking),
          pass,
          isPicking: true,
          moduleParameters
        }));
        this._colorEncoderState = null;
        const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
        return {
          decodePickingColor,
          stats: renderStatus
        };
      }
      shouldDrawLayer(layer) {
        const {
          pickable,
          operation
        } = layer.props;
        return pickable && operation.includes("draw") || operation.includes("terrain");
      }
      getModuleParameters() {
        return {
          pickingActive: 1,
          pickingAttribute: this.pickZ,
          lightSources: {}
        };
      }
      getLayerParameters(layer, layerIndex, viewport) {
        const pickParameters = {
          ...layer.props.parameters
        };
        const {
          pickable,
          operation
        } = layer.props;
        if (!this._colorEncoderState) {
          pickParameters.blend = false;
        } else if (pickable && operation.includes("draw")) {
          Object.assign(pickParameters, PICKING_PARAMETERS);
          pickParameters.blend = true;
          pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
        }
        if (operation.includes("terrain")) {
          pickParameters.blend = false;
        }
        return pickParameters;
      }
      _resetColorEncoder(pickZ) {
        this._colorEncoderState = pickZ ? null : {
          byLayer: /* @__PURE__ */ new Map(),
          byAlpha: []
        };
        return this._colorEncoderState;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js
var LIFECYCLE, COMPONENT_SYMBOL, PROP_TYPES_SYMBOL, DEPRECATED_PROPS_SYMBOL, ASYNC_DEFAULTS_SYMBOL, ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL;
var init_constants3 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"() {
    LIFECYCLE = {
      NO_STATE: "Awaiting state",
      MATCHED: "Matched. State transferred from previous layer",
      INITIALIZED: "Initialized",
      AWAITING_GC: "Discarded. Awaiting garbage collection",
      AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
      FINALIZED: "Finalized! Awaiting garbage collection"
    };
    COMPONENT_SYMBOL = Symbol.for("component");
    PROP_TYPES_SYMBOL = Symbol.for("propTypes");
    DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
    ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
    ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
    ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/flatten.js
function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }
  return flattenArray(array, filter, []);
}
function flattenArray(array, filter, result) {
  let index = -1;
  while (++index < array.length) {
    const value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }
  return result;
}
function fillArray2({
  target,
  source,
  start = 0,
  count: count2 = 1
}) {
  const length4 = source.length;
  const total = count2 * length4;
  let copied = 0;
  for (let i = start; copied < length4; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
var init_flatten = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/flatten.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js
var Resource2;
var init_resource2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js"() {
    init_defineProperty();
    init_esm7();
    Resource2 = class {
      constructor(id, data, context) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "context", void 0);
        _defineProperty(this, "isLoaded", void 0);
        _defineProperty(this, "persistent", void 0);
        _defineProperty(this, "_loadCount", 0);
        _defineProperty(this, "_subscribers", /* @__PURE__ */ new Set());
        _defineProperty(this, "_data", void 0);
        _defineProperty(this, "_loader", void 0);
        _defineProperty(this, "_error", void 0);
        _defineProperty(this, "_content", void 0);
        this.id = id;
        this.context = context;
        this.setData(data);
      }
      subscribe(consumer) {
        this._subscribers.add(consumer);
      }
      unsubscribe(consumer) {
        this._subscribers.delete(consumer);
      }
      inUse() {
        return this._subscribers.size > 0;
      }
      delete() {
      }
      getData() {
        return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
      }
      setData(data, forceUpdate) {
        if (data === this._data && !forceUpdate) {
          return;
        }
        this._data = data;
        const loadCount = ++this._loadCount;
        let loader = data;
        if (typeof data === "string") {
          loader = load(data);
        }
        if (loader instanceof Promise) {
          this.isLoaded = false;
          this._loader = loader.then((result) => {
            if (this._loadCount === loadCount) {
              this.isLoaded = true;
              this._error = void 0;
              this._content = result;
            }
          }).catch((error2) => {
            if (this._loadCount === loadCount) {
              this.isLoaded = true;
              this._error = error2 || true;
            }
          });
        } else {
          this.isLoaded = true;
          this._error = void 0;
          this._content = data;
        }
        for (const subscriber of this._subscribers) {
          subscriber.onChange(this.getData());
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js
var ResourceManager;
var init_resource_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js"() {
    init_defineProperty();
    init_resource2();
    ResourceManager = class {
      constructor({
        gl,
        protocol
      }) {
        _defineProperty(this, "protocol", void 0);
        _defineProperty(this, "_context", void 0);
        _defineProperty(this, "_resources", void 0);
        _defineProperty(this, "_consumers", void 0);
        _defineProperty(this, "_pruneRequest", void 0);
        this.protocol = protocol || "resource://";
        this._context = {
          gl,
          resourceManager: this
        };
        this._resources = {};
        this._consumers = {};
        this._pruneRequest = null;
      }
      contains(resourceId) {
        if (resourceId.startsWith(this.protocol)) {
          return true;
        }
        return resourceId in this._resources;
      }
      add({
        resourceId,
        data,
        forceUpdate = false,
        persistent = true
      }) {
        let res = this._resources[resourceId];
        if (res) {
          res.setData(data, forceUpdate);
        } else {
          res = new Resource2(resourceId, data, this._context);
          this._resources[resourceId] = res;
        }
        res.persistent = persistent;
      }
      remove(resourceId) {
        const res = this._resources[resourceId];
        if (res) {
          res.delete();
          delete this._resources[resourceId];
        }
      }
      unsubscribe({
        consumerId
      }) {
        const consumer = this._consumers[consumerId];
        if (consumer) {
          for (const requestId in consumer) {
            const request = consumer[requestId];
            const resource = this._resources[request.resourceId];
            if (resource) {
              resource.unsubscribe(request);
            }
          }
          delete this._consumers[consumerId];
          this.prune();
        }
      }
      subscribe({
        resourceId,
        onChange,
        consumerId,
        requestId = "default"
      }) {
        const {
          _resources: resources,
          protocol
        } = this;
        if (resourceId.startsWith(protocol)) {
          resourceId = resourceId.replace(protocol, "");
          if (!resources[resourceId]) {
            this.add({
              resourceId,
              data: null,
              persistent: false
            });
          }
        }
        const res = resources[resourceId];
        this._track(consumerId, requestId, res, onChange);
        if (res) {
          return res.getData();
        }
        return void 0;
      }
      prune() {
        if (!this._pruneRequest) {
          this._pruneRequest = setTimeout(() => this._prune(), 0);
        }
      }
      finalize() {
        for (const key in this._resources) {
          this._resources[key].delete();
        }
      }
      _track(consumerId, requestId, resource, onChange) {
        const consumers = this._consumers;
        const consumer = consumers[consumerId] = consumers[consumerId] || {};
        const request = consumer[requestId] || {};
        const oldResource = request.resourceId && this._resources[request.resourceId];
        if (oldResource) {
          oldResource.unsubscribe(request);
          this.prune();
        }
        if (resource) {
          consumer[requestId] = request;
          request.onChange = onChange;
          request.resourceId = resource.id;
          resource.subscribe(request);
        }
      }
      _prune() {
        this._pruneRequest = null;
        for (const key of Object.keys(this._resources)) {
          const res = this._resources[key];
          if (!res.persistent && !res.inUse()) {
            res.delete();
            delete this._resources[key];
          }
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js
var vs7, project32_default;
var init_project32 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js"() {
    init_project2();
    vs7 = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
    project32_default = {
      name: "project32",
      dependencies: [project_default],
      vs: vs7
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js
var picking_default;
var init_picking2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js"() {
    init_esm14();
    picking_default = {
      inject: {
        "vs:DECKGL_FILTER_GL_POSITION": "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
        "vs:DECKGL_FILTER_COLOR": "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
        "fs:#decl": "\nuniform bool picking_uAttribute;\n  ",
        "fs:DECKGL_FILTER_COLOR": {
          order: 99,
          injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
        }
      },
      ...picking
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/index.js
function createProgramManager(gl) {
  const programManager = ProgramManager.getDefaultProgramManager(gl);
  for (const shaderModule of DEFAULT_MODULES) {
    programManager.addDefaultModule(shaderModule);
  }
  for (const shaderHook of SHADER_HOOKS) {
    programManager.addShaderHook(shaderHook);
  }
  return programManager;
}
var DEFAULT_MODULES, SHADER_HOOKS;
var init_shaderlib = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/index.js"() {
    init_esm14();
    init_esm14();
    init_project2();
    init_project32();
    init_shadow();
    init_picking2();
    DEFAULT_MODULES = [project_default];
    SHADER_HOOKS = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js
var TRACE_SET_LAYERS, TRACE_ACTIVATE_VIEWPORT, LayerManager;
var init_layer_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js"() {
    init_defineProperty();
    init_esm14();
    init_constants3();
    init_log3();
    init_debug();
    init_flatten();
    init_esm3();
    init_resource_manager();
    init_viewport();
    init_shaderlib();
    TRACE_SET_LAYERS = "layerManager.setLayers";
    TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
    LayerManager = class {
      constructor(gl, {
        deck,
        stats,
        viewport: _viewport,
        timeline
      } = {}) {
        _defineProperty(this, "layers", void 0);
        _defineProperty(this, "context", void 0);
        _defineProperty(this, "resourceManager", void 0);
        _defineProperty(this, "_lastRenderedLayers", []);
        _defineProperty(this, "_needsRedraw", false);
        _defineProperty(this, "_needsUpdate", false);
        _defineProperty(this, "_nextLayers", null);
        _defineProperty(this, "_debug", false);
        _defineProperty(this, "activateViewport", (viewport) => {
          debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
          if (viewport) {
            this.context.viewport = viewport;
          }
        });
        this.layers = [];
        this.resourceManager = new ResourceManager({
          gl,
          protocol: "deck://"
        });
        this.context = {
          mousePosition: null,
          userData: {},
          layerManager: this,
          gl,
          deck,
          programManager: gl && createProgramManager(gl),
          stats: stats || new Stats({
            id: "deck.gl"
          }),
          viewport: _viewport || new Viewport({
            id: "DEFAULT-INITIAL-VIEWPORT"
          }),
          timeline: timeline || new Timeline(),
          resourceManager: this.resourceManager,
          onError: void 0
        };
        Object.seal(this);
      }
      finalize() {
        this.resourceManager.finalize();
        for (const layer of this.layers) {
          this._finalizeLayer(layer);
        }
      }
      needsRedraw(opts = {
        clearRedrawFlags: false
      }) {
        let redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        for (const layer of this.layers) {
          const layerNeedsRedraw = layer.getNeedsRedraw(opts);
          redraw = redraw || layerNeedsRedraw;
        }
        return redraw;
      }
      needsUpdate() {
        if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
          return "layers changed";
        }
        return this._needsUpdate;
      }
      setNeedsRedraw(reason) {
        this._needsRedraw = this._needsRedraw || reason;
      }
      setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
      }
      getLayers({
        layerIds
      } = {}) {
        return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
      }
      setProps(props) {
        if ("debug" in props) {
          this._debug = props.debug;
        }
        if ("userData" in props) {
          this.context.userData = props.userData;
        }
        if ("layers" in props) {
          this._nextLayers = props.layers;
        }
        if ("onError" in props) {
          this.context.onError = props.onError;
        }
      }
      setLayers(newLayers, reason) {
        debug(TRACE_SET_LAYERS, this, reason, newLayers);
        this._lastRenderedLayers = newLayers;
        const flatLayers = flatten(newLayers, Boolean);
        for (const layer of flatLayers) {
          layer.context = this.context;
        }
        this._updateLayers(this.layers, flatLayers);
      }
      updateLayers() {
        const reason = this.needsUpdate();
        if (reason) {
          this.setNeedsRedraw("updating layers: ".concat(reason));
          this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
        }
        this._nextLayers = null;
      }
      _handleError(stage, error2, layer) {
        layer.raiseError(error2, "".concat(stage, " of ").concat(layer));
      }
      _updateLayers(oldLayers, newLayers) {
        const oldLayerMap = {};
        for (const oldLayer of oldLayers) {
          if (oldLayerMap[oldLayer.id]) {
            log_default.warn("Multiple old layers with same id ".concat(oldLayer.id))();
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }
        const generatedLayers = [];
        this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
        this._finalizeOldLayers(oldLayerMap);
        let needsUpdate = false;
        for (const layer of generatedLayers) {
          if (layer.hasUniformTransition()) {
            needsUpdate = "Uniform transition in ".concat(layer);
            break;
          }
        }
        this._needsUpdate = needsUpdate;
        this.layers = generatedLayers;
      }
      _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
        for (const newLayer of newLayers) {
          newLayer.context = this.context;
          const oldLayer = oldLayerMap[newLayer.id];
          if (oldLayer === null) {
            log_default.warn("Multiple new layers with same id ".concat(newLayer.id))();
          }
          oldLayerMap[newLayer.id] = null;
          let sublayers = null;
          try {
            if (this._debug && oldLayer !== newLayer) {
              newLayer.validateProps();
            }
            if (!oldLayer) {
              this._initializeLayer(newLayer);
            } else {
              this._transferLayerState(oldLayer, newLayer);
              this._updateLayer(newLayer);
            }
            generatedLayers.push(newLayer);
            sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
          } catch (err) {
            this._handleError("matching", err, newLayer);
          }
          if (sublayers) {
            this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
          }
        }
      }
      _finalizeOldLayers(oldLayerMap) {
        for (const layerId in oldLayerMap) {
          const layer = oldLayerMap[layerId];
          if (layer) {
            this._finalizeLayer(layer);
          }
        }
      }
      _initializeLayer(layer) {
        try {
          layer._initialize();
          layer.lifecycle = LIFECYCLE.INITIALIZED;
        } catch (err) {
          this._handleError("initialization", err, layer);
        }
      }
      _transferLayerState(oldLayer, newLayer) {
        newLayer._transferState(oldLayer);
        newLayer.lifecycle = LIFECYCLE.MATCHED;
        if (newLayer !== oldLayer) {
          oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
        }
      }
      _updateLayer(layer) {
        try {
          layer._update();
        } catch (err) {
          this._handleError("update", err, layer);
        }
      }
      _finalizeLayer(layer) {
        this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
        layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
        try {
          layer._finalize();
          layer.lifecycle = LIFECYCLE.FINALIZED;
        } catch (err) {
          this._handleError("finalization", err, layer);
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js
function deepEqual(a, b, depth) {
  if (a === b) {
    return true;
  }
  if (!depth || !a || !b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b)) {
    return false;
  }
  if (typeof a === "object" && typeof b === "object") {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a[key], b[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var init_deep_equal = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/view-manager.js
var ViewManager;
var init_view_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/view-manager.js"() {
    init_defineProperty();
    init_deep_equal();
    init_log3();
    init_flatten();
    ViewManager = class {
      constructor(props) {
        _defineProperty(this, "width", void 0);
        _defineProperty(this, "height", void 0);
        _defineProperty(this, "views", void 0);
        _defineProperty(this, "viewState", void 0);
        _defineProperty(this, "controllers", void 0);
        _defineProperty(this, "timeline", void 0);
        _defineProperty(this, "_viewports", void 0);
        _defineProperty(this, "_viewportMap", void 0);
        _defineProperty(this, "_isUpdating", void 0);
        _defineProperty(this, "_needsRedraw", void 0);
        _defineProperty(this, "_needsUpdate", void 0);
        _defineProperty(this, "_eventManager", void 0);
        _defineProperty(this, "_eventCallbacks", void 0);
        this.views = [];
        this.width = 100;
        this.height = 100;
        this.viewState = {};
        this.controllers = {};
        this.timeline = props.timeline;
        this._viewports = [];
        this._viewportMap = {};
        this._isUpdating = false;
        this._needsRedraw = "First render";
        this._needsUpdate = "Initialize";
        this._eventManager = props.eventManager;
        this._eventCallbacks = {
          onViewStateChange: props.onViewStateChange,
          onInteractionStateChange: props.onInteractionStateChange
        };
        Object.seal(this);
        this.setProps(props);
      }
      finalize() {
        for (const key in this.controllers) {
          const controller = this.controllers[key];
          if (controller) {
            controller.finalize();
          }
        }
        this.controllers = {};
      }
      needsRedraw(opts = {
        clearRedrawFlags: false
      }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        return redraw;
      }
      setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
        this._needsRedraw = this._needsRedraw || reason;
      }
      updateViewStates() {
        for (const viewId in this.controllers) {
          const controller = this.controllers[viewId];
          if (controller) {
            controller.updateTransition();
          }
        }
      }
      getViewports(rect) {
        if (rect) {
          return this._viewports.filter((viewport) => viewport.containsPixel(rect));
        }
        return this._viewports;
      }
      getViews() {
        const viewMap = {};
        this.views.forEach((view) => {
          viewMap[view.id] = view;
        });
        return viewMap;
      }
      getView(viewId) {
        return this.views.find((view) => view.id === viewId);
      }
      getViewState(viewOrViewId) {
        const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
        const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
        return view ? view.filterViewState(viewState) : viewState;
      }
      getViewport(viewId) {
        return this._viewportMap[viewId];
      }
      unproject(xyz, opts) {
        const viewports = this.getViewports();
        const pixel = {
          x: xyz[0],
          y: xyz[1]
        };
        for (let i = viewports.length - 1; i >= 0; --i) {
          const viewport = viewports[i];
          if (viewport.containsPixel(pixel)) {
            const p = xyz.slice();
            p[0] -= viewport.x;
            p[1] -= viewport.y;
            return viewport.unproject(p, opts);
          }
        }
        return null;
      }
      setProps(props) {
        if (props.views) {
          this._setViews(props.views);
        }
        if (props.viewState) {
          this._setViewState(props.viewState);
        }
        if ("width" in props || "height" in props) {
          this._setSize(props.width, props.height);
        }
        if (!this._isUpdating) {
          this._update();
        }
      }
      _update() {
        this._isUpdating = true;
        if (this._needsUpdate) {
          this._needsUpdate = false;
          this._rebuildViewports();
        }
        if (this._needsUpdate) {
          this._needsUpdate = false;
          this._rebuildViewports();
        }
        this._isUpdating = false;
      }
      _setSize(width, height) {
        if (width !== this.width || height !== this.height) {
          this.width = width;
          this.height = height;
          this.setNeedsUpdate("Size changed");
        }
      }
      _setViews(views) {
        views = flatten(views, Boolean);
        const viewsChanged = this._diffViews(views, this.views);
        if (viewsChanged) {
          this.setNeedsUpdate("views changed");
        }
        this.views = views;
      }
      _setViewState(viewState) {
        if (viewState) {
          const viewStateChanged = !deepEqual(viewState, this.viewState, 3);
          if (viewStateChanged) {
            this.setNeedsUpdate("viewState changed");
          }
          this.viewState = viewState;
        } else {
          log_default.warn("missing `viewState` or `initialViewState`")();
        }
      }
      _onViewStateChange(viewId, event) {
        if (this._eventCallbacks.onViewStateChange) {
          this._eventCallbacks.onViewStateChange({
            ...event,
            viewId
          });
        }
      }
      _createController(view, props) {
        const Controller2 = props.type;
        const controller = new Controller2({
          timeline: this.timeline,
          eventManager: this._eventManager,
          onViewStateChange: this._onViewStateChange.bind(this, props.id),
          onStateChange: this._eventCallbacks.onInteractionStateChange,
          makeViewport: (viewState) => {
            var _this$getView;
            return (_this$getView = this.getView(view.id)) === null || _this$getView === void 0 ? void 0 : _this$getView.makeViewport({
              viewState,
              width: this.width,
              height: this.height
            });
          }
        });
        return controller;
      }
      _updateController(view, viewState, viewport, controller) {
        const controllerProps = view.controller;
        if (controllerProps && viewport) {
          const resolvedProps = {
            ...viewState,
            ...controllerProps,
            id: view.id,
            x: viewport.x,
            y: viewport.y,
            width: viewport.width,
            height: viewport.height
          };
          if (!controller) {
            controller = this._createController(view, resolvedProps);
          }
          if (controller) {
            controller.setProps(resolvedProps);
          }
          return controller;
        }
        return null;
      }
      _rebuildViewports() {
        const {
          views
        } = this;
        const oldControllers = this.controllers;
        this._viewports = [];
        this.controllers = {};
        let invalidateControllers = false;
        for (let i = views.length; i--; ) {
          const view = views[i];
          const viewState = this.getViewState(view);
          const viewport = view.makeViewport({
            viewState,
            width: this.width,
            height: this.height
          });
          let oldController = oldControllers[view.id];
          const hasController = Boolean(view.controller);
          if (hasController && !oldController) {
            invalidateControllers = true;
          }
          if ((invalidateControllers || !hasController) && oldController) {
            oldController.finalize();
            oldController = null;
          }
          this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
          if (viewport) {
            this._viewports.unshift(viewport);
          }
        }
        for (const id in oldControllers) {
          const oldController = oldControllers[id];
          if (oldController && !this.controllers[id]) {
            oldController.finalize();
          }
        }
        this._buildViewportMap();
      }
      _buildViewportMap() {
        this._viewportMap = {};
        this._viewports.forEach((viewport) => {
          if (viewport.id) {
            this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
          }
        });
      }
      _diffViews(newViews, oldViews) {
        if (newViews.length !== oldViews.length) {
          return true;
        }
        return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/positions.js
function parsePosition(value) {
  switch (typeof value) {
    case "number":
      return {
        position: value,
        relative: false
      };
    case "string":
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);
      if (match && match.length >= 3) {
        const relative = match[2] === "%";
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}
var PERCENT_OR_PIXELS_REGEX;
var init_positions = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/positions.js"() {
    PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/assert.js
function assert9(condition, message) {
  if (!condition) {
    throw new Error(message || "deck.gl: assertion failed.");
  }
}
var init_assert9 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/views/view.js
var View;
var init_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/view.js"() {
    init_defineProperty();
    init_viewport();
    init_positions();
    init_deep_equal();
    init_assert9();
    View = class {
      constructor(props) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "viewportInstance", void 0);
        _defineProperty(this, "_x", void 0);
        _defineProperty(this, "_y", void 0);
        _defineProperty(this, "_width", void 0);
        _defineProperty(this, "_height", void 0);
        _defineProperty(this, "_padding", void 0);
        _defineProperty(this, "props", void 0);
        const {
          id,
          x = 0,
          y = 0,
          width = "100%",
          height = "100%",
          padding = null,
          viewportInstance
        } = props || {};
        assert9(!viewportInstance || viewportInstance instanceof Viewport);
        this.viewportInstance = viewportInstance;
        this.id = id || this.constructor.displayName || "view";
        this.props = {
          ...props,
          id: this.id
        };
        this._x = parsePosition(x);
        this._y = parsePosition(y);
        this._width = parsePosition(width);
        this._height = parsePosition(height);
        this._padding = padding && {
          left: parsePosition(padding.left || 0),
          right: parsePosition(padding.right || 0),
          top: parsePosition(padding.top || 0),
          bottom: parsePosition(padding.bottom || 0)
        };
        this.equals = this.equals.bind(this);
        Object.seal(this);
      }
      equals(view) {
        if (this === view) {
          return true;
        }
        if (this.viewportInstance) {
          return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
        }
        return this.ViewportType === view.ViewportType && deepEqual(this.props, view.props, 2);
      }
      makeViewport({
        width,
        height,
        viewState
      }) {
        if (this.viewportInstance) {
          return this.viewportInstance;
        }
        viewState = this.filterViewState(viewState);
        const viewportDimensions = this.getDimensions({
          width,
          height
        });
        if (!viewportDimensions.height || !viewportDimensions.width) {
          return null;
        }
        return new this.ViewportType({
          ...viewState,
          ...this.props,
          ...viewportDimensions
        });
      }
      getViewStateId() {
        const {
          viewState
        } = this.props;
        if (typeof viewState === "string") {
          return viewState;
        }
        return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
      }
      filterViewState(viewState) {
        if (this.props.viewState && typeof this.props.viewState === "object") {
          if (!this.props.viewState.id) {
            return this.props.viewState;
          }
          const newViewState = {
            ...viewState
          };
          for (const key in this.props.viewState) {
            if (key !== "id") {
              newViewState[key] = this.props.viewState[key];
            }
          }
          return newViewState;
        }
        return viewState;
      }
      getDimensions({
        width,
        height
      }) {
        const dimensions = {
          x: getPosition(this._x, width),
          y: getPosition(this._y, height),
          width: getPosition(this._width, width),
          height: getPosition(this._height, height)
        };
        if (this._padding) {
          dimensions.padding = {
            left: getPosition(this._padding.left, width),
            top: getPosition(this._padding.top, height),
            right: getPosition(this._padding.right, width),
            bottom: getPosition(this._padding.bottom, height)
          };
        }
        return dimensions;
      }
      get controller() {
        const opts = this.props.controller;
        if (!opts) {
          return null;
        }
        if (opts === true) {
          return {
            type: this.ControllerType
          };
        }
        if (typeof opts === "function") {
          return {
            type: opts
          };
        }
        return {
          type: this.ControllerType,
          ...opts
        };
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/transition.js
var Transition;
var init_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/transition.js"() {
    init_defineProperty();
    Transition = class {
      constructor(timeline) {
        _defineProperty(this, "_inProgress", void 0);
        _defineProperty(this, "_handle", void 0);
        _defineProperty(this, "_timeline", void 0);
        _defineProperty(this, "time", void 0);
        _defineProperty(this, "settings", void 0);
        this._inProgress = false;
        this._handle = null;
        this._timeline = timeline;
        this.time = 0;
        this.settings = {
          duration: 0
        };
      }
      get inProgress() {
        return this._inProgress;
      }
      start(settings) {
        var _this$settings$onStar, _this$settings;
        this.cancel();
        this.settings = settings;
        this._inProgress = true;
        (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 ? void 0 : _this$settings$onStar.call(_this$settings, this);
      }
      end() {
        if (this._inProgress) {
          var _this$settings$onEnd, _this$settings2;
          this._timeline.removeChannel(this._handle);
          this._handle = null;
          this._inProgress = false;
          (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 ? void 0 : _this$settings$onEnd.call(_this$settings2, this);
        }
      }
      cancel() {
        if (this._inProgress) {
          var _this$settings$onInte, _this$settings3;
          (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 ? void 0 : _this$settings$onInte.call(_this$settings3, this);
          this._timeline.removeChannel(this._handle);
          this._handle = null;
          this._inProgress = false;
        }
      }
      update() {
        var _this$settings$onUpda, _this$settings4;
        if (!this._inProgress) {
          return false;
        }
        if (this._handle === null) {
          const {
            _timeline: timeline,
            settings
          } = this;
          this._handle = timeline.addChannel({
            delay: timeline.getTime(),
            duration: settings.duration
          });
        }
        this.time = this._timeline.getTime(this._handle);
        this._onUpdate();
        (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 ? void 0 : _this$settings$onUpda.call(_this$settings4, this);
        if (this._timeline.isFinished(this._handle)) {
          this.end();
        }
        return true;
      }
      _onUpdate() {
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js
var noop2, TRANSITION_EVENTS, DEFAULT_EASING, DEFAULT_INTERRUPTION, TransitionManager;
var init_transition_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js"() {
    init_defineProperty();
    init_transition();
    noop2 = () => {
    };
    TRANSITION_EVENTS = {
      BREAK: 1,
      SNAP_TO_END: 2,
      IGNORE: 3
    };
    DEFAULT_EASING = (t) => t;
    DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
    TransitionManager = class {
      constructor(opts) {
        _defineProperty(this, "getControllerState", void 0);
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "propsInTransition", void 0);
        _defineProperty(this, "transition", void 0);
        _defineProperty(this, "onViewStateChange", void 0);
        _defineProperty(this, "onStateChange", void 0);
        _defineProperty(this, "_onTransitionUpdate", (transition) => {
          const {
            time,
            settings: {
              interpolator,
              startProps,
              endProps,
              duration,
              easing
            }
          } = transition;
          const t = easing(time / duration);
          const viewport = interpolator.interpolateProps(startProps, endProps, t);
          this.propsInTransition = this.getControllerState({
            ...this.props,
            ...viewport
          }).getViewportProps();
          this.onViewStateChange({
            viewState: this.propsInTransition,
            oldViewState: this.props
          });
        });
        this.getControllerState = opts.getControllerState;
        this.propsInTransition = null;
        this.transition = new Transition(opts.timeline);
        this.onViewStateChange = opts.onViewStateChange || noop2;
        this.onStateChange = opts.onStateChange || noop2;
      }
      finalize() {
        this.transition.cancel();
      }
      getViewportInTransition() {
        return this.propsInTransition;
      }
      processViewStateChange(nextProps) {
        let transitionTriggered = false;
        const currentProps = this.props;
        this.props = nextProps;
        if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
          return false;
        }
        if (this._isTransitionEnabled(nextProps)) {
          let startProps = currentProps;
          if (this.transition.inProgress) {
            const {
              interruption,
              endProps
            } = this.transition.settings;
            startProps = {
              ...currentProps,
              ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
            };
          }
          this._triggerTransition(startProps, nextProps);
          transitionTriggered = true;
        } else {
          this.transition.cancel();
        }
        return transitionTriggered;
      }
      updateTransition() {
        this.transition.update();
      }
      _isTransitionEnabled(props) {
        const {
          transitionDuration,
          transitionInterpolator
        } = props;
        return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
      }
      _isUpdateDueToCurrentTransition(props) {
        if (this.transition.inProgress && this.propsInTransition) {
          return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
        }
        return false;
      }
      _shouldIgnoreViewportChange(currentProps, nextProps) {
        if (this.transition.inProgress) {
          return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
        }
        if (this._isTransitionEnabled(nextProps)) {
          return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
        }
        return true;
      }
      _triggerTransition(startProps, endProps) {
        const startViewstate = this.getControllerState(startProps);
        const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
        const transitionInterpolator = endProps.transitionInterpolator;
        const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
        if (duration === 0) {
          return;
        }
        const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
        this.propsInTransition = {};
        const transitionSettings = {
          duration,
          easing: endProps.transitionEasing || DEFAULT_EASING,
          interpolator: transitionInterpolator,
          interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
          startProps: initialProps.start,
          endProps: initialProps.end,
          onStart: endProps.onTransitionStart,
          onUpdate: this._onTransitionUpdate,
          onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
          onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
        };
        this.transition.start(transitionSettings);
        this.onStateChange({
          inTransition: true
        });
        this.updateTransition();
      }
      _onTransitionEnd(callback) {
        return (transition) => {
          this.propsInTransition = null;
          this.onStateChange({
            inTransition: false,
            isZooming: false,
            isPanning: false,
            isRotating: false
          });
          callback === null || callback === void 0 ? void 0 : callback(transition);
        };
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js
var TransitionInterpolator;
var init_transition_interpolator = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js"() {
    init_defineProperty();
    init_esm11();
    init_assert9();
    TransitionInterpolator = class {
      constructor(opts) {
        _defineProperty(this, "_propsToCompare", void 0);
        _defineProperty(this, "_propsToExtract", void 0);
        _defineProperty(this, "_requiredProps", void 0);
        const {
          compare,
          extract,
          required
        } = opts;
        this._propsToCompare = compare;
        this._propsToExtract = extract || compare;
        this._requiredProps = required;
      }
      arePropsEqual(currentProps, nextProps) {
        for (const key of this._propsToCompare) {
          if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
            return false;
          }
        }
        return true;
      }
      initializeProps(startProps, endProps) {
        const startViewStateProps = {};
        const endViewStateProps = {};
        for (const key of this._propsToExtract) {
          if (key in startProps || key in endProps) {
            startViewStateProps[key] = startProps[key];
            endViewStateProps[key] = endProps[key];
          }
        }
        this._checkRequiredProps(startViewStateProps);
        this._checkRequiredProps(endViewStateProps);
        return {
          start: startViewStateProps,
          end: endViewStateProps
        };
      }
      getDuration(startProps, endProps) {
        return endProps.transitionDuration;
      }
      _checkRequiredProps(props) {
        if (!this._requiredProps) {
          return;
        }
        this._requiredProps.forEach((propName) => {
          const value = props[propName];
          assert9(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
        });
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js
var DEFAULT_PROPS3, DEFAULT_REQUIRED_PROPS, LinearInterpolator;
var init_linear_interpolator = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"() {
    init_defineProperty();
    init_transition_interpolator();
    init_esm11();
    DEFAULT_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
    DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
    LinearInterpolator = class extends TransitionInterpolator {
      constructor(opts = {}) {
        const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
        const normalizedOpts = Array.isArray(opts) ? {} : opts;
        normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
          compare: transitionProps,
          required: transitionProps
        } : transitionProps || {
          compare: DEFAULT_PROPS3,
          required: DEFAULT_REQUIRED_PROPS
        };
        super(normalizedOpts.transitionProps);
        _defineProperty(this, "opts", void 0);
        this.opts = normalizedOpts;
      }
      initializeProps(startProps, endProps) {
        const result = super.initializeProps(startProps, endProps);
        const {
          makeViewport,
          around
        } = this.opts;
        if (makeViewport && around) {
          const startViewport = makeViewport(startProps);
          const endViewport = makeViewport(endProps);
          const aroundPosition = startViewport.unproject(around);
          result.start.around = around;
          Object.assign(result.end, {
            around: endViewport.project(aroundPosition),
            aroundPosition,
            width: endProps.width,
            height: endProps.height
          });
        }
        return result;
      }
      interpolateProps(startProps, endProps, t) {
        const propsInTransition = {};
        for (const key of this._propsToExtract) {
          propsInTransition[key] = lerp3(startProps[key] || 0, endProps[key] || 0, t);
        }
        if (endProps.aroundPosition && this.opts.makeViewport) {
          const viewport = this.opts.makeViewport({
            ...endProps,
            ...propsInTransition
          });
          Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, lerp3(startProps.around, endProps.around, t)));
        }
        return propsInTransition;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/controller.js
var NO_TRANSITION_PROPS, DEFAULT_INERTIA, INERTIA_EASING, EVENT_TYPES, pinchEventWorkaround, Controller;
var init_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/controller.js"() {
    init_defineProperty();
    init_transition_manager();
    init_linear_interpolator();
    NO_TRANSITION_PROPS = {
      transitionDuration: 0
    };
    DEFAULT_INERTIA = 300;
    INERTIA_EASING = (t) => 1 - (1 - t) * (1 - t);
    EVENT_TYPES = {
      WHEEL: ["wheel"],
      PAN: ["panstart", "panmove", "panend"],
      PINCH: ["pinchstart", "pinchmove", "pinchend"],
      TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
      DOUBLE_TAP: ["doubletap"],
      KEYBOARD: ["keydown"]
    };
    pinchEventWorkaround = {};
    Controller = class {
      constructor(opts) {
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "state", {});
        _defineProperty(this, "transitionManager", void 0);
        _defineProperty(this, "eventManager", void 0);
        _defineProperty(this, "onViewStateChange", void 0);
        _defineProperty(this, "onStateChange", void 0);
        _defineProperty(this, "makeViewport", void 0);
        _defineProperty(this, "_controllerState", void 0);
        _defineProperty(this, "_events", {});
        _defineProperty(this, "_interactionState", {
          isDragging: false
        });
        _defineProperty(this, "_customEvents", []);
        _defineProperty(this, "_eventStartBlocked", null);
        _defineProperty(this, "_panMove", false);
        _defineProperty(this, "invertPan", false);
        _defineProperty(this, "dragMode", "rotate");
        _defineProperty(this, "inertia", 0);
        _defineProperty(this, "scrollZoom", true);
        _defineProperty(this, "dragPan", true);
        _defineProperty(this, "dragRotate", true);
        _defineProperty(this, "doubleClickZoom", true);
        _defineProperty(this, "touchZoom", true);
        _defineProperty(this, "touchRotate", false);
        _defineProperty(this, "keyboard", true);
        this.transitionManager = new TransitionManager({
          ...opts,
          getControllerState: (props) => new this.ControllerState(props),
          onViewStateChange: this._onTransition.bind(this),
          onStateChange: this._setInteractionState.bind(this)
        });
        this.handleEvent = this.handleEvent.bind(this);
        this.eventManager = opts.eventManager;
        this.onViewStateChange = opts.onViewStateChange || (() => {
        });
        this.onStateChange = opts.onStateChange || (() => {
        });
        this.makeViewport = opts.makeViewport;
      }
      set events(customEvents) {
        this.toggleEvents(this._customEvents, false);
        this.toggleEvents(customEvents, true);
        this._customEvents = customEvents;
        if (this.props) {
          this.setProps(this.props);
        }
      }
      finalize() {
        for (const eventName in this._events) {
          if (this._events[eventName]) {
            var _this$eventManager;
            (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);
          }
        }
        this.transitionManager.finalize();
      }
      handleEvent(event) {
        this._controllerState = void 0;
        const eventStartBlocked = this._eventStartBlocked;
        switch (event.type) {
          case "panstart":
            return eventStartBlocked ? false : this._onPanStart(event);
          case "panmove":
            return this._onPan(event);
          case "panend":
            return this._onPanEnd(event);
          case "pinchstart":
            return eventStartBlocked ? false : this._onPinchStart(event);
          case "pinchmove":
            return this._onPinch(event);
          case "pinchend":
            return this._onPinchEnd(event);
          case "tripanstart":
            return eventStartBlocked ? false : this._onTriplePanStart(event);
          case "tripanmove":
            return this._onTriplePan(event);
          case "tripanend":
            return this._onTriplePanEnd(event);
          case "doubletap":
            return this._onDoubleTap(event);
          case "wheel":
            return this._onWheel(event);
          case "keydown":
            return this._onKeyDown(event);
          default:
            return false;
        }
      }
      get controllerState() {
        this._controllerState = this._controllerState || new this.ControllerState({
          makeViewport: this.makeViewport,
          ...this.props,
          ...this.state
        });
        return this._controllerState;
      }
      getCenter(event) {
        const {
          x,
          y
        } = this.props;
        const {
          offsetCenter
        } = event;
        return [offsetCenter.x - x, offsetCenter.y - y];
      }
      isPointInBounds(pos, event) {
        const {
          width,
          height
        } = this.props;
        if (event && event.handled) {
          return false;
        }
        const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
        if (inside && event) {
          event.stopPropagation();
        }
        return inside;
      }
      isFunctionKeyPressed(event) {
        const {
          srcEvent
        } = event;
        return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
      }
      isDragging() {
        return this._interactionState.isDragging || false;
      }
      blockEvents(timeout) {
        const timer = setTimeout(() => {
          if (this._eventStartBlocked === timer) {
            this._eventStartBlocked = null;
          }
        }, timeout);
        this._eventStartBlocked = timer;
      }
      setProps(props) {
        if (props.dragMode) {
          this.dragMode = props.dragMode;
        }
        this.props = props;
        if (!("transitionInterpolator" in props)) {
          props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
        }
        this.transitionManager.processViewStateChange(props);
        const {
          inertia
        } = props;
        this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
        const {
          scrollZoom = true,
          dragPan = true,
          dragRotate = true,
          doubleClickZoom = true,
          touchZoom = true,
          touchRotate = false,
          keyboard = true
        } = props;
        const isInteractive = Boolean(this.onViewStateChange);
        this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
        this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
        this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
        this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
        this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
        this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
        this.scrollZoom = scrollZoom;
        this.dragPan = dragPan;
        this.dragRotate = dragRotate;
        this.doubleClickZoom = doubleClickZoom;
        this.touchZoom = touchZoom;
        this.touchRotate = touchRotate;
        this.keyboard = keyboard;
      }
      updateTransition() {
        this.transitionManager.updateTransition();
      }
      toggleEvents(eventNames, enabled) {
        if (this.eventManager) {
          eventNames.forEach((eventName) => {
            if (this._events[eventName] !== enabled) {
              this._events[eventName] = enabled;
              if (enabled) {
                this.eventManager.on(eventName, this.handleEvent);
              } else {
                this.eventManager.off(eventName, this.handleEvent);
              }
            }
          });
        }
      }
      updateViewport(newControllerState, extraProps = null, interactionState = {}) {
        const viewState = {
          ...newControllerState.getViewportProps(),
          ...extraProps
        };
        const changed = this.controllerState !== newControllerState;
        this.state = newControllerState.getState();
        this._setInteractionState(interactionState);
        if (changed) {
          const oldViewState = this.controllerState && this.controllerState.getViewportProps();
          if (this.onViewStateChange) {
            this.onViewStateChange({
              viewState,
              interactionState: this._interactionState,
              oldViewState
            });
          }
        }
      }
      _onTransition(params) {
        this.onViewStateChange({
          ...params,
          interactionState: this._interactionState
        });
      }
      _setInteractionState(newStates) {
        Object.assign(this._interactionState, newStates);
        this.onStateChange(this._interactionState);
      }
      _onPanStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
        if (this.invertPan || this.dragMode === "pan") {
          alternateMode = !alternateMode;
        }
        const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
          pos
        });
        this._panMove = alternateMode;
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true
        });
        return true;
      }
      _onPan(event) {
        if (!this.isDragging()) {
          return false;
        }
        return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
      }
      _onPanEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
      }
      _onPanMove(event) {
        if (!this.dragPan) {
          return false;
        }
        const pos = this.getCenter(event);
        const newControllerState = this.controllerState.pan({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isPanning: true
        });
        return true;
      }
      _onPanMoveEnd(event) {
        const {
          inertia
        } = this;
        if (this.dragPan && inertia && event.velocity) {
          const pos = this.getCenter(event);
          const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
          const newControllerState = this.controllerState.pan({
            pos: endPos
          }).panEnd();
          this.updateViewport(newControllerState, {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }, {
            isDragging: false,
            isPanning: true
          });
        } else {
          const newControllerState = this.controllerState.panEnd();
          this.updateViewport(newControllerState, null, {
            isDragging: false,
            isPanning: false
          });
        }
        return true;
      }
      _onPanRotate(event) {
        if (!this.dragRotate) {
          return false;
        }
        const pos = this.getCenter(event);
        const newControllerState = this.controllerState.rotate({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isRotating: true
        });
        return true;
      }
      _onPanRotateEnd(event) {
        const {
          inertia
        } = this;
        if (this.dragRotate && inertia && event.velocity) {
          const pos = this.getCenter(event);
          const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
          const newControllerState = this.controllerState.rotate({
            pos: endPos
          }).rotateEnd();
          this.updateViewport(newControllerState, {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }, {
            isDragging: false,
            isRotating: true
          });
        } else {
          const newControllerState = this.controllerState.rotateEnd();
          this.updateViewport(newControllerState, null, {
            isDragging: false,
            isRotating: false
          });
        }
        return true;
      }
      _onWheel(event) {
        if (!this.scrollZoom) {
          return false;
        }
        event.srcEvent.preventDefault();
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        const {
          speed = 0.01,
          smooth = false
        } = this.scrollZoom === true ? {} : this.scrollZoom;
        const {
          delta
        } = event;
        let scale5 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
        if (delta < 0 && scale5 !== 0) {
          scale5 = 1 / scale5;
        }
        const newControllerState = this.controllerState.zoom({
          pos,
          scale: scale5
        });
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps({
            around: pos
          }),
          transitionDuration: smooth ? 250 : 1
        }, {
          isZooming: true,
          isPanning: true
        });
        return true;
      }
      _onTriplePanStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        const newControllerState = this.controllerState.rotateStart({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true
        });
        return true;
      }
      _onTriplePan(event) {
        if (!this.touchRotate) {
          return false;
        }
        if (!this.isDragging()) {
          return false;
        }
        const pos = this.getCenter(event);
        pos[0] -= event.deltaX;
        const newControllerState = this.controllerState.rotate({
          pos
        });
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isRotating: true
        });
        return true;
      }
      _onTriplePanEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        const {
          inertia
        } = this;
        if (this.touchRotate && inertia && event.velocityY) {
          const pos = this.getCenter(event);
          const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
          const newControllerState = this.controllerState.rotate({
            pos: endPos
          });
          this.updateViewport(newControllerState, {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }, {
            isDragging: false,
            isRotating: true
          });
          this.blockEvents(inertia);
        } else {
          const newControllerState = this.controllerState.rotateEnd();
          this.updateViewport(newControllerState, null, {
            isDragging: false,
            isRotating: false
          });
        }
        return true;
      }
      _onPinchStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        const newControllerState = this.controllerState.zoomStart({
          pos
        }).rotateStart({
          pos
        });
        pinchEventWorkaround._startPinchRotation = event.rotation;
        pinchEventWorkaround._lastPinchEvent = event;
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true
        });
        return true;
      }
      _onPinch(event) {
        if (!this.touchZoom && !this.touchRotate) {
          return false;
        }
        if (!this.isDragging()) {
          return false;
        }
        let newControllerState = this.controllerState;
        if (this.touchZoom) {
          const {
            scale: scale5
          } = event;
          const pos = this.getCenter(event);
          newControllerState = newControllerState.zoom({
            pos,
            scale: scale5
          });
        }
        if (this.touchRotate) {
          const {
            rotation
          } = event;
          newControllerState = newControllerState.rotate({
            deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
          });
        }
        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
          isDragging: true,
          isPanning: this.touchZoom,
          isZooming: this.touchZoom,
          isRotating: this.touchRotate
        });
        pinchEventWorkaround._lastPinchEvent = event;
        return true;
      }
      _onPinchEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        const {
          inertia
        } = this;
        const {
          _lastPinchEvent
        } = pinchEventWorkaround;
        if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
          const pos = this.getCenter(event);
          let newControllerState = this.controllerState.rotateEnd();
          const z = Math.log2(event.scale);
          const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
          const endScale = Math.pow(2, z + velocityZ * inertia / 2);
          newControllerState = newControllerState.zoom({
            pos,
            scale: endScale
          }).zoomEnd();
          this.updateViewport(newControllerState, {
            ...this._getTransitionProps({
              around: pos
            }),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          }, {
            isDragging: false,
            isPanning: this.touchZoom,
            isZooming: this.touchZoom,
            isRotating: false
          });
          this.blockEvents(inertia);
        } else {
          const newControllerState = this.controllerState.zoomEnd().rotateEnd();
          this.updateViewport(newControllerState, null, {
            isDragging: false,
            isPanning: false,
            isZooming: false,
            isRotating: false
          });
        }
        pinchEventWorkaround._startPinchRotation = null;
        pinchEventWorkaround._lastPinchEvent = null;
        return true;
      }
      _onDoubleTap(event) {
        if (!this.doubleClickZoom) {
          return false;
        }
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) {
          return false;
        }
        const isZoomOut = this.isFunctionKeyPressed(event);
        const newControllerState = this.controllerState.zoom({
          pos,
          scale: isZoomOut ? 0.5 : 2
        });
        this.updateViewport(newControllerState, this._getTransitionProps({
          around: pos
        }), {
          isZooming: true,
          isPanning: true
        });
        this.blockEvents(100);
        return true;
      }
      _onKeyDown(event) {
        if (!this.keyboard) {
          return false;
        }
        const funcKey = this.isFunctionKeyPressed(event);
        const {
          zoomSpeed,
          moveSpeed,
          rotateSpeedX,
          rotateSpeedY
        } = this.keyboard === true ? {} : this.keyboard;
        const {
          controllerState
        } = this;
        let newControllerState;
        const interactionState = {};
        switch (event.srcEvent.code) {
          case "Minus":
            newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
            interactionState.isZooming = true;
            break;
          case "Equal":
            newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
            interactionState.isZooming = true;
            break;
          case "ArrowLeft":
            if (funcKey) {
              newControllerState = controllerState.rotateLeft(rotateSpeedX);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveLeft(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          case "ArrowRight":
            if (funcKey) {
              newControllerState = controllerState.rotateRight(rotateSpeedX);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveRight(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          case "ArrowUp":
            if (funcKey) {
              newControllerState = controllerState.rotateUp(rotateSpeedY);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveUp(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          case "ArrowDown":
            if (funcKey) {
              newControllerState = controllerState.rotateDown(rotateSpeedY);
              interactionState.isRotating = true;
            } else {
              newControllerState = controllerState.moveDown(moveSpeed);
              interactionState.isPanning = true;
            }
            break;
          default:
            return false;
        }
        this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
        return true;
      }
      _getTransitionProps(opts) {
        const {
          transition
        } = this;
        if (!transition || !transition.transitionInterpolator) {
          return NO_TRANSITION_PROPS;
        }
        return opts ? {
          ...transition,
          transitionInterpolator: new LinearInterpolator({
            ...opts,
            ...transition.transitionInterpolator.opts,
            makeViewport: this.controllerState.makeViewport
          })
        } : transition;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/view-state.js
var ViewState;
var init_view_state = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/view-state.js"() {
    init_defineProperty();
    ViewState = class {
      constructor(props, state) {
        _defineProperty(this, "_viewportProps", void 0);
        _defineProperty(this, "_state", void 0);
        this._viewportProps = this.applyConstraints(props);
        this._state = state;
      }
      getViewportProps() {
        return this._viewportProps;
      }
      getState() {
        return this._state;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js
var PITCH_MOUSE_THRESHOLD, PITCH_ACCEL, MapState, MapController;
var init_map_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js"() {
    init_defineProperty();
    init_esm11();
    init_controller();
    init_view_state();
    init_esm();
    init_assert9();
    init_linear_interpolator();
    PITCH_MOUSE_THRESHOLD = 5;
    PITCH_ACCEL = 1.2;
    MapState = class extends ViewState {
      constructor(options) {
        const {
          width,
          height,
          latitude,
          longitude,
          zoom,
          bearing = 0,
          pitch = 0,
          altitude = 1.5,
          position = [0, 0, 0],
          maxZoom = 20,
          minZoom = 0,
          maxPitch = 60,
          minPitch = 0,
          startPanLngLat,
          startZoomLngLat,
          startRotatePos,
          startBearing,
          startPitch,
          startZoom,
          normalize: normalize4 = true
        } = options;
        assert9(Number.isFinite(longitude));
        assert9(Number.isFinite(latitude));
        assert9(Number.isFinite(zoom));
        super({
          width,
          height,
          latitude,
          longitude,
          zoom,
          bearing,
          pitch,
          altitude,
          maxZoom,
          minZoom,
          maxPitch,
          minPitch,
          normalize: normalize4,
          position
        }, {
          startPanLngLat,
          startZoomLngLat,
          startRotatePos,
          startBearing,
          startPitch,
          startZoom
        });
        _defineProperty(this, "makeViewport", void 0);
        this.makeViewport = options.makeViewport;
      }
      panStart({
        pos
      }) {
        return this._getUpdatedState({
          startPanLngLat: this._unproject(pos)
        });
      }
      pan({
        pos,
        startPos
      }) {
        const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
        if (!startPanLngLat) {
          return this;
        }
        const viewport = this.makeViewport(this.getViewportProps());
        const newProps = viewport.panByPosition(startPanLngLat, pos);
        return this._getUpdatedState(newProps);
      }
      panEnd() {
        return this._getUpdatedState({
          startPanLngLat: null
        });
      }
      rotateStart({
        pos
      }) {
        return this._getUpdatedState({
          startRotatePos: pos,
          startBearing: this.getViewportProps().bearing,
          startPitch: this.getViewportProps().pitch
        });
      }
      rotate({
        pos,
        deltaAngleX = 0,
        deltaAngleY = 0
      }) {
        const {
          startRotatePos,
          startBearing,
          startPitch
        } = this.getState();
        if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
          return this;
        }
        let newRotation;
        if (pos) {
          newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
        } else {
          newRotation = {
            bearing: startBearing + deltaAngleX,
            pitch: startPitch + deltaAngleY
          };
        }
        return this._getUpdatedState(newRotation);
      }
      rotateEnd() {
        return this._getUpdatedState({
          startBearing: null,
          startPitch: null
        });
      }
      zoomStart({
        pos
      }) {
        return this._getUpdatedState({
          startZoomLngLat: this._unproject(pos),
          startZoom: this.getViewportProps().zoom
        });
      }
      zoom({
        pos,
        startPos,
        scale: scale5
      }) {
        let {
          startZoom,
          startZoomLngLat
        } = this.getState();
        if (!startZoomLngLat) {
          startZoom = this.getViewportProps().zoom;
          startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
        }
        if (!startZoomLngLat) {
          return this;
        }
        const {
          maxZoom,
          minZoom
        } = this.getViewportProps();
        let zoom = startZoom + Math.log2(scale5);
        zoom = clamp(zoom, minZoom, maxZoom);
        const zoomedViewport = this.makeViewport({
          ...this.getViewportProps(),
          zoom
        });
        return this._getUpdatedState({
          zoom,
          ...zoomedViewport.panByPosition(startZoomLngLat, pos)
        });
      }
      zoomEnd() {
        return this._getUpdatedState({
          startZoomLngLat: null,
          startZoom: null
        });
      }
      zoomIn(speed = 2) {
        return this._zoomFromCenter(speed);
      }
      zoomOut(speed = 2) {
        return this._zoomFromCenter(1 / speed);
      }
      moveLeft(speed = 100) {
        return this._panFromCenter([speed, 0]);
      }
      moveRight(speed = 100) {
        return this._panFromCenter([-speed, 0]);
      }
      moveUp(speed = 100) {
        return this._panFromCenter([0, speed]);
      }
      moveDown(speed = 100) {
        return this._panFromCenter([0, -speed]);
      }
      rotateLeft(speed = 15) {
        return this._getUpdatedState({
          bearing: this.getViewportProps().bearing - speed
        });
      }
      rotateRight(speed = 15) {
        return this._getUpdatedState({
          bearing: this.getViewportProps().bearing + speed
        });
      }
      rotateUp(speed = 10) {
        return this._getUpdatedState({
          pitch: this.getViewportProps().pitch + speed
        });
      }
      rotateDown(speed = 10) {
        return this._getUpdatedState({
          pitch: this.getViewportProps().pitch - speed
        });
      }
      shortestPathFrom(viewState) {
        const fromProps = viewState.getViewportProps();
        const props = {
          ...this.getViewportProps()
        };
        const {
          bearing,
          longitude
        } = props;
        if (Math.abs(bearing - fromProps.bearing) > 180) {
          props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
        }
        if (Math.abs(longitude - fromProps.longitude) > 180) {
          props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
        }
        return props;
      }
      applyConstraints(props) {
        const {
          maxZoom,
          minZoom,
          zoom
        } = props;
        props.zoom = clamp(zoom, minZoom, maxZoom);
        const {
          maxPitch,
          minPitch,
          pitch
        } = props;
        props.pitch = clamp(pitch, minPitch, maxPitch);
        const {
          normalize: normalize4 = true
        } = props;
        if (normalize4) {
          Object.assign(props, normalizeViewportProps(props));
        }
        return props;
      }
      _zoomFromCenter(scale5) {
        const {
          width,
          height
        } = this.getViewportProps();
        return this.zoom({
          pos: [width / 2, height / 2],
          scale: scale5
        });
      }
      _panFromCenter(offset) {
        const {
          width,
          height
        } = this.getViewportProps();
        return this.pan({
          startPos: [width / 2, height / 2],
          pos: [width / 2 + offset[0], height / 2 + offset[1]]
        });
      }
      _getUpdatedState(newProps) {
        return new this.constructor({
          makeViewport: this.makeViewport,
          ...this.getViewportProps(),
          ...this.getState(),
          ...newProps
        });
      }
      _unproject(pos) {
        const viewport = this.makeViewport(this.getViewportProps());
        return pos && viewport.unproject(pos);
      }
      _getNewRotation(pos, startPos, startPitch, startBearing) {
        const deltaX = pos[0] - startPos[0];
        const deltaY = pos[1] - startPos[1];
        const centerY = pos[1];
        const startY = startPos[1];
        const {
          width,
          height
        } = this.getViewportProps();
        const deltaScaleX = deltaX / width;
        let deltaScaleY = 0;
        if (deltaY > 0) {
          if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
            deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
          }
        } else if (deltaY < 0) {
          if (startY > PITCH_MOUSE_THRESHOLD) {
            deltaScaleY = 1 - centerY / startY;
          }
        }
        deltaScaleY = clamp(deltaScaleY, -1, 1);
        const {
          minPitch,
          maxPitch
        } = this.getViewportProps();
        const bearing = startBearing + 180 * deltaScaleX;
        let pitch = startPitch;
        if (deltaScaleY > 0) {
          pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
        } else if (deltaScaleY < 0) {
          pitch = startPitch - deltaScaleY * (minPitch - startPitch);
        }
        return {
          pitch,
          bearing
        };
      }
    };
    MapController = class extends Controller {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "ControllerState", MapState);
        _defineProperty(this, "transition", {
          transitionDuration: 300,
          transitionInterpolator: new LinearInterpolator({
            transitionProps: {
              compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
              required: ["longitude", "latitude", "zoom"]
            }
          })
        });
        _defineProperty(this, "dragMode", "pan");
      }
      setProps(props) {
        props.position = props.position || [0, 0, 0];
        const oldProps = this.props;
        super.setProps(props);
        const dimensionChanged = !oldProps || oldProps.height !== props.height;
        if (dimensionChanged) {
          this.updateViewport(new this.ControllerState({
            makeViewport: this.makeViewport,
            ...props,
            ...this.state
          }));
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/views/map-view.js
var MapView;
var init_map_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/map-view.js"() {
    init_defineProperty();
    init_view();
    init_web_mercator_viewport();
    init_map_controller();
    MapView = class extends View {
      get ViewportType() {
        return WebMercatorViewport;
      }
      get ControllerType() {
        return MapController;
      }
    };
    _defineProperty(MapView, "displayName", "MapView");
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js
function compareEffects(e1, e2) {
  var _e1$order, _e2$order;
  const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;
  const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;
  return o1 - o2;
}
var DEFAULT_LIGHTING_EFFECT, EffectManager;
var init_effect_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js"() {
    init_defineProperty();
    init_deep_equal();
    init_lighting_effect();
    DEFAULT_LIGHTING_EFFECT = new LightingEffect();
    EffectManager = class {
      constructor() {
        _defineProperty(this, "effects", void 0);
        _defineProperty(this, "_resolvedEffects", []);
        _defineProperty(this, "_defaultEffects", []);
        _defineProperty(this, "_needsRedraw", void 0);
        this.effects = [];
        this._needsRedraw = "Initial render";
        this._setEffects([]);
      }
      addDefaultEffect(effect) {
        const defaultEffects = this._defaultEffects;
        if (!defaultEffects.find((e2) => e2.id === effect.id)) {
          const index = defaultEffects.findIndex((e2) => compareEffects(e2, effect) > 0);
          if (index < 0) {
            defaultEffects.push(effect);
          } else {
            defaultEffects.splice(index, 0, effect);
          }
          this._setEffects(this.effects);
        }
      }
      setProps(props) {
        if ("effects" in props) {
          if (!deepEqual(props.effects, this.effects, 1)) {
            this._setEffects(props.effects);
          }
        }
      }
      needsRedraw(opts = {
        clearRedrawFlags: false
      }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        return redraw;
      }
      getEffects() {
        return this._resolvedEffects;
      }
      _setEffects(effects) {
        const oldEffectsMap = {};
        for (const effect of this.effects) {
          oldEffectsMap[effect.id] = effect;
        }
        const nextEffects = [];
        for (const effect of effects) {
          const oldEffect = oldEffectsMap[effect.id];
          if (oldEffect && oldEffect !== effect) {
            if (oldEffect.setProps) {
              oldEffect.setProps(effect.props);
              nextEffects.push(oldEffect);
            } else {
              oldEffect.cleanup();
              nextEffects.push(effect);
            }
          } else {
            nextEffects.push(effect);
          }
          delete oldEffectsMap[effect.id];
        }
        for (const removedEffectId in oldEffectsMap) {
          oldEffectsMap[removedEffectId].cleanup();
        }
        this.effects = nextEffects;
        this._resolvedEffects = nextEffects.concat(this._defaultEffects);
        if (!effects.some((effect) => effect instanceof LightingEffect)) {
          this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
        }
        this._needsRedraw = "effects changed";
      }
      finalize() {
        for (const effect of this._resolvedEffects) {
          effect.cleanup();
        }
        this.effects.length = 0;
        this._resolvedEffects.length = 0;
        this._defaultEffects.length = 0;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js
var DrawLayersPass;
var init_draw_layers_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js"() {
    init_layers_pass();
    DrawLayersPass = class extends LayersPass {
      shouldDrawLayer(layer) {
        const {
          operation
        } = layer.props;
        return operation.includes("draw") || operation.includes("terrain");
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js
var TRACE_RENDER_LAYERS, DeckRenderer;
var init_deck_renderer = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js"() {
    init_defineProperty();
    init_debug();
    init_draw_layers_pass();
    init_pick_layers_pass();
    init_esm14();
    TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
    DeckRenderer = class {
      constructor(gl) {
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "layerFilter", void 0);
        _defineProperty(this, "drawPickingColors", void 0);
        _defineProperty(this, "drawLayersPass", void 0);
        _defineProperty(this, "pickLayersPass", void 0);
        _defineProperty(this, "renderCount", void 0);
        _defineProperty(this, "_needsRedraw", void 0);
        _defineProperty(this, "renderBuffers", void 0);
        _defineProperty(this, "lastPostProcessEffect", void 0);
        this.gl = gl;
        this.layerFilter = null;
        this.drawPickingColors = false;
        this.drawLayersPass = new DrawLayersPass(gl);
        this.pickLayersPass = new PickLayersPass(gl);
        this.renderCount = 0;
        this._needsRedraw = "Initial render";
        this.renderBuffers = [];
        this.lastPostProcessEffect = null;
      }
      setProps(props) {
        if (this.layerFilter !== props.layerFilter) {
          this.layerFilter = props.layerFilter;
          this._needsRedraw = "layerFilter changed";
        }
        if (this.drawPickingColors !== props.drawPickingColors) {
          this.drawPickingColors = props.drawPickingColors;
          this._needsRedraw = "drawPickingColors changed";
        }
      }
      renderLayers(opts) {
        const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
        const renderOpts = {
          layerFilter: this.layerFilter,
          isPicking: this.drawPickingColors,
          ...opts,
          target: opts.target || Framebuffer.getDefaultFramebuffer(this.gl)
        };
        if (renderOpts.effects) {
          this._preRender(renderOpts.effects, renderOpts);
        }
        const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
        const renderStats = layerPass.render({
          ...renderOpts,
          target: outputBuffer
        });
        if (renderOpts.effects) {
          this._postRender(renderOpts.effects, renderOpts);
        }
        this.renderCount++;
        debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
      }
      needsRedraw(opts = {
        clearRedrawFlags: false
      }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        return redraw;
      }
      finalize() {
        const {
          renderBuffers
        } = this;
        for (const buffer of renderBuffers) {
          buffer.delete();
        }
        renderBuffers.length = 0;
      }
      _preRender(effects, opts) {
        this.lastPostProcessEffect = null;
        opts.preRenderStats = opts.preRenderStats || {};
        for (const effect of effects) {
          opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
          if (effect.postRender) {
            this.lastPostProcessEffect = effect.id;
          }
        }
        if (this.lastPostProcessEffect) {
          this._resizeRenderBuffers();
        }
      }
      _resizeRenderBuffers() {
        const {
          renderBuffers
        } = this;
        if (renderBuffers.length === 0) {
          renderBuffers.push(new Framebuffer(this.gl), new Framebuffer(this.gl));
        }
        for (const buffer of renderBuffers) {
          buffer.resize();
        }
      }
      _postRender(effects, opts) {
        const {
          renderBuffers
        } = this;
        const params = {
          ...opts,
          inputBuffer: renderBuffers[0],
          swapBuffer: renderBuffers[1],
          target: null
        };
        for (const effect of effects) {
          if (effect.postRender) {
            if (effect.id === this.lastPostProcessEffect) {
              params.target = opts.target;
              effect.postRender(this.gl, params);
              break;
            }
            const buffer = effect.postRender(this.gl, params);
            params.inputBuffer = buffer;
            params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
          }
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js
function getClosestObject({
  pickedColors,
  decodePickingColor,
  deviceX,
  deviceY,
  deviceRadius,
  deviceRect
}) {
  const {
    x,
    y,
    width,
    height
  } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i = 0;
  for (let row = 0; row < height; row++) {
    const dy = row + y - deviceY;
    const dy2 = dy * dy;
    if (dy2 > minSquareDistanceToCenter) {
      i += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const dx = col + x - deviceX;
          const d2 = dx * dx + dy2;
          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }
        i += 4;
      }
    }
  }
  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);
    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return {
        ...pickedObject,
        pickedColor,
        pickedX: x + dx,
        pickedY: y + dy
      };
    }
    log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects({
  pickedColors,
  decodePickingColor
}) {
  const uniqueColors = /* @__PURE__ */ new Map();
  if (pickedColors) {
    for (let i = 0; i < pickedColors.length; i += 4) {
      const pickedLayerIndex = pickedColors[i + 3] - 1;
      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i, i + 4);
        const colorKey = pickedColor.join(",");
        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);
          if (pickedObject) {
            uniqueColors.set(colorKey, {
              ...pickedObject,
              color: pickedColor
            });
          } else {
            log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}
var NO_PICKED_OBJECT;
var init_query_object = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js"() {
    init_log3();
    NO_PICKED_OBJECT = {
      pickedColor: null,
      pickedObjectIndex: -1
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js
function getEmptyPickingInfo({
  pickInfo,
  viewports,
  pixelRatio,
  x,
  y,
  z
}) {
  let pickedViewport = viewports[0];
  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
      x,
      y
    });
  }
  let coordinate;
  if (pickedViewport) {
    const point = [x - pickedViewport.x, y - pickedViewport.y];
    if (z !== void 0) {
      point[2] = z;
    }
    coordinate = pickedViewport.unproject(point);
  }
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x,
    y,
    pixel: [x, y],
    coordinate,
    devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const {
    pickInfo,
    lastPickedInfo,
    mode,
    layers
  } = opts;
  const {
    pickedColor,
    pickedLayer,
    pickedObjectIndex
  } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === "hover") {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  const baseInfo = getEmptyPickingInfo(opts);
  const infos = /* @__PURE__ */ new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach((layer) => {
    let info = {
      ...baseInfo
    };
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({
      layer,
      info,
      mode
    });
    const rootLayer = info.layer;
    if (layer === pickedLayer && mode === "hover") {
      lastPickedInfo.info = info;
    }
    infos.set(rootLayer.id, info);
    if (mode === "hover") {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({
  layer,
  info,
  mode
}) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({
      info,
      mode,
      sourceLayer
    });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(viewports, pixel) {
  for (let i = viewports.length - 1; i >= 0; i--) {
    const viewport = viewports[i];
    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }
  return viewports[0];
}
var init_pick_info = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js
var DeckPicker;
var init_deck_picker = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js"() {
    init_defineProperty();
    init_esm14();
    init_pick_layers_pass();
    init_query_object();
    init_pick_info();
    DeckPicker = class {
      constructor(gl) {
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "pickingFBO", void 0);
        _defineProperty(this, "depthFBO", void 0);
        _defineProperty(this, "pickLayersPass", void 0);
        _defineProperty(this, "layerFilter", void 0);
        _defineProperty(this, "lastPickedInfo", void 0);
        _defineProperty(this, "_pickable", true);
        this.gl = gl;
        this.pickLayersPass = new PickLayersPass(gl);
        this.lastPickedInfo = {
          index: -1,
          layerId: null,
          info: null
        };
      }
      setProps(props) {
        if ("layerFilter" in props) {
          this.layerFilter = props.layerFilter;
        }
        if ("_pickable" in props) {
          this._pickable = props._pickable;
        }
      }
      finalize() {
        if (this.pickingFBO) {
          this.pickingFBO.delete();
        }
        if (this.depthFBO) {
          this.depthFBO.color.delete();
          this.depthFBO.delete();
        }
      }
      pickObject(opts) {
        return this._pickClosestObject(opts);
      }
      pickObjects(opts) {
        return this._pickVisibleObjects(opts);
      }
      getLastPickedObject({
        x,
        y,
        layers,
        viewports
      }, lastPickedInfo = this.lastPickedInfo.info) {
        const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
        const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
        const layer = lastPickedLayerId ? layers.find((l) => l.id === lastPickedLayerId) : null;
        const viewport = lastPickedViewportId && viewports.find((v) => v.id === lastPickedViewportId) || viewports[0];
        const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);
        const info = {
          x,
          y,
          viewport,
          coordinate,
          layer
        };
        return {
          ...lastPickedInfo,
          ...info
        };
      }
      _resizeBuffer() {
        var _this$pickingFBO, _this$depthFBO;
        const {
          gl
        } = this;
        if (!this.pickingFBO) {
          this.pickingFBO = new Framebuffer(gl);
          if (Framebuffer.isSupported(gl, {
            colorBufferFloat: true
          })) {
            const depthFBO = new Framebuffer(gl);
            depthFBO.attach({
              [36064]: new Texture2D(gl, {
                format: isWebGL2(gl) ? 34836 : 6408,
                type: 5126
              })
            });
            this.depthFBO = depthFBO;
          }
        }
        (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({
          width: gl.canvas.width,
          height: gl.canvas.height
        });
        (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({
          width: gl.canvas.width,
          height: gl.canvas.height
        });
      }
      _getPickable(layers) {
        if (this._pickable === false) {
          return null;
        }
        const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
        return pickableLayers.length ? pickableLayers : null;
      }
      _pickClosestObject({
        layers,
        views,
        viewports,
        x,
        y,
        radius = 0,
        depth = 1,
        mode = "query",
        unproject3D,
        onViewportActive,
        effects
      }) {
        const pickableLayers = this._getPickable(layers);
        const pixelRatio = cssToDeviceRatio(this.gl);
        if (!pickableLayers) {
          return {
            result: [],
            emptyInfo: getEmptyPickingInfo({
              viewports,
              x,
              y,
              pixelRatio
            })
          };
        }
        this._resizeBuffer();
        const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);
        const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
        const deviceRadius = Math.round(radius * pixelRatio);
        const {
          width,
          height
        } = this.pickingFBO;
        const deviceRect = this._getPickingRect({
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceWidth: width,
          deviceHeight: height
        });
        const cullRect = {
          x: x - radius,
          y: y - radius,
          width: radius * 2 + 1,
          height: radius * 2 + 1
        };
        let infos;
        const result = [];
        const affectedLayers = /* @__PURE__ */ new Set();
        for (let i = 0; i < depth; i++) {
          let pickInfo;
          if (deviceRect) {
            const pickedResult = this._drawAndSample({
              layers: pickableLayers,
              views,
              viewports,
              onViewportActive,
              deviceRect,
              cullRect,
              effects,
              pass: "picking:".concat(mode)
            });
            pickInfo = getClosestObject({
              ...pickedResult,
              deviceX: devicePixel[0],
              deviceY: devicePixel[1],
              deviceRadius,
              deviceRect
            });
          } else {
            pickInfo = {
              pickedColor: null,
              pickedObjectIndex: -1
            };
          }
          let z;
          if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
            const {
              pickedColors: pickedColors2
            } = this._drawAndSample({
              layers: [pickInfo.pickedLayer],
              views,
              viewports,
              onViewportActive,
              deviceRect: {
                x: pickInfo.pickedX,
                y: pickInfo.pickedY,
                width: 1,
                height: 1
              },
              cullRect,
              effects,
              pass: "picking:".concat(mode, ":z")
            }, true);
            if (pickedColors2[3]) {
              z = pickedColors2[0];
            }
          }
          if (pickInfo.pickedLayer && i + 1 < depth) {
            affectedLayers.add(pickInfo.pickedLayer);
            pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
          }
          infos = processPickInfo({
            pickInfo,
            lastPickedInfo: this.lastPickedInfo,
            mode,
            layers: pickableLayers,
            viewports,
            x,
            y,
            z,
            pixelRatio
          });
          for (const info of infos.values()) {
            if (info.layer) {
              result.push(info);
            }
          }
          if (!pickInfo.pickedColor) {
            break;
          }
        }
        for (const layer of affectedLayers) {
          layer.restorePickingColors();
        }
        return {
          result,
          emptyInfo: infos.get(null)
        };
      }
      _pickVisibleObjects({
        layers,
        views,
        viewports,
        x,
        y,
        width = 1,
        height = 1,
        mode = "query",
        maxObjects = null,
        onViewportActive,
        effects
      }) {
        const pickableLayers = this._getPickable(layers);
        if (!pickableLayers) {
          return [];
        }
        this._resizeBuffer();
        const pixelRatio = cssToDeviceRatio(this.gl);
        const leftTop = cssToDevicePixels(this.gl, [x, y], true);
        const deviceLeft = leftTop.x;
        const deviceTop = leftTop.y + leftTop.height;
        const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);
        const deviceRight = rightBottom.x + rightBottom.width;
        const deviceBottom = rightBottom.y;
        const deviceRect = {
          x: deviceLeft,
          y: deviceBottom,
          width: deviceRight - deviceLeft,
          height: deviceTop - deviceBottom
        };
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect: {
            x,
            y,
            width,
            height
          },
          effects,
          pass: "picking:".concat(mode)
        });
        const pickInfos = getUniqueObjects(pickedResult);
        const uniqueInfos = /* @__PURE__ */ new Map();
        const isMaxObjects = Number.isFinite(maxObjects);
        for (let i = 0; i < pickInfos.length; i++) {
          if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
            break;
          }
          const pickInfo = pickInfos[i];
          let info = {
            color: pickInfo.pickedColor,
            layer: null,
            index: pickInfo.pickedObjectIndex,
            picked: true,
            x,
            y,
            pixelRatio
          };
          info = getLayerPickingInfo({
            layer: pickInfo.pickedLayer,
            info,
            mode
          });
          if (!uniqueInfos.has(info.object)) {
            uniqueInfos.set(info.object, info);
          }
        }
        return Array.from(uniqueInfos.values());
      }
      _drawAndSample({
        layers,
        views,
        viewports,
        onViewportActive,
        deviceRect,
        cullRect,
        effects,
        pass
      }, pickZ = false) {
        const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
        const opts = {
          layers,
          layerFilter: this.layerFilter,
          views,
          viewports,
          onViewportActive,
          pickingFBO,
          deviceRect,
          cullRect,
          effects,
          pass,
          pickZ,
          preRenderStats: {}
        };
        for (const effect of effects) {
          if (effect.useInPicking) {
            opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
          }
        }
        const {
          decodePickingColor
        } = this.pickLayersPass.render(opts);
        const {
          x,
          y,
          width,
          height
        } = deviceRect;
        const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
        readPixelsToArray(pickingFBO, {
          sourceX: x,
          sourceY: y,
          sourceWidth: width,
          sourceHeight: height,
          target: pickedColors
        });
        return {
          pickedColors,
          decodePickingColor
        };
      }
      _getPickingRect({
        deviceX,
        deviceY,
        deviceRadius,
        deviceWidth,
        deviceHeight
      }) {
        const x = Math.max(0, deviceX - deviceRadius);
        const y = Math.max(0, deviceY - deviceRadius);
        const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
        const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
        if (width <= 0 || height <= 0) {
          return null;
        }
        return {
          x,
          y,
          width,
          height
        };
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/tooltip.js
var defaultStyle, Tooltip;
var init_tooltip = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/tooltip.js"() {
    init_defineProperty();
    defaultStyle = {
      zIndex: "1",
      position: "absolute",
      pointerEvents: "none",
      color: "#a0a7b4",
      backgroundColor: "#29323c",
      padding: "10px",
      top: "0",
      left: "0",
      display: "none"
    };
    Tooltip = class {
      constructor(canvas) {
        _defineProperty(this, "el", null);
        _defineProperty(this, "isVisible", false);
        const canvasParent = canvas.parentElement;
        if (canvasParent) {
          this.el = document.createElement("div");
          this.el.className = "deck-tooltip";
          Object.assign(this.el.style, defaultStyle);
          canvasParent.appendChild(this.el);
        }
      }
      setTooltip(displayInfo, x, y) {
        const el = this.el;
        if (!el) {
          return;
        }
        if (typeof displayInfo === "string") {
          el.innerText = displayInfo;
        } else if (!displayInfo) {
          this.isVisible = false;
          el.style.display = "none";
          return;
        } else {
          if (displayInfo.text) {
            el.innerText = displayInfo.text;
          }
          if (displayInfo.html) {
            el.innerHTML = displayInfo.html;
          }
          if (displayInfo.className) {
            el.className = displayInfo.className;
          }
          Object.assign(el.style, displayInfo.style);
        }
        this.isVisible = true;
        el.style.display = "block";
        el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
      }
      remove() {
        if (this.el) {
          this.el.remove();
          this.el = null;
        }
      }
    };
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module) {
    (function(window3, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round2 = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
          var e2 = new Error("get-stack-trace");
          var stack = e2 && e2.stack ? e2.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log4 = window3.console && (window3.console.warn || window3.console.log);
          if (log4) {
            log4.call(window3.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend = deprecate(function extend2(dest, src, merge2) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge = deprecate(function merge2(dest, src) {
        return extend(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node3, parent) {
        while (node3) {
          if (node3 == parent) {
            return true;
          }
          node3 = node3.parentNode;
        }
        return false;
      }
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window3;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window3;
      var SUPPORT_POINTER_EVENTS = prefixed(window3, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START2 = 1;
      var INPUT_MOVE2 = 2;
      var INPUT_END2 = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input2(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input2.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput2;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput2;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round2(input.pointers[i].clientX),
            clientY: round2(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round2(pointers[0].clientX),
            y: round2(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round2(x / pointersLength),
          y: round2(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP2 = {
        mousedown: INPUT_START2,
        mousemove: INPUT_MOVE2,
        mouseup: INPUT_END2
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput2() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input2.apply(this, arguments);
      }
      inherit(MouseInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP2[ev.type];
          if (eventType & INPUT_START2 && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE2 && ev.which !== 1) {
            eventType = INPUT_END2;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END2) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START2,
        pointermove: INPUT_MOVE2,
        pointerup: INPUT_END2,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window3.MSPointerEvent && !window3.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput2() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input2.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input2.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input2, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START2) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END2 | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input2.apply(this, arguments);
      }
      inherit(TouchInput, Input2, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START2) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input2.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput2(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input2, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START2) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window3.CSS && window3.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window3.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          assign(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END2) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance2 = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance2 = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance2 = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance2 > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START2) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END2) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END2) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START2 && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END2) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager3(element, options);
      }
      Hammer.VERSION = "2.0.7";
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager3(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager3.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          assign(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);
            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add5) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add5) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add5) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer, {
        INPUT_START: INPUT_START2,
        INPUT_MOVE: INPUT_MOVE2,
        INPUT_END: INPUT_END2,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager: Manager3,
        Input: Input2,
        TouchAction,
        TouchInput,
        MouseInput: MouseInput2,
        PointerEventInput: PointerEventInput2,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge,
        extend,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window3 !== "undefined" ? window3 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
      } else {
        window3[exportName] = Hammer;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
function some(array, predict) {
  for (let i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }
  return false;
}
function enhancePointerEventInput(PointerEventInput2) {
  const oldHandler = PointerEventInput2.prototype.handler;
  PointerEventInput2.prototype.handler = function handler(ev) {
    const store = this.store;
    if (ev.button > 0 && ev.type === "pointerdown") {
      if (!some(store, (e2) => e2.pointerId === ev.pointerId)) {
        store.push(ev);
      }
    }
    oldHandler.call(this, ev);
  };
}
function enhanceMouseInput(MouseInput2) {
  MouseInput2.prototype.handler = function handler(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];
    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: "mouse",
      srcEvent: ev
    });
  };
}
var INPUT_START, INPUT_MOVE, INPUT_END, MOUSE_INPUT_MAP;
var init_hammer_overrides = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js"() {
    INPUT_START = 1;
    INPUT_MOVE = 2;
    INPUT_END = 4;
    MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
    };
  }
});

// node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
var hammerjs, Manager2, hammer_browser_default;
var init_hammer_browser = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js"() {
    hammerjs = __toESM(require_hammer());
    init_hammer_overrides();
    enhancePointerEventInput(hammerjs.PointerEventInput);
    enhanceMouseInput(hammerjs.MouseInput);
    Manager2 = hammerjs.Manager;
    hammer_browser_default = hammerjs;
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/input.js
var Input;
var init_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/input.js"() {
    Input = class {
      constructor(element, callback, options) {
        this.element = element;
        this.callback = callback;
        this.options = { enable: true, ...options };
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/constants.js
var RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP, BASIC_EVENT_ALIASES, INPUT_EVENT_TYPES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES;
var init_constants4 = __esm({
  "node_modules/mjolnir.js/dist/esm/constants.js"() {
    init_hammer_browser();
    RECOGNIZERS = hammer_browser_default ? [
      [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
      [hammer_browser_default.Rotate, { enable: false }],
      [hammer_browser_default.Pinch, { enable: false }],
      [hammer_browser_default.Swipe, { enable: false }],
      [hammer_browser_default.Pan, { threshold: 0, enable: false }],
      [hammer_browser_default.Press, { enable: false }],
      [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
      // TODO - rename to 'tap' and 'singletap' in the next major release
      [hammer_browser_default.Tap, { event: "anytap", enable: false }],
      [hammer_browser_default.Tap, { enable: false }]
    ] : null;
    RECOGNIZER_COMPATIBLE_MAP = {
      tripan: ["rotate", "pinch", "pan"],
      rotate: ["pinch"],
      pinch: ["pan"],
      pan: ["press", "doubletap", "anytap", "tap"],
      doubletap: ["anytap"],
      anytap: ["tap"]
    };
    RECOGNIZER_FALLBACK_MAP = {
      doubletap: ["tap"]
    };
    BASIC_EVENT_ALIASES = {
      pointerdown: "pointerdown",
      pointermove: "pointermove",
      pointerup: "pointerup",
      touchstart: "pointerdown",
      touchmove: "pointermove",
      touchend: "pointerup",
      mousedown: "pointerdown",
      mousemove: "pointermove",
      mouseup: "pointerup"
    };
    INPUT_EVENT_TYPES = {
      KEY_EVENTS: ["keydown", "keyup"],
      MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
      WHEEL_EVENTS: [
        // Chrome, Safari
        "wheel",
        // IE
        "mousewheel"
      ]
    };
    EVENT_RECOGNIZER_MAP = {
      tap: "tap",
      anytap: "anytap",
      doubletap: "doubletap",
      press: "press",
      pinch: "pinch",
      pinchin: "pinch",
      pinchout: "pinch",
      pinchstart: "pinch",
      pinchmove: "pinch",
      pinchend: "pinch",
      pinchcancel: "pinch",
      rotate: "rotate",
      rotatestart: "rotate",
      rotatemove: "rotate",
      rotateend: "rotate",
      rotatecancel: "rotate",
      tripan: "tripan",
      tripanstart: "tripan",
      tripanmove: "tripan",
      tripanup: "tripan",
      tripandown: "tripan",
      tripanleft: "tripan",
      tripanright: "tripan",
      tripanend: "tripan",
      tripancancel: "tripan",
      pan: "pan",
      panstart: "pan",
      panmove: "pan",
      panup: "pan",
      pandown: "pan",
      panleft: "pan",
      panright: "pan",
      panend: "pan",
      pancancel: "pan",
      swipe: "swipe",
      swipeleft: "swipe",
      swiperight: "swipe",
      swipeup: "swipe",
      swipedown: "swipe"
    };
    GESTURE_EVENT_ALIASES = {
      click: "tap",
      anyclick: "anytap",
      dblclick: "doubletap",
      mousedown: "pointerdown",
      mousemove: "pointermove",
      mouseup: "pointerup",
      mouseover: "pointerover",
      mouseout: "pointerout",
      mouseleave: "pointerleave"
    };
  }
});

// node_modules/mjolnir.js/dist/esm/utils/globals.js
var userAgent, window_4, passiveSupported;
var init_globals5 = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/globals.js"() {
    userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
    window_4 = typeof window !== "undefined" ? window : global;
    passiveSupported = false;
    try {
      const options = {
        // This function will be called when the browser
        // attempts to access the passive property.
        get passive() {
          passiveSupported = true;
          return true;
        }
      };
      window_4.addEventListener("test", null, options);
      window_4.removeEventListener("test", null);
    } catch (err) {
      passiveSupported = false;
    }
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
var firefox, WHEEL_EVENTS, EVENT_TYPE, WHEEL_DELTA_MAGIC_SCALER, WHEEL_DELTA_PER_LINE, SHIFT_MULTIPLIER, WheelInput;
var init_wheel_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js"() {
    init_input();
    init_constants4();
    init_globals5();
    firefox = userAgent.indexOf("firefox") !== -1;
    ({ WHEEL_EVENTS } = INPUT_EVENT_TYPES);
    EVENT_TYPE = "wheel";
    WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
    WHEEL_DELTA_PER_LINE = 40;
    SHIFT_MULTIPLIER = 0.25;
    WheelInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          if (!this.options.enable) {
            return;
          }
          let value = event.deltaY;
          if (window_4.WheelEvent) {
            if (firefox && event.deltaMode === window_4.WheelEvent.DOM_DELTA_PIXEL) {
              value /= window_4.devicePixelRatio;
            }
            if (event.deltaMode === window_4.WheelEvent.DOM_DELTA_LINE) {
              value *= WHEEL_DELTA_PER_LINE;
            }
          }
          if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
            value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
          }
          if (event.shiftKey && value) {
            value = value * SHIFT_MULTIPLIER;
          }
          this.callback({
            type: EVENT_TYPE,
            center: {
              x: event.clientX,
              y: event.clientY
            },
            delta: -value,
            srcEvent: event,
            pointerType: "mouse",
            target: event.target
          });
        };
        this.events = (this.options.events || []).concat(WHEEL_EVENTS);
        this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
      }
      destroy() {
        this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE) {
          this.options.enable = enabled;
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/move-input.js
var MOUSE_EVENTS, MOVE_EVENT_TYPE, OVER_EVENT_TYPE, OUT_EVENT_TYPE, ENTER_EVENT_TYPE, LEAVE_EVENT_TYPE, MoveInput;
var init_move_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/move-input.js"() {
    init_input();
    init_constants4();
    ({ MOUSE_EVENTS } = INPUT_EVENT_TYPES);
    MOVE_EVENT_TYPE = "pointermove";
    OVER_EVENT_TYPE = "pointerover";
    OUT_EVENT_TYPE = "pointerout";
    ENTER_EVENT_TYPE = "pointerenter";
    LEAVE_EVENT_TYPE = "pointerleave";
    MoveInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          this.handleOverEvent(event);
          this.handleOutEvent(event);
          this.handleEnterEvent(event);
          this.handleLeaveEvent(event);
          this.handleMoveEvent(event);
        };
        this.pressed = false;
        const { enable: enable2 } = this.options;
        this.enableMoveEvent = enable2;
        this.enableLeaveEvent = enable2;
        this.enableEnterEvent = enable2;
        this.enableOutEvent = enable2;
        this.enableOverEvent = enable2;
        this.events = (this.options.events || []).concat(MOUSE_EVENTS);
        this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
      }
      destroy() {
        this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === MOVE_EVENT_TYPE) {
          this.enableMoveEvent = enabled;
        }
        if (eventType === OVER_EVENT_TYPE) {
          this.enableOverEvent = enabled;
        }
        if (eventType === OUT_EVENT_TYPE) {
          this.enableOutEvent = enabled;
        }
        if (eventType === ENTER_EVENT_TYPE) {
          this.enableEnterEvent = enabled;
        }
        if (eventType === LEAVE_EVENT_TYPE) {
          this.enableLeaveEvent = enabled;
        }
      }
      handleOverEvent(event) {
        if (this.enableOverEvent) {
          if (event.type === "mouseover") {
            this._emit(OVER_EVENT_TYPE, event);
          }
        }
      }
      handleOutEvent(event) {
        if (this.enableOutEvent) {
          if (event.type === "mouseout") {
            this._emit(OUT_EVENT_TYPE, event);
          }
        }
      }
      handleEnterEvent(event) {
        if (this.enableEnterEvent) {
          if (event.type === "mouseenter") {
            this._emit(ENTER_EVENT_TYPE, event);
          }
        }
      }
      handleLeaveEvent(event) {
        if (this.enableLeaveEvent) {
          if (event.type === "mouseleave") {
            this._emit(LEAVE_EVENT_TYPE, event);
          }
        }
      }
      handleMoveEvent(event) {
        if (this.enableMoveEvent) {
          switch (event.type) {
            case "mousedown":
              if (event.button >= 0) {
                this.pressed = true;
              }
              break;
            case "mousemove":
              if (event.which === 0) {
                this.pressed = false;
              }
              if (!this.pressed) {
                this._emit(MOVE_EVENT_TYPE, event);
              }
              break;
            case "mouseup":
              this.pressed = false;
              break;
            default:
          }
        }
      }
      _emit(type, event) {
        this.callback({
          type,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/key-input.js
var KEY_EVENTS, DOWN_EVENT_TYPE, UP_EVENT_TYPE, KeyInput;
var init_key_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/key-input.js"() {
    init_input();
    init_constants4();
    ({ KEY_EVENTS } = INPUT_EVENT_TYPES);
    DOWN_EVENT_TYPE = "keydown";
    UP_EVENT_TYPE = "keyup";
    KeyInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          const targetElement = event.target || event.srcElement;
          if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
            return;
          }
          if (this.enableDownEvent && event.type === "keydown") {
            this.callback({
              type: DOWN_EVENT_TYPE,
              srcEvent: event,
              key: event.key,
              target: event.target
            });
          }
          if (this.enableUpEvent && event.type === "keyup") {
            this.callback({
              type: UP_EVENT_TYPE,
              srcEvent: event,
              key: event.key,
              target: event.target
            });
          }
        };
        this.enableDownEvent = this.options.enable;
        this.enableUpEvent = this.options.enable;
        this.events = (this.options.events || []).concat(KEY_EVENTS);
        element.tabIndex = this.options.tabIndex || 0;
        element.style.outline = "none";
        this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
      }
      destroy() {
        this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === DOWN_EVENT_TYPE) {
          this.enableDownEvent = enabled;
        }
        if (eventType === UP_EVENT_TYPE) {
          this.enableUpEvent = enabled;
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
var EVENT_TYPE2, ContextmenuInput;
var init_contextmenu_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js"() {
    init_input();
    EVENT_TYPE2 = "contextmenu";
    ContextmenuInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          if (!this.options.enable) {
            return;
          }
          this.callback({
            type: EVENT_TYPE2,
            center: {
              x: event.clientX,
              y: event.clientY
            },
            srcEvent: event,
            pointerType: "mouse",
            target: event.target
          });
        };
        element.addEventListener("contextmenu", this.handleEvent);
      }
      destroy() {
        this.element.removeEventListener("contextmenu", this.handleEvent);
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE2) {
          this.options.enable = enabled;
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/utils/event-utils.js
function whichButtons(event) {
  const eventType = MOUSE_EVENTS2[event.srcEvent.type];
  if (!eventType) {
    return null;
  }
  const { buttons, button, which } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (
    // button is up, need to find out which one was pressed before
    eventType === UP_EVENT || // moving but does not support `buttons` API
    eventType === MOVE_EVENT && !Number.isFinite(buttons)
  ) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return { leftButton, middleButton, rightButton };
}
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  if (!center) {
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  const scaleX2 = rect.width / rootElement.offsetWidth || 1;
  const scaleY2 = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY2
  };
  return { center, offsetCenter };
}
var DOWN_EVENT, MOVE_EVENT, UP_EVENT, MOUSE_EVENTS2, MOUSE_EVENT_WHICH_LEFT, MOUSE_EVENT_WHICH_MIDDLE, MOUSE_EVENT_WHICH_RIGHT, MOUSE_EVENT_BUTTON_LEFT, MOUSE_EVENT_BUTTON_MIDDLE, MOUSE_EVENT_BUTTON_RIGHT, MOUSE_EVENT_BUTTONS_LEFT_MASK, MOUSE_EVENT_BUTTONS_RIGHT_MASK, MOUSE_EVENT_BUTTONS_MIDDLE_MASK;
var init_event_utils = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/event-utils.js"() {
    DOWN_EVENT = 1;
    MOVE_EVENT = 2;
    UP_EVENT = 4;
    MOUSE_EVENTS2 = {
      pointerdown: DOWN_EVENT,
      pointermove: MOVE_EVENT,
      pointerup: UP_EVENT,
      mousedown: DOWN_EVENT,
      mousemove: MOVE_EVENT,
      mouseup: UP_EVENT
    };
    MOUSE_EVENT_WHICH_LEFT = 1;
    MOUSE_EVENT_WHICH_MIDDLE = 2;
    MOUSE_EVENT_WHICH_RIGHT = 3;
    MOUSE_EVENT_BUTTON_LEFT = 0;
    MOUSE_EVENT_BUTTON_MIDDLE = 1;
    MOUSE_EVENT_BUTTON_RIGHT = 2;
    MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
    MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
    MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  }
});

// node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
var DEFAULT_OPTIONS, EventRegistrar;
var init_event_registrar = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/event-registrar.js"() {
    init_event_utils();
    DEFAULT_OPTIONS = {
      srcElement: "root",
      priority: 0
    };
    EventRegistrar = class {
      constructor(eventManager) {
        this.handleEvent = (event) => {
          if (this.isEmpty()) {
            return;
          }
          const mjolnirEvent = this._normalizeEvent(event);
          let target = event.srcEvent.target;
          while (target && target !== mjolnirEvent.rootElement) {
            this._emit(mjolnirEvent, target);
            if (mjolnirEvent.handled) {
              return;
            }
            target = target.parentNode;
          }
          this._emit(mjolnirEvent, "root");
        };
        this.eventManager = eventManager;
        this.handlers = [];
        this.handlersByElement = /* @__PURE__ */ new Map();
        this._active = false;
      }
      // Returns true if there are no non-passive handlers
      isEmpty() {
        return !this._active;
      }
      add(type, handler, options, once = false, passive = false) {
        const { handlers, handlersByElement } = this;
        let opts = DEFAULT_OPTIONS;
        if (typeof options === "string" || options && options.addEventListener) {
          opts = { ...DEFAULT_OPTIONS, srcElement: options };
        } else if (options) {
          opts = { ...DEFAULT_OPTIONS, ...options };
        }
        let entries = handlersByElement.get(opts.srcElement);
        if (!entries) {
          entries = [];
          handlersByElement.set(opts.srcElement, entries);
        }
        const entry = {
          type,
          handler,
          srcElement: opts.srcElement,
          priority: opts.priority
        };
        if (once) {
          entry.once = true;
        }
        if (passive) {
          entry.passive = true;
        }
        handlers.push(entry);
        this._active = this._active || !entry.passive;
        let insertPosition = entries.length - 1;
        while (insertPosition >= 0) {
          if (entries[insertPosition].priority >= entry.priority) {
            break;
          }
          insertPosition--;
        }
        entries.splice(insertPosition + 1, 0, entry);
      }
      remove(type, handler) {
        const { handlers, handlersByElement } = this;
        for (let i = handlers.length - 1; i >= 0; i--) {
          const entry = handlers[i];
          if (entry.type === type && entry.handler === handler) {
            handlers.splice(i, 1);
            const entries = handlersByElement.get(entry.srcElement);
            entries.splice(entries.indexOf(entry), 1);
            if (entries.length === 0) {
              handlersByElement.delete(entry.srcElement);
            }
          }
        }
        this._active = handlers.some((entry) => !entry.passive);
      }
      /**
       * Invoke handlers on a particular element
       */
      _emit(event, srcElement) {
        const entries = this.handlersByElement.get(srcElement);
        if (entries) {
          let immediatePropagationStopped = false;
          const stopPropagation = () => {
            event.handled = true;
          };
          const stopImmediatePropagation = () => {
            event.handled = true;
            immediatePropagationStopped = true;
          };
          const entriesToRemove = [];
          for (let i = 0; i < entries.length; i++) {
            const { type, handler, once } = entries[i];
            handler({
              ...event,
              // @ts-ignore
              type,
              stopPropagation,
              stopImmediatePropagation
            });
            if (once) {
              entriesToRemove.push(entries[i]);
            }
            if (immediatePropagationStopped) {
              break;
            }
          }
          for (let i = 0; i < entriesToRemove.length; i++) {
            const { type, handler } = entriesToRemove[i];
            this.remove(type, handler);
          }
        }
      }
      /**
       * Normalizes hammerjs and custom events to have predictable fields.
       */
      _normalizeEvent(event) {
        const rootElement = this.eventManager.getElement();
        return {
          ...event,
          ...whichButtons(event),
          ...getOffsetPosition(event, rootElement),
          preventDefault: () => {
            event.srcEvent.preventDefault();
          },
          stopImmediatePropagation: null,
          stopPropagation: null,
          handled: false,
          rootElement
        };
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/event-manager.js
var DEFAULT_OPTIONS2, EventManager;
var init_event_manager = __esm({
  "node_modules/mjolnir.js/dist/esm/event-manager.js"() {
    init_hammer_browser();
    init_wheel_input();
    init_move_input();
    init_key_input();
    init_contextmenu_input();
    init_event_registrar();
    init_constants4();
    DEFAULT_OPTIONS2 = {
      // event handlers
      events: null,
      // custom recognizers
      recognizers: null,
      recognizerOptions: {},
      // Manager class
      Manager: Manager2,
      // allow browser default touch action
      // https://github.com/uber/react-map-gl/issues/506
      touchAction: "none",
      tabIndex: 0
    };
    EventManager = class {
      constructor(element = null, options) {
        this._onBasicInput = (event) => {
          const { srcEvent } = event;
          const alias = BASIC_EVENT_ALIASES[srcEvent.type];
          if (alias) {
            this.manager.emit(alias, event);
          }
        };
        this._onOtherEvent = (event) => {
          this.manager.emit(event.type, event);
        };
        this.options = { ...DEFAULT_OPTIONS2, ...options };
        this.events = /* @__PURE__ */ new Map();
        this.setElement(element);
        const { events } = this.options;
        if (events) {
          this.on(events);
        }
      }
      getElement() {
        return this.element;
      }
      setElement(element) {
        if (this.element) {
          this.destroy();
        }
        this.element = element;
        if (!element) {
          return;
        }
        const { options } = this;
        const ManagerClass = options.Manager;
        this.manager = new ManagerClass(element, {
          touchAction: options.touchAction,
          recognizers: options.recognizers || RECOGNIZERS
        }).on("hammer.input", this._onBasicInput);
        if (!options.recognizers) {
          Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name) => {
            const recognizer = this.manager.get(name);
            if (recognizer) {
              RECOGNIZER_COMPATIBLE_MAP[name].forEach((otherName) => {
                recognizer.recognizeWith(otherName);
              });
            }
          });
        }
        for (const recognizerName in options.recognizerOptions) {
          const recognizer = this.manager.get(recognizerName);
          if (recognizer) {
            const recognizerOption = options.recognizerOptions[recognizerName];
            delete recognizerOption.enable;
            recognizer.set(recognizerOption);
          }
        }
        this.wheelInput = new WheelInput(element, this._onOtherEvent, {
          enable: false
        });
        this.moveInput = new MoveInput(element, this._onOtherEvent, {
          enable: false
        });
        this.keyInput = new KeyInput(element, this._onOtherEvent, {
          enable: false,
          tabIndex: options.tabIndex
        });
        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
          enable: false
        });
        for (const [eventAlias, eventRegistrar] of this.events) {
          if (!eventRegistrar.isEmpty()) {
            this._toggleRecognizer(eventRegistrar.recognizerName, true);
            this.manager.on(eventAlias, eventRegistrar.handleEvent);
          }
        }
      }
      // Tear down internal event management implementations.
      destroy() {
        if (this.element) {
          this.wheelInput.destroy();
          this.moveInput.destroy();
          this.keyInput.destroy();
          this.contextmenuInput.destroy();
          this.manager.destroy();
          this.wheelInput = null;
          this.moveInput = null;
          this.keyInput = null;
          this.contextmenuInput = null;
          this.manager = null;
          this.element = null;
        }
      }
      /** Register an event handler function to be called on `event` */
      on(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false);
      }
      once(event, handler, opts) {
        this._addEventHandler(event, handler, opts, true);
      }
      watch(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false, true);
      }
      off(event, handler) {
        this._removeEventHandler(event, handler);
      }
      /*
       * Enable/disable recognizer for the given event
       */
      _toggleRecognizer(name, enabled) {
        const { manager } = this;
        if (!manager) {
          return;
        }
        const recognizer = manager.get(name);
        if (recognizer && recognizer.options.enable !== enabled) {
          recognizer.set({ enable: enabled });
          const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
          if (fallbackRecognizers && !this.options.recognizers) {
            fallbackRecognizers.forEach((otherName) => {
              const otherRecognizer = manager.get(otherName);
              if (enabled) {
                otherRecognizer.requireFailure(name);
                recognizer.dropRequireFailure(otherName);
              } else {
                otherRecognizer.dropRequireFailure(name);
              }
            });
          }
        }
        this.wheelInput.enableEventType(name, enabled);
        this.moveInput.enableEventType(name, enabled);
        this.keyInput.enableEventType(name, enabled);
        this.contextmenuInput.enableEventType(name, enabled);
      }
      /**
       * Process the event registration for a single event + handler.
       */
      _addEventHandler(event, handler, opts, once, passive) {
        if (typeof event !== "string") {
          opts = handler;
          for (const eventName in event) {
            this._addEventHandler(eventName, event[eventName], opts, once, passive);
          }
          return;
        }
        const { manager, events } = this;
        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        let eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
          eventRegistrar = new EventRegistrar(this);
          events.set(eventAlias, eventRegistrar);
          eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
          if (manager) {
            manager.on(eventAlias, eventRegistrar.handleEvent);
          }
        }
        eventRegistrar.add(event, handler, opts, once, passive);
        if (!eventRegistrar.isEmpty()) {
          this._toggleRecognizer(eventRegistrar.recognizerName, true);
        }
      }
      /**
       * Process the event deregistration for a single event + handler.
       */
      _removeEventHandler(event, handler) {
        if (typeof event !== "string") {
          for (const eventName in event) {
            this._removeEventHandler(eventName, event[eventName]);
          }
          return;
        }
        const { events } = this;
        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        const eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
          return;
        }
        eventRegistrar.remove(event, handler);
        if (eventRegistrar.isEmpty()) {
          const { recognizerName } = eventRegistrar;
          let isRecognizerUsed = false;
          for (const eh of events.values()) {
            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
              isRecognizerUsed = true;
              break;
            }
          }
          if (!isRecognizerUsed) {
            this._toggleRecognizer(recognizerName, false);
          }
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/index.js
var init_esm16 = __esm({
  "node_modules/mjolnir.js/dist/esm/index.js"() {
    init_event_manager();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/deck.js
function noop3() {
}
var getCursor, defaultProps, Deck;
var init_deck = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/deck.js"() {
    init_defineProperty();
    init_layer_manager();
    init_view_manager();
    init_map_view();
    init_effect_manager();
    init_deck_renderer();
    init_deck_picker();
    init_tooltip();
    init_log3();
    init_deep_equal();
    init_typed_array_manager();
    init_init2();
    init_esm5();
    init_esm14();
    init_esm3();
    init_esm16();
    init_assert9();
    init_constants();
    getCursor = ({
      isDragging
    }) => isDragging ? "grabbing" : "grab";
    defaultProps = {
      id: "",
      width: "100%",
      height: "100%",
      style: null,
      viewState: null,
      initialViewState: null,
      pickingRadius: 0,
      layerFilter: null,
      glOptions: {},
      parameters: {},
      parent: null,
      gl: null,
      canvas: null,
      layers: [],
      effects: [],
      views: null,
      controller: null,
      useDevicePixels: true,
      touchAction: "none",
      eventRecognizerOptions: {},
      _framebuffer: null,
      _animate: false,
      _pickable: true,
      _typedArrayManagerProps: {},
      _customRender: null,
      onWebGLInitialized: noop3,
      onResize: noop3,
      onViewStateChange: noop3,
      onInteractionStateChange: noop3,
      onBeforeRender: noop3,
      onAfterRender: noop3,
      onLoad: noop3,
      onError: (error2) => log_default.error(error2.message)(),
      onHover: null,
      onClick: null,
      onDragStart: null,
      onDrag: null,
      onDragEnd: null,
      _onMetrics: null,
      getCursor,
      getTooltip: null,
      debug: false,
      drawPickingColors: false
    };
    Deck = class {
      constructor(props) {
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "width", 0);
        _defineProperty(this, "height", 0);
        _defineProperty(this, "userData", {});
        _defineProperty(this, "canvas", null);
        _defineProperty(this, "viewManager", null);
        _defineProperty(this, "layerManager", null);
        _defineProperty(this, "effectManager", null);
        _defineProperty(this, "deckRenderer", null);
        _defineProperty(this, "deckPicker", null);
        _defineProperty(this, "eventManager", null);
        _defineProperty(this, "tooltip", null);
        _defineProperty(this, "metrics", void 0);
        _defineProperty(this, "animationLoop", void 0);
        _defineProperty(this, "stats", void 0);
        _defineProperty(this, "viewState", void 0);
        _defineProperty(this, "cursorState", void 0);
        _defineProperty(this, "_needsRedraw", void 0);
        _defineProperty(this, "_pickRequest", void 0);
        _defineProperty(this, "_lastPointerDownInfo", null);
        _defineProperty(this, "_metricsCounter", void 0);
        _defineProperty(this, "_onPointerMove", (event) => {
          const {
            _pickRequest
          } = this;
          if (event.type === "pointerleave") {
            _pickRequest.x = -1;
            _pickRequest.y = -1;
            _pickRequest.radius = 0;
          } else if (event.leftButton || event.rightButton) {
            return;
          } else {
            const pos = event.offsetCenter;
            if (!pos) {
              return;
            }
            _pickRequest.x = pos.x;
            _pickRequest.y = pos.y;
            _pickRequest.radius = this.props.pickingRadius;
          }
          if (this.layerManager) {
            this.layerManager.context.mousePosition = {
              x: _pickRequest.x,
              y: _pickRequest.y
            };
          }
          _pickRequest.event = event;
        });
        _defineProperty(this, "_onEvent", (event) => {
          const eventOptions = EVENTS[event.type];
          const pos = event.offsetCenter;
          if (!eventOptions || !pos || !this.layerManager) {
            return;
          }
          const layers = this.layerManager.getLayers();
          const info = this.deckPicker.getLastPickedObject({
            x: pos.x,
            y: pos.y,
            layers,
            viewports: this.getViewports(pos)
          }, this._lastPointerDownInfo);
          const {
            layer
          } = info;
          const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
          const rootHandler = this.props[eventOptions.handler];
          let handled = false;
          if (layerHandler) {
            handled = layerHandler.call(layer, info, event);
          }
          if (!handled && rootHandler) {
            rootHandler(info, event);
          }
        });
        _defineProperty(this, "_onPointerDown", (event) => {
          const pos = event.offsetCenter;
          const pickedInfo = this._pick("pickObject", "pickObject Time", {
            x: pos.x,
            y: pos.y,
            radius: this.props.pickingRadius
          });
          this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
        });
        this.props = {
          ...defaultProps,
          ...props
        };
        props = this.props;
        this._needsRedraw = "Initial render";
        this._pickRequest = {
          mode: "hover",
          x: -1,
          y: -1,
          radius: 0,
          event: null
        };
        this.cursorState = {
          isHovering: false,
          isDragging: false
        };
        if (props.viewState && props.initialViewState) {
          log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
        }
        if (getBrowser() === "IE") {
          log_default.warn("IE 11 is not supported")();
        }
        this.viewState = props.initialViewState;
        if (!props.gl) {
          if (typeof document !== "undefined") {
            this.canvas = this._createCanvas(props);
          }
        }
        this.animationLoop = this._createAnimationLoop(props);
        this.stats = new Stats({
          id: "deck.gl"
        });
        this.metrics = {
          fps: 0,
          setPropsTime: 0,
          updateAttributesTime: 0,
          framesRedrawn: 0,
          pickTime: 0,
          pickCount: 0,
          gpuTime: 0,
          gpuTimePerFrame: 0,
          cpuTime: 0,
          cpuTimePerFrame: 0,
          bufferMemory: 0,
          textureMemory: 0,
          renderbufferMemory: 0,
          gpuMemory: 0
        };
        this._metricsCounter = 0;
        this.setProps(props);
        if (props._typedArrayManagerProps) {
          typed_array_manager_default.setOptions(props._typedArrayManagerProps);
        }
        this.animationLoop.start();
      }
      finalize() {
        var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
        this.animationLoop.stop();
        this.animationLoop = null;
        this._lastPointerDownInfo = null;
        (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();
        this.layerManager = null;
        (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();
        this.viewManager = null;
        (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();
        this.effectManager = null;
        (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();
        this.deckRenderer = null;
        (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();
        this.deckPicker = null;
        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();
        this.eventManager = null;
        (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();
        this.tooltip = null;
        if (!this.props.canvas && !this.props.gl && this.canvas) {
          var _this$canvas$parentEl;
          (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);
          this.canvas = null;
        }
      }
      setProps(props) {
        this.stats.get("setProps Time").timeStart();
        if ("onLayerHover" in props) {
          log_default.removed("onLayerHover", "onHover")();
        }
        if ("onLayerClick" in props) {
          log_default.removed("onLayerClick", "onClick")();
        }
        if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {
          this.viewState = props.initialViewState;
        }
        Object.assign(this.props, props);
        this._setCanvasSize(this.props);
        const resolvedProps = Object.create(this.props);
        Object.assign(resolvedProps, {
          views: this._getViews(),
          width: this.width,
          height: this.height,
          viewState: this._getViewState()
        });
        this.animationLoop.setProps(resolvedProps);
        if (this.layerManager) {
          this.viewManager.setProps(resolvedProps);
          this.layerManager.activateViewport(this.getViewports()[0]);
          this.layerManager.setProps(resolvedProps);
          this.effectManager.setProps(resolvedProps);
          this.deckRenderer.setProps(resolvedProps);
          this.deckPicker.setProps(resolvedProps);
        }
        this.stats.get("setProps Time").timeEnd();
      }
      needsRedraw(opts = {
        clearRedrawFlags: false
      }) {
        if (!this.layerManager) {
          return false;
        }
        if (this.props._animate) {
          return "Deck._animate";
        }
        let redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) {
          this._needsRedraw = false;
        }
        const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
        const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
        const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
        const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
        redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
        return redraw;
      }
      redraw(reason) {
        if (!this.layerManager) {
          return;
        }
        let redrawReason = this.needsRedraw({
          clearRedrawFlags: true
        });
        redrawReason = reason || redrawReason;
        if (!redrawReason) {
          return;
        }
        this.stats.get("Redraw Count").incrementCount();
        if (this.props._customRender) {
          this.props._customRender(redrawReason);
        } else {
          this._drawLayers(redrawReason);
        }
      }
      get isInitialized() {
        return this.viewManager !== null;
      }
      getViews() {
        assert9(this.viewManager);
        return this.viewManager.views;
      }
      getViewports(rect) {
        assert9(this.viewManager);
        return this.viewManager.getViewports(rect);
      }
      pickObject(opts) {
        const infos = this._pick("pickObject", "pickObject Time", opts).result;
        return infos.length ? infos[0] : null;
      }
      pickMultipleObjects(opts) {
        opts.depth = opts.depth || 10;
        return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
      }
      pickObjects(opts) {
        return this._pick("pickObjects", "pickObjects Time", opts);
      }
      _addResources(resources, forceUpdate = false) {
        for (const id in resources) {
          this.layerManager.resourceManager.add({
            resourceId: id,
            data: resources[id],
            forceUpdate
          });
        }
      }
      _removeResources(resourceIds) {
        for (const id of resourceIds) {
          this.layerManager.resourceManager.remove(id);
        }
      }
      _addDefaultEffect(effect) {
        this.effectManager.addDefaultEffect(effect);
      }
      _pick(method, statKey, opts) {
        assert9(this.deckPicker);
        const {
          stats
        } = this;
        stats.get("Pick Count").incrementCount();
        stats.get(statKey).timeStart();
        const infos = this.deckPicker[method]({
          layers: this.layerManager.getLayers(opts),
          views: this.viewManager.getViews(),
          viewports: this.getViewports(opts),
          onViewportActive: this.layerManager.activateViewport,
          effects: this.effectManager.getEffects(),
          ...opts
        });
        stats.get(statKey).timeEnd();
        return infos;
      }
      _createCanvas(props) {
        let canvas = props.canvas;
        if (typeof canvas === "string") {
          canvas = document.getElementById(canvas);
          assert9(canvas);
        }
        if (!canvas) {
          canvas = document.createElement("canvas");
          canvas.id = props.id || "deckgl-overlay";
          const parent = props.parent || document.body;
          parent.appendChild(canvas);
        }
        Object.assign(canvas.style, props.style);
        return canvas;
      }
      _setCanvasSize(props) {
        if (!this.canvas) {
          return;
        }
        const {
          width,
          height
        } = props;
        if (width || width === 0) {
          const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
          this.canvas.style.width = cssWidth;
        }
        if (height || height === 0) {
          var _props$style;
          const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
          this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || "absolute";
          this.canvas.style.height = cssHeight;
        }
      }
      _updateCanvasSize() {
        var _canvas$clientWidth, _canvas$clientHeight;
        const {
          canvas
        } = this;
        if (!canvas) {
          return;
        }
        const newWidth = (_canvas$clientWidth = canvas.clientWidth) !== null && _canvas$clientWidth !== void 0 ? _canvas$clientWidth : canvas.width;
        const newHeight = (_canvas$clientHeight = canvas.clientHeight) !== null && _canvas$clientHeight !== void 0 ? _canvas$clientHeight : canvas.height;
        if (newWidth !== this.width || newHeight !== this.height) {
          var _this$viewManager2;
          this.width = newWidth;
          this.height = newHeight;
          (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({
            width: newWidth,
            height: newHeight
          });
          this.props.onResize({
            width: newWidth,
            height: newHeight
          });
        }
      }
      _createAnimationLoop(props) {
        const {
          width,
          height,
          gl,
          glOptions,
          debug: debug2,
          onError,
          onBeforeRender,
          onAfterRender,
          useDevicePixels
        } = props;
        return new AnimationLoop({
          width,
          height,
          useDevicePixels,
          autoResizeViewport: false,
          gl,
          onCreateContext: (opts) => createGLContext({
            ...glOptions,
            ...opts,
            canvas: this.canvas,
            debug: debug2,
            onContextLost: () => this._onContextLost()
          }),
          onInitialize: (context) => this._setGLContext(context.gl),
          onRender: this._onRenderFrame.bind(this),
          onBeforeRender,
          onAfterRender,
          onError
        });
      }
      _getViewState() {
        return this.props.viewState || this.viewState;
      }
      _getViews() {
        let views = this.props.views || [new MapView({
          id: "default-view"
        })];
        views = Array.isArray(views) ? views : [views];
        if (views.length && this.props.controller) {
          views[0].props.controller = this.props.controller;
        }
        return views;
      }
      _onContextLost() {
        const {
          onError
        } = this.props;
        if (this.animationLoop && onError) {
          onError(new Error("WebGL context is lost"));
        }
      }
      _pickAndCallback() {
        const {
          _pickRequest
        } = this;
        if (_pickRequest.event) {
          const {
            result,
            emptyInfo
          } = this._pick("pickObject", "pickObject Time", _pickRequest);
          this.cursorState.isHovering = result.length > 0;
          let pickedInfo = emptyInfo;
          let handled = false;
          for (const info of result) {
            var _info$layer;
            pickedInfo = info;
            handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
          }
          if (!handled && this.props.onHover) {
            this.props.onHover(pickedInfo, _pickRequest.event);
          }
          if (this.props.getTooltip && this.tooltip) {
            const displayInfo = this.props.getTooltip(pickedInfo);
            this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
          }
          _pickRequest.event = null;
        }
      }
      _updateCursor() {
        const container = this.props.parent || this.canvas;
        if (container) {
          container.style.cursor = this.props.getCursor(this.cursorState);
        }
      }
      _setGLContext(gl) {
        if (this.layerManager) {
          return;
        }
        if (!this.canvas) {
          this.canvas = gl.canvas;
          instrumentGLContext(gl, {
            enable: true,
            copyState: true
          });
        }
        this.tooltip = new Tooltip(this.canvas);
        setParameters(gl, {
          blend: true,
          blendFunc: [770, 771, 1, 771],
          polygonOffsetFill: true,
          depthTest: true,
          depthFunc: 515
        });
        this.props.onWebGLInitialized(gl);
        const timeline = new Timeline();
        timeline.play();
        this.animationLoop.attachTimeline(timeline);
        this.eventManager = new EventManager(this.props.parent || gl.canvas, {
          touchAction: this.props.touchAction,
          recognizerOptions: this.props.eventRecognizerOptions,
          events: {
            pointerdown: this._onPointerDown,
            pointermove: this._onPointerMove,
            pointerleave: this._onPointerMove
          }
        });
        for (const eventType in EVENTS) {
          this.eventManager.on(eventType, this._onEvent);
        }
        this.viewManager = new ViewManager({
          timeline,
          eventManager: this.eventManager,
          onViewStateChange: this._onViewStateChange.bind(this),
          onInteractionStateChange: this._onInteractionStateChange.bind(this),
          views: this._getViews(),
          viewState: this._getViewState(),
          width: this.width,
          height: this.height
        });
        const viewport = this.viewManager.getViewports()[0];
        this.layerManager = new LayerManager(gl, {
          deck: this,
          stats: this.stats,
          viewport,
          timeline
        });
        this.effectManager = new EffectManager();
        this.deckRenderer = new DeckRenderer(gl);
        this.deckPicker = new DeckPicker(gl);
        this.setProps(this.props);
        this._updateCanvasSize();
        this.props.onLoad();
      }
      _drawLayers(redrawReason, renderOptions) {
        const {
          gl
        } = this.layerManager.context;
        setParameters(gl, this.props.parameters);
        this.props.onBeforeRender({
          gl
        });
        this.deckRenderer.renderLayers({
          target: this.props._framebuffer,
          layers: this.layerManager.getLayers(),
          viewports: this.viewManager.getViewports(),
          onViewportActive: this.layerManager.activateViewport,
          views: this.viewManager.getViews(),
          pass: "screen",
          effects: this.effectManager.getEffects(),
          ...renderOptions
        });
        this.props.onAfterRender({
          gl
        });
      }
      _onRenderFrame(animationProps) {
        this._getFrameStats();
        if (this._metricsCounter++ % 60 === 0) {
          this._getMetrics();
          this.stats.reset();
          log_default.table(4, this.metrics)();
          if (this.props._onMetrics) {
            this.props._onMetrics(this.metrics);
          }
        }
        this._updateCanvasSize();
        this._updateCursor();
        if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
          this.tooltip.setTooltip(null);
        }
        this.layerManager.updateLayers();
        this._pickAndCallback();
        this.redraw();
        if (this.viewManager) {
          this.viewManager.updateViewStates();
        }
      }
      _onViewStateChange(params) {
        const viewState = this.props.onViewStateChange(params) || params.viewState;
        if (this.viewState) {
          this.viewState = {
            ...this.viewState,
            [params.viewId]: viewState
          };
          if (!this.props.viewState) {
            if (this.viewManager) {
              this.viewManager.setProps({
                viewState: this.viewState
              });
            }
          }
        }
      }
      _onInteractionStateChange(interactionState) {
        this.cursorState.isDragging = interactionState.isDragging || false;
        this.props.onInteractionStateChange(interactionState);
      }
      _getFrameStats() {
        const {
          stats
        } = this;
        stats.get("frameRate").timeEnd();
        stats.get("frameRate").timeStart();
        const animationLoopStats = this.animationLoop.stats;
        stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
        stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
      }
      _getMetrics() {
        const {
          metrics,
          stats
        } = this;
        metrics.fps = stats.get("frameRate").getHz();
        metrics.setPropsTime = stats.get("setProps Time").time;
        metrics.updateAttributesTime = stats.get("Update Attributes").time;
        metrics.framesRedrawn = stats.get("Redraw Count").count;
        metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
        metrics.pickCount = stats.get("Pick Count").count;
        metrics.gpuTime = stats.get("GPU Time").time;
        metrics.cpuTime = stats.get("CPU Time").time;
        metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
        metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
        const memoryStats = lumaStats.get("Memory Usage");
        metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
        metrics.textureMemory = memoryStats.get("Texture Memory").count;
        metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
        metrics.gpuMemory = memoryStats.get("GPU Memory").count;
      }
    };
    _defineProperty(Deck, "defaultProps", defaultProps);
    _defineProperty(Deck, "VERSION", VERSION5);
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js
var ShaderAttribute;
var init_shader_attribute = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js"() {
    init_defineProperty();
    ShaderAttribute = class {
      constructor(dataColumn, opts) {
        _defineProperty(this, "opts", void 0);
        _defineProperty(this, "source", void 0);
        this.opts = opts;
        this.source = dataColumn;
      }
      get value() {
        return this.source.value;
      }
      getValue() {
        const buffer = this.source.getBuffer();
        const accessor = this.getAccessor();
        if (buffer) {
          return [buffer, accessor];
        }
        const {
          value
        } = this.source;
        const {
          size
        } = accessor;
        let constantValue = value;
        if (value && value.length !== size) {
          constantValue = new Float32Array(size);
          const index = accessor.elementOffset || 0;
          for (let i = 0; i < size; ++i) {
            constantValue[i] = value[index + i];
          }
        }
        return constantValue;
      }
      getAccessor() {
        return {
          ...this.source.getAccessor(),
          ...this.opts
        };
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js
function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Unknown GL type");
  }
}
var init_gl_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  }
  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
  return {
    ...shaderAttributeOptions,
    offset,
    stride
  };
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: {
      ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}
var DataColumn;
var init_data_column = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js"() {
    init_defineProperty();
    init_esm14();
    init_shader_attribute();
    init_gl_utils();
    init_typed_array_manager();
    init_math_utils2();
    init_log3();
    DataColumn = class {
      constructor(gl, opts, state) {
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "size", void 0);
        _defineProperty(this, "settings", void 0);
        _defineProperty(this, "value", void 0);
        _defineProperty(this, "doublePrecision", void 0);
        _defineProperty(this, "_buffer", void 0);
        _defineProperty(this, "state", void 0);
        this.gl = gl;
        this.id = opts.id || "";
        this.size = opts.size || 1;
        const logicalType = opts.logicalType || opts.type;
        const doublePrecision = logicalType === 5130;
        let {
          defaultValue
        } = opts;
        defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
        let bufferType;
        if (doublePrecision) {
          bufferType = 5126;
        } else if (!logicalType && opts.isIndexed) {
          bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
        } else {
          bufferType = logicalType || 5126;
        }
        let defaultType = glArrayFromType(logicalType || bufferType || 5126);
        this.doublePrecision = doublePrecision;
        if (doublePrecision && opts.fp64 === false) {
          defaultType = Float32Array;
        }
        this.value = null;
        this.settings = {
          ...opts,
          defaultType,
          defaultValue,
          logicalType,
          type: bufferType,
          size: this.size,
          bytesPerElement: defaultType.BYTES_PER_ELEMENT
        };
        this.state = {
          ...state,
          externalBuffer: null,
          bufferAccessor: this.settings,
          allocatedValue: null,
          numInstances: 0,
          bounds: null,
          constant: false
        };
        this._buffer = null;
      }
      get isConstant() {
        return this.state.constant;
      }
      get buffer() {
        if (!this._buffer) {
          const {
            isIndexed,
            type
          } = this.settings;
          this._buffer = new Buffer2(this.gl, {
            id: this.id,
            target: isIndexed ? 34963 : 34962,
            accessor: {
              type
            }
          });
        }
        return this._buffer;
      }
      get byteOffset() {
        const accessor = this.getAccessor();
        if (accessor.vertexOffset) {
          return accessor.vertexOffset * getStride(accessor);
        }
        return 0;
      }
      get numInstances() {
        return this.state.numInstances;
      }
      set numInstances(n) {
        this.state.numInstances = n;
      }
      delete() {
        if (this._buffer) {
          this._buffer.delete();
          this._buffer = null;
        }
        typed_array_manager_default.release(this.state.allocatedValue);
      }
      getShaderAttributes(id, options) {
        if (this.doublePrecision) {
          const shaderAttributes = {};
          const isBuffer64Bit = this.value instanceof Float64Array;
          const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
          shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);
          shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
          return shaderAttributes;
        }
        if (options) {
          const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
          return {
            [id]: new ShaderAttribute(this, shaderAttributeDef)
          };
        }
        return {
          [id]: this
        };
      }
      getBuffer() {
        if (this.state.constant) {
          return null;
        }
        return this.state.externalBuffer || this._buffer;
      }
      getValue() {
        if (this.state.constant) {
          return this.value;
        }
        return [this.getBuffer(), this.getAccessor()];
      }
      getAccessor() {
        return this.state.bufferAccessor;
      }
      getBounds() {
        if (this.state.bounds) {
          return this.state.bounds;
        }
        let result = null;
        if (this.state.constant && this.value) {
          const min = Array.from(this.value);
          result = [min, min];
        } else {
          const {
            value,
            numInstances,
            size
          } = this;
          const len2 = numInstances * size;
          if (value && len2 && value.length >= len2) {
            const min = new Array(size).fill(Infinity);
            const max = new Array(size).fill(-Infinity);
            for (let i = 0; i < len2; ) {
              for (let j = 0; j < size; j++) {
                const v = value[i++];
                if (v < min[j])
                  min[j] = v;
                if (v > max[j])
                  max[j] = v;
              }
            }
            result = [min, max];
          }
        }
        this.state.bounds = result;
        return result;
      }
      setData(data) {
        const {
          state
        } = this;
        let opts;
        if (ArrayBuffer.isView(data)) {
          opts = {
            value: data
          };
        } else if (data instanceof Buffer2) {
          opts = {
            buffer: data
          };
        } else {
          opts = data;
        }
        const accessor = {
          ...this.settings,
          ...opts
        };
        state.bufferAccessor = accessor;
        state.bounds = null;
        if (opts.constant) {
          let value = opts.value;
          value = this._normalizeValue(value, [], 0);
          if (this.settings.normalized) {
            value = this.normalizeConstant(value);
          }
          const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
          if (!hasChanged) {
            return false;
          }
          state.externalBuffer = null;
          state.constant = true;
          this.value = value;
        } else if (opts.buffer) {
          const buffer = opts.buffer;
          state.externalBuffer = buffer;
          state.constant = false;
          this.value = opts.value || null;
          const isBuffer64Bit = opts.value instanceof Float64Array;
          accessor.type = opts.type || buffer.accessor.type;
          accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
          accessor.stride = getStride(accessor);
        } else if (opts.value) {
          this._checkExternalBuffer(opts);
          let value = opts.value;
          state.externalBuffer = null;
          state.constant = false;
          this.value = value;
          accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
          accessor.stride = getStride(accessor);
          const {
            buffer,
            byteOffset
          } = this;
          if (this.doublePrecision && value instanceof Float64Array) {
            value = toDoublePrecisionArray(value, accessor);
          }
          const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
          if (buffer.byteLength < requiredBufferSize) {
            buffer.reallocate(requiredBufferSize);
          }
          buffer.setAccessor(null);
          buffer.subData({
            data: value,
            offset: byteOffset
          });
          accessor.type = opts.type || buffer.accessor.type;
        }
        return true;
      }
      updateSubBuffer(opts = {}) {
        this.state.bounds = null;
        const value = this.value;
        const {
          startOffset = 0,
          endOffset
        } = opts;
        this.buffer.subData({
          data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
            size: this.size,
            startIndex: startOffset,
            endIndex: endOffset
          }) : value.subarray(startOffset, endOffset),
          offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
        });
      }
      allocate(numInstances, copy2 = false) {
        const {
          state
        } = this;
        const oldValue = state.allocatedValue;
        const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
          size: this.size,
          type: this.settings.defaultType,
          copy: copy2
        });
        this.value = value;
        const {
          buffer,
          byteOffset
        } = this;
        if (buffer.byteLength < value.byteLength + byteOffset) {
          buffer.reallocate(value.byteLength + byteOffset);
          if (copy2 && oldValue) {
            buffer.subData({
              data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
              offset: byteOffset
            });
          }
        }
        state.allocatedValue = value;
        state.constant = false;
        state.externalBuffer = null;
        state.bufferAccessor = this.settings;
        return true;
      }
      _checkExternalBuffer(opts) {
        const {
          value
        } = opts;
        if (!ArrayBuffer.isView(value)) {
          throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
        }
        const ArrayType = this.settings.defaultType;
        let illegalArrayType = false;
        if (this.doublePrecision) {
          illegalArrayType = value.BYTES_PER_ELEMENT < 4;
        }
        if (illegalArrayType) {
          throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
        }
        if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
          log_default.warn("Attribute ".concat(this.id, " is normalized"))();
        }
      }
      normalizeConstant(value) {
        switch (this.settings.type) {
          case 5120:
            return new Float32Array(value).map((x) => (x + 128) / 255 * 2 - 1);
          case 5122:
            return new Float32Array(value).map((x) => (x + 32768) / 65535 * 2 - 1);
          case 5121:
            return new Float32Array(value).map((x) => x / 255);
          case 5123:
            return new Float32Array(value).map((x) => x / 65535);
          default:
            return value;
        }
      }
      _normalizeValue(value, out, start) {
        const {
          defaultValue,
          size
        } = this.settings;
        if (Number.isFinite(value)) {
          out[start] = value;
          return out;
        }
        if (!value) {
          let i = size;
          while (--i >= 0) {
            out[start + i] = defaultValue[i];
          }
          return out;
        }
        switch (size) {
          case 4:
            out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
          case 3:
            out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
          case 2:
            out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
          case 1:
            out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
            break;
          default:
            let i = size;
            while (--i >= 0) {
              out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
            }
        }
        return out;
      }
      _areValuesEqual(value1, value2) {
        if (!value1 || !value2) {
          return false;
        }
        const {
          size
        } = this;
        for (let i = 0; i < size; i++) {
          if (value1[i] !== value2[i]) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js
function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data,
    target: []
  };
  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === "function") {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return {
    iterable,
    objectInfo
  };
}
function isAsyncIterable2(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const {
    size,
    stride,
    offset,
    startIndices,
    nested
  } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_, {
    index,
    target
  }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;
      for (let j = 0; j < size; j++) {
        target[j] = typedArray[sourceIndex + j];
      }
      return target;
    }
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        target = new Array(size);
        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        result[i - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        for (let j = 0; j < size; j++) {
          result[targetIndex++] = typedArray[sourceIndex + j];
        }
      }
    }
    return result;
  };
}
var EMPTY_ARRAY, placeholderArray;
var init_iterable_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js"() {
    EMPTY_ARRAY = [];
    placeholderArray = [];
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/range.js
function add4(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range[0] < 0) {
    range[0] = 0;
  }
  if (range[0] >= range[1]) {
    return rangeList;
  }
  const newRangeList = [];
  const len2 = rangeList.length;
  let insertPosition = 0;
  for (let i = 0; i < len2; i++) {
    const range0 = rangeList[i];
    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}
var EMPTY, FULL;
var init_range = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/range.js"() {
    EMPTY = [];
    FULL = [[0, Infinity]];
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/array-utils.js
function padArrayChunk(options) {
  const {
    source,
    target,
    start = 0,
    size,
    getData
  } = options;
  const end = options.end || target.length;
  const sourceLength = source.length;
  const targetLength = end - start;
  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }
  target.set(source, start);
  if (!getData) {
    return;
  }
  let i = sourceLength;
  while (i < targetLength) {
    const datum = getData(i, source);
    for (let j = 0; j < size; j++) {
      target[start + i] = datum[j] || 0;
      i++;
    }
  }
}
function padArray({
  source,
  target,
  size,
  getData,
  sourceStartIndices,
  targetStartIndices
}) {
  if (!Array.isArray(targetStartIndices)) {
    padArrayChunk({
      source,
      target,
      size,
      getData
    });
    return target;
  }
  let sourceIndex = 0;
  let targetIndex = 0;
  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));
  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (let i = 1; i < n; i++) {
    const nextSourceIndex = sourceStartIndices[i] * size;
    const nextTargetIndex = targetStartIndices[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }
  return target;
}
var init_array_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/array-utils.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = {
      type: "interpolation",
      duration: userSettings
    };
  }
  const type = userSettings.type || "interpolation";
  return {
    ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}
function getSourceBufferAttribute(gl, attribute) {
  const buffer = attribute.getBuffer();
  if (buffer) {
    return [buffer, {
      divisor: 0,
      size: attribute.size,
      normalized: attribute.settings.normalized
    }];
  }
  return attribute.value;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error('No defined attribute type for size "'.concat(size, '"'));
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const {
    doublePrecision,
    settings,
    value,
    size
  } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
}
function padBuffer({
  buffer,
  numInstances,
  attribute,
  fromLength,
  fromStartIndices,
  getData = (x) => x
}) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const toLength = getAttributeBufferLength(attribute, numInstances);
  const isConstant = attribute.isConstant;
  if (!hasStartIndices && fromLength >= toLength) {
    return;
  }
  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
    srcByteOffset: byteOffset
  });
  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;
    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }
  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);
  const source = buffer.getData({
    length: fromLength
  });
  const data = new Float32Array(toLength);
  padArray({
    source,
    target: data,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });
  if (buffer.byteLength < data.byteLength + byteOffset) {
    buffer.reallocate(data.byteLength + byteOffset);
  }
  buffer.subData({
    data,
    offset: byteOffset
  });
}
var DEFAULT_TRANSITION_SETTINGS;
var init_attribute_transition_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js"() {
    init_array_utils();
    DEFAULT_TRANSITION_SETTINGS = {
      interpolation: {
        duration: 0,
        easing: (t) => t
      },
      spring: {
        stiffness: 0.05,
        damping: 0.5
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js
var Attribute;
var init_attribute = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js"() {
    init_defineProperty();
    init_data_column();
    init_assert9();
    init_iterable_utils();
    init_flatten();
    init_range();
    init_attribute_transition_utils();
    Attribute = class extends DataColumn {
      constructor(gl, opts) {
        super(gl, opts, {
          startIndices: null,
          lastExternalBuffer: null,
          binaryValue: null,
          binaryAccessor: null,
          needsUpdate: true,
          needsRedraw: false,
          updateRanges: FULL
        });
        _defineProperty(this, "constant", false);
        this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
        Object.seal(this.settings);
        Object.seal(this.state);
        this._validateAttributeUpdaters();
      }
      get startIndices() {
        return this.state.startIndices;
      }
      set startIndices(layout) {
        this.state.startIndices = layout;
      }
      needsUpdate() {
        return this.state.needsUpdate;
      }
      needsRedraw({
        clearChangedFlags = false
      } = {}) {
        const needsRedraw = this.state.needsRedraw;
        this.state.needsRedraw = needsRedraw && !clearChangedFlags;
        return needsRedraw;
      }
      getUpdateTriggers() {
        const {
          accessor
        } = this.settings;
        return [this.id].concat(typeof accessor !== "function" && accessor || []);
      }
      supportsTransition() {
        return Boolean(this.settings.transition);
      }
      getTransitionSetting(opts) {
        if (!opts || !this.supportsTransition()) {
          return null;
        }
        const {
          accessor
        } = this.settings;
        const layerSettings = this.settings.transition;
        const userSettings = Array.isArray(accessor) ? opts[accessor.find((a) => opts[a])] : opts[accessor];
        return normalizeTransitionSettings(userSettings, layerSettings);
      }
      setNeedsUpdate(reason = this.id, dataRange) {
        this.state.needsUpdate = this.state.needsUpdate || reason;
        this.setNeedsRedraw(reason);
        if (dataRange) {
          const {
            startRow = 0,
            endRow = Infinity
          } = dataRange;
          this.state.updateRanges = add4(this.state.updateRanges, [startRow, endRow]);
        } else {
          this.state.updateRanges = FULL;
        }
      }
      clearNeedsUpdate() {
        this.state.needsUpdate = false;
        this.state.updateRanges = EMPTY;
      }
      setNeedsRedraw(reason = this.id) {
        this.state.needsRedraw = this.state.needsRedraw || reason;
      }
      allocate(numInstances) {
        const {
          state,
          settings
        } = this;
        if (settings.noAlloc) {
          return false;
        }
        if (settings.update) {
          super.allocate(numInstances, state.updateRanges !== FULL);
          return true;
        }
        return false;
      }
      updateBuffer({
        numInstances,
        data,
        props,
        context
      }) {
        if (!this.needsUpdate()) {
          return false;
        }
        const {
          state: {
            updateRanges
          },
          settings: {
            update,
            noAlloc
          }
        } = this;
        let updated = true;
        if (update) {
          for (const [startRow, endRow] of updateRanges) {
            update.call(context, this, {
              data,
              startRow,
              endRow,
              props,
              numInstances
            });
          }
          if (!this.value) {
          } else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
            this.setData({
              value: this.value,
              constant: this.constant
            });
            this.constant = false;
          } else {
            for (const [startRow, endRow] of updateRanges) {
              const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
              const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
              super.updateSubBuffer({
                startOffset,
                endOffset
              });
            }
          }
          this._checkAttributeArray();
        } else {
          updated = false;
        }
        this.clearNeedsUpdate();
        this.setNeedsRedraw();
        return updated;
      }
      setConstantValue(value) {
        if (value === void 0 || typeof value === "function") {
          return false;
        }
        const hasChanged = this.setData({
          constant: true,
          value
        });
        if (hasChanged) {
          this.setNeedsRedraw();
        }
        this.clearNeedsUpdate();
        return true;
      }
      setExternalBuffer(buffer) {
        const {
          state
        } = this;
        if (!buffer) {
          state.lastExternalBuffer = null;
          return false;
        }
        this.clearNeedsUpdate();
        if (state.lastExternalBuffer === buffer) {
          return true;
        }
        state.lastExternalBuffer = buffer;
        this.setNeedsRedraw();
        this.setData(buffer);
        return true;
      }
      setBinaryValue(buffer, startIndices = null) {
        const {
          state,
          settings
        } = this;
        if (!buffer) {
          state.binaryValue = null;
          state.binaryAccessor = null;
          return false;
        }
        if (settings.noAlloc) {
          return false;
        }
        if (state.binaryValue === buffer) {
          this.clearNeedsUpdate();
          return true;
        }
        state.binaryValue = buffer;
        this.setNeedsRedraw();
        const needsUpdate = settings.transform || startIndices !== this.startIndices;
        if (needsUpdate) {
          if (ArrayBuffer.isView(buffer)) {
            buffer = {
              value: buffer
            };
          }
          const binaryValue = buffer;
          assert9(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
          const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
          state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
            size: binaryValue.size || this.size,
            stride: binaryValue.stride,
            offset: binaryValue.offset,
            startIndices,
            nested: needsNormalize
          });
          return false;
        }
        this.clearNeedsUpdate();
        this.setData(buffer);
        return true;
      }
      getVertexOffset(row) {
        const {
          startIndices
        } = this;
        const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
        return vertexIndex * this.size;
      }
      getShaderAttributes() {
        const shaderAttributeDefs = this.settings.shaderAttributes || {
          [this.id]: null
        };
        const shaderAttributes = {};
        for (const shaderAttributeName in shaderAttributeDefs) {
          Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
        }
        return shaderAttributes;
      }
      _autoUpdater(attribute, {
        data,
        startRow,
        endRow,
        props,
        numInstances
      }) {
        if (attribute.constant) {
          return;
        }
        const {
          settings,
          state,
          value,
          size,
          startIndices
        } = attribute;
        const {
          accessor,
          transform: transform2
        } = settings;
        const accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
        assert9(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
        let i = attribute.getVertexOffset(startRow);
        const {
          iterable,
          objectInfo
        } = createIterable(data, startRow, endRow);
        for (const object of iterable) {
          objectInfo.index++;
          let objectValue = accessorFunc(object, objectInfo);
          if (transform2) {
            objectValue = transform2.call(this, objectValue);
          }
          if (startIndices) {
            const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
            if (objectValue && Array.isArray(objectValue[0])) {
              let startIndex = i;
              for (const item of objectValue) {
                attribute._normalizeValue(item, value, startIndex);
                startIndex += size;
              }
            } else if (objectValue && objectValue.length > size) {
              value.set(objectValue, i);
            } else {
              attribute._normalizeValue(objectValue, objectInfo.target, 0);
              fillArray2({
                target: value,
                source: objectInfo.target,
                start: i,
                count: numVertices
              });
            }
            i += numVertices * size;
          } else {
            attribute._normalizeValue(objectValue, value, i);
            i += size;
          }
        }
      }
      _validateAttributeUpdaters() {
        const {
          settings
        } = this;
        const hasUpdater = settings.noAlloc || typeof settings.update === "function";
        if (!hasUpdater) {
          throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
        }
      }
      _checkAttributeArray() {
        const {
          value
        } = this;
        const limit = Math.min(4, this.size);
        if (value && value.length >= limit) {
          let valid = true;
          switch (limit) {
            case 4:
              valid = valid && Number.isFinite(value[3]);
            case 3:
              valid = valid && Number.isFinite(value[2]);
            case 2:
              valid = valid && Number.isFinite(value[1]);
            case 1:
              valid = valid && Number.isFinite(value[0]);
              break;
            default:
              valid = false;
          }
          if (!valid) {
            throw new Error("Illegal attribute generated for ".concat(this.id));
          }
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js
function getTransform(gl, attribute) {
  const attributeType = getAttributeTypeFromSize(attribute.size);
  return new Transform2(gl, {
    vs: vs8,
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vCurrent"]
  });
}
var GPUInterpolationTransition, vs8;
var init_gpu_interpolation_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js"() {
    init_defineProperty();
    init_esm14();
    init_attribute();
    init_attribute_transition_utils();
    init_transition();
    GPUInterpolationTransition = class {
      constructor({
        gl,
        attribute,
        timeline
      }) {
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "type", "interpolation");
        _defineProperty(this, "attributeInTransition", void 0);
        _defineProperty(this, "settings", void 0);
        _defineProperty(this, "attribute", void 0);
        _defineProperty(this, "transition", void 0);
        _defineProperty(this, "currentStartIndices", void 0);
        _defineProperty(this, "currentLength", void 0);
        _defineProperty(this, "transform", void 0);
        _defineProperty(this, "buffers", void 0);
        this.gl = gl;
        this.transition = new Transition(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new Attribute(gl, attribute.settings);
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.transform = getTransform(gl, attribute);
        const bufferOpts = {
          byteLength: 0,
          usage: 35050
        };
        this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
      }
      get inProgress() {
        return this.transition.inProgress;
      }
      start(transitionSettings, numInstances) {
        if (transitionSettings.duration <= 0) {
          this.transition.cancel();
          return;
        }
        this.settings = transitionSettings;
        const {
          gl,
          buffers,
          attribute
        } = this;
        cycleBuffers(buffers);
        const padBufferOpts = {
          numInstances,
          attribute,
          fromLength: this.currentLength,
          fromStartIndices: this.currentStartIndices,
          getData: transitionSettings.enter
        };
        for (const buffer of buffers) {
          padBuffer({
            buffer,
            ...padBufferOpts
          });
        }
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = getAttributeBufferLength(attribute, numInstances);
        this.attributeInTransition.setData({
          buffer: buffers[1],
          value: attribute.value
        });
        this.transition.start(transitionSettings);
        this.transform.update({
          elementCount: Math.floor(this.currentLength / attribute.size),
          sourceBuffers: {
            aFrom: buffers[0],
            aTo: getSourceBufferAttribute(gl, attribute)
          },
          feedbackBuffers: {
            vCurrent: buffers[1]
          }
        });
      }
      update() {
        const updated = this.transition.update();
        if (updated) {
          const {
            duration,
            easing
          } = this.settings;
          const {
            time
          } = this.transition;
          let t = time / duration;
          if (easing) {
            t = easing(t);
          }
          this.transform.run({
            uniforms: {
              time: t
            }
          });
        }
        return updated;
      }
      cancel() {
        this.transition.cancel();
        this.transform.delete();
        for (const buffer of this.buffers) {
          buffer.delete();
        }
        this.buffers.length = 0;
      }
    };
    vs8 = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js
function getTransform2(gl, attribute, framebuffer) {
  const attributeType = getAttributeTypeFromSize(attribute.size);
  return new Transform2(gl, {
    framebuffer,
    vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
    fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vNext"]
  });
}
function getTexture(gl) {
  return new Texture2D(gl, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: false,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function getFramebuffer2(gl, texture) {
  return new Framebuffer(gl, {
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    attachments: {
      [36064]: texture
    }
  });
}
var GPUSpringTransition;
var init_gpu_spring_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js"() {
    init_defineProperty();
    init_esm14();
    init_attribute_transition_utils();
    init_attribute();
    init_transition();
    GPUSpringTransition = class {
      constructor({
        gl,
        attribute,
        timeline
      }) {
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "type", "spring");
        _defineProperty(this, "attributeInTransition", void 0);
        _defineProperty(this, "settings", void 0);
        _defineProperty(this, "attribute", void 0);
        _defineProperty(this, "transition", void 0);
        _defineProperty(this, "currentStartIndices", void 0);
        _defineProperty(this, "currentLength", void 0);
        _defineProperty(this, "texture", void 0);
        _defineProperty(this, "framebuffer", void 0);
        _defineProperty(this, "transform", void 0);
        _defineProperty(this, "buffers", void 0);
        this.gl = gl;
        this.type = "spring";
        this.transition = new Transition(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new Attribute(gl, {
          ...attribute.settings,
          normalized: false
        });
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.texture = getTexture(gl);
        this.framebuffer = getFramebuffer2(gl, this.texture);
        this.transform = getTransform2(gl, attribute, this.framebuffer);
        const bufferOpts = {
          byteLength: 0,
          usage: 35050
        };
        this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
      }
      get inProgress() {
        return this.transition.inProgress;
      }
      start(transitionSettings, numInstances) {
        const {
          gl,
          buffers,
          attribute
        } = this;
        const padBufferOpts = {
          numInstances,
          attribute,
          fromLength: this.currentLength,
          fromStartIndices: this.currentStartIndices,
          getData: transitionSettings.enter
        };
        for (const buffer of buffers) {
          padBuffer({
            buffer,
            ...padBufferOpts
          });
        }
        this.settings = transitionSettings;
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = getAttributeBufferLength(attribute, numInstances);
        this.attributeInTransition.setData({
          buffer: buffers[1],
          value: attribute.value
        });
        this.transition.start({
          ...transitionSettings,
          duration: Infinity
        });
        this.transform.update({
          elementCount: Math.floor(this.currentLength / attribute.size),
          sourceBuffers: {
            aTo: getSourceBufferAttribute(gl, attribute)
          }
        });
      }
      update() {
        const {
          buffers,
          transform: transform2,
          framebuffer,
          transition
        } = this;
        const updated = transition.update();
        if (!updated) {
          return false;
        }
        const settings = this.settings;
        transform2.update({
          sourceBuffers: {
            aPrev: buffers[0],
            aCur: buffers[1]
          },
          feedbackBuffers: {
            vNext: buffers[2]
          }
        });
        transform2.run({
          framebuffer,
          discard: false,
          clearRenderTarget: true,
          uniforms: {
            stiffness: settings.stiffness,
            damping: settings.damping
          },
          parameters: {
            depthTest: false,
            blend: true,
            viewport: [0, 0, 1, 1],
            blendFunc: [1, 1],
            blendEquation: [32776, 32776]
          }
        });
        cycleBuffers(buffers);
        this.attributeInTransition.setData({
          buffer: buffers[1],
          value: this.attribute.value
        });
        const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;
        if (!isTransitioning) {
          transition.end();
        }
        return true;
      }
      cancel() {
        this.transition.cancel();
        this.transform.delete();
        for (const buffer of this.buffers) {
          buffer.delete();
        }
        this.buffers.length = 0;
        this.texture.delete();
        this.framebuffer.delete();
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js
var TRANSITION_TYPES, AttributeTransitionManager;
var init_attribute_transition_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js"() {
    init_defineProperty();
    init_esm14();
    init_gpu_interpolation_transition();
    init_gpu_spring_transition();
    init_log3();
    TRANSITION_TYPES = {
      interpolation: GPUInterpolationTransition,
      spring: GPUSpringTransition
    };
    AttributeTransitionManager = class {
      constructor(gl, {
        id,
        timeline
      }) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "isSupported", void 0);
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "timeline", void 0);
        _defineProperty(this, "transitions", void 0);
        _defineProperty(this, "needsRedraw", void 0);
        _defineProperty(this, "numInstances", void 0);
        this.id = id;
        this.gl = gl;
        this.timeline = timeline;
        this.transitions = {};
        this.needsRedraw = false;
        this.numInstances = 1;
        this.isSupported = Transform2.isSupported(gl);
      }
      finalize() {
        for (const attributeName in this.transitions) {
          this._removeTransition(attributeName);
        }
      }
      update({
        attributes,
        transitions,
        numInstances
      }) {
        this.numInstances = numInstances || 1;
        for (const attributeName in attributes) {
          const attribute = attributes[attributeName];
          const settings = attribute.getTransitionSetting(transitions);
          if (!settings)
            continue;
          this._updateAttribute(attributeName, attribute, settings);
        }
        for (const attributeName in this.transitions) {
          const attribute = attributes[attributeName];
          if (!attribute || !attribute.getTransitionSetting(transitions)) {
            this._removeTransition(attributeName);
          }
        }
      }
      hasAttribute(attributeName) {
        const transition = this.transitions[attributeName];
        return transition && transition.inProgress;
      }
      getAttributes() {
        const animatedAttributes = {};
        for (const attributeName in this.transitions) {
          const transition = this.transitions[attributeName];
          if (transition.inProgress) {
            animatedAttributes[attributeName] = transition.attributeInTransition;
          }
        }
        return animatedAttributes;
      }
      run() {
        if (!this.isSupported || this.numInstances === 0) {
          return false;
        }
        for (const attributeName in this.transitions) {
          const updated = this.transitions[attributeName].update();
          if (updated) {
            this.needsRedraw = true;
          }
        }
        const needsRedraw = this.needsRedraw;
        this.needsRedraw = false;
        return needsRedraw;
      }
      _removeTransition(attributeName) {
        this.transitions[attributeName].cancel();
        delete this.transitions[attributeName];
      }
      _updateAttribute(attributeName, attribute, settings) {
        const transition = this.transitions[attributeName];
        let isNew = !transition || transition.type !== settings.type;
        if (isNew) {
          if (!this.isSupported) {
            log_default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
            return;
          }
          if (transition) {
            this._removeTransition(attributeName);
          }
          const TransitionType = TRANSITION_TYPES[settings.type];
          if (TransitionType) {
            this.transitions[attributeName] = new TransitionType({
              attribute,
              timeline: this.timeline,
              gl: this.gl
            });
          } else {
            log_default.error("unsupported transition type '".concat(settings.type, "'"))();
            isNew = false;
          }
        }
        if (isNew || attribute.needsRedraw()) {
          this.needsRedraw = true;
          this.transitions[attributeName].start(settings, this.numInstances);
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js
var TRACE_INVALIDATE, TRACE_UPDATE_START, TRACE_UPDATE_END, TRACE_ATTRIBUTE_UPDATE_START, TRACE_ATTRIBUTE_ALLOCATE, TRACE_ATTRIBUTE_UPDATE_END, AttributeManager;
var init_attribute_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js"() {
    init_defineProperty();
    init_attribute();
    init_log3();
    init_memoize();
    init_math_utils2();
    init_debug();
    init_attribute_transition_manager();
    TRACE_INVALIDATE = "attributeManager.invalidate";
    TRACE_UPDATE_START = "attributeManager.updateStart";
    TRACE_UPDATE_END = "attributeManager.updateEnd";
    TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
    TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
    TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
    AttributeManager = class {
      constructor(gl, {
        id = "attribute-manager",
        stats,
        timeline
      } = {}) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "attributes", void 0);
        _defineProperty(this, "updateTriggers", void 0);
        _defineProperty(this, "needsRedraw", void 0);
        _defineProperty(this, "userData", void 0);
        _defineProperty(this, "stats", void 0);
        _defineProperty(this, "attributeTransitionManager", void 0);
        _defineProperty(this, "mergeBoundsMemoized", memoize(mergeBounds));
        this.id = id;
        this.gl = gl;
        this.attributes = {};
        this.updateTriggers = {};
        this.needsRedraw = true;
        this.userData = {};
        this.stats = stats;
        this.attributeTransitionManager = new AttributeTransitionManager(gl, {
          id: "".concat(id, "-transitions"),
          timeline
        });
        Object.seal(this);
      }
      finalize() {
        for (const attributeName in this.attributes) {
          this.attributes[attributeName].delete();
        }
        this.attributeTransitionManager.finalize();
      }
      getNeedsRedraw(opts = {
        clearRedrawFlags: false
      }) {
        const redraw = this.needsRedraw;
        this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
        return redraw && this.id;
      }
      setNeedsRedraw() {
        this.needsRedraw = true;
      }
      add(attributes) {
        this._add(attributes);
      }
      addInstanced(attributes) {
        this._add(attributes, {
          instanced: 1
        });
      }
      remove(attributeNameArray) {
        for (const name of attributeNameArray) {
          if (this.attributes[name] !== void 0) {
            this.attributes[name].delete();
            delete this.attributes[name];
          }
        }
      }
      invalidate(triggerName, dataRange) {
        const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
        debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
      }
      invalidateAll(dataRange) {
        for (const attributeName in this.attributes) {
          this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
        }
        debug(TRACE_INVALIDATE, this, "all");
      }
      update({
        data,
        numInstances,
        startIndices = null,
        transitions,
        props = {},
        buffers = {},
        context = {}
      }) {
        let updated = false;
        debug(TRACE_UPDATE_START, this);
        if (this.stats) {
          this.stats.get("Update Attributes").timeStart();
        }
        for (const attributeName in this.attributes) {
          const attribute = this.attributes[attributeName];
          const accessorName = attribute.settings.accessor;
          attribute.startIndices = startIndices;
          attribute.numInstances = numInstances;
          if (props[attributeName]) {
            log_default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
          }
          if (attribute.setExternalBuffer(buffers[attributeName])) {
          } else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {
          } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
          } else if (attribute.needsUpdate()) {
            updated = true;
            this._updateAttribute({
              attribute,
              numInstances,
              data,
              props,
              context
            });
          }
          this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
        }
        if (updated) {
          debug(TRACE_UPDATE_END, this, numInstances);
        }
        if (this.stats) {
          this.stats.get("Update Attributes").timeEnd();
        }
        this.attributeTransitionManager.update({
          attributes: this.attributes,
          numInstances,
          transitions
        });
      }
      updateTransition() {
        const {
          attributeTransitionManager
        } = this;
        const transitionUpdated = attributeTransitionManager.run();
        this.needsRedraw = this.needsRedraw || transitionUpdated;
        return transitionUpdated;
      }
      getAttributes() {
        return this.attributes;
      }
      getBounds(attributeNames) {
        const bounds = attributeNames.map((attributeName) => {
          var _this$attributes$attr;
          return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();
        });
        return this.mergeBoundsMemoized(bounds);
      }
      getChangedAttributes(opts = {
        clearChangedFlags: false
      }) {
        const {
          attributes,
          attributeTransitionManager
        } = this;
        const changedAttributes = {
          ...attributeTransitionManager.getAttributes()
        };
        for (const attributeName in attributes) {
          const attribute = attributes[attributeName];
          if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
            changedAttributes[attributeName] = attribute;
          }
        }
        return changedAttributes;
      }
      getShaderAttributes(attributes, excludeAttributes = {}) {
        if (!attributes) {
          attributes = this.getAttributes();
        }
        const shaderAttributes = {};
        for (const attributeName in attributes) {
          if (!excludeAttributes[attributeName]) {
            Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
          }
        }
        return shaderAttributes;
      }
      _add(attributes, extraProps = {}) {
        for (const attributeName in attributes) {
          const attribute = attributes[attributeName];
          this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
        }
        this._mapUpdateTriggersToAttributes();
      }
      _createAttribute(name, attribute, extraProps) {
        const props = {
          ...attribute,
          id: name,
          size: attribute.isIndexed && 1 || attribute.size || 1,
          divisor: extraProps.instanced ? 1 : attribute.divisor || 0
        };
        return new Attribute(this.gl, props);
      }
      _mapUpdateTriggersToAttributes() {
        const triggers = {};
        for (const attributeName in this.attributes) {
          const attribute = this.attributes[attributeName];
          attribute.getUpdateTriggers().forEach((triggerName) => {
            if (!triggers[triggerName]) {
              triggers[triggerName] = [];
            }
            triggers[triggerName].push(attributeName);
          });
        }
        this.updateTriggers = triggers;
      }
      _invalidateTrigger(triggerName, dataRange) {
        const {
          attributes,
          updateTriggers
        } = this;
        const invalidatedAttributes = updateTriggers[triggerName];
        if (invalidatedAttributes) {
          invalidatedAttributes.forEach((name) => {
            const attribute = attributes[name];
            if (attribute) {
              attribute.setNeedsUpdate(attribute.id, dataRange);
            }
          });
        }
        return invalidatedAttributes;
      }
      _updateAttribute(opts) {
        const {
          attribute,
          numInstances
        } = opts;
        debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
        if (attribute.constant) {
          attribute.setConstantValue(attribute.value);
          return;
        }
        if (attribute.allocate(numInstances)) {
          debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
        }
        const updated = attribute.updateBuffer(opts);
        if (updated) {
          this.needsRedraw = true;
          debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js
var CPUInterpolationTransition;
var init_cpu_interpolation_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js"() {
    init_esm11();
    init_transition();
    CPUInterpolationTransition = class extends Transition {
      get value() {
        return this._value;
      }
      _onUpdate() {
        const {
          time,
          settings: {
            fromValue,
            toValue,
            duration,
            easing
          }
        } = this;
        const t = easing(time / duration);
        this._value = lerp3(fromValue, toValue, t);
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];
    for (let i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;
    for (let i = 0; i < value1.length; i++) {
      const d = value1[i] - value2[i];
      distanceSquare += d * d;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value2);
}
var EPSILON3, CPUSpringTransition;
var init_cpu_spring_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js"() {
    init_transition();
    EPSILON3 = 1e-5;
    CPUSpringTransition = class extends Transition {
      get value() {
        return this._currValue;
      }
      _onUpdate() {
        const {
          fromValue,
          toValue,
          damping,
          stiffness
        } = this.settings;
        const {
          _prevValue = fromValue,
          _currValue = fromValue
        } = this;
        let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
        const delta = distance(nextValue, toValue);
        const velocity = distance(nextValue, _currValue);
        if (delta < EPSILON3 && velocity < EPSILON3) {
          nextValue = toValue;
          this.end();
        }
        this._prevValue = _currValue;
        this._currValue = nextValue;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js
var TRANSITION_TYPES2, UniformTransitionManager;
var init_uniform_transition_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js"() {
    init_attribute_transition_utils();
    init_cpu_interpolation_transition();
    init_cpu_spring_transition();
    init_log3();
    TRANSITION_TYPES2 = {
      interpolation: CPUInterpolationTransition,
      spring: CPUSpringTransition
    };
    UniformTransitionManager = class {
      constructor(timeline) {
        this.transitions = /* @__PURE__ */ new Map();
        this.timeline = timeline;
      }
      get active() {
        return this.transitions.size > 0;
      }
      add(key, fromValue, toValue, settings) {
        const {
          transitions
        } = this;
        if (transitions.has(key)) {
          const transition2 = transitions.get(key);
          const {
            value = transition2.settings.fromValue
          } = transition2;
          fromValue = value;
          this.remove(key);
        }
        settings = normalizeTransitionSettings(settings);
        if (!settings) {
          return;
        }
        const TransitionType = TRANSITION_TYPES2[settings.type];
        if (!TransitionType) {
          log_default.error("unsupported transition type '".concat(settings.type, "'"))();
          return;
        }
        const transition = new TransitionType(this.timeline);
        transition.start({
          ...settings,
          fromValue,
          toValue
        });
        transitions.set(key, transition);
      }
      remove(key) {
        const {
          transitions
        } = this;
        if (transitions.has(key)) {
          transitions.get(key).cancel();
          transitions.delete(key);
        }
      }
      update() {
        const propsInTransition = {};
        for (const [key, transition] of this.transitions) {
          transition.update();
          propsInTransition[key] = transition.value;
          if (!transition.inProgress) {
            this.remove(key);
          }
        }
        return propsInTransition;
      }
      clear() {
        for (const key of this.transitions.keys()) {
          this.remove(key);
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/props.js
function validateProps(props) {
  const propTypes = props[PROP_TYPES_SYMBOL];
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      validate
    } = propType;
    if (validate && !validate(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[PROP_TYPES_SYMBOL],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }
  const result = {};
  const propTypes = props[PROP_TYPES_SYMBOL];
  let changed = false;
  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === "number" || type === "color" || type === "array";
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }
  return changed ? result : false;
}
function compareProps({
  newProps,
  oldProps,
  ignoreProps = {},
  propTypes = {},
  triggerName = "props"
}) {
  if (oldProps === newProps) {
    return false;
  }
  if (typeof newProps !== "object" || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  if (typeof oldProps !== "object" || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }
      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }
  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return "".concat(triggerName, ".").concat(key, " dropped");
      }
      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
  }
  return false;
}
function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;
  if (equal && !equal(newProp, oldProp, propType)) {
    return "changed deeply";
  }
  if (!equal) {
    equal = newProp && oldProp && newProp.equals;
    if (equal && !equal.call(newProp, oldProp)) {
      return "changed deeply";
    }
  }
  if (!equal && oldProp !== newProp) {
    return "changed shallowly";
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  let dataChanged = false;
  const {
    dataComparator,
    _dataDiff
  } = props;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = "Data comparator detected a change";
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = "A new data container was supplied";
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return {
      all: true
    };
  }
  if ("all" in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, "all");
    if (diffReason) {
      return {
        all: true
      };
    }
  }
  const reason = {};
  let changed = false;
  for (const triggerName in props.updateTriggers) {
    if (triggerName !== "all") {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }
  return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }
  const oldExtensions = oldProps.extensions;
  const {
    extensions
  } = props;
  if (extensions === oldExtensions) {
    return false;
  }
  if (!oldExtensions || !extensions) {
    return true;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (let i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}
var init_props = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/props.js"() {
    init_constants3();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/count.js
function count(container) {
  if (!isObject2(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === "function") {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && value.constructor === Object;
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}
var ERR_NOT_OBJECT, ERR_NOT_CONTAINER;
var init_count = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/count.js"() {
    ERR_NOT_OBJECT = "count(): argument not an object";
    ERR_NOT_CONTAINER = "count(): argument not a container";
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/shader.js
function mergeShaders(target, source) {
  if (!source) {
    return target;
  }
  const result = {
    ...target,
    ...source
  };
  if ("defines" in source) {
    result.defines = {
      ...target.defines,
      ...source.defines
    };
  }
  if ("modules" in source) {
    result.modules = (target.modules || []).concat(source.modules);
    if (source.modules.some((module) => module.name === "project64")) {
      const index = result.modules.findIndex((module) => module.name === "project32");
      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }
  if ("inject" in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      const mergedInjection = {
        ...target.inject
      };
      for (const key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}
var init_shader2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/shader.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/texture.js
function createTexture(owner, gl, image, parameters) {
  if (image instanceof Texture2D) {
    return image;
  } else if (image.constructor && image.constructor.name !== "Object") {
    image = {
      data: image
    };
  }
  let specialTextureParameters = null;
  if (image.compressed) {
    specialTextureParameters = {
      [10241]: image.data.length > 1 ? 9985 : 9729
    };
  }
  const texture = new Texture2D(gl, {
    ...image,
    parameters: {
      ...DEFAULT_TEXTURE_PARAMETERS,
      ...specialTextureParameters,
      ...parameters
    }
  });
  internalTextures[texture.id] = owner;
  return texture;
}
function destroyTexture(owner, texture) {
  if (!texture || !(texture instanceof Texture2D)) {
    return;
  }
  if (internalTextures[texture.id] === owner) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}
var DEFAULT_TEXTURE_PARAMETERS, internalTextures;
var init_texture2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/texture.js"() {
    init_esm14();
    DEFAULT_TEXTURE_PARAMETERS = {
      [10241]: 9987,
      [10240]: 9729,
      [10242]: 33071,
      [10243]: 33071
    };
    internalTextures = {};
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js
function parsePropTypes2(propDefs) {
  const propTypes = {};
  const defaultProps3 = {};
  const deprecatedProps = {};
  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType2(propName, propDef);
      propTypes[propName] = propType;
      defaultProps3[propName] = propType.value;
    }
  }
  return {
    propTypes,
    defaultProps: defaultProps3,
    deprecatedProps
  };
}
function parsePropType2(name, propDef) {
  switch (getTypeOf2(propDef)) {
    case "object":
      return normalizePropDefinition(name, propDef);
    case "array":
      return normalizePropDefinition(name, {
        type: "array",
        value: propDef,
        compare: false
      });
    case "boolean":
      return normalizePropDefinition(name, {
        type: "boolean",
        value: propDef
      });
    case "number":
      return normalizePropDefinition(name, {
        type: "number",
        value: propDef
      });
    case "function":
      return normalizePropDefinition(name, {
        type: "function",
        value: propDef,
        compare: true
      });
    default:
      return {
        name,
        type: "unknown",
        value: propDef
      };
  }
}
function normalizePropDefinition(name, propDef) {
  if (!("type" in propDef)) {
    if (!("value" in propDef)) {
      return {
        name,
        type: "object",
        value: propDef
      };
    }
    return {
      name,
      type: getTypeOf2(propDef.value),
      ...propDef
    };
  }
  return {
    name,
    ...TYPE_DEFINITIONS2[propDef.type],
    ...propDef
  };
}
function isArray3(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf2(value) {
  if (isArray3(value)) {
    return "array";
  }
  if (value === null) {
    return "null";
  }
  return typeof value;
}
var TYPE_DEFINITIONS2;
var init_prop_types2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js"() {
    init_texture2();
    init_deep_equal();
    TYPE_DEFINITIONS2 = {
      boolean: {
        validate(value, propType) {
          return true;
        },
        equal(value1, value2, propType) {
          return Boolean(value1) === Boolean(value2);
        }
      },
      number: {
        validate(value, propType) {
          return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
        }
      },
      color: {
        validate(value, propType) {
          return propType.optional && !value || isArray3(value) && (value.length === 3 || value.length === 4);
        },
        equal(value1, value2, propType) {
          return deepEqual(value1, value2, 1);
        }
      },
      accessor: {
        validate(value, propType) {
          const valueType = getTypeOf2(value);
          return valueType === "function" || valueType === getTypeOf2(propType.value);
        },
        equal(value1, value2, propType) {
          if (typeof value2 === "function") {
            return true;
          }
          return deepEqual(value1, value2, 1);
        }
      },
      array: {
        validate(value, propType) {
          return propType.optional && !value || isArray3(value);
        },
        equal(value1, value2, propType) {
          const {
            compare
          } = propType;
          const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
          return compare ? deepEqual(value1, value2, depth) : value1 === value2;
        }
      },
      object: {
        equal(value1, value2, propType) {
          if (propType.ignore) {
            return true;
          }
          const {
            compare
          } = propType;
          const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
          return compare ? deepEqual(value1, value2, depth) : value1 === value2;
        }
      },
      function: {
        validate(value, propType) {
          return propType.optional && !value || typeof value === "function";
        },
        equal(value1, value2, propType) {
          const shouldIgnore = !propType.compare && propType.ignore !== false;
          return shouldIgnore || value1 === value2;
        }
      },
      data: {
        transform: (value, propType, component) => {
          const {
            dataTransform
          } = component.props;
          return dataTransform && value ? dataTransform(value) : value;
        }
      },
      image: {
        transform: (value, propType, component) => {
          const context = component.context;
          if (!context || !context.gl) {
            return null;
          }
          return createTexture(component.id, context.gl, value, {
            ...propType.parameters,
            ...component.props.textureParameters
          });
        },
        release: (value, propType, component) => {
          destroyTexture(component.id, value);
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js
function createProps(component, propObjects) {
  let extensions;
  for (let i = propObjects.length - 1; i >= 0; i--) {
    const props = propObjects[i];
    if ("extensions" in props) {
      extensions = props.extensions;
    }
  }
  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[COMPONENT_SYMBOL] = component;
  propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
  for (let i = 0; i < propObjects.length; ++i) {
    const props = propObjects[i];
    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
function getPropsPrototype(componentClass, extensions) {
  let cacheKey = MergedDefaultPropsCacheKey;
  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;
      if (ExtensionClass) {
        cacheKey += ":".concat(ExtensionClass.extensionName || ExtensionClass.name);
      }
    }
  }
  const defaultProps3 = getOwnProperty(componentClass, cacheKey);
  if (!defaultProps3) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }
  return defaultProps3;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;
  if (!parent) {
    return null;
  }
  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
  const componentPropDefs = parsePropTypes2(componentDefaultProps);
  const defaultProps3 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);
    if (extensionDefaultProps) {
      Object.assign(defaultProps3, extensionDefaultProps);
      Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
    }
  }
  createPropsPrototype(defaultProps3, componentClass);
  addAsyncPropsToPropPrototype(defaultProps3, propTypes);
  addDeprecatedPropsToPropPrototype(defaultProps3, deprecatedProps);
  defaultProps3[PROP_TYPES_SYMBOL] = propTypes;
  defaultProps3[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
  if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
    componentClass._propTypes = propTypes;
  }
  return defaultProps3;
}
function createPropsPrototype(defaultProps3, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps3, {
    id: {
      writable: true,
      value: id
    }
  });
}
function addDeprecatedPropsToPropPrototype(defaultProps3, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps3, propName, {
      enumerable: false,
      set(newValue) {
        const nameStr = "".concat(this.id, ": ").concat(propName);
        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }
        log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
      }
    });
  }
}
function addAsyncPropsToPropPrototype(defaultProps3, propTypes) {
  const defaultValues = {};
  const descriptors = {};
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      name,
      value
    } = propType;
    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name);
    }
  }
  defaultProps3[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps3[ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps3, descriptors);
}
function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,
    set(newValue) {
      if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
        this[ASYNC_ORIGINAL_SYMBOL][name] = newValue;
      } else {
        this[ASYNC_RESOLVED_SYMBOL][name] = newValue;
      }
    },
    get() {
      if (this[ASYNC_RESOLVED_SYMBOL]) {
        if (name in this[ASYNC_RESOLVED_SYMBOL]) {
          const value = this[ASYNC_RESOLVED_SYMBOL][name];
          return value || this[ASYNC_DEFAULTS_SYMBOL][name];
        }
        if (name in this[ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[ASYNC_DEFAULTS_SYMBOL][name];
          }
        }
      }
      return this[ASYNC_DEFAULTS_SYMBOL][name];
    }
  };
}
function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
  const componentName = componentClass.componentName;
  if (!componentName) {
    log_default.warn("".concat(componentClass.name, ".componentName not specified"))();
  }
  return componentName || componentClass.name;
}
var MergedDefaultPropsCacheKey;
var init_create_props = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js"() {
    init_log3();
    init_iterable_utils();
    init_prop_types2();
    init_constants3();
    MergedDefaultPropsCacheKey = "_mergedDefaultProps";
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/component.js
var counter, Component;
var init_component = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/component.js"() {
    init_defineProperty();
    init_constants3();
    init_create_props();
    counter = 0;
    Component = class {
      constructor(...propObjects) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "count", void 0);
        this.props = createProps(this, propObjects);
        this.id = this.props.id;
        this.count = counter++;
      }
      clone(newProps) {
        const {
          props
        } = this;
        const asyncProps = {};
        for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
          if (key in props[ASYNC_RESOLVED_SYMBOL]) {
            asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
          } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
            asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
          }
        }
        return new this.constructor({
          ...props,
          ...asyncProps,
          ...newProps
        });
      }
    };
    _defineProperty(Component, "componentName", "Component");
    _defineProperty(Component, "defaultProps", {});
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js
var EMPTY_PROPS, ComponentState;
var init_component_state = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"() {
    init_defineProperty();
    init_iterable_utils();
    init_constants3();
    EMPTY_PROPS = Object.freeze({});
    ComponentState = class {
      constructor(component) {
        _defineProperty(this, "component", void 0);
        _defineProperty(this, "onAsyncPropUpdated", void 0);
        _defineProperty(this, "asyncProps", void 0);
        _defineProperty(this, "oldProps", void 0);
        _defineProperty(this, "oldAsyncProps", void 0);
        this.component = component;
        this.asyncProps = {};
        this.onAsyncPropUpdated = () => {
        };
        this.oldProps = null;
        this.oldAsyncProps = null;
      }
      finalize() {
        for (const propName in this.asyncProps) {
          const asyncProp = this.asyncProps[propName];
          if (asyncProp && asyncProp.type && asyncProp.type.release) {
            asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
          }
        }
        this.asyncProps = {};
        this.component = null;
        this.resetOldProps();
      }
      getOldProps() {
        return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
      }
      resetOldProps() {
        this.oldAsyncProps = null;
        this.oldProps = this.component ? this.component.props : null;
      }
      hasAsyncProp(propName) {
        return propName in this.asyncProps;
      }
      getAsyncProp(propName) {
        const asyncProp = this.asyncProps[propName];
        return asyncProp && asyncProp.resolvedValue;
      }
      isAsyncPropLoading(propName) {
        if (propName) {
          const asyncProp = this.asyncProps[propName];
          return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
        }
        for (const key in this.asyncProps) {
          if (this.isAsyncPropLoading(key)) {
            return true;
          }
        }
        return false;
      }
      reloadAsyncProp(propName, value) {
        this._watchPromise(propName, Promise.resolve(value));
      }
      setAsyncProps(props) {
        this.component = props[COMPONENT_SYMBOL] || this.component;
        const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
        const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
        const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
        for (const propName in resolvedValues) {
          const value = resolvedValues[propName];
          this._createAsyncPropData(propName, defaultValues[propName]);
          this._updateAsyncProp(propName, value);
          resolvedValues[propName] = this.getAsyncProp(propName);
        }
        for (const propName in originalValues) {
          const value = originalValues[propName];
          this._createAsyncPropData(propName, defaultValues[propName]);
          this._updateAsyncProp(propName, value);
        }
      }
      _fetch(propName, url) {
        return null;
      }
      _onResolve(propName, value) {
      }
      _onError(propName, error2) {
      }
      _updateAsyncProp(propName, value) {
        if (!this._didAsyncInputValueChange(propName, value)) {
          return;
        }
        if (typeof value === "string") {
          value = this._fetch(propName, value);
        }
        if (value instanceof Promise) {
          this._watchPromise(propName, value);
          return;
        }
        if (isAsyncIterable2(value)) {
          this._resolveAsyncIterable(propName, value);
          return;
        }
        this._setPropValue(propName, value);
      }
      _freezeAsyncOldProps() {
        if (!this.oldAsyncProps && this.oldProps) {
          this.oldAsyncProps = Object.create(this.oldProps);
          for (const propName in this.asyncProps) {
            Object.defineProperty(this.oldAsyncProps, propName, {
              enumerable: true,
              value: this.oldProps[propName]
            });
          }
        }
      }
      _didAsyncInputValueChange(propName, value) {
        const asyncProp = this.asyncProps[propName];
        if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
          return false;
        }
        asyncProp.lastValue = value;
        return true;
      }
      _setPropValue(propName, value) {
        this._freezeAsyncOldProps();
        const asyncProp = this.asyncProps[propName];
        if (asyncProp) {
          value = this._postProcessValue(asyncProp, value);
          asyncProp.resolvedValue = value;
          asyncProp.pendingLoadCount++;
          asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
        }
      }
      _setAsyncPropValue(propName, value, loadCount) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
          this._freezeAsyncOldProps();
          asyncProp.resolvedValue = value;
          asyncProp.resolvedLoadCount = loadCount;
          this.onAsyncPropUpdated(propName, value);
        }
      }
      _watchPromise(propName, promise) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp) {
          asyncProp.pendingLoadCount++;
          const loadCount = asyncProp.pendingLoadCount;
          promise.then((data) => {
            if (!this.component) {
              return;
            }
            data = this._postProcessValue(asyncProp, data);
            this._setAsyncPropValue(propName, data, loadCount);
            this._onResolve(propName, data);
          }).catch((error2) => {
            this._onError(propName, error2);
          });
        }
      }
      async _resolveAsyncIterable(propName, iterable) {
        if (propName !== "data") {
          this._setPropValue(propName, iterable);
          return;
        }
        const asyncProp = this.asyncProps[propName];
        if (!asyncProp) {
          return;
        }
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        let data = [];
        let count2 = 0;
        for await (const chunk of iterable) {
          if (!this.component) {
            return;
          }
          const {
            dataTransform
          } = this.component.props;
          if (dataTransform) {
            data = dataTransform(chunk, data);
          } else {
            data = data.concat(chunk);
          }
          Object.defineProperty(data, "__diff", {
            enumerable: false,
            value: [{
              startRow: count2,
              endRow: data.length
            }]
          });
          count2 = data.length;
          this._setAsyncPropValue(propName, data, loadCount);
        }
        this._onResolve(propName, data);
      }
      _postProcessValue(asyncProp, value) {
        const propType = asyncProp.type;
        if (propType && this.component) {
          if (propType.release) {
            propType.release(asyncProp.resolvedValue, propType, this.component);
          }
          if (propType.transform) {
            return propType.transform(value, propType, this.component);
          }
        }
        return value;
      }
      _createAsyncPropData(propName, defaultValue) {
        const asyncProp = this.asyncProps[propName];
        if (!asyncProp) {
          const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
          this.asyncProps[propName] = {
            type: propTypes && propTypes[propName],
            lastValue: null,
            resolvedValue: defaultValue,
            pendingLoadCount: 0,
            resolvedLoadCount: 0
          };
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer-state.js
var LayerState;
var init_layer_state = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer-state.js"() {
    init_defineProperty();
    init_component_state();
    LayerState = class extends ComponentState {
      constructor({
        attributeManager,
        layer
      }) {
        super(layer);
        _defineProperty(this, "attributeManager", void 0);
        _defineProperty(this, "needsRedraw", void 0);
        _defineProperty(this, "needsUpdate", void 0);
        _defineProperty(this, "subLayers", void 0);
        _defineProperty(this, "usesPickingColorCache", void 0);
        _defineProperty(this, "hasPickingBuffer", void 0);
        _defineProperty(this, "changeFlags", void 0);
        _defineProperty(this, "viewport", void 0);
        _defineProperty(this, "uniformTransitions", void 0);
        _defineProperty(this, "propsInTransition", void 0);
        this.attributeManager = attributeManager;
        this.needsRedraw = true;
        this.needsUpdate = true;
        this.subLayers = null;
        this.usesPickingColorCache = false;
      }
      get layer() {
        return this.component;
      }
      _fetch(propName, url) {
        const layer = this.layer;
        const fetch2 = layer === null || layer === void 0 ? void 0 : layer.props.fetch;
        if (fetch2) {
          return fetch2(url, {
            propName,
            layer
          });
        }
        return super._fetch(propName, url);
      }
      _onResolve(propName, value) {
        const layer = this.layer;
        if (layer) {
          const onDataLoad = layer.props.onDataLoad;
          if (propName === "data" && onDataLoad) {
            onDataLoad(value, {
              propName,
              layer
            });
          }
        }
      }
      _onError(propName, error2) {
        const layer = this.layer;
        if (layer) {
          layer.raiseError(error2, "loading ".concat(propName, " of ").concat(this.layer));
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer.js
var TRACE_CHANGE_FLAG, TRACE_INITIALIZE, TRACE_UPDATE, TRACE_FINALIZE, TRACE_MATCHED, MAX_PICKING_COLOR_CACHE_SIZE, EMPTY_ARRAY2, areViewportsEqual, pickingColorCache, defaultProps2, Layer;
var init_layer = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer.js"() {
    init_defineProperty();
    init_constants();
    init_attribute_manager();
    init_uniform_transition_manager();
    init_props();
    init_constants3();
    init_count();
    init_log3();
    init_debug();
    init_esm14();
    init_assert9();
    init_memoize();
    init_shader2();
    init_project_functions();
    init_typed_array_manager();
    init_component();
    init_layer_state();
    init_esm();
    init_esm7();
    TRACE_CHANGE_FLAG = "layer.changeFlag";
    TRACE_INITIALIZE = "layer.initialize";
    TRACE_UPDATE = "layer.update";
    TRACE_FINALIZE = "layer.finalize";
    TRACE_MATCHED = "layer.matched";
    MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
    EMPTY_ARRAY2 = Object.freeze([]);
    areViewportsEqual = memoize(({
      oldViewport,
      viewport
    }) => {
      return oldViewport.equals(viewport);
    });
    pickingColorCache = new Uint8ClampedArray(0);
    defaultProps2 = {
      data: {
        type: "data",
        value: EMPTY_ARRAY2,
        async: true
      },
      dataComparator: {
        type: "function",
        value: null,
        optional: true
      },
      _dataDiff: {
        type: "function",
        value: (data) => data && data.__diff,
        optional: true
      },
      dataTransform: {
        type: "function",
        value: null,
        optional: true
      },
      onDataLoad: {
        type: "function",
        value: null,
        optional: true
      },
      onError: {
        type: "function",
        value: null,
        optional: true
      },
      fetch: {
        type: "function",
        value: (url, {
          propName,
          layer,
          loaders,
          loadOptions,
          signal
        }) => {
          const {
            resourceManager
          } = layer.context;
          loadOptions = loadOptions || layer.getLoadOptions();
          loaders = loaders || layer.props.loaders;
          if (signal) {
            var _loadOptions;
            loadOptions = {
              ...loadOptions,
              fetch: {
                ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch,
                signal
              }
            };
          }
          let inResourceManager = resourceManager.contains(url);
          if (!inResourceManager && !loadOptions) {
            resourceManager.add({
              resourceId: url,
              data: load(url, loaders),
              persistent: false
            });
            inResourceManager = true;
          }
          if (inResourceManager) {
            return resourceManager.subscribe({
              resourceId: url,
              onChange: (data) => {
                var _layer$internalState;
                return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
              },
              consumerId: layer.id,
              requestId: propName
            });
          }
          return load(url, loaders, loadOptions);
        }
      },
      updateTriggers: {},
      visible: true,
      pickable: false,
      opacity: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
      },
      operation: "draw",
      onHover: {
        type: "function",
        value: null,
        optional: true
      },
      onClick: {
        type: "function",
        value: null,
        optional: true
      },
      onDragStart: {
        type: "function",
        value: null,
        optional: true
      },
      onDrag: {
        type: "function",
        value: null,
        optional: true
      },
      onDragEnd: {
        type: "function",
        value: null,
        optional: true
      },
      coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
      coordinateOrigin: {
        type: "array",
        value: [0, 0, 0],
        compare: true
      },
      modelMatrix: {
        type: "array",
        value: null,
        compare: true,
        optional: true
      },
      wrapLongitude: false,
      positionFormat: "XYZ",
      colorFormat: "RGBA",
      parameters: {
        type: "object",
        value: {},
        optional: true,
        compare: 2
      },
      loadOptions: {
        type: "object",
        value: null,
        optional: true,
        ignore: true
      },
      transitions: null,
      extensions: [],
      loaders: {
        type: "array",
        value: [],
        optional: true,
        ignore: true
      },
      getPolygonOffset: {
        type: "function",
        value: ({
          layerIndex
        }) => [0, -layerIndex * 100]
      },
      highlightedObjectIndex: null,
      autoHighlight: false,
      highlightColor: {
        type: "accessor",
        value: [0, 0, 128, 128]
      }
    };
    Layer = class extends Component {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "internalState", null);
        _defineProperty(this, "lifecycle", LIFECYCLE.NO_STATE);
        _defineProperty(this, "context", void 0);
        _defineProperty(this, "state", void 0);
        _defineProperty(this, "parent", null);
      }
      static get componentName() {
        return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
      }
      get root() {
        let layer = this;
        while (layer.parent) {
          layer = layer.parent;
        }
        return layer;
      }
      toString() {
        const className = this.constructor.layerName || this.constructor.name;
        return "".concat(className, "({id: '").concat(this.props.id, "'})");
      }
      project(xyz) {
        assert9(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        const worldPosition = getWorldPosition(xyz, {
          viewport,
          modelMatrix: this.props.modelMatrix,
          coordinateOrigin: this.props.coordinateOrigin,
          coordinateSystem: this.props.coordinateSystem
        });
        const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
        return xyz.length === 2 ? [x, y] : [x, y, z];
      }
      unproject(xy) {
        assert9(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        return viewport.unproject(xy);
      }
      projectPosition(xyz, params) {
        assert9(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        return projectPosition(xyz, {
          viewport,
          modelMatrix: this.props.modelMatrix,
          coordinateOrigin: this.props.coordinateOrigin,
          coordinateSystem: this.props.coordinateSystem,
          ...params
        });
      }
      get isComposite() {
        return false;
      }
      setState(partialState) {
        this.setChangeFlags({
          stateChanged: true
        });
        Object.assign(this.state, partialState);
        this.setNeedsRedraw();
      }
      setNeedsRedraw() {
        if (this.internalState) {
          this.internalState.needsRedraw = true;
        }
      }
      setNeedsUpdate() {
        if (this.internalState) {
          this.context.layerManager.setNeedsUpdate(String(this));
          this.internalState.needsUpdate = true;
        }
      }
      get isLoaded() {
        return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
      }
      get wrapLongitude() {
        return this.props.wrapLongitude;
      }
      isPickable() {
        return this.props.pickable && this.props.visible;
      }
      getModels() {
        return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
      }
      setModuleParameters(moduleParameters) {
        for (const model of this.getModels()) {
          model.updateModuleSettings(moduleParameters);
        }
      }
      getAttributeManager() {
        return this.internalState && this.internalState.attributeManager;
      }
      getCurrentLayer() {
        return this.internalState && this.internalState.layer;
      }
      getLoadOptions() {
        return this.props.loadOptions;
      }
      use64bitPositions() {
        const {
          coordinateSystem
        } = this.props;
        return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
      }
      onHover(info, pickingEvent) {
        if (this.props.onHover) {
          return this.props.onHover(info, pickingEvent) || false;
        }
        return false;
      }
      onClick(info, pickingEvent) {
        if (this.props.onClick) {
          return this.props.onClick(info, pickingEvent) || false;
        }
        return false;
      }
      nullPickingColor() {
        return [0, 0, 0];
      }
      encodePickingColor(i, target = []) {
        target[0] = i + 1 & 255;
        target[1] = i + 1 >> 8 & 255;
        target[2] = i + 1 >> 8 >> 8 & 255;
        return target;
      }
      decodePickingColor(color) {
        assert9(color instanceof Uint8Array);
        const [i1, i2, i3] = color;
        const index = i1 + i2 * 256 + i3 * 65536 - 1;
        return index;
      }
      getNumInstances() {
        if (Number.isFinite(this.props.numInstances)) {
          return this.props.numInstances;
        }
        if (this.state && this.state.numInstances !== void 0) {
          return this.state.numInstances;
        }
        return count(this.props.data);
      }
      getStartIndices() {
        if (this.props.startIndices) {
          return this.props.startIndices;
        }
        if (this.state && this.state.startIndices) {
          return this.state.startIndices;
        }
        return null;
      }
      getBounds() {
        var _this$getAttributeMan;
        return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(["positions", "instancePositions"]);
      }
      getShaders(shaders) {
        for (const extension of this.props.extensions) {
          shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
        }
        return shaders;
      }
      shouldUpdateState(params) {
        return params.changeFlags.propsOrDataChanged;
      }
      updateState(params) {
        const attributeManager = this.getAttributeManager();
        const {
          dataChanged
        } = params.changeFlags;
        if (dataChanged && attributeManager) {
          if (Array.isArray(dataChanged)) {
            for (const dataRange of dataChanged) {
              attributeManager.invalidateAll(dataRange);
            }
          } else {
            attributeManager.invalidateAll();
          }
        }
        if (attributeManager) {
          const {
            props
          } = params;
          const hasPickingBuffer = this.internalState.hasPickingBuffer;
          const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
          if (hasPickingBuffer !== needsPickingBuffer) {
            this.internalState.hasPickingBuffer = needsPickingBuffer;
            const {
              pickingColors,
              instancePickingColors
            } = attributeManager.attributes;
            const pickingColorsAttribute = pickingColors || instancePickingColors;
            if (pickingColorsAttribute) {
              if (needsPickingBuffer && pickingColorsAttribute.constant) {
                pickingColorsAttribute.constant = false;
                attributeManager.invalidate(pickingColorsAttribute.id);
              }
              if (!pickingColorsAttribute.value && !needsPickingBuffer) {
                pickingColorsAttribute.constant = true;
                pickingColorsAttribute.value = [0, 0, 0];
              }
            }
          }
        }
      }
      finalizeState(context) {
        for (const model of this.getModels()) {
          model.delete();
        }
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.finalize();
        }
        if (this.context) {
          this.context.resourceManager.unsubscribe({
            consumerId: this.id
          });
        }
        if (this.internalState) {
          this.internalState.uniformTransitions.clear();
          this.internalState.finalize();
        }
      }
      draw(opts) {
        for (const model of this.getModels()) {
          model.draw(opts);
        }
      }
      getPickingInfo({
        info,
        mode,
        sourceLayer
      }) {
        const {
          index
        } = info;
        if (index >= 0) {
          if (Array.isArray(this.props.data)) {
            info.object = this.props.data[index];
          }
        }
        return info;
      }
      raiseError(error2, message) {
        var _this$props$onError, _this$props;
        if (message) {
          error2.message = "".concat(message, ": ").concat(error2.message);
        }
        if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error2))) {
          var _this$context, _this$context$onError;
          (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error2, this);
        }
      }
      getNeedsRedraw(opts = {
        clearRedrawFlags: false
      }) {
        return this._getNeedsRedraw(opts);
      }
      needsUpdate() {
        if (!this.internalState) {
          return false;
        }
        return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
      }
      hasUniformTransition() {
        var _this$internalState;
        return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
      }
      activateViewport(viewport) {
        if (!this.internalState) {
          return;
        }
        const oldViewport = this.internalState.viewport;
        this.internalState.viewport = viewport;
        if (!oldViewport || !areViewportsEqual({
          oldViewport,
          viewport
        })) {
          this.setChangeFlags({
            viewportChanged: true
          });
          if (this.isComposite) {
            if (this.needsUpdate()) {
              this.setNeedsUpdate();
            }
          } else {
            this._update();
          }
        }
      }
      invalidateAttribute(name = "all") {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) {
          return;
        }
        if (name === "all") {
          attributeManager.invalidateAll();
        } else {
          attributeManager.invalidate(name);
        }
      }
      updateAttributes(changedAttributes) {
        for (const model of this.getModels()) {
          this._setModelAttributes(model, changedAttributes);
        }
      }
      _updateAttributes() {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) {
          return;
        }
        const props = this.props;
        const numInstances = this.getNumInstances();
        const startIndices = this.getStartIndices();
        attributeManager.update({
          data: props.data,
          numInstances,
          startIndices,
          props,
          transitions: props.transitions,
          buffers: props.data.attributes,
          context: this
        });
        const changedAttributes = attributeManager.getChangedAttributes({
          clearChangedFlags: true
        });
        this.updateAttributes(changedAttributes);
      }
      _updateAttributeTransition() {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.updateTransition();
        }
      }
      _updateUniformTransition() {
        const {
          uniformTransitions
        } = this.internalState;
        if (uniformTransitions.active) {
          const propsInTransition = uniformTransitions.update();
          const props = Object.create(this.props);
          for (const key in propsInTransition) {
            Object.defineProperty(props, key, {
              value: propsInTransition[key]
            });
          }
          return props;
        }
        return this.props;
      }
      calculateInstancePickingColors(attribute, {
        numInstances
      }) {
        if (attribute.constant) {
          return;
        }
        const cacheSize = Math.floor(pickingColorCache.length / 3);
        this.internalState.usesPickingColorCache = true;
        if (cacheSize < numInstances) {
          if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
            log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
          }
          pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
            size: 3,
            copy: true,
            maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
          });
          const newCacheSize = Math.floor(pickingColorCache.length / 3);
          const pickingColor = [];
          for (let i = cacheSize; i < newCacheSize; i++) {
            this.encodePickingColor(i, pickingColor);
            pickingColorCache[i * 3 + 0] = pickingColor[0];
            pickingColorCache[i * 3 + 1] = pickingColor[1];
            pickingColorCache[i * 3 + 2] = pickingColor[2];
          }
        }
        attribute.value = pickingColorCache.subarray(0, numInstances * 3);
      }
      _setModelAttributes(model, changedAttributes) {
        const attributeManager = this.getAttributeManager();
        const excludeAttributes = model.userData.excludeAttributes || {};
        const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
        model.setAttributes(shaderAttributes);
      }
      disablePickingIndex(objectIndex) {
        const data = this.props.data;
        if (!("attributes" in data)) {
          this._disablePickingIndex(objectIndex);
          return;
        }
        const {
          pickingColors,
          instancePickingColors
        } = this.getAttributeManager().attributes;
        const colors = pickingColors || instancePickingColors;
        const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
        if (externalColorAttribute && externalColorAttribute.value) {
          const values = externalColorAttribute.value;
          const objectColor = this.encodePickingColor(objectIndex);
          for (let index = 0; index < data.length; index++) {
            const i = colors.getVertexOffset(index);
            if (values[i] === objectColor[0] && values[i + 1] === objectColor[1] && values[i + 2] === objectColor[2]) {
              this._disablePickingIndex(index);
            }
          }
        } else {
          this._disablePickingIndex(objectIndex);
        }
      }
      _disablePickingIndex(objectIndex) {
        const {
          pickingColors,
          instancePickingColors
        } = this.getAttributeManager().attributes;
        const colors = pickingColors || instancePickingColors;
        if (!colors) {
          return;
        }
        const start = colors.getVertexOffset(objectIndex);
        const end = colors.getVertexOffset(objectIndex + 1);
        colors.buffer.subData({
          data: new Uint8Array(end - start),
          offset: start
        });
      }
      restorePickingColors() {
        const {
          pickingColors,
          instancePickingColors
        } = this.getAttributeManager().attributes;
        const colors = pickingColors || instancePickingColors;
        if (!colors) {
          return;
        }
        if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
          colors.value = pickingColorCache.subarray(0, colors.value.length);
        }
        colors.updateSubBuffer({
          startOffset: 0
        });
      }
      _initialize() {
        assert9(!this.internalState);
        assert9(Number.isFinite(this.props.coordinateSystem));
        debug(TRACE_INITIALIZE, this);
        const attributeManager = this._getAttributeManager();
        if (attributeManager) {
          attributeManager.addInstanced({
            instancePickingColors: {
              type: 5121,
              size: 3,
              noAlloc: true,
              update: this.calculateInstancePickingColors
            }
          });
        }
        this.internalState = new LayerState({
          attributeManager,
          layer: this
        });
        this._clearChangeFlags();
        this.state = {};
        Object.defineProperty(this.state, "attributeManager", {
          get: () => {
            log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
            return attributeManager;
          }
        });
        this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
        this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
        this.internalState.setAsyncProps(this.props);
        this.initializeState(this.context);
        for (const extension of this.props.extensions) {
          extension.initializeState.call(this, this.context, extension);
        }
        this.setChangeFlags({
          dataChanged: "init",
          propsChanged: "init",
          viewportChanged: true,
          extensionsChanged: true
        });
        this._update();
      }
      _transferState(oldLayer) {
        debug(TRACE_MATCHED, this, this === oldLayer);
        const {
          state,
          internalState
        } = oldLayer;
        if (this === oldLayer) {
          return;
        }
        this.internalState = internalState;
        this.state = state;
        this.internalState.setAsyncProps(this.props);
        this._diffProps(this.props, this.internalState.getOldProps());
      }
      _update() {
        const stateNeedsUpdate = this.needsUpdate();
        debug(TRACE_UPDATE, this, stateNeedsUpdate);
        if (!stateNeedsUpdate) {
          return;
        }
        const currentProps = this.props;
        const context = this.context;
        const internalState = this.internalState;
        const currentViewport = context.viewport;
        const propsInTransition = this._updateUniformTransition();
        internalState.propsInTransition = propsInTransition;
        context.viewport = internalState.viewport || currentViewport;
        this.props = propsInTransition;
        try {
          const updateParams = this._getUpdateParams();
          const oldModels = this.getModels();
          if (context.gl) {
            this.updateState(updateParams);
          } else {
            try {
              this.updateState(updateParams);
            } catch (error2) {
            }
          }
          for (const extension of this.props.extensions) {
            extension.updateState.call(this, updateParams, extension);
          }
          const modelChanged = this.getModels()[0] !== oldModels[0];
          this._postUpdate(updateParams, modelChanged);
        } finally {
          context.viewport = currentViewport;
          this.props = currentProps;
          this._clearChangeFlags();
          internalState.needsUpdate = false;
          internalState.resetOldProps();
        }
      }
      _finalize() {
        debug(TRACE_FINALIZE, this);
        this.finalizeState(this.context);
        for (const extension of this.props.extensions) {
          extension.finalizeState.call(this, this.context, extension);
        }
      }
      _drawLayer({
        moduleParameters = null,
        uniforms: uniforms3 = {},
        parameters = {}
      }) {
        this._updateAttributeTransition();
        const currentProps = this.props;
        const context = this.context;
        this.props = this.internalState.propsInTransition || currentProps;
        const opacity = this.props.opacity;
        uniforms3.opacity = Math.pow(opacity, 1 / 2.2);
        try {
          if (moduleParameters) {
            this.setModuleParameters(moduleParameters);
          }
          const {
            getPolygonOffset
          } = this.props;
          const offsets = getPolygonOffset && getPolygonOffset(uniforms3) || [0, 0];
          setParameters(context.gl, {
            polygonOffset: offsets
          });
          withParameters(context.gl, parameters, () => {
            const opts = {
              moduleParameters,
              uniforms: uniforms3,
              parameters,
              context
            };
            for (const extension of this.props.extensions) {
              extension.draw.call(this, opts, extension);
            }
            this.draw(opts);
          });
        } finally {
          this.props = currentProps;
        }
      }
      getChangeFlags() {
        var _this$internalState2;
        return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
      }
      setChangeFlags(flags) {
        if (!this.internalState) {
          return;
        }
        const {
          changeFlags
        } = this.internalState;
        for (const key in flags) {
          if (flags[key]) {
            let flagChanged = false;
            switch (key) {
              case "dataChanged":
                const dataChangedReason = flags[key];
                const prevDataChangedReason = changeFlags[key];
                if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                  changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                  flagChanged = true;
                }
              default:
                if (!changeFlags[key]) {
                  changeFlags[key] = flags[key];
                  flagChanged = true;
                }
            }
            if (flagChanged) {
              debug(TRACE_CHANGE_FLAG, this, key, flags);
            }
          }
        }
        const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
        changeFlags.propsOrDataChanged = propsOrDataChanged;
        changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
      }
      _clearChangeFlags() {
        this.internalState.changeFlags = {
          dataChanged: false,
          propsChanged: false,
          updateTriggersChanged: false,
          viewportChanged: false,
          stateChanged: false,
          extensionsChanged: false,
          propsOrDataChanged: false,
          somethingChanged: false
        };
      }
      _diffProps(newProps, oldProps) {
        const changeFlags = diffProps(newProps, oldProps);
        if (changeFlags.updateTriggersChanged) {
          for (const key in changeFlags.updateTriggersChanged) {
            if (changeFlags.updateTriggersChanged[key]) {
              this.invalidateAttribute(key);
            }
          }
        }
        if (changeFlags.transitionsChanged) {
          for (const key in changeFlags.transitionsChanged) {
            var _newProps$transitions;
            this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
          }
        }
        return this.setChangeFlags(changeFlags);
      }
      validateProps() {
        validateProps(this.props);
      }
      updateAutoHighlight(info) {
        if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
          this._updateAutoHighlight(info);
        }
      }
      _updateAutoHighlight(info) {
        const pickingModuleParameters = {
          pickingSelectedColor: info.picked ? info.color : null
        };
        const {
          highlightColor
        } = this.props;
        if (info.picked && typeof highlightColor === "function") {
          pickingModuleParameters.pickingHighlightColor = highlightColor(info);
        }
        this.setModuleParameters(pickingModuleParameters);
        this.setNeedsRedraw();
      }
      _getAttributeManager() {
        const context = this.context;
        return new AttributeManager(context.gl, {
          id: this.props.id,
          stats: context.stats,
          timeline: context.timeline
        });
      }
      _postUpdate(updateParams, forceUpdate) {
        const {
          props,
          oldProps
        } = updateParams;
        this.setNeedsRedraw();
        this._updateAttributes();
        const {
          model
        } = this.state;
        model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());
        const {
          autoHighlight,
          highlightedObjectIndex,
          highlightColor
        } = props;
        if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
          const parameters = {};
          if (!autoHighlight) {
            parameters.pickingSelectedColor = null;
          }
          if (Array.isArray(highlightColor)) {
            parameters.pickingHighlightColor = highlightColor;
          }
          if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
            parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
          }
          this.setModuleParameters(parameters);
        }
      }
      _getUpdateParams() {
        return {
          props: this.props,
          oldProps: this.internalState.getOldProps(),
          context: this.context,
          changeFlags: this.internalState.changeFlags
        };
      }
      _getNeedsRedraw(opts) {
        if (!this.internalState) {
          return false;
        }
        let redraw = false;
        redraw = redraw || this.internalState.needsRedraw && this.id;
        const attributeManager = this.getAttributeManager();
        const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
        redraw = redraw || attributeManagerNeedsRedraw;
        if (redraw) {
          for (const extension of this.props.extensions) {
            extension.onNeedsRedraw.call(this, extension);
          }
        }
        this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
        return redraw;
      }
      _onAsyncPropUpdated() {
        this._diffProps(this.props, this.internalState.getOldProps());
        this.setNeedsUpdate();
      }
    };
    _defineProperty(Layer, "defaultProps", defaultProps2);
    _defineProperty(Layer, "layerName", "Layer");
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js
var TRACE_RENDER_LAYERS2, CompositeLayer;
var init_composite_layer = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"() {
    init_defineProperty();
    init_layer();
    init_debug();
    init_flatten();
    init_constants3();
    TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
    CompositeLayer = class extends Layer {
      get isComposite() {
        return true;
      }
      get isLoaded() {
        return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
      }
      getSubLayers() {
        return this.internalState && this.internalState.subLayers || [];
      }
      initializeState(context) {
      }
      setState(updateObject) {
        super.setState(updateObject);
        this.setNeedsUpdate();
      }
      getPickingInfo({
        info
      }) {
        const {
          object
        } = info;
        const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
        if (!isDataWrapped) {
          return info;
        }
        info.object = object.__source.object;
        info.index = object.__source.index;
        return info;
      }
      filterSubLayer(context) {
        return true;
      }
      shouldRenderSubLayer(subLayerId, data) {
        return data && data.length;
      }
      getSubLayerClass(subLayerId, DefaultLayerClass) {
        const {
          _subLayerProps: overridingProps
        } = this.props;
        return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
      }
      getSubLayerRow(row, sourceObject, sourceObjectIndex) {
        row.__source = {
          parent: this,
          object: sourceObject,
          index: sourceObjectIndex
        };
        return row;
      }
      getSubLayerAccessor(accessor) {
        if (typeof accessor === "function") {
          const objectInfo = {
            index: -1,
            data: this.props.data,
            target: []
          };
          return (x, i) => {
            if (x && x.__source) {
              objectInfo.index = x.__source.index;
              return accessor(x.__source.object, objectInfo);
            }
            return accessor(x, i);
          };
        }
        return accessor;
      }
      getSubLayerProps(sublayerProps = {}) {
        var _this$props$updateTri;
        const {
          opacity,
          pickable,
          visible,
          parameters,
          getPolygonOffset,
          highlightedObjectIndex,
          autoHighlight,
          highlightColor,
          coordinateSystem,
          coordinateOrigin,
          wrapLongitude,
          positionFormat,
          modelMatrix,
          extensions,
          fetch: fetch2,
          operation,
          _subLayerProps: overridingProps
        } = this.props;
        const newProps = {
          id: "",
          updateTriggers: {},
          opacity,
          pickable,
          visible,
          parameters,
          getPolygonOffset,
          highlightedObjectIndex,
          autoHighlight,
          highlightColor,
          coordinateSystem,
          coordinateOrigin,
          wrapLongitude,
          positionFormat,
          modelMatrix,
          extensions,
          fetch: fetch2,
          operation
        };
        const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
        const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
        const sublayerId = sublayerProps.id || "sublayer";
        if (overridingSublayerProps) {
          const propTypes = this.props[PROP_TYPES_SYMBOL];
          const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
          for (const key in overridingSublayerProps) {
            const propType = subLayerPropTypes[key] || propTypes[key];
            if (propType && propType.type === "accessor") {
              overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
            }
          }
        }
        Object.assign(newProps, sublayerProps, overridingSublayerProps);
        newProps.id = "".concat(this.props.id, "-").concat(sublayerId);
        newProps.updateTriggers = {
          all: (_this$props$updateTri = this.props.updateTriggers) === null || _this$props$updateTri === void 0 ? void 0 : _this$props$updateTri.all,
          ...sublayerProps.updateTriggers,
          ...overridingSublayerTriggers
        };
        for (const extension of extensions) {
          const passThroughProps = extension.getSubLayerProps.call(this, extension);
          if (passThroughProps) {
            Object.assign(newProps, passThroughProps, {
              updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
            });
          }
        }
        return newProps;
      }
      _updateAutoHighlight(info) {
        for (const layer of this.getSubLayers()) {
          layer.updateAutoHighlight(info);
        }
      }
      _getAttributeManager() {
        return null;
      }
      _postUpdate(updateParams, forceUpdate) {
        let subLayers = this.internalState.subLayers;
        const shouldUpdate = !subLayers || this.needsUpdate();
        if (shouldUpdate) {
          const subLayersList = this.renderLayers();
          subLayers = flatten(subLayersList, Boolean);
          this.internalState.subLayers = subLayers;
        }
        debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
        for (const layer of subLayers) {
          layer.parent = this;
        }
      }
    };
    _defineProperty(CompositeLayer, "layerName", "CompositeLayer");
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js
function getDistanceScales2() {
  const unitsPerMeter2 = GLOBE_RADIUS / EARTH_RADIUS;
  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter2, unitsPerMeter2, unitsPerMeter2],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter2, 1 / unitsPerMeter2, 1 / unitsPerMeter2],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter2],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter2]
  };
}
function transformVector(matrix, vector) {
  const result = transformMat43([], vector, matrix);
  scale2(result, result, 1 / result[3]);
  return result;
}
var DEGREES_TO_RADIANS4, RADIANS_TO_DEGREES2, EARTH_RADIUS, GLOBE_RADIUS, GlobeViewport;
var init_globe_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js"() {
    init_defineProperty();
    init_esm11();
    init_viewport();
    init_constants();
    init_vec3();
    init_vec4();
    DEGREES_TO_RADIANS4 = Math.PI / 180;
    RADIANS_TO_DEGREES2 = 180 / Math.PI;
    EARTH_RADIUS = 6370972;
    GLOBE_RADIUS = 256;
    GlobeViewport = class extends Viewport {
      constructor(opts = {}) {
        const {
          latitude = 0,
          longitude = 0,
          zoom = 0,
          nearZMultiplier = 0.1,
          farZMultiplier = 2,
          resolution = 10
        } = opts;
        let {
          height,
          altitude = 1.5
        } = opts;
        height = height || 1;
        altitude = Math.max(0.75, altitude);
        const viewMatrix2 = new Matrix4().lookAt({
          eye: [0, -altitude, 0],
          up: [0, 0, 1]
        });
        const scale5 = Math.pow(2, zoom);
        viewMatrix2.rotateX(latitude * DEGREES_TO_RADIANS4);
        viewMatrix2.rotateZ(-longitude * DEGREES_TO_RADIANS4);
        viewMatrix2.scale(scale5 / height);
        const halfFov = Math.atan(0.5 / altitude);
        const relativeScale = GLOBE_RADIUS * 2 * scale5 / height;
        super({
          ...opts,
          height,
          viewMatrix: viewMatrix2,
          longitude,
          latitude,
          zoom,
          distanceScales: getDistanceScales2(),
          fovyRadians: halfFov * 2,
          focalDistance: altitude,
          near: nearZMultiplier,
          far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
        });
        _defineProperty(this, "longitude", void 0);
        _defineProperty(this, "latitude", void 0);
        _defineProperty(this, "resolution", void 0);
        this.latitude = latitude;
        this.longitude = longitude;
        this.resolution = resolution;
      }
      get projectionMode() {
        return PROJECTION_MODE.GLOBE;
      }
      getDistanceScales() {
        return this.distanceScales;
      }
      getBounds(options = {}) {
        const unprojectOption = {
          targetZ: options.z || 0
        };
        const left = this.unproject([0, this.height / 2], unprojectOption);
        const top = this.unproject([this.width / 2, 0], unprojectOption);
        const right = this.unproject([this.width, this.height / 2], unprojectOption);
        const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
        if (right[0] < this.longitude)
          right[0] += 360;
        if (left[0] > this.longitude)
          left[0] -= 360;
        return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];
      }
      unproject(xyz, {
        topLeft = true,
        targetZ
      } = {}) {
        const [x, y, z] = xyz;
        const y2 = topLeft ? y : this.height - y;
        const {
          pixelUnprojectionMatrix
        } = this;
        let coord;
        if (Number.isFinite(z)) {
          coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);
        } else {
          const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);
          const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);
          const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
          const lSqr = sqrLen(sub([], coord0, coord1));
          const l0Sqr = sqrLen(coord0);
          const l1Sqr = sqrLen(coord1);
          const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
          const dSqr = 4 * sSqr / lSqr;
          const r0 = Math.sqrt(l0Sqr - dSqr);
          const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
          const t = (r0 - dr) / Math.sqrt(lSqr);
          coord = lerp([], coord0, coord1, t);
        }
        const [X, Y, Z] = this.unprojectPosition(coord);
        if (Number.isFinite(z)) {
          return [X, Y, Z];
        }
        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
      }
      projectPosition(xyz) {
        const [lng, lat, Z = 0] = xyz;
        const lambda = lng * DEGREES_TO_RADIANS4;
        const phi = lat * DEGREES_TO_RADIANS4;
        const cosPhi = Math.cos(phi);
        const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
        return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
      }
      unprojectPosition(xyz) {
        const [x, y, z] = xyz;
        const D = len(xyz);
        const phi = Math.asin(z / D);
        const lambda = Math.atan2(x, -y);
        const lng = lambda * RADIANS_TO_DEGREES2;
        const lat = phi * RADIANS_TO_DEGREES2;
        const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
        return [lng, lat, Z];
      }
      projectFlat(xyz) {
        return xyz;
      }
      unprojectFlat(xyz) {
        return xyz;
      }
      panByPosition(coords, pixel) {
        const fromPosition = this.unproject(pixel);
        return {
          longitude: coords[0] - fromPosition[0] + this.longitude,
          latitude: coords[1] - fromPosition[1] + this.latitude
        };
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js
function getViewMatrix2({
  height,
  focalDistance,
  orbitAxis,
  rotationX,
  rotationOrbit,
  zoom
}) {
  const up = orbitAxis === "Z" ? [0, 0, 1] : [0, 1, 0];
  const eye = orbitAxis === "Z" ? [0, -focalDistance, 0] : [0, 0, focalDistance];
  const viewMatrix2 = new Matrix4().lookAt({
    eye,
    up
  });
  viewMatrix2.rotateX(rotationX * DEGREES_TO_RADIANS5);
  if (orbitAxis === "Z") {
    viewMatrix2.rotateZ(rotationOrbit * DEGREES_TO_RADIANS5);
  } else {
    viewMatrix2.rotateY(rotationOrbit * DEGREES_TO_RADIANS5);
  }
  const projectionScale = Math.pow(2, zoom) / height;
  viewMatrix2.scale(projectionScale);
  return viewMatrix2;
}
var DEGREES_TO_RADIANS5, OrbitViewport;
var init_orbit_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js"() {
    init_defineProperty();
    init_viewport();
    init_esm11();
    init_esm();
    DEGREES_TO_RADIANS5 = Math.PI / 180;
    OrbitViewport = class extends Viewport {
      constructor(props) {
        const {
          height,
          projectionMatrix,
          fovy = 50,
          orbitAxis = "Z",
          target = [0, 0, 0],
          rotationX = 0,
          rotationOrbit = 0,
          zoom = 0
        } = props;
        const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);
        super({
          ...props,
          longitude: void 0,
          viewMatrix: getViewMatrix2({
            height: height || 1,
            focalDistance,
            orbitAxis,
            rotationX,
            rotationOrbit,
            zoom
          }),
          fovy,
          focalDistance,
          position: target,
          zoom
        });
        _defineProperty(this, "projectedCenter", void 0);
        this.projectedCenter = this.project(this.center);
      }
      unproject(xyz, {
        topLeft = true
      } = {}) {
        const [x, y, z = this.projectedCenter[2]] = xyz;
        const y2 = topLeft ? y : this.height - y;
        const [X, Y, Z] = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix);
        return [X, Y, Z];
      }
      panByPosition(coords, pixel) {
        const p0 = this.project(coords);
        const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];
        return {
          target: this.unproject(nextCenter)
        };
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js
function getProjectionMatrix({
  width,
  height,
  near,
  far,
  padding
}) {
  let left = -width / 2;
  let right = width / 2;
  let bottom = -height / 2;
  let top = height / 2;
  if (padding) {
    const {
      left: l = 0,
      right: r = 0,
      top: t = 0,
      bottom: b = 0
    } = padding;
    const offsetX = clamp((l + width - r) / 2, 0, width) - width / 2;
    const offsetY = clamp((t + height - b) / 2, 0, height) - height / 2;
    left -= offsetX;
    right -= offsetX;
    bottom += offsetY;
    top += offsetY;
  }
  return new Matrix4().ortho({
    left,
    right,
    bottom,
    top,
    near,
    far
  });
}
var viewMatrix, OrthographicViewport;
var init_orthographic_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js"() {
    init_viewport();
    init_esm11();
    init_esm();
    init_vec2();
    viewMatrix = new Matrix4().lookAt({
      eye: [0, 0, 1]
    });
    OrthographicViewport = class extends Viewport {
      constructor(props) {
        const {
          width,
          height,
          near = 0.1,
          far = 1e3,
          zoom = 0,
          target = [0, 0, 0],
          padding = null,
          flipY = true
        } = props;
        const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
        const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
        const zoom_ = Math.min(zoomX, zoomY);
        const scale5 = Math.pow(2, zoom_);
        let distanceScales;
        if (zoomX !== zoomY) {
          const scaleX2 = Math.pow(2, zoomX);
          const scaleY2 = Math.pow(2, zoomY);
          distanceScales = {
            unitsPerMeter: [scaleX2 / scale5, scaleY2 / scale5, 1],
            metersPerUnit: [scale5 / scaleX2, scale5 / scaleY2, 1]
          };
        }
        super({
          ...props,
          longitude: void 0,
          position: target,
          viewMatrix: viewMatrix.clone().scale([scale5, scale5 * (flipY ? -1 : 1), scale5]),
          projectionMatrix: getProjectionMatrix({
            width: width || 1,
            height: height || 1,
            padding,
            near,
            far
          }),
          zoom: zoom_,
          distanceScales
        });
      }
      projectFlat([X, Y]) {
        const {
          unitsPerMeter: unitsPerMeter2
        } = this.distanceScales;
        return [X * unitsPerMeter2[0], Y * unitsPerMeter2[1]];
      }
      unprojectFlat([x, y]) {
        const {
          metersPerUnit
        } = this.distanceScales;
        return [x * metersPerUnit[0], y * metersPerUnit[1]];
      }
      panByPosition(coords, pixel) {
        const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
        const toLocation = this.projectFlat(coords);
        const translate3 = add([], toLocation, negate([], fromLocation));
        const newCenter = add([], this.center, translate3);
        return {
          target: this.unprojectFlat(newCenter)
        };
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js
var FirstPersonViewport;
var init_first_person_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js"() {
    init_defineProperty();
    init_viewport();
    init_esm();
    init_esm11();
    FirstPersonViewport = class extends Viewport {
      constructor(props) {
        const {
          longitude,
          latitude,
          modelMatrix,
          bearing = 0,
          pitch = 0,
          up = [0, 0, 1]
        } = props;
        const spherical = new SphericalCoordinates({
          bearing,
          pitch: pitch === -90 ? 1e-4 : 90 + pitch
        });
        const dir = spherical.toVector3().normalize();
        const center = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(dir) : dir;
        const zoom = Number.isFinite(latitude) ? getMeterZoom({
          latitude
        }) : 0;
        const scale5 = Math.pow(2, zoom);
        const viewMatrix2 = new Matrix4().lookAt({
          eye: [0, 0, 0],
          center,
          up
        }).scale(scale5);
        super({
          ...props,
          zoom,
          viewMatrix: viewMatrix2
        });
        _defineProperty(this, "longitude", void 0);
        _defineProperty(this, "latitude", void 0);
        this.latitude = latitude;
        this.longitude = longitude;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js
var MOVEMENT_SPEED, FirstPersonState, FirstPersonController;
var init_first_person_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js"() {
    init_defineProperty();
    init_controller();
    init_view_state();
    init_math_utils2();
    init_linear_interpolator();
    init_esm11();
    MOVEMENT_SPEED = 20;
    FirstPersonState = class extends ViewState {
      constructor(options) {
        const {
          width,
          height,
          position = [0, 0, 0],
          bearing = 0,
          pitch = 0,
          longitude = null,
          latitude = null,
          maxPitch = 90,
          minPitch = -90,
          startRotatePos,
          startBearing,
          startPitch,
          startZoomPosition
        } = options;
        super({
          width,
          height,
          position,
          bearing,
          pitch,
          longitude,
          latitude,
          maxPitch,
          minPitch
        }, {
          startRotatePos,
          startBearing,
          startPitch,
          startZoomPosition
        });
      }
      panStart() {
        return this;
      }
      pan() {
        return this;
      }
      panEnd() {
        return this;
      }
      rotateStart({
        pos
      }) {
        return this._getUpdatedState({
          startRotatePos: pos,
          startBearing: this.getViewportProps().bearing,
          startPitch: this.getViewportProps().pitch
        });
      }
      rotate({
        pos,
        deltaAngleX = 0,
        deltaAngleY = 0
      }) {
        const {
          startRotatePos,
          startBearing,
          startPitch
        } = this.getState();
        const {
          width,
          height
        } = this.getViewportProps();
        if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
          return this;
        }
        let newRotation;
        if (pos) {
          const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
          const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
          newRotation = {
            bearing: startBearing - deltaScaleX * 180,
            pitch: startPitch - deltaScaleY * 90
          };
        } else {
          newRotation = {
            bearing: startBearing - deltaAngleX,
            pitch: startPitch - deltaAngleY
          };
        }
        return this._getUpdatedState(newRotation);
      }
      rotateEnd() {
        return this._getUpdatedState({
          startRotatePos: null,
          startBearing: null,
          startPitch: null
        });
      }
      zoomStart() {
        return this._getUpdatedState({
          startZoomPosition: this.getViewportProps().position
        });
      }
      zoom({
        scale: scale5
      }) {
        let {
          startZoomPosition
        } = this.getState();
        if (!startZoomPosition) {
          startZoomPosition = this.getViewportProps().position;
        }
        const direction = this.getDirection();
        return this._move(direction, Math.log2(scale5) * MOVEMENT_SPEED, startZoomPosition);
      }
      zoomEnd() {
        return this._getUpdatedState({
          startZoomPosition: null
        });
      }
      moveLeft(speed = MOVEMENT_SPEED) {
        const direction = this.getDirection(true);
        return this._move(direction.rotateZ({
          radians: Math.PI / 2
        }), speed);
      }
      moveRight(speed = MOVEMENT_SPEED) {
        const direction = this.getDirection(true);
        return this._move(direction.rotateZ({
          radians: -Math.PI / 2
        }), speed);
      }
      moveUp(speed = MOVEMENT_SPEED) {
        const direction = this.getDirection(true);
        return this._move(direction, speed);
      }
      moveDown(speed = MOVEMENT_SPEED) {
        const direction = this.getDirection(true);
        return this._move(direction.negate(), speed);
      }
      rotateLeft(speed = 15) {
        return this._getUpdatedState({
          bearing: this.getViewportProps().bearing - speed
        });
      }
      rotateRight(speed = 15) {
        return this._getUpdatedState({
          bearing: this.getViewportProps().bearing + speed
        });
      }
      rotateUp(speed = 10) {
        return this._getUpdatedState({
          pitch: this.getViewportProps().pitch + speed
        });
      }
      rotateDown(speed = 10) {
        return this._getUpdatedState({
          pitch: this.getViewportProps().pitch - speed
        });
      }
      zoomIn(speed = 2) {
        return this.zoom({
          scale: speed
        });
      }
      zoomOut(speed = 2) {
        return this.zoom({
          scale: 1 / speed
        });
      }
      shortestPathFrom(viewState) {
        const fromProps = viewState.getViewportProps();
        const props = {
          ...this.getViewportProps()
        };
        const {
          bearing,
          longitude
        } = props;
        if (Math.abs(bearing - fromProps.bearing) > 180) {
          props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
        }
        if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
          props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
        }
        return props;
      }
      _move(direction, speed, fromPosition = this.getViewportProps().position) {
        const delta = direction.scale(speed);
        return this._getUpdatedState({
          position: new Vector3(fromPosition).add(delta)
        });
      }
      getDirection(use2D = false) {
        const spherical = new SphericalCoordinates({
          bearing: this.getViewportProps().bearing,
          pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
        });
        const direction = spherical.toVector3().normalize();
        return direction;
      }
      _getUpdatedState(newProps) {
        return new FirstPersonState({
          ...this.getViewportProps(),
          ...this.getState(),
          ...newProps
        });
      }
      applyConstraints(props) {
        const {
          pitch,
          maxPitch,
          minPitch,
          longitude,
          bearing
        } = props;
        props.pitch = clamp(pitch, minPitch, maxPitch);
        if (longitude !== null && (longitude < -180 || longitude > 180)) {
          props.longitude = mod(longitude + 180, 360) - 180;
        }
        if (bearing < -180 || bearing > 180) {
          props.bearing = mod(bearing + 180, 360) - 180;
        }
        return props;
      }
    };
    FirstPersonController = class extends Controller {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "ControllerState", FirstPersonState);
        _defineProperty(this, "transition", {
          transitionDuration: 300,
          transitionInterpolator: new LinearInterpolator(["position", "pitch", "bearing"])
        });
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/views/first-person-view.js
var FirstPersonView;
var init_first_person_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/first-person-view.js"() {
    init_defineProperty();
    init_view();
    init_first_person_viewport();
    init_first_person_controller();
    FirstPersonView = class extends View {
      get ViewportType() {
        return FirstPersonViewport;
      }
      get ControllerType() {
        return FirstPersonController;
      }
    };
    _defineProperty(FirstPersonView, "displayName", "FirstPersonView");
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js
var OrbitState, OrbitController;
var init_orbit_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"() {
    init_defineProperty();
    init_esm11();
    init_controller();
    init_view_state();
    init_math_utils2();
    init_linear_interpolator();
    OrbitState = class extends ViewState {
      constructor(options) {
        const {
          width,
          height,
          rotationX = 0,
          rotationOrbit = 0,
          target = [0, 0, 0],
          zoom = 0,
          minRotationX = -90,
          maxRotationX = 90,
          minZoom = -Infinity,
          maxZoom = Infinity,
          startPanPosition,
          startRotatePos,
          startRotationX,
          startRotationOrbit,
          startZoomPosition,
          startZoom
        } = options;
        super({
          width,
          height,
          rotationX,
          rotationOrbit,
          target,
          zoom,
          minRotationX,
          maxRotationX,
          minZoom,
          maxZoom
        }, {
          startPanPosition,
          startRotatePos,
          startRotationX,
          startRotationOrbit,
          startZoomPosition,
          startZoom
        });
        _defineProperty(this, "makeViewport", void 0);
        this.makeViewport = options.makeViewport;
      }
      panStart({
        pos
      }) {
        return this._getUpdatedState({
          startPanPosition: this._unproject(pos)
        });
      }
      pan({
        pos,
        startPosition
      }) {
        const startPanPosition = this.getState().startPanPosition || startPosition;
        if (!startPanPosition) {
          return this;
        }
        const viewport = this.makeViewport(this.getViewportProps());
        const newProps = viewport.panByPosition(startPanPosition, pos);
        return this._getUpdatedState(newProps);
      }
      panEnd() {
        return this._getUpdatedState({
          startPanPosition: null
        });
      }
      rotateStart({
        pos
      }) {
        return this._getUpdatedState({
          startRotatePos: pos,
          startRotationX: this.getViewportProps().rotationX,
          startRotationOrbit: this.getViewportProps().rotationOrbit
        });
      }
      rotate({
        pos,
        deltaAngleX = 0,
        deltaAngleY = 0
      }) {
        const {
          startRotatePos,
          startRotationX,
          startRotationOrbit
        } = this.getState();
        const {
          width,
          height
        } = this.getViewportProps();
        if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) {
          return this;
        }
        let newRotation;
        if (pos) {
          let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
          const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
          if (startRotationX < -90 || startRotationX > 90) {
            deltaScaleX *= -1;
          }
          newRotation = {
            rotationX: startRotationX + deltaScaleY * 180,
            rotationOrbit: startRotationOrbit + deltaScaleX * 180
          };
        } else {
          newRotation = {
            rotationX: startRotationX + deltaAngleY,
            rotationOrbit: startRotationOrbit + deltaAngleX
          };
        }
        return this._getUpdatedState(newRotation);
      }
      rotateEnd() {
        return this._getUpdatedState({
          startRotationX: null,
          startRotationOrbit: null
        });
      }
      shortestPathFrom(viewState) {
        const fromProps = viewState.getViewportProps();
        const props = {
          ...this.getViewportProps()
        };
        const {
          rotationOrbit
        } = props;
        if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
          props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
        }
        return props;
      }
      zoomStart({
        pos
      }) {
        return this._getUpdatedState({
          startZoomPosition: this._unproject(pos),
          startZoom: this.getViewportProps().zoom
        });
      }
      zoom({
        pos,
        startPos,
        scale: scale5
      }) {
        let {
          startZoom,
          startZoomPosition
        } = this.getState();
        if (!startZoomPosition) {
          startZoom = this.getViewportProps().zoom;
          startZoomPosition = this._unproject(startPos) || this._unproject(pos);
        }
        if (!startZoomPosition) {
          return this;
        }
        const newZoom = this._calculateNewZoom({
          scale: scale5,
          startZoom
        });
        const zoomedViewport = this.makeViewport({
          ...this.getViewportProps(),
          zoom: newZoom
        });
        return this._getUpdatedState({
          zoom: newZoom,
          ...zoomedViewport.panByPosition(startZoomPosition, pos)
        });
      }
      zoomEnd() {
        return this._getUpdatedState({
          startZoomPosition: null,
          startZoom: null
        });
      }
      zoomIn(speed = 2) {
        return this._getUpdatedState({
          zoom: this._calculateNewZoom({
            scale: speed
          })
        });
      }
      zoomOut(speed = 2) {
        return this._getUpdatedState({
          zoom: this._calculateNewZoom({
            scale: 1 / speed
          })
        });
      }
      moveLeft(speed = 50) {
        return this._panFromCenter([-speed, 0]);
      }
      moveRight(speed = 50) {
        return this._panFromCenter([speed, 0]);
      }
      moveUp(speed = 50) {
        return this._panFromCenter([0, -speed]);
      }
      moveDown(speed = 50) {
        return this._panFromCenter([0, speed]);
      }
      rotateLeft(speed = 15) {
        return this._getUpdatedState({
          rotationOrbit: this.getViewportProps().rotationOrbit - speed
        });
      }
      rotateRight(speed = 15) {
        return this._getUpdatedState({
          rotationOrbit: this.getViewportProps().rotationOrbit + speed
        });
      }
      rotateUp(speed = 10) {
        return this._getUpdatedState({
          rotationX: this.getViewportProps().rotationX - speed
        });
      }
      rotateDown(speed = 10) {
        return this._getUpdatedState({
          rotationX: this.getViewportProps().rotationX + speed
        });
      }
      _unproject(pos) {
        const viewport = this.makeViewport(this.getViewportProps());
        return pos && viewport.unproject(pos);
      }
      _calculateNewZoom({
        scale: scale5,
        startZoom
      }) {
        const {
          maxZoom,
          minZoom
        } = this.getViewportProps();
        if (startZoom === void 0) {
          startZoom = this.getViewportProps().zoom;
        }
        const zoom = startZoom + Math.log2(scale5);
        return clamp(zoom, minZoom, maxZoom);
      }
      _panFromCenter(offset) {
        const {
          width,
          height,
          target
        } = this.getViewportProps();
        return this.pan({
          startPosition: target,
          pos: [width / 2 + offset[0], height / 2 + offset[1]]
        });
      }
      _getUpdatedState(newProps) {
        return new this.constructor({
          makeViewport: this.makeViewport,
          ...this.getViewportProps(),
          ...this.getState(),
          ...newProps
        });
      }
      applyConstraints(props) {
        const {
          maxZoom,
          minZoom,
          zoom,
          maxRotationX,
          minRotationX,
          rotationOrbit
        } = props;
        props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
        props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
        if (rotationOrbit < -180 || rotationOrbit > 180) {
          props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;
        }
        return props;
      }
    };
    OrbitController = class extends Controller {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "ControllerState", OrbitState);
        _defineProperty(this, "transition", {
          transitionDuration: 300,
          transitionInterpolator: new LinearInterpolator({
            transitionProps: {
              compare: ["target", "zoom", "rotationX", "rotationOrbit"],
              required: ["target", "zoom"]
            }
          })
        });
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/views/orbit-view.js
var OrbitView;
var init_orbit_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/orbit-view.js"() {
    init_defineProperty();
    init_view();
    init_orbit_viewport();
    init_orbit_controller();
    OrbitView = class extends View {
      constructor(props = {}) {
        super(props);
        this.props.orbitAxis = props.orbitAxis || "Z";
      }
      get ViewportType() {
        return OrbitViewport;
      }
      get ControllerType() {
        return OrbitController;
      }
    };
    _defineProperty(OrbitView, "displayName", "OrbitView");
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js
var OrthographicState, OrthographicController;
var init_orthographic_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js"() {
    init_defineProperty();
    init_esm11();
    init_controller();
    init_orbit_controller();
    init_linear_interpolator();
    OrthographicState = class extends OrbitState {
      constructor(props) {
        super(props);
        _defineProperty(this, "zoomAxis", void 0);
        this.zoomAxis = props.zoomAxis || "all";
      }
      _calculateNewZoom({
        scale: scale5,
        startZoom
      }) {
        const {
          maxZoom,
          minZoom
        } = this.getViewportProps();
        if (startZoom === void 0) {
          startZoom = this.getViewportProps().zoom;
        }
        let deltaZoom = Math.log2(scale5);
        if (Array.isArray(startZoom)) {
          let [newZoomX, newZoomY] = startZoom;
          switch (this.zoomAxis) {
            case "X":
              newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
              break;
            case "Y":
              newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
              break;
            default:
              let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
              if (z < minZoom) {
                deltaZoom += minZoom - z;
              }
              z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
              if (z > maxZoom) {
                deltaZoom += maxZoom - z;
              }
              newZoomX += deltaZoom;
              newZoomY += deltaZoom;
          }
          return [newZoomX, newZoomY];
        }
        return clamp(startZoom + deltaZoom, minZoom, maxZoom);
      }
    };
    OrthographicController = class extends Controller {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "ControllerState", OrthographicState);
        _defineProperty(this, "transition", {
          transitionDuration: 300,
          transitionInterpolator: new LinearInterpolator(["target", "zoom"])
        });
        _defineProperty(this, "dragMode", "pan");
      }
      _onPanRotate() {
        return false;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js
var OrthographicView;
var init_orthographic_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js"() {
    init_defineProperty();
    init_view();
    init_orthographic_viewport();
    init_orthographic_controller();
    OrthographicView = class extends View {
      get ViewportType() {
        return OrthographicViewport;
      }
      get ControllerType() {
        return OrthographicController;
      }
    };
    _defineProperty(OrthographicView, "displayName", "OrthographicView");
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js
var GlobeState, GlobeController;
var init_globe_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js"() {
    init_defineProperty();
    init_esm11();
    init_controller();
    init_map_controller();
    init_math_utils2();
    init_linear_interpolator();
    GlobeState = class extends MapState {
      applyConstraints(props) {
        const {
          maxZoom,
          minZoom,
          zoom
        } = props;
        props.zoom = clamp(zoom, minZoom, maxZoom);
        const {
          longitude,
          latitude
        } = props;
        if (longitude < -180 || longitude > 180) {
          props.longitude = mod(longitude + 180, 360) - 180;
        }
        props.latitude = clamp(latitude, -89, 89);
        return props;
      }
    };
    GlobeController = class extends Controller {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "ControllerState", GlobeState);
        _defineProperty(this, "transition", {
          transitionDuration: 300,
          transitionInterpolator: new LinearInterpolator(["longitude", "latitude", "zoom"])
        });
        _defineProperty(this, "dragMode", "pan");
      }
      setProps(props) {
        super.setProps(props);
        this.dragRotate = false;
        this.touchRotate = false;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/views/globe-view.js
var GlobeView;
var init_globe_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/globe-view.js"() {
    init_defineProperty();
    init_view();
    init_globe_viewport();
    init_globe_controller();
    GlobeView = class extends View {
      get ViewportType() {
        return GlobeViewport;
      }
      get ControllerType() {
        return GlobeController;
      }
    };
    _defineProperty(GlobeView, "displayName", "GlobeView");
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js
var LayerExtension;
var init_layer_extension = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js"() {
    init_defineProperty();
    init_deep_equal();
    LayerExtension = class {
      static get componentName() {
        return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
      }
      constructor(opts) {
        _defineProperty(this, "opts", void 0);
        if (opts) {
          this.opts = opts;
        }
      }
      equals(extension) {
        if (this === extension) {
          return true;
        }
        return this.constructor === extension.constructor && deepEqual(this.opts, extension.opts, 1);
      }
      getShaders(extension) {
        return null;
      }
      getSubLayerProps(extension) {
        const {
          defaultProps: defaultProps3
        } = extension.constructor;
        const newProps = {
          updateTriggers: {}
        };
        for (const key in defaultProps3) {
          if (key in this.props) {
            const propDef = defaultProps3[key];
            const propValue = this.props[key];
            newProps[key] = propValue;
            if (propDef && propDef.type === "accessor") {
              newProps.updateTriggers[key] = this.props.updateTriggers[key];
              if (typeof propValue === "function") {
                newProps[key] = this.getSubLayerAccessor(propValue);
              }
            }
          }
        }
        return newProps;
      }
      initializeState(context, extension) {
      }
      updateState(params, extension) {
      }
      onNeedsRedraw(extension) {
      }
      getNeedsPickingBuffer(extension) {
        return false;
      }
      draw(params, extension) {
      }
      finalizeState(context, extension) {
      }
    };
    _defineProperty(LayerExtension, "defaultProps", {});
    _defineProperty(LayerExtension, "extensionName", "LayerExtension");
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js
var LINEARLY_INTERPOLATED_PROPS, DEFAULT_OPTS, FlyToInterpolator;
var init_fly_to_interpolator = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js"() {
    init_defineProperty();
    init_transition_interpolator();
    init_esm11();
    init_esm();
    LINEARLY_INTERPOLATED_PROPS = ["bearing", "pitch"];
    DEFAULT_OPTS = {
      speed: 1.2,
      curve: 1.414
    };
    FlyToInterpolator = class extends TransitionInterpolator {
      constructor(opts = {}) {
        super({
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch"],
          extract: ["width", "height", "longitude", "latitude", "zoom", "bearing", "pitch"],
          required: ["width", "height", "latitude", "longitude", "zoom"]
        });
        _defineProperty(this, "opts", void 0);
        this.opts = {
          ...DEFAULT_OPTS,
          ...opts
        };
      }
      interpolateProps(startProps, endProps, t) {
        const viewport = flyToViewport(startProps, endProps, t, this.opts);
        for (const key of LINEARLY_INTERPOLATED_PROPS) {
          viewport[key] = lerp3(startProps[key] || 0, endProps[key] || 0, t);
        }
        return viewport;
      }
      getDuration(startProps, endProps) {
        let {
          transitionDuration
        } = endProps;
        if (transitionDuration === "auto") {
          transitionDuration = getFlyToDuration(startProps, endProps, this.opts);
        }
        return transitionDuration;
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/tesselator.js
var Tesselator;
var init_tesselator = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/tesselator.js"() {
    init_defineProperty();
    init_iterable_utils();
    init_typed_array_manager();
    init_assert9();
    init_esm10();
    Tesselator = class {
      constructor(opts) {
        _defineProperty(this, "opts", void 0);
        _defineProperty(this, "typedArrayManager", void 0);
        _defineProperty(this, "indexStarts", [0]);
        _defineProperty(this, "vertexStarts", [0]);
        _defineProperty(this, "vertexCount", 0);
        _defineProperty(this, "instanceCount", 0);
        _defineProperty(this, "attributes", void 0);
        _defineProperty(this, "_attributeDefs", void 0);
        _defineProperty(this, "data", void 0);
        _defineProperty(this, "getGeometry", void 0);
        _defineProperty(this, "geometryBuffer", void 0);
        _defineProperty(this, "buffers", void 0);
        _defineProperty(this, "positionSize", void 0);
        _defineProperty(this, "normalize", void 0);
        const {
          attributes = {}
        } = opts;
        this.typedArrayManager = typed_array_manager_default;
        this.attributes = {};
        this._attributeDefs = attributes;
        this.opts = opts;
        this.updateGeometry(opts);
      }
      updateGeometry(opts) {
        Object.assign(this.opts, opts);
        const {
          data,
          buffers = {},
          getGeometry,
          geometryBuffer,
          positionFormat,
          dataChanged,
          normalize: normalize4 = true
        } = this.opts;
        this.data = data;
        this.getGeometry = getGeometry;
        this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
        this.buffers = buffers;
        this.normalize = normalize4;
        if (geometryBuffer) {
          assert9(data.startIndices);
          this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
          if (!normalize4) {
            buffers.positions = geometryBuffer;
          }
        }
        this.geometryBuffer = buffers.positions;
        if (Array.isArray(dataChanged)) {
          for (const dataRange of dataChanged) {
            this._rebuildGeometry(dataRange);
          }
        } else {
          this._rebuildGeometry();
        }
      }
      updatePartialGeometry({
        startRow,
        endRow
      }) {
        this._rebuildGeometry({
          startRow,
          endRow
        });
      }
      getGeometryFromBuffer(geometryBuffer) {
        const value = geometryBuffer.value || geometryBuffer;
        if (!ArrayBuffer.isView(value)) {
          return null;
        }
        return getAccessorFromBuffer(value, {
          size: this.positionSize,
          offset: geometryBuffer.offset,
          stride: geometryBuffer.stride,
          startIndices: this.data.startIndices
        });
      }
      _allocate(instanceCount, copy2) {
        const {
          attributes,
          buffers,
          _attributeDefs,
          typedArrayManager
        } = this;
        for (const name in _attributeDefs) {
          if (name in buffers) {
            typedArrayManager.release(attributes[name]);
            attributes[name] = null;
          } else {
            const def = _attributeDefs[name];
            def.copy = copy2;
            attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
          }
        }
      }
      _forEachGeometry(visitor, startRow, endRow) {
        const {
          data,
          getGeometry
        } = this;
        const {
          iterable,
          objectInfo
        } = createIterable(data, startRow, endRow);
        for (const object of iterable) {
          objectInfo.index++;
          const geometry = getGeometry ? getGeometry(object, objectInfo) : null;
          visitor(geometry, objectInfo.index);
        }
      }
      _rebuildGeometry(dataRange) {
        if (!this.data) {
          return;
        }
        let {
          indexStarts,
          vertexStarts,
          instanceCount
        } = this;
        const {
          data,
          geometryBuffer
        } = this;
        const {
          startRow = 0,
          endRow = Infinity
        } = dataRange || {};
        const normalizedData = {};
        if (!dataRange) {
          indexStarts = [0];
          vertexStarts = [0];
        }
        if (this.normalize || !geometryBuffer) {
          this._forEachGeometry((geometry, dataIndex) => {
            const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
            normalizedData[dataIndex] = normalizedGeometry;
            vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
          }, startRow, endRow);
          instanceCount = vertexStarts[vertexStarts.length - 1];
        } else {
          vertexStarts = data.startIndices;
          instanceCount = vertexStarts[data.length] || 0;
          if (ArrayBuffer.isView(geometryBuffer)) {
            instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
          } else if (geometryBuffer instanceof Buffer2) {
            const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;
            instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
          } else if (geometryBuffer.buffer) {
            const byteStride = geometryBuffer.stride || this.positionSize * 4;
            instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
          } else if (geometryBuffer.value) {
            const bufferValue = geometryBuffer.value;
            const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
            instanceCount = instanceCount || bufferValue.length / elementStride;
          }
        }
        this._allocate(instanceCount, Boolean(dataRange));
        this.indexStarts = indexStarts;
        this.vertexStarts = vertexStarts;
        this.instanceCount = instanceCount;
        const context = {};
        this._forEachGeometry((geometry, dataIndex) => {
          const normalizedGeometry = normalizedData[dataIndex] || geometry;
          context.vertexStart = vertexStarts[dataIndex];
          context.indexStart = indexStarts[dataIndex];
          const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
          context.geometrySize = vertexEnd - vertexStarts[dataIndex];
          context.geometryIndex = dataIndex;
          this.updateGeometryAttributes(normalizedGeometry, context);
        }, startRow, endRow);
        this.vertexCount = indexStarts[indexStarts.length - 1];
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  AmbientLight: () => AmbientLight,
  AttributeManager: () => AttributeManager,
  COORDINATE_SYSTEM: () => COORDINATE_SYSTEM,
  CompositeLayer: () => CompositeLayer,
  Controller: () => Controller,
  Deck: () => Deck,
  DeckRenderer: () => DeckRenderer,
  DirectionalLight: () => DirectionalLight,
  FirstPersonController: () => FirstPersonController,
  FirstPersonView: () => FirstPersonView,
  FirstPersonViewport: () => FirstPersonViewport,
  FlyToInterpolator: () => FlyToInterpolator,
  Layer: () => Layer,
  LayerExtension: () => LayerExtension,
  LayerManager: () => LayerManager,
  LightingEffect: () => LightingEffect,
  LinearInterpolator: () => LinearInterpolator,
  MapController: () => MapController,
  MapView: () => MapView,
  OPERATION: () => OPERATION,
  OrbitController: () => OrbitController,
  OrbitView: () => OrbitView,
  OrbitViewport: () => OrbitViewport,
  OrthographicController: () => OrthographicController,
  OrthographicView: () => OrthographicView,
  OrthographicViewport: () => OrthographicViewport,
  PointLight: () => PointLight,
  PostProcessEffect: () => PostProcessEffect,
  TRANSITION_EVENTS: () => TRANSITION_EVENTS,
  Tesselator: () => Tesselator,
  TransitionInterpolator: () => TransitionInterpolator,
  UNIT: () => UNIT,
  VERSION: () => VERSION5,
  View: () => View,
  Viewport: () => Viewport,
  WebMercatorViewport: () => WebMercatorViewport,
  _CameraLight: () => CameraLight,
  _GlobeController: () => GlobeController,
  _GlobeView: () => GlobeView,
  _GlobeViewport: () => GlobeViewport,
  _LayersPass: () => LayersPass,
  _PickLayersPass: () => PickLayersPass,
  _SunLight: () => SunLight,
  _compareProps: () => compareProps,
  _count: () => count,
  _deepEqual: () => deepEqual,
  _fillArray: () => fillArray2,
  _flatten: () => flatten,
  _memoize: () => memoize,
  _mergeShaders: () => mergeShaders,
  assert: () => assert9,
  createIterable: () => createIterable,
  fp64LowPart: () => fp64LowPart2,
  gouraudLighting: () => gouraudLighting,
  log: () => log_default,
  phongLighting: () => phongLighting,
  picking: () => picking_default,
  project: () => project_default,
  project32: () => project32_default,
  shadow: () => shadow_default
});
var init_esm17 = __esm({
  "node_modules/@deck.gl/core/dist/esm/index.js"() {
    init_init2();
    init_constants();
    init_lighting_effect();
    init_ambient_light();
    init_directional_light();
    init_point_light();
    init_camera_light();
    init_sun_light();
    init_post_process_effect();
    init_layers_pass();
    init_pick_layers_pass();
    init_deck();
    init_layer_manager();
    init_attribute_manager();
    init_layer();
    init_composite_layer();
    init_deck_renderer();
    init_viewport();
    init_web_mercator_viewport();
    init_globe_viewport();
    init_orbit_viewport();
    init_orthographic_viewport();
    init_first_person_viewport();
    init_shaderlib();
    init_view();
    init_map_view();
    init_first_person_view();
    init_orbit_view();
    init_orthographic_view();
    init_globe_view();
    init_controller();
    init_map_controller();
    init_globe_controller();
    init_first_person_controller();
    init_orbit_controller();
    init_orthographic_controller();
    init_layer_extension();
    init_transition_manager();
    init_transition_interpolator();
    init_linear_interpolator();
    init_fly_to_interpolator();
    init_log3();
    init_assert9();
    init_iterable_utils();
    init_math_utils2();
    init_tesselator();
    init_flatten();
    init_count();
    init_deep_equal();
    init_memoize();
    init_shader2();
    init_props();
  }
});

export {
  assert,
  isBrowser2 as isBrowser,
  loadLibrary,
  init_esm2 as init_esm,
  parseJSON,
  concatenateTypedArrays,
  sliceArrayBuffer,
  padToNBytes,
  copyToArray,
  Stats,
  init_esm3 as init_esm2,
  RequestScheduler,
  path_exports,
  init_esm4 as init_esm3,
  fetchFile,
  load,
  init_esm7 as init_esm4,
  getBinaryImageMetadata,
  ImageLoader,
  _isImageFormatSupported,
  init_esm8 as init_esm5,
  log_default,
  VERSION5 as VERSION,
  COORDINATE_SYSTEM,
  UNIT,
  OPERATION,
  log2 as log,
  isWebGL2,
  withParameters,
  cssToDeviceRatio,
  init_esm9 as init_esm6,
  assert6 as assert2,
  uid,
  Accessor,
  Buffer2 as Buffer,
  Texture2D,
  Renderbuffer,
  clear,
  readPixelsToArray,
  copyToTexture,
  FEATURES,
  hasFeature,
  hasFeatures,
  Framebuffer,
  init_esm10 as init_esm7,
  fp64,
  assert8 as assert3,
  config,
  configure,
  formatValue2 as formatValue,
  isArray2 as isArray,
  clone,
  toRadians,
  toDegrees,
  radians,
  degrees,
  sin,
  cos,
  tan,
  asin,
  acos,
  atan,
  clamp,
  lerp3 as lerp,
  equals,
  exactEquals,
  withEpsilon,
  Vector2,
  Vector3,
  Vector4,
  Matrix3,
  Matrix4,
  Quaternion,
  SphericalCoordinates,
  Euler,
  Pose,
  math_utils_default,
  init_esm11 as init_esm8,
  gouraudLighting,
  phongLighting,
  pbr,
  init_esm12 as init_esm9,
  ProgramManager,
  Model,
  Geometry,
  CubeGeometry,
  init_esm13 as init_esm10,
  esm_exports,
  init_esm14 as init_esm11,
  AmbientLight,
  DirectionalLight,
  LayersPass,
  memoize,
  project_default,
  shadow_default,
  LightingEffect,
  fp64LowPart2 as fp64LowPart,
  Viewport,
  WebMercatorViewport,
  PointLight,
  CameraLight,
  SunLight,
  PostProcessEffect,
  PickLayersPass,
  flatten,
  fillArray2 as fillArray,
  project32_default,
  picking_default,
  LayerManager,
  deepEqual,
  assert9 as assert4,
  View,
  TRANSITION_EVENTS,
  TransitionInterpolator,
  LinearInterpolator,
  Controller,
  MapController,
  MapView,
  DeckRenderer,
  Deck,
  createIterable,
  AttributeManager,
  compareProps,
  count,
  mergeShaders,
  Layer,
  CompositeLayer,
  GlobeViewport,
  OrbitViewport,
  OrthographicViewport,
  FirstPersonViewport,
  FirstPersonController,
  FirstPersonView,
  OrbitController,
  OrbitView,
  OrthographicController,
  OrthographicView,
  GlobeController,
  GlobeView,
  LayerExtension,
  FlyToInterpolator,
  Tesselator,
  esm_exports2,
  init_esm17 as init_esm12
};
/*! Bundled license information:

@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js:
  (**
   * ORIGINAL LICENCE
   * @license
   * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   *  * Neither the name of NVIDIA CORPORATION nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
   * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=chunk-T5R6RA5R.js.map
