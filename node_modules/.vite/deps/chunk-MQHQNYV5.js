import {
  MAX_LATITUDE,
  WebMercatorViewport,
  addMetersToLngLat,
  altitudeToFovy,
  fitBounds,
  flyToViewport,
  fovyToAltitude,
  getBounds,
  getDistanceScales,
  getFlyToDuration,
  getMeterZoom,
  getProjectionMatrix,
  getProjectionParameters,
  getViewMatrix,
  init_esm,
  lngLatToWorld,
  normalizeViewportProps,
  pixelsToWorld,
  scaleToZoom,
  unitsPerMeter,
  worldToLngLat,
  worldToPixels,
  zoomToScale
} from "./chunk-YAGFDRXW.js";
import {
  d3_geo_exports,
  init_d3_geo,
  require_geojson_rbush,
  require_js,
  require_js2,
  require_js3
} from "./chunk-EXNR5W7M.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-TFWDKVI3.js";

// node_modules/polygon-clipping/dist/polygon-clipping.umd.js
var require_polygon_clipping_umd = __commonJS({
  "node_modules/polygon-clipping/dist/polygon-clipping.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.polygonClipping = factory());
    })(exports, function() {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var Node = (
        /** @class */
        function() {
          function Node2(key, data) {
            this.next = null;
            this.key = key;
            this.data = data;
            this.left = null;
            this.right = null;
          }
          return Node2;
        }()
      );
      function DEFAULT_COMPARE(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
      }
      function splay(i, t, comparator) {
        var N = new Node(null, null);
        var l = N;
        var r = N;
        while (true) {
          var cmp2 = comparator(i, t.key);
          if (cmp2 < 0) {
            if (t.left === null)
              break;
            if (comparator(i, t.left.key) < 0) {
              var y = t.left;
              t.left = y.right;
              y.right = t;
              t = y;
              if (t.left === null)
                break;
            }
            r.left = t;
            r = t;
            t = t.left;
          } else if (cmp2 > 0) {
            if (t.right === null)
              break;
            if (comparator(i, t.right.key) > 0) {
              var y = t.right;
              t.right = y.left;
              y.left = t;
              t = y;
              if (t.right === null)
                break;
            }
            l.right = t;
            l = t;
            t = t.right;
          } else
            break;
        }
        l.right = t.left;
        r.left = t.right;
        t.left = N.right;
        t.right = N.left;
        return t;
      }
      function insert(i, data, t, comparator) {
        var node = new Node(i, data);
        if (t === null) {
          node.left = node.right = null;
          return node;
        }
        t = splay(i, t, comparator);
        var cmp2 = comparator(i, t.key);
        if (cmp2 < 0) {
          node.left = t.left;
          node.right = t;
          t.left = null;
        } else if (cmp2 >= 0) {
          node.right = t.right;
          node.left = t;
          t.right = null;
        }
        return node;
      }
      function split(key, v, comparator) {
        var left = null;
        var right = null;
        if (v) {
          v = splay(key, v, comparator);
          var cmp2 = comparator(v.key, key);
          if (cmp2 === 0) {
            left = v.left;
            right = v.right;
          } else if (cmp2 < 0) {
            right = v.right;
            v.right = null;
            left = v;
          } else {
            left = v.left;
            v.left = null;
            right = v;
          }
        }
        return {
          left,
          right
        };
      }
      function merge(left, right, comparator) {
        if (right === null)
          return left;
        if (left === null)
          return right;
        right = splay(left.key, right, comparator);
        right.left = left;
        return right;
      }
      function printRow(root, prefix, isTail, out, printNode) {
        if (root) {
          out("" + prefix + (isTail ? "└── " : "├── ") + printNode(root) + "\n");
          var indent = prefix + (isTail ? "    " : "│   ");
          if (root.left)
            printRow(root.left, indent, false, out, printNode);
          if (root.right)
            printRow(root.right, indent, true, out, printNode);
        }
      }
      var Tree = (
        /** @class */
        function() {
          function Tree2(comparator) {
            if (comparator === void 0) {
              comparator = DEFAULT_COMPARE;
            }
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
          }
          Tree2.prototype.insert = function(key, data) {
            this._size++;
            return this._root = insert(key, data, this._root, this._comparator);
          };
          Tree2.prototype.add = function(key, data) {
            var node = new Node(key, data);
            if (this._root === null) {
              node.left = node.right = null;
              this._size++;
              this._root = node;
            }
            var comparator = this._comparator;
            var t = splay(key, this._root, comparator);
            var cmp2 = comparator(key, t.key);
            if (cmp2 === 0)
              this._root = t;
            else {
              if (cmp2 < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
              } else if (cmp2 > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
              }
              this._size++;
              this._root = node;
            }
            return this._root;
          };
          Tree2.prototype.remove = function(key) {
            this._root = this._remove(key, this._root, this._comparator);
          };
          Tree2.prototype._remove = function(i, t, comparator) {
            var x;
            if (t === null)
              return null;
            t = splay(i, t, comparator);
            var cmp2 = comparator(i, t.key);
            if (cmp2 === 0) {
              if (t.left === null) {
                x = t.right;
              } else {
                x = splay(i, t.left, comparator);
                x.right = t.right;
              }
              this._size--;
              return x;
            }
            return t;
          };
          Tree2.prototype.pop = function() {
            var node = this._root;
            if (node) {
              while (node.left) {
                node = node.left;
              }
              this._root = splay(node.key, this._root, this._comparator);
              this._root = this._remove(node.key, this._root, this._comparator);
              return {
                key: node.key,
                data: node.data
              };
            }
            return null;
          };
          Tree2.prototype.findStatic = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp2 = compare(key, current.key);
              if (cmp2 === 0)
                return current;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return null;
          };
          Tree2.prototype.find = function(key) {
            if (this._root) {
              this._root = splay(key, this._root, this._comparator);
              if (this._comparator(key, this._root.key) !== 0)
                return null;
            }
            return this._root;
          };
          Tree2.prototype.contains = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp2 = compare(key, current.key);
              if (cmp2 === 0)
                return true;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return false;
          };
          Tree2.prototype.forEach = function(visitor, ctx) {
            var current = this._root;
            var Q = [];
            var done = false;
            while (!done) {
              if (current !== null) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length !== 0) {
                  current = Q.pop();
                  visitor.call(ctx, current);
                  current = current.right;
                } else
                  done = true;
              }
            }
            return this;
          };
          Tree2.prototype.range = function(low, high, fn, ctx) {
            var Q = [];
            var compare = this._comparator;
            var node = this._root;
            var cmp2;
            while (Q.length !== 0 || node) {
              if (node) {
                Q.push(node);
                node = node.left;
              } else {
                node = Q.pop();
                cmp2 = compare(node.key, high);
                if (cmp2 > 0) {
                  break;
                } else if (compare(node.key, low) >= 0) {
                  if (fn.call(ctx, node))
                    return this;
                }
                node = node.right;
              }
            }
            return this;
          };
          Tree2.prototype.keys = function() {
            var keys = [];
            this.forEach(function(_a) {
              var key = _a.key;
              return keys.push(key);
            });
            return keys;
          };
          Tree2.prototype.values = function() {
            var values = [];
            this.forEach(function(_a) {
              var data = _a.data;
              return values.push(data);
            });
            return values;
          };
          Tree2.prototype.min = function() {
            if (this._root)
              return this.minNode(this._root).key;
            return null;
          };
          Tree2.prototype.max = function() {
            if (this._root)
              return this.maxNode(this._root).key;
            return null;
          };
          Tree2.prototype.minNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.left) {
                t = t.left;
              }
            return t;
          };
          Tree2.prototype.maxNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.right) {
                t = t.right;
              }
            return t;
          };
          Tree2.prototype.at = function(index2) {
            var current = this._root;
            var done = false;
            var i = 0;
            var Q = [];
            while (!done) {
              if (current) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length > 0) {
                  current = Q.pop();
                  if (i === index2)
                    return current;
                  i++;
                  current = current.right;
                } else
                  done = true;
              }
            }
            return null;
          };
          Tree2.prototype.next = function(d) {
            var root = this._root;
            var successor = null;
            if (d.right) {
              successor = d.right;
              while (successor.left) {
                successor = successor.left;
              }
              return successor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0) {
                successor = root;
                root = root.left;
              } else
                root = root.right;
            }
            return successor;
          };
          Tree2.prototype.prev = function(d) {
            var root = this._root;
            var predecessor = null;
            if (d.left !== null) {
              predecessor = d.left;
              while (predecessor.right) {
                predecessor = predecessor.right;
              }
              return predecessor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0)
                root = root.left;
              else {
                predecessor = root;
                root = root.right;
              }
            }
            return predecessor;
          };
          Tree2.prototype.clear = function() {
            this._root = null;
            this._size = 0;
            return this;
          };
          Tree2.prototype.toList = function() {
            return toList(this._root);
          };
          Tree2.prototype.load = function(keys, values, presort) {
            if (values === void 0) {
              values = [];
            }
            if (presort === void 0) {
              presort = false;
            }
            var size = keys.length;
            var comparator = this._comparator;
            if (presort)
              sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) {
              this._root = loadRecursive(keys, values, 0, size);
              this._size = size;
            } else {
              var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
              size = this._size + size;
              this._root = sortedListToBST({
                head: mergedList
              }, 0, size);
            }
            return this;
          };
          Tree2.prototype.isEmpty = function() {
            return this._root === null;
          };
          Object.defineProperty(Tree2.prototype, "size", {
            get: function get() {
              return this._size;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Tree2.prototype, "root", {
            get: function get() {
              return this._root;
            },
            enumerable: true,
            configurable: true
          });
          Tree2.prototype.toString = function(printNode) {
            if (printNode === void 0) {
              printNode = function printNode2(n) {
                return String(n.key);
              };
            }
            var out = [];
            printRow(this._root, "", true, function(v) {
              return out.push(v);
            }, printNode);
            return out.join("");
          };
          Tree2.prototype.update = function(key, newKey, newData) {
            var comparator = this._comparator;
            var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
            if (comparator(key, newKey) < 0) {
              right = insert(newKey, newData, right, comparator);
            } else {
              left = insert(newKey, newData, left, comparator);
            }
            this._root = merge(left, right, comparator);
          };
          Tree2.prototype.split = function(key) {
            return split(key, this._root, this._comparator);
          };
          return Tree2;
        }()
      );
      function loadRecursive(keys, values, start, end) {
        var size = end - start;
        if (size > 0) {
          var middle = start + Math.floor(size / 2);
          var key = keys[middle];
          var data = values[middle];
          var node = new Node(key, data);
          node.left = loadRecursive(keys, values, start, middle);
          node.right = loadRecursive(keys, values, middle + 1, end);
          return node;
        }
        return null;
      }
      function createList(keys, values) {
        var head = new Node(null, null);
        var p = head;
        for (var i = 0; i < keys.length; i++) {
          p = p.next = new Node(keys[i], values[i]);
        }
        p.next = null;
        return head.next;
      }
      function toList(root) {
        var current = root;
        var Q = [];
        var done = false;
        var head = new Node(null, null);
        var p = head;
        while (!done) {
          if (current) {
            Q.push(current);
            current = current.left;
          } else {
            if (Q.length > 0) {
              current = p = p.next = Q.pop();
              current = current.right;
            } else
              done = true;
          }
        }
        p.next = null;
        return head.next;
      }
      function sortedListToBST(list, start, end) {
        var size = end - start;
        if (size > 0) {
          var middle = start + Math.floor(size / 2);
          var left = sortedListToBST(list, start, middle);
          var root = list.head;
          root.left = left;
          list.head = list.head.next;
          root.right = sortedListToBST(list, middle + 1, end);
          return root;
        }
        return null;
      }
      function mergeLists(l1, l2, compare) {
        var head = new Node(null, null);
        var p = head;
        var p1 = l1;
        var p2 = l2;
        while (p1 !== null && p2 !== null) {
          if (compare(p1.key, p2.key) < 0) {
            p.next = p1;
            p1 = p1.next;
          } else {
            p.next = p2;
            p2 = p2.next;
          }
          p = p.next;
        }
        if (p1 !== null) {
          p.next = p1;
        } else if (p2 !== null) {
          p.next = p2;
        }
        return head.next;
      }
      function sort(keys, values, left, right, compare) {
        if (left >= right)
          return;
        var pivot = keys[left + right >> 1];
        var i = left - 1;
        var j = right + 1;
        while (true) {
          do {
            i++;
          } while (compare(keys[i], pivot) < 0);
          do {
            j--;
          } while (compare(keys[j], pivot) > 0);
          if (i >= j)
            break;
          var tmp = keys[i];
          keys[i] = keys[j];
          keys[j] = tmp;
          tmp = values[i];
          values[i] = values[j];
          values[j] = tmp;
        }
        sort(keys, values, left, j, compare);
        sort(keys, values, j + 1, right, compare);
      }
      var isInBbox = function isInBbox2(bbox, point2) {
        return bbox.ll.x <= point2.x && point2.x <= bbox.ur.x && bbox.ll.y <= point2.y && point2.y <= bbox.ur.y;
      };
      var getBboxOverlap = function getBboxOverlap2(b1, b2) {
        if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
          return null;
        var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
        var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
        var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
        var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
        return {
          ll: {
            x: lowerX,
            y: lowerY
          },
          ur: {
            x: upperX,
            y: upperY
          }
        };
      };
      var epsilon = Number.EPSILON;
      if (epsilon === void 0)
        epsilon = Math.pow(2, -52);
      var EPSILON_SQ = epsilon * epsilon;
      var cmp = function cmp2(a, b) {
        if (-epsilon < a && a < epsilon) {
          if (-epsilon < b && b < epsilon) {
            return 0;
          }
        }
        var ab = a - b;
        if (ab * ab < EPSILON_SQ * a * b) {
          return 0;
        }
        return a < b ? -1 : 1;
      };
      var PtRounder = function() {
        function PtRounder2() {
          _classCallCheck(this, PtRounder2);
          this.reset();
        }
        _createClass(PtRounder2, [{
          key: "reset",
          value: function reset() {
            this.xRounder = new CoordRounder();
            this.yRounder = new CoordRounder();
          }
        }, {
          key: "round",
          value: function round(x, y) {
            return {
              x: this.xRounder.round(x),
              y: this.yRounder.round(y)
            };
          }
        }]);
        return PtRounder2;
      }();
      var CoordRounder = function() {
        function CoordRounder2() {
          _classCallCheck(this, CoordRounder2);
          this.tree = new Tree();
          this.round(0);
        }
        _createClass(CoordRounder2, [{
          key: "round",
          value: function round(coord) {
            var node = this.tree.add(coord);
            var prevNode = this.tree.prev(node);
            if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
              this.tree.remove(coord);
              return prevNode.key;
            }
            var nextNode = this.tree.next(node);
            if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
              this.tree.remove(coord);
              return nextNode.key;
            }
            return coord;
          }
        }]);
        return CoordRounder2;
      }();
      var rounder = new PtRounder();
      var crossProduct = function crossProduct2(a, b) {
        return a.x * b.y - a.y * b.x;
      };
      var dotProduct = function dotProduct2(a, b) {
        return a.x * b.x + a.y * b.y;
      };
      var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
        var v1 = {
          x: endPt1.x - basePt.x,
          y: endPt1.y - basePt.y
        };
        var v2 = {
          x: endPt2.x - basePt.x,
          y: endPt2.y - basePt.y
        };
        var kross = crossProduct(v1, v2);
        return cmp(kross, 0);
      };
      var length = function length2(v) {
        return Math.sqrt(dotProduct(v, v));
      };
      var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
        var vBase = {
          x: pBase.x - pShared.x,
          y: pBase.y - pShared.y
        };
        var vAngle = {
          x: pAngle.x - pShared.x,
          y: pAngle.y - pShared.y
        };
        return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
      };
      var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
        var vBase = {
          x: pBase.x - pShared.x,
          y: pBase.y - pShared.y
        };
        var vAngle = {
          x: pAngle.x - pShared.x,
          y: pAngle.y - pShared.y
        };
        return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
      };
      var horizontalIntersection = function horizontalIntersection2(pt, v, y) {
        if (v.y === 0)
          return null;
        return {
          x: pt.x + v.x / v.y * (y - pt.y),
          y
        };
      };
      var verticalIntersection = function verticalIntersection2(pt, v, x) {
        if (v.x === 0)
          return null;
        return {
          x,
          y: pt.y + v.y / v.x * (x - pt.x)
        };
      };
      var intersection = function intersection2(pt1, v1, pt2, v2) {
        if (v1.x === 0)
          return verticalIntersection(pt2, v2, pt1.x);
        if (v2.x === 0)
          return verticalIntersection(pt1, v1, pt2.x);
        if (v1.y === 0)
          return horizontalIntersection(pt2, v2, pt1.y);
        if (v2.y === 0)
          return horizontalIntersection(pt1, v1, pt2.y);
        var kross = crossProduct(v1, v2);
        if (kross == 0)
          return null;
        var ve = {
          x: pt2.x - pt1.x,
          y: pt2.y - pt1.y
        };
        var d1 = crossProduct(ve, v1) / kross;
        var d2 = crossProduct(ve, v2) / kross;
        var x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
        var y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
        var x = (x1 + x2) / 2;
        var y = (y1 + y2) / 2;
        return {
          x,
          y
        };
      };
      var SweepEvent = function() {
        _createClass(SweepEvent2, null, [{
          key: "compare",
          // for ordering sweep events in the sweep event queue
          value: function compare(a, b) {
            var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
            if (ptCmp !== 0)
              return ptCmp;
            if (a.point !== b.point)
              a.link(b);
            if (a.isLeft !== b.isLeft)
              return a.isLeft ? 1 : -1;
            return Segment.compare(a.segment, b.segment);
          }
          // for ordering points in sweep line order
        }, {
          key: "comparePoints",
          value: function comparePoints(aPt, bPt) {
            if (aPt.x < bPt.x)
              return -1;
            if (aPt.x > bPt.x)
              return 1;
            if (aPt.y < bPt.y)
              return -1;
            if (aPt.y > bPt.y)
              return 1;
            return 0;
          }
          // Warning: 'point' input will be modified and re-used (for performance)
        }]);
        function SweepEvent2(point2, isLeft) {
          _classCallCheck(this, SweepEvent2);
          if (point2.events === void 0)
            point2.events = [this];
          else
            point2.events.push(this);
          this.point = point2;
          this.isLeft = isLeft;
        }
        _createClass(SweepEvent2, [{
          key: "link",
          value: function link(other) {
            if (other.point === this.point) {
              throw new Error("Tried to link already linked events");
            }
            var otherEvents = other.point.events;
            for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
              var evt = otherEvents[i];
              this.point.events.push(evt);
              evt.point = this.point;
            }
            this.checkForConsuming();
          }
          /* Do a pass over our linked events and check to see if any pair
           * of segments match, and should be consumed. */
        }, {
          key: "checkForConsuming",
          value: function checkForConsuming() {
            var numEvents = this.point.events.length;
            for (var i = 0; i < numEvents; i++) {
              var evt1 = this.point.events[i];
              if (evt1.segment.consumedBy !== void 0)
                continue;
              for (var j = i + 1; j < numEvents; j++) {
                var evt2 = this.point.events[j];
                if (evt2.consumedBy !== void 0)
                  continue;
                if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
                  continue;
                evt1.segment.consume(evt2.segment);
              }
            }
          }
        }, {
          key: "getAvailableLinkedEvents",
          value: function getAvailableLinkedEvents() {
            var events = [];
            for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
              var evt = this.point.events[i];
              if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                events.push(evt);
              }
            }
            return events;
          }
          /**
           * Returns a comparator function for sorting linked events that will
           * favor the event that will give us the smallest left-side angle.
           * All ring construction starts as low as possible heading to the right,
           * so by always turning left as sharp as possible we'll get polygons
           * without uncessary loops & holes.
           *
           * The comparator function has a compute cache such that it avoids
           * re-computing already-computed values.
           */
        }, {
          key: "getLeftmostComparator",
          value: function getLeftmostComparator(baseEvent) {
            var _this = this;
            var cache = /* @__PURE__ */ new Map();
            var fillCache = function fillCache2(linkedEvent) {
              var nextEvent = linkedEvent.otherSE;
              cache.set(linkedEvent, {
                sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
                cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
              });
            };
            return function(a, b) {
              if (!cache.has(a))
                fillCache(a);
              if (!cache.has(b))
                fillCache(b);
              var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
              var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
              if (asine >= 0 && bsine >= 0) {
                if (acosine < bcosine)
                  return 1;
                if (acosine > bcosine)
                  return -1;
                return 0;
              }
              if (asine < 0 && bsine < 0) {
                if (acosine < bcosine)
                  return -1;
                if (acosine > bcosine)
                  return 1;
                return 0;
              }
              if (bsine < asine)
                return -1;
              if (bsine > asine)
                return 1;
              return 0;
            };
          }
        }]);
        return SweepEvent2;
      }();
      var segmentId = 0;
      var Segment = function() {
        _createClass(Segment2, null, [{
          key: "compare",
          /* This compare() function is for ordering segments in the sweep
           * line tree, and does so according to the following criteria:
           *
           * Consider the vertical line that lies an infinestimal step to the
           * right of the right-more of the two left endpoints of the input
           * segments. Imagine slowly moving a point up from negative infinity
           * in the increasing y direction. Which of the two segments will that
           * point intersect first? That segment comes 'before' the other one.
           *
           * If neither segment would be intersected by such a line, (if one
           * or more of the segments are vertical) then the line to be considered
           * is directly on the right-more of the two left inputs.
           */
          value: function compare(a, b) {
            var alx = a.leftSE.point.x;
            var blx = b.leftSE.point.x;
            var arx = a.rightSE.point.x;
            var brx = b.rightSE.point.x;
            if (brx < alx)
              return 1;
            if (arx < blx)
              return -1;
            var aly = a.leftSE.point.y;
            var bly = b.leftSE.point.y;
            var ary = a.rightSE.point.y;
            var bry = b.rightSE.point.y;
            if (alx < blx) {
              if (bly < aly && bly < ary)
                return 1;
              if (bly > aly && bly > ary)
                return -1;
              var aCmpBLeft = a.comparePoint(b.leftSE.point);
              if (aCmpBLeft < 0)
                return 1;
              if (aCmpBLeft > 0)
                return -1;
              var bCmpARight = b.comparePoint(a.rightSE.point);
              if (bCmpARight !== 0)
                return bCmpARight;
              return -1;
            }
            if (alx > blx) {
              if (aly < bly && aly < bry)
                return -1;
              if (aly > bly && aly > bry)
                return 1;
              var bCmpALeft = b.comparePoint(a.leftSE.point);
              if (bCmpALeft !== 0)
                return bCmpALeft;
              var aCmpBRight = a.comparePoint(b.rightSE.point);
              if (aCmpBRight < 0)
                return 1;
              if (aCmpBRight > 0)
                return -1;
              return 1;
            }
            if (aly < bly)
              return -1;
            if (aly > bly)
              return 1;
            if (arx < brx) {
              var _bCmpARight = b.comparePoint(a.rightSE.point);
              if (_bCmpARight !== 0)
                return _bCmpARight;
            }
            if (arx > brx) {
              var _aCmpBRight = a.comparePoint(b.rightSE.point);
              if (_aCmpBRight < 0)
                return 1;
              if (_aCmpBRight > 0)
                return -1;
            }
            if (arx !== brx) {
              var ay = ary - aly;
              var ax = arx - alx;
              var by = bry - bly;
              var bx = brx - blx;
              if (ay > ax && by < bx)
                return 1;
              if (ay < ax && by > bx)
                return -1;
            }
            if (arx > brx)
              return 1;
            if (arx < brx)
              return -1;
            if (ary < bry)
              return -1;
            if (ary > bry)
              return 1;
            if (a.id < b.id)
              return -1;
            if (a.id > b.id)
              return 1;
            return 0;
          }
          /* Warning: a reference to ringWindings input will be stored,
           *  and possibly will be later modified */
        }]);
        function Segment2(leftSE, rightSE, rings, windings) {
          _classCallCheck(this, Segment2);
          this.id = ++segmentId;
          this.leftSE = leftSE;
          leftSE.segment = this;
          leftSE.otherSE = rightSE;
          this.rightSE = rightSE;
          rightSE.segment = this;
          rightSE.otherSE = leftSE;
          this.rings = rings;
          this.windings = windings;
        }
        _createClass(Segment2, [{
          key: "replaceRightSE",
          /* When a segment is split, the rightSE is replaced with a new sweep event */
          value: function replaceRightSE(newRightSE) {
            this.rightSE = newRightSE;
            this.rightSE.segment = this;
            this.rightSE.otherSE = this.leftSE;
            this.leftSE.otherSE = this.rightSE;
          }
        }, {
          key: "bbox",
          value: function bbox() {
            var y1 = this.leftSE.point.y;
            var y2 = this.rightSE.point.y;
            return {
              ll: {
                x: this.leftSE.point.x,
                y: y1 < y2 ? y1 : y2
              },
              ur: {
                x: this.rightSE.point.x,
                y: y1 > y2 ? y1 : y2
              }
            };
          }
          /* A vector from the left point to the right */
        }, {
          key: "vector",
          value: function vector() {
            return {
              x: this.rightSE.point.x - this.leftSE.point.x,
              y: this.rightSE.point.y - this.leftSE.point.y
            };
          }
        }, {
          key: "isAnEndpoint",
          value: function isAnEndpoint(pt) {
            return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
          }
          /* Compare this segment with a point.
           *
           * A point P is considered to be colinear to a segment if there
           * exists a distance D such that if we travel along the segment
           * from one * endpoint towards the other a distance D, we find
           * ourselves at point P.
           *
           * Return value indicates:
           *
           *   1: point lies above the segment (to the left of vertical)
           *   0: point is colinear to segment
           *  -1: point lies below the segment (to the right of vertical)
           */
        }, {
          key: "comparePoint",
          value: function comparePoint(point2) {
            if (this.isAnEndpoint(point2))
              return 0;
            var lPt = this.leftSE.point;
            var rPt = this.rightSE.point;
            var v = this.vector();
            if (lPt.x === rPt.x) {
              if (point2.x === lPt.x)
                return 0;
              return point2.x < lPt.x ? 1 : -1;
            }
            var yDist = (point2.y - lPt.y) / v.y;
            var xFromYDist = lPt.x + yDist * v.x;
            if (point2.x === xFromYDist)
              return 0;
            var xDist = (point2.x - lPt.x) / v.x;
            var yFromXDist = lPt.y + xDist * v.y;
            if (point2.y === yFromXDist)
              return 0;
            return point2.y < yFromXDist ? -1 : 1;
          }
          /**
           * Given another segment, returns the first non-trivial intersection
           * between the two segments (in terms of sweep line ordering), if it exists.
           *
           * A 'non-trivial' intersection is one that will cause one or both of the
           * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
           *
           *   * endpoint of segA with endpoint of segB --> trivial
           *   * endpoint of segA with point along segB --> non-trivial
           *   * endpoint of segB with point along segA --> non-trivial
           *   * point along segA with point along segB --> non-trivial
           *
           * If no non-trivial intersection exists, return null
           * Else, return null.
           */
        }, {
          key: "getIntersection",
          value: function getIntersection(other) {
            var tBbox = this.bbox();
            var oBbox = other.bbox();
            var bboxOverlap = getBboxOverlap(tBbox, oBbox);
            if (bboxOverlap === null)
              return null;
            var tlp = this.leftSE.point;
            var trp = this.rightSE.point;
            var olp = other.leftSE.point;
            var orp = other.rightSE.point;
            var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
            var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
            var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
            var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
            if (touchesThisLSE && touchesOtherLSE) {
              if (touchesThisRSE && !touchesOtherRSE)
                return trp;
              if (!touchesThisRSE && touchesOtherRSE)
                return orp;
              return null;
            }
            if (touchesThisLSE) {
              if (touchesOtherRSE) {
                if (tlp.x === orp.x && tlp.y === orp.y)
                  return null;
              }
              return tlp;
            }
            if (touchesOtherLSE) {
              if (touchesThisRSE) {
                if (trp.x === olp.x && trp.y === olp.y)
                  return null;
              }
              return olp;
            }
            if (touchesThisRSE && touchesOtherRSE)
              return null;
            if (touchesThisRSE)
              return trp;
            if (touchesOtherRSE)
              return orp;
            var pt = intersection(tlp, this.vector(), olp, other.vector());
            if (pt === null)
              return null;
            if (!isInBbox(bboxOverlap, pt))
              return null;
            return rounder.round(pt.x, pt.y);
          }
          /**
           * Split the given segment into multiple segments on the given points.
           *  * Each existing segment will retain its leftSE and a new rightSE will be
           *    generated for it.
           *  * A new segment will be generated which will adopt the original segment's
           *    rightSE, and a new leftSE will be generated for it.
           *  * If there are more than two points given to split on, new segments
           *    in the middle will be generated with new leftSE and rightSE's.
           *  * An array of the newly generated SweepEvents will be returned.
           *
           * Warning: input array of points is modified
           */
        }, {
          key: "split",
          value: function split2(point2) {
            var newEvents = [];
            var alreadyLinked = point2.events !== void 0;
            var newLeftSE = new SweepEvent(point2, true);
            var newRightSE = new SweepEvent(point2, false);
            var oldRightSE = this.rightSE;
            this.replaceRightSE(newRightSE);
            newEvents.push(newRightSE);
            newEvents.push(newLeftSE);
            var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
            if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
              newSeg.swapEvents();
            }
            if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
              this.swapEvents();
            }
            if (alreadyLinked) {
              newLeftSE.checkForConsuming();
              newRightSE.checkForConsuming();
            }
            return newEvents;
          }
          /* Swap which event is left and right */
        }, {
          key: "swapEvents",
          value: function swapEvents() {
            var tmpEvt = this.rightSE;
            this.rightSE = this.leftSE;
            this.leftSE = tmpEvt;
            this.leftSE.isLeft = true;
            this.rightSE.isLeft = false;
            for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
              this.windings[i] *= -1;
            }
          }
          /* Consume another segment. We take their rings under our wing
           * and mark them as consumed. Use for perfectly overlapping segments */
        }, {
          key: "consume",
          value: function consume(other) {
            var consumer = this;
            var consumee = other;
            while (consumer.consumedBy) {
              consumer = consumer.consumedBy;
            }
            while (consumee.consumedBy) {
              consumee = consumee.consumedBy;
            }
            var cmp2 = Segment2.compare(consumer, consumee);
            if (cmp2 === 0)
              return;
            if (cmp2 > 0) {
              var tmp = consumer;
              consumer = consumee;
              consumee = tmp;
            }
            if (consumer.prev === consumee) {
              var _tmp = consumer;
              consumer = consumee;
              consumee = _tmp;
            }
            for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
              var ring = consumee.rings[i];
              var winding = consumee.windings[i];
              var index2 = consumer.rings.indexOf(ring);
              if (index2 === -1) {
                consumer.rings.push(ring);
                consumer.windings.push(winding);
              } else
                consumer.windings[index2] += winding;
            }
            consumee.rings = null;
            consumee.windings = null;
            consumee.consumedBy = consumer;
            consumee.leftSE.consumedBy = consumer.leftSE;
            consumee.rightSE.consumedBy = consumer.rightSE;
          }
          /* The first segment previous segment chain that is in the result */
        }, {
          key: "prevInResult",
          value: function prevInResult() {
            if (this._prevInResult !== void 0)
              return this._prevInResult;
            if (!this.prev)
              this._prevInResult = null;
            else if (this.prev.isInResult())
              this._prevInResult = this.prev;
            else
              this._prevInResult = this.prev.prevInResult();
            return this._prevInResult;
          }
        }, {
          key: "beforeState",
          value: function beforeState() {
            if (this._beforeState !== void 0)
              return this._beforeState;
            if (!this.prev)
              this._beforeState = {
                rings: [],
                windings: [],
                multiPolys: []
              };
            else {
              var seg = this.prev.consumedBy || this.prev;
              this._beforeState = seg.afterState();
            }
            return this._beforeState;
          }
        }, {
          key: "afterState",
          value: function afterState() {
            if (this._afterState !== void 0)
              return this._afterState;
            var beforeState = this.beforeState();
            this._afterState = {
              rings: beforeState.rings.slice(0),
              windings: beforeState.windings.slice(0),
              multiPolys: []
            };
            var ringsAfter = this._afterState.rings;
            var windingsAfter = this._afterState.windings;
            var mpsAfter = this._afterState.multiPolys;
            for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
              var ring = this.rings[i];
              var winding = this.windings[i];
              var index2 = ringsAfter.indexOf(ring);
              if (index2 === -1) {
                ringsAfter.push(ring);
                windingsAfter.push(winding);
              } else
                windingsAfter[index2] += winding;
            }
            var polysAfter = [];
            var polysExclude = [];
            for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
              if (windingsAfter[_i] === 0)
                continue;
              var _ring = ringsAfter[_i];
              var poly = _ring.poly;
              if (polysExclude.indexOf(poly) !== -1)
                continue;
              if (_ring.isExterior)
                polysAfter.push(poly);
              else {
                if (polysExclude.indexOf(poly) === -1)
                  polysExclude.push(poly);
                var _index = polysAfter.indexOf(_ring.poly);
                if (_index !== -1)
                  polysAfter.splice(_index, 1);
              }
            }
            for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
              var mp = polysAfter[_i2].multiPoly;
              if (mpsAfter.indexOf(mp) === -1)
                mpsAfter.push(mp);
            }
            return this._afterState;
          }
          /* Is this segment part of the final result? */
        }, {
          key: "isInResult",
          value: function isInResult() {
            if (this.consumedBy)
              return false;
            if (this._isInResult !== void 0)
              return this._isInResult;
            var mpsBefore = this.beforeState().multiPolys;
            var mpsAfter = this.afterState().multiPolys;
            switch (operation.type) {
              case "union": {
                var noBefores = mpsBefore.length === 0;
                var noAfters = mpsAfter.length === 0;
                this._isInResult = noBefores !== noAfters;
                break;
              }
              case "intersection": {
                var least;
                var most;
                if (mpsBefore.length < mpsAfter.length) {
                  least = mpsBefore.length;
                  most = mpsAfter.length;
                } else {
                  least = mpsAfter.length;
                  most = mpsBefore.length;
                }
                this._isInResult = most === operation.numMultiPolys && least < most;
                break;
              }
              case "xor": {
                var diff = Math.abs(mpsBefore.length - mpsAfter.length);
                this._isInResult = diff % 2 === 1;
                break;
              }
              case "difference": {
                var isJustSubject = function isJustSubject2(mps) {
                  return mps.length === 1 && mps[0].isSubject;
                };
                this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                break;
              }
              default:
                throw new Error("Unrecognized operation type found ".concat(operation.type));
            }
            return this._isInResult;
          }
        }], [{
          key: "fromRing",
          value: function fromRing(pt1, pt2, ring) {
            var leftPt, rightPt, winding;
            var cmpPts = SweepEvent.comparePoints(pt1, pt2);
            if (cmpPts < 0) {
              leftPt = pt1;
              rightPt = pt2;
              winding = 1;
            } else if (cmpPts > 0) {
              leftPt = pt2;
              rightPt = pt1;
              winding = -1;
            } else
              throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
            var leftSE = new SweepEvent(leftPt, true);
            var rightSE = new SweepEvent(rightPt, false);
            return new Segment2(leftSE, rightSE, [ring], [winding]);
          }
        }]);
        return Segment2;
      }();
      var RingIn = function() {
        function RingIn2(geomRing, poly, isExterior) {
          _classCallCheck(this, RingIn2);
          if (!Array.isArray(geomRing) || geomRing.length === 0) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          }
          this.poly = poly;
          this.isExterior = isExterior;
          this.segments = [];
          if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          }
          var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
          this.bbox = {
            ll: {
              x: firstPoint.x,
              y: firstPoint.y
            },
            ur: {
              x: firstPoint.x,
              y: firstPoint.y
            }
          };
          var prevPoint = firstPoint;
          for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
            if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            var point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
            if (point2.x === prevPoint.x && point2.y === prevPoint.y)
              continue;
            this.segments.push(Segment.fromRing(prevPoint, point2, this));
            if (point2.x < this.bbox.ll.x)
              this.bbox.ll.x = point2.x;
            if (point2.y < this.bbox.ll.y)
              this.bbox.ll.y = point2.y;
            if (point2.x > this.bbox.ur.x)
              this.bbox.ur.x = point2.x;
            if (point2.y > this.bbox.ur.y)
              this.bbox.ur.y = point2.y;
            prevPoint = point2;
          }
          if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
            this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
          }
        }
        _createClass(RingIn2, [{
          key: "getSweepEvents",
          value: function getSweepEvents() {
            var sweepEvents = [];
            for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
              var segment = this.segments[i];
              sweepEvents.push(segment.leftSE);
              sweepEvents.push(segment.rightSE);
            }
            return sweepEvents;
          }
        }]);
        return RingIn2;
      }();
      var PolyIn = function() {
        function PolyIn2(geomPoly, multiPoly) {
          _classCallCheck(this, PolyIn2);
          if (!Array.isArray(geomPoly)) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          }
          this.exteriorRing = new RingIn(geomPoly[0], this, true);
          this.bbox = {
            ll: {
              x: this.exteriorRing.bbox.ll.x,
              y: this.exteriorRing.bbox.ll.y
            },
            ur: {
              x: this.exteriorRing.bbox.ur.x,
              y: this.exteriorRing.bbox.ur.y
            }
          };
          this.interiorRings = [];
          for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
            var ring = new RingIn(geomPoly[i], this, false);
            if (ring.bbox.ll.x < this.bbox.ll.x)
              this.bbox.ll.x = ring.bbox.ll.x;
            if (ring.bbox.ll.y < this.bbox.ll.y)
              this.bbox.ll.y = ring.bbox.ll.y;
            if (ring.bbox.ur.x > this.bbox.ur.x)
              this.bbox.ur.x = ring.bbox.ur.x;
            if (ring.bbox.ur.y > this.bbox.ur.y)
              this.bbox.ur.y = ring.bbox.ur.y;
            this.interiorRings.push(ring);
          }
          this.multiPoly = multiPoly;
        }
        _createClass(PolyIn2, [{
          key: "getSweepEvents",
          value: function getSweepEvents() {
            var sweepEvents = this.exteriorRing.getSweepEvents();
            for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
              var ringSweepEvents = this.interiorRings[i].getSweepEvents();
              for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
                sweepEvents.push(ringSweepEvents[j]);
              }
            }
            return sweepEvents;
          }
        }]);
        return PolyIn2;
      }();
      var MultiPolyIn = function() {
        function MultiPolyIn2(geom, isSubject) {
          _classCallCheck(this, MultiPolyIn2);
          if (!Array.isArray(geom)) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          }
          try {
            if (typeof geom[0][0][0] === "number")
              geom = [geom];
          } catch (ex) {
          }
          this.polys = [];
          this.bbox = {
            ll: {
              x: Number.POSITIVE_INFINITY,
              y: Number.POSITIVE_INFINITY
            },
            ur: {
              x: Number.NEGATIVE_INFINITY,
              y: Number.NEGATIVE_INFINITY
            }
          };
          for (var i = 0, iMax = geom.length; i < iMax; i++) {
            var poly = new PolyIn(geom[i], this);
            if (poly.bbox.ll.x < this.bbox.ll.x)
              this.bbox.ll.x = poly.bbox.ll.x;
            if (poly.bbox.ll.y < this.bbox.ll.y)
              this.bbox.ll.y = poly.bbox.ll.y;
            if (poly.bbox.ur.x > this.bbox.ur.x)
              this.bbox.ur.x = poly.bbox.ur.x;
            if (poly.bbox.ur.y > this.bbox.ur.y)
              this.bbox.ur.y = poly.bbox.ur.y;
            this.polys.push(poly);
          }
          this.isSubject = isSubject;
        }
        _createClass(MultiPolyIn2, [{
          key: "getSweepEvents",
          value: function getSweepEvents() {
            var sweepEvents = [];
            for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
              var polySweepEvents = this.polys[i].getSweepEvents();
              for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
                sweepEvents.push(polySweepEvents[j]);
              }
            }
            return sweepEvents;
          }
        }]);
        return MultiPolyIn2;
      }();
      var RingOut = function() {
        _createClass(RingOut2, null, [{
          key: "factory",
          /* Given the segments from the sweep line pass, compute & return a series
           * of closed rings from all the segments marked to be part of the result */
          value: function factory(allSegments) {
            var ringsOut = [];
            for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
              var segment = allSegments[i];
              if (!segment.isInResult() || segment.ringOut)
                continue;
              var prevEvent = null;
              var event = segment.leftSE;
              var nextEvent = segment.rightSE;
              var events = [event];
              var startingPoint = event.point;
              var intersectionLEs = [];
              while (true) {
                prevEvent = event;
                event = nextEvent;
                events.push(event);
                if (event.point === startingPoint)
                  break;
                while (true) {
                  var availableLEs = event.getAvailableLinkedEvents();
                  if (availableLEs.length === 0) {
                    var firstPt = events[0].point;
                    var lastPt = events[events.length - 1].point;
                    throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                  }
                  if (availableLEs.length === 1) {
                    nextEvent = availableLEs[0].otherSE;
                    break;
                  }
                  var indexLE = null;
                  for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                    if (intersectionLEs[j].point === event.point) {
                      indexLE = j;
                      break;
                    }
                  }
                  if (indexLE !== null) {
                    var intersectionLE = intersectionLEs.splice(indexLE)[0];
                    var ringEvents = events.splice(intersectionLE.index);
                    ringEvents.unshift(ringEvents[0].otherSE);
                    ringsOut.push(new RingOut2(ringEvents.reverse()));
                    continue;
                  }
                  intersectionLEs.push({
                    index: events.length,
                    point: event.point
                  });
                  var comparator = event.getLeftmostComparator(prevEvent);
                  nextEvent = availableLEs.sort(comparator)[0].otherSE;
                  break;
                }
              }
              ringsOut.push(new RingOut2(events));
            }
            return ringsOut;
          }
        }]);
        function RingOut2(events) {
          _classCallCheck(this, RingOut2);
          this.events = events;
          for (var i = 0, iMax = events.length; i < iMax; i++) {
            events[i].segment.ringOut = this;
          }
          this.poly = null;
        }
        _createClass(RingOut2, [{
          key: "getGeom",
          value: function getGeom() {
            var prevPt = this.events[0].point;
            var points = [prevPt];
            for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
              var _pt = this.events[i].point;
              var _nextPt = this.events[i + 1].point;
              if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
                continue;
              points.push(_pt);
              prevPt = _pt;
            }
            if (points.length === 1)
              return null;
            var pt = points[0];
            var nextPt = points[1];
            if (compareVectorAngles(pt, prevPt, nextPt) === 0)
              points.shift();
            points.push(points[0]);
            var step = this.isExteriorRing() ? 1 : -1;
            var iStart = this.isExteriorRing() ? 0 : points.length - 1;
            var iEnd = this.isExteriorRing() ? points.length : -1;
            var orderedPoints = [];
            for (var _i = iStart; _i != iEnd; _i += step) {
              orderedPoints.push([points[_i].x, points[_i].y]);
            }
            return orderedPoints;
          }
        }, {
          key: "isExteriorRing",
          value: function isExteriorRing() {
            if (this._isExteriorRing === void 0) {
              var enclosing = this.enclosingRing();
              this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
            }
            return this._isExteriorRing;
          }
        }, {
          key: "enclosingRing",
          value: function enclosingRing() {
            if (this._enclosingRing === void 0) {
              this._enclosingRing = this._calcEnclosingRing();
            }
            return this._enclosingRing;
          }
          /* Returns the ring that encloses this one, if any */
        }, {
          key: "_calcEnclosingRing",
          value: function _calcEnclosingRing() {
            var leftMostEvt = this.events[0];
            for (var i = 1, iMax = this.events.length; i < iMax; i++) {
              var evt = this.events[i];
              if (SweepEvent.compare(leftMostEvt, evt) > 0)
                leftMostEvt = evt;
            }
            var prevSeg = leftMostEvt.segment.prevInResult();
            var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            while (true) {
              if (!prevSeg)
                return null;
              if (!prevPrevSeg)
                return prevSeg.ringOut;
              if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                  return prevSeg.ringOut;
                } else
                  return prevSeg.ringOut.enclosingRing();
              }
              prevSeg = prevPrevSeg.prevInResult();
              prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            }
          }
        }]);
        return RingOut2;
      }();
      var PolyOut = function() {
        function PolyOut2(exteriorRing) {
          _classCallCheck(this, PolyOut2);
          this.exteriorRing = exteriorRing;
          exteriorRing.poly = this;
          this.interiorRings = [];
        }
        _createClass(PolyOut2, [{
          key: "addInterior",
          value: function addInterior(ring) {
            this.interiorRings.push(ring);
            ring.poly = this;
          }
        }, {
          key: "getGeom",
          value: function getGeom() {
            var geom = [this.exteriorRing.getGeom()];
            if (geom[0] === null)
              return null;
            for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
              var ringGeom = this.interiorRings[i].getGeom();
              if (ringGeom === null)
                continue;
              geom.push(ringGeom);
            }
            return geom;
          }
        }]);
        return PolyOut2;
      }();
      var MultiPolyOut = function() {
        function MultiPolyOut2(rings) {
          _classCallCheck(this, MultiPolyOut2);
          this.rings = rings;
          this.polys = this._composePolys(rings);
        }
        _createClass(MultiPolyOut2, [{
          key: "getGeom",
          value: function getGeom() {
            var geom = [];
            for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
              var polyGeom = this.polys[i].getGeom();
              if (polyGeom === null)
                continue;
              geom.push(polyGeom);
            }
            return geom;
          }
        }, {
          key: "_composePolys",
          value: function _composePolys(rings) {
            var polys = [];
            for (var i = 0, iMax = rings.length; i < iMax; i++) {
              var ring = rings[i];
              if (ring.poly)
                continue;
              if (ring.isExteriorRing())
                polys.push(new PolyOut(ring));
              else {
                var enclosingRing = ring.enclosingRing();
                if (!enclosingRing.poly)
                  polys.push(new PolyOut(enclosingRing));
                enclosingRing.poly.addInterior(ring);
              }
            }
            return polys;
          }
        }]);
        return MultiPolyOut2;
      }();
      var SweepLine = function() {
        function SweepLine2(queue) {
          var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
          _classCallCheck(this, SweepLine2);
          this.queue = queue;
          this.tree = new Tree(comparator);
          this.segments = [];
        }
        _createClass(SweepLine2, [{
          key: "process",
          value: function process2(event) {
            var segment = event.segment;
            var newEvents = [];
            if (event.consumedBy) {
              if (event.isLeft)
                this.queue.remove(event.otherSE);
              else
                this.tree.remove(segment);
              return newEvents;
            }
            var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
            if (!node)
              throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
            var prevNode = node;
            var nextNode = node;
            var prevSeg = void 0;
            var nextSeg = void 0;
            while (prevSeg === void 0) {
              prevNode = this.tree.prev(prevNode);
              if (prevNode === null)
                prevSeg = null;
              else if (prevNode.key.consumedBy === void 0)
                prevSeg = prevNode.key;
            }
            while (nextSeg === void 0) {
              nextNode = this.tree.next(nextNode);
              if (nextNode === null)
                nextSeg = null;
              else if (nextNode.key.consumedBy === void 0)
                nextSeg = nextNode.key;
            }
            if (event.isLeft) {
              var prevMySplitter = null;
              if (prevSeg) {
                var prevInter = prevSeg.getIntersection(segment);
                if (prevInter !== null) {
                  if (!segment.isAnEndpoint(prevInter))
                    prevMySplitter = prevInter;
                  if (!prevSeg.isAnEndpoint(prevInter)) {
                    var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                    for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                      newEvents.push(newEventsFromSplit[i]);
                    }
                  }
                }
              }
              var nextMySplitter = null;
              if (nextSeg) {
                var nextInter = nextSeg.getIntersection(segment);
                if (nextInter !== null) {
                  if (!segment.isAnEndpoint(nextInter))
                    nextMySplitter = nextInter;
                  if (!nextSeg.isAnEndpoint(nextInter)) {
                    var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                    for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                      newEvents.push(_newEventsFromSplit[_i]);
                    }
                  }
                }
              }
              if (prevMySplitter !== null || nextMySplitter !== null) {
                var mySplitter = null;
                if (prevMySplitter === null)
                  mySplitter = nextMySplitter;
                else if (nextMySplitter === null)
                  mySplitter = prevMySplitter;
                else {
                  var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                  mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                }
                this.queue.remove(segment.rightSE);
                newEvents.push(segment.rightSE);
                var _newEventsFromSplit2 = segment.split(mySplitter);
                for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                  newEvents.push(_newEventsFromSplit2[_i2]);
                }
              }
              if (newEvents.length > 0) {
                this.tree.remove(segment);
                newEvents.push(event);
              } else {
                this.segments.push(segment);
                segment.prev = prevSeg;
              }
            } else {
              if (prevSeg && nextSeg) {
                var inter = prevSeg.getIntersection(nextSeg);
                if (inter !== null) {
                  if (!prevSeg.isAnEndpoint(inter)) {
                    var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
                    for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                      newEvents.push(_newEventsFromSplit3[_i3]);
                    }
                  }
                  if (!nextSeg.isAnEndpoint(inter)) {
                    var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
                    for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                      newEvents.push(_newEventsFromSplit4[_i4]);
                    }
                  }
                }
              }
              this.tree.remove(segment);
            }
            return newEvents;
          }
          /* Safely split a segment that is currently in the datastructures
           * IE - a segment other than the one that is currently being processed. */
        }, {
          key: "_splitSafely",
          value: function _splitSafely(seg, pt) {
            this.tree.remove(seg);
            var rightSE = seg.rightSE;
            this.queue.remove(rightSE);
            var newEvents = seg.split(pt);
            newEvents.push(rightSE);
            if (seg.consumedBy === void 0)
              this.tree.insert(seg);
            return newEvents;
          }
        }]);
        return SweepLine2;
      }();
      var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
      var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
      var Operation = function() {
        function Operation2() {
          _classCallCheck(this, Operation2);
        }
        _createClass(Operation2, [{
          key: "run",
          value: function run(type, geom, moreGeoms) {
            operation.type = type;
            rounder.reset();
            var multipolys = [new MultiPolyIn(geom, true)];
            for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
              multipolys.push(new MultiPolyIn(moreGeoms[i], false));
            }
            operation.numMultiPolys = multipolys.length;
            if (operation.type === "difference") {
              var subject = multipolys[0];
              var _i = 1;
              while (_i < multipolys.length) {
                if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
                  _i++;
                else
                  multipolys.splice(_i, 1);
              }
            }
            if (operation.type === "intersection") {
              for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
                var mpA = multipolys[_i2];
                for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                  if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
                    return [];
                }
              }
            }
            var queue = new Tree(SweepEvent.compare);
            for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
              var sweepEvents = multipolys[_i3].getSweepEvents();
              for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
                queue.insert(sweepEvents[_j]);
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                }
              }
            }
            var sweepLine = new SweepLine(queue);
            var prevQueueSize = queue.size;
            var node = queue.pop();
            while (node) {
              var evt = node.key;
              if (queue.size === prevQueueSize) {
                var seg = evt.segment;
                throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
              }
              if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
              }
              if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
              }
              var newEvents = sweepLine.process(evt);
              for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
                var _evt = newEvents[_i4];
                if (_evt.consumedBy === void 0)
                  queue.insert(_evt);
              }
              prevQueueSize = queue.size;
              node = queue.pop();
            }
            rounder.reset();
            var ringsOut = RingOut.factory(sweepLine.segments);
            var result = new MultiPolyOut(ringsOut);
            return result.getGeom();
          }
        }]);
        return Operation2;
      }();
      var operation = new Operation();
      var union = function union2(geom) {
        for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          moreGeoms[_key - 1] = arguments[_key];
        }
        return operation.run("union", geom, moreGeoms);
      };
      var intersection$1 = function intersection2(geom) {
        for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          moreGeoms[_key2 - 1] = arguments[_key2];
        }
        return operation.run("intersection", geom, moreGeoms);
      };
      var xor = function xor2(geom) {
        for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          moreGeoms[_key3 - 1] = arguments[_key3];
        }
        return operation.run("xor", geom, moreGeoms);
      };
      var difference = function difference2(subjectGeom) {
        for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          clippingGeoms[_key4 - 1] = arguments[_key4];
        }
        return operation.run("difference", subjectGeom, clippingGeoms);
      };
      var index = {
        union,
        intersection: intersection$1,
        xor,
        difference
      };
      return index;
    });
  }
});

// node_modules/@turf/invariant/dist/js/index.js
var require_js4 = __commonJS({
  "node_modules/@turf/invariant/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    function getCoord(coord) {
      if (!coord) {
        throw new Error("coord is required");
      }
      if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
          return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
          return coord.coordinates;
        }
      }
      if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
      }
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    exports.getCoord = getCoord;
    function getCoords3(coords) {
      if (Array.isArray(coords)) {
        return coords;
      }
      if (coords.type === "Feature") {
        if (coords.geometry !== null) {
          return coords.geometry.coordinates;
        }
      } else {
        if (coords.coordinates) {
          return coords.coordinates;
        }
      }
      throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
    }
    exports.getCoords = getCoords3;
    function containsNumber(coordinates) {
      if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
      }
      if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
      }
      throw new Error("coordinates must only contain numbers");
    }
    exports.containsNumber = containsNumber;
    function geojsonType(value, type, name) {
      if (!type || !name) {
        throw new Error("type and name required");
      }
      if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
      }
    }
    exports.geojsonType = geojsonType;
    function featureOf(feature2, type, name) {
      if (!feature2) {
        throw new Error("No feature passed");
      }
      if (!name) {
        throw new Error(".featureOf() requires a name");
      }
      if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
      }
      if (!feature2.geometry || feature2.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
      }
    }
    exports.featureOf = featureOf;
    function collectionOf(featureCollection2, type, name) {
      if (!featureCollection2) {
        throw new Error("No featureCollection passed");
      }
      if (!name) {
        throw new Error(".collectionOf() requires a name");
      }
      if (!featureCollection2 || featureCollection2.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
      }
      for (var _i = 0, _a = featureCollection2.features; _i < _a.length; _i++) {
        var feature2 = _a[_i];
        if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
          throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature2.geometry || feature2.geometry.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
        }
      }
    }
    exports.collectionOf = collectionOf;
    function getGeom(geojson) {
      if (geojson.type === "Feature") {
        return geojson.geometry;
      }
      return geojson;
    }
    exports.getGeom = getGeom;
    function getType(geojson, _name) {
      if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
      }
      if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
      }
      if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
      }
      return geojson.type;
    }
    exports.getType = getType;
  }
});

// node_modules/@turf/union/dist/js/index.js
var require_js5 = __commonJS({
  "node_modules/@turf/union/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var polygon_clipping_1 = __importDefault(require_polygon_clipping_umd());
    var invariant_1 = require_js4();
    var helpers_1 = require_js();
    function union(poly1, poly2, options) {
      if (options === void 0) {
        options = {};
      }
      var geom1 = invariant_1.getGeom(poly1);
      var geom2 = invariant_1.getGeom(poly2);
      var unioned = polygon_clipping_1.default.union(geom1.coordinates, geom2.coordinates);
      if (unioned.length === 0)
        return null;
      if (unioned.length === 1)
        return helpers_1.polygon(unioned[0], options.properties);
      else
        return helpers_1.multiPolygon(unioned, options.properties);
    }
    exports.default = union;
  }
});

// node_modules/@turf/difference/dist/js/index.js
var require_js6 = __commonJS({
  "node_modules/@turf/difference/dist/js/index.js"(exports, module) {
    "use strict";
    var polygonClipping = require_polygon_clipping_umd();
    var helpers = require_js();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var polygonClipping__default = _interopDefaultLegacy(polygonClipping);
    function difference(polygon1, polygon2) {
      var geom1 = invariant.getGeom(polygon1);
      var geom2 = invariant.getGeom(polygon2);
      var properties = polygon1.properties || {};
      var differenced = polygonClipping__default["default"].difference(
        geom1.coordinates,
        geom2.coordinates
      );
      if (differenced.length === 0)
        return null;
      if (differenced.length === 1)
        return helpers.polygon(differenced[0], properties);
      return helpers.multiPolygon(differenced, properties);
    }
    module.exports = difference;
    module.exports.default = difference;
  }
});

// node_modules/@turf/intersect/dist/js/index.js
var require_js7 = __commonJS({
  "node_modules/@turf/intersect/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var polygon_clipping_1 = __importDefault(require_polygon_clipping_umd());
    function intersect(poly1, poly2, options) {
      if (options === void 0) {
        options = {};
      }
      var geom1 = invariant_1.getGeom(poly1);
      var geom2 = invariant_1.getGeom(poly2);
      var intersection = polygon_clipping_1.default.intersection(geom1.coordinates, geom2.coordinates);
      if (intersection.length === 0)
        return null;
      if (intersection.length === 1)
        return helpers_1.polygon(intersection[0], options.properties);
      return helpers_1.multiPolygon(intersection, options.properties);
    }
    exports.default = intersect;
  }
});

// node_modules/@turf/rewind/node_modules/@turf/clone/main.es.js
function clone(geojson) {
  if (!geojson)
    throw new Error("geojson is required");
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  var cloned = { type: "Feature" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  cloned.geometry = cloneGeometry(geojson.geometry);
  return cloned;
}
function cloneProperties(properties) {
  var cloned = {};
  if (!properties)
    return cloned;
  Object.keys(properties).forEach(function(key) {
    var value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (value.length) {
        cloned[key] = value.map(function(item) {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else
      cloned[key] = value;
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  var cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map(function(feature2) {
    return cloneFeature(feature2);
  });
  return cloned;
}
function cloneGeometry(geometry) {
  var geom = { type: geometry.type };
  if (geometry.bbox)
    geom.bbox = geometry.bbox;
  if (geometry.type === "GeometryCollection") {
    geom.geometries = geometry.geometries.map(function(geom2) {
      return cloneGeometry(geom2);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry.coordinates);
  return geom;
}
function deepSlice(coords) {
  if (typeof coords[0] !== "object") {
    return coords.slice();
  }
  return coords.map(function(coord) {
    return deepSlice(coord);
  });
}
var main_es_default;
var init_main_es = __esm({
  "node_modules/@turf/rewind/node_modules/@turf/clone/main.es.js"() {
    main_es_default = clone;
  }
});

// node_modules/@turf/boolean-clockwise/node_modules/@turf/helpers/main.es.js
var earthRadius, factors, unitsFactors;
var init_main_es2 = __esm({
  "node_modules/@turf/boolean-clockwise/node_modules/@turf/helpers/main.es.js"() {
    earthRadius = 63710088e-1;
    factors = {
      meters: earthRadius,
      metres: earthRadius,
      millimeters: earthRadius * 1e3,
      millimetres: earthRadius * 1e3,
      centimeters: earthRadius * 100,
      centimetres: earthRadius * 100,
      kilometers: earthRadius / 1e3,
      kilometres: earthRadius / 1e3,
      miles: earthRadius / 1609.344,
      nauticalmiles: earthRadius / 1852,
      inches: earthRadius * 39.37,
      yards: earthRadius / 1.0936,
      feet: earthRadius * 3.28084,
      radians: 1,
      degrees: earthRadius / 111325
    };
    unitsFactors = {
      meters: 1,
      metres: 1,
      millimeters: 1e3,
      millimetres: 1e3,
      centimeters: 100,
      centimetres: 100,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      miles: 1 / 1609.344,
      nauticalmiles: 1 / 1852,
      inches: 39.37,
      yards: 1 / 1.0936,
      feet: 3.28084,
      radians: 1 / earthRadius,
      degrees: 1 / 111325
    };
  }
});

// node_modules/@turf/boolean-clockwise/node_modules/@turf/invariant/main.es.js
function getCoords(coords) {
  if (!coords)
    throw new Error("coords is required");
  if (coords.type === "Feature" && coords.geometry !== null)
    return coords.geometry.coordinates;
  if (coords.coordinates)
    return coords.coordinates;
  if (Array.isArray(coords))
    return coords;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
var init_main_es3 = __esm({
  "node_modules/@turf/boolean-clockwise/node_modules/@turf/invariant/main.es.js"() {
    init_main_es2();
  }
});

// node_modules/@turf/boolean-clockwise/main.es.js
function booleanClockwise(line) {
  if (!line)
    throw new Error("line is required");
  var type = line.geometry ? line.geometry.type : line.type;
  if (!Array.isArray(line) && type !== "LineString")
    throw new Error("geometry must be a LineString");
  var ring = getCoords(line);
  var sum = 0;
  var i = 1;
  var prev, cur;
  while (i < ring.length) {
    prev = cur || ring[0];
    cur = ring[i];
    sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
    i++;
  }
  return sum > 0;
}
var main_es_default2;
var init_main_es4 = __esm({
  "node_modules/@turf/boolean-clockwise/main.es.js"() {
    init_main_es3();
    main_es_default2 = booleanClockwise;
  }
});

// node_modules/@turf/rewind/node_modules/@turf/helpers/main.es.js
function featureCollection(features, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var bbox = options.bbox;
  var id = options.id;
  if (!features)
    throw new Error("No features passed");
  if (!Array.isArray(features))
    throw new Error("features must be an Array");
  if (bbox)
    validateBBox(bbox);
  if (id)
    validateId(id);
  var fc = { type: "FeatureCollection" };
  if (id)
    fc.id = id;
  if (bbox)
    fc.bbox = bbox;
  fc.features = features;
  return fc;
}
function isNumber2(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
  return !!input && input.constructor === Object;
}
function validateBBox(bbox) {
  if (!bbox)
    throw new Error("bbox is required");
  if (!Array.isArray(bbox))
    throw new Error("bbox must be an Array");
  if (bbox.length !== 4 && bbox.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  bbox.forEach(function(num) {
    if (!isNumber2(num))
      throw new Error("bbox must only contain numbers");
  });
}
function validateId(id) {
  if (!id)
    throw new Error("id is required");
  if (["string", "number"].indexOf(typeof id) === -1)
    throw new Error("id must be a number or a string");
}
var earthRadius2, factors2, unitsFactors2;
var init_main_es5 = __esm({
  "node_modules/@turf/rewind/node_modules/@turf/helpers/main.es.js"() {
    earthRadius2 = 63710088e-1;
    factors2 = {
      meters: earthRadius2,
      metres: earthRadius2,
      millimeters: earthRadius2 * 1e3,
      millimetres: earthRadius2 * 1e3,
      centimeters: earthRadius2 * 100,
      centimetres: earthRadius2 * 100,
      kilometers: earthRadius2 / 1e3,
      kilometres: earthRadius2 / 1e3,
      miles: earthRadius2 / 1609.344,
      nauticalmiles: earthRadius2 / 1852,
      inches: earthRadius2 * 39.37,
      yards: earthRadius2 / 1.0936,
      feet: earthRadius2 * 3.28084,
      radians: 1,
      degrees: earthRadius2 / 111325
    };
    unitsFactors2 = {
      meters: 1,
      metres: 1,
      millimeters: 1e3,
      millimetres: 1e3,
      centimeters: 100,
      centimetres: 100,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      miles: 1 / 1609.344,
      nauticalmiles: 1 / 1852,
      inches: 39.37,
      yards: 1 / 1.0936,
      feet: 3.28084,
      radians: 1 / earthRadius2,
      degrees: 1 / 111325
    };
  }
});

// node_modules/@turf/rewind/node_modules/@turf/meta/main.es.js
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false)
        break;
    }
  }
}
function geomEach(geojson, callback) {
  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
var init_main_es6 = __esm({
  "node_modules/@turf/rewind/node_modules/@turf/meta/main.es.js"() {
    init_main_es5();
  }
});

// node_modules/@turf/rewind/node_modules/@turf/invariant/main.es.js
function getCoords2(coords) {
  if (!coords)
    throw new Error("coords is required");
  if (coords.type === "Feature" && coords.geometry !== null)
    return coords.geometry.coordinates;
  if (coords.coordinates)
    return coords.coordinates;
  if (Array.isArray(coords))
    return coords;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
var init_main_es7 = __esm({
  "node_modules/@turf/rewind/node_modules/@turf/invariant/main.es.js"() {
    init_main_es5();
  }
});

// node_modules/@turf/rewind/main.es.js
var main_es_exports = {};
__export(main_es_exports, {
  default: () => main_es_default3
});
function rewind(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var reverse = options.reverse || false;
  var mutate = options.mutate || false;
  if (!geojson)
    throw new Error("<geojson> is required");
  if (typeof reverse !== "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof mutate !== "boolean")
    throw new Error("<mutate> must be a boolean");
  if (mutate === false)
    geojson = main_es_default(geojson);
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "FeatureCollection":
      featureEach(geojson, function(feature2) {
        featureEach(rewindFeature(feature2, reverse), function(result) {
          results.push(result);
        });
      });
      return featureCollection(results);
  }
  return rewindFeature(geojson, reverse);
}
function rewindFeature(geojson, reverse) {
  var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
  switch (type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        rewindFeature(geometry, reverse);
      });
      return geojson;
    case "LineString":
      rewindLineString(getCoords2(geojson), reverse);
      return geojson;
    case "Polygon":
      rewindPolygon(getCoords2(geojson), reverse);
      return geojson;
    case "MultiLineString":
      getCoords2(geojson).forEach(function(lineCoords) {
        rewindLineString(lineCoords, reverse);
      });
      return geojson;
    case "MultiPolygon":
      getCoords2(geojson).forEach(function(lineCoords) {
        rewindPolygon(lineCoords, reverse);
      });
      return geojson;
    case "Point":
    case "MultiPoint":
      return geojson;
  }
}
function rewindLineString(coords, reverse) {
  if (main_es_default2(coords) === reverse)
    coords.reverse();
}
function rewindPolygon(coords, reverse) {
  if (main_es_default2(coords[0]) !== reverse) {
    coords[0].reverse();
  }
  for (var i = 1; i < coords.length; i++) {
    if (main_es_default2(coords[i]) === reverse) {
      coords[i].reverse();
    }
  }
}
var main_es_default3;
var init_main_es8 = __esm({
  "node_modules/@turf/rewind/main.es.js"() {
    init_main_es();
    init_main_es4();
    init_main_es6();
    init_main_es7();
    init_main_es5();
    main_es_default3 = rewind;
  }
});

// node_modules/@turf/destination/dist/js/index.js
var require_js8 = __commonJS({
  "node_modules/@turf/destination/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function destination(origin, distance, bearing, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(origin);
      var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);
      var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);
      var bearingRad = helpers_1.degreesToRadians(bearing);
      var radians = helpers_1.lengthToRadians(distance, options.units);
      var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
      var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
      var lng = helpers_1.radiansToDegrees(longitude2);
      var lat = helpers_1.radiansToDegrees(latitude2);
      return helpers_1.point([lng, lat], options.properties);
    }
    exports.default = destination;
  }
});

// node_modules/@turf/bearing/dist/js/index.js
var require_js9 = __commonJS({
  "node_modules/@turf/bearing/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function bearing(start, end, options) {
      if (options === void 0) {
        options = {};
      }
      if (options.final === true) {
        return calculateFinalBearing(start, end);
      }
      var coordinates1 = invariant_1.getCoord(start);
      var coordinates2 = invariant_1.getCoord(end);
      var lon1 = helpers_1.degreesToRadians(coordinates1[0]);
      var lon2 = helpers_1.degreesToRadians(coordinates2[0]);
      var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
      var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
      var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
      var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
      return helpers_1.radiansToDegrees(Math.atan2(a, b));
    }
    exports.default = bearing;
    function calculateFinalBearing(start, end) {
      var bear = bearing(end, start);
      bear = (bear + 180) % 360;
      return bear;
    }
  }
});

// node_modules/@turf/distance/dist/js/index.js
var require_js10 = __commonJS({
  "node_modules/@turf/distance/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var invariant_1 = require_js4();
    var helpers_1 = require_js();
    function distance(from, to, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(from);
      var coordinates2 = invariant_1.getCoord(to);
      var dLat = helpers_1.degreesToRadians(coordinates2[1] - coordinates1[1]);
      var dLon = helpers_1.degreesToRadians(coordinates2[0] - coordinates1[0]);
      var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
      var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
      var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
      return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
    }
    exports.default = distance;
  }
});

// node_modules/@turf/rhumb-distance/dist/js/index.js
var require_js11 = __commonJS({
  "node_modules/@turf/rhumb-distance/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function rhumbDistance(from, to, options) {
      if (options === void 0) {
        options = {};
      }
      var origin = invariant_1.getCoord(from);
      var destination = invariant_1.getCoord(to);
      destination[0] += destination[0] - origin[0] > 180 ? -360 : origin[0] - destination[0] > 180 ? 360 : 0;
      var distanceInMeters = calculateRhumbDistance(origin, destination);
      var distance = helpers_1.convertLength(distanceInMeters, "meters", options.units);
      return distance;
    }
    function calculateRhumbDistance(origin, destination, radius) {
      radius = radius === void 0 ? helpers_1.earthRadius : Number(radius);
      var R = radius;
      var phi1 = origin[1] * Math.PI / 180;
      var phi2 = destination[1] * Math.PI / 180;
      var DeltaPhi = phi2 - phi1;
      var DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;
      if (DeltaLambda > Math.PI) {
        DeltaLambda -= 2 * Math.PI;
      }
      var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
      var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda);
      var dist = delta * R;
      return dist;
    }
    exports.default = rhumbDistance;
  }
});

// node_modules/@turf/point-to-line-distance/dist/js/index.js
var require_js12 = __commonJS({
  "node_modules/@turf/point-to-line-distance/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var distance_1 = __importDefault(require_js10());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    var rhumb_distance_1 = __importDefault(require_js11());
    function pointToLineDistance(pt, line, options) {
      if (options === void 0) {
        options = {};
      }
      if (!options.method) {
        options.method = "geodesic";
      }
      if (!options.units) {
        options.units = "kilometers";
      }
      if (!pt) {
        throw new Error("pt is required");
      }
      if (Array.isArray(pt)) {
        pt = helpers_1.point(pt);
      } else if (pt.type === "Point") {
        pt = helpers_1.feature(pt);
      } else {
        invariant_1.featureOf(pt, "Point", "point");
      }
      if (!line) {
        throw new Error("line is required");
      }
      if (Array.isArray(line)) {
        line = helpers_1.lineString(line);
      } else if (line.type === "LineString") {
        line = helpers_1.feature(line);
      } else {
        invariant_1.featureOf(line, "LineString", "line");
      }
      var distance = Infinity;
      var p = pt.geometry.coordinates;
      meta_1.segmentEach(line, function(segment) {
        var a = segment.geometry.coordinates[0];
        var b = segment.geometry.coordinates[1];
        var d = distanceToSegment(p, a, b, options);
        if (d < distance) {
          distance = d;
        }
      });
      return helpers_1.convertLength(distance, "degrees", options.units);
    }
    function distanceToSegment(p, a, b, options) {
      var v = [b[0] - a[0], b[1] - a[1]];
      var w = [p[0] - a[0], p[1] - a[1]];
      var c1 = dot(w, v);
      if (c1 <= 0) {
        return calcDistance(p, a, { method: options.method, units: "degrees" });
      }
      var c2 = dot(v, v);
      if (c2 <= c1) {
        return calcDistance(p, b, { method: options.method, units: "degrees" });
      }
      var b2 = c1 / c2;
      var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
      return calcDistance(p, Pb, { method: options.method, units: "degrees" });
    }
    function dot(u, v) {
      return u[0] * v[0] + u[1] * v[1];
    }
    function calcDistance(a, b, options) {
      return options.method === "planar" ? rhumb_distance_1.default(a, b, options) : distance_1.default(a, b, options);
    }
    exports.default = pointToLineDistance;
  }
});

// node_modules/viewport-mercator-project/module.js
var module_exports = {};
__export(module_exports, {
  MAX_LATITUDE: () => MAX_LATITUDE,
  WebMercatorViewport: () => WebMercatorViewport,
  addMetersToLngLat: () => addMetersToLngLat,
  altitudeToFovy: () => altitudeToFovy,
  default: () => WebMercatorViewport,
  fitBounds: () => fitBounds,
  flyToViewport: () => flyToViewport,
  fovyToAltitude: () => fovyToAltitude,
  getBounds: () => getBounds,
  getDistanceScales: () => getDistanceScales,
  getFlyToDuration: () => getFlyToDuration,
  getMeterZoom: () => getMeterZoom,
  getProjectionMatrix: () => getProjectionMatrix,
  getProjectionParameters: () => getProjectionParameters,
  getViewMatrix: () => getViewMatrix,
  lngLatToWorld: () => lngLatToWorld,
  normalizeViewportProps: () => normalizeViewportProps,
  pixelsToWorld: () => pixelsToWorld,
  scaleToZoom: () => scaleToZoom,
  unitsPerMeter: () => unitsPerMeter,
  worldToLngLat: () => worldToLngLat,
  worldToPixels: () => worldToPixels,
  zoomToScale: () => zoomToScale
});
var init_module = __esm({
  "node_modules/viewport-mercator-project/module.js"() {
    init_esm();
    init_esm();
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/utils.js
var require_utils = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toDeckColor = toDeckColor;
    exports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;
    exports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;
    exports.distance2d = distance2d;
    exports.mix = mix;
    exports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;
    exports.nearestPointOnLine = nearestPointOnLine;
    exports.getPickedEditHandle = getPickedEditHandle;
    exports.getPickedSnapSourceEditHandle = getPickedSnapSourceEditHandle;
    exports.getNonGuidePicks = getNonGuidePicks;
    exports.getPickedExistingEditHandle = getPickedExistingEditHandle;
    exports.getPickedIntermediateEditHandle = getPickedIntermediateEditHandle;
    exports.getPickedEditHandles = getPickedEditHandles;
    exports.getEditHandlesForGeometry = getEditHandlesForGeometry;
    exports.updateRectanglePosition = updateRectanglePosition;
    exports.mapCoords = mapCoords;
    var _destination = _interopRequireDefault(require_js8());
    var _bearing = _interopRequireDefault(require_js9());
    var _pointToLineDistance = _interopRequireDefault(require_js12());
    var _meta = require_js2();
    var _helpers = require_js();
    var _invariant = require_js4();
    var _viewportMercatorProject = _interopRequireDefault((init_module(), __toCommonJS(module_exports)));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function toDeckColor(color) {
      var defaultColor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [255, 0, 0, 255];
      if (!Array.isArray(color)) {
        return defaultColor;
      }
      return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];
    }
    function recursivelyTraverseNestedArrays(array, prefix, fn) {
      if (!Array.isArray(array[0])) {
        return true;
      }
      for (var i = 0; i < array.length; i++) {
        if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {
          fn(array, prefix);
          break;
        }
      }
      return false;
    }
    function generatePointsParallelToLinePoints(p1, p2, mapCoords2) {
      var lineString2 = {
        type: "LineString",
        coordinates: [p1, p2]
      };
      var pt = (0, _helpers.point)(mapCoords2);
      var ddistance = (0, _pointToLineDistance["default"])(pt, lineString2);
      var lineBearing = (0, _bearing["default"])(p1, p2);
      var isPointToLeftOfLine = (mapCoords2[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords2[1] - p1[1]) * (p2[0] - p1[0]);
      var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;
      var p3 = (0, _destination["default"])(p2, ddistance, orthogonalBearing);
      var p4 = (0, _destination["default"])(p1, ddistance, orthogonalBearing);
      return [p3.geometry.coordinates, p4.geometry.coordinates];
    }
    function distance2d(x1, y1, x2, y2) {
      var dx = x1 - x2;
      var dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function mix(a, b, ratio) {
      return b * ratio + a * (1 - ratio);
    }
    function nearestPointOnProjectedLine(line, inPoint, viewport) {
      var wmViewport = new _viewportMercatorProject["default"](viewport);
      var coordinates = line.geometry.coordinates;
      var projectedCoords = coordinates.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 3), x3 = _ref2[0], y3 = _ref2[1], _ref2$ = _ref2[2], z = _ref2$ === void 0 ? 0 : _ref2$;
        return wmViewport.project([x3, y3, z]);
      });
      var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates), _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2), x = _wmViewport$project2[0], y = _wmViewport$project2[1];
      var minDistance = Infinity;
      var minPointInfo = {};
      projectedCoords.forEach(function(_ref3, index2) {
        var _ref4 = _slicedToArray(_ref3, 2), x22 = _ref4[0], y22 = _ref4[1];
        if (index2 === 0) {
          return;
        }
        var _projectedCoords = _slicedToArray(projectedCoords[index2 - 1], 2), x12 = _projectedCoords[0], y12 = _projectedCoords[1];
        var A = y12 - y22;
        var B = x22 - x12;
        var C = x12 * y22 - x22 * y12;
        var div = A * A + B * B;
        var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);
        if (distance < minDistance) {
          minDistance = distance;
          minPointInfo = {
            index: index2,
            x0: (B * (B * x - A * y) - A * C) / div,
            y0: (A * (-B * x + A * y) - B * C) / div
          };
        }
      });
      var _minPointInfo = minPointInfo, index = _minPointInfo.index, x0 = _minPointInfo.x0, y0 = _minPointInfo.y0;
      var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3), x1 = _projectedCoords2[0], y1 = _projectedCoords2[1], _projectedCoords2$ = _projectedCoords2[2], z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;
      var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3), x2 = _projectedCoords$inde[0], y2 = _projectedCoords$inde[1], _projectedCoords$inde2 = _projectedCoords$inde[2], z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2;
      var lineLength = distance2d(x1, y1, x2, y2);
      var startToPointLength = distance2d(x1, y1, x0, y0);
      var ratio = startToPointLength / lineLength;
      var z0 = mix(z1, z2, ratio);
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: wmViewport.unproject([x0, y0, z0])
        },
        properties: {
          // TODO: calculate the distance in proper units
          dist: minDistance,
          index: index - 1
        }
      };
    }
    function nearestPointOnLine(lines, inPoint, viewport) {
      var _lines$geometry, _lines$geometry2;
      var mercator;
      if (viewport) {
        mercator = new _viewportMercatorProject["default"](viewport);
      }
      var closestPoint = (0, _helpers.point)([Infinity, Infinity], {
        dist: Infinity
      });
      if (!((_lines$geometry = lines.geometry) === null || _lines$geometry === void 0 ? void 0 : _lines$geometry.coordinates.length) || ((_lines$geometry2 = lines.geometry) === null || _lines$geometry2 === void 0 ? void 0 : _lines$geometry2.coordinates.length) < 2) {
        return closestPoint;
      }
      (0, _meta.flattenEach)(lines, function(line) {
        var coords = (0, _invariant.getCoords)(line);
        var pointCoords = (0, _invariant.getCoords)(inPoint);
        var minDist;
        var to;
        var from;
        var x;
        var y;
        var segmentIdx;
        var dist;
        if (coords.length > 1 && pointCoords.length) {
          var lineCoordinates;
          var pointCoordinate;
          if (mercator) {
            lineCoordinates = coords.map(function(lineCoordinate) {
              return mercator.project(lineCoordinate);
            });
            pointCoordinate = mercator.project(pointCoords);
          } else {
            lineCoordinates = coords;
            pointCoordinate = pointCoords;
          }
          for (var n = 1; n < lineCoordinates.length; n++) {
            if (lineCoordinates[n][0] !== lineCoordinates[n - 1][0]) {
              var slope = (lineCoordinates[n][1] - lineCoordinates[n - 1][1]) / (lineCoordinates[n][0] - lineCoordinates[n - 1][0]);
              var inverseSlope = lineCoordinates[n][1] - slope * lineCoordinates[n][0];
              dist = Math.abs(slope * pointCoordinate[0] + inverseSlope - pointCoordinate[1]) / Math.sqrt(slope * slope + 1);
            } else
              dist = Math.abs(pointCoordinate[0] - lineCoordinates[n][0]);
            var rl2 = Math.pow(lineCoordinates[n][1] - lineCoordinates[n - 1][1], 2) + Math.pow(lineCoordinates[n][0] - lineCoordinates[n - 1][0], 2);
            var ln2 = Math.pow(lineCoordinates[n][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n][0] - pointCoordinate[0], 2);
            var lnm12 = Math.pow(lineCoordinates[n - 1][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n - 1][0] - pointCoordinate[0], 2);
            var dist2 = Math.pow(dist, 2);
            var calcrl2 = ln2 - dist2 + lnm12 - dist2;
            if (calcrl2 > rl2) {
              dist = Math.sqrt(Math.min(ln2, lnm12));
            }
            if (minDist === null || minDist === void 0 || minDist > dist) {
              if (calcrl2 > rl2) {
                if (lnm12 < ln2) {
                  to = 0;
                  from = 1;
                } else {
                  from = 0;
                  to = 1;
                }
              } else {
                to = Math.sqrt(lnm12 - dist2) / Math.sqrt(rl2);
                from = Math.sqrt(ln2 - dist2) / Math.sqrt(rl2);
              }
              minDist = dist;
              segmentIdx = n;
            }
          }
          var dx = lineCoordinates[segmentIdx - 1][0] - lineCoordinates[segmentIdx][0];
          var dy = lineCoordinates[segmentIdx - 1][1] - lineCoordinates[segmentIdx][1];
          x = lineCoordinates[segmentIdx - 1][0] - dx * to;
          y = lineCoordinates[segmentIdx - 1][1] - dy * to;
        }
        var snapPoint = {
          x,
          y,
          idx: segmentIdx - 1,
          to,
          from
        };
        if (mercator) {
          var pixelToLatLong = mercator.unproject([snapPoint.x, snapPoint.y]);
          snapPoint = {
            x: pixelToLatLong[0],
            y: pixelToLatLong[1],
            idx: segmentIdx - 1,
            to,
            from
          };
        }
        closestPoint = (0, _helpers.point)([snapPoint.x, snapPoint.y], {
          dist: Math.abs(snapPoint.from - snapPoint.to),
          index: snapPoint.idx
        });
      });
      return closestPoint;
    }
    function getPickedEditHandle(picks) {
      var handles = getPickedEditHandles(picks);
      return handles.length ? handles[0] : null;
    }
    function getPickedSnapSourceEditHandle(picks) {
      var handles = getPickedEditHandles(picks);
      return handles.find(function(handle) {
        return handle.properties.editHandleType === "snap-source";
      });
    }
    function getNonGuidePicks(picks) {
      return picks && picks.filter(function(pick) {
        return !pick.isGuide;
      });
    }
    function getPickedExistingEditHandle(picks) {
      var handles = getPickedEditHandles(picks);
      return handles.find(function(_ref5) {
        var properties = _ref5.properties;
        return properties.featureIndex >= 0 && properties.editHandleType === "existing";
      });
    }
    function getPickedIntermediateEditHandle(picks) {
      var handles = getPickedEditHandles(picks);
      return handles.find(function(_ref6) {
        var properties = _ref6.properties;
        return properties.featureIndex >= 0 && properties.editHandleType === "intermediate";
      });
    }
    function getPickedEditHandles(picks) {
      var handles = picks && picks.filter(function(pick) {
        return pick.isGuide && pick.object.properties.guideType === "editHandle";
      }).map(function(pick) {
        return pick.object;
      }) || [];
      return handles;
    }
    function getEditHandlesForGeometry(geometry, featureIndex) {
      var editHandleType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "existing";
      var handles = [];
      switch (geometry.type) {
        case "Point":
          handles = [{
            type: "Feature",
            properties: {
              guideType: "editHandle",
              editHandleType,
              positionIndexes: [],
              featureIndex
            },
            geometry: {
              type: "Point",
              coordinates: geometry.coordinates
            }
          }];
          break;
        case "MultiPoint":
        case "LineString":
          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));
          break;
        case "Polygon":
        case "MultiLineString":
          for (var a = 0; a < geometry.coordinates.length; a++) {
            handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));
            if (geometry.type === "Polygon") {
              handles = handles.slice(0, -1);
            }
          }
          break;
        case "MultiPolygon":
          for (var _a = 0; _a < geometry.coordinates.length; _a++) {
            for (var b = 0; b < geometry.coordinates[_a].length; b++) {
              handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType));
              handles = handles.slice(0, -1);
            }
          }
          break;
        default:
          throw Error("Unhandled geometry type: ".concat(geometry.type));
      }
      return handles;
    }
    function getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {
      var editHandleType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "existing";
      var editHandles = [];
      for (var i = 0; i < coordinates.length; i++) {
        var position = coordinates[i];
        editHandles.push({
          type: "Feature",
          properties: {
            guideType: "editHandle",
            positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [i]),
            featureIndex,
            editHandleType
          },
          geometry: {
            type: "Point",
            coordinates: position
          }
        });
      }
      return editHandles;
    }
    function updateRectanglePosition(feature2, editHandleIndex, mapCoords2) {
      var coordinates = feature2.geometry.coordinates;
      if (!coordinates) {
        return null;
      }
      var points = coordinates[0].slice(0, 4);
      points[editHandleIndex % 4] = mapCoords2;
      var p0 = points[(editHandleIndex + 2) % 4];
      var p2 = points[editHandleIndex % 4];
      points[(editHandleIndex + 1) % 4] = [p2[0], p0[1]];
      points[(editHandleIndex + 3) % 4] = [p0[0], p2[1]];
      return [[].concat(_toConsumableArray(points), [points[0]])];
    }
    function mapCoords(coords, callback) {
      if (typeof coords[0] === "number") {
        if (!isNaN(coords[0]) && isFinite(coords[0])) {
          return callback(coords);
        }
        return coords;
      }
      return coords.map(function(coord) {
        return mapCoords(coord, callback);
      }).filter(Boolean);
    }
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/immutable-feature-collection.js
var require_immutable_feature_collection = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/immutable-feature-collection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ImmutableFeatureCollection = void 0;
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ImmutableFeatureCollection = function() {
      function ImmutableFeatureCollection2(featureCollection2) {
        _classCallCheck(this, ImmutableFeatureCollection2);
        _defineProperty(this, "featureCollection", void 0);
        this.featureCollection = featureCollection2;
      }
      _createClass(ImmutableFeatureCollection2, [{
        key: "getObject",
        value: function getObject() {
          return this.featureCollection;
        }
        /**
         * Replaces the position deeply nested withing the given feature's geometry.
         * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.
         *
         * @param featureIndex The index of the feature to update
         * @param positionIndexes An array containing the indexes of the position to replace
         * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])
         *
         * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.
         */
      }, {
        key: "replacePosition",
        value: function replacePosition(featureIndex, positionIndexes, updatedPosition) {
          var geometry = this.featureCollection.features[featureIndex].geometry;
          var isPolygonal = geometry.type === "Polygon" || geometry.type === "MultiPolygon";
          var updatedGeometry = _objectSpread({}, geometry, {
            coordinates: immutablyReplacePosition(geometry.coordinates, positionIndexes, updatedPosition, isPolygonal)
          });
          return this.replaceGeometry(featureIndex, updatedGeometry);
        }
        /**
         * Removes a position deeply nested in a GeoJSON geometry coordinates array.
         * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.
         *
         * @param featureIndex The index of the feature to update
         * @param positionIndexes An array containing the indexes of the postion to remove
         *
         * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.
         */
      }, {
        key: "removePosition",
        value: function removePosition(featureIndex, positionIndexes) {
          var geometry = this.featureCollection.features[featureIndex].geometry;
          if (geometry.type === "Point") {
            throw Error("Can't remove a position from a Point or there'd be nothing left");
          }
          if (geometry.type === "MultiPoint" && // only 1 point left
          geometry.coordinates.length < 2) {
            throw Error("Can't remove the last point of a MultiPoint or there'd be nothing left");
          }
          if (geometry.type === "LineString" && // only 2 positions
          geometry.coordinates.length < 3) {
            throw Error("Can't remove position. LineString must have at least two positions");
          }
          if (geometry.type === "Polygon" && // outer ring is a triangle
          geometry.coordinates[0].length < 5 && Array.isArray(positionIndexes) && // trying to remove from outer ring
          positionIndexes[0] === 0) {
            throw Error("Can't remove position. Polygon's outer ring must have at least four positions");
          }
          if (geometry.type === "MultiLineString" && // only 1 LineString left
          geometry.coordinates.length === 1 && // only 2 positions
          geometry.coordinates[0].length < 3) {
            throw Error("Can't remove position. MultiLineString must have at least two positions");
          }
          if (geometry.type === "MultiPolygon" && // only 1 polygon left
          geometry.coordinates.length === 1 && // outer ring is a triangle
          geometry.coordinates[0][0].length < 5 && Array.isArray(positionIndexes) && // trying to remove from first polygon
          positionIndexes[0] === 0 && // trying to remove from outer ring
          positionIndexes[1] === 0) {
            throw Error("Can't remove position. MultiPolygon's outer ring must have at least four positions");
          }
          var isPolygonal = geometry.type === "Polygon" || geometry.type === "MultiPolygon";
          var updatedGeometry = _objectSpread({}, geometry, {
            coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)
          });
          pruneGeometryIfNecessary(updatedGeometry);
          return this.replaceGeometry(featureIndex, updatedGeometry);
        }
        /**
         * Adds a position deeply nested in a GeoJSON geometry coordinates array.
         * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.
         *
         * @param featureIndex The index of the feature to update
         * @param positionIndexes An array containing the indexes of the position that will proceed the new position
         * @param positionToAdd The new position to place in the result (i.e. [lng, lat])
         *
         * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.
         */
      }, {
        key: "addPosition",
        value: function addPosition(featureIndex, positionIndexes, positionToAdd) {
          var geometry = this.featureCollection.features[featureIndex].geometry;
          if (geometry.type === "Point") {
            throw new Error("Unable to add a position to a Point feature");
          }
          var isPolygonal = geometry.type === "Polygon" || geometry.type === "MultiPolygon";
          var updatedGeometry = _objectSpread({}, geometry, {
            coordinates: immutablyAddPosition(geometry.coordinates, positionIndexes, positionToAdd, isPolygonal)
          });
          return this.replaceGeometry(featureIndex, updatedGeometry);
        }
      }, {
        key: "replaceGeometry",
        value: function replaceGeometry(featureIndex, geometry) {
          var updatedFeature = _objectSpread({}, this.featureCollection.features[featureIndex], {
            geometry
          });
          var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {
            features: [].concat(_toConsumableArray(this.featureCollection.features.slice(0, featureIndex)), [updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))
          });
          return new ImmutableFeatureCollection2(updatedFeatureCollection);
        }
      }, {
        key: "addFeature",
        value: function addFeature(feature2) {
          return this.addFeatures([feature2]);
        }
      }, {
        key: "addFeatures",
        value: function addFeatures(features) {
          var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {
            features: [].concat(_toConsumableArray(this.featureCollection.features), _toConsumableArray(features))
          });
          return new ImmutableFeatureCollection2(updatedFeatureCollection);
        }
      }, {
        key: "deleteFeature",
        value: function deleteFeature(featureIndex) {
          return this.deleteFeatures([featureIndex]);
        }
      }, {
        key: "deleteFeatures",
        value: function deleteFeatures(featureIndexes) {
          var features = _toConsumableArray(this.featureCollection.features);
          featureIndexes.sort();
          for (var i = featureIndexes.length - 1; i >= 0; i--) {
            var featureIndex = featureIndexes[i];
            if (featureIndex >= 0 && featureIndex < features.length) {
              features.splice(featureIndex, 1);
            }
          }
          var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {
            features
          });
          return new ImmutableFeatureCollection2(updatedFeatureCollection);
        }
      }]);
      return ImmutableFeatureCollection2;
    }();
    exports.ImmutableFeatureCollection = ImmutableFeatureCollection;
    function getUpdatedPosition(updatedPosition, previousPosition) {
      if (updatedPosition.length === 2 && previousPosition.length === 3) {
        var elevation = previousPosition[2];
        return [updatedPosition[0], updatedPosition[1], elevation];
      }
      return updatedPosition;
    }
    function immutablyReplacePosition(coordinates, positionIndexes, updatedPosition, isPolygonal) {
      if (!positionIndexes) {
        return coordinates;
      }
      if (positionIndexes.length === 0) {
        return getUpdatedPosition(updatedPosition, coordinates);
      }
      if (positionIndexes.length === 1) {
        var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]])], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
        if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {
          updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);
          updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);
        }
        return updated;
      }
      return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyReplacePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), updatedPosition, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
    }
    function immutablyRemovePosition(coordinates, positionIndexes, isPolygonal) {
      if (!positionIndexes) {
        return coordinates;
      }
      if (positionIndexes.length === 0) {
        throw Error("Must specify the index of the position to remove");
      }
      if (positionIndexes.length === 1) {
        var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
        if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {
          if (positionIndexes[0] === 0) {
            updated[updated.length - 1] = updated[0];
          } else if (positionIndexes[0] === coordinates.length - 1) {
            updated[0] = updated[updated.length - 1];
          }
        }
        return updated;
      }
      return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyRemovePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
    }
    function immutablyAddPosition(coordinates, positionIndexes, positionToAdd, isPolygonal) {
      if (!positionIndexes) {
        return coordinates;
      }
      if (positionIndexes.length === 0) {
        throw Error("Must specify the index of the position to remove");
      }
      if (positionIndexes.length === 1) {
        var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [positionToAdd], _toConsumableArray(coordinates.slice(positionIndexes[0])));
        return updated;
      }
      return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyAddPosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), positionToAdd, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));
    }
    function pruneGeometryIfNecessary(geometry) {
      switch (geometry.type) {
        case "Polygon":
          prunePolygonIfNecessary(geometry);
          break;
        case "MultiLineString":
          pruneMultiLineStringIfNecessary(geometry);
          break;
        case "MultiPolygon":
          pruneMultiPolygonIfNecessary(geometry);
          break;
        default:
          break;
      }
    }
    function prunePolygonIfNecessary(geometry) {
      var polygon = geometry.coordinates;
      for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {
        if (removeHoleIfNecessary(polygon, holeIndex)) {
          holeIndex--;
        }
      }
    }
    function pruneMultiLineStringIfNecessary(geometry) {
      for (var lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {
        var lineString2 = geometry.coordinates[lineStringIndex];
        if (lineString2.length === 1) {
          geometry.coordinates.splice(lineStringIndex, 1);
          lineStringIndex--;
        }
      }
    }
    function pruneMultiPolygonIfNecessary(geometry) {
      for (var polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {
        var polygon = geometry.coordinates[polygonIndex];
        var outerRing = polygon[0];
        if (outerRing.length <= 3) {
          geometry.coordinates.splice(polygonIndex, 1);
          polygonIndex--;
        }
        for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {
          if (removeHoleIfNecessary(polygon, holeIndex)) {
            holeIndex--;
          }
        }
      }
    }
    function removeHoleIfNecessary(polygon, holeIndex) {
      var hole = polygon[holeIndex];
      if (hole.length <= 3) {
        polygon.splice(holeIndex, 1);
        return true;
      }
      return false;
    }
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/geojson-edit-mode.js
var require_geojson_edit_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/geojson-edit-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getIntermediatePosition = getIntermediatePosition;
    exports.GeoJsonEditMode = void 0;
    var _union = _interopRequireDefault(require_js5());
    var _difference = _interopRequireDefault(require_js6());
    var _intersect = _interopRequireDefault(require_js7());
    var _rewind = _interopRequireDefault((init_main_es8(), __toCommonJS(main_es_exports)));
    var _utils = require_utils();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DEFAULT_GUIDES = {
      type: "FeatureCollection",
      features: []
    };
    var DEFAULT_TOOLTIPS = [];
    var GeoJsonEditMode = function() {
      function GeoJsonEditMode2() {
        _classCallCheck(this, GeoJsonEditMode2);
        _defineProperty(this, "_clickSequence", []);
      }
      _createClass(GeoJsonEditMode2, [{
        key: "getGuides",
        value: function getGuides(props) {
          return DEFAULT_GUIDES;
        }
      }, {
        key: "getTooltips",
        value: function getTooltips(props) {
          return DEFAULT_TOOLTIPS;
        }
      }, {
        key: "getSelectedFeature",
        value: function getSelectedFeature(props) {
          if (props.selectedIndexes.length === 1) {
            return props.data.features[props.selectedIndexes[0]];
          }
          return null;
        }
      }, {
        key: "getSelectedGeometry",
        value: function getSelectedGeometry(props) {
          var feature2 = this.getSelectedFeature(props);
          if (feature2) {
            return feature2.geometry;
          }
          return null;
        }
      }, {
        key: "getSelectedFeaturesAsFeatureCollection",
        value: function getSelectedFeaturesAsFeatureCollection(props) {
          var features = props.data.features;
          var selectedFeatures = props.selectedIndexes.map(function(selectedIndex) {
            return features[selectedIndex];
          });
          return {
            type: "FeatureCollection",
            features: selectedFeatures
          };
        }
      }, {
        key: "getClickSequence",
        value: function getClickSequence() {
          return this._clickSequence;
        }
      }, {
        key: "addClickSequence",
        value: function addClickSequence(_ref) {
          var mapCoords = _ref.mapCoords;
          this._clickSequence.push(mapCoords);
        }
      }, {
        key: "resetClickSequence",
        value: function resetClickSequence() {
          this._clickSequence = [];
        }
      }, {
        key: "getTentativeGuide",
        value: function getTentativeGuide(props) {
          var guides = this.getGuides(props);
          return guides.features.find(function(f) {
            return f.properties && f.properties.guideType === "tentative";
          });
        }
      }, {
        key: "isSelectionPicked",
        value: function isSelectionPicked(picks, props) {
          if (!picks.length)
            return false;
          var pickedFeatures = (0, _utils.getNonGuidePicks)(picks).map(function(_ref2) {
            var index = _ref2.index;
            return index;
          });
          var pickedHandles = (0, _utils.getPickedEditHandles)(picks).map(function(_ref3) {
            var properties = _ref3.properties;
            return properties.featureIndex;
          });
          var pickedIndexes = new Set([].concat(_toConsumableArray(pickedFeatures), _toConsumableArray(pickedHandles)));
          return props.selectedIndexes.some(function(index) {
            return pickedIndexes.has(index);
          });
        }
      }, {
        key: "rewindPolygon",
        value: function rewindPolygon2(feature2) {
          var geometry = feature2.geometry;
          var isPolygonal = geometry.type === "Polygon" || geometry.type === "MultiPolygon";
          if (isPolygonal) {
            return (0, _rewind["default"])(feature2);
          }
          return feature2;
        }
      }, {
        key: "getAddFeatureAction",
        value: function getAddFeatureAction(featureOrGeometry, features) {
          var featureOrGeometryAsAny = featureOrGeometry;
          var feature2 = featureOrGeometryAsAny.type === "Feature" ? featureOrGeometryAsAny : {
            type: "Feature",
            properties: {},
            geometry: featureOrGeometryAsAny
          };
          var rewindFeature2 = this.rewindPolygon(feature2);
          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features).addFeature(rewindFeature2).getObject();
          return {
            updatedData,
            editType: "addFeature",
            editContext: {
              featureIndexes: [updatedData.features.length - 1]
            }
          };
        }
      }, {
        key: "getAddManyFeaturesAction",
        value: function getAddManyFeaturesAction(_ref4, features) {
          var featuresToAdd = _ref4.features;
          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features);
          var initialIndex = updatedData.getObject().features.length;
          var updatedIndexes = [];
          var _iterator = _createForOfIteratorHelper(featuresToAdd), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var feature2 = _step.value;
              var properties = feature2.properties, geometry = feature2.geometry;
              var geometryAsAny = geometry;
              updatedData = updatedData.addFeature({
                type: "Feature",
                properties,
                geometry: geometryAsAny
              });
              updatedIndexes.push(initialIndex + updatedIndexes.length);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return {
            updatedData: updatedData.getObject(),
            editType: "addFeature",
            editContext: {
              featureIndexes: updatedIndexes
            }
          };
        }
      }, {
        key: "getAddFeatureOrBooleanPolygonAction",
        value: function getAddFeatureOrBooleanPolygonAction(featureOrGeometry, props) {
          var featureOrGeometryAsAny = featureOrGeometry;
          var selectedFeature = this.getSelectedFeature(props);
          var modeConfig = props.modeConfig;
          if (modeConfig && modeConfig.booleanOperation) {
            if (!selectedFeature || selectedFeature.geometry.type !== "Polygon" && selectedFeature.geometry.type !== "MultiPolygon") {
              console.warn("booleanOperation only supported for single Polygon or MultiPolygon selection");
              return null;
            }
            var feature2 = featureOrGeometryAsAny.type === "Feature" ? featureOrGeometryAsAny : {
              type: "Feature",
              geometry: featureOrGeometryAsAny
            };
            var updatedGeometry;
            if (modeConfig.booleanOperation === "union") {
              updatedGeometry = (0, _union["default"])(selectedFeature, feature2);
            } else if (modeConfig.booleanOperation === "difference") {
              updatedGeometry = (0, _difference["default"])(selectedFeature, feature2);
            } else if (modeConfig.booleanOperation === "intersection") {
              updatedGeometry = (0, _intersect["default"])(selectedFeature, feature2);
            } else {
              console.warn("Invalid booleanOperation ".concat(modeConfig.booleanOperation));
              return null;
            }
            if (!updatedGeometry) {
              console.warn("Canceling edit. Boolean operation erased entire polygon.");
              return null;
            }
            var featureIndex = props.selectedIndexes[0];
            var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, updatedGeometry.geometry).getObject();
            var editAction = {
              updatedData,
              editType: "unionGeometry",
              editContext: {
                featureIndexes: [featureIndex]
              }
            };
            return editAction;
          }
          return this.getAddFeatureAction(featureOrGeometry, props.data);
        }
      }, {
        key: "createTentativeFeature",
        value: function createTentativeFeature(props) {
          return null;
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          var tentativeFeature = this.createTentativeFeature(props);
          if (tentativeFeature) {
            props.onEdit({
              updatedData: props.data,
              editType: "updateTentativeFeature",
              editContext: {
                feature: tentativeFeature
              }
            });
          }
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
        }
      }, {
        key: "handleKeyUp",
        value: function handleKeyUp(event, props) {
          if (event.key === "Escape") {
            this.resetClickSequence();
            props.onEdit({
              // Because the new drawing feature is dropped, so the data will keep as the same.
              updatedData: props.data,
              editType: "cancelFeature",
              editContext: {}
            });
          }
        }
      }]);
      return GeoJsonEditMode2;
    }();
    exports.GeoJsonEditMode = GeoJsonEditMode;
    function getIntermediatePosition(position1, position2) {
      var intermediatePosition = [(position1[0] + position2[0]) / 2, (position1[1] + position2[1]) / 2];
      return intermediatePosition;
    }
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/modify-mode.js
var require_modify_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/modify-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ModifyMode = void 0;
    var _helpers = require_js();
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ModifyMode = function(_GeoJsonEditMode) {
      _inherits(ModifyMode2, _GeoJsonEditMode);
      var _super = _createSuper(ModifyMode2);
      function ModifyMode2() {
        _classCallCheck(this, ModifyMode2);
        return _super.apply(this, arguments);
      }
      _createClass(ModifyMode2, [{
        key: "getGuides",
        value: function getGuides(props) {
          var _this = this;
          var handles = [];
          var data = props.data, lastPointerMoveEvent = props.lastPointerMoveEvent;
          var features = data.features;
          var picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;
          var mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;
          var _iterator = _createForOfIteratorHelper(props.selectedIndexes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _index = _step.value;
              if (_index < features.length) {
                var geometry = features[_index].geometry;
                handles.push.apply(handles, _toConsumableArray((0, _utils.getEditHandlesForGeometry)(geometry, _index)));
              } else {
                console.warn("selectedFeatureIndexes out of range ".concat(_index));
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (picks && picks.length && mapCoords) {
            var _props$modeConfig;
            var existingEditHandle = (0, _utils.getPickedExistingEditHandle)(picks);
            var featureAsPick = !existingEditHandle && picks.find(function(pick) {
              return !pick.isGuide;
            });
            if (featureAsPick && !featureAsPick.object.geometry.type.includes("Point") && !(((_props$modeConfig = props.modeConfig) === null || _props$modeConfig === void 0 ? void 0 : _props$modeConfig.lockRectangles) && featureAsPick.object.properties.shape === "Rectangle") && props.selectedIndexes.includes(featureAsPick.index)) {
              var intermediatePoint = null;
              var positionIndexPrefix = [];
              var referencePoint = (0, _helpers.point)(mapCoords);
              (0, _utils.recursivelyTraverseNestedArrays)(featureAsPick.object.geometry.coordinates, [], function(lineString2, prefix) {
                var lineStringFeature = (0, _helpers.lineString)(lineString2);
                var candidateIntermediatePoint = _this.getNearestPoint(
                  // @ts-ignore
                  lineStringFeature,
                  referencePoint,
                  props.modeConfig && props.modeConfig.viewport
                );
                if (!intermediatePoint || candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist) {
                  intermediatePoint = candidateIntermediatePoint;
                  positionIndexPrefix = prefix;
                }
              });
              if (intermediatePoint) {
                var _intermediatePoint = intermediatePoint, position = _intermediatePoint.geometry.coordinates, index = _intermediatePoint.properties.index;
                handles.push({
                  type: "Feature",
                  properties: {
                    guideType: "editHandle",
                    editHandleType: "intermediate",
                    featureIndex: featureAsPick.index,
                    positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [index + 1])
                  },
                  geometry: {
                    type: "Point",
                    coordinates: position
                  }
                });
              }
            }
          }
          return {
            type: "FeatureCollection",
            features: handles
          };
        }
        // turf.js does not support elevation for nearestPointOnLine
      }, {
        key: "getNearestPoint",
        value: function getNearestPoint(line, inPoint, viewport) {
          var coordinates = line.geometry.coordinates;
          if (coordinates.some(function(coord) {
            return coord.length > 2;
          })) {
            if (viewport) {
              return (0, _utils.nearestPointOnProjectedLine)(line, inPoint, viewport);
            }
            console.log("Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.");
          }
          return (0, _utils.nearestPointOnLine)(line, inPoint, viewport);
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
          var pickedExistingHandle = (0, _utils.getPickedExistingEditHandle)(event.picks);
          var pickedIntermediateHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);
          if (pickedExistingHandle) {
            var _pickedExistingHandle = pickedExistingHandle.properties, featureIndex = _pickedExistingHandle.featureIndex, positionIndexes = _pickedExistingHandle.positionIndexes;
            var updatedData;
            try {
              updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).removePosition(featureIndex, positionIndexes).getObject();
            } catch (ignored) {
            }
            if (updatedData) {
              props.onEdit({
                updatedData,
                editType: "removePosition",
                editContext: {
                  featureIndexes: [featureIndex],
                  positionIndexes,
                  position: pickedExistingHandle.geometry.coordinates
                }
              });
            }
          } else if (pickedIntermediateHandle) {
            var _props$modeConfig2;
            var _pickedIntermediateHa = pickedIntermediateHandle.properties, _featureIndex = _pickedIntermediateHa.featureIndex, _positionIndexes = _pickedIntermediateHa.positionIndexes;
            var feature2 = props.data.features[_featureIndex];
            var canAddPosition = !(((_props$modeConfig2 = props.modeConfig) === null || _props$modeConfig2 === void 0 ? void 0 : _props$modeConfig2.lockRectangles) && (feature2 === null || feature2 === void 0 ? void 0 : feature2.properties.shape) === "Rectangle");
            if (canAddPosition) {
              var _updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(_featureIndex, _positionIndexes, pickedIntermediateHandle.geometry.coordinates).getObject();
              if (_updatedData) {
                props.onEdit({
                  updatedData: _updatedData,
                  editType: "addPosition",
                  editContext: {
                    featureIndexes: [_featureIndex],
                    positionIndexes: _positionIndexes,
                    position: pickedIntermediateHandle.geometry.coordinates
                  }
                });
              }
            }
          }
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
          var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);
          if (editHandle) {
            event.cancelPan();
            this._dragEditHandle("movePosition", props, editHandle, event);
          }
        }
      }, {
        key: "_dragEditHandle",
        value: function _dragEditHandle(editType, props, editHandle, event) {
          var _props$modeConfig3;
          var editHandleProperties = editHandle.properties;
          var editedFeature = props.data.features[editHandleProperties.featureIndex];
          var updatedData;
          if (((_props$modeConfig3 = props.modeConfig) === null || _props$modeConfig3 === void 0 ? void 0 : _props$modeConfig3.lockRectangles) && editedFeature.properties.shape === "Rectangle") {
            var coordinates = (0, _utils.updateRectanglePosition)(editedFeature, editHandleProperties.positionIndexes[1], event.mapCoords);
            updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(editHandleProperties.featureIndex, {
              coordinates,
              type: "Polygon"
            }).getObject();
          } else {
            updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(editHandleProperties.featureIndex, editHandleProperties.positionIndexes, event.mapCoords).getObject();
          }
          props.onEdit({
            updatedData,
            editType,
            editContext: {
              featureIndexes: [editHandleProperties.featureIndex],
              positionIndexes: editHandleProperties.positionIndexes,
              position: event.mapCoords
            }
          });
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          var cursor = this.getCursor(event);
          props.onUpdateCursor(cursor);
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          var selectedFeatureIndexes = props.selectedIndexes;
          var editHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);
          if (selectedFeatureIndexes.length && editHandle) {
            var editHandleProperties = editHandle.properties;
            var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(editHandleProperties.featureIndex, editHandleProperties.positionIndexes, event.mapCoords).getObject();
            props.onEdit({
              updatedData,
              editType: "addPosition",
              editContext: {
                featureIndexes: [editHandleProperties.featureIndex],
                positionIndexes: editHandleProperties.positionIndexes,
                position: event.mapCoords
              }
            });
          }
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          var selectedFeatureIndexes = props.selectedIndexes;
          var editHandle = (0, _utils.getPickedEditHandle)(event.picks);
          if (selectedFeatureIndexes.length && editHandle) {
            this._dragEditHandle("finishMovePosition", props, editHandle, event);
          }
        }
      }, {
        key: "getCursor",
        value: function getCursor(event) {
          var picks = event && event.picks || [];
          var handlesPicked = (0, _utils.getPickedEditHandles)(picks);
          if (handlesPicked.length) {
            return "cell";
          }
          return null;
        }
      }]);
      return ModifyMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.ModifyMode = ModifyMode;
  }
});

// node_modules/@turf/line-segment/dist/js/index.js
var require_js13 = __commonJS({
  "node_modules/@turf/line-segment/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var meta_1 = require_js2();
    function lineSegment(geojson) {
      if (!geojson) {
        throw new Error("geojson is required");
      }
      var results = [];
      meta_1.flattenEach(geojson, function(feature2) {
        lineSegmentFeature(feature2, results);
      });
      return helpers_1.featureCollection(results);
    }
    function lineSegmentFeature(geojson, results) {
      var coords = [];
      var geometry = geojson.geometry;
      if (geometry !== null) {
        switch (geometry.type) {
          case "Polygon":
            coords = invariant_1.getCoords(geometry);
            break;
          case "LineString":
            coords = [invariant_1.getCoords(geometry)];
        }
        coords.forEach(function(coord) {
          var segments = createSegments(coord, geojson.properties);
          segments.forEach(function(segment) {
            segment.id = results.length;
            results.push(segment);
          });
        });
      }
    }
    function createSegments(coords, properties) {
      var segments = [];
      coords.reduce(function(previousCoords, currentCoords) {
        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
      });
      return segments;
    }
    function bbox(coords1, coords2) {
      var x1 = coords1[0];
      var y1 = coords1[1];
      var x2 = coords2[0];
      var y2 = coords2[1];
      var west = x1 < x2 ? x1 : x2;
      var south = y1 < y2 ? y1 : y2;
      var east = x1 > x2 ? x1 : x2;
      var north = y1 > y2 ? y1 : y2;
      return [west, south, east, north];
    }
    exports.default = lineSegment;
  }
});

// node_modules/@turf/line-intersect/dist/js/index.js
var require_js14 = __commonJS({
  "node_modules/@turf/line-intersect/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    var line_segment_1 = __importDefault(require_js13());
    var meta_1 = require_js2();
    var geojson_rbush_1 = __importDefault(require_geojson_rbush());
    function lineIntersect(line1, line2) {
      var unique = {};
      var results = [];
      if (line1.type === "LineString") {
        line1 = helpers_1.feature(line1);
      }
      if (line2.type === "LineString") {
        line2 = helpers_1.feature(line2);
      }
      if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
        var intersect = intersects(line1, line2);
        if (intersect) {
          results.push(intersect);
        }
        return helpers_1.featureCollection(results);
      }
      var tree = geojson_rbush_1.default();
      tree.load(line_segment_1.default(line2));
      meta_1.featureEach(line_segment_1.default(line1), function(segment) {
        meta_1.featureEach(tree.search(segment), function(match) {
          var intersect2 = intersects(segment, match);
          if (intersect2) {
            var key = invariant_1.getCoords(intersect2).join(",");
            if (!unique[key]) {
              unique[key] = true;
              results.push(intersect2);
            }
          }
        });
      });
      return helpers_1.featureCollection(results);
    }
    function intersects(line1, line2) {
      var coords1 = invariant_1.getCoords(line1);
      var coords2 = invariant_1.getCoords(line2);
      if (coords1.length !== 2) {
        throw new Error("<intersects> line1 must only contain 2 coordinates");
      }
      if (coords2.length !== 2) {
        throw new Error("<intersects> line2 must only contain 2 coordinates");
      }
      var x1 = coords1[0][0];
      var y1 = coords1[0][1];
      var x2 = coords1[1][0];
      var y2 = coords1[1][1];
      var x3 = coords2[0][0];
      var y3 = coords2[0][1];
      var x4 = coords2[1][0];
      var y4 = coords2[1][1];
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      if (denom === 0) {
        if (numeA === 0 && numeB === 0) {
          return null;
        }
        return null;
      }
      var uA = numeA / denom;
      var uB = numeB / denom;
      if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        var x = x1 + uA * (x2 - x1);
        var y = y1 + uA * (y2 - y1);
        return helpers_1.point([x, y]);
      }
      return null;
    }
    exports.default = lineIntersect;
  }
});

// node_modules/@turf/nearest-point-on-line/dist/js/index.js
var require_js15 = __commonJS({
  "node_modules/@turf/nearest-point-on-line/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bearing_1 = __importDefault(require_js9());
    var distance_1 = __importDefault(require_js10());
    var destination_1 = __importDefault(require_js8());
    var line_intersect_1 = __importDefault(require_js14());
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function nearestPointOnLine(lines, pt, options) {
      if (options === void 0) {
        options = {};
      }
      var closestPt = helpers_1.point([Infinity, Infinity], {
        dist: Infinity
      });
      var length = 0;
      meta_1.flattenEach(lines, function(line) {
        var coords = invariant_1.getCoords(line);
        for (var i = 0; i < coords.length - 1; i++) {
          var start = helpers_1.point(coords[i]);
          start.properties.dist = distance_1.default(pt, start, options);
          var stop_1 = helpers_1.point(coords[i + 1]);
          stop_1.properties.dist = distance_1.default(pt, stop_1, options);
          var sectionLength = distance_1.default(start, stop_1, options);
          var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
          var direction = bearing_1.default(start, stop_1);
          var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);
          var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);
          var intersect = line_intersect_1.default(helpers_1.lineString([
            perpendicularPt1.geometry.coordinates,
            perpendicularPt2.geometry.coordinates
          ]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
          var intersectPt = null;
          if (intersect.features.length > 0) {
            intersectPt = intersect.features[0];
            intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);
            intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);
          }
          if (start.properties.dist < closestPt.properties.dist) {
            closestPt = start;
            closestPt.properties.index = i;
            closestPt.properties.location = length;
          }
          if (stop_1.properties.dist < closestPt.properties.dist) {
            closestPt = stop_1;
            closestPt.properties.index = i + 1;
            closestPt.properties.location = length + sectionLength;
          }
          if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
            closestPt = intersectPt;
            closestPt.properties.index = i;
          }
          length += sectionLength;
        }
      });
      return closestPt;
    }
    exports.default = nearestPointOnLine;
  }
});

// node_modules/@turf/circle/dist/js/index.js
var require_js16 = __commonJS({
  "node_modules/@turf/circle/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var destination_1 = __importDefault(require_js8());
    var helpers_1 = require_js();
    function circle(center, radius, options) {
      if (options === void 0) {
        options = {};
      }
      var steps = options.steps || 64;
      var properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
      var coordinates = [];
      for (var i = 0; i < steps; i++) {
        coordinates.push(destination_1.default(center, radius, i * -360 / steps, options).geometry.coordinates);
      }
      coordinates.push(coordinates[0]);
      return helpers_1.polygon([coordinates], properties);
    }
    exports.default = circle;
  }
});

// node_modules/@turf/center/dist/js/index.js
var require_js17 = __commonJS({
  "node_modules/@turf/center/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bbox_1 = __importDefault(require_js3());
    var helpers_1 = require_js();
    function center(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      var ext = bbox_1.default(geojson);
      var x = (ext[0] + ext[2]) / 2;
      var y = (ext[1] + ext[3]) / 2;
      return helpers_1.point([x, y], options.properties, options);
    }
    exports.default = center;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/resize-circle-mode.js
var require_resize_circle_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/resize-circle-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ResizeCircleMode = void 0;
    var _nearestPointOnLine = _interopRequireDefault(require_js15());
    var _helpers = require_js();
    var _circle = _interopRequireDefault(require_js16());
    var _distance = _interopRequireDefault(require_js10());
    var _center = _interopRequireDefault(require_js17());
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ResizeCircleMode = function(_GeoJsonEditMode) {
      _inherits(ResizeCircleMode2, _GeoJsonEditMode);
      var _super = _createSuper(ResizeCircleMode2);
      function ResizeCircleMode2() {
        var _this;
        _classCallCheck(this, ResizeCircleMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "_selectedEditHandle", void 0);
        _defineProperty(_assertThisInitialized(_this), "_isResizing", false);
        return _this;
      }
      _createClass(ResizeCircleMode2, [{
        key: "getGuides",
        value: function getGuides(props) {
          var _this2 = this;
          var handles = [];
          var selectedFeatureIndexes = props.selectedIndexes;
          var lastPointerMoveEvent = props.lastPointerMoveEvent;
          var picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;
          var mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;
          if (picks && picks.length && mapCoords && selectedFeatureIndexes.length === 1 && !this._isResizing) {
            var featureAsPick = picks.find(function(pick) {
              return !pick.isGuide;
            });
            if (featureAsPick && featureAsPick.object.properties.shape && featureAsPick.object.properties.shape.includes("Circle") && props.selectedIndexes.includes(featureAsPick.index)) {
              var intermediatePoint = null;
              var positionIndexPrefix = [];
              var referencePoint = (0, _helpers.point)(mapCoords);
              (0, _utils.recursivelyTraverseNestedArrays)(featureAsPick.object.geometry.coordinates, [], function(lineString2, prefix) {
                var lineStringFeature = (0, _helpers.lineString)(lineString2);
                var candidateIntermediatePoint = _this2.getNearestPoint(
                  // @ts-ignore
                  lineStringFeature,
                  referencePoint,
                  props.modeConfig && props.modeConfig.viewport
                );
                if (!intermediatePoint || candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist) {
                  intermediatePoint = candidateIntermediatePoint;
                  positionIndexPrefix = prefix;
                }
              });
              if (intermediatePoint) {
                var _intermediatePoint = intermediatePoint, position = _intermediatePoint.geometry.coordinates, index = _intermediatePoint.properties.index;
                handles.push({
                  type: "Feature",
                  properties: {
                    guideType: "editHandle",
                    editHandleType: "intermediate",
                    featureIndex: featureAsPick.index,
                    positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [index + 1])
                  },
                  geometry: {
                    type: "Point",
                    coordinates: position
                  }
                });
              }
            }
          }
          return {
            type: "FeatureCollection",
            features: handles
          };
        }
        // turf.js does not support elevation for nearestPointOnLine
      }, {
        key: "getNearestPoint",
        value: function getNearestPoint(line, inPoint, viewport) {
          var coordinates = line.geometry.coordinates;
          if (coordinates.some(function(coord) {
            return coord.length > 2;
          })) {
            if (viewport) {
              return (0, _utils.nearestPointOnProjectedLine)(line, inPoint, viewport);
            }
            console.log("Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.");
          }
          return (0, _nearestPointOnLine["default"])(line, inPoint);
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
          var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);
          if (editHandle) {
            event.cancelPan();
            var editHandleProperties = editHandle.properties;
            var feature2 = this.getSelectedFeature(props);
            var center = (0, _center["default"])(feature2).geometry.coordinates;
            var numberOfSteps = Object.entries(feature2.geometry.coordinates[0]).length - 1;
            var radius = Math.max((0, _distance["default"])(center, event.mapCoords), 1e-3);
            var _ref = {}, _ref$steps = _ref.steps, steps = _ref$steps === void 0 ? numberOfSteps : _ref$steps;
            var options = {
              steps
            };
            var updatedFeature = (0, _circle["default"])(center, radius, options);
            var geometry = updatedFeature.geometry;
            var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(editHandleProperties.featureIndex, geometry).getObject();
            props.onEdit({
              updatedData,
              editType: "unionGeometry",
              editContext: {
                featureIndexes: [editHandleProperties.featureIndex]
              }
            });
          }
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          if (!this._isResizing) {
            var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);
            this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === "intermediate" ? selectedEditHandle : null;
          }
          var cursor = this.getCursor(event);
          props.onUpdateCursor(cursor);
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          if (this._selectedEditHandle) {
            this._isResizing = true;
          }
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          if (this._isResizing) {
            this._selectedEditHandle = null;
            this._isResizing = false;
          }
        }
      }, {
        key: "getCursor",
        value: function getCursor(event) {
          var picks = event && event.picks || [];
          var handlesPicked = (0, _utils.getPickedEditHandles)(picks);
          if (handlesPicked.length) {
            return "cell";
          }
          return null;
        }
      }]);
      return ResizeCircleMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.ResizeCircleMode = ResizeCircleMode;
  }
});

// node_modules/@turf/clone/dist/js/index.js
var require_js18 = __commonJS({
  "node_modules/@turf/clone/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function clone2(geojson) {
      if (!geojson) {
        throw new Error("geojson is required");
      }
      switch (geojson.type) {
        case "Feature":
          return cloneFeature2(geojson);
        case "FeatureCollection":
          return cloneFeatureCollection2(geojson);
        case "Point":
        case "LineString":
        case "Polygon":
        case "MultiPoint":
        case "MultiLineString":
        case "MultiPolygon":
        case "GeometryCollection":
          return cloneGeometry2(geojson);
        default:
          throw new Error("unknown GeoJSON type");
      }
    }
    function cloneFeature2(geojson) {
      var cloned = { type: "Feature" };
      Object.keys(geojson).forEach(function(key) {
        switch (key) {
          case "type":
          case "properties":
          case "geometry":
            return;
          default:
            cloned[key] = geojson[key];
        }
      });
      cloned.properties = cloneProperties2(geojson.properties);
      cloned.geometry = cloneGeometry2(geojson.geometry);
      return cloned;
    }
    function cloneProperties2(properties) {
      var cloned = {};
      if (!properties) {
        return cloned;
      }
      Object.keys(properties).forEach(function(key) {
        var value = properties[key];
        if (typeof value === "object") {
          if (value === null) {
            cloned[key] = null;
          } else if (Array.isArray(value)) {
            cloned[key] = value.map(function(item) {
              return item;
            });
          } else {
            cloned[key] = cloneProperties2(value);
          }
        } else {
          cloned[key] = value;
        }
      });
      return cloned;
    }
    function cloneFeatureCollection2(geojson) {
      var cloned = { type: "FeatureCollection" };
      Object.keys(geojson).forEach(function(key) {
        switch (key) {
          case "type":
          case "features":
            return;
          default:
            cloned[key] = geojson[key];
        }
      });
      cloned.features = geojson.features.map(function(feature2) {
        return cloneFeature2(feature2);
      });
      return cloned;
    }
    function cloneGeometry2(geometry) {
      var geom = { type: geometry.type };
      if (geometry.bbox) {
        geom.bbox = geometry.bbox;
      }
      if (geometry.type === "GeometryCollection") {
        geom.geometries = geometry.geometries.map(function(g) {
          return cloneGeometry2(g);
        });
        return geom;
      }
      geom.coordinates = deepSlice2(geometry.coordinates);
      return geom;
    }
    function deepSlice2(coords) {
      var cloned = coords;
      if (typeof cloned[0] !== "object") {
        return cloned.slice();
      }
      return cloned.map(function(coord) {
        return deepSlice2(coord);
      });
    }
    exports.default = clone2;
  }
});

// node_modules/@turf/rhumb-destination/dist/js/index.js
var require_js19 = __commonJS({
  "node_modules/@turf/rhumb-destination/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function rhumbDestination(origin, distance, bearing, options) {
      if (options === void 0) {
        options = {};
      }
      var wasNegativeDistance = distance < 0;
      var distanceInMeters = helpers_1.convertLength(Math.abs(distance), options.units, "meters");
      if (wasNegativeDistance)
        distanceInMeters = -Math.abs(distanceInMeters);
      var coords = invariant_1.getCoord(origin);
      var destination = calculateRhumbDestination(coords, distanceInMeters, bearing);
      destination[0] += destination[0] - coords[0] > 180 ? -360 : coords[0] - destination[0] > 180 ? 360 : 0;
      return helpers_1.point(destination, options.properties);
    }
    function calculateRhumbDestination(origin, distance, bearing, radius) {
      radius = radius === void 0 ? helpers_1.earthRadius : Number(radius);
      var delta = distance / radius;
      var lambda1 = origin[0] * Math.PI / 180;
      var phi1 = helpers_1.degreesToRadians(origin[1]);
      var theta = helpers_1.degreesToRadians(bearing);
      var DeltaPhi = delta * Math.cos(theta);
      var phi2 = phi1 + DeltaPhi;
      if (Math.abs(phi2) > Math.PI / 2) {
        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
      }
      var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
      var DeltaLambda = delta * Math.sin(theta) / q;
      var lambda2 = lambda1 + DeltaLambda;
      return [
        (lambda2 * 180 / Math.PI + 540) % 360 - 180,
        phi2 * 180 / Math.PI
      ];
    }
    exports.default = rhumbDestination;
  }
});

// node_modules/@turf/transform-translate/dist/js/index.js
var require_js20 = __commonJS({
  "node_modules/@turf/transform-translate/dist/js/index.js"(exports, module) {
    "use strict";
    var meta = require_js2();
    var helpers = require_js();
    var invariant = require_js4();
    var clone2 = require_js18();
    var rhumbDestination = require_js19();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var clone__default = _interopDefaultLegacy(clone2);
    var rhumbDestination__default = _interopDefaultLegacy(rhumbDestination);
    function transformTranslate(geojson, distance, direction, options) {
      options = options || {};
      if (!helpers.isObject(options))
        throw new Error("options is invalid");
      var units = options.units;
      var zTranslation = options.zTranslation;
      var mutate = options.mutate;
      if (!geojson)
        throw new Error("geojson is required");
      if (distance === void 0 || distance === null || isNaN(distance))
        throw new Error("distance is required");
      if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
        throw new Error("zTranslation is not a number");
      zTranslation = zTranslation !== void 0 ? zTranslation : 0;
      if (distance === 0 && zTranslation === 0)
        return geojson;
      if (direction === void 0 || direction === null || isNaN(direction))
        throw new Error("direction is required");
      if (distance < 0) {
        distance = -distance;
        direction = direction + 180;
      }
      if (mutate === false || mutate === void 0)
        geojson = clone__default["default"](geojson);
      meta.coordEach(geojson, function(pointCoords) {
        var newCoords = invariant.getCoords(
          rhumbDestination__default["default"](pointCoords, distance, direction, { units })
        );
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
        if (zTranslation && pointCoords.length === 3)
          pointCoords[2] += zTranslation;
      });
      return geojson;
    }
    module.exports = transformTranslate;
    module.exports.default = transformTranslate;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/translate-mode.js
var require_translate_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/translate-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TranslateMode = void 0;
    var _bearing = _interopRequireDefault(require_js9());
    var _distance = _interopRequireDefault(require_js10());
    var _transformTranslate = _interopRequireDefault(require_js20());
    var _helpers = require_js();
    var _viewportMercatorProject = _interopRequireDefault((init_module(), __toCommonJS(module_exports)));
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var TranslateMode = function(_GeoJsonEditMode) {
      _inherits(TranslateMode2, _GeoJsonEditMode);
      var _super = _createSuper(TranslateMode2);
      function TranslateMode2() {
        var _this;
        _classCallCheck(this, TranslateMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "_geometryBeforeTranslate", void 0);
        _defineProperty(_assertThisInitialized(_this), "_isTranslatable", void 0);
        return _this;
      }
      _createClass(TranslateMode2, [{
        key: "handleDragging",
        value: function handleDragging(event, props) {
          if (!this._isTranslatable) {
            return;
          }
          if (this._geometryBeforeTranslate) {
            var editAction = this.getTranslateAction(event.pointerDownMapCoords, event.mapCoords, "translating", props);
            if (editAction) {
              props.onEdit(editAction);
            }
          }
          event.cancelPan();
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          this._isTranslatable = this.isSelectionPicked(event.pointerDownPicks || event.picks, props);
          this.updateCursor(props);
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          if (!this._isTranslatable) {
            return;
          }
          this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection(props);
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          if (this._geometryBeforeTranslate) {
            var editAction = this.getTranslateAction(event.pointerDownMapCoords, event.mapCoords, "translated", props);
            if (editAction) {
              props.onEdit(editAction);
            }
            this._geometryBeforeTranslate = null;
          }
        }
      }, {
        key: "updateCursor",
        value: function updateCursor(props) {
          if (this._isTranslatable) {
            props.onUpdateCursor("move");
          } else {
            props.onUpdateCursor(null);
          }
        }
      }, {
        key: "getTranslateAction",
        value: function getTranslateAction(startDragPoint, currentPoint, editType, props) {
          var _this2 = this;
          if (!this._geometryBeforeTranslate) {
            return null;
          }
          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);
          var selectedIndexes = props.selectedIndexes;
          var _ref = props.modeConfig || {}, viewportDesc = _ref.viewport, screenSpace = _ref.screenSpace;
          if (viewportDesc && screenSpace) {
            (function() {
              var viewport = viewportDesc.project ? viewportDesc : new _viewportMercatorProject["default"](viewportDesc);
              var from = viewport.project(startDragPoint);
              var to = viewport.project(currentPoint);
              var dx = to[0] - from[0];
              var dy = to[1] - from[1];
              for (var i2 = 0; i2 < selectedIndexes.length; i2++) {
                var selectedIndex2 = selectedIndexes[i2];
                var feature2 = _this2._geometryBeforeTranslate.features[i2];
                var coordinates = feature2.geometry.coordinates;
                if (coordinates) {
                  coordinates = (0, _utils.mapCoords)(coordinates, function(coord) {
                    var pixels = viewport.project(coord);
                    if (pixels) {
                      pixels[0] += dx;
                      pixels[1] += dy;
                      return viewport.unproject(pixels);
                    }
                    return null;
                  });
                  updatedData = updatedData.replaceGeometry(selectedIndex2, {
                    type: feature2.geometry.type,
                    coordinates
                  });
                }
              }
            })();
          } else {
            var p1 = (0, _helpers.point)(startDragPoint);
            var p2 = (0, _helpers.point)(currentPoint);
            var distanceMoved = (0, _distance["default"])(p1, p2);
            var direction = (0, _bearing["default"])(p1, p2);
            var movedFeatures = (0, _transformTranslate["default"])(
              // @ts-ignore
              this._geometryBeforeTranslate,
              distanceMoved,
              direction
            );
            for (var i = 0; i < selectedIndexes.length; i++) {
              var selectedIndex = selectedIndexes[i];
              var movedFeature = movedFeatures.features[i];
              updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);
            }
          }
          return {
            updatedData: updatedData.getObject(),
            editType,
            editContext: {
              featureIndexes: selectedIndexes
            }
          };
        }
      }]);
      return TranslateMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.TranslateMode = TranslateMode;
  }
});

// node_modules/@turf/centroid/dist/js/index.js
var require_js21 = __commonJS({
  "node_modules/@turf/centroid/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var meta_1 = require_js2();
    var helpers_1 = require_js();
    function centroid(geojson, options) {
      if (options === void 0) {
        options = {};
      }
      var xSum = 0;
      var ySum = 0;
      var len = 0;
      meta_1.coordEach(geojson, function(coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
      }, true);
      return helpers_1.point([xSum / len, ySum / len], options.properties);
    }
    exports.default = centroid;
  }
});

// node_modules/@turf/bbox-polygon/dist/js/index.js
var require_js22 = __commonJS({
  "node_modules/@turf/bbox-polygon/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    function bboxPolygon(bbox, options) {
      if (options === void 0) {
        options = {};
      }
      var west = Number(bbox[0]);
      var south = Number(bbox[1]);
      var east = Number(bbox[2]);
      var north = Number(bbox[3]);
      if (bbox.length === 6) {
        throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
      }
      var lowLeft = [west, south];
      var topLeft = [west, north];
      var topRight = [east, north];
      var lowRight = [east, south];
      return helpers_1.polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox, id: options.id });
    }
    exports.default = bboxPolygon;
  }
});

// node_modules/@turf/polygon-to-line/dist/js/index.js
var require_js23 = __commonJS({
  "node_modules/@turf/polygon-to-line/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function default_1(poly, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(poly);
      if (!options.properties && poly.type === "Feature") {
        options.properties = poly.properties;
      }
      switch (geom.type) {
        case "Polygon":
          return polygonToLine(geom, options);
        case "MultiPolygon":
          return multiPolygonToLine(geom, options);
        default:
          throw new Error("invalid poly");
      }
    }
    exports.default = default_1;
    function polygonToLine(poly, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(poly);
      var coords = geom.coordinates;
      var properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
      return coordsToLine(coords, properties);
    }
    exports.polygonToLine = polygonToLine;
    function multiPolygonToLine(multiPoly, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(multiPoly);
      var coords = geom.coordinates;
      var properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
      var lines = [];
      coords.forEach(function(coord) {
        lines.push(coordsToLine(coord, properties));
      });
      return helpers_1.featureCollection(lines);
    }
    exports.multiPolygonToLine = multiPolygonToLine;
    function coordsToLine(coords, properties) {
      if (coords.length > 1) {
        return helpers_1.multiLineString(coords, properties);
      }
      return helpers_1.lineString(coords[0], properties);
    }
    exports.coordsToLine = coordsToLine;
  }
});

// node_modules/@turf/rhumb-bearing/dist/js/index.js
var require_js24 = __commonJS({
  "node_modules/@turf/rhumb-bearing/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function rhumbBearing(start, end, options) {
      if (options === void 0) {
        options = {};
      }
      var bear360;
      if (options.final) {
        bear360 = calculateRhumbBearing(invariant_1.getCoord(end), invariant_1.getCoord(start));
      } else {
        bear360 = calculateRhumbBearing(invariant_1.getCoord(start), invariant_1.getCoord(end));
      }
      var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
      return bear180;
    }
    function calculateRhumbBearing(from, to) {
      var phi1 = helpers_1.degreesToRadians(from[1]);
      var phi2 = helpers_1.degreesToRadians(to[1]);
      var deltaLambda = helpers_1.degreesToRadians(to[0] - from[0]);
      if (deltaLambda > Math.PI) {
        deltaLambda -= 2 * Math.PI;
      }
      if (deltaLambda < -Math.PI) {
        deltaLambda += 2 * Math.PI;
      }
      var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var theta = Math.atan2(deltaLambda, deltaPsi);
      return (helpers_1.radiansToDegrees(theta) + 360) % 360;
    }
    exports.default = rhumbBearing;
  }
});

// node_modules/@turf/transform-scale/dist/js/index.js
var require_js25 = __commonJS({
  "node_modules/@turf/transform-scale/dist/js/index.js"(exports, module) {
    "use strict";
    var clone2 = require_js18();
    var center = require_js17();
    var centroid = require_js21();
    var turfBBox = require_js3();
    var rhumbBearing = require_js24();
    var rhumbDistance = require_js11();
    var rhumbDestination = require_js19();
    var meta = require_js2();
    var helpers = require_js();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var clone__default = _interopDefaultLegacy(clone2);
    var center__default = _interopDefaultLegacy(center);
    var centroid__default = _interopDefaultLegacy(centroid);
    var turfBBox__default = _interopDefaultLegacy(turfBBox);
    var rhumbBearing__default = _interopDefaultLegacy(rhumbBearing);
    var rhumbDistance__default = _interopDefaultLegacy(rhumbDistance);
    var rhumbDestination__default = _interopDefaultLegacy(rhumbDestination);
    function transformScale(geojson, factor, options) {
      options = options || {};
      if (!helpers.isObject(options))
        throw new Error("options is invalid");
      var origin = options.origin;
      var mutate = options.mutate;
      if (!geojson)
        throw new Error("geojson required");
      if (typeof factor !== "number" || factor === 0)
        throw new Error("invalid factor");
      var originIsPoint = Array.isArray(origin) || typeof origin === "object";
      if (mutate !== true)
        geojson = clone__default["default"](geojson);
      if (geojson.type === "FeatureCollection" && !originIsPoint) {
        meta.featureEach(geojson, function(feature2, index) {
          geojson.features[index] = scale(feature2, factor, origin);
        });
        return geojson;
      }
      return scale(geojson, factor, origin);
    }
    function scale(feature2, factor, origin) {
      var isPoint = invariant.getType(feature2) === "Point";
      origin = defineOrigin(feature2, origin);
      if (factor === 1 || isPoint)
        return feature2;
      meta.coordEach(feature2, function(coord) {
        var originalDistance = rhumbDistance__default["default"](origin, coord);
        var bearing = rhumbBearing__default["default"](origin, coord);
        var newDistance = originalDistance * factor;
        var newCoord = invariant.getCoords(rhumbDestination__default["default"](origin, newDistance, bearing));
        coord[0] = newCoord[0];
        coord[1] = newCoord[1];
        if (coord.length === 3)
          coord[2] *= factor;
      });
      return feature2;
    }
    function defineOrigin(geojson, origin) {
      if (origin === void 0 || origin === null)
        origin = "centroid";
      if (Array.isArray(origin) || typeof origin === "object")
        return invariant.getCoord(origin);
      var bbox = geojson.bbox ? geojson.bbox : turfBBox__default["default"](geojson);
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];
      switch (origin) {
        case "sw":
        case "southwest":
        case "westsouth":
        case "bottomleft":
          return helpers.point([west, south]);
        case "se":
        case "southeast":
        case "eastsouth":
        case "bottomright":
          return helpers.point([east, south]);
        case "nw":
        case "northwest":
        case "westnorth":
        case "topleft":
          return helpers.point([west, north]);
        case "ne":
        case "northeast":
        case "eastnorth":
        case "topright":
          return helpers.point([east, north]);
        case "center":
          return center__default["default"](geojson);
        case void 0:
        case null:
        case "centroid":
          return centroid__default["default"](geojson);
        default:
          throw new Error("invalid origin");
      }
    }
    module.exports = transformScale;
    module.exports.default = transformScale;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/scale-mode.js
var require_scale_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/scale-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScaleMode = void 0;
    var _bbox = _interopRequireDefault(require_js3());
    var _centroid = _interopRequireDefault(require_js21());
    var _bearing = _interopRequireDefault(require_js9());
    var _bboxPolygon = _interopRequireDefault(require_js22());
    var _helpers = require_js();
    var _polygonToLine = _interopRequireDefault(require_js23());
    var _meta = require_js2();
    var _distance = _interopRequireDefault(require_js10());
    var _transformScale = _interopRequireDefault(require_js25());
    var _invariant = require_js4();
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ScaleMode = function(_GeoJsonEditMode) {
      _inherits(ScaleMode2, _GeoJsonEditMode);
      var _super = _createSuper(ScaleMode2);
      function ScaleMode2() {
        var _this;
        _classCallCheck(this, ScaleMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "_geometryBeingScaled", void 0);
        _defineProperty(_assertThisInitialized(_this), "_selectedEditHandle", void 0);
        _defineProperty(_assertThisInitialized(_this), "_cornerGuidePoints", void 0);
        _defineProperty(_assertThisInitialized(_this), "_cursor", void 0);
        _defineProperty(_assertThisInitialized(_this), "_isScaling", false);
        _defineProperty(_assertThisInitialized(_this), "_isSinglePointGeometrySelected", function(geometry) {
          var _ref = geometry || {}, features = _ref.features;
          if (Array.isArray(features) && features.length === 1) {
            var _getGeom = (0, _invariant.getGeom)(features[0]), type = _getGeom.type;
            return type === "Point";
          }
          return false;
        });
        _defineProperty(_assertThisInitialized(_this), "_getOppositeScaleHandle", function(selectedHandle) {
          var selectedHandleIndex = selectedHandle && selectedHandle.properties && Array.isArray(selectedHandle.properties.positionIndexes) && selectedHandle.properties.positionIndexes[0];
          if (typeof selectedHandleIndex !== "number") {
            return null;
          }
          var guidePointCount = _this._cornerGuidePoints.length;
          var oppositeIndex = (selectedHandleIndex + guidePointCount / 2) % guidePointCount;
          return _this._cornerGuidePoints.find(function(p) {
            if (!Array.isArray(p.properties.positionIndexes)) {
              return false;
            }
            return p.properties.positionIndexes[0] === oppositeIndex;
          });
        });
        _defineProperty(_assertThisInitialized(_this), "_getUpdatedData", function(props, editedData) {
          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);
          var selectedIndexes = props.selectedIndexes;
          for (var i = 0; i < selectedIndexes.length; i++) {
            var selectedIndex = selectedIndexes[i];
            var movedFeature = editedData.features[i];
            updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);
          }
          return updatedData.getObject();
        });
        _defineProperty(_assertThisInitialized(_this), "isEditHandleSelected", function() {
          return Boolean(_this._selectedEditHandle);
        });
        _defineProperty(_assertThisInitialized(_this), "getScaleAction", function(startDragPoint, currentPoint, editType, props) {
          if (!_this._selectedEditHandle) {
            return null;
          }
          var oppositeHandle = _this._getOppositeScaleHandle(_this._selectedEditHandle);
          var origin = (0, _invariant.getCoord)(oppositeHandle);
          var scaleFactor = getScaleFactor(origin, startDragPoint, currentPoint);
          var scaledFeatures = (0, _transformScale["default"])(
            // @ts-ignore
            _this._geometryBeingScaled,
            scaleFactor,
            {
              origin
            }
          );
          return {
            updatedData: _this._getUpdatedData(props, scaledFeatures),
            editType,
            editContext: {
              featureIndexes: props.selectedIndexes
            }
          };
        });
        _defineProperty(_assertThisInitialized(_this), "updateCursor", function(props) {
          if (_this._selectedEditHandle) {
            if (_this._cursor) {
              props.onUpdateCursor(_this._cursor);
            }
            var cursorGeometry = _this.getSelectedFeaturesAsFeatureCollection(props);
            var centroid = (0, _centroid["default"])(cursorGeometry);
            var bearing = (0, _bearing["default"])(centroid, _this._selectedEditHandle);
            var positiveBearing = bearing < 0 ? bearing + 180 : bearing;
            if (positiveBearing >= 0 && positiveBearing <= 90 || positiveBearing >= 180 && positiveBearing <= 270) {
              _this._cursor = "nesw-resize";
              props.onUpdateCursor("nesw-resize");
            } else {
              _this._cursor = "nwse-resize";
              props.onUpdateCursor("nwse-resize");
            }
          } else {
            props.onUpdateCursor(null);
            _this._cursor = null;
          }
        });
        return _this;
      }
      _createClass(ScaleMode2, [{
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          if (!this._isScaling) {
            var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);
            this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === "scale" ? selectedEditHandle : null;
            this.updateCursor(props);
          }
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          if (this._selectedEditHandle) {
            this._isScaling = true;
            this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection(props);
          }
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
          if (!this._isScaling) {
            return;
          }
          props.onUpdateCursor(this._cursor);
          var scaleAction = this.getScaleAction(event.pointerDownMapCoords, event.mapCoords, "scaling", props);
          if (scaleAction) {
            props.onEdit(scaleAction);
          }
          event.cancelPan();
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          if (this._isScaling) {
            var scaleAction = this.getScaleAction(event.pointerDownMapCoords, event.mapCoords, "scaled", props);
            if (scaleAction) {
              props.onEdit(scaleAction);
            }
            props.onUpdateCursor(null);
            this._geometryBeingScaled = null;
            this._selectedEditHandle = null;
            this._cursor = null;
            this._isScaling = false;
          }
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          this._cornerGuidePoints = [];
          var selectedGeometry = this.getSelectedFeaturesAsFeatureCollection(props);
          if (this._isSinglePointGeometrySelected(selectedGeometry)) {
            return {
              type: "FeatureCollection",
              features: []
            };
          }
          var boundingBox = (0, _bboxPolygon["default"])((0, _bbox["default"])(selectedGeometry));
          boundingBox.properties.mode = "scale";
          var cornerGuidePoints = [];
          (0, _meta.coordEach)(boundingBox, function(coord, coordIndex) {
            if (coordIndex < 4) {
              var cornerPoint = (0, _helpers.point)(coord, {
                guideType: "editHandle",
                editHandleType: "scale",
                positionIndexes: [coordIndex]
              });
              cornerGuidePoints.push(cornerPoint);
            }
          });
          this._cornerGuidePoints = cornerGuidePoints;
          return (0, _helpers.featureCollection)([(0, _polygonToLine["default"])(boundingBox)].concat(_toConsumableArray(this._cornerGuidePoints)));
        }
      }]);
      return ScaleMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.ScaleMode = ScaleMode;
    function getScaleFactor(centroid, startDragPoint, currentPoint) {
      var startDistance = (0, _distance["default"])(centroid, startDragPoint);
      var endDistance = (0, _distance["default"])(centroid, currentPoint);
      return endDistance / startDistance;
    }
  }
});

// node_modules/@turf/transform-rotate/dist/js/index.js
var require_js26 = __commonJS({
  "node_modules/@turf/transform-rotate/dist/js/index.js"(exports, module) {
    "use strict";
    var centroid = require_js21();
    var rhumbBearing = require_js24();
    var rhumbDistance = require_js11();
    var rhumbDestination = require_js19();
    var clone2 = require_js18();
    var meta = require_js2();
    var invariant = require_js4();
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var centroid__default = _interopDefaultLegacy(centroid);
    var rhumbBearing__default = _interopDefaultLegacy(rhumbBearing);
    var rhumbDistance__default = _interopDefaultLegacy(rhumbDistance);
    var rhumbDestination__default = _interopDefaultLegacy(rhumbDestination);
    var clone__default = _interopDefaultLegacy(clone2);
    function transformRotate(geojson, angle, options) {
      options = options || {};
      if (!helpers.isObject(options))
        throw new Error("options is invalid");
      var pivot = options.pivot;
      var mutate = options.mutate;
      if (!geojson)
        throw new Error("geojson is required");
      if (angle === void 0 || angle === null || isNaN(angle))
        throw new Error("angle is required");
      if (angle === 0)
        return geojson;
      if (!pivot)
        pivot = centroid__default["default"](geojson);
      if (mutate === false || mutate === void 0)
        geojson = clone__default["default"](geojson);
      meta.coordEach(geojson, function(pointCoords) {
        var initialAngle = rhumbBearing__default["default"](pivot, pointCoords);
        var finalAngle = initialAngle + angle;
        var distance = rhumbDistance__default["default"](pivot, pointCoords);
        var newCoords = invariant.getCoords(rhumbDestination__default["default"](pivot, distance, finalAngle));
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
      });
      return geojson;
    }
    module.exports = transformRotate;
    module.exports.default = transformRotate;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/rotate-mode.js
var require_rotate_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/rotate-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RotateMode = void 0;
    var _bbox = _interopRequireDefault(require_js3());
    var _centroid = _interopRequireDefault(require_js21());
    var _bearing = _interopRequireDefault(require_js9());
    var _bboxPolygon = _interopRequireDefault(require_js22());
    var _distance = _interopRequireDefault(require_js10());
    var _meta = require_js2();
    var _invariant = require_js4();
    var _helpers = require_js();
    var _transformRotate = _interopRequireDefault(require_js26());
    var _polygonToLine = _interopRequireDefault(require_js23());
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var RotateMode = function(_GeoJsonEditMode) {
      _inherits(RotateMode2, _GeoJsonEditMode);
      var _super = _createSuper(RotateMode2);
      function RotateMode2() {
        var _this;
        _classCallCheck(this, RotateMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "_selectedEditHandle", void 0);
        _defineProperty(_assertThisInitialized(_this), "_geometryBeingRotated", void 0);
        _defineProperty(_assertThisInitialized(_this), "_isRotating", false);
        _defineProperty(_assertThisInitialized(_this), "_isSinglePointGeometrySelected", function(geometry) {
          var _ref = geometry || {}, features = _ref.features;
          if (Array.isArray(features) && features.length === 1) {
            var _getGeom = (0, _invariant.getGeom)(features[0]), type = _getGeom.type;
            return type === "Point";
          }
          return false;
        });
        _defineProperty(_assertThisInitialized(_this), "getIsRotating", function() {
          return _this._isRotating;
        });
        return _this;
      }
      _createClass(RotateMode2, [{
        key: "getGuides",
        value: function getGuides(props) {
          var selectedGeometry = this._geometryBeingRotated || this.getSelectedFeaturesAsFeatureCollection(props);
          if (this._isSinglePointGeometrySelected(selectedGeometry)) {
            return {
              type: "FeatureCollection",
              features: []
            };
          }
          if (this._isRotating) {
            return (0, _helpers.featureCollection)([(0, _centroid["default"])(selectedGeometry)]);
          }
          var boundingBox = (0, _bboxPolygon["default"])((0, _bbox["default"])(selectedGeometry));
          var previousCoord = null;
          var topEdgeMidpointCoords = null;
          var longestEdgeLength = 0;
          (0, _meta.coordEach)(boundingBox, function(coord) {
            if (previousCoord) {
              var edgeMidpoint = (0, _geojsonEditMode.getIntermediatePosition)(coord, previousCoord);
              if (!topEdgeMidpointCoords || edgeMidpoint[1] > topEdgeMidpointCoords[1]) {
                topEdgeMidpointCoords = edgeMidpoint;
              }
              var edgeDistance = (0, _distance["default"])(coord, previousCoord);
              longestEdgeLength = Math.max(longestEdgeLength, edgeDistance);
            }
            previousCoord = coord;
          });
          var rotateHandleCoords = topEdgeMidpointCoords && [topEdgeMidpointCoords[0], topEdgeMidpointCoords[1] + longestEdgeLength / 1e3];
          var lineFromEnvelopeToRotateHandle = (0, _helpers.lineString)([topEdgeMidpointCoords, rotateHandleCoords]);
          var rotateHandle = (0, _helpers.point)(rotateHandleCoords, {
            guideType: "editHandle",
            editHandleType: "rotate"
          });
          return (0, _helpers.featureCollection)([
            // @ts-ignore
            (0, _polygonToLine["default"])(boundingBox),
            // @ts-ignore
            rotateHandle,
            // @ts-ignore
            lineFromEnvelopeToRotateHandle
          ]);
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
          if (!this._isRotating) {
            return;
          }
          var rotateAction = this.getRotateAction(event.pointerDownMapCoords, event.mapCoords, "rotating", props);
          if (rotateAction) {
            props.onEdit(rotateAction);
          }
          event.cancelPan();
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          if (!this._isRotating) {
            var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);
            this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === "rotate" ? selectedEditHandle : null;
          }
          this.updateCursor(props);
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          if (this._selectedEditHandle) {
            this._isRotating = true;
            this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection(props);
          }
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          if (this._isRotating) {
            var rotateAction = this.getRotateAction(event.pointerDownMapCoords, event.mapCoords, "rotated", props);
            if (rotateAction) {
              props.onEdit(rotateAction);
            }
            this._geometryBeingRotated = null;
            this._selectedEditHandle = null;
            this._isRotating = false;
          }
        }
      }, {
        key: "updateCursor",
        value: function updateCursor(props) {
          if (this._selectedEditHandle) {
            props.onUpdateCursor("crosshair");
          } else {
            props.onUpdateCursor(null);
          }
        }
      }, {
        key: "getRotateAction",
        value: function getRotateAction(startDragPoint, currentPoint, editType, props) {
          if (!this._geometryBeingRotated) {
            return null;
          }
          var centroid = (0, _centroid["default"])(this._geometryBeingRotated);
          var angle = getRotationAngle(centroid, startDragPoint, currentPoint);
          var rotatedFeatures = (0, _transformRotate["default"])(
            // @ts-ignore
            this._geometryBeingRotated,
            angle,
            {
              pivot: centroid
            }
          );
          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);
          var selectedIndexes = props.selectedIndexes;
          for (var i = 0; i < selectedIndexes.length; i++) {
            var selectedIndex = selectedIndexes[i];
            var movedFeature = rotatedFeatures.features[i];
            updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);
          }
          return {
            updatedData: updatedData.getObject(),
            editType,
            editContext: {
              featureIndexes: selectedIndexes
            }
          };
        }
      }]);
      return RotateMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.RotateMode = RotateMode;
    function getRotationAngle(centroid, startDragPoint, currentPoint) {
      var bearing1 = (0, _bearing["default"])(centroid, startDragPoint);
      var bearing2 = (0, _bearing["default"])(centroid, currentPoint);
      return bearing2 - bearing1;
    }
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/duplicate-mode.js
var require_duplicate_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/duplicate-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DuplicateMode = void 0;
    var _translateMode = require_translate_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DuplicateMode = function(_TranslateMode) {
      _inherits(DuplicateMode2, _TranslateMode);
      var _super = _createSuper(DuplicateMode2);
      function DuplicateMode2() {
        _classCallCheck(this, DuplicateMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DuplicateMode2, [{
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          _get(_getPrototypeOf(DuplicateMode2.prototype), "handleStartDragging", this).call(this, event, props);
          if (this._geometryBeforeTranslate) {
            props.onEdit(this.getAddManyFeaturesAction(this._geometryBeforeTranslate, props.data));
          }
        }
      }, {
        key: "updateCursor",
        value: function updateCursor(props) {
          if (this._isTranslatable) {
            props.onUpdateCursor("copy");
          } else {
            props.onUpdateCursor(null);
          }
        }
      }]);
      return DuplicateMode2;
    }(_translateMode.TranslateMode);
    exports.DuplicateMode = DuplicateMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/extend-line-string-mode.js
var require_extend_line_string_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/extend-line-string-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExtendLineStringMode = void 0;
    var _geojsonEditMode = require_geojson_edit_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ExtendLineStringMode = function(_GeoJsonEditMode) {
      _inherits(ExtendLineStringMode2, _GeoJsonEditMode);
      var _super = _createSuper(ExtendLineStringMode2);
      function ExtendLineStringMode2() {
        _classCallCheck(this, ExtendLineStringMode2);
        return _super.apply(this, arguments);
      }
      _createClass(ExtendLineStringMode2, [{
        key: "getSingleSelectedLineString",
        value: function getSingleSelectedLineString(props) {
          var selectedGeometry = this.getSelectedGeometry(props);
          if (selectedGeometry && selectedGeometry.type === "LineString") {
            return selectedGeometry;
          }
          return null;
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
          var selectedIndexes = props.selectedIndexes;
          var selectedLineString = this.getSingleSelectedLineString(props);
          if (!selectedLineString) {
            console.warn("ExtendLineStringMode only supported for single LineString selection");
            return;
          }
          var positionIndexes = [selectedLineString.coordinates.length];
          var modeConfig = props.modeConfig;
          if (modeConfig && modeConfig.drawAtFront) {
            positionIndexes = [0];
          }
          var featureIndex = selectedIndexes[0];
          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(featureIndex, positionIndexes, event.mapCoords).getObject();
          props.onEdit({
            updatedData,
            editType: "addPosition",
            editContext: {
              featureIndexes: [featureIndex],
              positionIndexes,
              position: event.mapCoords
            }
          });
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          var selectedLineString = this.getSingleSelectedLineString(props);
          if (!selectedLineString) {
            return guides;
          }
          var mapCoords = props.lastPointerMoveEvent && props.lastPointerMoveEvent.mapCoords;
          var startPosition = null;
          var modeConfig = props.modeConfig;
          if (modeConfig && modeConfig.drawAtFront) {
            startPosition = selectedLineString.coordinates[0];
          } else {
            startPosition = selectedLineString.coordinates[selectedLineString.coordinates.length - 1];
          }
          guides.features.push({
            type: "Feature",
            properties: {
              guideType: "tentative"
            },
            geometry: {
              type: "LineString",
              coordinates: [startPosition, mapCoords]
            }
          });
          return guides;
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
        }
      }]);
      return ExtendLineStringMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.ExtendLineStringMode = ExtendLineStringMode;
  }
});

// node_modules/@turf/boolean-point-in-polygon/dist/js/index.js
var require_js27 = __commonJS({
  "node_modules/@turf/boolean-point-in-polygon/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var invariant_1 = require_js4();
    function booleanPointInPolygon(point2, polygon, options) {
      if (options === void 0) {
        options = {};
      }
      if (!point2) {
        throw new Error("point is required");
      }
      if (!polygon) {
        throw new Error("polygon is required");
      }
      var pt = invariant_1.getCoord(point2);
      var geom = invariant_1.getGeom(polygon);
      var type = geom.type;
      var bbox = polygon.bbox;
      var polys = geom.coordinates;
      if (bbox && inBBox(pt, bbox) === false) {
        return false;
      }
      if (type === "Polygon") {
        polys = [polys];
      }
      var insidePoly = false;
      for (var i = 0; i < polys.length && !insidePoly; i++) {
        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
          var inHole = false;
          var k = 1;
          while (k < polys[i].length && !inHole) {
            if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
              inHole = true;
            }
            k++;
          }
          if (!inHole) {
            insidePoly = true;
          }
        }
      }
      return insidePoly;
    }
    exports.default = booleanPointInPolygon;
    function inRing(pt, ring, ignoreBoundary) {
      var isInside = false;
      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
        ring = ring.slice(0, ring.length - 1);
      }
      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0];
        var yi = ring[i][1];
        var xj = ring[j][0];
        var yj = ring[j][1];
        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
        if (onBoundary) {
          return !ignoreBoundary;
        }
        var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
        if (intersect) {
          isInside = !isInside;
        }
      }
      return isInside;
    }
    function inBBox(pt, bbox) {
      return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
    }
  }
});

// node_modules/turf-jsts/jsts.min.js
var require_jsts_min = __commonJS({
  "node_modules/turf-jsts/jsts.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.jsts = {});
    }(exports, function(t) {
      "use strict";
      function e() {
      }
      function n(t2) {
        this.message = t2 || "";
      }
      function i(t2) {
        this.message = t2 || "";
      }
      function r(t2) {
        this.message = t2 || "";
      }
      function o() {
      }
      function s(t2) {
        return null === t2 ? Mt : t2.color;
      }
      function a(t2) {
        return null === t2 ? null : t2.parent;
      }
      function u(t2, e2) {
        null !== t2 && (t2.color = e2);
      }
      function l(t2) {
        return null === t2 ? null : t2.left;
      }
      function c(t2) {
        return null === t2 ? null : t2.right;
      }
      function p() {
        this.root_ = null, this.size_ = 0;
      }
      function h() {
      }
      function f() {
        this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
      }
      function g() {
      }
      function d(t2) {
        this.message = t2 || "";
      }
      function y() {
        this.array_ = [];
      }
      "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: true, value: function(t2) {
        if (void 0 === this || null === this)
          throw new TypeError(this + " is not an object");
        var e2 = Object(this), n2 = Math.max(Math.min(e2.length, 9007199254740991), 0) || 0, i2 = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
        i2 = i2 < 0 ? Math.max(n2 + i2, 0) : Math.min(i2, n2);
        var r2 = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n2;
        for (r2 = r2 < 0 ? Math.max(n2 + arguments[2], 0) : Math.min(r2, n2); i2 < r2; )
          e2[i2] = t2, ++i2;
        return e2;
      }, writable: true }), Number.isFinite = Number.isFinite || function(t2) {
        return "number" == typeof t2 && isFinite(t2);
      }, Number.isInteger = Number.isInteger || function(t2) {
        return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
      }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t2) {
        return t2 != t2;
      }, Math.trunc = Math.trunc || function(t2) {
        return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
      };
      var _ = function() {
      };
      _.prototype.interfaces_ = function() {
        return [];
      }, _.prototype.getClass = function() {
        return _;
      }, _.prototype.equalsWithTolerance = function(t2, e2, n2) {
        return Math.abs(t2 - e2) <= n2;
      };
      var m = function(t2) {
        function e2(e3) {
          t2.call(this, e3), this.name = "IllegalArgumentException", this.message = e3, this.stack = new t2().stack;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
      }(Error), v = function() {
      }, I = { MAX_VALUE: { configurable: true } };
      v.isNaN = function(t2) {
        return Number.isNaN(t2);
      }, v.doubleToLongBits = function(t2) {
        return t2;
      }, v.longBitsToDouble = function(t2) {
        return t2;
      }, v.isInfinite = function(t2) {
        return !Number.isFinite(t2);
      }, I.MAX_VALUE.get = function() {
        return Number.MAX_VALUE;
      }, Object.defineProperties(v, I);
      var E = function() {
      }, x = function() {
      }, N = function() {
      }, C = function t2() {
        if (this.x = null, this.y = null, this.z = null, 0 === arguments.length)
          this.x = 0, this.y = 0, this.z = t2.NULL_ORDINATE;
        else if (1 === arguments.length) {
          var e2 = arguments[0];
          this.x = e2.x, this.y = e2.y, this.z = e2.z;
        } else
          2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t2.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
      }, S = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
      C.prototype.setOrdinate = function(t2, e2) {
        switch (t2) {
          case C.X:
            this.x = e2;
            break;
          case C.Y:
            this.y = e2;
            break;
          case C.Z:
            this.z = e2;
            break;
          default:
            throw new m("Invalid ordinate index: " + t2);
        }
      }, C.prototype.equals2D = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.x === t2.x && this.y === t2.y;
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return !!_.equalsWithTolerance(this.x, e2.x, n2) && !!_.equalsWithTolerance(this.y, e2.y, n2);
        }
      }, C.prototype.getOrdinate = function(t2) {
        switch (t2) {
          case C.X:
            return this.x;
          case C.Y:
            return this.y;
          case C.Z:
            return this.z;
        }
        throw new m("Invalid ordinate index: " + t2);
      }, C.prototype.equals3D = function(t2) {
        return this.x === t2.x && this.y === t2.y && (this.z === t2.z || v.isNaN(this.z)) && v.isNaN(t2.z);
      }, C.prototype.equals = function(t2) {
        return t2 instanceof C && this.equals2D(t2);
      }, C.prototype.equalInZ = function(t2, e2) {
        return _.equalsWithTolerance(this.z, t2.z, e2);
      }, C.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this.x < e2.x ? -1 : this.x > e2.x ? 1 : this.y < e2.y ? -1 : this.y > e2.y ? 1 : 0;
      }, C.prototype.clone = function() {
      }, C.prototype.copy = function() {
        return new C(this);
      }, C.prototype.toString = function() {
        return "(" + this.x + ", " + this.y + ", " + this.z + ")";
      }, C.prototype.distance3D = function(t2) {
        var e2 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
        return Math.sqrt(e2 * e2 + n2 * n2 + i2 * i2);
      }, C.prototype.distance = function(t2) {
        var e2 = this.x - t2.x, n2 = this.y - t2.y;
        return Math.sqrt(e2 * e2 + n2 * n2);
      }, C.prototype.hashCode = function() {
        var t2 = 17;
        return t2 = 37 * t2 + C.hashCode(this.x), t2 = 37 * t2 + C.hashCode(this.y);
      }, C.prototype.setCoordinate = function(t2) {
        this.x = t2.x, this.y = t2.y, this.z = t2.z;
      }, C.prototype.interfaces_ = function() {
        return [E, x, e];
      }, C.prototype.getClass = function() {
        return C;
      }, C.hashCode = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = v.doubleToLongBits(t2);
          return Math.trunc((e2 ^ e2) >>> 32);
        }
      }, S.DimensionalComparator.get = function() {
        return L;
      }, S.serialVersionUID.get = function() {
        return 6683108902428367e3;
      }, S.NULL_ORDINATE.get = function() {
        return v.NaN;
      }, S.X.get = function() {
        return 0;
      }, S.Y.get = function() {
        return 1;
      }, S.Z.get = function() {
        return 2;
      }, Object.defineProperties(C, S);
      var L = function(t2) {
        if (this._dimensionsToTest = 2, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var e2 = arguments[0];
          if (2 !== e2 && 3 !== e2)
            throw new m("only 2 or 3 dimensions may be specified");
          this._dimensionsToTest = e2;
        }
      };
      L.prototype.compare = function(t2, e2) {
        var n2 = t2, i2 = e2, r2 = L.compare(n2.x, i2.x);
        if (0 !== r2)
          return r2;
        var o2 = L.compare(n2.y, i2.y);
        if (0 !== o2)
          return o2;
        if (this._dimensionsToTest <= 2)
          return 0;
        return L.compare(n2.z, i2.z);
      }, L.prototype.interfaces_ = function() {
        return [N];
      }, L.prototype.getClass = function() {
        return L;
      }, L.compare = function(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : v.isNaN(t2) ? v.isNaN(e2) ? 0 : -1 : v.isNaN(e2) ? 1 : 0;
      };
      var b = function() {
      };
      b.prototype.create = function() {
      }, b.prototype.interfaces_ = function() {
        return [];
      }, b.prototype.getClass = function() {
        return b;
      };
      var w = function() {
      }, O = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
      w.prototype.interfaces_ = function() {
        return [];
      }, w.prototype.getClass = function() {
        return w;
      }, w.toLocationSymbol = function(t2) {
        switch (t2) {
          case w.EXTERIOR:
            return "e";
          case w.BOUNDARY:
            return "b";
          case w.INTERIOR:
            return "i";
          case w.NONE:
            return "-";
        }
        throw new m("Unknown location value: " + t2);
      }, O.INTERIOR.get = function() {
        return 0;
      }, O.BOUNDARY.get = function() {
        return 1;
      }, O.EXTERIOR.get = function() {
        return 2;
      }, O.NONE.get = function() {
        return -1;
      }, Object.defineProperties(w, O);
      var T = function(t2, e2) {
        return t2.interfaces_ && t2.interfaces_().indexOf(e2) > -1;
      }, R = function() {
      }, P = { LOG_10: { configurable: true } };
      R.prototype.interfaces_ = function() {
        return [];
      }, R.prototype.getClass = function() {
        return R;
      }, R.log10 = function(t2) {
        var e2 = Math.log(t2);
        return v.isInfinite(e2) ? e2 : v.isNaN(e2) ? e2 : e2 / R.LOG_10;
      }, R.min = function(t2, e2, n2, i2) {
        var r2 = t2;
        return e2 < r2 && (r2 = e2), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
      }, R.clamp = function() {
        if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          return t2 < e2 ? e2 : t2 > n2 ? n2 : t2;
        }
        if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
          return i2 < r2 ? r2 : i2 > o2 ? o2 : i2;
        }
      }, R.wrap = function(t2, e2) {
        return t2 < 0 ? e2 - -t2 % e2 : t2 % e2;
      }, R.max = function() {
        if (3 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = t2;
          return e2 > i2 && (i2 = e2), n2 > i2 && (i2 = n2), i2;
        }
        if (4 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = r2;
          return o2 > u2 && (u2 = o2), s2 > u2 && (u2 = s2), a2 > u2 && (u2 = a2), u2;
        }
      }, R.average = function(t2, e2) {
        return (t2 + e2) / 2;
      }, P.LOG_10.get = function() {
        return Math.log(10);
      }, Object.defineProperties(R, P);
      var D = function(t2) {
        this.str = t2;
      };
      D.prototype.append = function(t2) {
        this.str += t2;
      }, D.prototype.setCharAt = function(t2, e2) {
        this.str = this.str.substr(0, t2) + e2 + this.str.substr(t2 + 1);
      }, D.prototype.toString = function(t2) {
        return this.str;
      };
      var M = function(t2) {
        this.value = t2;
      };
      M.prototype.intValue = function() {
        return this.value;
      }, M.prototype.compareTo = function(t2) {
        return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
      }, M.isNaN = function(t2) {
        return Number.isNaN(t2);
      };
      var A = function() {
      };
      A.isWhitespace = function(t2) {
        return t2 <= 32 && t2 >= 0 || 127 === t2;
      }, A.toUpperCase = function(t2) {
        return t2.toUpperCase();
      };
      var F = function t2() {
        if (this._hi = 0, this._lo = 0, 0 === arguments.length)
          this.init(0);
        else if (1 === arguments.length) {
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            this.init(e2);
          } else if (arguments[0] instanceof t2) {
            var n2 = arguments[0];
            this.init(n2);
          } else if ("string" == typeof arguments[0]) {
            var i2 = arguments[0];
            t2.call(this, t2.parse(i2));
          }
        } else if (2 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1];
          this.init(r2, o2);
        }
      }, G = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
      F.prototype.le = function(t2) {
        return (this._hi < t2._hi || this._hi === t2._hi) && this._lo <= t2._lo;
      }, F.prototype.extractSignificantDigits = function(t2, e2) {
        var n2 = this.abs(), i2 = F.magnitude(n2._hi), r2 = F.TEN.pow(i2);
        (n2 = n2.divide(r2)).gt(F.TEN) ? (n2 = n2.divide(F.TEN), i2 += 1) : n2.lt(F.ONE) && (n2 = n2.multiply(F.TEN), i2 -= 1);
        for (var o2 = i2 + 1, s2 = new D(), a2 = F.MAX_PRINT_DIGITS - 1, u2 = 0; u2 <= a2; u2++) {
          t2 && u2 === o2 && s2.append(".");
          var l2 = Math.trunc(n2._hi);
          if (l2 < 0)
            break;
          var c2 = false, p2 = 0;
          l2 > 9 ? (c2 = true, p2 = "9") : p2 = "0" + l2, s2.append(p2), n2 = n2.subtract(F.valueOf(l2)).multiply(F.TEN), c2 && n2.selfAdd(F.TEN);
          var h2 = true, f2 = F.magnitude(n2._hi);
          if (f2 < 0 && Math.abs(f2) >= a2 - u2 && (h2 = false), !h2)
            break;
        }
        return e2[0] = i2, s2.toString();
      }, F.prototype.sqr = function() {
        return this.multiply(this);
      }, F.prototype.doubleValue = function() {
        return this._hi + this._lo;
      }, F.prototype.subtract = function() {
        if (arguments[0] instanceof F) {
          var t2 = arguments[0];
          return this.add(t2.negate());
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return this.add(-e2);
        }
      }, F.prototype.equals = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this._hi === t2._hi && this._lo === t2._lo;
        }
      }, F.prototype.isZero = function() {
        return 0 === this._hi && 0 === this._lo;
      }, F.prototype.selfSubtract = function() {
        if (arguments[0] instanceof F) {
          var t2 = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-t2._hi, -t2._lo);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-e2, 0);
        }
      }, F.prototype.getSpecialNumberString = function() {
        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
      }, F.prototype.min = function(t2) {
        return this.le(t2) ? this : t2;
      }, F.prototype.selfDivide = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.selfDivide(t2._hi, t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            return this.selfDivide(e2, 0);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null, c2 = null, p2 = null;
          return u2 = this._hi / n2, l2 = F.SPLIT * u2, r2 = l2 - u2, p2 = F.SPLIT * n2, r2 = l2 - r2, o2 = u2 - r2, s2 = p2 - n2, c2 = u2 * n2, s2 = p2 - s2, a2 = n2 - s2, p2 = r2 * s2 - c2 + r2 * a2 + o2 * s2 + o2 * a2, l2 = (this._hi - c2 - p2 + this._lo - u2 * i2) / n2, p2 = u2 + l2, this._hi = p2, this._lo = u2 - p2 + l2, this;
        }
      }, F.prototype.dump = function() {
        return "DD<" + this._hi + ", " + this._lo + ">";
      }, F.prototype.divide = function() {
        if (arguments[0] instanceof F) {
          var t2 = arguments[0], e2 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null, u2 = null;
          n2 = (o2 = this._hi / t2._hi) - (e2 = (s2 = F.SPLIT * o2) - (e2 = s2 - o2)), u2 = e2 * (i2 = (u2 = F.SPLIT * t2._hi) - (i2 = u2 - t2._hi)) - (a2 = o2 * t2._hi) + e2 * (r2 = t2._hi - i2) + n2 * i2 + n2 * r2, s2 = (this._hi - a2 - u2 + this._lo - o2 * t2._lo) / t2._hi;
          return new F(u2 = o2 + s2, o2 - u2 + s2);
        }
        if ("number" == typeof arguments[0]) {
          var l2 = arguments[0];
          return v.isNaN(l2) ? F.createNaN() : F.copy(this).selfDivide(l2, 0);
        }
      }, F.prototype.ge = function(t2) {
        return (this._hi > t2._hi || this._hi === t2._hi) && this._lo >= t2._lo;
      }, F.prototype.pow = function(t2) {
        if (0 === t2)
          return F.valueOf(1);
        var e2 = new F(this), n2 = F.valueOf(1), i2 = Math.abs(t2);
        if (i2 > 1)
          for (; i2 > 0; )
            i2 % 2 == 1 && n2.selfMultiply(e2), (i2 /= 2) > 0 && (e2 = e2.sqr());
        else
          n2 = e2;
        return t2 < 0 ? n2.reciprocal() : n2;
      }, F.prototype.ceil = function() {
        if (this.isNaN())
          return F.NaN;
        var t2 = Math.ceil(this._hi), e2 = 0;
        return t2 === this._hi && (e2 = Math.ceil(this._lo)), new F(t2, e2);
      }, F.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this._hi < e2._hi ? -1 : this._hi > e2._hi ? 1 : this._lo < e2._lo ? -1 : this._lo > e2._lo ? 1 : 0;
      }, F.prototype.rint = function() {
        if (this.isNaN())
          return this;
        return this.add(0.5).floor();
      }, F.prototype.setValue = function() {
        if (arguments[0] instanceof F) {
          var t2 = arguments[0];
          return this.init(t2), this;
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return this.init(e2), this;
        }
      }, F.prototype.max = function(t2) {
        return this.ge(t2) ? this : t2;
      }, F.prototype.sqrt = function() {
        if (this.isZero())
          return F.valueOf(0);
        if (this.isNegative())
          return F.NaN;
        var t2 = 1 / Math.sqrt(this._hi), e2 = this._hi * t2, n2 = F.valueOf(e2), i2 = this.subtract(n2.sqr())._hi * (0.5 * t2);
        return n2.add(i2);
      }, F.prototype.selfAdd = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.selfAdd(t2._hi, t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0], n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
            return r2 = this._hi + e2, s2 = r2 - this._hi, o2 = r2 - s2, o2 = e2 - s2 + (this._hi - o2), a2 = o2 + this._lo, n2 = r2 + a2, i2 = a2 + (r2 - n2), this._hi = n2 + i2, this._lo = i2 + (n2 - this._hi), this;
          }
        } else if (2 === arguments.length) {
          var u2 = arguments[0], l2 = arguments[1], c2 = null, p2 = null, h2 = null, f2 = null, g2 = null, d2 = null, y2 = null;
          f2 = this._hi + u2, p2 = this._lo + l2, g2 = f2 - (d2 = f2 - this._hi), h2 = p2 - (y2 = p2 - this._lo);
          var _2 = (c2 = f2 + (d2 = (g2 = u2 - d2 + (this._hi - g2)) + p2)) + (d2 = (h2 = l2 - y2 + (this._lo - h2)) + (d2 + (f2 - c2))), m2 = d2 + (c2 - _2);
          return this._hi = _2, this._lo = m2, this;
        }
      }, F.prototype.selfMultiply = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.selfMultiply(t2._hi, t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            return this.selfMultiply(e2, 0);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null;
          r2 = (u2 = F.SPLIT * this._hi) - this._hi, l2 = F.SPLIT * n2, r2 = u2 - r2, o2 = this._hi - r2, s2 = l2 - n2;
          var c2 = (u2 = this._hi * n2) + (l2 = r2 * (s2 = l2 - s2) - u2 + r2 * (a2 = n2 - s2) + o2 * s2 + o2 * a2 + (this._hi * i2 + this._lo * n2)), p2 = l2 + (r2 = u2 - c2);
          return this._hi = c2, this._lo = p2, this;
        }
      }, F.prototype.selfSqr = function() {
        return this.selfMultiply(this);
      }, F.prototype.floor = function() {
        if (this.isNaN())
          return F.NaN;
        var t2 = Math.floor(this._hi), e2 = 0;
        return t2 === this._hi && (e2 = Math.floor(this._lo)), new F(t2, e2);
      }, F.prototype.negate = function() {
        return this.isNaN() ? this : new F(-this._hi, -this._lo);
      }, F.prototype.clone = function() {
      }, F.prototype.multiply = function() {
        if (arguments[0] instanceof F) {
          var t2 = arguments[0];
          return t2.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t2);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return v.isNaN(e2) ? F.createNaN() : F.copy(this).selfMultiply(e2, 0);
        }
      }, F.prototype.isNaN = function() {
        return v.isNaN(this._hi);
      }, F.prototype.intValue = function() {
        return Math.trunc(this._hi);
      }, F.prototype.toString = function() {
        var t2 = F.magnitude(this._hi);
        return t2 >= -3 && t2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
      }, F.prototype.toStandardNotation = function() {
        var t2 = this.getSpecialNumberString();
        if (null !== t2)
          return t2;
        var e2 = new Array(1).fill(null), n2 = this.extractSignificantDigits(true, e2), i2 = e2[0] + 1, r2 = n2;
        if ("." === n2.charAt(0))
          r2 = "0" + n2;
        else if (i2 < 0)
          r2 = "0." + F.stringOfChar("0", -i2) + n2;
        else if (-1 === n2.indexOf(".")) {
          var o2 = i2 - n2.length;
          r2 = n2 + F.stringOfChar("0", o2) + ".0";
        }
        return this.isNegative() ? "-" + r2 : r2;
      }, F.prototype.reciprocal = function() {
        var t2 = null, e2 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
        e2 = (r2 = 1 / this._hi) - (t2 = (o2 = F.SPLIT * r2) - (t2 = o2 - r2)), n2 = (a2 = F.SPLIT * this._hi) - this._hi;
        var u2 = r2 + (o2 = (1 - (s2 = r2 * this._hi) - (a2 = t2 * (n2 = a2 - n2) - s2 + t2 * (i2 = this._hi - n2) + e2 * n2 + e2 * i2) - r2 * this._lo) / this._hi);
        return new F(u2, r2 - u2 + o2);
      }, F.prototype.toSciNotation = function() {
        if (this.isZero())
          return F.SCI_NOT_ZERO;
        var t2 = this.getSpecialNumberString();
        if (null !== t2)
          return t2;
        var e2 = new Array(1).fill(null), n2 = this.extractSignificantDigits(false, e2), i2 = F.SCI_NOT_EXPONENT_CHAR + e2[0];
        if ("0" === n2.charAt(0))
          throw new Error("Found leading zero: " + n2);
        var r2 = "";
        n2.length > 1 && (r2 = n2.substring(1));
        var o2 = n2.charAt(0) + "." + r2;
        return this.isNegative() ? "-" + o2 + i2 : o2 + i2;
      }, F.prototype.abs = function() {
        return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);
      }, F.prototype.isPositive = function() {
        return (this._hi > 0 || 0 === this._hi) && this._lo > 0;
      }, F.prototype.lt = function(t2) {
        return (this._hi < t2._hi || this._hi === t2._hi) && this._lo < t2._lo;
      }, F.prototype.add = function() {
        if (arguments[0] instanceof F) {
          var t2 = arguments[0];
          return F.copy(this).selfAdd(t2);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return F.copy(this).selfAdd(e2);
        }
      }, F.prototype.init = function() {
        if (1 === arguments.length) {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            this._hi = t2, this._lo = 0;
          } else if (arguments[0] instanceof F) {
            var e2 = arguments[0];
            this._hi = e2._hi, this._lo = e2._lo;
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          this._hi = n2, this._lo = i2;
        }
      }, F.prototype.gt = function(t2) {
        return (this._hi > t2._hi || this._hi === t2._hi) && this._lo > t2._lo;
      }, F.prototype.isNegative = function() {
        return (this._hi < 0 || 0 === this._hi) && this._lo < 0;
      }, F.prototype.trunc = function() {
        return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();
      }, F.prototype.signum = function() {
        return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
      }, F.prototype.interfaces_ = function() {
        return [e, E, x];
      }, F.prototype.getClass = function() {
        return F;
      }, F.sqr = function(t2) {
        return F.valueOf(t2).selfMultiply(t2);
      }, F.valueOf = function() {
        if ("string" == typeof arguments[0]) {
          var t2 = arguments[0];
          return F.parse(t2);
        }
        if ("number" == typeof arguments[0]) {
          var e2 = arguments[0];
          return new F(e2);
        }
      }, F.sqrt = function(t2) {
        return F.valueOf(t2).sqrt();
      }, F.parse = function(t2) {
        for (var e2 = 0, n2 = t2.length; A.isWhitespace(t2.charAt(e2)); )
          e2++;
        var i2 = false;
        if (e2 < n2) {
          var r2 = t2.charAt(e2);
          "-" !== r2 && "+" !== r2 || (e2++, "-" === r2 && (i2 = true));
        }
        for (var o2 = new F(), s2 = 0, a2 = 0, u2 = 0; !(e2 >= n2); ) {
          var l2 = t2.charAt(e2);
          if (e2++, A.isDigit(l2)) {
            var c2 = l2 - "0";
            o2.selfMultiply(F.TEN), o2.selfAdd(c2), s2++;
          } else {
            if ("." !== l2) {
              if ("e" === l2 || "E" === l2) {
                var p2 = t2.substring(e2);
                try {
                  u2 = M.parseInt(p2);
                } catch (e3) {
                  throw e3 instanceof Error ? new Error("Invalid exponent " + p2 + " in string " + t2) : e3;
                }
                break;
              }
              throw new Error("Unexpected character '" + l2 + "' at position " + e2 + " in string " + t2);
            }
            a2 = s2;
          }
        }
        var h2 = o2, f2 = s2 - a2 - u2;
        if (0 === f2)
          h2 = o2;
        else if (f2 > 0) {
          var g2 = F.TEN.pow(f2);
          h2 = o2.divide(g2);
        } else if (f2 < 0) {
          var d2 = F.TEN.pow(-f2);
          h2 = o2.multiply(d2);
        }
        return i2 ? h2.negate() : h2;
      }, F.createNaN = function() {
        return new F(v.NaN, v.NaN);
      }, F.copy = function(t2) {
        return new F(t2);
      }, F.magnitude = function(t2) {
        var e2 = Math.abs(t2), n2 = Math.log(e2) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
        return 10 * Math.pow(10, i2) <= e2 && (i2 += 1), i2;
      }, F.stringOfChar = function(t2, e2) {
        for (var n2 = new D(), i2 = 0; i2 < e2; i2++)
          n2.append(t2);
        return n2.toString();
      }, G.PI.get = function() {
        return new F(3.141592653589793, 12246467991473532e-32);
      }, G.TWO_PI.get = function() {
        return new F(6.283185307179586, 24492935982947064e-32);
      }, G.PI_2.get = function() {
        return new F(1.5707963267948966, 6123233995736766e-32);
      }, G.E.get = function() {
        return new F(2.718281828459045, 14456468917292502e-32);
      }, G.NaN.get = function() {
        return new F(v.NaN, v.NaN);
      }, G.EPS.get = function() {
        return 123259516440783e-46;
      }, G.SPLIT.get = function() {
        return 134217729;
      }, G.MAX_PRINT_DIGITS.get = function() {
        return 32;
      }, G.TEN.get = function() {
        return F.valueOf(10);
      }, G.ONE.get = function() {
        return F.valueOf(1);
      }, G.SCI_NOT_EXPONENT_CHAR.get = function() {
        return "E";
      }, G.SCI_NOT_ZERO.get = function() {
        return "0.0E0";
      }, Object.defineProperties(F, G);
      var q = function() {
      }, B = { DP_SAFE_EPSILON: { configurable: true } };
      q.prototype.interfaces_ = function() {
        return [];
      }, q.prototype.getClass = function() {
        return q;
      }, q.orientationIndex = function(t2, e2, n2) {
        var i2 = q.orientationIndexFilter(t2, e2, n2);
        if (i2 <= 1)
          return i2;
        var r2 = F.valueOf(e2.x).selfAdd(-t2.x), o2 = F.valueOf(e2.y).selfAdd(-t2.y), s2 = F.valueOf(n2.x).selfAdd(-e2.x), a2 = F.valueOf(n2.y).selfAdd(-e2.y);
        return r2.selfMultiply(a2).selfSubtract(o2.selfMultiply(s2)).signum();
      }, q.signOfDet2x2 = function(t2, e2, n2, i2) {
        return t2.multiply(i2).selfSubtract(e2.multiply(n2)).signum();
      }, q.intersection = function(t2, e2, n2, i2) {
        var r2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(e2.x).selfSubtract(t2.x)), o2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(e2.y).selfSubtract(t2.y)), s2 = r2.subtract(o2), a2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), u2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), l2 = a2.subtract(u2).selfDivide(s2).doubleValue(), c2 = F.valueOf(t2.x).selfAdd(F.valueOf(e2.x).selfSubtract(t2.x).selfMultiply(l2)).doubleValue(), p2 = F.valueOf(e2.x).selfSubtract(t2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), h2 = F.valueOf(e2.y).selfSubtract(t2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), f2 = p2.subtract(h2).selfDivide(s2).doubleValue(), g2 = F.valueOf(n2.y).selfAdd(F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(f2)).doubleValue();
        return new C(c2, g2);
      }, q.orientationIndexFilter = function(t2, e2, n2) {
        var i2 = null, r2 = (t2.x - n2.x) * (e2.y - n2.y), o2 = (t2.y - n2.y) * (e2.x - n2.x), s2 = r2 - o2;
        if (r2 > 0) {
          if (o2 <= 0)
            return q.signum(s2);
          i2 = r2 + o2;
        } else {
          if (!(r2 < 0))
            return q.signum(s2);
          if (o2 >= 0)
            return q.signum(s2);
          i2 = -r2 - o2;
        }
        var a2 = q.DP_SAFE_EPSILON * i2;
        return s2 >= a2 || -s2 >= a2 ? q.signum(s2) : 2;
      }, q.signum = function(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }, B.DP_SAFE_EPSILON.get = function() {
        return 1e-15;
      }, Object.defineProperties(q, B);
      var V = function() {
      }, U = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
      U.X.get = function() {
        return 0;
      }, U.Y.get = function() {
        return 1;
      }, U.Z.get = function() {
        return 2;
      }, U.M.get = function() {
        return 3;
      }, V.prototype.setOrdinate = function(t2, e2, n2) {
      }, V.prototype.size = function() {
      }, V.prototype.getOrdinate = function(t2, e2) {
      }, V.prototype.getCoordinate = function() {
      }, V.prototype.getCoordinateCopy = function(t2) {
      }, V.prototype.getDimension = function() {
      }, V.prototype.getX = function(t2) {
      }, V.prototype.clone = function() {
      }, V.prototype.expandEnvelope = function(t2) {
      }, V.prototype.copy = function() {
      }, V.prototype.getY = function(t2) {
      }, V.prototype.toCoordinateArray = function() {
      }, V.prototype.interfaces_ = function() {
        return [x];
      }, V.prototype.getClass = function() {
        return V;
      }, Object.defineProperties(V, U);
      var z = function() {
      }, X = function(t2) {
        function e2() {
          t2.call(this, "Projective point not representable on the Cartesian plane.");
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(z), Y = function() {
      };
      Y.arraycopy = function(t2, e2, n2, i2, r2) {
        for (var o2 = 0, s2 = e2; s2 < e2 + r2; s2++)
          n2[i2 + o2] = t2[s2], o2++;
      }, Y.getProperty = function(t2) {
        return { "line.separator": "\n" }[t2];
      };
      var k = function t2() {
        if (this.x = null, this.y = null, this.w = null, 0 === arguments.length)
          this.x = 0, this.y = 0, this.w = 1;
        else if (1 === arguments.length) {
          var e2 = arguments[0];
          this.x = e2.x, this.y = e2.y, this.w = 1;
        } else if (2 === arguments.length) {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var n2 = arguments[0], i2 = arguments[1];
            this.x = n2, this.y = i2, this.w = 1;
          } else if (arguments[0] instanceof t2 && arguments[1] instanceof t2) {
            var r2 = arguments[0], o2 = arguments[1];
            this.x = r2.y * o2.w - o2.y * r2.w, this.y = o2.x * r2.w - r2.x * o2.w, this.w = r2.x * o2.y - o2.x * r2.y;
          } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var s2 = arguments[0], a2 = arguments[1];
            this.x = s2.y - a2.y, this.y = a2.x - s2.x, this.w = s2.x * a2.y - a2.x * s2.y;
          }
        } else if (3 === arguments.length) {
          var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
          this.x = u2, this.y = l2, this.w = c2;
        } else if (4 === arguments.length) {
          var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2], g2 = arguments[3], d2 = p2.y - h2.y, y2 = h2.x - p2.x, _2 = p2.x * h2.y - h2.x * p2.y, m2 = f2.y - g2.y, v2 = g2.x - f2.x, I2 = f2.x * g2.y - g2.x * f2.y;
          this.x = y2 * I2 - v2 * _2, this.y = m2 * _2 - d2 * I2, this.w = d2 * v2 - m2 * y2;
        }
      };
      k.prototype.getY = function() {
        var t2 = this.y / this.w;
        if (v.isNaN(t2) || v.isInfinite(t2))
          throw new X();
        return t2;
      }, k.prototype.getX = function() {
        var t2 = this.x / this.w;
        if (v.isNaN(t2) || v.isInfinite(t2))
          throw new X();
        return t2;
      }, k.prototype.getCoordinate = function() {
        var t2 = new C();
        return t2.x = this.getX(), t2.y = this.getY(), t2;
      }, k.prototype.interfaces_ = function() {
        return [];
      }, k.prototype.getClass = function() {
        return k;
      }, k.intersection = function(t2, e2, n2, i2) {
        var r2 = t2.y - e2.y, o2 = e2.x - t2.x, s2 = t2.x * e2.y - e2.x * t2.y, a2 = n2.y - i2.y, u2 = i2.x - n2.x, l2 = n2.x * i2.y - i2.x * n2.y, c2 = r2 * u2 - a2 * o2, p2 = (o2 * l2 - u2 * s2) / c2, h2 = (a2 * s2 - r2 * l2) / c2;
        if (v.isNaN(p2) || v.isInfinite(p2) || v.isNaN(h2) || v.isInfinite(h2))
          throw new X();
        return new C(p2, h2);
      };
      var j = function t2() {
        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length)
          this.init();
        else if (1 === arguments.length) {
          if (arguments[0] instanceof C) {
            var e2 = arguments[0];
            this.init(e2.x, e2.x, e2.y, e2.y);
          } else if (arguments[0] instanceof t2) {
            var n2 = arguments[0];
            this.init(n2);
          }
        } else if (2 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1];
          this.init(i2.x, r2.x, i2.y, r2.y);
        } else if (4 === arguments.length) {
          var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = arguments[3];
          this.init(o2, s2, a2, u2);
        }
      }, H = { serialVersionUID: { configurable: true } };
      j.prototype.getArea = function() {
        return this.getWidth() * this.getHeight();
      }, j.prototype.equals = function(t2) {
        if (!(t2 instanceof j))
          return false;
        var e2 = t2;
        return this.isNull() ? e2.isNull() : this._maxx === e2.getMaxX() && this._maxy === e2.getMaxY() && this._minx === e2.getMinX() && this._miny === e2.getMinY();
      }, j.prototype.intersection = function(t2) {
        if (this.isNull() || t2.isNull() || !this.intersects(t2))
          return new j();
        var e2 = this._minx > t2._minx ? this._minx : t2._minx, n2 = this._miny > t2._miny ? this._miny : t2._miny, i2 = this._maxx < t2._maxx ? this._maxx : t2._maxx, r2 = this._maxy < t2._maxy ? this._maxy : t2._maxy;
        return new j(e2, i2, n2, r2);
      }, j.prototype.isNull = function() {
        return this._maxx < this._minx;
      }, j.prototype.getMaxX = function() {
        return this._maxx;
      }, j.prototype.covers = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            return this.covers(t2.x, t2.y);
          }
          if (arguments[0] instanceof j) {
            var e2 = arguments[0];
            return !this.isNull() && !e2.isNull() && (e2.getMinX() >= this._minx && e2.getMaxX() <= this._maxx && e2.getMinY() >= this._miny && e2.getMaxY() <= this._maxy);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          return !this.isNull() && (n2 >= this._minx && n2 <= this._maxx && i2 >= this._miny && i2 <= this._maxy);
        }
      }, j.prototype.intersects = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof j) {
            var t2 = arguments[0];
            return !this.isNull() && !t2.isNull() && !(t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
          }
          if (arguments[0] instanceof C) {
            var e2 = arguments[0];
            return this.intersects(e2.x, e2.y);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          return !this.isNull() && !(n2 > this._maxx || n2 < this._minx || i2 > this._maxy || i2 < this._miny);
        }
      }, j.prototype.getMinY = function() {
        return this._miny;
      }, j.prototype.getMinX = function() {
        return this._minx;
      }, j.prototype.expandToInclude = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            this.expandToInclude(t2.x, t2.y);
          } else if (arguments[0] instanceof j) {
            var e2 = arguments[0];
            if (e2.isNull())
              return null;
            this.isNull() ? (this._minx = e2.getMinX(), this._maxx = e2.getMaxX(), this._miny = e2.getMinY(), this._maxy = e2.getMaxY()) : (e2._minx < this._minx && (this._minx = e2._minx), e2._maxx > this._maxx && (this._maxx = e2._maxx), e2._miny < this._miny && (this._miny = e2._miny), e2._maxy > this._maxy && (this._maxy = e2._maxy));
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          this.isNull() ? (this._minx = n2, this._maxx = n2, this._miny = i2, this._maxy = i2) : (n2 < this._minx && (this._minx = n2), n2 > this._maxx && (this._maxx = n2), i2 < this._miny && (this._miny = i2), i2 > this._maxy && (this._maxy = i2));
        }
      }, j.prototype.minExtent = function() {
        if (this.isNull())
          return 0;
        var t2 = this.getWidth(), e2 = this.getHeight();
        return t2 < e2 ? t2 : e2;
      }, j.prototype.getWidth = function() {
        return this.isNull() ? 0 : this._maxx - this._minx;
      }, j.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this.isNull() ? e2.isNull() ? 0 : -1 : e2.isNull() ? 1 : this._minx < e2._minx ? -1 : this._minx > e2._minx ? 1 : this._miny < e2._miny ? -1 : this._miny > e2._miny ? 1 : this._maxx < e2._maxx ? -1 : this._maxx > e2._maxx ? 1 : this._maxy < e2._maxy ? -1 : this._maxy > e2._maxy ? 1 : 0;
      }, j.prototype.translate = function(t2, e2) {
        if (this.isNull())
          return null;
        this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e2, this.getMaxY() + e2);
      }, j.prototype.toString = function() {
        return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
      }, j.prototype.setToNull = function() {
        this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
      }, j.prototype.getHeight = function() {
        return this.isNull() ? 0 : this._maxy - this._miny;
      }, j.prototype.maxExtent = function() {
        if (this.isNull())
          return 0;
        var t2 = this.getWidth(), e2 = this.getHeight();
        return t2 > e2 ? t2 : e2;
      }, j.prototype.expandBy = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.expandBy(t2, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (this.isNull())
            return null;
          this._minx -= e2, this._maxx += e2, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
        }
      }, j.prototype.contains = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof j) {
            var t2 = arguments[0];
            return this.covers(t2);
          }
          if (arguments[0] instanceof C) {
            var e2 = arguments[0];
            return this.covers(e2);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          return this.covers(n2, i2);
        }
      }, j.prototype.centre = function() {
        return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
      }, j.prototype.init = function() {
        if (0 === arguments.length)
          this.setToNull();
        else if (1 === arguments.length) {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            this.init(t2.x, t2.x, t2.y, t2.y);
          } else if (arguments[0] instanceof j) {
            var e2 = arguments[0];
            this._minx = e2._minx, this._maxx = e2._maxx, this._miny = e2._miny, this._maxy = e2._maxy;
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          this.init(n2.x, i2.x, n2.y, i2.y);
        } else if (4 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
          r2 < o2 ? (this._minx = r2, this._maxx = o2) : (this._minx = o2, this._maxx = r2), s2 < a2 ? (this._miny = s2, this._maxy = a2) : (this._miny = a2, this._maxy = s2);
        }
      }, j.prototype.getMaxY = function() {
        return this._maxy;
      }, j.prototype.distance = function(t2) {
        if (this.intersects(t2))
          return 0;
        var e2 = 0;
        this._maxx < t2._minx ? e2 = t2._minx - this._maxx : this._minx > t2._maxx && (e2 = this._minx - t2._maxx);
        var n2 = 0;
        return this._maxy < t2._miny ? n2 = t2._miny - this._maxy : this._miny > t2._maxy && (n2 = this._miny - t2._maxy), 0 === e2 ? n2 : 0 === n2 ? e2 : Math.sqrt(e2 * e2 + n2 * n2);
      }, j.prototype.hashCode = function() {
        var t2 = 17;
        return t2 = 37 * t2 + C.hashCode(this._minx), t2 = 37 * t2 + C.hashCode(this._maxx), t2 = 37 * t2 + C.hashCode(this._miny), t2 = 37 * t2 + C.hashCode(this._maxy);
      }, j.prototype.interfaces_ = function() {
        return [E, e];
      }, j.prototype.getClass = function() {
        return j;
      }, j.intersects = function() {
        if (3 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          return n2.x >= (t2.x < e2.x ? t2.x : e2.x) && n2.x <= (t2.x > e2.x ? t2.x : e2.x) && n2.y >= (t2.y < e2.y ? t2.y : e2.y) && n2.y <= (t2.y > e2.y ? t2.y : e2.y);
        }
        if (4 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = Math.min(o2.x, s2.x), u2 = Math.max(o2.x, s2.x), l2 = Math.min(i2.x, r2.x), c2 = Math.max(i2.x, r2.x);
          return !(l2 > u2) && (!(c2 < a2) && (a2 = Math.min(o2.y, s2.y), u2 = Math.max(o2.y, s2.y), l2 = Math.min(i2.y, r2.y), c2 = Math.max(i2.y, r2.y), !(l2 > u2) && !(c2 < a2)));
        }
      }, H.serialVersionUID.get = function() {
        return 5873921885273102e3;
      }, Object.defineProperties(j, H);
      var W = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }, K = function(t2) {
        this.geometryFactory = t2 || new _e();
      };
      K.prototype.read = function(t2) {
        var e2, n2, i2;
        t2 = t2.replace(/[\n\r]/g, " ");
        var r2 = W.typeStr.exec(t2);
        if (-1 !== t2.search("EMPTY") && ((r2 = W.emptyTypeStr.exec(t2))[2] = void 0), r2 && (n2 = r2[1].toLowerCase(), i2 = r2[2], Q[n2] && (e2 = Q[n2].apply(this, [i2]))), void 0 === e2)
          throw new Error("Could not parse WKT " + t2);
        return e2;
      }, K.prototype.write = function(t2) {
        return this.extractGeometry(t2);
      }, K.prototype.extractGeometry = function(t2) {
        var e2 = t2.getGeometryType().toLowerCase();
        if (!J[e2])
          return null;
        var n2 = e2.toUpperCase();
        return t2.isEmpty() ? n2 + " EMPTY" : n2 + "(" + J[e2].apply(this, [t2]) + ")";
      };
      var J = { coordinate: function(t2) {
        return t2.x + " " + t2.y;
      }, point: function(t2) {
        return J.coordinate.call(this, t2._coordinates._coordinates[0]);
      }, multipoint: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
          e2.push("(" + J.point.apply(this, [t2._geometries[n2]]) + ")");
        return e2.join(",");
      }, linestring: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
          e2.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
        return e2.join(",");
      }, linearring: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
          e2.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
        return e2.join(",");
      }, multilinestring: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
          e2.push("(" + J.linestring.apply(this, [t2._geometries[n2]]) + ")");
        return e2.join(",");
      }, polygon: function(t2) {
        var e2 = [];
        e2.push("(" + J.linestring.apply(this, [t2._shell]) + ")");
        for (var n2 = 0, i2 = t2._holes.length; n2 < i2; ++n2)
          e2.push("(" + J.linestring.apply(this, [t2._holes[n2]]) + ")");
        return e2.join(",");
      }, multipolygon: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
          e2.push("(" + J.polygon.apply(this, [t2._geometries[n2]]) + ")");
        return e2.join(",");
      }, geometrycollection: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
          e2.push(this.extractGeometry(t2._geometries[n2]));
        return e2.join(",");
      } }, Q = { point: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createPoint();
        var e2 = t2.trim().split(W.spaces);
        return this.geometryFactory.createPoint(new C(Number.parseFloat(e2[0]), Number.parseFloat(e2[1])));
      }, multipoint: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createMultiPoint();
        for (var e2, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
          e2 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.point.apply(this, [e2]));
        return this.geometryFactory.createMultiPoint(i2);
      }, linestring: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createLineString();
        for (var e2, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
          e2 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e2[0]), Number.parseFloat(e2[1])));
        return this.geometryFactory.createLineString(i2);
      }, linearring: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createLinearRing();
        for (var e2, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
          e2 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e2[0]), Number.parseFloat(e2[1])));
        return this.geometryFactory.createLinearRing(i2);
      }, multilinestring: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createMultiLineString();
        for (var e2, n2 = t2.trim().split(W.parenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
          e2 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.linestring.apply(this, [e2]));
        return this.geometryFactory.createMultiLineString(i2);
      }, polygon: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createPolygon();
        for (var e2, n2, i2, r2, o2 = t2.trim().split(W.parenComma), s2 = [], a2 = 0, u2 = o2.length; a2 < u2; ++a2)
          e2 = o2[a2].replace(W.trimParens, "$1"), n2 = Q.linestring.apply(this, [e2]), i2 = this.geometryFactory.createLinearRing(n2._points), 0 === a2 ? r2 = i2 : s2.push(i2);
        return this.geometryFactory.createPolygon(r2, s2);
      }, multipolygon: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createMultiPolygon();
        for (var e2, n2 = t2.trim().split(W.doubleParenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
          e2 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.polygon.apply(this, [e2]));
        return this.geometryFactory.createMultiPolygon(i2);
      }, geometrycollection: function(t2) {
        if (void 0 === t2)
          return this.geometryFactory.createGeometryCollection();
        for (var e2 = (t2 = t2.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n2 = [], i2 = 0, r2 = e2.length; i2 < r2; ++i2)
          n2.push(this.read(e2[i2]));
        return this.geometryFactory.createGeometryCollection(n2);
      } }, Z = function(t2) {
        this.parser = new K(t2);
      };
      Z.prototype.write = function(t2) {
        return this.parser.write(t2);
      }, Z.toLineString = function(t2, e2) {
        if (2 !== arguments.length)
          throw new Error("Not implemented");
        return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e2.x + " " + e2.y + " )";
      };
      var $ = function(t2) {
        function e2(e3) {
          t2.call(this, e3), this.name = "RuntimeException", this.message = e3, this.stack = new t2().stack;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
      }(Error), tt = function(t2) {
        function e2() {
          if (t2.call(this), 0 === arguments.length)
            t2.call(this);
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            t2.call(this, e3);
          }
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }($), et = function() {
      };
      et.prototype.interfaces_ = function() {
        return [];
      }, et.prototype.getClass = function() {
        return et;
      }, et.shouldNeverReachHere = function() {
        if (0 === arguments.length)
          et.shouldNeverReachHere(null);
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          throw new tt("Should never reach here" + (null !== t2 ? ": " + t2 : ""));
        }
      }, et.isTrue = function() {
        var t2, e2;
        if (1 === arguments.length)
          t2 = arguments[0], et.isTrue(t2, null);
        else if (2 === arguments.length && (t2 = arguments[0], e2 = arguments[1], !t2))
          throw null === e2 ? new tt() : new tt(e2);
      }, et.equals = function() {
        var t2, e2, n2;
        if (2 === arguments.length)
          t2 = arguments[0], e2 = arguments[1], et.equals(t2, e2, null);
        else if (3 === arguments.length && (t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], !e2.equals(t2)))
          throw new tt("Expected " + t2 + " but encountered " + e2 + (null !== n2 ? ": " + n2 : ""));
      };
      var nt = function() {
        this._result = null, this._inputLines = Array(2).fill().map(function() {
          return Array(2);
        }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
      }, it = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
      nt.prototype.getIndexAlongSegment = function(t2, e2) {
        return this.computeIntLineIndex(), this._intLineIndex[t2][e2];
      }, nt.prototype.getTopologySummary = function() {
        var t2 = new D();
        return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
      }, nt.prototype.computeIntersection = function(t2, e2, n2, i2) {
        this._inputLines[0][0] = t2, this._inputLines[0][1] = e2, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t2, e2, n2, i2);
      }, nt.prototype.getIntersectionNum = function() {
        return this._result;
      }, nt.prototype.computeIntLineIndex = function() {
        if (0 === arguments.length)
          null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
            return Array(2);
          }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.getEdgeDistance(t2, 0) > this.getEdgeDistance(t2, 1) ? (this._intLineIndex[t2][0] = 0, this._intLineIndex[t2][1] = 1) : (this._intLineIndex[t2][0] = 1, this._intLineIndex[t2][1] = 0);
        }
      }, nt.prototype.isProper = function() {
        return this.hasIntersection() && this._isProper;
      }, nt.prototype.setPrecisionModel = function(t2) {
        this._precisionModel = t2;
      }, nt.prototype.isInteriorIntersection = function() {
        if (0 === arguments.length)
          return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = 0; e2 < this._result; e2++)
            if (!this._intPt[e2].equals2D(this._inputLines[t2][0]) && !this._intPt[e2].equals2D(this._inputLines[t2][1]))
              return true;
          return false;
        }
      }, nt.prototype.getIntersection = function(t2) {
        return this._intPt[t2];
      }, nt.prototype.isEndPoint = function() {
        return this.hasIntersection() && !this._isProper;
      }, nt.prototype.hasIntersection = function() {
        return this._result !== nt.NO_INTERSECTION;
      }, nt.prototype.getEdgeDistance = function(t2, e2) {
        return nt.computeEdgeDistance(this._intPt[e2], this._inputLines[t2][0], this._inputLines[t2][1]);
      }, nt.prototype.isCollinear = function() {
        return this._result === nt.COLLINEAR_INTERSECTION;
      }, nt.prototype.toString = function() {
        return Z.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Z.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
      }, nt.prototype.getEndpoint = function(t2, e2) {
        return this._inputLines[t2][e2];
      }, nt.prototype.isIntersection = function(t2) {
        for (var e2 = 0; e2 < this._result; e2++)
          if (this._intPt[e2].equals2D(t2))
            return true;
        return false;
      }, nt.prototype.getIntersectionAlongSegment = function(t2, e2) {
        return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t2][e2]];
      }, nt.prototype.interfaces_ = function() {
        return [];
      }, nt.prototype.getClass = function() {
        return nt;
      }, nt.computeEdgeDistance = function(t2, e2, n2) {
        var i2 = Math.abs(n2.x - e2.x), r2 = Math.abs(n2.y - e2.y), o2 = -1;
        if (t2.equals(e2))
          o2 = 0;
        else if (t2.equals(n2))
          o2 = i2 > r2 ? i2 : r2;
        else {
          var s2 = Math.abs(t2.x - e2.x), a2 = Math.abs(t2.y - e2.y);
          0 !== (o2 = i2 > r2 ? s2 : a2) || t2.equals(e2) || (o2 = Math.max(s2, a2));
        }
        return et.isTrue(!(0 === o2 && !t2.equals(e2)), "Bad distance calculation"), o2;
      }, nt.nonRobustComputeEdgeDistance = function(t2, e2, n2) {
        var i2 = t2.x - e2.x, r2 = t2.y - e2.y, o2 = Math.sqrt(i2 * i2 + r2 * r2);
        return et.isTrue(!(0 === o2 && !t2.equals(e2)), "Invalid distance calculation"), o2;
      }, it.DONT_INTERSECT.get = function() {
        return 0;
      }, it.DO_INTERSECT.get = function() {
        return 1;
      }, it.COLLINEAR.get = function() {
        return 2;
      }, it.NO_INTERSECTION.get = function() {
        return 0;
      }, it.POINT_INTERSECTION.get = function() {
        return 1;
      }, it.COLLINEAR_INTERSECTION.get = function() {
        return 2;
      }, Object.defineProperties(nt, it);
      var rt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.isInSegmentEnvelopes = function(t3) {
          var e3 = new j(this._inputLines[0][0], this._inputLines[0][1]), n2 = new j(this._inputLines[1][0], this._inputLines[1][1]);
          return e3.contains(t3) && n2.contains(t3);
        }, e2.prototype.computeIntersection = function() {
          if (3 !== arguments.length)
            return t2.prototype.computeIntersection.apply(this, arguments);
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          if (this._isProper = false, j.intersects(n2, i2, e3) && 0 === at.orientationIndex(n2, i2, e3) && 0 === at.orientationIndex(i2, n2, e3))
            return this._isProper = true, (e3.equals(n2) || e3.equals(i2)) && (this._isProper = false), this._result = t2.POINT_INTERSECTION, null;
          this._result = t2.NO_INTERSECTION;
        }, e2.prototype.normalizeToMinimum = function(t3, e3, n2, i2, r2) {
          r2.x = this.smallestInAbsValue(t3.x, e3.x, n2.x, i2.x), r2.y = this.smallestInAbsValue(t3.y, e3.y, n2.y, i2.y), t3.x -= r2.x, t3.y -= r2.y, e3.x -= r2.x, e3.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
        }, e2.prototype.safeHCoordinateIntersection = function(t3, n2, i2, r2) {
          var o2 = null;
          try {
            o2 = k.intersection(t3, n2, i2, r2);
          } catch (s2) {
            if (!(s2 instanceof X))
              throw s2;
            o2 = e2.nearestEndpoint(t3, n2, i2, r2);
          }
          return o2;
        }, e2.prototype.intersection = function(t3, n2, i2, r2) {
          var o2 = this.intersectionWithNormalization(t3, n2, i2, r2);
          return this.isInSegmentEnvelopes(o2) || (o2 = new C(e2.nearestEndpoint(t3, n2, i2, r2))), null !== this._precisionModel && this._precisionModel.makePrecise(o2), o2;
        }, e2.prototype.smallestInAbsValue = function(t3, e3, n2, i2) {
          var r2 = t3, o2 = Math.abs(r2);
          return Math.abs(e3) < o2 && (r2 = e3, o2 = Math.abs(e3)), Math.abs(n2) < o2 && (r2 = n2, o2 = Math.abs(n2)), Math.abs(i2) < o2 && (r2 = i2), r2;
        }, e2.prototype.checkDD = function(t3, e3, n2, i2, r2) {
          var o2 = q.intersection(t3, e3, n2, i2), s2 = this.isInSegmentEnvelopes(o2);
          Y.out.println("DD in env = " + s2 + "  --------------------- " + o2), r2.distance(o2) > 1e-4 && Y.out.println("Distance = " + r2.distance(o2));
        }, e2.prototype.intersectionWithNormalization = function(t3, e3, n2, i2) {
          var r2 = new C(t3), o2 = new C(e3), s2 = new C(n2), a2 = new C(i2), u2 = new C();
          this.normalizeToEnvCentre(r2, o2, s2, a2, u2);
          var l2 = this.safeHCoordinateIntersection(r2, o2, s2, a2);
          return l2.x += u2.x, l2.y += u2.y, l2;
        }, e2.prototype.computeCollinearIntersection = function(e3, n2, i2, r2) {
          var o2 = j.intersects(e3, n2, i2), s2 = j.intersects(e3, n2, r2), a2 = j.intersects(i2, r2, e3), u2 = j.intersects(i2, r2, n2);
          return o2 && s2 ? (this._intPt[0] = i2, this._intPt[1] = r2, t2.COLLINEAR_INTERSECTION) : a2 && u2 ? (this._intPt[0] = e3, this._intPt[1] = n2, t2.COLLINEAR_INTERSECTION) : o2 && a2 ? (this._intPt[0] = i2, this._intPt[1] = e3, !i2.equals(e3) || s2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : o2 && u2 ? (this._intPt[0] = i2, this._intPt[1] = n2, !i2.equals(n2) || s2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && a2 ? (this._intPt[0] = r2, this._intPt[1] = e3, !r2.equals(e3) || o2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && u2 ? (this._intPt[0] = r2, this._intPt[1] = n2, !r2.equals(n2) || o2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : t2.NO_INTERSECTION;
        }, e2.prototype.normalizeToEnvCentre = function(t3, e3, n2, i2, r2) {
          var o2 = t3.x < e3.x ? t3.x : e3.x, s2 = t3.y < e3.y ? t3.y : e3.y, a2 = t3.x > e3.x ? t3.x : e3.x, u2 = t3.y > e3.y ? t3.y : e3.y, l2 = n2.x < i2.x ? n2.x : i2.x, c2 = n2.y < i2.y ? n2.y : i2.y, p2 = n2.x > i2.x ? n2.x : i2.x, h2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((o2 > l2 ? o2 : l2) + (a2 < p2 ? a2 : p2)) / 2, g2 = ((s2 > c2 ? s2 : c2) + (u2 < h2 ? u2 : h2)) / 2;
          r2.x = f2, r2.y = g2, t3.x -= r2.x, t3.y -= r2.y, e3.x -= r2.x, e3.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
        }, e2.prototype.computeIntersect = function(e3, n2, i2, r2) {
          if (this._isProper = false, !j.intersects(e3, n2, i2, r2))
            return t2.NO_INTERSECTION;
          var o2 = at.orientationIndex(e3, n2, i2), s2 = at.orientationIndex(e3, n2, r2);
          if (o2 > 0 && s2 > 0 || o2 < 0 && s2 < 0)
            return t2.NO_INTERSECTION;
          var a2 = at.orientationIndex(i2, r2, e3), u2 = at.orientationIndex(i2, r2, n2);
          if (a2 > 0 && u2 > 0 || a2 < 0 && u2 < 0)
            return t2.NO_INTERSECTION;
          return 0 === o2 && 0 === s2 && 0 === a2 && 0 === u2 ? this.computeCollinearIntersection(e3, n2, i2, r2) : (0 === o2 || 0 === s2 || 0 === a2 || 0 === u2 ? (this._isProper = false, e3.equals2D(i2) || e3.equals2D(r2) ? this._intPt[0] = e3 : n2.equals2D(i2) || n2.equals2D(r2) ? this._intPt[0] = n2 : 0 === o2 ? this._intPt[0] = new C(i2) : 0 === s2 ? this._intPt[0] = new C(r2) : 0 === a2 ? this._intPt[0] = new C(e3) : 0 === u2 && (this._intPt[0] = new C(n2))) : (this._isProper = true, this._intPt[0] = this.intersection(e3, n2, i2, r2)), t2.POINT_INTERSECTION);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2.nearestEndpoint = function(t3, e3, n2, i2) {
          var r2 = t3, o2 = at.distancePointLine(t3, n2, i2), s2 = at.distancePointLine(e3, n2, i2);
          return s2 < o2 && (o2 = s2, r2 = e3), (s2 = at.distancePointLine(n2, t3, e3)) < o2 && (o2 = s2, r2 = n2), (s2 = at.distancePointLine(i2, t3, e3)) < o2 && (o2 = s2, r2 = i2), r2;
        }, e2;
      }(nt), ot = function() {
      };
      ot.prototype.interfaces_ = function() {
        return [];
      }, ot.prototype.getClass = function() {
        return ot;
      }, ot.orientationIndex = function(t2, e2, n2) {
        var i2 = e2.x - t2.x, r2 = e2.y - t2.y, o2 = n2.x - e2.x, s2 = n2.y - e2.y;
        return ot.signOfDet2x2(i2, r2, o2, s2);
      }, ot.signOfDet2x2 = function(t2, e2, n2, i2) {
        var r2 = null, o2 = null, s2 = null;
        if (r2 = 1, 0 === t2 || 0 === i2)
          return 0 === e2 || 0 === n2 ? 0 : e2 > 0 ? n2 > 0 ? -r2 : r2 : n2 > 0 ? r2 : -r2;
        if (0 === e2 || 0 === n2)
          return i2 > 0 ? t2 > 0 ? r2 : -r2 : t2 > 0 ? -r2 : r2;
        if (e2 > 0 ? i2 > 0 ? e2 <= i2 || (r2 = -r2, o2 = t2, t2 = n2, n2 = o2, o2 = e2, e2 = i2, i2 = o2) : e2 <= -i2 ? (r2 = -r2, n2 = -n2, i2 = -i2) : (o2 = t2, t2 = -n2, n2 = o2, o2 = e2, e2 = -i2, i2 = o2) : i2 > 0 ? -e2 <= i2 ? (r2 = -r2, t2 = -t2, e2 = -e2) : (o2 = -t2, t2 = n2, n2 = o2, o2 = -e2, e2 = i2, i2 = o2) : e2 >= i2 ? (t2 = -t2, e2 = -e2, n2 = -n2, i2 = -i2) : (r2 = -r2, o2 = -t2, t2 = -n2, n2 = o2, o2 = -e2, e2 = -i2, i2 = o2), t2 > 0) {
          if (!(n2 > 0))
            return r2;
          if (!(t2 <= n2))
            return r2;
        } else {
          if (n2 > 0)
            return -r2;
          if (!(t2 >= n2))
            return -r2;
          r2 = -r2, t2 = -t2, n2 = -n2;
        }
        for (; ; ) {
          if (s2 = Math.floor(n2 / t2), n2 -= s2 * t2, (i2 -= s2 * e2) < 0)
            return -r2;
          if (i2 > e2)
            return r2;
          if (t2 > n2 + n2) {
            if (e2 < i2 + i2)
              return r2;
          } else {
            if (e2 > i2 + i2)
              return -r2;
            n2 = t2 - n2, i2 = e2 - i2, r2 = -r2;
          }
          if (0 === i2)
            return 0 === n2 ? 0 : -r2;
          if (0 === n2)
            return r2;
          if (s2 = Math.floor(t2 / n2), t2 -= s2 * n2, (e2 -= s2 * i2) < 0)
            return r2;
          if (e2 > i2)
            return -r2;
          if (n2 > t2 + t2) {
            if (i2 < e2 + e2)
              return -r2;
          } else {
            if (i2 > e2 + e2)
              return r2;
            t2 = n2 - t2, e2 = i2 - e2, r2 = -r2;
          }
          if (0 === e2)
            return 0 === t2 ? 0 : r2;
          if (0 === t2)
            return -r2;
        }
      };
      var st = function() {
        this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
        var t2 = arguments[0];
        this._p = t2;
      };
      st.prototype.countSegment = function(t2, e2) {
        if (t2.x < this._p.x && e2.x < this._p.x)
          return null;
        if (this._p.x === e2.x && this._p.y === e2.y)
          return this._isPointOnSegment = true, null;
        if (t2.y === this._p.y && e2.y === this._p.y) {
          var n2 = t2.x, i2 = e2.x;
          return n2 > i2 && (n2 = e2.x, i2 = t2.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
        }
        if (t2.y > this._p.y && e2.y <= this._p.y || e2.y > this._p.y && t2.y <= this._p.y) {
          var r2 = t2.x - this._p.x, o2 = t2.y - this._p.y, s2 = e2.x - this._p.x, a2 = e2.y - this._p.y, u2 = ot.signOfDet2x2(r2, o2, s2, a2);
          if (0 === u2)
            return this._isPointOnSegment = true, null;
          a2 < o2 && (u2 = -u2), u2 > 0 && this._crossingCount++;
        }
      }, st.prototype.isPointInPolygon = function() {
        return this.getLocation() !== w.EXTERIOR;
      }, st.prototype.getLocation = function() {
        return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;
      }, st.prototype.isOnSegment = function() {
        return this._isPointOnSegment;
      }, st.prototype.interfaces_ = function() {
        return [];
      }, st.prototype.getClass = function() {
        return st;
      }, st.locatePointInRing = function() {
        if (arguments[0] instanceof C && T(arguments[1], V)) {
          for (var t2 = arguments[0], e2 = arguments[1], n2 = new st(t2), i2 = new C(), r2 = new C(), o2 = 1; o2 < e2.size(); o2++)
            if (e2.getCoordinate(o2, i2), e2.getCoordinate(o2 - 1, r2), n2.countSegment(i2, r2), n2.isOnSegment())
              return n2.getLocation();
          return n2.getLocation();
        }
        if (arguments[0] instanceof C && arguments[1] instanceof Array) {
          for (var s2 = arguments[0], a2 = arguments[1], u2 = new st(s2), l2 = 1; l2 < a2.length; l2++) {
            var c2 = a2[l2], p2 = a2[l2 - 1];
            if (u2.countSegment(c2, p2), u2.isOnSegment())
              return u2.getLocation();
          }
          return u2.getLocation();
        }
      };
      var at = function() {
      }, ut = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
      at.prototype.interfaces_ = function() {
        return [];
      }, at.prototype.getClass = function() {
        return at;
      }, at.orientationIndex = function(t2, e2, n2) {
        return q.orientationIndex(t2, e2, n2);
      }, at.signedArea = function() {
        if (arguments[0] instanceof Array) {
          var t2 = arguments[0];
          if (t2.length < 3)
            return 0;
          for (var e2 = 0, n2 = t2[0].x, i2 = 1; i2 < t2.length - 1; i2++) {
            var r2 = t2[i2].x - n2, o2 = t2[i2 + 1].y;
            e2 += r2 * (t2[i2 - 1].y - o2);
          }
          return e2 / 2;
        }
        if (T(arguments[0], V)) {
          var s2 = arguments[0], a2 = s2.size();
          if (a2 < 3)
            return 0;
          var u2 = new C(), l2 = new C(), c2 = new C();
          s2.getCoordinate(0, l2), s2.getCoordinate(1, c2);
          var p2 = l2.x;
          c2.x -= p2;
          for (var h2 = 0, f2 = 1; f2 < a2 - 1; f2++)
            u2.y = l2.y, l2.x = c2.x, l2.y = c2.y, s2.getCoordinate(f2 + 1, c2), c2.x -= p2, h2 += l2.x * (u2.y - c2.y);
          return h2 / 2;
        }
      }, at.distanceLineLine = function(t2, e2, n2, i2) {
        if (t2.equals(e2))
          return at.distancePointLine(t2, n2, i2);
        if (n2.equals(i2))
          return at.distancePointLine(i2, t2, e2);
        var r2 = false;
        if (j.intersects(t2, e2, n2, i2)) {
          var o2 = (e2.x - t2.x) * (i2.y - n2.y) - (e2.y - t2.y) * (i2.x - n2.x);
          if (0 === o2)
            r2 = true;
          else {
            var s2 = (t2.y - n2.y) * (i2.x - n2.x) - (t2.x - n2.x) * (i2.y - n2.y), a2 = ((t2.y - n2.y) * (e2.x - t2.x) - (t2.x - n2.x) * (e2.y - t2.y)) / o2, u2 = s2 / o2;
            (u2 < 0 || u2 > 1 || a2 < 0 || a2 > 1) && (r2 = true);
          }
        } else
          r2 = true;
        return r2 ? R.min(at.distancePointLine(t2, n2, i2), at.distancePointLine(e2, n2, i2), at.distancePointLine(n2, t2, e2), at.distancePointLine(i2, t2, e2)) : 0;
      }, at.isPointInRing = function(t2, e2) {
        return at.locatePointInRing(t2, e2) !== w.EXTERIOR;
      }, at.computeLength = function(t2) {
        var e2 = t2.size();
        if (e2 <= 1)
          return 0;
        var n2 = 0, i2 = new C();
        t2.getCoordinate(0, i2);
        for (var r2 = i2.x, o2 = i2.y, s2 = 1; s2 < e2; s2++) {
          t2.getCoordinate(s2, i2);
          var a2 = i2.x, u2 = i2.y, l2 = a2 - r2, c2 = u2 - o2;
          n2 += Math.sqrt(l2 * l2 + c2 * c2), r2 = a2, o2 = u2;
        }
        return n2;
      }, at.isCCW = function(t2) {
        var e2 = t2.length - 1;
        if (e2 < 3)
          throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
        for (var n2 = t2[0], i2 = 0, r2 = 1; r2 <= e2; r2++) {
          var o2 = t2[r2];
          o2.y > n2.y && (n2 = o2, i2 = r2);
        }
        var s2 = i2;
        do {
          (s2 -= 1) < 0 && (s2 = e2);
        } while (t2[s2].equals2D(n2) && s2 !== i2);
        var a2 = i2;
        do {
          a2 = (a2 + 1) % e2;
        } while (t2[a2].equals2D(n2) && a2 !== i2);
        var u2 = t2[s2], l2 = t2[a2];
        if (u2.equals2D(n2) || l2.equals2D(n2) || u2.equals2D(l2))
          return false;
        var c2 = at.computeOrientation(u2, n2, l2), p2 = false;
        return p2 = 0 === c2 ? u2.x > l2.x : c2 > 0, p2;
      }, at.locatePointInRing = function(t2, e2) {
        return st.locatePointInRing(t2, e2);
      }, at.distancePointLinePerpendicular = function(t2, e2, n2) {
        var i2 = (n2.x - e2.x) * (n2.x - e2.x) + (n2.y - e2.y) * (n2.y - e2.y), r2 = ((e2.y - t2.y) * (n2.x - e2.x) - (e2.x - t2.x) * (n2.y - e2.y)) / i2;
        return Math.abs(r2) * Math.sqrt(i2);
      }, at.computeOrientation = function(t2, e2, n2) {
        return at.orientationIndex(t2, e2, n2);
      }, at.distancePointLine = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          if (0 === e2.length)
            throw new m("Line array must contain at least one vertex");
          for (var n2 = t2.distance(e2[0]), i2 = 0; i2 < e2.length - 1; i2++) {
            var r2 = at.distancePointLine(t2, e2[i2], e2[i2 + 1]);
            r2 < n2 && (n2 = r2);
          }
          return n2;
        }
        if (3 === arguments.length) {
          var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
          if (s2.x === a2.x && s2.y === a2.y)
            return o2.distance(s2);
          var u2 = (a2.x - s2.x) * (a2.x - s2.x) + (a2.y - s2.y) * (a2.y - s2.y), l2 = ((o2.x - s2.x) * (a2.x - s2.x) + (o2.y - s2.y) * (a2.y - s2.y)) / u2;
          if (l2 <= 0)
            return o2.distance(s2);
          if (l2 >= 1)
            return o2.distance(a2);
          var c2 = ((s2.y - o2.y) * (a2.x - s2.x) - (s2.x - o2.x) * (a2.y - s2.y)) / u2;
          return Math.abs(c2) * Math.sqrt(u2);
        }
      }, at.isOnLine = function(t2, e2) {
        for (var n2 = new rt(), i2 = 1; i2 < e2.length; i2++) {
          var r2 = e2[i2 - 1], o2 = e2[i2];
          if (n2.computeIntersection(t2, r2, o2), n2.hasIntersection())
            return true;
        }
        return false;
      }, ut.CLOCKWISE.get = function() {
        return -1;
      }, ut.RIGHT.get = function() {
        return at.CLOCKWISE;
      }, ut.COUNTERCLOCKWISE.get = function() {
        return 1;
      }, ut.LEFT.get = function() {
        return at.COUNTERCLOCKWISE;
      }, ut.COLLINEAR.get = function() {
        return 0;
      }, ut.STRAIGHT.get = function() {
        return at.COLLINEAR;
      }, Object.defineProperties(at, ut);
      var lt = function() {
      };
      lt.prototype.filter = function(t2) {
      }, lt.prototype.interfaces_ = function() {
        return [];
      }, lt.prototype.getClass = function() {
        return lt;
      };
      var ct = function() {
        var t2 = arguments[0];
        this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID();
      }, pt = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
      ct.prototype.isGeometryCollection = function() {
        return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;
      }, ct.prototype.getFactory = function() {
        return this._factory;
      }, ct.prototype.getGeometryN = function(t2) {
        return this;
      }, ct.prototype.getArea = function() {
        return 0;
      }, ct.prototype.isRectangle = function() {
        return false;
      }, ct.prototype.equals = function() {
        if (arguments[0] instanceof ct) {
          var t2 = arguments[0];
          return null !== t2 && this.equalsTopo(t2);
        }
        if (arguments[0] instanceof Object) {
          var e2 = arguments[0];
          if (!(e2 instanceof ct))
            return false;
          var n2 = e2;
          return this.equalsExact(n2);
        }
      }, ct.prototype.equalsExact = function(t2) {
        return this === t2 || this.equalsExact(t2, 0);
      }, ct.prototype.geometryChanged = function() {
        this.apply(ct.geometryChangedFilter);
      }, ct.prototype.geometryChangedAction = function() {
        this._envelope = null;
      }, ct.prototype.equalsNorm = function(t2) {
        return null !== t2 && this.norm().equalsExact(t2.norm());
      }, ct.prototype.getLength = function() {
        return 0;
      }, ct.prototype.getNumGeometries = function() {
        return 1;
      }, ct.prototype.compareTo = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = t2;
          return this.getSortIndex() !== e2.getSortIndex() ? this.getSortIndex() - e2.getSortIndex() : this.isEmpty() && e2.isEmpty() ? 0 : this.isEmpty() ? -1 : e2.isEmpty() ? 1 : this.compareToSameClass(t2);
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          return this.getSortIndex() !== n2.getSortIndex() ? this.getSortIndex() - n2.getSortIndex() : this.isEmpty() && n2.isEmpty() ? 0 : this.isEmpty() ? -1 : n2.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
        }
      }, ct.prototype.getUserData = function() {
        return this._userData;
      }, ct.prototype.getSRID = function() {
        return this._SRID;
      }, ct.prototype.getEnvelope = function() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal());
      }, ct.prototype.checkNotGeometryCollection = function(t2) {
        if (t2.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION)
          throw new m("This method does not support GeometryCollection arguments");
      }, ct.prototype.equal = function(t2, e2, n2) {
        return 0 === n2 ? t2.equals(e2) : t2.distance(e2) <= n2;
      }, ct.prototype.norm = function() {
        var t2 = this.copy();
        return t2.normalize(), t2;
      }, ct.prototype.getPrecisionModel = function() {
        return this._factory.getPrecisionModel();
      }, ct.prototype.getEnvelopeInternal = function() {
        return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);
      }, ct.prototype.setSRID = function(t2) {
        this._SRID = t2;
      }, ct.prototype.setUserData = function(t2) {
        this._userData = t2;
      }, ct.prototype.compare = function(t2, e2) {
        for (var n2 = t2.iterator(), i2 = e2.iterator(); n2.hasNext() && i2.hasNext(); ) {
          var r2 = n2.next(), o2 = i2.next(), s2 = r2.compareTo(o2);
          if (0 !== s2)
            return s2;
        }
        return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
      }, ct.prototype.hashCode = function() {
        return this.getEnvelopeInternal().hashCode();
      }, ct.prototype.isGeometryCollectionOrDerived = function() {
        return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;
      }, ct.prototype.interfaces_ = function() {
        return [x, E, e];
      }, ct.prototype.getClass = function() {
        return ct;
      }, ct.hasNonEmptyElements = function(t2) {
        for (var e2 = 0; e2 < t2.length; e2++)
          if (!t2[e2].isEmpty())
            return true;
        return false;
      }, ct.hasNullElements = function(t2) {
        for (var e2 = 0; e2 < t2.length; e2++)
          if (null === t2[e2])
            return true;
        return false;
      }, pt.serialVersionUID.get = function() {
        return 8763622679187377e3;
      }, pt.SORTINDEX_POINT.get = function() {
        return 0;
      }, pt.SORTINDEX_MULTIPOINT.get = function() {
        return 1;
      }, pt.SORTINDEX_LINESTRING.get = function() {
        return 2;
      }, pt.SORTINDEX_LINEARRING.get = function() {
        return 3;
      }, pt.SORTINDEX_MULTILINESTRING.get = function() {
        return 4;
      }, pt.SORTINDEX_POLYGON.get = function() {
        return 5;
      }, pt.SORTINDEX_MULTIPOLYGON.get = function() {
        return 6;
      }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
        return 7;
      }, pt.geometryChangedFilter.get = function() {
        return ht;
      }, Object.defineProperties(ct, pt);
      var ht = function() {
      };
      ht.interfaces_ = function() {
        return [lt];
      }, ht.filter = function(t2) {
        t2.geometryChangedAction();
      };
      var ft = function() {
      };
      ft.prototype.filter = function(t2) {
      }, ft.prototype.interfaces_ = function() {
        return [];
      }, ft.prototype.getClass = function() {
        return ft;
      };
      var gt = function() {
      }, dt = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
      gt.prototype.isInBoundary = function(t2) {
      }, gt.prototype.interfaces_ = function() {
        return [];
      }, gt.prototype.getClass = function() {
        return gt;
      }, dt.Mod2BoundaryNodeRule.get = function() {
        return yt;
      }, dt.EndPointBoundaryNodeRule.get = function() {
        return _t;
      }, dt.MultiValentEndPointBoundaryNodeRule.get = function() {
        return mt;
      }, dt.MonoValentEndPointBoundaryNodeRule.get = function() {
        return vt;
      }, dt.MOD2_BOUNDARY_RULE.get = function() {
        return new yt();
      }, dt.ENDPOINT_BOUNDARY_RULE.get = function() {
        return new _t();
      }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
        return new mt();
      }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
        return new vt();
      }, dt.OGC_SFS_BOUNDARY_RULE.get = function() {
        return gt.MOD2_BOUNDARY_RULE;
      }, Object.defineProperties(gt, dt);
      var yt = function() {
      };
      yt.prototype.isInBoundary = function(t2) {
        return t2 % 2 == 1;
      }, yt.prototype.interfaces_ = function() {
        return [gt];
      }, yt.prototype.getClass = function() {
        return yt;
      };
      var _t = function() {
      };
      _t.prototype.isInBoundary = function(t2) {
        return t2 > 0;
      }, _t.prototype.interfaces_ = function() {
        return [gt];
      }, _t.prototype.getClass = function() {
        return _t;
      };
      var mt = function() {
      };
      mt.prototype.isInBoundary = function(t2) {
        return t2 > 1;
      }, mt.prototype.interfaces_ = function() {
        return [gt];
      }, mt.prototype.getClass = function() {
        return mt;
      };
      var vt = function() {
      };
      vt.prototype.isInBoundary = function(t2) {
        return 1 === t2;
      }, vt.prototype.interfaces_ = function() {
        return [gt];
      }, vt.prototype.getClass = function() {
        return vt;
      };
      var It = function() {
      };
      It.prototype.add = function() {
      }, It.prototype.addAll = function() {
      }, It.prototype.isEmpty = function() {
      }, It.prototype.iterator = function() {
      }, It.prototype.size = function() {
      }, It.prototype.toArray = function() {
      }, It.prototype.remove = function() {
      }, (n.prototype = new Error()).name = "IndexOutOfBoundsException";
      var Et = function() {
      };
      Et.prototype.hasNext = function() {
      }, Et.prototype.next = function() {
      }, Et.prototype.remove = function() {
      };
      var xt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.get = function() {
        }, e2.prototype.set = function() {
        }, e2.prototype.isEmpty = function() {
        }, e2;
      }(It);
      (i.prototype = new Error()).name = "NoSuchElementException";
      var Nt = function(t2) {
        function e2() {
          t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.ensureCapacity = function() {
        }, e2.prototype.interfaces_ = function() {
          return [t2, It];
        }, e2.prototype.add = function(t3) {
          return 1 === arguments.length ? this.array_.push(t3) : this.array_.splice(arguments[0], arguments[1]), true;
        }, e2.prototype.clear = function() {
          this.array_ = [];
        }, e2.prototype.addAll = function(t3) {
          for (var e3 = t3.iterator(); e3.hasNext(); )
            this.add(e3.next());
          return true;
        }, e2.prototype.set = function(t3, e3) {
          var n2 = this.array_[t3];
          return this.array_[t3] = e3, n2;
        }, e2.prototype.iterator = function() {
          return new Ct(this);
        }, e2.prototype.get = function(t3) {
          if (t3 < 0 || t3 >= this.size())
            throw new n();
          return this.array_[t3];
        }, e2.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        }, e2.prototype.size = function() {
          return this.array_.length;
        }, e2.prototype.toArray = function() {
          for (var t3 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t3.push(this.array_[e3]);
          return t3;
        }, e2.prototype.remove = function(t3) {
          for (var e3 = false, n2 = 0, i2 = this.array_.length; n2 < i2; n2++)
            if (this.array_[n2] === t3) {
              this.array_.splice(n2, 1), e3 = true;
              break;
            }
          return e3;
        }, e2;
      }(xt), Ct = function(t2) {
        function e2(e3) {
          t2.call(this), this.arrayList_ = e3, this.position_ = 0;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.next = function() {
          if (this.position_ === this.arrayList_.size())
            throw new i();
          return this.arrayList_.get(this.position_++);
        }, e2.prototype.hasNext = function() {
          return this.position_ < this.arrayList_.size();
        }, e2.prototype.set = function(t3) {
          return this.arrayList_.set(this.position_ - 1, t3);
        }, e2.prototype.remove = function() {
          this.arrayList_.remove(this.arrayList_.get(this.position_));
        }, e2;
      }(Et), St = function(t2) {
        function e2() {
          if (t2.call(this), 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.ensureCapacity(e3.length), this.add(e3, true);
          } else if (2 === arguments.length) {
            var n3 = arguments[0], i2 = arguments[1];
            this.ensureCapacity(n3.length), this.add(n3, i2);
          }
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { coordArrayType: { configurable: true } };
        return n2.coordArrayType.get = function() {
          return new Array(0).fill(null);
        }, e2.prototype.getCoordinate = function(t3) {
          return this.get(t3);
        }, e2.prototype.addAll = function() {
          if (2 === arguments.length) {
            for (var e3 = arguments[0], n3 = arguments[1], i2 = false, r2 = e3.iterator(); r2.hasNext(); )
              this.add(r2.next(), n3), i2 = true;
            return i2;
          }
          return t2.prototype.addAll.apply(this, arguments);
        }, e2.prototype.clone = function() {
          for (var e3 = t2.prototype.clone.call(this), n3 = 0; n3 < this.size(); n3++)
            e3.add(n3, this.get(n3).copy());
          return e3;
        }, e2.prototype.toCoordinateArray = function() {
          return this.toArray(e2.coordArrayType);
        }, e2.prototype.add = function() {
          if (1 === arguments.length) {
            var e3 = arguments[0];
            t2.prototype.add.call(this, e3);
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
              var n3 = arguments[0], i2 = arguments[1];
              return this.add(n3, i2, true), true;
            }
            if (arguments[0] instanceof C && "boolean" == typeof arguments[1]) {
              var r2 = arguments[0];
              if (!arguments[1] && this.size() >= 1) {
                if (this.get(this.size() - 1).equals2D(r2))
                  return null;
              }
              t2.prototype.add.call(this, r2);
            } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
              var o2 = arguments[0], s2 = arguments[1];
              return this.add(o2, s2), true;
            }
          } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
              var a2 = arguments[0], u2 = arguments[1];
              if (arguments[2])
                for (var l2 = 0; l2 < a2.length; l2++)
                  this.add(a2[l2], u2);
              else
                for (var c2 = a2.length - 1; c2 >= 0; c2--)
                  this.add(a2[c2], u2);
              return true;
            }
            if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
              var p2 = arguments[0], h2 = arguments[1];
              if (!arguments[2]) {
                var f2 = this.size();
                if (f2 > 0) {
                  if (p2 > 0) {
                    if (this.get(p2 - 1).equals2D(h2))
                      return null;
                  }
                  if (p2 < f2) {
                    if (this.get(p2).equals2D(h2))
                      return null;
                  }
                }
              }
              t2.prototype.add.call(this, p2, h2);
            }
          } else if (4 === arguments.length) {
            var g2 = arguments[0], d2 = arguments[1], y2 = arguments[2], _2 = arguments[3], m2 = 1;
            y2 > _2 && (m2 = -1);
            for (var v2 = y2; v2 !== _2; v2 += m2)
              this.add(g2[v2], d2);
            return true;
          }
        }, e2.prototype.closeRing = function() {
          this.size() > 0 && this.add(new C(this.get(0)), false);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, Object.defineProperties(e2, n2), e2;
      }(Nt), Lt = function() {
      }, bt = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
      bt.ForwardComparator.get = function() {
        return wt;
      }, bt.BidirectionalComparator.get = function() {
        return Ot;
      }, bt.coordArrayType.get = function() {
        return new Array(0).fill(null);
      }, Lt.prototype.interfaces_ = function() {
        return [];
      }, Lt.prototype.getClass = function() {
        return Lt;
      }, Lt.isRing = function(t2) {
        return !(t2.length < 4) && !!t2[0].equals2D(t2[t2.length - 1]);
      }, Lt.ptNotInList = function(t2, e2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2];
          if (Lt.indexOf(i2, e2) < 0)
            return i2;
        }
        return null;
      }, Lt.scroll = function(t2, e2) {
        var n2 = Lt.indexOf(e2, t2);
        if (n2 < 0)
          return null;
        var i2 = new Array(t2.length).fill(null);
        Y.arraycopy(t2, n2, i2, 0, t2.length - n2), Y.arraycopy(t2, 0, i2, t2.length - n2, n2), Y.arraycopy(i2, 0, t2, 0, t2.length);
      }, Lt.equals = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          if (t2 === e2)
            return true;
          if (null === t2 || null === e2)
            return false;
          if (t2.length !== e2.length)
            return false;
          for (var n2 = 0; n2 < t2.length; n2++)
            if (!t2[n2].equals(e2[n2]))
              return false;
          return true;
        }
        if (3 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
          if (i2 === r2)
            return true;
          if (null === i2 || null === r2)
            return false;
          if (i2.length !== r2.length)
            return false;
          for (var s2 = 0; s2 < i2.length; s2++)
            if (0 !== o2.compare(i2[s2], r2[s2]))
              return false;
          return true;
        }
      }, Lt.intersection = function(t2, e2) {
        for (var n2 = new St(), i2 = 0; i2 < t2.length; i2++)
          e2.intersects(t2[i2]) && n2.add(t2[i2], true);
        return n2.toCoordinateArray();
      }, Lt.hasRepeatedPoints = function(t2) {
        for (var e2 = 1; e2 < t2.length; e2++)
          if (t2[e2 - 1].equals(t2[e2]))
            return true;
        return false;
      }, Lt.removeRepeatedPoints = function(t2) {
        if (!Lt.hasRepeatedPoints(t2))
          return t2;
        return new St(t2, false).toCoordinateArray();
      }, Lt.reverse = function(t2) {
        for (var e2 = t2.length - 1, n2 = Math.trunc(e2 / 2), i2 = 0; i2 <= n2; i2++) {
          var r2 = t2[i2];
          t2[i2] = t2[e2 - i2], t2[e2 - i2] = r2;
        }
      }, Lt.removeNull = function(t2) {
        for (var e2 = 0, n2 = 0; n2 < t2.length; n2++)
          null !== t2[n2] && e2++;
        var i2 = new Array(e2).fill(null);
        if (0 === e2)
          return i2;
        for (var r2 = 0, o2 = 0; o2 < t2.length; o2++)
          null !== t2[o2] && (i2[r2++] = t2[o2]);
        return i2;
      }, Lt.copyDeep = function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++)
            e2[n2] = new C(t2[n2]);
          return e2;
        }
        if (5 === arguments.length)
          for (var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = arguments[4], u2 = 0; u2 < a2; u2++)
            o2[s2 + u2] = new C(i2[r2 + u2]);
      }, Lt.isEqualReversed = function(t2, e2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2], r2 = e2[t2.length - n2 - 1];
          if (0 !== i2.compareTo(r2))
            return false;
        }
        return true;
      }, Lt.envelope = function(t2) {
        for (var e2 = new j(), n2 = 0; n2 < t2.length; n2++)
          e2.expandToInclude(t2[n2]);
        return e2;
      }, Lt.toCoordinateArray = function(t2) {
        return t2.toArray(Lt.coordArrayType);
      }, Lt.atLeastNCoordinatesOrNothing = function(t2, e2) {
        return e2.length >= t2 ? e2 : [];
      }, Lt.indexOf = function(t2, e2) {
        for (var n2 = 0; n2 < e2.length; n2++)
          if (t2.equals(e2[n2]))
            return n2;
        return -1;
      }, Lt.increasingDirection = function(t2) {
        for (var e2 = 0; e2 < Math.trunc(t2.length / 2); e2++) {
          var n2 = t2.length - 1 - e2, i2 = t2[e2].compareTo(t2[n2]);
          if (0 !== i2)
            return i2;
        }
        return 1;
      }, Lt.compare = function(t2, e2) {
        for (var n2 = 0; n2 < t2.length && n2 < e2.length; ) {
          var i2 = t2[n2].compareTo(e2[n2]);
          if (0 !== i2)
            return i2;
          n2++;
        }
        return n2 < e2.length ? -1 : n2 < t2.length ? 1 : 0;
      }, Lt.minCoordinate = function(t2) {
        for (var e2 = null, n2 = 0; n2 < t2.length; n2++)
          (null === e2 || e2.compareTo(t2[n2]) > 0) && (e2 = t2[n2]);
        return e2;
      }, Lt.extract = function(t2, e2, n2) {
        e2 = R.clamp(e2, 0, t2.length);
        var i2 = (n2 = R.clamp(n2, -1, t2.length)) - e2 + 1;
        n2 < 0 && (i2 = 0), e2 >= t2.length && (i2 = 0), n2 < e2 && (i2 = 0);
        var r2 = new Array(i2).fill(null);
        if (0 === i2)
          return r2;
        for (var o2 = 0, s2 = e2; s2 <= n2; s2++)
          r2[o2++] = t2[s2];
        return r2;
      }, Object.defineProperties(Lt, bt);
      var wt = function() {
      };
      wt.prototype.compare = function(t2, e2) {
        return Lt.compare(t2, e2);
      }, wt.prototype.interfaces_ = function() {
        return [N];
      }, wt.prototype.getClass = function() {
        return wt;
      };
      var Ot = function() {
      };
      Ot.prototype.compare = function(t2, e2) {
        var n2 = t2, i2 = e2;
        if (n2.length < i2.length)
          return -1;
        if (n2.length > i2.length)
          return 1;
        if (0 === n2.length)
          return 0;
        var r2 = Lt.compare(n2, i2);
        return Lt.isEqualReversed(n2, i2) ? 0 : r2;
      }, Ot.prototype.OLDcompare = function(t2, e2) {
        var n2 = t2, i2 = e2;
        if (n2.length < i2.length)
          return -1;
        if (n2.length > i2.length)
          return 1;
        if (0 === n2.length)
          return 0;
        for (var r2 = Lt.increasingDirection(n2), o2 = Lt.increasingDirection(i2), s2 = r2 > 0 ? 0 : n2.length - 1, a2 = o2 > 0 ? 0 : n2.length - 1, u2 = 0; u2 < n2.length; u2++) {
          var l2 = n2[s2].compareTo(i2[a2]);
          if (0 !== l2)
            return l2;
          s2 += r2, a2 += o2;
        }
        return 0;
      }, Ot.prototype.interfaces_ = function() {
        return [N];
      }, Ot.prototype.getClass = function() {
        return Ot;
      };
      var Tt = function() {
      };
      Tt.prototype.get = function() {
      }, Tt.prototype.put = function() {
      }, Tt.prototype.size = function() {
      }, Tt.prototype.values = function() {
      }, Tt.prototype.entrySet = function() {
      };
      var Rt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2;
      }(Tt);
      (r.prototype = new Error()).name = "OperationNotSupported", (o.prototype = new It()).contains = function() {
      };
      var Pt = function(t2) {
        function e2() {
          t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.contains = function(t3) {
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (this.array_[e3] === t3)
              return true;
          }
          return false;
        }, e2.prototype.add = function(t3) {
          return !this.contains(t3) && (this.array_.push(t3), true);
        }, e2.prototype.addAll = function(t3) {
          for (var e3 = t3.iterator(); e3.hasNext(); )
            this.add(e3.next());
          return true;
        }, e2.prototype.remove = function(t3) {
          throw new Error();
        }, e2.prototype.size = function() {
          return this.array_.length;
        }, e2.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        }, e2.prototype.toArray = function() {
          for (var t3 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t3.push(this.array_[e3]);
          return t3;
        }, e2.prototype.iterator = function() {
          return new Dt(this);
        }, e2;
      }(o), Dt = function(t2) {
        function e2(e3) {
          t2.call(this), this.hashSet_ = e3, this.position_ = 0;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.next = function() {
          if (this.position_ === this.hashSet_.size())
            throw new i();
          return this.hashSet_.array_[this.position_++];
        }, e2.prototype.hasNext = function() {
          return this.position_ < this.hashSet_.size();
        }, e2.prototype.remove = function() {
          throw new r();
        }, e2;
      }(Et), Mt = 0;
      (p.prototype = new Rt()).get = function(t2) {
        for (var e2 = this.root_; null !== e2; ) {
          var n2 = t2.compareTo(e2.key);
          if (n2 < 0)
            e2 = e2.left;
          else {
            if (!(n2 > 0))
              return e2.value;
            e2 = e2.right;
          }
        }
        return null;
      }, p.prototype.put = function(t2, e2) {
        if (null === this.root_)
          return this.root_ = { key: t2, value: e2, left: null, right: null, parent: null, color: Mt, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
        var n2, i2, r2 = this.root_;
        do {
          if (n2 = r2, (i2 = t2.compareTo(r2.key)) < 0)
            r2 = r2.left;
          else {
            if (!(i2 > 0)) {
              var o2 = r2.value;
              return r2.value = e2, o2;
            }
            r2 = r2.right;
          }
        } while (null !== r2);
        var s2 = { key: t2, left: null, right: null, value: e2, parent: n2, color: Mt, getValue: function() {
          return this.value;
        }, getKey: function() {
          return this.key;
        } };
        return i2 < 0 ? n2.left = s2 : n2.right = s2, this.fixAfterInsertion(s2), this.size_++, null;
      }, p.prototype.fixAfterInsertion = function(t2) {
        for (t2.color = 1; null != t2 && t2 !== this.root_ && 1 === t2.parent.color; )
          if (a(t2) === l(a(a(t2)))) {
            var e2 = c(a(a(t2)));
            1 === s(e2) ? (u(a(t2), Mt), u(e2, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === c(a(t2)) && (t2 = a(t2), this.rotateLeft(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateRight(a(a(t2))));
          } else {
            var n2 = l(a(a(t2)));
            1 === s(n2) ? (u(a(t2), Mt), u(n2, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === l(a(t2)) && (t2 = a(t2), this.rotateRight(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateLeft(a(a(t2))));
          }
        this.root_.color = Mt;
      }, p.prototype.values = function() {
        var t2 = new Nt(), e2 = this.getFirstEntry();
        if (null !== e2)
          for (t2.add(e2.value); null !== (e2 = p.successor(e2)); )
            t2.add(e2.value);
        return t2;
      }, p.prototype.entrySet = function() {
        var t2 = new Pt(), e2 = this.getFirstEntry();
        if (null !== e2)
          for (t2.add(e2); null !== (e2 = p.successor(e2)); )
            t2.add(e2);
        return t2;
      }, p.prototype.rotateLeft = function(t2) {
        if (null != t2) {
          var e2 = t2.right;
          t2.right = e2.left, null != e2.left && (e2.left.parent = t2), e2.parent = t2.parent, null === t2.parent ? this.root_ = e2 : t2.parent.left === t2 ? t2.parent.left = e2 : t2.parent.right = e2, e2.left = t2, t2.parent = e2;
        }
      }, p.prototype.rotateRight = function(t2) {
        if (null != t2) {
          var e2 = t2.left;
          t2.left = e2.right, null != e2.right && (e2.right.parent = t2), e2.parent = t2.parent, null === t2.parent ? this.root_ = e2 : t2.parent.right === t2 ? t2.parent.right = e2 : t2.parent.left = e2, e2.right = t2, t2.parent = e2;
        }
      }, p.prototype.getFirstEntry = function() {
        var t2 = this.root_;
        if (null != t2)
          for (; null != t2.left; )
            t2 = t2.left;
        return t2;
      }, p.successor = function(t2) {
        if (null === t2)
          return null;
        if (null !== t2.right) {
          for (var e2 = t2.right; null !== e2.left; )
            e2 = e2.left;
          return e2;
        }
        for (var n2 = t2.parent, i2 = t2; null !== n2 && i2 === n2.right; )
          i2 = n2, n2 = n2.parent;
        return n2;
      }, p.prototype.size = function() {
        return this.size_;
      };
      var At = function() {
      };
      At.prototype.interfaces_ = function() {
        return [];
      }, At.prototype.getClass = function() {
        return At;
      }, h.prototype = new o(), (f.prototype = new h()).contains = function(t2) {
        for (var e2 = 0, n2 = this.array_.length; e2 < n2; e2++) {
          if (0 === this.array_[e2].compareTo(t2))
            return true;
        }
        return false;
      }, f.prototype.add = function(t2) {
        if (this.contains(t2))
          return false;
        for (var e2 = 0, n2 = this.array_.length; e2 < n2; e2++) {
          if (1 === this.array_[e2].compareTo(t2))
            return this.array_.splice(e2, 0, t2), true;
        }
        return this.array_.push(t2), true;
      }, f.prototype.addAll = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.add(e2.next());
        return true;
      }, f.prototype.remove = function(t2) {
        throw new r();
      }, f.prototype.size = function() {
        return this.array_.length;
      }, f.prototype.isEmpty = function() {
        return 0 === this.array_.length;
      }, f.prototype.toArray = function() {
        for (var t2 = [], e2 = 0, n2 = this.array_.length; e2 < n2; e2++)
          t2.push(this.array_[e2]);
        return t2;
      }, f.prototype.iterator = function() {
        return new Ft(this);
      };
      var Ft = function(t2) {
        this.treeSet_ = t2, this.position_ = 0;
      };
      Ft.prototype.next = function() {
        if (this.position_ === this.treeSet_.size())
          throw new i();
        return this.treeSet_.array_[this.position_++];
      }, Ft.prototype.hasNext = function() {
        return this.position_ < this.treeSet_.size();
      }, Ft.prototype.remove = function() {
        throw new r();
      };
      var Gt = function() {
      };
      Gt.sort = function() {
        var t2, e2, n2, i2, r2 = arguments[0];
        if (1 === arguments.length)
          i2 = function(t3, e3) {
            return t3.compareTo(e3);
          }, r2.sort(i2);
        else if (2 === arguments.length)
          n2 = arguments[1], i2 = function(t3, e3) {
            return n2.compare(t3, e3);
          }, r2.sort(i2);
        else if (3 === arguments.length) {
          (e2 = r2.slice(arguments[1], arguments[2])).sort();
          var o2 = r2.slice(0, arguments[1]).concat(e2, r2.slice(arguments[2], r2.length));
          for (r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
            r2.push(o2[t2]);
        } else if (4 === arguments.length)
          for (e2 = r2.slice(arguments[1], arguments[2]), n2 = arguments[3], i2 = function(t3, e3) {
            return n2.compare(t3, e3);
          }, e2.sort(i2), o2 = r2.slice(0, arguments[1]).concat(e2, r2.slice(arguments[2], r2.length)), r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
            r2.push(o2[t2]);
      }, Gt.asList = function(t2) {
        for (var e2 = new Nt(), n2 = 0, i2 = t2.length; n2 < i2; n2++)
          e2.add(t2[n2]);
        return e2;
      };
      var qt = function() {
      }, Bt = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
      Bt.P.get = function() {
        return 0;
      }, Bt.L.get = function() {
        return 1;
      }, Bt.A.get = function() {
        return 2;
      }, Bt.FALSE.get = function() {
        return -1;
      }, Bt.TRUE.get = function() {
        return -2;
      }, Bt.DONTCARE.get = function() {
        return -3;
      }, Bt.SYM_FALSE.get = function() {
        return "F";
      }, Bt.SYM_TRUE.get = function() {
        return "T";
      }, Bt.SYM_DONTCARE.get = function() {
        return "*";
      }, Bt.SYM_P.get = function() {
        return "0";
      }, Bt.SYM_L.get = function() {
        return "1";
      }, Bt.SYM_A.get = function() {
        return "2";
      }, qt.prototype.interfaces_ = function() {
        return [];
      }, qt.prototype.getClass = function() {
        return qt;
      }, qt.toDimensionSymbol = function(t2) {
        switch (t2) {
          case qt.FALSE:
            return qt.SYM_FALSE;
          case qt.TRUE:
            return qt.SYM_TRUE;
          case qt.DONTCARE:
            return qt.SYM_DONTCARE;
          case qt.P:
            return qt.SYM_P;
          case qt.L:
            return qt.SYM_L;
          case qt.A:
            return qt.SYM_A;
        }
        throw new m("Unknown dimension value: " + t2);
      }, qt.toDimensionValue = function(t2) {
        switch (A.toUpperCase(t2)) {
          case qt.SYM_FALSE:
            return qt.FALSE;
          case qt.SYM_TRUE:
            return qt.TRUE;
          case qt.SYM_DONTCARE:
            return qt.DONTCARE;
          case qt.SYM_P:
            return qt.P;
          case qt.SYM_L:
            return qt.L;
          case qt.SYM_A:
            return qt.A;
        }
        throw new m("Unknown dimension symbol: " + t2);
      }, Object.defineProperties(qt, Bt);
      var Vt = function() {
      };
      Vt.prototype.filter = function(t2) {
      }, Vt.prototype.interfaces_ = function() {
        return [];
      }, Vt.prototype.getClass = function() {
        return Vt;
      };
      var Ut = function() {
      };
      Ut.prototype.filter = function(t2, e2) {
      }, Ut.prototype.isDone = function() {
      }, Ut.prototype.isGeometryChanged = function() {
      }, Ut.prototype.interfaces_ = function() {
        return [];
      }, Ut.prototype.getClass = function() {
        return Ut;
      };
      var zt = function(t2) {
        function e2(e3, n3) {
          if (t2.call(this, n3), this._geometries = e3 || [], t2.hasNullElements(this._geometries))
            throw new m("geometries must not contain null elements");
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { serialVersionUID: { configurable: true } };
        return e2.prototype.computeEnvelopeInternal = function() {
          for (var t3 = new j(), e3 = 0; e3 < this._geometries.length; e3++)
            t3.expandToInclude(this._geometries[e3].getEnvelopeInternal());
          return t3;
        }, e2.prototype.getGeometryN = function(t3) {
          return this._geometries[t3];
        }, e2.prototype.getSortIndex = function() {
          return t2.SORTINDEX_GEOMETRYCOLLECTION;
        }, e2.prototype.getCoordinates = function() {
          for (var t3 = new Array(this.getNumPoints()).fill(null), e3 = -1, n3 = 0; n3 < this._geometries.length; n3++)
            for (var i2 = this._geometries[n3].getCoordinates(), r2 = 0; r2 < i2.length; r2++)
              t3[++e3] = i2[r2];
          return t3;
        }, e2.prototype.getArea = function() {
          for (var t3 = 0, e3 = 0; e3 < this._geometries.length; e3++)
            t3 += this._geometries[e3].getArea();
          return t3;
        }, e2.prototype.equalsExact = function() {
          if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            if (!this.isEquivalentClass(e3))
              return false;
            var i2 = e3;
            if (this._geometries.length !== i2._geometries.length)
              return false;
            for (var r2 = 0; r2 < this._geometries.length; r2++)
              if (!this._geometries[r2].equalsExact(i2._geometries[r2], n3))
                return false;
            return true;
          }
          return t2.prototype.equalsExact.apply(this, arguments);
        }, e2.prototype.normalize = function() {
          for (var t3 = 0; t3 < this._geometries.length; t3++)
            this._geometries[t3].normalize();
          Gt.sort(this._geometries);
        }, e2.prototype.getCoordinate = function() {
          return this.isEmpty() ? null : this._geometries[0].getCoordinate();
        }, e2.prototype.getBoundaryDimension = function() {
          for (var t3 = qt.FALSE, e3 = 0; e3 < this._geometries.length; e3++)
            t3 = Math.max(t3, this._geometries[e3].getBoundaryDimension());
          return t3;
        }, e2.prototype.getDimension = function() {
          for (var t3 = qt.FALSE, e3 = 0; e3 < this._geometries.length; e3++)
            t3 = Math.max(t3, this._geometries[e3].getDimension());
          return t3;
        }, e2.prototype.getLength = function() {
          for (var t3 = 0, e3 = 0; e3 < this._geometries.length; e3++)
            t3 += this._geometries[e3].getLength();
          return t3;
        }, e2.prototype.getNumPoints = function() {
          for (var t3 = 0, e3 = 0; e3 < this._geometries.length; e3++)
            t3 += this._geometries[e3].getNumPoints();
          return t3;
        }, e2.prototype.getNumGeometries = function() {
          return this._geometries.length;
        }, e2.prototype.reverse = function() {
          for (var t3 = this._geometries.length, e3 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
            e3[n3] = this._geometries[n3].reverse();
          return this.getFactory().createGeometryCollection(e3);
        }, e2.prototype.compareToSameClass = function() {
          if (1 === arguments.length) {
            var t3 = arguments[0], e3 = new f(Gt.asList(this._geometries)), n3 = new f(Gt.asList(t3._geometries));
            return this.compare(e3, n3);
          }
          if (2 === arguments.length) {
            for (var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this.getNumGeometries(), a2 = o2.getNumGeometries(), u2 = 0; u2 < s2 && u2 < a2; ) {
              var l2 = this.getGeometryN(u2), c2 = o2.getGeometryN(u2), p2 = l2.compareToSameClass(c2, r2);
              if (0 !== p2)
                return p2;
              u2++;
            }
            return u2 < s2 ? 1 : u2 < a2 ? -1 : 0;
          }
        }, e2.prototype.apply = function() {
          if (T(arguments[0], ft))
            for (var t3 = arguments[0], e3 = 0; e3 < this._geometries.length; e3++)
              this._geometries[e3].apply(t3);
          else if (T(arguments[0], Ut)) {
            var n3 = arguments[0];
            if (0 === this._geometries.length)
              return null;
            for (var i2 = 0; i2 < this._geometries.length && (this._geometries[i2].apply(n3), !n3.isDone()); i2++)
              ;
            n3.isGeometryChanged() && this.geometryChanged();
          } else if (T(arguments[0], Vt)) {
            var r2 = arguments[0];
            r2.filter(this);
            for (var o2 = 0; o2 < this._geometries.length; o2++)
              this._geometries[o2].apply(r2);
          } else if (T(arguments[0], lt)) {
            var s2 = arguments[0];
            s2.filter(this);
            for (var a2 = 0; a2 < this._geometries.length; a2++)
              this._geometries[a2].apply(s2);
          }
        }, e2.prototype.getBoundary = function() {
          return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;
        }, e2.prototype.clone = function() {
          var e3 = t2.prototype.clone.call(this);
          e3._geometries = new Array(this._geometries.length).fill(null);
          for (var n3 = 0; n3 < this._geometries.length; n3++)
            e3._geometries[n3] = this._geometries[n3].clone();
          return e3;
        }, e2.prototype.getGeometryType = function() {
          return "GeometryCollection";
        }, e2.prototype.copy = function() {
          for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
            t3[n3] = this._geometries[n3].copy();
          return new e2(t3, this._factory);
        }, e2.prototype.isEmpty = function() {
          for (var t3 = 0; t3 < this._geometries.length; t3++)
            if (!this._geometries[t3].isEmpty())
              return false;
          return true;
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.serialVersionUID.get = function() {
          return -5694727726395021e3;
        }, Object.defineProperties(e2, n2), e2;
      }(ct), Xt = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { serialVersionUID: { configurable: true } };
        return e2.prototype.getSortIndex = function() {
          return ct.SORTINDEX_MULTILINESTRING;
        }, e2.prototype.equalsExact = function() {
          if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            return !!this.isEquivalentClass(e3) && t2.prototype.equalsExact.call(this, e3, n3);
          }
          return t2.prototype.equalsExact.apply(this, arguments);
        }, e2.prototype.getBoundaryDimension = function() {
          return this.isClosed() ? qt.FALSE : 0;
        }, e2.prototype.isClosed = function() {
          if (this.isEmpty())
            return false;
          for (var t3 = 0; t3 < this._geometries.length; t3++)
            if (!this._geometries[t3].isClosed())
              return false;
          return true;
        }, e2.prototype.getDimension = function() {
          return 1;
        }, e2.prototype.reverse = function() {
          for (var t3 = this._geometries.length, e3 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
            e3[t3 - 1 - n3] = this._geometries[n3].reverse();
          return this.getFactory().createMultiLineString(e3);
        }, e2.prototype.getBoundary = function() {
          return new Yt(this).getBoundary();
        }, e2.prototype.getGeometryType = function() {
          return "MultiLineString";
        }, e2.prototype.copy = function() {
          for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
            t3[n3] = this._geometries[n3].copy();
          return new e2(t3, this._factory);
        }, e2.prototype.interfaces_ = function() {
          return [At];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.serialVersionUID.get = function() {
          return 8166665132445434e3;
        }, Object.defineProperties(e2, n2), e2;
      }(zt), Yt = function() {
        if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
          var t2 = arguments[0], e2 = gt.MOD2_BOUNDARY_RULE;
          this._geom = t2, this._geomFact = t2.getFactory(), this._bnRule = e2;
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          this._geom = n2, this._geomFact = n2.getFactory(), this._bnRule = i2;
        }
      };
      Yt.prototype.boundaryMultiLineString = function(t2) {
        if (this._geom.isEmpty())
          return this.getEmptyMultiPoint();
        var e2 = this.computeBoundaryCoordinates(t2);
        return 1 === e2.length ? this._geomFact.createPoint(e2[0]) : this._geomFact.createMultiPointFromCoords(e2);
      }, Yt.prototype.getBoundary = function() {
        return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
      }, Yt.prototype.boundaryLineString = function(t2) {
        if (this._geom.isEmpty())
          return this.getEmptyMultiPoint();
        if (t2.isClosed()) {
          return this._bnRule.isInBoundary(2) ? t2.getStartPoint() : this._geomFact.createMultiPoint();
        }
        return this._geomFact.createMultiPoint([t2.getStartPoint(), t2.getEndPoint()]);
      }, Yt.prototype.getEmptyMultiPoint = function() {
        return this._geomFact.createMultiPoint();
      }, Yt.prototype.computeBoundaryCoordinates = function(t2) {
        var e2 = new Nt();
        this._endpointMap = new p();
        for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
          var i2 = t2.getGeometryN(n2);
          0 !== i2.getNumPoints() && (this.addEndpoint(i2.getCoordinateN(0)), this.addEndpoint(i2.getCoordinateN(i2.getNumPoints() - 1)));
        }
        for (var r2 = this._endpointMap.entrySet().iterator(); r2.hasNext(); ) {
          var o2 = r2.next(), s2 = o2.getValue().count;
          this._bnRule.isInBoundary(s2) && e2.add(o2.getKey());
        }
        return Lt.toCoordinateArray(e2);
      }, Yt.prototype.addEndpoint = function(t2) {
        var e2 = this._endpointMap.get(t2);
        null === e2 && (e2 = new kt(), this._endpointMap.put(t2, e2)), e2.count++;
      }, Yt.prototype.interfaces_ = function() {
        return [];
      }, Yt.prototype.getClass = function() {
        return Yt;
      }, Yt.getBoundary = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new Yt(t2).getBoundary();
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return new Yt(e2, n2).getBoundary();
        }
      };
      var kt = function() {
        this.count = null;
      };
      kt.prototype.interfaces_ = function() {
        return [];
      }, kt.prototype.getClass = function() {
        return kt;
      };
      var jt = function() {
      }, Ht = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
      jt.prototype.interfaces_ = function() {
        return [];
      }, jt.prototype.getClass = function() {
        return jt;
      }, jt.chars = function(t2, e2) {
        for (var n2 = new Array(e2).fill(null), i2 = 0; i2 < e2; i2++)
          n2[i2] = t2;
        return String(n2);
      }, jt.getStackTrace = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new function() {
          }(), n2 = new function() {
          }(e2);
          return t2.printStackTrace(n2), e2.toString();
        }
        if (2 === arguments.length) {
          for (var i2 = arguments[0], r2 = arguments[1], o2 = "", s2 = new function() {
          }(new function() {
          }(jt.getStackTrace(i2))), a2 = 0; a2 < r2; a2++)
            try {
              o2 += s2.readLine() + jt.NEWLINE;
            } catch (t3) {
              if (!(t3 instanceof g))
                throw t3;
              et.shouldNeverReachHere();
            }
          return o2;
        }
      }, jt.split = function(t2, e2) {
        for (var n2 = e2.length, i2 = new Nt(), r2 = "" + t2, o2 = r2.indexOf(e2); o2 >= 0; ) {
          var s2 = r2.substring(0, o2);
          i2.add(s2), o2 = (r2 = r2.substring(o2 + n2)).indexOf(e2);
        }
        r2.length > 0 && i2.add(r2);
        for (var a2 = new Array(i2.size()).fill(null), u2 = 0; u2 < a2.length; u2++)
          a2[u2] = i2.get(u2);
        return a2;
      }, jt.toString = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return jt.SIMPLE_ORDINATE_FORMAT.format(t2);
        }
      }, jt.spaces = function(t2) {
        return jt.chars(" ", t2);
      }, Ht.NEWLINE.get = function() {
        return Y.getProperty("line.separator");
      }, Ht.SIMPLE_ORDINATE_FORMAT.get = function() {
        return new function() {
        }("0.#");
      }, Object.defineProperties(jt, Ht);
      var Wt = function() {
      };
      Wt.prototype.interfaces_ = function() {
        return [];
      }, Wt.prototype.getClass = function() {
        return Wt;
      }, Wt.copyCoord = function(t2, e2, n2, i2) {
        for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), o2 = 0; o2 < r2; o2++)
          n2.setOrdinate(i2, o2, t2.getOrdinate(e2, o2));
      }, Wt.isRing = function(t2) {
        var e2 = t2.size();
        return 0 === e2 || !(e2 <= 3) && (t2.getOrdinate(0, V.X) === t2.getOrdinate(e2 - 1, V.X) && t2.getOrdinate(0, V.Y) === t2.getOrdinate(e2 - 1, V.Y));
      }, Wt.isEqual = function(t2, e2) {
        var n2 = t2.size();
        if (n2 !== e2.size())
          return false;
        for (var i2 = Math.min(t2.getDimension(), e2.getDimension()), r2 = 0; r2 < n2; r2++)
          for (var o2 = 0; o2 < i2; o2++) {
            var s2 = t2.getOrdinate(r2, o2), a2 = e2.getOrdinate(r2, o2);
            if (t2.getOrdinate(r2, o2) !== e2.getOrdinate(r2, o2) && (!v.isNaN(s2) || !v.isNaN(a2)))
              return false;
          }
        return true;
      }, Wt.extend = function(t2, e2, n2) {
        var i2 = t2.create(n2, e2.getDimension()), r2 = e2.size();
        if (Wt.copy(e2, 0, i2, 0, r2), r2 > 0)
          for (var o2 = r2; o2 < n2; o2++)
            Wt.copy(e2, r2 - 1, i2, o2, 1);
        return i2;
      }, Wt.reverse = function(t2) {
        for (var e2 = t2.size() - 1, n2 = Math.trunc(e2 / 2), i2 = 0; i2 <= n2; i2++)
          Wt.swap(t2, i2, e2 - i2);
      }, Wt.swap = function(t2, e2, n2) {
        if (e2 === n2)
          return null;
        for (var i2 = 0; i2 < t2.getDimension(); i2++) {
          var r2 = t2.getOrdinate(e2, i2);
          t2.setOrdinate(e2, i2, t2.getOrdinate(n2, i2)), t2.setOrdinate(n2, i2, r2);
        }
      }, Wt.copy = function(t2, e2, n2, i2, r2) {
        for (var o2 = 0; o2 < r2; o2++)
          Wt.copyCoord(t2, e2 + o2, n2, i2 + o2);
      }, Wt.toString = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = t2.size();
          if (0 === e2)
            return "()";
          var n2 = t2.getDimension(), i2 = new D();
          i2.append("(");
          for (var r2 = 0; r2 < e2; r2++) {
            r2 > 0 && i2.append(" ");
            for (var o2 = 0; o2 < n2; o2++)
              o2 > 0 && i2.append(","), i2.append(jt.toString(t2.getOrdinate(r2, o2)));
          }
          return i2.append(")"), i2.toString();
        }
      }, Wt.ensureValidRing = function(t2, e2) {
        var n2 = e2.size();
        if (0 === n2)
          return e2;
        if (n2 <= 3)
          return Wt.createClosedRing(t2, e2, 4);
        return e2.getOrdinate(0, V.X) === e2.getOrdinate(n2 - 1, V.X) && e2.getOrdinate(0, V.Y) === e2.getOrdinate(n2 - 1, V.Y) ? e2 : Wt.createClosedRing(t2, e2, n2 + 1);
      }, Wt.createClosedRing = function(t2, e2, n2) {
        var i2 = t2.create(n2, e2.getDimension()), r2 = e2.size();
        Wt.copy(e2, 0, i2, 0, r2);
        for (var o2 = r2; o2 < n2; o2++)
          Wt.copy(e2, 0, i2, o2, 1);
        return i2;
      };
      var Kt = function(t2) {
        function e2(e3, n3) {
          t2.call(this, n3), this._points = null, this.init(e3);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { serialVersionUID: { configurable: true } };
        return e2.prototype.computeEnvelopeInternal = function() {
          return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());
        }, e2.prototype.isRing = function() {
          return this.isClosed() && this.isSimple();
        }, e2.prototype.getSortIndex = function() {
          return t2.SORTINDEX_LINESTRING;
        }, e2.prototype.getCoordinates = function() {
          return this._points.toCoordinateArray();
        }, e2.prototype.equalsExact = function() {
          if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            if (!this.isEquivalentClass(e3))
              return false;
            var i2 = e3;
            if (this._points.size() !== i2._points.size())
              return false;
            for (var r2 = 0; r2 < this._points.size(); r2++)
              if (!this.equal(this._points.getCoordinate(r2), i2._points.getCoordinate(r2), n3))
                return false;
            return true;
          }
          return t2.prototype.equalsExact.apply(this, arguments);
        }, e2.prototype.normalize = function() {
          for (var t3 = 0; t3 < Math.trunc(this._points.size() / 2); t3++) {
            var e3 = this._points.size() - 1 - t3;
            if (!this._points.getCoordinate(t3).equals(this._points.getCoordinate(e3)))
              return this._points.getCoordinate(t3).compareTo(this._points.getCoordinate(e3)) > 0 && Wt.reverse(this._points), null;
          }
        }, e2.prototype.getCoordinate = function() {
          return this.isEmpty() ? null : this._points.getCoordinate(0);
        }, e2.prototype.getBoundaryDimension = function() {
          return this.isClosed() ? qt.FALSE : 0;
        }, e2.prototype.isClosed = function() {
          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
        }, e2.prototype.getEndPoint = function() {
          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
        }, e2.prototype.getDimension = function() {
          return 1;
        }, e2.prototype.getLength = function() {
          return at.computeLength(this._points);
        }, e2.prototype.getNumPoints = function() {
          return this._points.size();
        }, e2.prototype.reverse = function() {
          var t3 = this._points.copy();
          Wt.reverse(t3);
          return this.getFactory().createLineString(t3);
        }, e2.prototype.compareToSameClass = function() {
          if (1 === arguments.length) {
            for (var t3 = arguments[0], e3 = 0, n3 = 0; e3 < this._points.size() && n3 < t3._points.size(); ) {
              var i2 = this._points.getCoordinate(e3).compareTo(t3._points.getCoordinate(n3));
              if (0 !== i2)
                return i2;
              e3++, n3++;
            }
            return e3 < this._points.size() ? 1 : n3 < t3._points.size() ? -1 : 0;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0];
            return arguments[1].compare(this._points, r2._points);
          }
        }, e2.prototype.apply = function() {
          if (T(arguments[0], ft))
            for (var t3 = arguments[0], e3 = 0; e3 < this._points.size(); e3++)
              t3.filter(this._points.getCoordinate(e3));
          else if (T(arguments[0], Ut)) {
            var n3 = arguments[0];
            if (0 === this._points.size())
              return null;
            for (var i2 = 0; i2 < this._points.size() && (n3.filter(this._points, i2), !n3.isDone()); i2++)
              ;
            n3.isGeometryChanged() && this.geometryChanged();
          } else if (T(arguments[0], Vt)) {
            arguments[0].filter(this);
          } else if (T(arguments[0], lt)) {
            arguments[0].filter(this);
          }
        }, e2.prototype.getBoundary = function() {
          return new Yt(this).getBoundary();
        }, e2.prototype.isEquivalentClass = function(t3) {
          return t3 instanceof e2;
        }, e2.prototype.clone = function() {
          var e3 = t2.prototype.clone.call(this);
          return e3._points = this._points.clone(), e3;
        }, e2.prototype.getCoordinateN = function(t3) {
          return this._points.getCoordinate(t3);
        }, e2.prototype.getGeometryType = function() {
          return "LineString";
        }, e2.prototype.copy = function() {
          return new e2(this._points.copy(), this._factory);
        }, e2.prototype.getCoordinateSequence = function() {
          return this._points;
        }, e2.prototype.isEmpty = function() {
          return 0 === this._points.size();
        }, e2.prototype.init = function(t3) {
          if (null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t3.size())
            throw new m("Invalid number of points in LineString (found " + t3.size() + " - must be 0 or >= 2)");
          this._points = t3;
        }, e2.prototype.isCoordinate = function(t3) {
          for (var e3 = 0; e3 < this._points.size(); e3++)
            if (this._points.getCoordinate(e3).equals(t3))
              return true;
          return false;
        }, e2.prototype.getStartPoint = function() {
          return this.isEmpty() ? null : this.getPointN(0);
        }, e2.prototype.getPointN = function(t3) {
          return this.getFactory().createPoint(this._points.getCoordinate(t3));
        }, e2.prototype.interfaces_ = function() {
          return [At];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.serialVersionUID.get = function() {
          return 3110669828065365500;
        }, Object.defineProperties(e2, n2), e2;
      }(ct), Jt = function() {
      };
      Jt.prototype.interfaces_ = function() {
        return [];
      }, Jt.prototype.getClass = function() {
        return Jt;
      };
      var Qt = function(t2) {
        function e2(e3, n3) {
          t2.call(this, n3), this._coordinates = e3 || null, this.init(this._coordinates);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { serialVersionUID: { configurable: true } };
        return e2.prototype.computeEnvelopeInternal = function() {
          if (this.isEmpty())
            return new j();
          var t3 = new j();
          return t3.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t3;
        }, e2.prototype.getSortIndex = function() {
          return t2.SORTINDEX_POINT;
        }, e2.prototype.getCoordinates = function() {
          return this.isEmpty() ? [] : [this.getCoordinate()];
        }, e2.prototype.equalsExact = function() {
          if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            return !!this.isEquivalentClass(e3) && (!(!this.isEmpty() || !e3.isEmpty()) || this.isEmpty() === e3.isEmpty() && this.equal(e3.getCoordinate(), this.getCoordinate(), n3));
          }
          return t2.prototype.equalsExact.apply(this, arguments);
        }, e2.prototype.normalize = function() {
        }, e2.prototype.getCoordinate = function() {
          return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
        }, e2.prototype.getBoundaryDimension = function() {
          return qt.FALSE;
        }, e2.prototype.getDimension = function() {
          return 0;
        }, e2.prototype.getNumPoints = function() {
          return this.isEmpty() ? 0 : 1;
        }, e2.prototype.reverse = function() {
          return this.copy();
        }, e2.prototype.getX = function() {
          if (null === this.getCoordinate())
            throw new Error("getX called on empty Point");
          return this.getCoordinate().x;
        }, e2.prototype.compareToSameClass = function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this.getCoordinate().compareTo(t3.getCoordinate());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0];
            return arguments[1].compare(this._coordinates, e3._coordinates);
          }
        }, e2.prototype.apply = function() {
          if (T(arguments[0], ft)) {
            var t3 = arguments[0];
            if (this.isEmpty())
              return null;
            t3.filter(this.getCoordinate());
          } else if (T(arguments[0], Ut)) {
            var e3 = arguments[0];
            if (this.isEmpty())
              return null;
            e3.filter(this._coordinates, 0), e3.isGeometryChanged() && this.geometryChanged();
          } else if (T(arguments[0], Vt)) {
            arguments[0].filter(this);
          } else if (T(arguments[0], lt)) {
            arguments[0].filter(this);
          }
        }, e2.prototype.getBoundary = function() {
          return this.getFactory().createGeometryCollection(null);
        }, e2.prototype.clone = function() {
          var e3 = t2.prototype.clone.call(this);
          return e3._coordinates = this._coordinates.clone(), e3;
        }, e2.prototype.getGeometryType = function() {
          return "Point";
        }, e2.prototype.copy = function() {
          return new e2(this._coordinates.copy(), this._factory);
        }, e2.prototype.getCoordinateSequence = function() {
          return this._coordinates;
        }, e2.prototype.getY = function() {
          if (null === this.getCoordinate())
            throw new Error("getY called on empty Point");
          return this.getCoordinate().y;
        }, e2.prototype.isEmpty = function() {
          return 0 === this._coordinates.size();
        }, e2.prototype.init = function(t3) {
          null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t3.size() <= 1), this._coordinates = t3;
        }, e2.prototype.isSimple = function() {
          return true;
        }, e2.prototype.interfaces_ = function() {
          return [Jt];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.serialVersionUID.get = function() {
          return 4902022702746615e3;
        }, Object.defineProperties(e2, n2), e2;
      }(ct), Zt = function() {
      };
      Zt.prototype.interfaces_ = function() {
        return [];
      }, Zt.prototype.getClass = function() {
        return Zt;
      };
      var $t = function(t2) {
        function e2(e3, n3, i2) {
          if (t2.call(this, i2), this._shell = null, this._holes = null, null === e3 && (e3 = this.getFactory().createLinearRing()), null === n3 && (n3 = []), t2.hasNullElements(n3))
            throw new m("holes must not contain null elements");
          if (e3.isEmpty() && t2.hasNonEmptyElements(n3))
            throw new m("shell is empty but holes are not");
          this._shell = e3, this._holes = n3;
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { serialVersionUID: { configurable: true } };
        return e2.prototype.computeEnvelopeInternal = function() {
          return this._shell.getEnvelopeInternal();
        }, e2.prototype.getSortIndex = function() {
          return t2.SORTINDEX_POLYGON;
        }, e2.prototype.getCoordinates = function() {
          if (this.isEmpty())
            return [];
          for (var t3 = new Array(this.getNumPoints()).fill(null), e3 = -1, n3 = this._shell.getCoordinates(), i2 = 0; i2 < n3.length; i2++)
            t3[++e3] = n3[i2];
          for (var r2 = 0; r2 < this._holes.length; r2++)
            for (var o2 = this._holes[r2].getCoordinates(), s2 = 0; s2 < o2.length; s2++)
              t3[++e3] = o2[s2];
          return t3;
        }, e2.prototype.getArea = function() {
          var t3 = 0;
          t3 += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));
          for (var e3 = 0; e3 < this._holes.length; e3++)
            t3 -= Math.abs(at.signedArea(this._holes[e3].getCoordinateSequence()));
          return t3;
        }, e2.prototype.isRectangle = function() {
          if (0 !== this.getNumInteriorRing())
            return false;
          if (null === this._shell)
            return false;
          if (5 !== this._shell.getNumPoints())
            return false;
          for (var t3 = this._shell.getCoordinateSequence(), e3 = this.getEnvelopeInternal(), n3 = 0; n3 < 5; n3++) {
            var i2 = t3.getX(n3);
            if (i2 !== e3.getMinX() && i2 !== e3.getMaxX())
              return false;
            var r2 = t3.getY(n3);
            if (r2 !== e3.getMinY() && r2 !== e3.getMaxY())
              return false;
          }
          for (var o2 = t3.getX(0), s2 = t3.getY(0), a2 = 1; a2 <= 4; a2++) {
            var u2 = t3.getX(a2), l2 = t3.getY(a2);
            if (u2 !== o2 === (l2 !== s2))
              return false;
            o2 = u2, s2 = l2;
          }
          return true;
        }, e2.prototype.equalsExact = function() {
          if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            if (!this.isEquivalentClass(e3))
              return false;
            var i2 = e3, r2 = this._shell, o2 = i2._shell;
            if (!r2.equalsExact(o2, n3))
              return false;
            if (this._holes.length !== i2._holes.length)
              return false;
            for (var s2 = 0; s2 < this._holes.length; s2++)
              if (!this._holes[s2].equalsExact(i2._holes[s2], n3))
                return false;
            return true;
          }
          return t2.prototype.equalsExact.apply(this, arguments);
        }, e2.prototype.normalize = function() {
          if (0 === arguments.length) {
            this.normalize(this._shell, true);
            for (var t3 = 0; t3 < this._holes.length; t3++)
              this.normalize(this._holes[t3], false);
            Gt.sort(this._holes);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            if (e3.isEmpty())
              return null;
            var i2 = new Array(e3.getCoordinates().length - 1).fill(null);
            Y.arraycopy(e3.getCoordinates(), 0, i2, 0, i2.length);
            var r2 = Lt.minCoordinate(e3.getCoordinates());
            Lt.scroll(i2, r2), Y.arraycopy(i2, 0, e3.getCoordinates(), 0, i2.length), e3.getCoordinates()[i2.length] = i2[0], at.isCCW(e3.getCoordinates()) === n3 && Lt.reverse(e3.getCoordinates());
          }
        }, e2.prototype.getCoordinate = function() {
          return this._shell.getCoordinate();
        }, e2.prototype.getNumInteriorRing = function() {
          return this._holes.length;
        }, e2.prototype.getBoundaryDimension = function() {
          return 1;
        }, e2.prototype.getDimension = function() {
          return 2;
        }, e2.prototype.getLength = function() {
          var t3 = 0;
          t3 += this._shell.getLength();
          for (var e3 = 0; e3 < this._holes.length; e3++)
            t3 += this._holes[e3].getLength();
          return t3;
        }, e2.prototype.getNumPoints = function() {
          for (var t3 = this._shell.getNumPoints(), e3 = 0; e3 < this._holes.length; e3++)
            t3 += this._holes[e3].getNumPoints();
          return t3;
        }, e2.prototype.reverse = function() {
          var t3 = this.copy();
          t3._shell = this._shell.copy().reverse(), t3._holes = new Array(this._holes.length).fill(null);
          for (var e3 = 0; e3 < this._holes.length; e3++)
            t3._holes[e3] = this._holes[e3].copy().reverse();
          return t3;
        }, e2.prototype.convexHull = function() {
          return this.getExteriorRing().convexHull();
        }, e2.prototype.compareToSameClass = function() {
          if (1 === arguments.length) {
            var t3 = arguments[0], e3 = this._shell, n3 = t3._shell;
            return e3.compareToSameClass(n3);
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this._shell, a2 = o2._shell, u2 = s2.compareToSameClass(a2, r2);
            if (0 !== u2)
              return u2;
            for (var l2 = this.getNumInteriorRing(), c2 = o2.getNumInteriorRing(), p2 = 0; p2 < l2 && p2 < c2; ) {
              var h2 = this.getInteriorRingN(p2), f2 = o2.getInteriorRingN(p2), g2 = h2.compareToSameClass(f2, r2);
              if (0 !== g2)
                return g2;
              p2++;
            }
            return p2 < l2 ? 1 : p2 < c2 ? -1 : 0;
          }
        }, e2.prototype.apply = function(t3) {
          if (T(t3, ft)) {
            this._shell.apply(t3);
            for (var e3 = 0; e3 < this._holes.length; e3++)
              this._holes[e3].apply(t3);
          } else if (T(t3, Ut)) {
            if (this._shell.apply(t3), !t3.isDone())
              for (var n3 = 0; n3 < this._holes.length && (this._holes[n3].apply(t3), !t3.isDone()); n3++)
                ;
            t3.isGeometryChanged() && this.geometryChanged();
          } else if (T(t3, Vt))
            t3.filter(this);
          else if (T(t3, lt)) {
            t3.filter(this), this._shell.apply(t3);
            for (var i2 = 0; i2 < this._holes.length; i2++)
              this._holes[i2].apply(t3);
          }
        }, e2.prototype.getBoundary = function() {
          if (this.isEmpty())
            return this.getFactory().createMultiLineString();
          var t3 = new Array(this._holes.length + 1).fill(null);
          t3[0] = this._shell;
          for (var e3 = 0; e3 < this._holes.length; e3++)
            t3[e3 + 1] = this._holes[e3];
          return t3.length <= 1 ? this.getFactory().createLinearRing(t3[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t3);
        }, e2.prototype.clone = function() {
          var e3 = t2.prototype.clone.call(this);
          e3._shell = this._shell.clone(), e3._holes = new Array(this._holes.length).fill(null);
          for (var n3 = 0; n3 < this._holes.length; n3++)
            e3._holes[n3] = this._holes[n3].clone();
          return e3;
        }, e2.prototype.getGeometryType = function() {
          return "Polygon";
        }, e2.prototype.copy = function() {
          for (var t3 = this._shell.copy(), n3 = new Array(this._holes.length).fill(null), i2 = 0; i2 < n3.length; i2++)
            n3[i2] = this._holes[i2].copy();
          return new e2(t3, n3, this._factory);
        }, e2.prototype.getExteriorRing = function() {
          return this._shell;
        }, e2.prototype.isEmpty = function() {
          return this._shell.isEmpty();
        }, e2.prototype.getInteriorRingN = function(t3) {
          return this._holes[t3];
        }, e2.prototype.interfaces_ = function() {
          return [Zt];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.serialVersionUID.get = function() {
          return -3494792200821764600;
        }, Object.defineProperties(e2, n2), e2;
      }(ct), te = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { serialVersionUID: { configurable: true } };
        return e2.prototype.getSortIndex = function() {
          return ct.SORTINDEX_MULTIPOINT;
        }, e2.prototype.isValid = function() {
          return true;
        }, e2.prototype.equalsExact = function() {
          if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            return !!this.isEquivalentClass(e3) && t2.prototype.equalsExact.call(this, e3, n3);
          }
          return t2.prototype.equalsExact.apply(this, arguments);
        }, e2.prototype.getCoordinate = function() {
          if (1 === arguments.length) {
            var e3 = arguments[0];
            return this._geometries[e3].getCoordinate();
          }
          return t2.prototype.getCoordinate.apply(this, arguments);
        }, e2.prototype.getBoundaryDimension = function() {
          return qt.FALSE;
        }, e2.prototype.getDimension = function() {
          return 0;
        }, e2.prototype.getBoundary = function() {
          return this.getFactory().createGeometryCollection(null);
        }, e2.prototype.getGeometryType = function() {
          return "MultiPoint";
        }, e2.prototype.copy = function() {
          for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
            t3[n3] = this._geometries[n3].copy();
          return new e2(t3, this._factory);
        }, e2.prototype.interfaces_ = function() {
          return [Jt];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.serialVersionUID.get = function() {
          return -8048474874175356e3;
        }, Object.defineProperties(e2, n2), e2;
      }(zt), ee = function(t2) {
        function e2(e3, n3) {
          e3 instanceof C && n3 instanceof _e && (e3 = n3.getCoordinateSequenceFactory().create(e3)), t2.call(this, e3, n3), this.validateConstruction();
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
        return e2.prototype.getSortIndex = function() {
          return ct.SORTINDEX_LINEARRING;
        }, e2.prototype.getBoundaryDimension = function() {
          return qt.FALSE;
        }, e2.prototype.isClosed = function() {
          return !!this.isEmpty() || t2.prototype.isClosed.call(this);
        }, e2.prototype.reverse = function() {
          var t3 = this._points.copy();
          Wt.reverse(t3);
          return this.getFactory().createLinearRing(t3);
        }, e2.prototype.validateConstruction = function() {
          if (!this.isEmpty() && !t2.prototype.isClosed.call(this))
            throw new m("Points of LinearRing do not form a closed linestring");
          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e2.MINIMUM_VALID_SIZE)
            throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        }, e2.prototype.getGeometryType = function() {
          return "LinearRing";
        }, e2.prototype.copy = function() {
          return new e2(this._points.copy(), this._factory);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.MINIMUM_VALID_SIZE.get = function() {
          return 4;
        }, n2.serialVersionUID.get = function() {
          return -4261142084085851600;
        }, Object.defineProperties(e2, n2), e2;
      }(Kt), ne = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { serialVersionUID: { configurable: true } };
        return e2.prototype.getSortIndex = function() {
          return ct.SORTINDEX_MULTIPOLYGON;
        }, e2.prototype.equalsExact = function() {
          if (2 === arguments.length) {
            var e3 = arguments[0], n3 = arguments[1];
            return !!this.isEquivalentClass(e3) && t2.prototype.equalsExact.call(this, e3, n3);
          }
          return t2.prototype.equalsExact.apply(this, arguments);
        }, e2.prototype.getBoundaryDimension = function() {
          return 1;
        }, e2.prototype.getDimension = function() {
          return 2;
        }, e2.prototype.reverse = function() {
          for (var t3 = this._geometries.length, e3 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
            e3[n3] = this._geometries[n3].reverse();
          return this.getFactory().createMultiPolygon(e3);
        }, e2.prototype.getBoundary = function() {
          if (this.isEmpty())
            return this.getFactory().createMultiLineString();
          for (var t3 = new Nt(), e3 = 0; e3 < this._geometries.length; e3++)
            for (var n3 = this._geometries[e3].getBoundary(), i2 = 0; i2 < n3.getNumGeometries(); i2++)
              t3.add(n3.getGeometryN(i2));
          var r2 = new Array(t3.size()).fill(null);
          return this.getFactory().createMultiLineString(t3.toArray(r2));
        }, e2.prototype.getGeometryType = function() {
          return "MultiPolygon";
        }, e2.prototype.copy = function() {
          for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
            t3[n3] = this._geometries[n3].copy();
          return new e2(t3, this._factory);
        }, e2.prototype.interfaces_ = function() {
          return [Zt];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.serialVersionUID.get = function() {
          return -551033529766975900;
        }, Object.defineProperties(e2, n2), e2;
      }(zt), ie = function(t2) {
        this._factory = t2 || null, this._isUserDataCopied = false;
      }, re = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
      ie.prototype.setCopyUserData = function(t2) {
        this._isUserDataCopied = t2;
      }, ie.prototype.edit = function(t2, e2) {
        if (null === t2)
          return null;
        var n2 = this.editInternal(t2, e2);
        return this._isUserDataCopied && n2.setUserData(t2.getUserData()), n2;
      }, ie.prototype.editInternal = function(t2, e2) {
        return null === this._factory && (this._factory = t2.getFactory()), t2 instanceof zt ? this.editGeometryCollection(t2, e2) : t2 instanceof $t ? this.editPolygon(t2, e2) : t2 instanceof Qt ? e2.edit(t2, this._factory) : t2 instanceof Kt ? e2.edit(t2, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t2.getClass().getName()), null);
      }, ie.prototype.editGeometryCollection = function(t2, e2) {
        for (var n2 = e2.edit(t2, this._factory), i2 = new Nt(), r2 = 0; r2 < n2.getNumGeometries(); r2++) {
          var o2 = this.edit(n2.getGeometryN(r2), e2);
          null === o2 || o2.isEmpty() || i2.add(o2);
        }
        return n2.getClass() === te ? this._factory.createMultiPoint(i2.toArray([])) : n2.getClass() === Xt ? this._factory.createMultiLineString(i2.toArray([])) : n2.getClass() === ne ? this._factory.createMultiPolygon(i2.toArray([])) : this._factory.createGeometryCollection(i2.toArray([]));
      }, ie.prototype.editPolygon = function(t2, e2) {
        var n2 = e2.edit(t2, this._factory);
        if (null === n2 && (n2 = this._factory.createPolygon(null)), n2.isEmpty())
          return n2;
        var i2 = this.edit(n2.getExteriorRing(), e2);
        if (null === i2 || i2.isEmpty())
          return this._factory.createPolygon();
        for (var r2 = new Nt(), o2 = 0; o2 < n2.getNumInteriorRing(); o2++) {
          var s2 = this.edit(n2.getInteriorRingN(o2), e2);
          null === s2 || s2.isEmpty() || r2.add(s2);
        }
        return this._factory.createPolygon(i2, r2.toArray([]));
      }, ie.prototype.interfaces_ = function() {
        return [];
      }, ie.prototype.getClass = function() {
        return ie;
      }, ie.GeometryEditorOperation = function() {
      }, re.NoOpGeometryOperation.get = function() {
        return oe;
      }, re.CoordinateOperation.get = function() {
        return se;
      }, re.CoordinateSequenceOperation.get = function() {
        return ae;
      }, Object.defineProperties(ie, re);
      var oe = function() {
      };
      oe.prototype.edit = function(t2, e2) {
        return t2;
      }, oe.prototype.interfaces_ = function() {
        return [ie.GeometryEditorOperation];
      }, oe.prototype.getClass = function() {
        return oe;
      };
      var se = function() {
      };
      se.prototype.edit = function(t2, e2) {
        var n2 = this.editCoordinates(t2.getCoordinates(), t2);
        return null === n2 ? t2 : t2 instanceof ee ? e2.createLinearRing(n2) : t2 instanceof Kt ? e2.createLineString(n2) : t2 instanceof Qt ? n2.length > 0 ? e2.createPoint(n2[0]) : e2.createPoint() : t2;
      }, se.prototype.interfaces_ = function() {
        return [ie.GeometryEditorOperation];
      }, se.prototype.getClass = function() {
        return se;
      };
      var ae = function() {
      };
      ae.prototype.edit = function(t2, e2) {
        return t2 instanceof ee ? e2.createLinearRing(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Kt ? e2.createLineString(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Qt ? e2.createPoint(this.edit(t2.getCoordinateSequence(), t2)) : t2;
      }, ae.prototype.interfaces_ = function() {
        return [ie.GeometryEditorOperation];
      }, ae.prototype.getClass = function() {
        return ae;
      };
      var ue = function() {
        if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
          if (arguments[0] instanceof Array)
            this._coordinates = arguments[0], this._dimension = 3;
          else if (Number.isInteger(arguments[0])) {
            var t2 = arguments[0];
            this._coordinates = new Array(t2).fill(null);
            for (var e2 = 0; e2 < t2; e2++)
              this._coordinates[e2] = new C();
          } else if (T(arguments[0], V)) {
            var n2 = arguments[0];
            if (null === n2)
              return this._coordinates = new Array(0).fill(null), null;
            this._dimension = n2.getDimension(), this._coordinates = new Array(n2.size()).fill(null);
            for (var i2 = 0; i2 < this._coordinates.length; i2++)
              this._coordinates[i2] = n2.getCoordinateCopy(i2);
          }
        } else if (2 === arguments.length) {
          if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var r2 = arguments[0], o2 = arguments[1];
            this._coordinates = r2, this._dimension = o2, null === r2 && (this._coordinates = new Array(0).fill(null));
          } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var s2 = arguments[0], a2 = arguments[1];
            this._coordinates = new Array(s2).fill(null), this._dimension = a2;
            for (var u2 = 0; u2 < s2; u2++)
              this._coordinates[u2] = new C();
          }
        }
      }, le = { serialVersionUID: { configurable: true } };
      ue.prototype.setOrdinate = function(t2, e2, n2) {
        switch (e2) {
          case V.X:
            this._coordinates[t2].x = n2;
            break;
          case V.Y:
            this._coordinates[t2].y = n2;
            break;
          case V.Z:
            this._coordinates[t2].z = n2;
            break;
          default:
            throw new m("invalid ordinateIndex");
        }
      }, ue.prototype.size = function() {
        return this._coordinates.length;
      }, ue.prototype.getOrdinate = function(t2, e2) {
        switch (e2) {
          case V.X:
            return this._coordinates[t2].x;
          case V.Y:
            return this._coordinates[t2].y;
          case V.Z:
            return this._coordinates[t2].z;
        }
        return v.NaN;
      }, ue.prototype.getCoordinate = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this._coordinates[t2];
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          n2.x = this._coordinates[e2].x, n2.y = this._coordinates[e2].y, n2.z = this._coordinates[e2].z;
        }
      }, ue.prototype.getCoordinateCopy = function(t2) {
        return new C(this._coordinates[t2]);
      }, ue.prototype.getDimension = function() {
        return this._dimension;
      }, ue.prototype.getX = function(t2) {
        return this._coordinates[t2].x;
      }, ue.prototype.clone = function() {
        for (var t2 = new Array(this.size()).fill(null), e2 = 0; e2 < this._coordinates.length; e2++)
          t2[e2] = this._coordinates[e2].clone();
        return new ue(t2, this._dimension);
      }, ue.prototype.expandEnvelope = function(t2) {
        for (var e2 = 0; e2 < this._coordinates.length; e2++)
          t2.expandToInclude(this._coordinates[e2]);
        return t2;
      }, ue.prototype.copy = function() {
        for (var t2 = new Array(this.size()).fill(null), e2 = 0; e2 < this._coordinates.length; e2++)
          t2[e2] = this._coordinates[e2].copy();
        return new ue(t2, this._dimension);
      }, ue.prototype.toString = function() {
        if (this._coordinates.length > 0) {
          var t2 = new D(17 * this._coordinates.length);
          t2.append("("), t2.append(this._coordinates[0]);
          for (var e2 = 1; e2 < this._coordinates.length; e2++)
            t2.append(", "), t2.append(this._coordinates[e2]);
          return t2.append(")"), t2.toString();
        }
        return "()";
      }, ue.prototype.getY = function(t2) {
        return this._coordinates[t2].y;
      }, ue.prototype.toCoordinateArray = function() {
        return this._coordinates;
      }, ue.prototype.interfaces_ = function() {
        return [V, e];
      }, ue.prototype.getClass = function() {
        return ue;
      }, le.serialVersionUID.get = function() {
        return -915438501601840600;
      }, Object.defineProperties(ue, le);
      var ce = function() {
      }, pe = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
      ce.prototype.readResolve = function() {
        return ce.instance();
      }, ce.prototype.create = function() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return new ue(t2);
          }
          if (T(arguments[0], V)) {
            var e2 = arguments[0];
            return new ue(e2);
          }
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          return i2 > 3 && (i2 = 3), i2 < 2 ? new ue(n2) : new ue(n2, i2);
        }
      }, ce.prototype.interfaces_ = function() {
        return [b, e];
      }, ce.prototype.getClass = function() {
        return ce;
      }, ce.instance = function() {
        return ce.instanceObject;
      }, pe.serialVersionUID.get = function() {
        return -4099577099607551500;
      }, pe.instanceObject.get = function() {
        return new ce();
      }, Object.defineProperties(ce, pe);
      var he = function(t2) {
        function e2() {
          t2.call(this), this.map_ = /* @__PURE__ */ new Map();
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.get = function(t3) {
          return this.map_.get(t3) || null;
        }, e2.prototype.put = function(t3, e3) {
          return this.map_.set(t3, e3), e3;
        }, e2.prototype.values = function() {
          for (var t3 = new Nt(), e3 = this.map_.values(), n2 = e3.next(); !n2.done; )
            t3.add(n2.value), n2 = e3.next();
          return t3;
        }, e2.prototype.entrySet = function() {
          var t3 = new Pt();
          return this.map_.entries().forEach(function(e3) {
            return t3.add(e3);
          }), t3;
        }, e2.prototype.size = function() {
          return this.map_.size();
        }, e2;
      }(Tt), fe = function t2() {
        if (this._modelType = null, this._scale = null, 0 === arguments.length)
          this._modelType = t2.FLOATING;
        else if (1 === arguments.length) {
          if (arguments[0] instanceof de) {
            var e2 = arguments[0];
            this._modelType = e2, e2 === t2.FIXED && this.setScale(1);
          } else if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            this._modelType = t2.FIXED, this.setScale(n2);
          } else if (arguments[0] instanceof t2) {
            var i2 = arguments[0];
            this._modelType = i2._modelType, this._scale = i2._scale;
          }
        }
      }, ge = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
      fe.prototype.equals = function(t2) {
        if (!(t2 instanceof fe))
          return false;
        var e2 = t2;
        return this._modelType === e2._modelType && this._scale === e2._scale;
      }, fe.prototype.compareTo = function(t2) {
        var e2 = t2, n2 = this.getMaximumSignificantDigits(), i2 = e2.getMaximumSignificantDigits();
        return new M(n2).compareTo(new M(i2));
      }, fe.prototype.getScale = function() {
        return this._scale;
      }, fe.prototype.isFloating = function() {
        return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;
      }, fe.prototype.getType = function() {
        return this._modelType;
      }, fe.prototype.toString = function() {
        var t2 = "UNKNOWN";
        return this._modelType === fe.FLOATING ? t2 = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t2 = "Floating-Single" : this._modelType === fe.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
      }, fe.prototype.makePrecise = function() {
        if ("number" == typeof arguments[0]) {
          var t2 = arguments[0];
          if (v.isNaN(t2))
            return t2;
          if (this._modelType === fe.FLOATING_SINGLE) {
            return t2;
          }
          return this._modelType === fe.FIXED ? Math.round(t2 * this._scale) / this._scale : t2;
        }
        if (arguments[0] instanceof C) {
          var e2 = arguments[0];
          if (this._modelType === fe.FLOATING)
            return null;
          e2.x = this.makePrecise(e2.x), e2.y = this.makePrecise(e2.y);
        }
      }, fe.prototype.getMaximumSignificantDigits = function() {
        var t2 = 16;
        return this._modelType === fe.FLOATING ? t2 = 16 : this._modelType === fe.FLOATING_SINGLE ? t2 = 6 : this._modelType === fe.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
      }, fe.prototype.setScale = function(t2) {
        this._scale = Math.abs(t2);
      }, fe.prototype.interfaces_ = function() {
        return [e, E];
      }, fe.prototype.getClass = function() {
        return fe;
      }, fe.mostPrecise = function(t2, e2) {
        return t2.compareTo(e2) >= 0 ? t2 : e2;
      }, ge.serialVersionUID.get = function() {
        return 7777263578777804e3;
      }, ge.maximumPreciseValue.get = function() {
        return 9007199254740992;
      }, Object.defineProperties(fe, ge);
      var de = function t2(e2) {
        this._name = e2 || null, t2.nameToTypeMap.put(e2, this);
      }, ye = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
      de.prototype.readResolve = function() {
        return de.nameToTypeMap.get(this._name);
      }, de.prototype.toString = function() {
        return this._name;
      }, de.prototype.interfaces_ = function() {
        return [e];
      }, de.prototype.getClass = function() {
        return de;
      }, ye.serialVersionUID.get = function() {
        return -552860263173159e4;
      }, ye.nameToTypeMap.get = function() {
        return new he();
      }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de("FIXED"), fe.FLOATING = new de("FLOATING"), fe.FLOATING_SINGLE = new de("FLOATING SINGLE");
      var _e = function t2() {
        this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t2.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
      }, me = { serialVersionUID: { configurable: true } };
      _e.prototype.toGeometry = function(t2) {
        return t2.isNull() ? this.createPoint(null) : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new C(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMinX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMinY()), new C(t2.getMinX(), t2.getMinY())]), null);
      }, _e.prototype.createLineString = function(t2) {
        return t2 ? t2 instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t2), this) : T(t2, V) ? new Kt(t2, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);
      }, _e.prototype.createMultiLineString = function() {
        if (0 === arguments.length)
          return new Xt(null, this);
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new Xt(t2, this);
        }
      }, _e.prototype.buildGeometry = function(t2) {
        for (var e2 = null, n2 = false, i2 = false, r2 = t2.iterator(); r2.hasNext(); ) {
          var o2 = r2.next(), s2 = o2.getClass();
          null === e2 && (e2 = s2), s2 !== e2 && (n2 = true), o2.isGeometryCollectionOrDerived() && (i2 = true);
        }
        if (null === e2)
          return this.createGeometryCollection();
        if (n2 || i2)
          return this.createGeometryCollection(_e.toGeometryArray(t2));
        var a2 = t2.iterator().next();
        if (t2.size() > 1) {
          if (a2 instanceof $t)
            return this.createMultiPolygon(_e.toPolygonArray(t2));
          if (a2 instanceof Kt)
            return this.createMultiLineString(_e.toLineStringArray(t2));
          if (a2 instanceof Qt)
            return this.createMultiPoint(_e.toPointArray(t2));
          et.shouldNeverReachHere("Unhandled class: " + a2.getClass().getName());
        }
        return a2;
      }, _e.prototype.createMultiPointFromCoords = function(t2) {
        return this.createMultiPoint(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
      }, _e.prototype.createPoint = function() {
        if (0 === arguments.length)
          return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        if (1 === arguments.length) {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            return this.createPoint(null !== t2 ? this.getCoordinateSequenceFactory().create([t2]) : null);
          }
          if (T(arguments[0], V)) {
            var e2 = arguments[0];
            return new Qt(e2, this);
          }
        }
      }, _e.prototype.getCoordinateSequenceFactory = function() {
        return this._coordinateSequenceFactory;
      }, _e.prototype.createPolygon = function() {
        if (0 === arguments.length)
          return new $t(null, null, this);
        if (1 === arguments.length) {
          if (T(arguments[0], V)) {
            var t2 = arguments[0];
            return this.createPolygon(this.createLinearRing(t2));
          }
          if (arguments[0] instanceof Array) {
            var e2 = arguments[0];
            return this.createPolygon(this.createLinearRing(e2));
          }
          if (arguments[0] instanceof ee) {
            var n2 = arguments[0];
            return this.createPolygon(n2, null);
          }
        } else if (2 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1];
          return new $t(i2, r2, this);
        }
      }, _e.prototype.getSRID = function() {
        return this._SRID;
      }, _e.prototype.createGeometryCollection = function() {
        if (0 === arguments.length)
          return new zt(null, this);
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new zt(t2, this);
        }
      }, _e.prototype.createGeometry = function(t2) {
        return new ie(this).edit(t2, { edit: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0];
            return this._coordinateSequenceFactory.create(t3);
          }
        } });
      }, _e.prototype.getPrecisionModel = function() {
        return this._precisionModel;
      }, _e.prototype.createLinearRing = function() {
        if (0 === arguments.length)
          return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return this.createLinearRing(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
          }
          if (T(arguments[0], V)) {
            var e2 = arguments[0];
            return new ee(e2, this);
          }
        }
      }, _e.prototype.createMultiPolygon = function() {
        if (0 === arguments.length)
          return new ne(null, this);
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new ne(t2, this);
        }
      }, _e.prototype.createMultiPoint = function() {
        if (0 === arguments.length)
          return new te(null, this);
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            return new te(t2, this);
          }
          if (arguments[0] instanceof Array) {
            var e2 = arguments[0];
            return this.createMultiPoint(null !== e2 ? this.getCoordinateSequenceFactory().create(e2) : null);
          }
          if (T(arguments[0], V)) {
            var n2 = arguments[0];
            if (null === n2)
              return this.createMultiPoint(new Array(0).fill(null));
            for (var i2 = new Array(n2.size()).fill(null), r2 = 0; r2 < n2.size(); r2++) {
              var o2 = this.getCoordinateSequenceFactory().create(1, n2.getDimension());
              Wt.copy(n2, r2, o2, 0, 1), i2[r2] = this.createPoint(o2);
            }
            return this.createMultiPoint(i2);
          }
        }
      }, _e.prototype.interfaces_ = function() {
        return [e];
      }, _e.prototype.getClass = function() {
        return _e;
      }, _e.toMultiPolygonArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.toGeometryArray = function(t2) {
        if (null === t2)
          return null;
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.getDefaultCoordinateSequenceFactory = function() {
        return ce.instance();
      }, _e.toMultiLineStringArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.toLineStringArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.toMultiPointArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.toLinearRingArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.toPointArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.toPolygonArray = function(t2) {
        var e2 = new Array(t2.size()).fill(null);
        return t2.toArray(e2);
      }, _e.createPointFromInternalCoord = function(t2, e2) {
        return e2.getPrecisionModel().makePrecise(t2), e2.getFactory().createPoint(t2);
      }, me.serialVersionUID.get = function() {
        return -6820524753094096e3;
      }, Object.defineProperties(_e, me);
      var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ie = function(t2) {
        this.geometryFactory = t2 || new _e();
      };
      Ie.prototype.read = function(t2) {
        var e2, n2 = (e2 = "string" == typeof t2 ? JSON.parse(t2) : t2).type;
        if (!Ee[n2])
          throw new Error("Unknown GeoJSON type: " + e2.type);
        return -1 !== ve.indexOf(n2) ? Ee[n2].apply(this, [e2.coordinates]) : "GeometryCollection" === n2 ? Ee[n2].apply(this, [e2.geometries]) : Ee[n2].apply(this, [e2]);
      }, Ie.prototype.write = function(t2) {
        var e2 = t2.getGeometryType();
        if (!xe[e2])
          throw new Error("Geometry is not supported");
        return xe[e2].apply(this, [t2]);
      };
      var Ee = { Feature: function(t2) {
        var e2 = {};
        for (var n2 in t2)
          e2[n2] = t2[n2];
        if (t2.geometry) {
          var i2 = t2.geometry.type;
          if (!Ee[i2])
            throw new Error("Unknown GeoJSON type: " + t2.type);
          e2.geometry = this.read(t2.geometry);
        }
        return t2.bbox && (e2.bbox = Ee.bbox.apply(this, [t2.bbox])), e2;
      }, FeatureCollection: function(t2) {
        var e2 = {};
        if (t2.features) {
          e2.features = [];
          for (var n2 = 0; n2 < t2.features.length; ++n2)
            e2.features.push(this.read(t2.features[n2]));
        }
        return t2.bbox && (e2.bbox = this.parse.bbox.apply(this, [t2.bbox])), e2;
      }, coordinates: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e2.push(new C(i2[0], i2[1]));
        }
        return e2;
      }, bbox: function(t2) {
        return this.geometryFactory.createLinearRing([new C(t2[0], t2[1]), new C(t2[2], t2[1]), new C(t2[2], t2[3]), new C(t2[0], t2[3]), new C(t2[0], t2[1])]);
      }, Point: function(t2) {
        var e2 = new C(t2[0], t2[1]);
        return this.geometryFactory.createPoint(e2);
      }, MultiPoint: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2)
          e2.push(Ee.Point.apply(this, [t2[n2]]));
        return this.geometryFactory.createMultiPoint(e2);
      }, LineString: function(t2) {
        var e2 = Ee.coordinates.apply(this, [t2]);
        return this.geometryFactory.createLineString(e2);
      }, MultiLineString: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2)
          e2.push(Ee.LineString.apply(this, [t2[n2]]));
        return this.geometryFactory.createMultiLineString(e2);
      }, Polygon: function(t2) {
        for (var e2 = Ee.coordinates.apply(this, [t2[0]]), n2 = this.geometryFactory.createLinearRing(e2), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
          var o2 = t2[r2], s2 = Ee.coordinates.apply(this, [o2]), a2 = this.geometryFactory.createLinearRing(s2);
          i2.push(a2);
        }
        return this.geometryFactory.createPolygon(n2, i2);
      }, MultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e2.push(Ee.Polygon.apply(this, [i2]));
        }
        return this.geometryFactory.createMultiPolygon(e2);
      }, GeometryCollection: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e2.push(this.read(i2));
        }
        return this.geometryFactory.createGeometryCollection(e2);
      } }, xe = { coordinate: function(t2) {
        return [t2.x, t2.y];
      }, Point: function(t2) {
        return { type: "Point", coordinates: xe.coordinate.apply(this, [t2.getCoordinate()]) };
      }, MultiPoint: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = xe.Point.apply(this, [i2]);
          e2.push(r2.coordinates);
        }
        return { type: "MultiPoint", coordinates: e2 };
      }, LineString: function(t2) {
        for (var e2 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
          var r2 = n2[i2];
          e2.push(xe.coordinate.apply(this, [r2]));
        }
        return { type: "LineString", coordinates: e2 };
      }, MultiLineString: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = xe.LineString.apply(this, [i2]);
          e2.push(r2.coordinates);
        }
        return { type: "MultiLineString", coordinates: e2 };
      }, Polygon: function(t2) {
        var e2 = [], n2 = xe.LineString.apply(this, [t2._shell]);
        e2.push(n2.coordinates);
        for (var i2 = 0; i2 < t2._holes.length; ++i2) {
          var r2 = t2._holes[i2], o2 = xe.LineString.apply(this, [r2]);
          e2.push(o2.coordinates);
        }
        return { type: "Polygon", coordinates: e2 };
      }, MultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = xe.Polygon.apply(this, [i2]);
          e2.push(r2.coordinates);
        }
        return { type: "MultiPolygon", coordinates: e2 };
      }, GeometryCollection: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
          e2.push(xe[r2].apply(this, [i2]));
        }
        return { type: "GeometryCollection", geometries: e2 };
      } }, Ne = function(t2) {
        this.geometryFactory = t2 || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
      };
      Ne.prototype.read = function(t2) {
        var e2 = this.parser.read(t2);
        return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e2), e2;
      }, Ne.prototype.reducePrecision = function(t2) {
        var e2, n2;
        if (t2.coordinate)
          this.precisionModel.makePrecise(t2.coordinate);
        else if (t2.points)
          for (e2 = 0, n2 = t2.points.length; e2 < n2; e2++)
            this.precisionModel.makePrecise(t2.points[e2]);
        else if (t2.geometries)
          for (e2 = 0, n2 = t2.geometries.length; e2 < n2; e2++)
            this.reducePrecision(t2.geometries[e2]);
      };
      var Ce = function() {
        this.parser = new Ie(this.geometryFactory);
      };
      Ce.prototype.write = function(t2) {
        return this.parser.write(t2);
      };
      var Se = function() {
      }, Le = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
      Se.prototype.interfaces_ = function() {
        return [];
      }, Se.prototype.getClass = function() {
        return Se;
      }, Se.opposite = function(t2) {
        return t2 === Se.LEFT ? Se.RIGHT : t2 === Se.RIGHT ? Se.LEFT : t2;
      }, Le.ON.get = function() {
        return 0;
      }, Le.LEFT.get = function() {
        return 1;
      }, Le.RIGHT.get = function() {
        return 2;
      }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = "EmptyStackException", (y.prototype = new xt()).add = function(t2) {
        return this.array_.push(t2), true;
      }, y.prototype.get = function(t2) {
        if (t2 < 0 || t2 >= this.size())
          throw new Error();
        return this.array_[t2];
      }, y.prototype.push = function(t2) {
        return this.array_.push(t2), t2;
      }, y.prototype.pop = function(t2) {
        if (0 === this.array_.length)
          throw new d();
        return this.array_.pop();
      }, y.prototype.peek = function() {
        if (0 === this.array_.length)
          throw new d();
        return this.array_[this.array_.length - 1];
      }, y.prototype.empty = function() {
        return 0 === this.array_.length;
      }, y.prototype.isEmpty = function() {
        return this.empty();
      }, y.prototype.search = function(t2) {
        return this.array_.indexOf(t2);
      }, y.prototype.size = function() {
        return this.array_.length;
      }, y.prototype.toArray = function() {
        for (var t2 = [], e2 = 0, n2 = this.array_.length; e2 < n2; e2++)
          t2.push(this.array_[e2]);
        return t2;
      };
      var be = function() {
        this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
      };
      be.prototype.getCoordinate = function() {
        return this._minCoord;
      }, be.prototype.getRightmostSide = function(t2, e2) {
        var n2 = this.getRightmostSideOfSegment(t2, e2);
        return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e2 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
      }, be.prototype.findRightmostEdgeAtVertex = function() {
        var t2 = this._minDe.getEdge().getCoordinates();
        et.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
        var e2 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = at.computeOrientation(this._minCoord, n2, e2), r2 = false;
        e2.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === at.COUNTERCLOCKWISE ? r2 = true : e2.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === at.CLOCKWISE && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
      }, be.prototype.getRightmostSideOfSegment = function(t2, e2) {
        var n2 = t2.getEdge().getCoordinates();
        if (e2 < 0 || e2 + 1 >= n2.length)
          return -1;
        if (n2[e2].y === n2[e2 + 1].y)
          return -1;
        var i2 = Se.LEFT;
        return n2[e2].y < n2[e2 + 1].y && (i2 = Se.RIGHT), i2;
      }, be.prototype.getEdge = function() {
        return this._orientedDe;
      }, be.prototype.checkForRightmostCoordinate = function(t2) {
        for (var e2 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e2.length - 1; n2++)
          (null === this._minCoord || e2[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e2[n2]);
      }, be.prototype.findRightmostEdgeAtNode = function() {
        var t2 = this._minDe.getNode().getEdges();
        this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
      }, be.prototype.findEdge = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          n2.isForward() && this.checkForRightmostCoordinate(n2);
        }
        et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
        this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());
      }, be.prototype.interfaces_ = function() {
        return [];
      }, be.prototype.getClass = function() {
        return be;
      };
      var we = function(t2) {
        function e2(n2, i2) {
          t2.call(this, e2.msgWithCoord(n2, i2)), this.pt = i2 ? new C(i2) : null, this.name = "TopologyException";
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getCoordinate = function() {
          return this.pt;
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2.msgWithCoord = function(t3, e3) {
          return e3 ? t3 : t3 + " [ " + e3 + " ]";
        }, e2;
      }($), Oe = function() {
        this.array_ = [];
      };
      Oe.prototype.addLast = function(t2) {
        this.array_.push(t2);
      }, Oe.prototype.removeFirst = function() {
        return this.array_.shift();
      }, Oe.prototype.isEmpty = function() {
        return 0 === this.array_.length;
      };
      var Te = function() {
        this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();
      };
      Te.prototype.clearVisitedEdges = function() {
        for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
          t2.next().setVisited(false);
        }
      }, Te.prototype.getRightmostCoordinate = function() {
        return this._rightMostCoord;
      }, Te.prototype.computeNodeDepth = function(t2) {
        for (var e2 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          if (i2.isVisited() || i2.getSym().isVisited()) {
            e2 = i2;
            break;
          }
        }
        if (null === e2)
          throw new we("unable to find edge to compute depths at " + t2.getCoordinate());
        t2.getEdges().computeDepths(e2);
        for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
          var o2 = r2.next();
          o2.setVisited(true), this.copySymDepths(o2);
        }
      }, Te.prototype.computeDepth = function(t2) {
        this.clearVisitedEdges();
        var e2 = this._finder.getEdge();
        e2.setEdgeDepths(Se.RIGHT, t2), this.copySymDepths(e2), this.computeDepths(e2);
      }, Te.prototype.create = function(t2) {
        this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
      }, Te.prototype.findResultEdges = function() {
        for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
          var e2 = t2.next();
          e2.getDepth(Se.RIGHT) >= 1 && e2.getDepth(Se.LEFT) <= 0 && !e2.isInteriorAreaEdge() && e2.setInResult(true);
        }
      }, Te.prototype.computeDepths = function(t2) {
        var e2 = new Pt(), n2 = new Oe(), i2 = t2.getNode();
        for (n2.addLast(i2), e2.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
          var r2 = n2.removeFirst();
          e2.add(r2), this.computeNodeDepth(r2);
          for (var o2 = r2.getEdges().iterator(); o2.hasNext(); ) {
            var s2 = o2.next().getSym();
            if (!s2.isVisited()) {
              var a2 = s2.getNode();
              e2.contains(a2) || (n2.addLast(a2), e2.add(a2));
            }
          }
        }
      }, Te.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this._rightMostCoord.x < e2._rightMostCoord.x ? -1 : this._rightMostCoord.x > e2._rightMostCoord.x ? 1 : 0;
      }, Te.prototype.getEnvelope = function() {
        if (null === this._env) {
          for (var t2 = new j(), e2 = this._dirEdgeList.iterator(); e2.hasNext(); )
            for (var n2 = e2.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++)
              t2.expandToInclude(n2[i2]);
          this._env = t2;
        }
        return this._env;
      }, Te.prototype.addReachable = function(t2) {
        var e2 = new y();
        for (e2.add(t2); !e2.empty(); ) {
          var n2 = e2.pop();
          this.add(n2, e2);
        }
      }, Te.prototype.copySymDepths = function(t2) {
        var e2 = t2.getSym();
        e2.setDepth(Se.LEFT, t2.getDepth(Se.RIGHT)), e2.setDepth(Se.RIGHT, t2.getDepth(Se.LEFT));
      }, Te.prototype.add = function(t2, e2) {
        t2.setVisited(true), this._nodes.add(t2);
        for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          this._dirEdgeList.add(i2);
          var r2 = i2.getSym().getNode();
          r2.isVisited() || e2.push(r2);
        }
      }, Te.prototype.getNodes = function() {
        return this._nodes;
      }, Te.prototype.getDirectedEdges = function() {
        return this._dirEdgeList;
      }, Te.prototype.interfaces_ = function() {
        return [E];
      }, Te.prototype.getClass = function() {
        return Te;
      };
      var Re = function t2() {
        if (this.location = null, 1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var e2 = arguments[0];
            this.init(e2.length);
          } else if (Number.isInteger(arguments[0])) {
            var n2 = arguments[0];
            this.init(1), this.location[Se.ON] = n2;
          } else if (arguments[0] instanceof t2) {
            var i2 = arguments[0];
            if (this.init(i2.location.length), null !== i2)
              for (var r2 = 0; r2 < this.location.length; r2++)
                this.location[r2] = i2.location[r2];
          }
        } else if (3 === arguments.length) {
          var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
          this.init(3), this.location[Se.ON] = o2, this.location[Se.LEFT] = s2, this.location[Se.RIGHT] = a2;
        }
      };
      Re.prototype.setAllLocations = function(t2) {
        for (var e2 = 0; e2 < this.location.length; e2++)
          this.location[e2] = t2;
      }, Re.prototype.isNull = function() {
        for (var t2 = 0; t2 < this.location.length; t2++)
          if (this.location[t2] !== w.NONE)
            return false;
        return true;
      }, Re.prototype.setAllLocationsIfNull = function(t2) {
        for (var e2 = 0; e2 < this.location.length; e2++)
          this.location[e2] === w.NONE && (this.location[e2] = t2);
      }, Re.prototype.isLine = function() {
        return 1 === this.location.length;
      }, Re.prototype.merge = function(t2) {
        if (t2.location.length > this.location.length) {
          var e2 = new Array(3).fill(null);
          e2[Se.ON] = this.location[Se.ON], e2[Se.LEFT] = w.NONE, e2[Se.RIGHT] = w.NONE, this.location = e2;
        }
        for (var n2 = 0; n2 < this.location.length; n2++)
          this.location[n2] === w.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
      }, Re.prototype.getLocations = function() {
        return this.location;
      }, Re.prototype.flip = function() {
        if (this.location.length <= 1)
          return null;
        var t2 = this.location[Se.LEFT];
        this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t2;
      }, Re.prototype.toString = function() {
        var t2 = new D();
        return this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.LEFT])), t2.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.RIGHT])), t2.toString();
      }, Re.prototype.setLocations = function(t2, e2, n2) {
        this.location[Se.ON] = t2, this.location[Se.LEFT] = e2, this.location[Se.RIGHT] = n2;
      }, Re.prototype.get = function(t2) {
        return t2 < this.location.length ? this.location[t2] : w.NONE;
      }, Re.prototype.isArea = function() {
        return this.location.length > 1;
      }, Re.prototype.isAnyNull = function() {
        for (var t2 = 0; t2 < this.location.length; t2++)
          if (this.location[t2] === w.NONE)
            return true;
        return false;
      }, Re.prototype.setLocation = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setLocation(Se.ON, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.location[e2] = n2;
        }
      }, Re.prototype.init = function(t2) {
        this.location = new Array(t2).fill(null), this.setAllLocations(w.NONE);
      }, Re.prototype.isEqualOnSide = function(t2, e2) {
        return this.location[e2] === t2.location[e2];
      }, Re.prototype.allPositionsEqual = function(t2) {
        for (var e2 = 0; e2 < this.location.length; e2++)
          if (this.location[e2] !== t2)
            return false;
        return true;
      }, Re.prototype.interfaces_ = function() {
        return [];
      }, Re.prototype.getClass = function() {
        return Re;
      };
      var Pe = function t2() {
        if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
          if (Number.isInteger(arguments[0])) {
            var e2 = arguments[0];
            this.elt[0] = new Re(e2), this.elt[1] = new Re(e2);
          } else if (arguments[0] instanceof t2) {
            var n2 = arguments[0];
            this.elt[0] = new Re(n2.elt[0]), this.elt[1] = new Re(n2.elt[1]);
          }
        } else if (2 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1];
          this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i2].setLocation(r2);
        } else if (3 === arguments.length) {
          var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
          this.elt[0] = new Re(o2, s2, a2), this.elt[1] = new Re(o2, s2, a2);
        } else if (4 === arguments.length) {
          var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2], p2 = arguments[3];
          this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u2].setLocations(l2, c2, p2);
        }
      };
      Pe.prototype.getGeometryCount = function() {
        var t2 = 0;
        return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
      }, Pe.prototype.setAllLocations = function(t2, e2) {
        this.elt[t2].setAllLocations(e2);
      }, Pe.prototype.isNull = function(t2) {
        return this.elt[t2].isNull();
      }, Pe.prototype.setAllLocationsIfNull = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.elt[e2].setAllLocationsIfNull(n2);
        }
      }, Pe.prototype.isLine = function(t2) {
        return this.elt[t2].isLine();
      }, Pe.prototype.merge = function(t2) {
        for (var e2 = 0; e2 < 2; e2++)
          null === this.elt[e2] && null !== t2.elt[e2] ? this.elt[e2] = new Re(t2.elt[e2]) : this.elt[e2].merge(t2.elt[e2]);
      }, Pe.prototype.flip = function() {
        this.elt[0].flip(), this.elt[1].flip();
      }, Pe.prototype.getLocation = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.elt[t2].get(Se.ON);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return this.elt[e2].get(n2);
        }
      }, Pe.prototype.toString = function() {
        var t2 = new D();
        return null !== this.elt[0] && (t2.append("A:"), t2.append(this.elt[0].toString())), null !== this.elt[1] && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
      }, Pe.prototype.isArea = function() {
        if (0 === arguments.length)
          return this.elt[0].isArea() || this.elt[1].isArea();
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.elt[t2].isArea();
        }
      }, Pe.prototype.isAnyNull = function(t2) {
        return this.elt[t2].isAnyNull();
      }, Pe.prototype.setLocation = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.elt[t2].setLocation(Se.ON, e2);
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
          this.elt[n2].setLocation(i2, r2);
        }
      }, Pe.prototype.isEqualOnSide = function(t2, e2) {
        return this.elt[0].isEqualOnSide(t2.elt[0], e2) && this.elt[1].isEqualOnSide(t2.elt[1], e2);
      }, Pe.prototype.allPositionsEqual = function(t2, e2) {
        return this.elt[t2].allPositionsEqual(e2);
      }, Pe.prototype.toLine = function(t2) {
        this.elt[t2].isArea() && (this.elt[t2] = new Re(this.elt[t2].location[0]));
      }, Pe.prototype.interfaces_ = function() {
        return [];
      }, Pe.prototype.getClass = function() {
        return Pe;
      }, Pe.toLineLabel = function(t2) {
        for (var e2 = new Pe(w.NONE), n2 = 0; n2 < 2; n2++)
          e2.setLocation(n2, t2.getLocation(n2));
        return e2;
      };
      var De = function() {
        this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;
        var t2 = arguments[0], e2 = arguments[1];
        this._geometryFactory = e2, this.computePoints(t2), this.computeRing();
      };
      De.prototype.computeRing = function() {
        if (null !== this._ring)
          return null;
        for (var t2 = new Array(this._pts.size()).fill(null), e2 = 0; e2 < this._pts.size(); e2++)
          t2[e2] = this._pts.get(e2);
        this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = at.isCCW(this._ring.getCoordinates());
      }, De.prototype.isIsolated = function() {
        return 1 === this._label.getGeometryCount();
      }, De.prototype.computePoints = function(t2) {
        this._startDe = t2;
        var e2 = t2, n2 = true;
        do {
          if (null === e2)
            throw new we("Found null DirectedEdge");
          if (e2.getEdgeRing() === this)
            throw new we("Directed Edge visited twice during ring-building at " + e2.getCoordinate());
          this._edges.add(e2);
          var i2 = e2.getLabel();
          et.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e2.getEdge(), e2.isForward(), n2), n2 = false, this.setEdgeRing(e2, this), e2 = this.getNext(e2);
        } while (e2 !== this._startDe);
      }, De.prototype.getLinearRing = function() {
        return this._ring;
      }, De.prototype.getCoordinate = function(t2) {
        return this._pts.get(t2);
      }, De.prototype.computeMaxNodeDegree = function() {
        this._maxNodeDegree = 0;
        var t2 = this._startDe;
        do {
          var e2 = t2.getNode().getEdges().getOutgoingDegree(this);
          e2 > this._maxNodeDegree && (this._maxNodeDegree = e2), t2 = this.getNext(t2);
        } while (t2 !== this._startDe);
        this._maxNodeDegree *= 2;
      }, De.prototype.addPoints = function(t2, e2, n2) {
        var i2 = t2.getCoordinates();
        if (e2) {
          var r2 = 1;
          n2 && (r2 = 0);
          for (var o2 = r2; o2 < i2.length; o2++)
            this._pts.add(i2[o2]);
        } else {
          var s2 = i2.length - 2;
          n2 && (s2 = i2.length - 1);
          for (var a2 = s2; a2 >= 0; a2--)
            this._pts.add(i2[a2]);
        }
      }, De.prototype.isHole = function() {
        return this._isHole;
      }, De.prototype.setInResult = function() {
        var t2 = this._startDe;
        do {
          t2.getEdge().setInResult(true), t2 = t2.getNext();
        } while (t2 !== this._startDe);
      }, De.prototype.containsPoint = function(t2) {
        var e2 = this.getLinearRing();
        if (!e2.getEnvelopeInternal().contains(t2))
          return false;
        if (!at.isPointInRing(t2, e2.getCoordinates()))
          return false;
        for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
          if (n2.next().containsPoint(t2))
            return false;
        }
        return true;
      }, De.prototype.addHole = function(t2) {
        this._holes.add(t2);
      }, De.prototype.isShell = function() {
        return null === this._shell;
      }, De.prototype.getLabel = function() {
        return this._label;
      }, De.prototype.getEdges = function() {
        return this._edges;
      }, De.prototype.getMaxNodeDegree = function() {
        return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
      }, De.prototype.getShell = function() {
        return this._shell;
      }, De.prototype.mergeLabel = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = e2.getLocation(n2, Se.RIGHT);
          if (i2 === w.NONE)
            return null;
          if (this._label.getLocation(n2) === w.NONE)
            return this._label.setLocation(n2, i2), null;
        }
      }, De.prototype.setShell = function(t2) {
        this._shell = t2, null !== t2 && t2.addHole(this);
      }, De.prototype.toPolygon = function(t2) {
        for (var e2 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++)
          e2[n2] = this._holes.get(n2).getLinearRing();
        return t2.createPolygon(this.getLinearRing(), e2);
      }, De.prototype.interfaces_ = function() {
        return [];
      }, De.prototype.getClass = function() {
        return De;
      };
      var Me = function(t2) {
        function e2() {
          var e3 = arguments[0], n2 = arguments[1];
          t2.call(this, e3, n2);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.setEdgeRing = function(t3, e3) {
          t3.setMinEdgeRing(e3);
        }, e2.prototype.getNext = function(t3) {
          return t3.getNextMin();
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(De), Ae = function(t2) {
        function e2() {
          var e3 = arguments[0], n2 = arguments[1];
          t2.call(this, e3, n2);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.buildMinimalRings = function() {
          var t3 = new Nt(), e3 = this._startDe;
          do {
            if (null === e3.getMinEdgeRing()) {
              var n2 = new Me(e3, this._geometryFactory);
              t3.add(n2);
            }
            e3 = e3.getNext();
          } while (e3 !== this._startDe);
          return t3;
        }, e2.prototype.setEdgeRing = function(t3, e3) {
          t3.setEdgeRing(e3);
        }, e2.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
          var t3 = this._startDe;
          do {
            t3.getNode().getEdges().linkMinimalDirectedEdges(this), t3 = t3.getNext();
          } while (t3 !== this._startDe);
        }, e2.prototype.getNext = function(t3) {
          return t3.getNext();
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(De), Fe = function() {
        if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this._label = t2;
        }
      };
      Fe.prototype.setVisited = function(t2) {
        this._isVisited = t2;
      }, Fe.prototype.setInResult = function(t2) {
        this._isInResult = t2;
      }, Fe.prototype.isCovered = function() {
        return this._isCovered;
      }, Fe.prototype.isCoveredSet = function() {
        return this._isCoveredSet;
      }, Fe.prototype.setLabel = function(t2) {
        this._label = t2;
      }, Fe.prototype.getLabel = function() {
        return this._label;
      }, Fe.prototype.setCovered = function(t2) {
        this._isCovered = t2, this._isCoveredSet = true;
      }, Fe.prototype.updateIM = function(t2) {
        et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
      }, Fe.prototype.isInResult = function() {
        return this._isInResult;
      }, Fe.prototype.isVisited = function() {
        return this._isVisited;
      }, Fe.prototype.interfaces_ = function() {
        return [];
      }, Fe.prototype.getClass = function() {
        return Fe;
      };
      var Ge = function(t2) {
        function e2() {
          t2.call(this), this._coord = null, this._edges = null;
          var e3 = arguments[0], n2 = arguments[1];
          this._coord = e3, this._edges = n2, this._label = new Pe(0, w.NONE);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.isIncidentEdgeInResult = function() {
          for (var t3 = this.getEdges().getEdges().iterator(); t3.hasNext(); ) {
            if (t3.next().getEdge().isInResult())
              return true;
          }
          return false;
        }, e2.prototype.isIsolated = function() {
          return 1 === this._label.getGeometryCount();
        }, e2.prototype.getCoordinate = function() {
          return this._coord;
        }, e2.prototype.print = function(t3) {
          t3.println("node " + this._coord + " lbl: " + this._label);
        }, e2.prototype.computeIM = function(t3) {
        }, e2.prototype.computeMergedLocation = function(t3, e3) {
          var n2 = w.NONE;
          if (n2 = this._label.getLocation(e3), !t3.isNull(e3)) {
            var i2 = t3.getLocation(e3);
            n2 !== w.BOUNDARY && (n2 = i2);
          }
          return n2;
        }, e2.prototype.setLabel = function() {
          if (2 !== arguments.length)
            return t2.prototype.setLabel.apply(this, arguments);
          var e3 = arguments[0], n2 = arguments[1];
          null === this._label ? this._label = new Pe(e3, n2) : this._label.setLocation(e3, n2);
        }, e2.prototype.getEdges = function() {
          return this._edges;
        }, e2.prototype.mergeLabel = function() {
          if (arguments[0] instanceof e2) {
            var t3 = arguments[0];
            this.mergeLabel(t3._label);
          } else if (arguments[0] instanceof Pe)
            for (var n2 = arguments[0], i2 = 0; i2 < 2; i2++) {
              var r2 = this.computeMergedLocation(n2, i2);
              this._label.getLocation(i2) === w.NONE && this._label.setLocation(i2, r2);
            }
        }, e2.prototype.add = function(t3) {
          this._edges.insert(t3), t3.setNode(this);
        }, e2.prototype.setLabelBoundary = function(t3) {
          if (null === this._label)
            return null;
          var e3 = w.NONE;
          null !== this._label && (e3 = this._label.getLocation(t3));
          var n2 = null;
          switch (e3) {
            case w.BOUNDARY:
              n2 = w.INTERIOR;
              break;
            case w.INTERIOR:
            default:
              n2 = w.BOUNDARY;
          }
          this._label.setLocation(t3, n2);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(Fe), qe = function() {
        this.nodeMap = new p(), this.nodeFact = null;
        var t2 = arguments[0];
        this.nodeFact = t2;
      };
      qe.prototype.find = function(t2) {
        return this.nodeMap.get(t2);
      }, qe.prototype.addNode = function() {
        if (arguments[0] instanceof C) {
          var t2 = arguments[0], e2 = this.nodeMap.get(t2);
          return null === e2 && (e2 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e2)), e2;
        }
        if (arguments[0] instanceof Ge) {
          var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
          return null === i2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
        }
      }, qe.prototype.print = function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          e2.next().print(t2);
        }
      }, qe.prototype.iterator = function() {
        return this.nodeMap.values().iterator();
      }, qe.prototype.values = function() {
        return this.nodeMap.values();
      }, qe.prototype.getBoundaryNodes = function(t2) {
        for (var e2 = new Nt(), n2 = this.iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          i2.getLabel().getLocation(t2) === w.BOUNDARY && e2.add(i2);
        }
        return e2;
      }, qe.prototype.add = function(t2) {
        var e2 = t2.getCoordinate();
        this.addNode(e2).add(t2);
      }, qe.prototype.interfaces_ = function() {
        return [];
      }, qe.prototype.getClass = function() {
        return qe;
      };
      var Be = function() {
      }, Ve = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
      Be.prototype.interfaces_ = function() {
        return [];
      }, Be.prototype.getClass = function() {
        return Be;
      }, Be.isNorthern = function(t2) {
        return t2 === Be.NE || t2 === Be.NW;
      }, Be.isOpposite = function(t2, e2) {
        if (t2 === e2)
          return false;
        return 2 === (t2 - e2 + 4) % 4;
      }, Be.commonHalfPlane = function(t2, e2) {
        if (t2 === e2)
          return t2;
        if (2 === (t2 - e2 + 4) % 4)
          return -1;
        var n2 = t2 < e2 ? t2 : e2;
        return 0 === n2 && 3 === (t2 > e2 ? t2 : e2) ? 3 : n2;
      }, Be.isInHalfPlane = function(t2, e2) {
        return e2 === Be.SE ? t2 === Be.SE || t2 === Be.SW : t2 === e2 || t2 === e2 + 1;
      }, Be.quadrant = function() {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1];
          if (0 === t2 && 0 === e2)
            throw new m("Cannot compute the quadrant for point ( " + t2 + ", " + e2 + " )");
          return t2 >= 0 ? e2 >= 0 ? Be.NE : Be.SE : e2 >= 0 ? Be.NW : Be.SW;
        }
        if (arguments[0] instanceof C && arguments[1] instanceof C) {
          var n2 = arguments[0], i2 = arguments[1];
          if (i2.x === n2.x && i2.y === n2.y)
            throw new m("Cannot compute the quadrant for two identical points " + n2);
          return i2.x >= n2.x ? i2.y >= n2.y ? Be.NE : Be.SE : i2.y >= n2.y ? Be.NW : Be.SW;
        }
      }, Ve.NE.get = function() {
        return 0;
      }, Ve.NW.get = function() {
        return 1;
      }, Ve.SW.get = function() {
        return 2;
      }, Ve.SE.get = function() {
        return 3;
      }, Object.defineProperties(Be, Ve);
      var Ue = function() {
        if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this._edge = t2;
        } else if (3 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._edge = e2, this.init(n2, i2), this._label = null;
        } else if (4 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
          this._edge = r2, this.init(o2, s2), this._label = a2;
        }
      };
      Ue.prototype.compareDirection = function(t2) {
        return this._dx === t2._dx && this._dy === t2._dy ? 0 : this._quadrant > t2._quadrant ? 1 : this._quadrant < t2._quadrant ? -1 : at.computeOrientation(t2._p0, t2._p1, this._p1);
      }, Ue.prototype.getDy = function() {
        return this._dy;
      }, Ue.prototype.getCoordinate = function() {
        return this._p0;
      }, Ue.prototype.setNode = function(t2) {
        this._node = t2;
      }, Ue.prototype.print = function(t2) {
        var e2 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
        t2.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e2 + "   " + this._label);
      }, Ue.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this.compareDirection(e2);
      }, Ue.prototype.getDirectedCoordinate = function() {
        return this._p1;
      }, Ue.prototype.getDx = function() {
        return this._dx;
      }, Ue.prototype.getLabel = function() {
        return this._label;
      }, Ue.prototype.getEdge = function() {
        return this._edge;
      }, Ue.prototype.getQuadrant = function() {
        return this._quadrant;
      }, Ue.prototype.getNode = function() {
        return this._node;
      }, Ue.prototype.toString = function() {
        var t2 = Math.atan2(this._dy, this._dx), e2 = this.getClass().getName(), n2 = e2.lastIndexOf(".");
        return "  " + e2.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t2 + "   " + this._label;
      }, Ue.prototype.computeLabel = function(t2) {
      }, Ue.prototype.init = function(t2, e2) {
        this._p0 = t2, this._p1 = e2, this._dx = e2.x - t2.x, this._dy = e2.y - t2.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
      }, Ue.prototype.interfaces_ = function() {
        return [E];
      }, Ue.prototype.getClass = function() {
        return Ue;
      };
      var ze = function(t2) {
        function e2() {
          var e3 = arguments[0], n2 = arguments[1];
          if (t2.call(this, e3), this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n2, n2)
            this.init(e3.getCoordinate(0), e3.getCoordinate(1));
          else {
            var i2 = e3.getNumPoints() - 1;
            this.init(e3.getCoordinate(i2), e3.getCoordinate(i2 - 1));
          }
          this.computeDirectedLabel();
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getNextMin = function() {
          return this._nextMin;
        }, e2.prototype.getDepth = function(t3) {
          return this._depth[t3];
        }, e2.prototype.setVisited = function(t3) {
          this._isVisited = t3;
        }, e2.prototype.computeDirectedLabel = function() {
          this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
        }, e2.prototype.getNext = function() {
          return this._next;
        }, e2.prototype.setDepth = function(t3, e3) {
          if (-999 !== this._depth[t3] && this._depth[t3] !== e3)
            throw new we("assigned depths do not match", this.getCoordinate());
          this._depth[t3] = e3;
        }, e2.prototype.isInteriorAreaEdge = function() {
          for (var t3 = true, e3 = 0; e3 < 2; e3++)
            this._label.isArea(e3) && this._label.getLocation(e3, Se.LEFT) === w.INTERIOR && this._label.getLocation(e3, Se.RIGHT) === w.INTERIOR || (t3 = false);
          return t3;
        }, e2.prototype.setNextMin = function(t3) {
          this._nextMin = t3;
        }, e2.prototype.print = function(e3) {
          t2.prototype.print.call(this, e3), e3.print(" " + this._depth[Se.LEFT] + "/" + this._depth[Se.RIGHT]), e3.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e3.print(" inResult");
        }, e2.prototype.setMinEdgeRing = function(t3) {
          this._minEdgeRing = t3;
        }, e2.prototype.isLineEdge = function() {
          var t3 = this._label.isLine(0) || this._label.isLine(1), e3 = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);
          return t3 && e3 && n2;
        }, e2.prototype.setEdgeRing = function(t3) {
          this._edgeRing = t3;
        }, e2.prototype.getMinEdgeRing = function() {
          return this._minEdgeRing;
        }, e2.prototype.getDepthDelta = function() {
          var t3 = this._edge.getDepthDelta();
          return this._isForward || (t3 = -t3), t3;
        }, e2.prototype.setInResult = function(t3) {
          this._isInResult = t3;
        }, e2.prototype.getSym = function() {
          return this._sym;
        }, e2.prototype.isForward = function() {
          return this._isForward;
        }, e2.prototype.getEdge = function() {
          return this._edge;
        }, e2.prototype.printEdge = function(t3) {
          this.print(t3), t3.print(" "), this._isForward ? this._edge.print(t3) : this._edge.printReverse(t3);
        }, e2.prototype.setSym = function(t3) {
          this._sym = t3;
        }, e2.prototype.setVisitedEdge = function(t3) {
          this.setVisited(t3), this._sym.setVisited(t3);
        }, e2.prototype.setEdgeDepths = function(t3, e3) {
          var n2 = this.getEdge().getDepthDelta();
          this._isForward || (n2 = -n2);
          var i2 = 1;
          t3 === Se.LEFT && (i2 = -1);
          var r2 = Se.opposite(t3), o2 = e3 + n2 * i2;
          this.setDepth(t3, e3), this.setDepth(r2, o2);
        }, e2.prototype.getEdgeRing = function() {
          return this._edgeRing;
        }, e2.prototype.isInResult = function() {
          return this._isInResult;
        }, e2.prototype.setNext = function(t3) {
          this._next = t3;
        }, e2.prototype.isVisited = function() {
          return this._isVisited;
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2.depthFactor = function(t3, e3) {
          return t3 === w.EXTERIOR && e3 === w.INTERIOR ? 1 : t3 === w.INTERIOR && e3 === w.EXTERIOR ? -1 : 0;
        }, e2;
      }(Ue), Xe = function() {
      };
      Xe.prototype.createNode = function(t2) {
        return new Ge(t2, null);
      }, Xe.prototype.interfaces_ = function() {
        return [];
      }, Xe.prototype.getClass = function() {
        return Xe;
      };
      var Ye = function() {
        if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), 0 === arguments.length)
          this._nodes = new qe(new Xe());
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this._nodes = new qe(t2);
        }
      };
      Ye.prototype.printEdges = function(t2) {
        t2.println("Edges:");
        for (var e2 = 0; e2 < this._edges.size(); e2++) {
          t2.println("edge " + e2 + ":");
          var n2 = this._edges.get(e2);
          n2.print(t2), n2.eiList.print(t2);
        }
      }, Ye.prototype.find = function(t2) {
        return this._nodes.find(t2);
      }, Ye.prototype.addNode = function() {
        if (arguments[0] instanceof Ge) {
          var t2 = arguments[0];
          return this._nodes.addNode(t2);
        }
        if (arguments[0] instanceof C) {
          var e2 = arguments[0];
          return this._nodes.addNode(e2);
        }
      }, Ye.prototype.getNodeIterator = function() {
        return this._nodes.iterator();
      }, Ye.prototype.linkResultDirectedEdges = function() {
        for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
          t2.next().getEdges().linkResultDirectedEdges();
        }
      }, Ye.prototype.debugPrintln = function(t2) {
        Y.out.println(t2);
      }, Ye.prototype.isBoundaryNode = function(t2, e2) {
        var n2 = this._nodes.find(e2);
        if (null === n2)
          return false;
        var i2 = n2.getLabel();
        return null !== i2 && i2.getLocation(t2) === w.BOUNDARY;
      }, Ye.prototype.linkAllDirectedEdges = function() {
        for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
          t2.next().getEdges().linkAllDirectedEdges();
        }
      }, Ye.prototype.matchInSameDirection = function(t2, e2, n2, i2) {
        return !!t2.equals(n2) && (at.computeOrientation(t2, e2, i2) === at.COLLINEAR && Be.quadrant(t2, e2) === Be.quadrant(n2, i2));
      }, Ye.prototype.getEdgeEnds = function() {
        return this._edgeEndList;
      }, Ye.prototype.debugPrint = function(t2) {
        Y.out.print(t2);
      }, Ye.prototype.getEdgeIterator = function() {
        return this._edges.iterator();
      }, Ye.prototype.findEdgeInSameDirection = function(t2, e2) {
        for (var n2 = 0; n2 < this._edges.size(); n2++) {
          var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
          if (this.matchInSameDirection(t2, e2, r2[0], r2[1]))
            return i2;
          if (this.matchInSameDirection(t2, e2, r2[r2.length - 1], r2[r2.length - 2]))
            return i2;
        }
        return null;
      }, Ye.prototype.insertEdge = function(t2) {
        this._edges.add(t2);
      }, Ye.prototype.findEdgeEnd = function(t2) {
        for (var e2 = this.getEdgeEnds().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (n2.getEdge() === t2)
            return n2;
        }
        return null;
      }, Ye.prototype.addEdges = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this._edges.add(n2);
          var i2 = new ze(n2, true), r2 = new ze(n2, false);
          i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
        }
      }, Ye.prototype.add = function(t2) {
        this._nodes.add(t2), this._edgeEndList.add(t2);
      }, Ye.prototype.getNodes = function() {
        return this._nodes.values();
      }, Ye.prototype.findEdge = function(t2, e2) {
        for (var n2 = 0; n2 < this._edges.size(); n2++) {
          var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
          if (t2.equals(r2[0]) && e2.equals(r2[1]))
            return i2;
        }
        return null;
      }, Ye.prototype.interfaces_ = function() {
        return [];
      }, Ye.prototype.getClass = function() {
        return Ye;
      }, Ye.linkResultDirectedEdges = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          e2.next().getEdges().linkResultDirectedEdges();
        }
      };
      var ke = function() {
        this._geometryFactory = null, this._shellList = new Nt();
        var t2 = arguments[0];
        this._geometryFactory = t2;
      };
      ke.prototype.sortShellsAndHoles = function(t2, e2, n2) {
        for (var i2 = t2.iterator(); i2.hasNext(); ) {
          var r2 = i2.next();
          r2.isHole() ? n2.add(r2) : e2.add(r2);
        }
      }, ke.prototype.computePolygons = function(t2) {
        for (var e2 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next().toPolygon(this._geometryFactory);
          e2.add(i2);
        }
        return e2;
      }, ke.prototype.placeFreeHoles = function(t2, e2) {
        for (var n2 = e2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          if (null === i2.getShell()) {
            var r2 = this.findEdgeRingContaining(i2, t2);
            if (null === r2)
              throw new we("unable to assign hole to a shell", i2.getCoordinate(0));
            i2.setShell(r2);
          }
        }
      }, ke.prototype.buildMinimalEdgeRings = function(t2, e2, n2) {
        for (var i2 = new Nt(), r2 = t2.iterator(); r2.hasNext(); ) {
          var o2 = r2.next();
          if (o2.getMaxNodeDegree() > 2) {
            o2.linkDirectedEdgesForMinimalEdgeRings();
            var s2 = o2.buildMinimalRings(), a2 = this.findShell(s2);
            null !== a2 ? (this.placePolygonHoles(a2, s2), e2.add(a2)) : n2.addAll(s2);
          } else
            i2.add(o2);
        }
        return i2;
      }, ke.prototype.containsPoint = function(t2) {
        for (var e2 = this._shellList.iterator(); e2.hasNext(); ) {
          if (e2.next().containsPoint(t2))
            return true;
        }
        return false;
      }, ke.prototype.buildMaximalEdgeRings = function(t2) {
        for (var e2 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          if (i2.isInResult() && i2.getLabel().isArea() && null === i2.getEdgeRing()) {
            var r2 = new Ae(i2, this._geometryFactory);
            e2.add(r2), r2.setInResult();
          }
        }
        return e2;
      }, ke.prototype.placePolygonHoles = function(t2, e2) {
        for (var n2 = e2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          i2.isHole() && i2.setShell(t2);
        }
      }, ke.prototype.getPolygons = function() {
        return this.computePolygons(this._shellList);
      }, ke.prototype.findEdgeRingContaining = function(t2, e2) {
        for (var n2 = t2.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), o2 = null, s2 = null, a2 = e2.iterator(); a2.hasNext(); ) {
          var u2 = a2.next(), l2 = u2.getLinearRing(), c2 = l2.getEnvelopeInternal();
          null !== o2 && (s2 = o2.getLinearRing().getEnvelopeInternal());
          var p2 = false;
          c2.contains(i2) && at.isPointInRing(r2, l2.getCoordinates()) && (p2 = true), p2 && (null === o2 || s2.contains(c2)) && (o2 = u2);
        }
        return o2;
      }, ke.prototype.findShell = function(t2) {
        for (var e2 = 0, n2 = null, i2 = t2.iterator(); i2.hasNext(); ) {
          var r2 = i2.next();
          r2.isHole() || (n2 = r2, e2++);
        }
        return et.isTrue(e2 <= 1, "found two shells in MinimalEdgeRing list"), n2;
      }, ke.prototype.add = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.add(t2.getEdgeEnds(), t2.getNodes());
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          Ye.linkResultDirectedEdges(n2);
          var i2 = this.buildMaximalEdgeRings(e2), r2 = new Nt(), o2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
          this.sortShellsAndHoles(o2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
        }
      }, ke.prototype.interfaces_ = function() {
        return [];
      }, ke.prototype.getClass = function() {
        return ke;
      };
      var je = function() {
      };
      je.prototype.getBounds = function() {
      }, je.prototype.interfaces_ = function() {
        return [];
      }, je.prototype.getClass = function() {
        return je;
      };
      var He = function() {
        this._bounds = null, this._item = null;
        var t2 = arguments[0], e2 = arguments[1];
        this._bounds = t2, this._item = e2;
      };
      He.prototype.getItem = function() {
        return this._item;
      }, He.prototype.getBounds = function() {
        return this._bounds;
      }, He.prototype.interfaces_ = function() {
        return [je, e];
      }, He.prototype.getClass = function() {
        return He;
      };
      var We = function() {
        this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);
      };
      We.prototype.poll = function() {
        if (this.isEmpty())
          return null;
        var t2 = this._items.get(1);
        return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
      }, We.prototype.size = function() {
        return this._size;
      }, We.prototype.reorder = function(t2) {
        for (var e2 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e2 = 2 * t2) !== this._size && this._items.get(e2 + 1).compareTo(this._items.get(e2)) < 0 && e2++, this._items.get(e2).compareTo(n2) < 0); t2 = e2)
          this._items.set(t2, this._items.get(e2));
        this._items.set(t2, n2);
      }, We.prototype.clear = function() {
        this._size = 0, this._items.clear();
      }, We.prototype.isEmpty = function() {
        return 0 === this._size;
      }, We.prototype.add = function(t2) {
        this._items.add(null), this._size += 1;
        var e2 = this._size;
        for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e2 / 2))) < 0; e2 /= 2)
          this._items.set(e2, this._items.get(Math.trunc(e2 / 2)));
        this._items.set(e2, t2);
      }, We.prototype.interfaces_ = function() {
        return [];
      }, We.prototype.getClass = function() {
        return We;
      };
      var Ke = function() {
      };
      Ke.prototype.visitItem = function(t2) {
      }, Ke.prototype.interfaces_ = function() {
        return [];
      }, Ke.prototype.getClass = function() {
        return Ke;
      };
      var Je = function() {
      };
      Je.prototype.insert = function(t2, e2) {
      }, Je.prototype.remove = function(t2, e2) {
      }, Je.prototype.query = function() {
      }, Je.prototype.interfaces_ = function() {
        return [];
      }, Je.prototype.getClass = function() {
        return Je;
      };
      var Qe = function() {
        if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this._level = t2;
        }
      }, Ze = { serialVersionUID: { configurable: true } };
      Qe.prototype.getLevel = function() {
        return this._level;
      }, Qe.prototype.size = function() {
        return this._childBoundables.size();
      }, Qe.prototype.getChildBoundables = function() {
        return this._childBoundables;
      }, Qe.prototype.addChildBoundable = function(t2) {
        et.isTrue(null === this._bounds), this._childBoundables.add(t2);
      }, Qe.prototype.isEmpty = function() {
        return this._childBoundables.isEmpty();
      }, Qe.prototype.getBounds = function() {
        return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
      }, Qe.prototype.interfaces_ = function() {
        return [je, e];
      }, Qe.prototype.getClass = function() {
        return Qe;
      }, Ze.serialVersionUID.get = function() {
        return 6493722185909574e3;
      }, Object.defineProperties(Qe, Ze);
      var $e = function() {
      };
      $e.reverseOrder = function() {
        return { compare: function(t2, e2) {
          return e2.compareTo(t2);
        } };
      }, $e.min = function(t2) {
        return $e.sort(t2), t2.get(0);
      }, $e.sort = function(t2, e2) {
        var n2 = t2.toArray();
        e2 ? Gt.sort(n2, e2) : Gt.sort(n2);
        for (var i2 = t2.iterator(), r2 = 0, o2 = n2.length; r2 < o2; r2++)
          i2.next(), i2.set(n2[r2]);
      }, $e.singletonList = function(t2) {
        var e2 = new Nt();
        return e2.add(t2), e2;
      };
      var tn = function() {
        this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this._boundable1 = t2, this._boundable2 = e2, this._itemDistance = n2, this._distance = this.distance();
      };
      tn.prototype.expandToQueue = function(t2, e2) {
        var n2 = tn.isComposite(this._boundable1), i2 = tn.isComposite(this._boundable2);
        if (n2 && i2)
          return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t2, e2), null) : (this.expand(this._boundable2, this._boundable1, t2, e2), null);
        if (n2)
          return this.expand(this._boundable1, this._boundable2, t2, e2), null;
        if (i2)
          return this.expand(this._boundable2, this._boundable1, t2, e2), null;
        throw new m("neither boundable is composite");
      }, tn.prototype.isLeaves = function() {
        return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));
      }, tn.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this._distance < e2._distance ? -1 : this._distance > e2._distance ? 1 : 0;
      }, tn.prototype.expand = function(t2, e2, n2, i2) {
        for (var r2 = t2.getChildBoundables().iterator(); r2.hasNext(); ) {
          var o2 = r2.next(), s2 = new tn(o2, e2, this._itemDistance);
          s2.getDistance() < i2 && n2.add(s2);
        }
      }, tn.prototype.getBoundable = function(t2) {
        return 0 === t2 ? this._boundable1 : this._boundable2;
      }, tn.prototype.getDistance = function() {
        return this._distance;
      }, tn.prototype.distance = function() {
        return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
      }, tn.prototype.interfaces_ = function() {
        return [E];
      }, tn.prototype.getClass = function() {
        return tn;
      }, tn.area = function(t2) {
        return t2.getBounds().getArea();
      }, tn.isComposite = function(t2) {
        return t2 instanceof Qe;
      };
      var en = function t2() {
        if (this._root = null, this._built = false, this._itemBoundables = new Nt(), this._nodeCapacity = null, 0 === arguments.length) {
          var e2 = t2.DEFAULT_NODE_CAPACITY;
          this._nodeCapacity = e2;
        } else if (1 === arguments.length) {
          var n2 = arguments[0];
          et.isTrue(n2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n2;
        }
      }, nn = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
      en.prototype.getNodeCapacity = function() {
        return this._nodeCapacity;
      }, en.prototype.lastNode = function(t2) {
        return t2.get(t2.size() - 1);
      }, en.prototype.size = function() {
        if (0 === arguments.length)
          return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
        if (1 === arguments.length) {
          for (var t2 = 0, e2 = arguments[0].getChildBoundables().iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            n2 instanceof Qe ? t2 += this.size(n2) : n2 instanceof He && (t2 += 1);
          }
          return t2;
        }
      }, en.prototype.removeItem = function(t2, e2) {
        for (var n2 = null, i2 = t2.getChildBoundables().iterator(); i2.hasNext(); ) {
          var r2 = i2.next();
          r2 instanceof He && r2.getItem() === e2 && (n2 = r2);
        }
        return null !== n2 && (t2.getChildBoundables().remove(n2), true);
      }, en.prototype.itemsTree = function() {
        if (0 === arguments.length) {
          this.build();
          var t2 = this.itemsTree(this._root);
          return null === t2 ? new Nt() : t2;
        }
        if (1 === arguments.length) {
          for (var e2 = arguments[0], n2 = new Nt(), i2 = e2.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            if (r2 instanceof Qe) {
              var o2 = this.itemsTree(r2);
              null !== o2 && n2.add(o2);
            } else
              r2 instanceof He ? n2.add(r2.getItem()) : et.shouldNeverReachHere();
          }
          return n2.size() <= 0 ? null : n2;
        }
      }, en.prototype.insert = function(t2, e2) {
        et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new He(t2, e2));
      }, en.prototype.boundablesAtLevel = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new Nt();
          return this.boundablesAtLevel(t2, this._root, e2), e2;
        }
        if (3 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
          if (et.isTrue(n2 > -2), i2.getLevel() === n2)
            return r2.add(i2), null;
          for (var o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
            var s2 = o2.next();
            s2 instanceof Qe ? this.boundablesAtLevel(n2, s2, r2) : (et.isTrue(s2 instanceof He), -1 === n2 && r2.add(s2));
          }
          return null;
        }
      }, en.prototype.query = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.build();
          var e2 = new Nt();
          return this.isEmpty() ? e2 : (this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.query(t2, this._root, e2), e2);
        }
        if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          if (this.build(), this.isEmpty())
            return null;
          this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.query(n2, this._root, i2);
        } else if (3 === arguments.length) {
          if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
            for (var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = o2.getChildBoundables(), u2 = 0; u2 < a2.size(); u2++) {
              var l2 = a2.get(u2);
              this.getIntersectsOp().intersects(l2.getBounds(), r2) && (l2 instanceof Qe ? this.query(r2, l2, s2) : l2 instanceof He ? s2.visitItem(l2.getItem()) : et.shouldNeverReachHere());
            }
          else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
            for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = p2.getChildBoundables(), g2 = 0; g2 < f2.size(); g2++) {
              var d2 = f2.get(g2);
              this.getIntersectsOp().intersects(d2.getBounds(), c2) && (d2 instanceof Qe ? this.query(c2, d2, h2) : d2 instanceof He ? h2.add(d2.getItem()) : et.shouldNeverReachHere());
            }
        }
      }, en.prototype.build = function() {
        if (this._built)
          return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
      }, en.prototype.getRoot = function() {
        return this.build(), this._root;
      }, en.prototype.remove = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.remove(t2, this._root, e2);
        }
        if (3 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = this.removeItem(i2, r2);
          if (o2)
            return true;
          for (var s2 = null, a2 = i2.getChildBoundables().iterator(); a2.hasNext(); ) {
            var u2 = a2.next();
            if (this.getIntersectsOp().intersects(u2.getBounds(), n2) && (u2 instanceof Qe && (o2 = this.remove(n2, u2, r2)))) {
              s2 = u2;
              break;
            }
          }
          return null !== s2 && s2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(s2), o2;
        }
      }, en.prototype.createHigherLevels = function(t2, e2) {
        et.isTrue(!t2.isEmpty());
        var n2 = this.createParentBoundables(t2, e2 + 1);
        return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e2 + 1);
      }, en.prototype.depth = function() {
        if (0 === arguments.length)
          return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
        if (1 === arguments.length) {
          for (var t2 = 0, e2 = arguments[0].getChildBoundables().iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            if (n2 instanceof Qe) {
              var i2 = this.depth(n2);
              i2 > t2 && (t2 = i2);
            }
          }
          return t2 + 1;
        }
      }, en.prototype.createParentBoundables = function(t2, e2) {
        et.isTrue(!t2.isEmpty());
        var n2 = new Nt();
        n2.add(this.createNode(e2));
        var i2 = new Nt(t2);
        $e.sort(i2, this.getComparator());
        for (var r2 = i2.iterator(); r2.hasNext(); ) {
          var o2 = r2.next();
          this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e2)), this.lastNode(n2).addChildBoundable(o2);
        }
        return n2;
      }, en.prototype.isEmpty = function() {
        return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
      }, en.prototype.interfaces_ = function() {
        return [e];
      }, en.prototype.getClass = function() {
        return en;
      }, en.compareDoubles = function(t2, e2) {
        return t2 > e2 ? 1 : t2 < e2 ? -1 : 0;
      }, nn.IntersectsOp.get = function() {
        return rn;
      }, nn.serialVersionUID.get = function() {
        return -3886435814360241e3;
      }, nn.DEFAULT_NODE_CAPACITY.get = function() {
        return 10;
      }, Object.defineProperties(en, nn);
      var rn = function() {
      }, on = function() {
      };
      on.prototype.distance = function(t2, e2) {
      }, on.prototype.interfaces_ = function() {
        return [];
      }, on.prototype.getClass = function() {
        return on;
      };
      var sn = function(t2) {
        function n2(e2) {
          e2 = e2 || n2.DEFAULT_NODE_CAPACITY, t2.call(this, e2);
        }
        t2 && (n2.__proto__ = t2), (n2.prototype = Object.create(t2 && t2.prototype)).constructor = n2;
        var i2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
        return n2.prototype.createParentBoundablesFromVerticalSlices = function(t3, e2) {
          et.isTrue(t3.length > 0);
          for (var n3 = new Nt(), i3 = 0; i3 < t3.length; i3++)
            n3.addAll(this.createParentBoundablesFromVerticalSlice(t3[i3], e2));
          return n3;
        }, n2.prototype.createNode = function(t3) {
          return new an(t3);
        }, n2.prototype.size = function() {
          return 0 === arguments.length ? t2.prototype.size.call(this) : t2.prototype.size.apply(this, arguments);
        }, n2.prototype.insert = function() {
          if (2 !== arguments.length)
            return t2.prototype.insert.apply(this, arguments);
          var e2 = arguments[0], n3 = arguments[1];
          if (e2.isNull())
            return null;
          t2.prototype.insert.call(this, e2, n3);
        }, n2.prototype.getIntersectsOp = function() {
          return n2.intersectsOp;
        }, n2.prototype.verticalSlices = function(t3, e2) {
          for (var n3 = Math.trunc(Math.ceil(t3.size() / e2)), i3 = new Array(e2).fill(null), r2 = t3.iterator(), o2 = 0; o2 < e2; o2++) {
            i3[o2] = new Nt();
            for (var s2 = 0; r2.hasNext() && s2 < n3; ) {
              var a2 = r2.next();
              i3[o2].add(a2), s2++;
            }
          }
          return i3;
        }, n2.prototype.query = function() {
          if (1 === arguments.length) {
            var e2 = arguments[0];
            return t2.prototype.query.call(this, e2);
          }
          if (2 === arguments.length) {
            var n3 = arguments[0], i3 = arguments[1];
            t2.prototype.query.call(this, n3, i3);
          } else if (3 === arguments.length) {
            if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
              var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
              t2.prototype.query.call(this, r2, o2, s2);
            } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
              var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
              t2.prototype.query.call(this, a2, u2, l2);
            }
          }
        }, n2.prototype.getComparator = function() {
          return n2.yComparator;
        }, n2.prototype.createParentBoundablesFromVerticalSlice = function(e2, n3) {
          return t2.prototype.createParentBoundables.call(this, e2, n3);
        }, n2.prototype.remove = function() {
          if (2 === arguments.length) {
            var e2 = arguments[0], n3 = arguments[1];
            return t2.prototype.remove.call(this, e2, n3);
          }
          return t2.prototype.remove.apply(this, arguments);
        }, n2.prototype.depth = function() {
          return 0 === arguments.length ? t2.prototype.depth.call(this) : t2.prototype.depth.apply(this, arguments);
        }, n2.prototype.createParentBoundables = function(t3, e2) {
          et.isTrue(!t3.isEmpty());
          var i3 = Math.trunc(Math.ceil(t3.size() / this.getNodeCapacity())), r2 = new Nt(t3);
          $e.sort(r2, n2.xComparator);
          var o2 = this.verticalSlices(r2, Math.trunc(Math.ceil(Math.sqrt(i3))));
          return this.createParentBoundablesFromVerticalSlices(o2, e2);
        }, n2.prototype.nearestNeighbour = function() {
          if (1 === arguments.length) {
            if (T(arguments[0], on)) {
              var t3 = arguments[0], e2 = new tn(this.getRoot(), this.getRoot(), t3);
              return this.nearestNeighbour(e2);
            }
            if (arguments[0] instanceof tn) {
              var i3 = arguments[0];
              return this.nearestNeighbour(i3, v.POSITIVE_INFINITY);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof n2 && T(arguments[1], on)) {
              var r2 = arguments[0], o2 = arguments[1], s2 = new tn(this.getRoot(), r2.getRoot(), o2);
              return this.nearestNeighbour(s2);
            }
            if (arguments[0] instanceof tn && "number" == typeof arguments[1]) {
              var a2 = arguments[0], u2 = arguments[1], l2 = null, c2 = new We();
              for (c2.add(a2); !c2.isEmpty() && u2 > 0; ) {
                var p2 = c2.poll(), h2 = p2.getDistance();
                if (h2 >= u2)
                  break;
                p2.isLeaves() ? (u2 = h2, l2 = p2) : p2.expandToQueue(c2, u2);
              }
              return [l2.getBoundable(0).getItem(), l2.getBoundable(1).getItem()];
            }
          } else if (3 === arguments.length) {
            var f2 = arguments[0], g2 = arguments[1], d2 = arguments[2], y2 = new He(f2, g2), _2 = new tn(this.getRoot(), y2, d2);
            return this.nearestNeighbour(_2)[0];
          }
        }, n2.prototype.interfaces_ = function() {
          return [Je, e];
        }, n2.prototype.getClass = function() {
          return n2;
        }, n2.centreX = function(t3) {
          return n2.avg(t3.getMinX(), t3.getMaxX());
        }, n2.avg = function(t3, e2) {
          return (t3 + e2) / 2;
        }, n2.centreY = function(t3) {
          return n2.avg(t3.getMinY(), t3.getMaxY());
        }, i2.STRtreeNode.get = function() {
          return an;
        }, i2.serialVersionUID.get = function() {
          return 259274702368956900;
        }, i2.xComparator.get = function() {
          return { interfaces_: function() {
            return [N];
          }, compare: function(e2, i3) {
            return t2.compareDoubles(n2.centreX(e2.getBounds()), n2.centreX(i3.getBounds()));
          } };
        }, i2.yComparator.get = function() {
          return { interfaces_: function() {
            return [N];
          }, compare: function(e2, i3) {
            return t2.compareDoubles(n2.centreY(e2.getBounds()), n2.centreY(i3.getBounds()));
          } };
        }, i2.intersectsOp.get = function() {
          return { interfaces_: function() {
            return [t2.IntersectsOp];
          }, intersects: function(t3, e2) {
            return t3.intersects(e2);
          } };
        }, i2.DEFAULT_NODE_CAPACITY.get = function() {
          return 10;
        }, Object.defineProperties(n2, i2), n2;
      }(en), an = function(t2) {
        function e2() {
          var e3 = arguments[0];
          t2.call(this, e3);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.computeBounds = function() {
          for (var t3 = null, e3 = this.getChildBoundables().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            null === t3 ? t3 = new j(n2.getBounds()) : t3.expandToInclude(n2.getBounds());
          }
          return t3;
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(Qe), un = function() {
      };
      un.prototype.interfaces_ = function() {
        return [];
      }, un.prototype.getClass = function() {
        return un;
      }, un.relativeSign = function(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }, un.compare = function(t2, e2, n2) {
        if (e2.equals2D(n2))
          return 0;
        var i2 = un.relativeSign(e2.x, n2.x), r2 = un.relativeSign(e2.y, n2.y);
        switch (t2) {
          case 0:
            return un.compareValue(i2, r2);
          case 1:
            return un.compareValue(r2, i2);
          case 2:
            return un.compareValue(r2, -i2);
          case 3:
            return un.compareValue(-i2, r2);
          case 4:
            return un.compareValue(-i2, -r2);
          case 5:
            return un.compareValue(-r2, -i2);
          case 6:
            return un.compareValue(-r2, i2);
          case 7:
            return un.compareValue(i2, -r2);
        }
        return et.shouldNeverReachHere("invalid octant value"), 0;
      }, un.compareValue = function(t2, e2) {
        return t2 < 0 ? -1 : t2 > 0 ? 1 : e2 < 0 ? -1 : e2 > 0 ? 1 : 0;
      };
      var ln = function() {
        this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = arguments[3];
        this._segString = t2, this.coord = new C(e2), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e2.equals2D(t2.getCoordinate(n2));
      };
      ln.prototype.getCoordinate = function() {
        return this.coord;
      }, ln.prototype.print = function(t2) {
        t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
      }, ln.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this.segmentIndex < e2.segmentIndex ? -1 : this.segmentIndex > e2.segmentIndex ? 1 : this.coord.equals2D(e2.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e2.coord);
      }, ln.prototype.isEndPoint = function(t2) {
        return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t2;
      }, ln.prototype.isInterior = function() {
        return this._isInterior;
      }, ln.prototype.interfaces_ = function() {
        return [E];
      }, ln.prototype.getClass = function() {
        return ln;
      };
      var cn = function() {
        this._nodeMap = new p(), this._edge = null;
        var t2 = arguments[0];
        this._edge = t2;
      };
      cn.prototype.getSplitCoordinates = function() {
        var t2 = new St();
        this.addEndpoints();
        for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
          var i2 = e2.next();
          this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
        }
        return t2.toCoordinateArray();
      }, cn.prototype.addCollapsedNodes = function() {
        var t2 = new Nt();
        this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next().intValue();
          this.add(this._edge.getCoordinate(n2), n2);
        }
      }, cn.prototype.print = function(t2) {
        t2.println("Intersections:");
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          e2.next().print(t2);
        }
      }, cn.prototype.findCollapsesFromExistingVertices = function(t2) {
        for (var e2 = 0; e2 < this._edge.size() - 2; e2++) {
          var n2 = this._edge.getCoordinate(e2), i2 = this._edge.getCoordinate(e2 + 2);
          n2.equals2D(i2) && t2.add(new M(e2 + 1));
        }
      }, cn.prototype.addEdgeCoordinates = function(t2, e2, n2) {
        var i2 = this._edge.getCoordinate(e2.segmentIndex), r2 = e2.isInterior() || !e2.coord.equals2D(i2);
        n2.add(new C(t2.coord), false);
        for (var o2 = t2.segmentIndex + 1; o2 <= e2.segmentIndex; o2++)
          n2.add(this._edge.getCoordinate(o2));
        r2 && n2.add(new C(e2.coord));
      }, cn.prototype.iterator = function() {
        return this._nodeMap.values().iterator();
      }, cn.prototype.addSplitEdges = function(t2) {
        this.addEndpoints(), this.addCollapsedNodes();
        for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
          var i2 = e2.next(), r2 = this.createSplitEdge(n2, i2);
          t2.add(r2), n2 = i2;
        }
      }, cn.prototype.findCollapseIndex = function(t2, e2, n2) {
        if (!t2.coord.equals2D(e2.coord))
          return false;
        var i2 = e2.segmentIndex - t2.segmentIndex;
        return e2.isInterior() || i2--, 1 === i2 && (n2[0] = t2.segmentIndex + 1, true);
      }, cn.prototype.findCollapsesFromInsertedNodes = function(t2) {
        for (var e2 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
          var r2 = n2.next();
          this.findCollapseIndex(i2, r2, e2) && t2.add(new M(e2[0])), i2 = r2;
        }
      }, cn.prototype.getEdge = function() {
        return this._edge;
      }, cn.prototype.addEndpoints = function() {
        var t2 = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
      }, cn.prototype.createSplitEdge = function(t2, e2) {
        var n2 = e2.segmentIndex - t2.segmentIndex + 2, i2 = this._edge.getCoordinate(e2.segmentIndex), r2 = e2.isInterior() || !e2.coord.equals2D(i2);
        r2 || n2--;
        var o2 = new Array(n2).fill(null), s2 = 0;
        o2[s2++] = new C(t2.coord);
        for (var a2 = t2.segmentIndex + 1; a2 <= e2.segmentIndex; a2++)
          o2[s2++] = this._edge.getCoordinate(a2);
        return r2 && (o2[s2] = new C(e2.coord)), new gn(o2, this._edge.getData());
      }, cn.prototype.add = function(t2, e2) {
        var n2 = new ln(this._edge, t2, e2, this._edge.getSegmentOctant(e2)), i2 = this._nodeMap.get(n2);
        return null !== i2 ? (et.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
      }, cn.prototype.checkSplitEdgesCorrectness = function(t2) {
        var e2 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
        if (!n2.equals2D(e2[0]))
          throw new $("bad split edge start point at " + n2);
        var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
        if (!r2.equals2D(e2[e2.length - 1]))
          throw new $("bad split edge end point at " + r2);
      }, cn.prototype.interfaces_ = function() {
        return [];
      }, cn.prototype.getClass = function() {
        return cn;
      };
      var pn = function() {
      };
      pn.prototype.interfaces_ = function() {
        return [];
      }, pn.prototype.getClass = function() {
        return pn;
      }, pn.octant = function() {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var t2 = arguments[0], e2 = arguments[1];
          if (0 === t2 && 0 === e2)
            throw new m("Cannot compute the octant for point ( " + t2 + ", " + e2 + " )");
          var n2 = Math.abs(t2), i2 = Math.abs(e2);
          return t2 >= 0 ? e2 >= 0 ? n2 >= i2 ? 0 : 1 : n2 >= i2 ? 7 : 6 : e2 >= 0 ? n2 >= i2 ? 3 : 2 : n2 >= i2 ? 4 : 5;
        }
        if (arguments[0] instanceof C && arguments[1] instanceof C) {
          var r2 = arguments[0], o2 = arguments[1], s2 = o2.x - r2.x, a2 = o2.y - r2.y;
          if (0 === s2 && 0 === a2)
            throw new m("Cannot compute the octant for two identical points " + r2);
          return pn.octant(s2, a2);
        }
      };
      var hn = function() {
      };
      hn.prototype.getCoordinates = function() {
      }, hn.prototype.size = function() {
      }, hn.prototype.getCoordinate = function(t2) {
      }, hn.prototype.isClosed = function() {
      }, hn.prototype.setData = function(t2) {
      }, hn.prototype.getData = function() {
      }, hn.prototype.interfaces_ = function() {
        return [];
      }, hn.prototype.getClass = function() {
        return hn;
      };
      var fn = function() {
      };
      fn.prototype.addIntersection = function(t2, e2) {
      }, fn.prototype.interfaces_ = function() {
        return [hn];
      }, fn.prototype.getClass = function() {
        return fn;
      };
      var gn = function() {
        this._nodeList = new cn(this), this._pts = null, this._data = null;
        var t2 = arguments[0], e2 = arguments[1];
        this._pts = t2, this._data = e2;
      };
      gn.prototype.getCoordinates = function() {
        return this._pts;
      }, gn.prototype.size = function() {
        return this._pts.length;
      }, gn.prototype.getCoordinate = function(t2) {
        return this._pts[t2];
      }, gn.prototype.isClosed = function() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
      }, gn.prototype.getSegmentOctant = function(t2) {
        return t2 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
      }, gn.prototype.setData = function(t2) {
        this._data = t2;
      }, gn.prototype.safeOctant = function(t2, e2) {
        return t2.equals2D(e2) ? 0 : pn.octant(t2, e2);
      }, gn.prototype.getData = function() {
        return this._data;
      }, gn.prototype.addIntersection = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this.addIntersectionNode(t2, e2);
        } else if (4 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[3], o2 = new C(n2.getIntersection(r2));
          this.addIntersection(o2, i2);
        }
      }, gn.prototype.toString = function() {
        return Z.toLineString(new ue(this._pts));
      }, gn.prototype.getNodeList = function() {
        return this._nodeList;
      }, gn.prototype.addIntersectionNode = function(t2, e2) {
        var n2 = e2, i2 = n2 + 1;
        if (i2 < this._pts.length) {
          var r2 = this._pts[i2];
          t2.equals2D(r2) && (n2 = i2);
        }
        return this._nodeList.add(t2, n2);
      }, gn.prototype.addIntersections = function(t2, e2, n2) {
        for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++)
          this.addIntersection(t2, e2, n2, i2);
      }, gn.prototype.interfaces_ = function() {
        return [fn];
      }, gn.prototype.getClass = function() {
        return gn;
      }, gn.getNodedSubstrings = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = new Nt();
          return gn.getNodedSubstrings(t2, e2), e2;
        }
        if (2 === arguments.length)
          for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
            r2.next().getNodeList().addSplitEdges(i2);
          }
      };
      var dn = function() {
        if (this.p0 = null, this.p1 = null, 0 === arguments.length)
          this.p0 = new C(), this.p1 = new C();
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.p0 = new C(t2.p0), this.p1 = new C(t2.p1);
        } else if (2 === arguments.length)
          this.p0 = arguments[0], this.p1 = arguments[1];
        else if (4 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
          this.p0 = new C(e2, n2), this.p1 = new C(i2, r2);
        }
      }, yn = { serialVersionUID: { configurable: true } };
      dn.prototype.minX = function() {
        return Math.min(this.p0.x, this.p1.x);
      }, dn.prototype.orientationIndex = function() {
        if (arguments[0] instanceof dn) {
          var t2 = arguments[0], e2 = at.orientationIndex(this.p0, this.p1, t2.p0), n2 = at.orientationIndex(this.p0, this.p1, t2.p1);
          return e2 >= 0 && n2 >= 0 ? Math.max(e2, n2) : e2 <= 0 && n2 <= 0 ? Math.max(e2, n2) : 0;
        }
        if (arguments[0] instanceof C) {
          var i2 = arguments[0];
          return at.orientationIndex(this.p0, this.p1, i2);
        }
      }, dn.prototype.toGeometry = function(t2) {
        return t2.createLineString([this.p0, this.p1]);
      }, dn.prototype.isVertical = function() {
        return this.p0.x === this.p1.x;
      }, dn.prototype.equals = function(t2) {
        if (!(t2 instanceof dn))
          return false;
        var e2 = t2;
        return this.p0.equals(e2.p0) && this.p1.equals(e2.p1);
      }, dn.prototype.intersection = function(t2) {
        var e2 = new rt();
        return e2.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e2.hasIntersection() ? e2.getIntersection(0) : null;
      }, dn.prototype.project = function() {
        if (arguments[0] instanceof C) {
          var t2 = arguments[0];
          if (t2.equals(this.p0) || t2.equals(this.p1))
            return new C(t2);
          var e2 = this.projectionFactor(t2), n2 = new C();
          return n2.x = this.p0.x + e2 * (this.p1.x - this.p0.x), n2.y = this.p0.y + e2 * (this.p1.y - this.p0.y), n2;
        }
        if (arguments[0] instanceof dn) {
          var i2 = arguments[0], r2 = this.projectionFactor(i2.p0), o2 = this.projectionFactor(i2.p1);
          if (r2 >= 1 && o2 >= 1)
            return null;
          if (r2 <= 0 && o2 <= 0)
            return null;
          var s2 = this.project(i2.p0);
          r2 < 0 && (s2 = this.p0), r2 > 1 && (s2 = this.p1);
          var a2 = this.project(i2.p1);
          return o2 < 0 && (a2 = this.p0), o2 > 1 && (a2 = this.p1), new dn(s2, a2);
        }
      }, dn.prototype.normalize = function() {
        this.p1.compareTo(this.p0) < 0 && this.reverse();
      }, dn.prototype.angle = function() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
      }, dn.prototype.getCoordinate = function(t2) {
        return 0 === t2 ? this.p0 : this.p1;
      }, dn.prototype.distancePerpendicular = function(t2) {
        return at.distancePointLinePerpendicular(t2, this.p0, this.p1);
      }, dn.prototype.minY = function() {
        return Math.min(this.p0.y, this.p1.y);
      }, dn.prototype.midPoint = function() {
        return dn.midPoint(this.p0, this.p1);
      }, dn.prototype.projectionFactor = function(t2) {
        if (t2.equals(this.p0))
          return 0;
        if (t2.equals(this.p1))
          return 1;
        var e2 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e2 * e2 + n2 * n2;
        if (i2 <= 0)
          return v.NaN;
        return ((t2.x - this.p0.x) * e2 + (t2.y - this.p0.y) * n2) / i2;
      }, dn.prototype.closestPoints = function(t2) {
        var e2 = this.intersection(t2);
        if (null !== e2)
          return [e2, e2];
        var n2 = new Array(2).fill(null), i2 = v.MAX_VALUE, r2 = null, o2 = this.closestPoint(t2.p0);
        i2 = o2.distance(t2.p0), n2[0] = o2, n2[1] = t2.p0;
        var s2 = this.closestPoint(t2.p1);
        (r2 = s2.distance(t2.p1)) < i2 && (i2 = r2, n2[0] = s2, n2[1] = t2.p1);
        var a2 = t2.closestPoint(this.p0);
        (r2 = a2.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = a2);
        var u2 = t2.closestPoint(this.p1);
        return (r2 = u2.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u2), n2;
      }, dn.prototype.closestPoint = function(t2) {
        var e2 = this.projectionFactor(t2);
        if (e2 > 0 && e2 < 1)
          return this.project(t2);
        return this.p0.distance(t2) < this.p1.distance(t2) ? this.p0 : this.p1;
      }, dn.prototype.maxX = function() {
        return Math.max(this.p0.x, this.p1.x);
      }, dn.prototype.getLength = function() {
        return this.p0.distance(this.p1);
      }, dn.prototype.compareTo = function(t2) {
        var e2 = t2, n2 = this.p0.compareTo(e2.p0);
        return 0 !== n2 ? n2 : this.p1.compareTo(e2.p1);
      }, dn.prototype.reverse = function() {
        var t2 = this.p0;
        this.p0 = this.p1, this.p1 = t2;
      }, dn.prototype.equalsTopo = function(t2) {
        return this.p0.equals(t2.p0) && (this.p1.equals(t2.p1) || this.p0.equals(t2.p1)) && this.p1.equals(t2.p0);
      }, dn.prototype.lineIntersection = function(t2) {
        try {
          return k.intersection(this.p0, this.p1, t2.p0, t2.p1);
        } catch (t3) {
          if (!(t3 instanceof X))
            throw t3;
        }
        return null;
      }, dn.prototype.maxY = function() {
        return Math.max(this.p0.y, this.p1.y);
      }, dn.prototype.pointAlongOffset = function(t2, e2) {
        var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i2 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, o2 = this.p1.y - this.p0.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = 0, u2 = 0;
        if (0 !== e2) {
          if (s2 <= 0)
            throw new Error("Cannot compute offset from zero-length line segment");
          a2 = e2 * r2 / s2, u2 = e2 * o2 / s2;
        }
        return new C(n2 - u2, i2 + a2);
      }, dn.prototype.setCoordinates = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setCoordinates(t2.p0, t2.p1);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this.p0.x = e2.x, this.p0.y = e2.y, this.p1.x = n2.x, this.p1.y = n2.y;
        }
      }, dn.prototype.segmentFraction = function(t2) {
        var e2 = this.projectionFactor(t2);
        return e2 < 0 ? e2 = 0 : (e2 > 1 || v.isNaN(e2)) && (e2 = 1), e2;
      }, dn.prototype.toString = function() {
        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
      }, dn.prototype.isHorizontal = function() {
        return this.p0.y === this.p1.y;
      }, dn.prototype.distance = function() {
        if (arguments[0] instanceof dn) {
          var t2 = arguments[0];
          return at.distanceLineLine(this.p0, this.p1, t2.p0, t2.p1);
        }
        if (arguments[0] instanceof C) {
          var e2 = arguments[0];
          return at.distancePointLine(e2, this.p0, this.p1);
        }
      }, dn.prototype.pointAlong = function(t2) {
        var e2 = new C();
        return e2.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e2.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e2;
      }, dn.prototype.hashCode = function() {
        var t2 = v.doubleToLongBits(this.p0.x);
        t2 ^= 31 * v.doubleToLongBits(this.p0.y);
        var e2 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = v.doubleToLongBits(this.p1.x);
        n2 ^= 31 * v.doubleToLongBits(this.p1.y);
        return e2 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
      }, dn.prototype.interfaces_ = function() {
        return [E, e];
      }, dn.prototype.getClass = function() {
        return dn;
      }, dn.midPoint = function(t2, e2) {
        return new C((t2.x + e2.x) / 2, (t2.y + e2.y) / 2);
      }, yn.serialVersionUID.get = function() {
        return 3252005833466256400;
      }, Object.defineProperties(dn, yn);
      var _n = function() {
        this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();
      };
      _n.prototype.overlap = function() {
        if (2 === arguments.length)
          ;
        else if (4 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          t2.getLineSegment(e2, this._overlapSeg1), n2.getLineSegment(i2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
        }
      }, _n.prototype.interfaces_ = function() {
        return [];
      }, _n.prototype.getClass = function() {
        return _n;
      };
      var mn = function() {
        this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = arguments[3];
        this._pts = t2, this._start = e2, this._end = n2, this._context = i2;
      };
      mn.prototype.getLineSegment = function(t2, e2) {
        e2.p0 = this._pts[t2], e2.p1 = this._pts[t2 + 1];
      }, mn.prototype.computeSelect = function(t2, e2, n2, i2) {
        var r2 = this._pts[e2], o2 = this._pts[n2];
        if (i2.tempEnv1.init(r2, o2), n2 - e2 == 1)
          return i2.select(this, e2), null;
        if (!t2.intersects(i2.tempEnv1))
          return null;
        var s2 = Math.trunc((e2 + n2) / 2);
        e2 < s2 && this.computeSelect(t2, e2, s2, i2), s2 < n2 && this.computeSelect(t2, s2, n2, i2);
      }, mn.prototype.getCoordinates = function() {
        for (var t2 = new Array(this._end - this._start + 1).fill(null), e2 = 0, n2 = this._start; n2 <= this._end; n2++)
          t2[e2++] = this._pts[n2];
        return t2;
      }, mn.prototype.computeOverlaps = function(t2, e2) {
        this.computeOverlapsInternal(this._start, this._end, t2, t2._start, t2._end, e2);
      }, mn.prototype.setId = function(t2) {
        this._id = t2;
      }, mn.prototype.select = function(t2, e2) {
        this.computeSelect(t2, this._start, this._end, e2);
      }, mn.prototype.getEnvelope = function() {
        if (null === this._env) {
          var t2 = this._pts[this._start], e2 = this._pts[this._end];
          this._env = new j(t2, e2);
        }
        return this._env;
      }, mn.prototype.getEndIndex = function() {
        return this._end;
      }, mn.prototype.getStartIndex = function() {
        return this._start;
      }, mn.prototype.getContext = function() {
        return this._context;
      }, mn.prototype.getId = function() {
        return this._id;
      }, mn.prototype.computeOverlapsInternal = function(t2, e2, n2, i2, r2, o2) {
        var s2 = this._pts[t2], a2 = this._pts[e2], u2 = n2._pts[i2], l2 = n2._pts[r2];
        if (e2 - t2 == 1 && r2 - i2 == 1)
          return o2.overlap(this, t2, n2, i2), null;
        if (o2.tempEnv1.init(s2, a2), o2.tempEnv2.init(u2, l2), !o2.tempEnv1.intersects(o2.tempEnv2))
          return null;
        var c2 = Math.trunc((t2 + e2) / 2), p2 = Math.trunc((i2 + r2) / 2);
        t2 < c2 && (i2 < p2 && this.computeOverlapsInternal(t2, c2, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(t2, c2, n2, p2, r2, o2)), c2 < e2 && (i2 < p2 && this.computeOverlapsInternal(c2, e2, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(c2, e2, n2, p2, r2, o2));
      }, mn.prototype.interfaces_ = function() {
        return [];
      }, mn.prototype.getClass = function() {
        return mn;
      };
      var vn = function() {
      };
      vn.prototype.interfaces_ = function() {
        return [];
      }, vn.prototype.getClass = function() {
        return vn;
      }, vn.getChainStartIndices = function(t2) {
        var e2 = 0, n2 = new Nt();
        n2.add(new M(e2));
        do {
          var i2 = vn.findChainEnd(t2, e2);
          n2.add(new M(i2)), e2 = i2;
        } while (e2 < t2.length - 1);
        return vn.toIntArray(n2);
      }, vn.findChainEnd = function(t2, e2) {
        for (var n2 = e2; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); )
          n2++;
        if (n2 >= t2.length - 1)
          return t2.length - 1;
        for (var i2 = Be.quadrant(t2[n2], t2[n2 + 1]), r2 = e2 + 1; r2 < t2.length; ) {
          if (!t2[r2 - 1].equals2D(t2[r2])) {
            if (Be.quadrant(t2[r2 - 1], t2[r2]) !== i2)
              break;
          }
          r2++;
        }
        return r2 - 1;
      }, vn.getChains = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return vn.getChains(t2, null);
        }
        if (2 === arguments.length) {
          for (var e2 = arguments[0], n2 = arguments[1], i2 = new Nt(), r2 = vn.getChainStartIndices(e2), o2 = 0; o2 < r2.length - 1; o2++) {
            var s2 = new mn(e2, r2[o2], r2[o2 + 1], n2);
            i2.add(s2);
          }
          return i2;
        }
      }, vn.toIntArray = function(t2) {
        for (var e2 = new Array(t2.size()).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = t2.get(n2).intValue();
        return e2;
      };
      var In = function() {
      };
      In.prototype.computeNodes = function(t2) {
      }, In.prototype.getNodedSubstrings = function() {
      }, In.prototype.interfaces_ = function() {
        return [];
      }, In.prototype.getClass = function() {
        return In;
      };
      var En = function() {
        if (this._segInt = null, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setSegmentIntersector(t2);
        }
      };
      En.prototype.setSegmentIntersector = function(t2) {
        this._segInt = t2;
      }, En.prototype.interfaces_ = function() {
        return [In];
      }, En.prototype.getClass = function() {
        return En;
      };
      var xn = function(t2) {
        function e2(e3) {
          e3 ? t2.call(this, e3) : t2.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
        }
        t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
        var n2 = { SegmentOverlapAction: { configurable: true } };
        return e2.prototype.getMonotoneChains = function() {
          return this._monoChains;
        }, e2.prototype.getNodedSubstrings = function() {
          return gn.getNodedSubstrings(this._nodedSegStrings);
        }, e2.prototype.getIndex = function() {
          return this._index;
        }, e2.prototype.add = function(t3) {
          for (var e3 = vn.getChains(t3.getCoordinates(), t3).iterator(); e3.hasNext(); ) {
            var n3 = e3.next();
            n3.setId(this._idCounter++), this._index.insert(n3.getEnvelope(), n3), this._monoChains.add(n3);
          }
        }, e2.prototype.computeNodes = function(t3) {
          this._nodedSegStrings = t3;
          for (var e3 = t3.iterator(); e3.hasNext(); )
            this.add(e3.next());
          this.intersectChains();
        }, e2.prototype.intersectChains = function() {
          for (var t3 = new Nn(this._segInt), e3 = this._monoChains.iterator(); e3.hasNext(); )
            for (var n3 = e3.next(), i2 = this._index.query(n3.getEnvelope()).iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2.getId() > n3.getId() && (n3.computeOverlaps(r2, t3), this._nOverlaps++), this._segInt.isDone())
                return null;
            }
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, n2.SegmentOverlapAction.get = function() {
          return Nn;
        }, Object.defineProperties(e2, n2), e2;
      }(En), Nn = function(t2) {
        function e2() {
          t2.call(this), this._si = null;
          var e3 = arguments[0];
          this._si = e3;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.overlap = function() {
          if (4 !== arguments.length)
            return t2.prototype.overlap.apply(this, arguments);
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3], o2 = e3.getContext(), s2 = i2.getContext();
          this._si.processIntersections(o2, n2, s2, r2);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(_n), Cn = function t2() {
        if (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t2.CAP_ROUND, this._joinStyle = t2.JOIN_ROUND, this._mitreLimit = t2.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = t2.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var e2 = arguments[0];
          this.setQuadrantSegments(e2);
        } else if (2 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1];
          this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
        } else if (4 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
          this.setQuadrantSegments(r2), this.setEndCapStyle(o2), this.setJoinStyle(s2), this.setMitreLimit(a2);
        }
      }, Sn = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
      Cn.prototype.getEndCapStyle = function() {
        return this._endCapStyle;
      }, Cn.prototype.isSingleSided = function() {
        return this._isSingleSided;
      }, Cn.prototype.setQuadrantSegments = function(t2) {
        this._quadrantSegments = t2, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);
      }, Cn.prototype.getJoinStyle = function() {
        return this._joinStyle;
      }, Cn.prototype.setJoinStyle = function(t2) {
        this._joinStyle = t2;
      }, Cn.prototype.setSimplifyFactor = function(t2) {
        this._simplifyFactor = t2 < 0 ? 0 : t2;
      }, Cn.prototype.getSimplifyFactor = function() {
        return this._simplifyFactor;
      }, Cn.prototype.getQuadrantSegments = function() {
        return this._quadrantSegments;
      }, Cn.prototype.setEndCapStyle = function(t2) {
        this._endCapStyle = t2;
      }, Cn.prototype.getMitreLimit = function() {
        return this._mitreLimit;
      }, Cn.prototype.setMitreLimit = function(t2) {
        this._mitreLimit = t2;
      }, Cn.prototype.setSingleSided = function(t2) {
        this._isSingleSided = t2;
      }, Cn.prototype.interfaces_ = function() {
        return [];
      }, Cn.prototype.getClass = function() {
        return Cn;
      }, Cn.bufferDistanceError = function(t2) {
        var e2 = Math.PI / 2 / t2;
        return 1 - Math.cos(e2 / 2);
      }, Sn.CAP_ROUND.get = function() {
        return 1;
      }, Sn.CAP_FLAT.get = function() {
        return 2;
      }, Sn.CAP_SQUARE.get = function() {
        return 3;
      }, Sn.JOIN_ROUND.get = function() {
        return 1;
      }, Sn.JOIN_MITRE.get = function() {
        return 2;
      }, Sn.JOIN_BEVEL.get = function() {
        return 3;
      }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function() {
        return 8;
      }, Sn.DEFAULT_MITRE_LIMIT.get = function() {
        return 5;
      }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function() {
        return 0.01;
      }, Object.defineProperties(Cn, Sn);
      var Ln = function(t2) {
        this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t2 || null;
      }, bn = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
      Ln.prototype.isDeletable = function(t2, e2, n2, i2) {
        var r2 = this._inputLine[t2], o2 = this._inputLine[e2], s2 = this._inputLine[n2];
        return !!this.isConcave(r2, o2, s2) && (!!this.isShallow(r2, o2, s2, i2) && this.isShallowSampled(r2, o2, t2, n2, i2));
      }, Ln.prototype.deleteShallowConcavities = function() {
        for (var t2 = 1, e2 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e2), i2 = false; n2 < this._inputLine.length; ) {
          var r2 = false;
          this.isDeletable(t2, e2, n2, this._distanceTol) && (this._isDeleted[e2] = Ln.DELETE, r2 = true, i2 = true), t2 = r2 ? n2 : e2, e2 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e2);
        }
        return i2;
      }, Ln.prototype.isShallowConcavity = function(t2, e2, n2, i2) {
        if (!(at.computeOrientation(t2, e2, n2) === this._angleOrientation))
          return false;
        return at.distancePointLine(e2, t2, n2) < i2;
      }, Ln.prototype.isShallowSampled = function(t2, e2, n2, i2, r2) {
        var o2 = Math.trunc((i2 - n2) / Ln.NUM_PTS_TO_CHECK);
        o2 <= 0 && (o2 = 1);
        for (var s2 = n2; s2 < i2; s2 += o2)
          if (!this.isShallow(t2, e2, this._inputLine[s2], r2))
            return false;
        return true;
      }, Ln.prototype.isConcave = function(t2, e2, n2) {
        var i2 = at.computeOrientation(t2, e2, n2) === this._angleOrientation;
        return i2;
      }, Ln.prototype.simplify = function(t2) {
        this._distanceTol = Math.abs(t2), t2 < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
        var e2 = false;
        do {
          e2 = this.deleteShallowConcavities();
        } while (e2);
        return this.collapseLine();
      }, Ln.prototype.findNextNonDeletedIndex = function(t2) {
        for (var e2 = t2 + 1; e2 < this._inputLine.length && this._isDeleted[e2] === Ln.DELETE; )
          e2++;
        return e2;
      }, Ln.prototype.isShallow = function(t2, e2, n2, i2) {
        return at.distancePointLine(e2, t2, n2) < i2;
      }, Ln.prototype.collapseLine = function() {
        for (var t2 = new St(), e2 = 0; e2 < this._inputLine.length; e2++)
          this._isDeleted[e2] !== Ln.DELETE && t2.add(this._inputLine[e2]);
        return t2.toCoordinateArray();
      }, Ln.prototype.interfaces_ = function() {
        return [];
      }, Ln.prototype.getClass = function() {
        return Ln;
      }, Ln.simplify = function(t2, e2) {
        return new Ln(t2).simplify(e2);
      }, bn.INIT.get = function() {
        return 0;
      }, bn.DELETE.get = function() {
        return 1;
      }, bn.KEEP.get = function() {
        return 1;
      }, bn.NUM_PTS_TO_CHECK.get = function() {
        return 10;
      }, Object.defineProperties(Ln, bn);
      var wn = function() {
        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();
      }, On = { COORDINATE_ARRAY_TYPE: { configurable: true } };
      wn.prototype.getCoordinates = function() {
        return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);
      }, wn.prototype.setPrecisionModel = function(t2) {
        this._precisionModel = t2;
      }, wn.prototype.addPt = function(t2) {
        var e2 = new C(t2);
        if (this._precisionModel.makePrecise(e2), this.isRedundant(e2))
          return null;
        this._ptList.add(e2);
      }, wn.prototype.revere = function() {
      }, wn.prototype.addPts = function(t2, e2) {
        if (e2)
          for (var n2 = 0; n2 < t2.length; n2++)
            this.addPt(t2[n2]);
        else
          for (var i2 = t2.length - 1; i2 >= 0; i2--)
            this.addPt(t2[i2]);
      }, wn.prototype.isRedundant = function(t2) {
        if (this._ptList.size() < 1)
          return false;
        var e2 = this._ptList.get(this._ptList.size() - 1);
        return t2.distance(e2) < this._minimimVertexDistance;
      }, wn.prototype.toString = function() {
        return new _e().createLineString(this.getCoordinates()).toString();
      }, wn.prototype.closeRing = function() {
        if (this._ptList.size() < 1)
          return null;
        var t2 = new C(this._ptList.get(0)), e2 = this._ptList.get(this._ptList.size() - 1);
        if (t2.equals(e2))
          return null;
        this._ptList.add(t2);
      }, wn.prototype.setMinimumVertexDistance = function(t2) {
        this._minimimVertexDistance = t2;
      }, wn.prototype.interfaces_ = function() {
        return [];
      }, wn.prototype.getClass = function() {
        return wn;
      }, On.COORDINATE_ARRAY_TYPE.get = function() {
        return new Array(0).fill(null);
      }, Object.defineProperties(wn, On);
      var Tn = function() {
      }, Rn = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
      Tn.prototype.interfaces_ = function() {
        return [];
      }, Tn.prototype.getClass = function() {
        return Tn;
      }, Tn.toDegrees = function(t2) {
        return 180 * t2 / Math.PI;
      }, Tn.normalize = function(t2) {
        for (; t2 > Math.PI; )
          t2 -= Tn.PI_TIMES_2;
        for (; t2 <= -Math.PI; )
          t2 += Tn.PI_TIMES_2;
        return t2;
      }, Tn.angle = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Math.atan2(t2.y, t2.x);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = n2.x - e2.x, r2 = n2.y - e2.y;
          return Math.atan2(r2, i2);
        }
      }, Tn.isAcute = function(t2, e2, n2) {
        var i2 = t2.x - e2.x, r2 = t2.y - e2.y;
        return i2 * (n2.x - e2.x) + r2 * (n2.y - e2.y) > 0;
      }, Tn.isObtuse = function(t2, e2, n2) {
        var i2 = t2.x - e2.x, r2 = t2.y - e2.y;
        return i2 * (n2.x - e2.x) + r2 * (n2.y - e2.y) < 0;
      }, Tn.interiorAngle = function(t2, e2, n2) {
        var i2 = Tn.angle(e2, t2), r2 = Tn.angle(e2, n2);
        return Math.abs(r2 - i2);
      }, Tn.normalizePositive = function(t2) {
        if (t2 < 0) {
          for (; t2 < 0; )
            t2 += Tn.PI_TIMES_2;
          t2 >= Tn.PI_TIMES_2 && (t2 = 0);
        } else {
          for (; t2 >= Tn.PI_TIMES_2; )
            t2 -= Tn.PI_TIMES_2;
          t2 < 0 && (t2 = 0);
        }
        return t2;
      }, Tn.angleBetween = function(t2, e2, n2) {
        var i2 = Tn.angle(e2, t2), r2 = Tn.angle(e2, n2);
        return Tn.diff(i2, r2);
      }, Tn.diff = function(t2, e2) {
        var n2 = null;
        return (n2 = t2 < e2 ? e2 - t2 : t2 - e2) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
      }, Tn.toRadians = function(t2) {
        return t2 * Math.PI / 180;
      }, Tn.getTurn = function(t2, e2) {
        var n2 = Math.sin(e2 - t2);
        return n2 > 0 ? Tn.COUNTERCLOCKWISE : n2 < 0 ? Tn.CLOCKWISE : Tn.NONE;
      }, Tn.angleBetweenOriented = function(t2, e2, n2) {
        var i2 = Tn.angle(e2, t2), r2 = Tn.angle(e2, n2) - i2;
        return r2 <= -Math.PI ? r2 + Tn.PI_TIMES_2 : r2 > Math.PI ? r2 - Tn.PI_TIMES_2 : r2;
      }, Rn.PI_TIMES_2.get = function() {
        return 2 * Math.PI;
      }, Rn.PI_OVER_2.get = function() {
        return Math.PI / 2;
      }, Rn.PI_OVER_4.get = function() {
        return Math.PI / 4;
      }, Rn.COUNTERCLOCKWISE.get = function() {
        return at.COUNTERCLOCKWISE;
      }, Rn.CLOCKWISE.get = function() {
        return at.CLOCKWISE;
      }, Rn.NONE.get = function() {
        return at.COLLINEAR;
      }, Object.defineProperties(Tn, Rn);
      var Pn = function t2() {
        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = false;
        var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2];
        this._precisionModel = e2, this._bufParams = n2, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t2.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
      }, Dn = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
      Pn.prototype.addNextSegment = function(t2, e2) {
        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t2, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
          return null;
        var n2 = at.computeOrientation(this._s0, this._s1, this._s2), i2 = n2 === at.CLOCKWISE && this._side === Se.LEFT || n2 === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;
        0 === n2 ? this.addCollinear(e2) : i2 ? this.addOutsideTurn(n2, e2) : this.addInsideTurn(n2, e2);
      }, Pn.prototype.addLineEndCap = function(t2, e2) {
        var n2 = new dn(t2, e2), i2 = new dn();
        this.computeOffsetSegment(n2, Se.LEFT, this._distance, i2);
        var r2 = new dn();
        this.computeOffsetSegment(n2, Se.RIGHT, this._distance, r2);
        var o2 = e2.x - t2.x, s2 = e2.y - t2.y, a2 = Math.atan2(s2, o2);
        switch (this._bufParams.getEndCapStyle()) {
          case Cn.CAP_ROUND:
            this._segList.addPt(i2.p1), this.addFilletArc(e2, a2 + Math.PI / 2, a2 - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
            break;
          case Cn.CAP_FLAT:
            this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
            break;
          case Cn.CAP_SQUARE:
            var u2 = new C();
            u2.x = Math.abs(this._distance) * Math.cos(a2), u2.y = Math.abs(this._distance) * Math.sin(a2);
            var l2 = new C(i2.p1.x + u2.x, i2.p1.y + u2.y), c2 = new C(r2.p1.x + u2.x, r2.p1.y + u2.y);
            this._segList.addPt(l2), this._segList.addPt(c2);
        }
      }, Pn.prototype.getCoordinates = function() {
        return this._segList.getCoordinates();
      }, Pn.prototype.addMitreJoin = function(t2, e2, n2, i2) {
        var r2 = true, o2 = null;
        try {
          o2 = k.intersection(e2.p0, e2.p1, n2.p0, n2.p1);
          (i2 <= 0 ? 1 : o2.distance(t2) / Math.abs(i2)) > this._bufParams.getMitreLimit() && (r2 = false);
        } catch (t3) {
          if (!(t3 instanceof X))
            throw t3;
          o2 = new C(0, 0), r2 = false;
        }
        r2 ? this._segList.addPt(o2) : this.addLimitedMitreJoin(e2, n2, i2, this._bufParams.getMitreLimit());
      }, Pn.prototype.addFilletCorner = function(t2, e2, n2, i2, r2) {
        var o2 = e2.x - t2.x, s2 = e2.y - t2.y, a2 = Math.atan2(s2, o2), u2 = n2.x - t2.x, l2 = n2.y - t2.y, c2 = Math.atan2(l2, u2);
        i2 === at.CLOCKWISE ? a2 <= c2 && (a2 += 2 * Math.PI) : a2 >= c2 && (a2 -= 2 * Math.PI), this._segList.addPt(e2), this.addFilletArc(t2, a2, c2, i2, r2), this._segList.addPt(n2);
      }, Pn.prototype.addOutsideTurn = function(t2, e2) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)
          return this._segList.addPt(this._offset0.p1), null;
        this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e2 && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t2, this._distance), this._segList.addPt(this._offset1.p0));
      }, Pn.prototype.createSquare = function(t2) {
        this._segList.addPt(new C(t2.x + this._distance, t2.y + this._distance)), this._segList.addPt(new C(t2.x + this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y + this._distance)), this._segList.closeRing();
      }, Pn.prototype.addSegments = function(t2, e2) {
        this._segList.addPts(t2, e2);
      }, Pn.prototype.addFirstSegment = function() {
        this._segList.addPt(this._offset1.p0);
      }, Pn.prototype.addLastSegment = function() {
        this._segList.addPt(this._offset1.p1);
      }, Pn.prototype.initSideSegments = function(t2, e2, n2) {
        this._s1 = t2, this._s2 = e2, this._side = n2, this._seg1.setCoordinates(t2, e2), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
      }, Pn.prototype.addLimitedMitreJoin = function(t2, e2, n2, i2) {
        var r2 = this._seg0.p1, o2 = Tn.angle(r2, this._seg0.p0), s2 = Tn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, a2 = Tn.normalize(o2 + s2), u2 = Tn.normalize(a2 + Math.PI), l2 = i2 * n2, c2 = n2 - l2 * Math.abs(Math.sin(s2)), p2 = r2.x + l2 * Math.cos(u2), h2 = r2.y + l2 * Math.sin(u2), f2 = new C(p2, h2), g2 = new dn(r2, f2), d2 = g2.pointAlongOffset(1, c2), y2 = g2.pointAlongOffset(1, -c2);
        this._side === Se.LEFT ? (this._segList.addPt(d2), this._segList.addPt(y2)) : (this._segList.addPt(y2), this._segList.addPt(d2));
      }, Pn.prototype.computeOffsetSegment = function(t2, e2, n2, i2) {
        var r2 = e2 === Se.LEFT ? 1 : -1, o2 = t2.p1.x - t2.p0.x, s2 = t2.p1.y - t2.p0.y, a2 = Math.sqrt(o2 * o2 + s2 * s2), u2 = r2 * n2 * o2 / a2, l2 = r2 * n2 * s2 / a2;
        i2.p0.x = t2.p0.x - l2, i2.p0.y = t2.p0.y + u2, i2.p1.x = t2.p1.x - l2, i2.p1.y = t2.p1.y + u2;
      }, Pn.prototype.addFilletArc = function(t2, e2, n2, i2, r2) {
        var o2 = i2 === at.CLOCKWISE ? -1 : 1, s2 = Math.abs(e2 - n2), a2 = Math.trunc(s2 / this._filletAngleQuantum + 0.5);
        if (a2 < 1)
          return null;
        for (var u2 = s2 / a2, l2 = 0, c2 = new C(); l2 < s2; ) {
          var p2 = e2 + o2 * l2;
          c2.x = t2.x + r2 * Math.cos(p2), c2.y = t2.y + r2 * Math.sin(p2), this._segList.addPt(c2), l2 += u2;
        }
      }, Pn.prototype.addInsideTurn = function(t2, e2) {
        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
          this._segList.addPt(this._li.getIntersection(0));
        else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
          this._segList.addPt(this._offset0.p1);
        else {
          if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
            var n2 = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(n2);
            var i2 = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(i2);
          } else
            this._segList.addPt(this._s1);
          this._segList.addPt(this._offset1.p0);
        }
      }, Pn.prototype.createCircle = function(t2) {
        var e2 = new C(t2.x + this._distance, t2.y);
        this._segList.addPt(e2), this.addFilletArc(t2, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
      }, Pn.prototype.addBevelJoin = function(t2, e2) {
        this._segList.addPt(t2.p1), this._segList.addPt(e2.p0);
      }, Pn.prototype.init = function(t2) {
        this._distance = t2, this._maxCurveSegmentError = t2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t2 * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
      }, Pn.prototype.addCollinear = function(t2) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
        this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t2 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));
      }, Pn.prototype.closeRing = function() {
        this._segList.closeRing();
      }, Pn.prototype.hasNarrowConcaveAngle = function() {
        return this._hasNarrowConcaveAngle;
      }, Pn.prototype.interfaces_ = function() {
        return [];
      }, Pn.prototype.getClass = function() {
        return Pn;
      }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
        return 1e-3;
      }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
        return 1e-3;
      }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
        return 1e-6;
      }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
        return 80;
      }, Object.defineProperties(Pn, Dn);
      var Mn = function() {
        this._distance = 0, this._precisionModel = null, this._bufParams = null;
        var t2 = arguments[0], e2 = arguments[1];
        this._precisionModel = t2, this._bufParams = e2;
      };
      Mn.prototype.getOffsetCurve = function(t2, e2) {
        if (this._distance = e2, 0 === e2)
          return null;
        var n2 = e2 < 0, i2 = Math.abs(e2), r2 = this.getSegGen(i2);
        t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
        var o2 = r2.getCoordinates();
        return n2 && Lt.reverse(o2), o2;
      }, Mn.prototype.computeSingleSidedBufferCurve = function(t2, e2, n2) {
        var i2 = this.simplifyTolerance(this._distance);
        if (e2) {
          n2.addSegments(t2, true);
          var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
          n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
          for (var s2 = o2 - 2; s2 >= 0; s2--)
            n2.addNextSegment(r2[s2], true);
        } else {
          n2.addSegments(t2, false);
          var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
          n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
          for (var l2 = 2; l2 <= u2; l2++)
            n2.addNextSegment(a2[l2], true);
        }
        n2.addLastSegment(), n2.closeRing();
      }, Mn.prototype.computeRingBufferCurve = function(t2, e2, n2) {
        var i2 = this.simplifyTolerance(this._distance);
        e2 === Se.RIGHT && (i2 = -i2);
        var r2 = Ln.simplify(t2, i2), o2 = r2.length - 1;
        n2.initSideSegments(r2[o2 - 1], r2[0], e2);
        for (var s2 = 1; s2 <= o2; s2++) {
          var a2 = 1 !== s2;
          n2.addNextSegment(r2[s2], a2);
        }
        n2.closeRing();
      }, Mn.prototype.computeLineBufferCurve = function(t2, e2) {
        var n2 = this.simplifyTolerance(this._distance), i2 = Ln.simplify(t2, n2), r2 = i2.length - 1;
        e2.initSideSegments(i2[0], i2[1], Se.LEFT);
        for (var o2 = 2; o2 <= r2; o2++)
          e2.addNextSegment(i2[o2], true);
        e2.addLastSegment(), e2.addLineEndCap(i2[r2 - 1], i2[r2]);
        var s2 = Ln.simplify(t2, -n2), a2 = s2.length - 1;
        e2.initSideSegments(s2[a2], s2[a2 - 1], Se.LEFT);
        for (var u2 = a2 - 2; u2 >= 0; u2--)
          e2.addNextSegment(s2[u2], true);
        e2.addLastSegment(), e2.addLineEndCap(s2[1], s2[0]), e2.closeRing();
      }, Mn.prototype.computePointCurve = function(t2, e2) {
        switch (this._bufParams.getEndCapStyle()) {
          case Cn.CAP_ROUND:
            e2.createCircle(t2);
            break;
          case Cn.CAP_SQUARE:
            e2.createSquare(t2);
        }
      }, Mn.prototype.getLineCurve = function(t2, e2) {
        if (this._distance = e2, e2 < 0 && !this._bufParams.isSingleSided())
          return null;
        if (0 === e2)
          return null;
        var n2 = Math.abs(e2), i2 = this.getSegGen(n2);
        if (t2.length <= 1)
          this.computePointCurve(t2[0], i2);
        else if (this._bufParams.isSingleSided()) {
          var r2 = e2 < 0;
          this.computeSingleSidedBufferCurve(t2, r2, i2);
        } else
          this.computeLineBufferCurve(t2, i2);
        return i2.getCoordinates();
      }, Mn.prototype.getBufferParameters = function() {
        return this._bufParams;
      }, Mn.prototype.simplifyTolerance = function(t2) {
        return t2 * this._bufParams.getSimplifyFactor();
      }, Mn.prototype.getRingCurve = function(t2, e2, n2) {
        if (this._distance = n2, t2.length <= 2)
          return this.getLineCurve(t2, n2);
        if (0 === n2)
          return Mn.copyCoordinates(t2);
        var i2 = this.getSegGen(n2);
        return this.computeRingBufferCurve(t2, e2, i2), i2.getCoordinates();
      }, Mn.prototype.computeOffsetCurve = function(t2, e2, n2) {
        var i2 = this.simplifyTolerance(this._distance);
        if (e2) {
          var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
          n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
          for (var s2 = o2 - 2; s2 >= 0; s2--)
            n2.addNextSegment(r2[s2], true);
        } else {
          var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
          n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
          for (var l2 = 2; l2 <= u2; l2++)
            n2.addNextSegment(a2[l2], true);
        }
        n2.addLastSegment();
      }, Mn.prototype.getSegGen = function(t2) {
        return new Pn(this._precisionModel, this._bufParams, t2);
      }, Mn.prototype.interfaces_ = function() {
        return [];
      }, Mn.prototype.getClass = function() {
        return Mn;
      }, Mn.copyCoordinates = function(t2) {
        for (var e2 = new Array(t2.length).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = new C(t2[n2]);
        return e2;
      };
      var An = function() {
        this._subgraphs = null, this._seg = new dn(), this._cga = new at();
        var t2 = arguments[0];
        this._subgraphs = t2;
      }, Fn = { DepthSegment: { configurable: true } };
      An.prototype.findStabbedSegments = function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = new Nt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
            var i2 = n2.next(), r2 = i2.getEnvelope();
            t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e2);
          }
          return e2;
        }
        if (3 === arguments.length) {
          if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze)
            for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = s2.getEdge().getCoordinates(), l2 = 0; l2 < u2.length - 1; l2++) {
              this._seg.p0 = u2[l2], this._seg.p1 = u2[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
              if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o2.x) && !(this._seg.isHorizontal() || o2.y < this._seg.p0.y || o2.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o2) === at.RIGHT)) {
                var c2 = s2.getDepth(Se.LEFT);
                this._seg.p0.equals(u2[l2]) || (c2 = s2.getDepth(Se.RIGHT));
                var p2 = new Gn(this._seg, c2);
                a2.add(p2);
              }
            }
          else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt))
            for (var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = f2.iterator(); d2.hasNext(); ) {
              var y2 = d2.next();
              y2.isForward() && this.findStabbedSegments(h2, y2, g2);
            }
        }
      }, An.prototype.getDepth = function(t2) {
        var e2 = this.findStabbedSegments(t2);
        if (0 === e2.size())
          return 0;
        return $e.min(e2)._leftDepth;
      }, An.prototype.interfaces_ = function() {
        return [];
      }, An.prototype.getClass = function() {
        return An;
      }, Fn.DepthSegment.get = function() {
        return Gn;
      }, Object.defineProperties(An, Fn);
      var Gn = function() {
        this._upwardSeg = null, this._leftDepth = null;
        var t2 = arguments[0], e2 = arguments[1];
        this._upwardSeg = new dn(t2), this._leftDepth = e2;
      };
      Gn.prototype.compareTo = function(t2) {
        var e2 = t2;
        if (this._upwardSeg.minX() >= e2._upwardSeg.maxX())
          return 1;
        if (this._upwardSeg.maxX() <= e2._upwardSeg.minX())
          return -1;
        var n2 = this._upwardSeg.orientationIndex(e2._upwardSeg);
        return 0 !== n2 ? n2 : 0 != (n2 = -1 * e2._upwardSeg.orientationIndex(this._upwardSeg)) ? n2 : this._upwardSeg.compareTo(e2._upwardSeg);
      }, Gn.prototype.compareX = function(t2, e2) {
        var n2 = t2.p0.compareTo(e2.p0);
        return 0 !== n2 ? n2 : t2.p1.compareTo(e2.p1);
      }, Gn.prototype.toString = function() {
        return this._upwardSeg.toString();
      }, Gn.prototype.interfaces_ = function() {
        return [E];
      }, Gn.prototype.getClass = function() {
        return Gn;
      };
      var qn = function(t2, e2, n2) {
        this.p0 = t2 || null, this.p1 = e2 || null, this.p2 = n2 || null;
      };
      qn.prototype.area = function() {
        return qn.area(this.p0, this.p1, this.p2);
      }, qn.prototype.signedArea = function() {
        return qn.signedArea(this.p0, this.p1, this.p2);
      }, qn.prototype.interpolateZ = function(t2) {
        if (null === t2)
          throw new m("Supplied point is null.");
        return qn.interpolateZ(t2, this.p0, this.p1, this.p2);
      }, qn.prototype.longestSideLength = function() {
        return qn.longestSideLength(this.p0, this.p1, this.p2);
      }, qn.prototype.isAcute = function() {
        return qn.isAcute(this.p0, this.p1, this.p2);
      }, qn.prototype.circumcentre = function() {
        return qn.circumcentre(this.p0, this.p1, this.p2);
      }, qn.prototype.area3D = function() {
        return qn.area3D(this.p0, this.p1, this.p2);
      }, qn.prototype.centroid = function() {
        return qn.centroid(this.p0, this.p1, this.p2);
      }, qn.prototype.inCentre = function() {
        return qn.inCentre(this.p0, this.p1, this.p2);
      }, qn.prototype.interfaces_ = function() {
        return [];
      }, qn.prototype.getClass = function() {
        return qn;
      }, qn.area = function(t2, e2, n2) {
        return Math.abs(((n2.x - t2.x) * (e2.y - t2.y) - (e2.x - t2.x) * (n2.y - t2.y)) / 2);
      }, qn.signedArea = function(t2, e2, n2) {
        return ((n2.x - t2.x) * (e2.y - t2.y) - (e2.x - t2.x) * (n2.y - t2.y)) / 2;
      }, qn.det = function(t2, e2, n2, i2) {
        return t2 * i2 - e2 * n2;
      }, qn.interpolateZ = function(t2, e2, n2, i2) {
        var r2 = e2.x, o2 = e2.y, s2 = n2.x - r2, a2 = i2.x - r2, u2 = n2.y - o2, l2 = i2.y - o2, c2 = s2 * l2 - a2 * u2, p2 = t2.x - r2, h2 = t2.y - o2, f2 = (l2 * p2 - a2 * h2) / c2, g2 = (-u2 * p2 + s2 * h2) / c2;
        return e2.z + f2 * (n2.z - e2.z) + g2 * (i2.z - e2.z);
      }, qn.longestSideLength = function(t2, e2, n2) {
        var i2 = t2.distance(e2), r2 = e2.distance(n2), o2 = n2.distance(t2), s2 = i2;
        return r2 > s2 && (s2 = r2), o2 > s2 && (s2 = o2), s2;
      }, qn.isAcute = function(t2, e2, n2) {
        return !!Tn.isAcute(t2, e2, n2) && (!!Tn.isAcute(e2, n2, t2) && !!Tn.isAcute(n2, t2, e2));
      }, qn.circumcentre = function(t2, e2, n2) {
        var i2 = n2.x, r2 = n2.y, o2 = t2.x - i2, s2 = t2.y - r2, a2 = e2.x - i2, u2 = e2.y - r2, l2 = 2 * qn.det(o2, s2, a2, u2), c2 = qn.det(s2, o2 * o2 + s2 * s2, u2, a2 * a2 + u2 * u2), p2 = qn.det(o2, o2 * o2 + s2 * s2, a2, a2 * a2 + u2 * u2);
        return new C(i2 - c2 / l2, r2 + p2 / l2);
      }, qn.perpendicularBisector = function(t2, e2) {
        var n2 = e2.x - t2.x, i2 = e2.y - t2.y, r2 = new k(t2.x + n2 / 2, t2.y + i2 / 2, 1), o2 = new k(t2.x - i2 + n2 / 2, t2.y + n2 + i2 / 2, 1);
        return new k(r2, o2);
      }, qn.angleBisector = function(t2, e2, n2) {
        var i2 = e2.distance(t2), r2 = i2 / (i2 + e2.distance(n2)), o2 = n2.x - t2.x, s2 = n2.y - t2.y;
        return new C(t2.x + r2 * o2, t2.y + r2 * s2);
      }, qn.area3D = function(t2, e2, n2) {
        var i2 = e2.x - t2.x, r2 = e2.y - t2.y, o2 = e2.z - t2.z, s2 = n2.x - t2.x, a2 = n2.y - t2.y, u2 = n2.z - t2.z, l2 = r2 * u2 - o2 * a2, c2 = o2 * s2 - i2 * u2, p2 = i2 * a2 - r2 * s2, h2 = l2 * l2 + c2 * c2 + p2 * p2, f2 = Math.sqrt(h2) / 2;
        return f2;
      }, qn.centroid = function(t2, e2, n2) {
        var i2 = (t2.x + e2.x + n2.x) / 3, r2 = (t2.y + e2.y + n2.y) / 3;
        return new C(i2, r2);
      }, qn.inCentre = function(t2, e2, n2) {
        var i2 = e2.distance(n2), r2 = t2.distance(n2), o2 = t2.distance(e2), s2 = i2 + r2 + o2, a2 = (i2 * t2.x + r2 * e2.x + o2 * n2.x) / s2, u2 = (i2 * t2.y + r2 * e2.y + o2 * n2.y) / s2;
        return new C(a2, u2);
      };
      var Bn = function() {
        this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this._inputGeom = t2, this._distance = e2, this._curveBuilder = n2;
      };
      Bn.prototype.addPoint = function(t2) {
        if (this._distance <= 0)
          return null;
        var e2 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e2, this._distance);
        this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
      }, Bn.prototype.addPolygon = function(t2) {
        var e2 = this._distance, n2 = Se.LEFT;
        this._distance < 0 && (e2 = -this._distance, n2 = Se.RIGHT);
        var i2 = t2.getExteriorRing(), r2 = Lt.removeRepeatedPoints(i2.getCoordinates());
        if (this._distance < 0 && this.isErodedCompletely(i2, this._distance))
          return null;
        if (this._distance <= 0 && r2.length < 3)
          return null;
        this.addPolygonRing(r2, e2, n2, w.EXTERIOR, w.INTERIOR);
        for (var o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
          var s2 = t2.getInteriorRingN(o2), a2 = Lt.removeRepeatedPoints(s2.getCoordinates());
          this._distance > 0 && this.isErodedCompletely(s2, -this._distance) || this.addPolygonRing(a2, e2, Se.opposite(n2), w.INTERIOR, w.EXTERIOR);
        }
      }, Bn.prototype.isTriangleErodedCompletely = function(t2, e2) {
        var n2 = new qn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
        return at.distancePointLine(i2, n2.p0, n2.p1) < Math.abs(e2);
      }, Bn.prototype.addLineString = function(t2) {
        if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
          return null;
        var e2 = Lt.removeRepeatedPoints(t2.getCoordinates()), n2 = this._curveBuilder.getLineCurve(e2, this._distance);
        this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
      }, Bn.prototype.addCurve = function(t2, e2, n2) {
        if (null === t2 || t2.length < 2)
          return null;
        var i2 = new gn(t2, new Pe(0, w.BOUNDARY, e2, n2));
        this._curveList.add(i2);
      }, Bn.prototype.getCurves = function() {
        return this.add(this._inputGeom), this._curveList;
      }, Bn.prototype.addPolygonRing = function(t2, e2, n2, i2, r2) {
        if (0 === e2 && t2.length < ee.MINIMUM_VALID_SIZE)
          return null;
        var o2 = i2, s2 = r2;
        t2.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t2) && (o2 = r2, s2 = i2, n2 = Se.opposite(n2));
        var a2 = this._curveBuilder.getRingCurve(t2, n2, e2);
        this.addCurve(a2, o2, s2);
      }, Bn.prototype.add = function(t2) {
        if (t2.isEmpty())
          return null;
        t2 instanceof $t ? this.addPolygon(t2) : t2 instanceof Kt ? this.addLineString(t2) : t2 instanceof Qt ? this.addPoint(t2) : t2 instanceof te ? this.addCollection(t2) : t2 instanceof Xt ? this.addCollection(t2) : t2 instanceof ne ? this.addCollection(t2) : t2 instanceof zt && this.addCollection(t2);
      }, Bn.prototype.isErodedCompletely = function(t2, e2) {
        var n2 = t2.getCoordinates();
        if (n2.length < 4)
          return e2 < 0;
        if (4 === n2.length)
          return this.isTriangleErodedCompletely(n2, e2);
        var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
        return e2 < 0 && 2 * Math.abs(e2) > r2;
      }, Bn.prototype.addCollection = function(t2) {
        for (var e2 = 0; e2 < t2.getNumGeometries(); e2++) {
          var n2 = t2.getGeometryN(e2);
          this.add(n2);
        }
      }, Bn.prototype.interfaces_ = function() {
        return [];
      }, Bn.prototype.getClass = function() {
        return Bn;
      };
      var Vn = function() {
      };
      Vn.prototype.locate = function(t2) {
      }, Vn.prototype.interfaces_ = function() {
        return [];
      }, Vn.prototype.getClass = function() {
        return Vn;
      };
      var Un = function() {
        this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
        var t2 = arguments[0];
        this._parent = t2, this._atStart = true, this._index = 0, this._max = t2.getNumGeometries();
      };
      Un.prototype.next = function() {
        if (this._atStart)
          return this._atStart = false, Un.isAtomic(this._parent) && this._index++, this._parent;
        if (null !== this._subcollectionIterator) {
          if (this._subcollectionIterator.hasNext())
            return this._subcollectionIterator.next();
          this._subcollectionIterator = null;
        }
        if (this._index >= this._max)
          throw new i();
        var t2 = this._parent.getGeometryN(this._index++);
        return t2 instanceof zt ? (this._subcollectionIterator = new Un(t2), this._subcollectionIterator.next()) : t2;
      }, Un.prototype.remove = function() {
        throw new Error(this.getClass().getName());
      }, Un.prototype.hasNext = function() {
        if (this._atStart)
          return true;
        if (null !== this._subcollectionIterator) {
          if (this._subcollectionIterator.hasNext())
            return true;
          this._subcollectionIterator = null;
        }
        return !(this._index >= this._max);
      }, Un.prototype.interfaces_ = function() {
        return [Et];
      }, Un.prototype.getClass = function() {
        return Un;
      }, Un.isAtomic = function(t2) {
        return !(t2 instanceof zt);
      };
      var zn = function() {
        this._geom = null;
        var t2 = arguments[0];
        this._geom = t2;
      };
      zn.prototype.locate = function(t2) {
        return zn.locate(t2, this._geom);
      }, zn.prototype.interfaces_ = function() {
        return [Vn];
      }, zn.prototype.getClass = function() {
        return zn;
      }, zn.isPointInRing = function(t2, e2) {
        return !!e2.getEnvelopeInternal().intersects(t2) && at.isPointInRing(t2, e2.getCoordinates());
      }, zn.containsPointInPolygon = function(t2, e2) {
        if (e2.isEmpty())
          return false;
        var n2 = e2.getExteriorRing();
        if (!zn.isPointInRing(t2, n2))
          return false;
        for (var i2 = 0; i2 < e2.getNumInteriorRing(); i2++) {
          var r2 = e2.getInteriorRingN(i2);
          if (zn.isPointInRing(t2, r2))
            return false;
        }
        return true;
      }, zn.containsPoint = function(t2, e2) {
        if (e2 instanceof $t)
          return zn.containsPointInPolygon(t2, e2);
        if (e2 instanceof zt)
          for (var n2 = new Un(e2); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2 !== e2 && zn.containsPoint(t2, i2))
              return true;
          }
        return false;
      }, zn.locate = function(t2, e2) {
        return e2.isEmpty() ? w.EXTERIOR : zn.containsPoint(t2, e2) ? w.INTERIOR : w.EXTERIOR;
      };
      var Xn = function() {
        this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];
      };
      Xn.prototype.getNextCW = function(t2) {
        this.getEdges();
        var e2 = this._edgeList.indexOf(t2), n2 = e2 - 1;
        return 0 === e2 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
      }, Xn.prototype.propagateSideLabels = function(t2) {
        for (var e2 = w.NONE, n2 = this.iterator(); n2.hasNext(); ) {
          var i2 = n2.next().getLabel();
          i2.isArea(t2) && i2.getLocation(t2, Se.LEFT) !== w.NONE && (e2 = i2.getLocation(t2, Se.LEFT));
        }
        if (e2 === w.NONE)
          return null;
        for (var r2 = e2, o2 = this.iterator(); o2.hasNext(); ) {
          var s2 = o2.next(), a2 = s2.getLabel();
          if (a2.getLocation(t2, Se.ON) === w.NONE && a2.setLocation(t2, Se.ON, r2), a2.isArea(t2)) {
            var u2 = a2.getLocation(t2, Se.LEFT), l2 = a2.getLocation(t2, Se.RIGHT);
            if (l2 !== w.NONE) {
              if (l2 !== r2)
                throw new we("side location conflict", s2.getCoordinate());
              u2 === w.NONE && et.shouldNeverReachHere("found single null side (at " + s2.getCoordinate() + ")"), r2 = u2;
            } else
              et.isTrue(a2.getLocation(t2, Se.LEFT) === w.NONE, "found single null side"), a2.setLocation(t2, Se.RIGHT, r2), a2.setLocation(t2, Se.LEFT, r2);
          }
        }
      }, Xn.prototype.getCoordinate = function() {
        var t2 = this.iterator();
        if (!t2.hasNext())
          return null;
        return t2.next().getCoordinate();
      }, Xn.prototype.print = function(t2) {
        Y.out.println("EdgeEndStar:   " + this.getCoordinate());
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          e2.next().print(t2);
        }
      }, Xn.prototype.isAreaLabelsConsistent = function(t2) {
        return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
      }, Xn.prototype.checkAreaLabelsConsistent = function(t2) {
        var e2 = this.getEdges();
        if (e2.size() <= 0)
          return true;
        var n2 = e2.size() - 1, i2 = e2.get(n2).getLabel().getLocation(t2, Se.LEFT);
        et.isTrue(i2 !== w.NONE, "Found unlabelled area edge");
        for (var r2 = i2, o2 = this.iterator(); o2.hasNext(); ) {
          var s2 = o2.next().getLabel();
          et.isTrue(s2.isArea(t2), "Found non-area edge");
          var a2 = s2.getLocation(t2, Se.LEFT), u2 = s2.getLocation(t2, Se.RIGHT);
          if (a2 === u2)
            return false;
          if (u2 !== r2)
            return false;
          r2 = a2;
        }
        return true;
      }, Xn.prototype.findIndex = function(t2) {
        this.iterator();
        for (var e2 = 0; e2 < this._edgeList.size(); e2++) {
          if (this._edgeList.get(e2) === t2)
            return e2;
        }
        return -1;
      }, Xn.prototype.iterator = function() {
        return this.getEdges().iterator();
      }, Xn.prototype.getEdges = function() {
        return null === this._edgeList && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;
      }, Xn.prototype.getLocation = function(t2, e2, n2) {
        return this._ptInAreaLocation[t2] === w.NONE && (this._ptInAreaLocation[t2] = zn.locate(e2, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
      }, Xn.prototype.toString = function() {
        var t2 = new D();
        t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          t2.append(n2), t2.append("\n");
        }
        return t2.toString();
      }, Xn.prototype.computeEdgeEndLabels = function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          e2.next().computeLabel(t2);
        }
      }, Xn.prototype.computeLabelling = function(t2) {
        this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
        for (var e2 = [false, false], n2 = this.iterator(); n2.hasNext(); )
          for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++)
            i2.isLine(r2) && i2.getLocation(r2) === w.BOUNDARY && (e2[r2] = true);
        for (var o2 = this.iterator(); o2.hasNext(); )
          for (var s2 = o2.next(), a2 = s2.getLabel(), u2 = 0; u2 < 2; u2++)
            if (a2.isAnyNull(u2)) {
              var l2 = w.NONE;
              if (e2[u2])
                l2 = w.EXTERIOR;
              else {
                var c2 = s2.getCoordinate();
                l2 = this.getLocation(u2, c2, t2);
              }
              a2.setAllLocationsIfNull(u2, l2);
            }
      }, Xn.prototype.getDegree = function() {
        return this._edgeMap.size();
      }, Xn.prototype.insertEdgeEnd = function(t2, e2) {
        this._edgeMap.put(t2, e2), this._edgeList = null;
      }, Xn.prototype.interfaces_ = function() {
        return [];
      }, Xn.prototype.getClass = function() {
        return Xn;
      };
      var Yn = function(t2) {
        function e2() {
          t2.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.linkResultDirectedEdges = function() {
          this.getResultAreaEdges();
          for (var t3 = null, e3 = null, n2 = this._SCANNING_FOR_INCOMING, i2 = 0; i2 < this._resultAreaEdgeList.size(); i2++) {
            var r2 = this._resultAreaEdgeList.get(i2), o2 = r2.getSym();
            if (r2.getLabel().isArea())
              switch (null === t3 && r2.isInResult() && (t3 = r2), n2) {
                case this._SCANNING_FOR_INCOMING:
                  if (!o2.isInResult())
                    continue;
                  e3 = o2, n2 = this._LINKING_TO_OUTGOING;
                  break;
                case this._LINKING_TO_OUTGOING:
                  if (!r2.isInResult())
                    continue;
                  e3.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
              }
          }
          if (n2 === this._LINKING_TO_OUTGOING) {
            if (null === t3)
              throw new we("no outgoing dirEdge found", this.getCoordinate());
            et.isTrue(t3.isInResult(), "unable to link last incoming dirEdge"), e3.setNext(t3);
          }
        }, e2.prototype.insert = function(t3) {
          var e3 = t3;
          this.insertEdgeEnd(e3, e3);
        }, e2.prototype.getRightmostEdge = function() {
          var t3 = this.getEdges(), e3 = t3.size();
          if (e3 < 1)
            return null;
          var n2 = t3.get(0);
          if (1 === e3)
            return n2;
          var i2 = t3.get(e3 - 1), r2 = n2.getQuadrant(), o2 = i2.getQuadrant();
          return Be.isNorthern(r2) && Be.isNorthern(o2) ? n2 : Be.isNorthern(r2) || Be.isNorthern(o2) ? 0 !== n2.getDy() ? n2 : 0 !== i2.getDy() ? i2 : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i2;
        }, e2.prototype.print = function(t3) {
          Y.out.println("DirectedEdgeStar: " + this.getCoordinate());
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t3.print("out "), n2.print(t3), t3.println(), t3.print("in "), n2.getSym().print(t3), t3.println();
          }
        }, e2.prototype.getResultAreaEdges = function() {
          if (null !== this._resultAreaEdgeList)
            return this._resultAreaEdgeList;
          this._resultAreaEdgeList = new Nt();
          for (var t3 = this.iterator(); t3.hasNext(); ) {
            var e3 = t3.next();
            (e3.isInResult() || e3.getSym().isInResult()) && this._resultAreaEdgeList.add(e3);
          }
          return this._resultAreaEdgeList;
        }, e2.prototype.updateLabelling = function(t3) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next().getLabel();
            n2.setAllLocationsIfNull(0, t3.getLocation(0)), n2.setAllLocationsIfNull(1, t3.getLocation(1));
          }
        }, e2.prototype.linkAllDirectedEdges = function() {
          this.getEdges();
          for (var t3 = null, e3 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
            var i2 = this._edgeList.get(n2), r2 = i2.getSym();
            null === e3 && (e3 = r2), null !== t3 && r2.setNext(t3), t3 = i2;
          }
          e3.setNext(t3);
        }, e2.prototype.computeDepths = function() {
          if (1 === arguments.length) {
            var t3 = arguments[0], e3 = this.findIndex(t3), n2 = t3.getDepth(Se.LEFT), i2 = t3.getDepth(Se.RIGHT), r2 = this.computeDepths(e3 + 1, this._edgeList.size(), n2);
            if (this.computeDepths(0, e3, r2) !== i2)
              throw new we("depth mismatch at " + t3.getCoordinate());
          } else if (3 === arguments.length) {
            for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = o2; u2 < s2; u2++) {
              var l2 = this._edgeList.get(u2);
              l2.setEdgeDepths(Se.RIGHT, a2), a2 = l2.getDepth(Se.LEFT);
            }
            return a2;
          }
        }, e2.prototype.mergeSymLabels = function() {
          for (var t3 = this.iterator(); t3.hasNext(); ) {
            var e3 = t3.next();
            e3.getLabel().merge(e3.getSym().getLabel());
          }
        }, e2.prototype.linkMinimalDirectedEdges = function(t3) {
          for (var e3 = null, n2 = null, i2 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
            var o2 = this._resultAreaEdgeList.get(r2), s2 = o2.getSym();
            switch (null === e3 && o2.getEdgeRing() === t3 && (e3 = o2), i2) {
              case this._SCANNING_FOR_INCOMING:
                if (s2.getEdgeRing() !== t3)
                  continue;
                n2 = s2, i2 = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (o2.getEdgeRing() !== t3)
                  continue;
                n2.setNextMin(o2), i2 = this._SCANNING_FOR_INCOMING;
            }
          }
          i2 === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e3, "found null for first outgoing dirEdge"), et.isTrue(e3.getEdgeRing() === t3, "unable to link last incoming dirEdge"), n2.setNextMin(e3));
        }, e2.prototype.getOutgoingDegree = function() {
          if (0 === arguments.length) {
            for (var t3 = 0, e3 = this.iterator(); e3.hasNext(); ) {
              e3.next().isInResult() && t3++;
            }
            return t3;
          }
          if (1 === arguments.length) {
            for (var n2 = arguments[0], i2 = 0, r2 = this.iterator(); r2.hasNext(); ) {
              r2.next().getEdgeRing() === n2 && i2++;
            }
            return i2;
          }
        }, e2.prototype.getLabel = function() {
          return this._label;
        }, e2.prototype.findCoveredLineEdges = function() {
          for (var t3 = w.NONE, e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getSym();
            if (!n2.isLineEdge()) {
              if (n2.isInResult()) {
                t3 = w.INTERIOR;
                break;
              }
              if (i2.isInResult()) {
                t3 = w.EXTERIOR;
                break;
              }
            }
          }
          if (t3 === w.NONE)
            return null;
          for (var r2 = t3, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next(), a2 = s2.getSym();
            s2.isLineEdge() ? s2.getEdge().setCovered(r2 === w.INTERIOR) : (s2.isInResult() && (r2 = w.EXTERIOR), a2.isInResult() && (r2 = w.INTERIOR));
          }
        }, e2.prototype.computeLabelling = function(e3) {
          t2.prototype.computeLabelling.call(this, e3), this._label = new Pe(w.NONE);
          for (var n2 = this.iterator(); n2.hasNext(); )
            for (var i2 = n2.next().getEdge().getLabel(), r2 = 0; r2 < 2; r2++) {
              var o2 = i2.getLocation(r2);
              o2 !== w.INTERIOR && o2 !== w.BOUNDARY || this._label.setLocation(r2, w.INTERIOR);
            }
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(Xn), kn = function(t2) {
        function e2() {
          t2.apply(this, arguments);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.createNode = function(t3) {
          return new Ge(t3, new Yn());
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(Xe), jn = function t2() {
        this._pts = null, this._orientation = null;
        var e2 = arguments[0];
        this._pts = e2, this._orientation = t2.orientation(e2);
      };
      jn.prototype.compareTo = function(t2) {
        var e2 = t2;
        return jn.compareOriented(this._pts, this._orientation, e2._pts, e2._orientation);
      }, jn.prototype.interfaces_ = function() {
        return [E];
      }, jn.prototype.getClass = function() {
        return jn;
      }, jn.orientation = function(t2) {
        return 1 === Lt.increasingDirection(t2);
      }, jn.compareOriented = function(t2, e2, n2, i2) {
        for (var r2 = e2 ? 1 : -1, o2 = i2 ? 1 : -1, s2 = e2 ? t2.length : -1, a2 = i2 ? n2.length : -1, u2 = e2 ? 0 : t2.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
          var c2 = t2[u2].compareTo(n2[l2]);
          if (0 !== c2)
            return c2;
          var p2 = (u2 += r2) === s2, h2 = (l2 += o2) === a2;
          if (p2 && !h2)
            return -1;
          if (!p2 && h2)
            return 1;
          if (p2 && h2)
            return 0;
        }
      };
      var Hn = function() {
        this._edges = new Nt(), this._ocaMap = new p();
      };
      Hn.prototype.print = function(t2) {
        t2.print("MULTILINESTRING ( ");
        for (var e2 = 0; e2 < this._edges.size(); e2++) {
          var n2 = this._edges.get(e2);
          e2 > 0 && t2.print(","), t2.print("(");
          for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++)
            r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
          t2.println(")");
        }
        t2.print(")  ");
      }, Hn.prototype.addAll = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); )
          this.add(e2.next());
      }, Hn.prototype.findEdgeIndex = function(t2) {
        for (var e2 = 0; e2 < this._edges.size(); e2++)
          if (this._edges.get(e2).equals(t2))
            return e2;
        return -1;
      }, Hn.prototype.iterator = function() {
        return this._edges.iterator();
      }, Hn.prototype.getEdges = function() {
        return this._edges;
      }, Hn.prototype.get = function(t2) {
        return this._edges.get(t2);
      }, Hn.prototype.findEqualEdge = function(t2) {
        var e2 = new jn(t2.getCoordinates());
        return this._ocaMap.get(e2);
      }, Hn.prototype.add = function(t2) {
        this._edges.add(t2);
        var e2 = new jn(t2.getCoordinates());
        this._ocaMap.put(e2, t2);
      }, Hn.prototype.interfaces_ = function() {
        return [];
      }, Hn.prototype.getClass = function() {
        return Hn;
      };
      var Wn = function() {
      };
      Wn.prototype.processIntersections = function(t2, e2, n2, i2) {
      }, Wn.prototype.isDone = function() {
      }, Wn.prototype.interfaces_ = function() {
        return [];
      }, Wn.prototype.getClass = function() {
        return Wn;
      };
      var Kn = function() {
        this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
        var t2 = arguments[0];
        this._li = t2;
      };
      Kn.prototype.isTrivialIntersection = function(t2, e2, n2, i2) {
        if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
          if (Kn.isAdjacentSegments(e2, i2))
            return true;
          if (t2.isClosed()) {
            var r2 = t2.size() - 1;
            if (0 === e2 && i2 === r2 || 0 === i2 && e2 === r2)
              return true;
          }
        }
        return false;
      }, Kn.prototype.getProperIntersectionPoint = function() {
        return this._properIntersectionPoint;
      }, Kn.prototype.hasProperInteriorIntersection = function() {
        return this._hasProperInterior;
      }, Kn.prototype.getLineIntersector = function() {
        return this._li;
      }, Kn.prototype.hasProperIntersection = function() {
        return this._hasProper;
      }, Kn.prototype.processIntersections = function(t2, e2, n2, i2) {
        if (t2 === n2 && e2 === i2)
          return null;
        this.numTests++;
        var r2 = t2.getCoordinates()[e2], o2 = t2.getCoordinates()[e2 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
        this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t2, e2, n2, i2) || (this._hasIntersection = true, t2.addIntersections(this._li, e2, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
      }, Kn.prototype.hasIntersection = function() {
        return this._hasIntersection;
      }, Kn.prototype.isDone = function() {
        return false;
      }, Kn.prototype.hasInteriorIntersection = function() {
        return this._hasInterior;
      }, Kn.prototype.interfaces_ = function() {
        return [Wn];
      }, Kn.prototype.getClass = function() {
        return Kn;
      }, Kn.isAdjacentSegments = function(t2, e2) {
        return 1 === Math.abs(t2 - e2);
      };
      var Jn = function() {
        this.coord = null, this.segmentIndex = null, this.dist = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this.coord = new C(t2), this.segmentIndex = e2, this.dist = n2;
      };
      Jn.prototype.getSegmentIndex = function() {
        return this.segmentIndex;
      }, Jn.prototype.getCoordinate = function() {
        return this.coord;
      }, Jn.prototype.print = function(t2) {
        t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
      }, Jn.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this.compare(e2.segmentIndex, e2.dist);
      }, Jn.prototype.isEndPoint = function(t2) {
        return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t2;
      }, Jn.prototype.toString = function() {
        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
      }, Jn.prototype.getDistance = function() {
        return this.dist;
      }, Jn.prototype.compare = function(t2, e2) {
        return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e2 ? -1 : this.dist > e2 ? 1 : 0;
      }, Jn.prototype.interfaces_ = function() {
        return [E];
      }, Jn.prototype.getClass = function() {
        return Jn;
      };
      var Qn = function() {
        this._nodeMap = new p(), this.edge = null;
        var t2 = arguments[0];
        this.edge = t2;
      };
      Qn.prototype.print = function(t2) {
        t2.println("Intersections:");
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          e2.next().print(t2);
        }
      }, Qn.prototype.iterator = function() {
        return this._nodeMap.values().iterator();
      }, Qn.prototype.addSplitEdges = function(t2) {
        this.addEndpoints();
        for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
          var i2 = e2.next(), r2 = this.createSplitEdge(n2, i2);
          t2.add(r2), n2 = i2;
        }
      }, Qn.prototype.addEndpoints = function() {
        var t2 = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
      }, Qn.prototype.createSplitEdge = function(t2, e2) {
        var n2 = e2.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e2.segmentIndex], r2 = e2.dist > 0 || !e2.coord.equals2D(i2);
        r2 || n2--;
        var o2 = new Array(n2).fill(null), s2 = 0;
        o2[s2++] = new C(t2.coord);
        for (var a2 = t2.segmentIndex + 1; a2 <= e2.segmentIndex; a2++)
          o2[s2++] = this.edge.pts[a2];
        return r2 && (o2[s2] = e2.coord), new ni(o2, new Pe(this.edge._label));
      }, Qn.prototype.add = function(t2, e2, n2) {
        var i2 = new Jn(t2, e2, n2), r2 = this._nodeMap.get(i2);
        return null !== r2 ? r2 : (this._nodeMap.put(i2, i2), i2);
      }, Qn.prototype.isIntersection = function(t2) {
        for (var e2 = this.iterator(); e2.hasNext(); ) {
          if (e2.next().coord.equals(t2))
            return true;
        }
        return false;
      }, Qn.prototype.interfaces_ = function() {
        return [];
      }, Qn.prototype.getClass = function() {
        return Qn;
      };
      var Zn = function() {
      };
      Zn.prototype.getChainStartIndices = function(t2) {
        var e2 = 0, n2 = new Nt();
        n2.add(new M(e2));
        do {
          var i2 = this.findChainEnd(t2, e2);
          n2.add(new M(i2)), e2 = i2;
        } while (e2 < t2.length - 1);
        return Zn.toIntArray(n2);
      }, Zn.prototype.findChainEnd = function(t2, e2) {
        for (var n2 = Be.quadrant(t2[e2], t2[e2 + 1]), i2 = e2 + 1; i2 < t2.length; ) {
          if (Be.quadrant(t2[i2 - 1], t2[i2]) !== n2)
            break;
          i2++;
        }
        return i2 - 1;
      }, Zn.prototype.interfaces_ = function() {
        return [];
      }, Zn.prototype.getClass = function() {
        return Zn;
      }, Zn.toIntArray = function(t2) {
        for (var e2 = new Array(t2.size()).fill(null), n2 = 0; n2 < e2.length; n2++)
          e2[n2] = t2.get(n2).intValue();
        return e2;
      };
      var $n = function() {
        this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();
        var t2 = arguments[0];
        this.e = t2, this.pts = t2.getCoordinates();
        var e2 = new Zn();
        this.startIndex = e2.getChainStartIndices(this.pts);
      };
      $n.prototype.getCoordinates = function() {
        return this.pts;
      }, $n.prototype.getMaxX = function(t2) {
        var e2 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
        return e2 > n2 ? e2 : n2;
      }, $n.prototype.getMinX = function(t2) {
        var e2 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
        return e2 < n2 ? e2 : n2;
      }, $n.prototype.computeIntersectsForChain = function() {
        if (4 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e2, e2.startIndex[n2], e2.startIndex[n2 + 1], i2);
        } else if (6 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = arguments[4], l2 = arguments[5], c2 = this.pts[r2], p2 = this.pts[o2], h2 = s2.pts[a2], f2 = s2.pts[u2];
          if (o2 - r2 == 1 && u2 - a2 == 1)
            return l2.addIntersections(this.e, r2, s2.e, a2), null;
          if (this.env1.init(c2, p2), this.env2.init(h2, f2), !this.env1.intersects(this.env2))
            return null;
          var g2 = Math.trunc((r2 + o2) / 2), d2 = Math.trunc((a2 + u2) / 2);
          r2 < g2 && (a2 < d2 && this.computeIntersectsForChain(r2, g2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(r2, g2, s2, d2, u2, l2)), g2 < o2 && (a2 < d2 && this.computeIntersectsForChain(g2, o2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(g2, o2, s2, d2, u2, l2));
        }
      }, $n.prototype.getStartIndexes = function() {
        return this.startIndex;
      }, $n.prototype.computeIntersects = function(t2, e2) {
        for (var n2 = 0; n2 < this.startIndex.length - 1; n2++)
          for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++)
            this.computeIntersectsForChain(n2, t2, i2, e2);
      }, $n.prototype.interfaces_ = function() {
        return [];
      }, $n.prototype.getClass = function() {
        return $n;
      };
      var ti = function t2() {
        this._depth = Array(2).fill().map(function() {
          return Array(3);
        });
        for (var e2 = 0; e2 < 2; e2++)
          for (var n2 = 0; n2 < 3; n2++)
            this._depth[e2][n2] = t2.NULL_VALUE;
      }, ei = { NULL_VALUE: { configurable: true } };
      ti.prototype.getDepth = function(t2, e2) {
        return this._depth[t2][e2];
      }, ti.prototype.setDepth = function(t2, e2, n2) {
        this._depth[t2][e2] = n2;
      }, ti.prototype.isNull = function() {
        if (0 === arguments.length) {
          for (var t2 = 0; t2 < 2; t2++)
            for (var e2 = 0; e2 < 3; e2++)
              if (this._depth[t2][e2] !== ti.NULL_VALUE)
                return false;
          return true;
        }
        if (1 === arguments.length) {
          var n2 = arguments[0];
          return this._depth[n2][1] === ti.NULL_VALUE;
        }
        if (2 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1];
          return this._depth[i2][r2] === ti.NULL_VALUE;
        }
      }, ti.prototype.normalize = function() {
        for (var t2 = 0; t2 < 2; t2++)
          if (!this.isNull(t2)) {
            var e2 = this._depth[t2][1];
            this._depth[t2][2] < e2 && (e2 = this._depth[t2][2]), e2 < 0 && (e2 = 0);
            for (var n2 = 1; n2 < 3; n2++) {
              var i2 = 0;
              this._depth[t2][n2] > e2 && (i2 = 1), this._depth[t2][n2] = i2;
            }
          }
      }, ti.prototype.getDelta = function(t2) {
        return this._depth[t2][Se.RIGHT] - this._depth[t2][Se.LEFT];
      }, ti.prototype.getLocation = function(t2, e2) {
        return this._depth[t2][e2] <= 0 ? w.EXTERIOR : w.INTERIOR;
      }, ti.prototype.toString = function() {
        return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
      }, ti.prototype.add = function() {
        if (1 === arguments.length)
          for (var t2 = arguments[0], e2 = 0; e2 < 2; e2++)
            for (var n2 = 1; n2 < 3; n2++) {
              var i2 = t2.getLocation(e2, n2);
              i2 !== w.EXTERIOR && i2 !== w.INTERIOR || (this.isNull(e2, n2) ? this._depth[e2][n2] = ti.depthAtLocation(i2) : this._depth[e2][n2] += ti.depthAtLocation(i2));
            }
        else if (3 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1];
          arguments[2] === w.INTERIOR && this._depth[r2][o2]++;
        }
      }, ti.prototype.interfaces_ = function() {
        return [];
      }, ti.prototype.getClass = function() {
        return ti;
      }, ti.depthAtLocation = function(t2) {
        return t2 === w.EXTERIOR ? 0 : t2 === w.INTERIOR ? 1 : ti.NULL_VALUE;
      }, ei.NULL_VALUE.get = function() {
        return -1;
      }, Object.defineProperties(ti, ei);
      var ni = function(t2) {
        function e2() {
          if (t2.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ti(), this._depthDelta = 0, 1 === arguments.length) {
            var n2 = arguments[0];
            e2.call(this, n2, null);
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.pts = i2, this._label = r2;
          }
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.getDepth = function() {
          return this._depth;
        }, e2.prototype.getCollapsedEdge = function() {
          var t3 = new Array(2).fill(null);
          t3[0] = this.pts[0], t3[1] = this.pts[1];
          return new e2(t3, Pe.toLineLabel(this._label));
        }, e2.prototype.isIsolated = function() {
          return this._isIsolated;
        }, e2.prototype.getCoordinates = function() {
          return this.pts;
        }, e2.prototype.setIsolated = function(t3) {
          this._isIsolated = t3;
        }, e2.prototype.setName = function(t3) {
          this._name = t3;
        }, e2.prototype.equals = function(t3) {
          if (!(t3 instanceof e2))
            return false;
          var n2 = t3;
          if (this.pts.length !== n2.pts.length)
            return false;
          for (var i2 = true, r2 = true, o2 = this.pts.length, s2 = 0; s2 < this.pts.length; s2++)
            if (this.pts[s2].equals2D(n2.pts[s2]) || (i2 = false), this.pts[s2].equals2D(n2.pts[--o2]) || (r2 = false), !i2 && !r2)
              return false;
          return true;
        }, e2.prototype.getCoordinate = function() {
          if (0 === arguments.length)
            return this.pts.length > 0 ? this.pts[0] : null;
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this.pts[t3];
          }
        }, e2.prototype.print = function(t3) {
          t3.print("edge " + this._name + ": "), t3.print("LINESTRING (");
          for (var e3 = 0; e3 < this.pts.length; e3++)
            e3 > 0 && t3.print(","), t3.print(this.pts[e3].x + " " + this.pts[e3].y);
          t3.print(")  " + this._label + " " + this._depthDelta);
        }, e2.prototype.computeIM = function(t3) {
          e2.updateIM(this._label, t3);
        }, e2.prototype.isCollapsed = function() {
          return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2]));
        }, e2.prototype.isClosed = function() {
          return this.pts[0].equals(this.pts[this.pts.length - 1]);
        }, e2.prototype.getMaximumSegmentIndex = function() {
          return this.pts.length - 1;
        }, e2.prototype.getDepthDelta = function() {
          return this._depthDelta;
        }, e2.prototype.getNumPoints = function() {
          return this.pts.length;
        }, e2.prototype.printReverse = function(t3) {
          t3.print("edge " + this._name + ": ");
          for (var e3 = this.pts.length - 1; e3 >= 0; e3--)
            t3.print(this.pts[e3] + " ");
          t3.println("");
        }, e2.prototype.getMonotoneChainEdge = function() {
          return null === this._mce && (this._mce = new $n(this)), this._mce;
        }, e2.prototype.getEnvelope = function() {
          if (null === this._env) {
            this._env = new j();
            for (var t3 = 0; t3 < this.pts.length; t3++)
              this._env.expandToInclude(this.pts[t3]);
          }
          return this._env;
        }, e2.prototype.addIntersection = function(t3, e3, n2, i2) {
          var r2 = new C(t3.getIntersection(i2)), o2 = e3, s2 = t3.getEdgeDistance(n2, i2), a2 = o2 + 1;
          if (a2 < this.pts.length) {
            var u2 = this.pts[a2];
            r2.equals2D(u2) && (o2 = a2, s2 = 0);
          }
          this.eiList.add(r2, o2, s2);
        }, e2.prototype.toString = function() {
          var t3 = new D();
          t3.append("edge " + this._name + ": "), t3.append("LINESTRING (");
          for (var e3 = 0; e3 < this.pts.length; e3++)
            e3 > 0 && t3.append(","), t3.append(this.pts[e3].x + " " + this.pts[e3].y);
          return t3.append(")  " + this._label + " " + this._depthDelta), t3.toString();
        }, e2.prototype.isPointwiseEqual = function(t3) {
          if (this.pts.length !== t3.pts.length)
            return false;
          for (var e3 = 0; e3 < this.pts.length; e3++)
            if (!this.pts[e3].equals2D(t3.pts[e3]))
              return false;
          return true;
        }, e2.prototype.setDepthDelta = function(t3) {
          this._depthDelta = t3;
        }, e2.prototype.getEdgeIntersectionList = function() {
          return this.eiList;
        }, e2.prototype.addIntersections = function(t3, e3, n2) {
          for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++)
            this.addIntersection(t3, e3, n2, i2);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2.updateIM = function() {
          if (2 !== arguments.length)
            return t2.prototype.updateIM.apply(this, arguments);
          var e3 = arguments[0], n2 = arguments[1];
          n2.setAtLeastIfValid(e3.getLocation(0, Se.ON), e3.getLocation(1, Se.ON), 1), e3.isArea() && (n2.setAtLeastIfValid(e3.getLocation(0, Se.LEFT), e3.getLocation(1, Se.LEFT), 2), n2.setAtLeastIfValid(e3.getLocation(0, Se.RIGHT), e3.getLocation(1, Se.RIGHT), 2));
        }, e2;
      }(Fe), ii = function(t2) {
        this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t2 || null;
      };
      ii.prototype.setWorkingPrecisionModel = function(t2) {
        this._workingPrecisionModel = t2;
      }, ii.prototype.insertUniqueEdge = function(t2) {
        var e2 = this._edgeList.findEqualEdge(t2);
        if (null !== e2) {
          var n2 = e2.getLabel(), i2 = t2.getLabel();
          e2.isPointwiseEqual(t2) || (i2 = new Pe(t2.getLabel())).flip(), n2.merge(i2);
          var r2 = ii.depthDelta(i2), o2 = e2.getDepthDelta() + r2;
          e2.setDepthDelta(o2);
        } else
          this._edgeList.add(t2), t2.setDepthDelta(ii.depthDelta(t2.getLabel()));
      }, ii.prototype.buildSubgraphs = function(t2, e2) {
        for (var n2 = new Nt(), i2 = t2.iterator(); i2.hasNext(); ) {
          var r2 = i2.next(), o2 = r2.getRightmostCoordinate(), s2 = new An(n2).getDepth(o2);
          r2.computeDepth(s2), r2.findResultEdges(), n2.add(r2), e2.add(r2.getDirectedEdges(), r2.getNodes());
        }
      }, ii.prototype.createSubgraphs = function(t2) {
        for (var e2 = new Nt(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          if (!i2.isVisited()) {
            var r2 = new Te();
            r2.create(i2), e2.add(r2);
          }
        }
        return $e.sort(e2, $e.reverseOrder()), e2;
      }, ii.prototype.createEmptyResultGeometry = function() {
        return this._geomFact.createPolygon();
      }, ii.prototype.getNoder = function(t2) {
        if (null !== this._workingNoder)
          return this._workingNoder;
        var e2 = new xn(), n2 = new rt();
        return n2.setPrecisionModel(t2), e2.setSegmentIntersector(new Kn(n2)), e2;
      }, ii.prototype.buffer = function(t2, e2) {
        var n2 = this._workingPrecisionModel;
        null === n2 && (n2 = t2.getPrecisionModel()), this._geomFact = t2.getFactory();
        var i2 = new Mn(n2, this._bufParams), r2 = new Bn(t2, e2, i2).getCurves();
        if (r2.size() <= 0)
          return this.createEmptyResultGeometry();
        this.computeNodedEdges(r2, n2), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());
        var o2 = this.createSubgraphs(this._graph), s2 = new ke(this._geomFact);
        this.buildSubgraphs(o2, s2);
        var a2 = s2.getPolygons();
        if (a2.size() <= 0)
          return this.createEmptyResultGeometry();
        return this._geomFact.buildGeometry(a2);
      }, ii.prototype.computeNodedEdges = function(t2, e2) {
        var n2 = this.getNoder(e2);
        n2.computeNodes(t2);
        for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
          var r2 = i2.next(), o2 = r2.getCoordinates();
          if (2 !== o2.length || !o2[0].equals2D(o2[1])) {
            var s2 = r2.getData(), a2 = new ni(r2.getCoordinates(), new Pe(s2));
            this.insertUniqueEdge(a2);
          }
        }
      }, ii.prototype.setNoder = function(t2) {
        this._workingNoder = t2;
      }, ii.prototype.interfaces_ = function() {
        return [];
      }, ii.prototype.getClass = function() {
        return ii;
      }, ii.depthDelta = function(t2) {
        var e2 = t2.getLocation(0, Se.LEFT), n2 = t2.getLocation(0, Se.RIGHT);
        return e2 === w.INTERIOR && n2 === w.EXTERIOR ? 1 : e2 === w.EXTERIOR && n2 === w.INTERIOR ? -1 : 0;
      }, ii.convertSegStrings = function(t2) {
        for (var e2 = new _e(), n2 = new Nt(); t2.hasNext(); ) {
          var i2 = t2.next(), r2 = e2.createLineString(i2.getCoordinates());
          n2.add(r2);
        }
        return e2.buildGeometry(n2);
      };
      var ri = function() {
        if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this._noder = t2, this._scaleFactor = e2, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
        } else if (4 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = arguments[3];
          this._noder = n2, this._scaleFactor = i2, this._offsetX = r2, this._offsetY = o2, this._isScaled = !this.isIntegerPrecision();
        }
      };
      ri.prototype.rescale = function() {
        if (T(arguments[0], It))
          for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
            var e2 = t2.next();
            this.rescale(e2.getCoordinates());
          }
        else if (arguments[0] instanceof Array) {
          for (var n2 = arguments[0], i2 = 0; i2 < n2.length; i2++)
            n2[i2].x = n2[i2].x / this._scaleFactor + this._offsetX, n2[i2].y = n2[i2].y / this._scaleFactor + this._offsetY;
          2 === n2.length && n2[0].equals2D(n2[1]) && Y.out.println(n2);
        }
      }, ri.prototype.scale = function() {
        if (T(arguments[0], It)) {
          for (var t2 = arguments[0], e2 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e2.add(new gn(this.scale(i2.getCoordinates()), i2.getData()));
          }
          return e2;
        }
        if (arguments[0] instanceof Array) {
          for (var r2 = arguments[0], o2 = new Array(r2.length).fill(null), s2 = 0; s2 < r2.length; s2++)
            o2[s2] = new C(Math.round((r2[s2].x - this._offsetX) * this._scaleFactor), Math.round((r2[s2].y - this._offsetY) * this._scaleFactor), r2[s2].z);
          return Lt.removeRepeatedPoints(o2);
        }
      }, ri.prototype.isIntegerPrecision = function() {
        return 1 === this._scaleFactor;
      }, ri.prototype.getNodedSubstrings = function() {
        var t2 = this._noder.getNodedSubstrings();
        return this._isScaled && this.rescale(t2), t2;
      }, ri.prototype.computeNodes = function(t2) {
        var e2 = t2;
        this._isScaled && (e2 = this.scale(t2)), this._noder.computeNodes(e2);
      }, ri.prototype.interfaces_ = function() {
        return [In];
      }, ri.prototype.getClass = function() {
        return ri;
      };
      var oi = function() {
        this._li = new rt(), this._segStrings = null;
        var t2 = arguments[0];
        this._segStrings = t2;
      }, si = { fact: { configurable: true } };
      oi.prototype.checkEndPtVertexIntersections = function() {
        if (0 === arguments.length)
          for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
            var e2 = t2.next().getCoordinates();
            this.checkEndPtVertexIntersections(e2[0], this._segStrings), this.checkEndPtVertexIntersections(e2[e2.length - 1], this._segStrings);
          }
        else if (2 === arguments.length) {
          for (var n2 = arguments[0], i2 = arguments[1].iterator(); i2.hasNext(); )
            for (var r2 = i2.next().getCoordinates(), o2 = 1; o2 < r2.length - 1; o2++)
              if (r2[o2].equals(n2))
                throw new $("found endpt/interior pt intersection at index " + o2 + " :pt " + n2);
        }
      }, oi.prototype.checkInteriorIntersections = function() {
        if (0 === arguments.length)
          for (var t2 = this._segStrings.iterator(); t2.hasNext(); )
            for (var e2 = t2.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              this.checkInteriorIntersections(e2, i2);
            }
        else if (2 === arguments.length)
          for (var r2 = arguments[0], o2 = arguments[1], s2 = r2.getCoordinates(), a2 = o2.getCoordinates(), u2 = 0; u2 < s2.length - 1; u2++)
            for (var l2 = 0; l2 < a2.length - 1; l2++)
              this.checkInteriorIntersections(r2, u2, o2, l2);
        else if (4 === arguments.length) {
          var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = arguments[3];
          if (c2 === h2 && p2 === f2)
            return null;
          var g2 = c2.getCoordinates()[p2], d2 = c2.getCoordinates()[p2 + 1], y2 = h2.getCoordinates()[f2], _2 = h2.getCoordinates()[f2 + 1];
          if (this._li.computeIntersection(g2, d2, y2, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g2, d2) || this.hasInteriorIntersection(this._li, y2, _2)))
            throw new $("found non-noded intersection at " + g2 + "-" + d2 + " and " + y2 + "-" + _2);
        }
      }, oi.prototype.checkValid = function() {
        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
      }, oi.prototype.checkCollapses = function() {
        if (0 === arguments.length)
          for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
            var e2 = t2.next();
            this.checkCollapses(e2);
          }
        else if (1 === arguments.length)
          for (var n2 = arguments[0].getCoordinates(), i2 = 0; i2 < n2.length - 2; i2++)
            this.checkCollapse(n2[i2], n2[i2 + 1], n2[i2 + 2]);
      }, oi.prototype.hasInteriorIntersection = function(t2, e2, n2) {
        for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) {
          var r2 = t2.getIntersection(i2);
          if (!r2.equals(e2) && !r2.equals(n2))
            return true;
        }
        return false;
      }, oi.prototype.checkCollapse = function(t2, e2, n2) {
        if (t2.equals(n2))
          throw new $("found non-noded collapse at " + oi.fact.createLineString([t2, e2, n2]));
      }, oi.prototype.interfaces_ = function() {
        return [];
      }, oi.prototype.getClass = function() {
        return oi;
      }, si.fact.get = function() {
        return new _e();
      }, Object.defineProperties(oi, si);
      var ai = function() {
        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        if (this._originalPt = t2, this._pt = t2, this._scaleFactor = e2, this._li = n2, e2 <= 0)
          throw new m("Scale factor must be non-zero");
        1 !== e2 && (this._pt = new C(this.scale(t2.x), this.scale(t2.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);
      }, ui = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
      ai.prototype.intersectsScaled = function(t2, e2) {
        var n2 = Math.min(t2.x, e2.x), i2 = Math.max(t2.x, e2.x), r2 = Math.min(t2.y, e2.y), o2 = Math.max(t2.y, e2.y), s2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > o2;
        if (s2)
          return false;
        var a2 = this.intersectsToleranceSquare(t2, e2);
        return et.isTrue(!(s2 && a2), "Found bad envelope test"), a2;
      }, ai.prototype.initCorners = function(t2) {
        this._minx = t2.x - 0.5, this._maxx = t2.x + 0.5, this._miny = t2.y - 0.5, this._maxy = t2.y + 0.5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);
      }, ai.prototype.intersects = function(t2, e2) {
        return 1 === this._scaleFactor ? this.intersectsScaled(t2, e2) : (this.copyScaled(t2, this._p0Scaled), this.copyScaled(e2, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
      }, ai.prototype.scale = function(t2) {
        return Math.round(t2 * this._scaleFactor);
      }, ai.prototype.getCoordinate = function() {
        return this._originalPt;
      }, ai.prototype.copyScaled = function(t2, e2) {
        e2.x = this.scale(t2.x), e2.y = this.scale(t2.y);
      }, ai.prototype.getSafeEnvelope = function() {
        if (null === this._safeEnv) {
          var t2 = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
          this._safeEnv = new j(this._originalPt.x - t2, this._originalPt.x + t2, this._originalPt.y - t2, this._originalPt.y + t2);
        }
        return this._safeEnv;
      }, ai.prototype.intersectsPixelClosure = function(t2, e2) {
        return this._li.computeIntersection(t2, e2, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e2, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e2, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e2, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
      }, ai.prototype.intersectsToleranceSquare = function(t2, e2) {
        var n2 = false, i2 = false;
        return this._li.computeIntersection(t2, e2, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t2, e2, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t2, e2, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t2, e2, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t2.equals(this._pt) || !!e2.equals(this._pt))))));
      }, ai.prototype.addSnappedNode = function(t2, e2) {
        var n2 = t2.getCoordinate(e2), i2 = t2.getCoordinate(e2 + 1);
        return !!this.intersects(n2, i2) && (t2.addIntersection(this.getCoordinate(), e2), true);
      }, ai.prototype.interfaces_ = function() {
        return [];
      }, ai.prototype.getClass = function() {
        return ai;
      }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function() {
        return 0.75;
      }, Object.defineProperties(ai, ui);
      var li = function() {
        this.tempEnv1 = new j(), this.selectedSegment = new dn();
      };
      li.prototype.select = function() {
        if (1 === arguments.length)
          ;
        else if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          t2.getLineSegment(e2, this.selectedSegment), this.select(this.selectedSegment);
        }
      }, li.prototype.interfaces_ = function() {
        return [];
      }, li.prototype.getClass = function() {
        return li;
      };
      var ci = function() {
        this._index = null;
        var t2 = arguments[0];
        this._index = t2;
      }, pi = { HotPixelSnapAction: { configurable: true } };
      ci.prototype.snap = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.snap(t2, null, -1);
        }
        if (3 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = e2.getSafeEnvelope(), o2 = new hi(e2, n2, i2);
          return this._index.query(r2, { interfaces_: function() {
            return [Ke];
          }, visitItem: function(t3) {
            t3.select(r2, o2);
          } }), o2.isNodeAdded();
        }
      }, ci.prototype.interfaces_ = function() {
        return [];
      }, ci.prototype.getClass = function() {
        return ci;
      }, pi.HotPixelSnapAction.get = function() {
        return hi;
      }, Object.defineProperties(ci, pi);
      var hi = function(t2) {
        function e2() {
          t2.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._hotPixel = e3, this._parentEdge = n2, this._hotPixelVertexIndex = i2;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.isNodeAdded = function() {
          return this._isNodeAdded;
        }, e2.prototype.select = function() {
          if (2 !== arguments.length)
            return t2.prototype.select.apply(this, arguments);
          var e3 = arguments[0], n2 = arguments[1], i2 = e3.getContext();
          if (null !== this._parentEdge && i2 === this._parentEdge && n2 === this._hotPixelVertexIndex)
            return null;
          this._isNodeAdded = this._hotPixel.addSnappedNode(i2, n2);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(li), fi = function() {
        this._li = null, this._interiorIntersections = null;
        var t2 = arguments[0];
        this._li = t2, this._interiorIntersections = new Nt();
      };
      fi.prototype.processIntersections = function(t2, e2, n2, i2) {
        if (t2 === n2 && e2 === i2)
          return null;
        var r2 = t2.getCoordinates()[e2], o2 = t2.getCoordinates()[e2 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
        if (this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
          for (var u2 = 0; u2 < this._li.getIntersectionNum(); u2++)
            this._interiorIntersections.add(this._li.getIntersection(u2));
          t2.addIntersections(this._li, e2, 0), n2.addIntersections(this._li, i2, 1);
        }
      }, fi.prototype.isDone = function() {
        return false;
      }, fi.prototype.getInteriorIntersections = function() {
        return this._interiorIntersections;
      }, fi.prototype.interfaces_ = function() {
        return [Wn];
      }, fi.prototype.getClass = function() {
        return fi;
      };
      var gi = function() {
        this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
        var t2 = arguments[0];
        this._pm = t2, this._li = new rt(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
      };
      gi.prototype.checkCorrectness = function(t2) {
        var e2 = gn.getNodedSubstrings(t2), n2 = new oi(e2);
        try {
          n2.checkValid();
        } catch (t3) {
          if (!(t3 instanceof z))
            throw t3;
          t3.printStackTrace();
        }
      }, gi.prototype.getNodedSubstrings = function() {
        return gn.getNodedSubstrings(this._nodedSegStrings);
      }, gi.prototype.snapRound = function(t2, e2) {
        var n2 = this.findInteriorIntersections(t2, e2);
        this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
      }, gi.prototype.findInteriorIntersections = function(t2, e2) {
        var n2 = new fi(e2);
        return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
      }, gi.prototype.computeVertexSnaps = function() {
        if (T(arguments[0], It))
          for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
            var e2 = t2.next();
            this.computeVertexSnaps(e2);
          }
        else if (arguments[0] instanceof gn)
          for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) {
            var o2 = new ai(i2[r2], this._scaleFactor, this._li);
            this._pointSnapper.snap(o2, n2, r2) && n2.addIntersection(i2[r2], r2);
          }
      }, gi.prototype.computeNodes = function(t2) {
        this._nodedSegStrings = t2, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t2, this._li);
      }, gi.prototype.computeIntersectionSnaps = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i2 = new ai(n2, this._scaleFactor, this._li);
          this._pointSnapper.snap(i2);
        }
      }, gi.prototype.interfaces_ = function() {
        return [In];
      }, gi.prototype.getClass = function() {
        return gi;
      };
      var di = function() {
        if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this._argGeom = t2;
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this._argGeom = e2, this._bufParams = n2;
        }
      }, yi = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
      di.prototype.bufferFixedPrecision = function(t2) {
        var e2 = new ri(new gi(new fe(1)), t2.getScale()), n2 = new ii(this._bufParams);
        n2.setWorkingPrecisionModel(t2), n2.setNoder(e2), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
      }, di.prototype.bufferReducedPrecision = function() {
        var t2 = this;
        if (0 === arguments.length) {
          for (var e2 = di.MAX_PRECISION_DIGITS; e2 >= 0; e2--) {
            try {
              t2.bufferReducedPrecision(e2);
            } catch (e3) {
              if (!(e3 instanceof we))
                throw e3;
              t2._saveException = e3;
            }
            if (null !== t2._resultGeometry)
              return null;
          }
          throw this._saveException;
        }
        if (1 === arguments.length) {
          var n2 = arguments[0], i2 = di.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new fe(i2);
          this.bufferFixedPrecision(r2);
        }
      }, di.prototype.computeGeometry = function() {
        if (this.bufferOriginalPrecision(), null !== this._resultGeometry)
          return null;
        var t2 = this._argGeom.getFactory().getPrecisionModel();
        t2.getType() === fe.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
      }, di.prototype.setQuadrantSegments = function(t2) {
        this._bufParams.setQuadrantSegments(t2);
      }, di.prototype.bufferOriginalPrecision = function() {
        try {
          var t2 = new ii(this._bufParams);
          this._resultGeometry = t2.buffer(this._argGeom, this._distance);
        } catch (t3) {
          if (!(t3 instanceof $))
            throw t3;
          this._saveException = t3;
        }
      }, di.prototype.getResultGeometry = function(t2) {
        return this._distance = t2, this.computeGeometry(), this._resultGeometry;
      }, di.prototype.setEndCapStyle = function(t2) {
        this._bufParams.setEndCapStyle(t2);
      }, di.prototype.interfaces_ = function() {
        return [];
      }, di.prototype.getClass = function() {
        return di;
      }, di.bufferOp = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return new di(t2).getResultGeometry(e2);
        }
        if (3 === arguments.length) {
          if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new di(n2);
            o2.setQuadrantSegments(r2);
            return o2.getResultGeometry(i2);
          }
          if (arguments[2] instanceof Cn && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
            var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
            return new di(s2, u2).getResultGeometry(a2);
          }
        } else if (4 === arguments.length) {
          var l2 = arguments[0], c2 = arguments[1], p2 = arguments[2], h2 = arguments[3], f2 = new di(l2);
          f2.setQuadrantSegments(p2), f2.setEndCapStyle(h2);
          return f2.getResultGeometry(c2);
        }
      }, di.precisionScaleFactor = function(t2, e2, n2) {
        var i2 = t2.getEnvelopeInternal(), r2 = R.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e2 > 0 ? e2 : 0), o2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
        return Math.pow(10, o2);
      }, yi.CAP_ROUND.get = function() {
        return Cn.CAP_ROUND;
      }, yi.CAP_BUTT.get = function() {
        return Cn.CAP_FLAT;
      }, yi.CAP_FLAT.get = function() {
        return Cn.CAP_FLAT;
      }, yi.CAP_SQUARE.get = function() {
        return Cn.CAP_SQUARE;
      }, yi.MAX_PRECISION_DIGITS.get = function() {
        return 12;
      }, Object.defineProperties(di, yi);
      var _i = function() {
        this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
      };
      _i.prototype.getCoordinates = function() {
        return this._pt;
      }, _i.prototype.getCoordinate = function(t2) {
        return this._pt[t2];
      }, _i.prototype.setMinimum = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setMinimum(t2._pt[0], t2._pt[1]);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (this._isNull)
            return this.initialize(e2, n2), null;
          var i2 = e2.distance(n2);
          i2 < this._distance && this.initialize(e2, n2, i2);
        }
      }, _i.prototype.initialize = function() {
        if (0 === arguments.length)
          this._isNull = true;
        else if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e2), this._distance = t2.distance(e2), this._isNull = false;
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
          this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
        }
      }, _i.prototype.getDistance = function() {
        return this._distance;
      }, _i.prototype.setMaximum = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setMaximum(t2._pt[0], t2._pt[1]);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (this._isNull)
            return this.initialize(e2, n2), null;
          var i2 = e2.distance(n2);
          i2 > this._distance && this.initialize(e2, n2, i2);
        }
      }, _i.prototype.interfaces_ = function() {
        return [];
      }, _i.prototype.getClass = function() {
        return _i;
      };
      var mi = function() {
      };
      mi.prototype.interfaces_ = function() {
        return [];
      }, mi.prototype.getClass = function() {
        return mi;
      }, mi.computeDistance = function() {
        if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C)
          for (var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = t2.getCoordinates(), r2 = new dn(), o2 = 0; o2 < i2.length - 1; o2++) {
            r2.setCoordinates(i2[o2], i2[o2 + 1]);
            var s2 = r2.closestPoint(e2);
            n2.setMinimum(s2, e2);
          }
        else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {
          var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
          mi.computeDistance(a2.getExteriorRing(), u2, l2);
          for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
            mi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
        } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {
          var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
          if (p2 instanceof Kt)
            mi.computeDistance(p2, h2, f2);
          else if (p2 instanceof $t)
            mi.computeDistance(p2, h2, f2);
          else if (p2 instanceof zt)
            for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
              var y2 = g2.getGeometryN(d2);
              mi.computeDistance(y2, h2, f2);
            }
          else
            f2.setMinimum(p2.getCoordinate(), h2);
        } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {
          var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
          v2.setMinimum(I2, m2);
        }
      };
      var vi = function(t2) {
        this._maxPtDist = new _i(), this._inputGeom = t2 || null;
      }, Ii = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
      vi.prototype.computeMaxMidpointDistance = function(t2) {
        var e2 = new xi(this._inputGeom);
        t2.apply(e2), this._maxPtDist.setMaximum(e2.getMaxPointDistance());
      }, vi.prototype.computeMaxVertexDistance = function(t2) {
        var e2 = new Ei(this._inputGeom);
        t2.apply(e2), this._maxPtDist.setMaximum(e2.getMaxPointDistance());
      }, vi.prototype.findDistance = function(t2) {
        return this.computeMaxVertexDistance(t2), this.computeMaxMidpointDistance(t2), this._maxPtDist.getDistance();
      }, vi.prototype.getDistancePoints = function() {
        return this._maxPtDist;
      }, vi.prototype.interfaces_ = function() {
        return [];
      }, vi.prototype.getClass = function() {
        return vi;
      }, Ii.MaxPointDistanceFilter.get = function() {
        return Ei;
      }, Ii.MaxMidpointDistanceFilter.get = function() {
        return xi;
      }, Object.defineProperties(vi, Ii);
      var Ei = function(t2) {
        this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
      };
      Ei.prototype.filter = function(t2) {
        this._minPtDist.initialize(), mi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
      }, Ei.prototype.getMaxPointDistance = function() {
        return this._maxPtDist;
      }, Ei.prototype.interfaces_ = function() {
        return [ft];
      }, Ei.prototype.getClass = function() {
        return Ei;
      };
      var xi = function(t2) {
        this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
      };
      xi.prototype.filter = function(t2, e2) {
        if (0 === e2)
          return null;
        var n2 = t2.getCoordinate(e2 - 1), i2 = t2.getCoordinate(e2), r2 = new C((n2.x + i2.x) / 2, (n2.y + i2.y) / 2);
        this._minPtDist.initialize(), mi.computeDistance(this._geom, r2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
      }, xi.prototype.isDone = function() {
        return false;
      }, xi.prototype.isGeometryChanged = function() {
        return false;
      }, xi.prototype.getMaxPointDistance = function() {
        return this._maxPtDist;
      }, xi.prototype.interfaces_ = function() {
        return [Ut];
      }, xi.prototype.getClass = function() {
        return xi;
      };
      var Ni = function(t2) {
        this._comps = t2 || null;
      };
      Ni.prototype.filter = function(t2) {
        t2 instanceof $t && this._comps.add(t2);
      }, Ni.prototype.interfaces_ = function() {
        return [Vt];
      }, Ni.prototype.getClass = function() {
        return Ni;
      }, Ni.getPolygons = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Ni.getPolygons(t2, new Nt());
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return e2 instanceof $t ? n2.add(e2) : e2 instanceof zt && e2.apply(new Ni(n2)), n2;
        }
      };
      var Ci = function() {
        if (this._lines = null, this._isForcedToLineString = false, 1 === arguments.length) {
          var t2 = arguments[0];
          this._lines = t2;
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this._lines = e2, this._isForcedToLineString = n2;
        }
      };
      Ci.prototype.filter = function(t2) {
        if (this._isForcedToLineString && t2 instanceof ee) {
          var e2 = t2.getFactory().createLineString(t2.getCoordinateSequence());
          return this._lines.add(e2), null;
        }
        t2 instanceof Kt && this._lines.add(t2);
      }, Ci.prototype.setForceToLineString = function(t2) {
        this._isForcedToLineString = t2;
      }, Ci.prototype.interfaces_ = function() {
        return [lt];
      }, Ci.prototype.getClass = function() {
        return Ci;
      }, Ci.getGeometry = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return t2.getFactory().buildGeometry(Ci.getLines(t2));
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return e2.getFactory().buildGeometry(Ci.getLines(e2, n2));
        }
      }, Ci.getLines = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return Ci.getLines(t2, false);
        }
        if (2 === arguments.length) {
          if (T(arguments[0], It) && T(arguments[1], It)) {
            for (var e2 = arguments[0], n2 = arguments[1], i2 = e2.iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              Ci.getLines(r2, n2);
            }
            return n2;
          }
          if (arguments[0] instanceof ct && "boolean" == typeof arguments[1]) {
            var o2 = arguments[0], s2 = arguments[1], a2 = new Nt();
            return o2.apply(new Ci(a2, s2)), a2;
          }
          if (arguments[0] instanceof ct && T(arguments[1], It)) {
            var u2 = arguments[0], l2 = arguments[1];
            return u2 instanceof Kt ? l2.add(u2) : u2.apply(new Ci(l2)), l2;
          }
        } else if (3 === arguments.length) {
          if ("boolean" == typeof arguments[2] && T(arguments[0], It) && T(arguments[1], It)) {
            for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = c2.iterator(); f2.hasNext(); ) {
              var g2 = f2.next();
              Ci.getLines(g2, p2, h2);
            }
            return p2;
          }
          if ("boolean" == typeof arguments[2] && arguments[0] instanceof ct && T(arguments[1], It)) {
            var d2 = arguments[0], y2 = arguments[1], _2 = arguments[2];
            return d2.apply(new Ci(y2, _2)), y2;
          }
        }
      };
      var Si = function() {
        if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length)
          ;
        else if (1 === arguments.length) {
          var t2 = arguments[0];
          if (null === t2)
            throw new m("Rule must be non-null");
          this._boundaryRule = t2;
        }
      };
      Si.prototype.locateInternal = function() {
        if (arguments[0] instanceof C && arguments[1] instanceof $t) {
          var t2 = arguments[0], e2 = arguments[1];
          if (e2.isEmpty())
            return w.EXTERIOR;
          var n2 = e2.getExteriorRing(), i2 = this.locateInPolygonRing(t2, n2);
          if (i2 === w.EXTERIOR)
            return w.EXTERIOR;
          if (i2 === w.BOUNDARY)
            return w.BOUNDARY;
          for (var r2 = 0; r2 < e2.getNumInteriorRing(); r2++) {
            var o2 = e2.getInteriorRingN(r2), s2 = this.locateInPolygonRing(t2, o2);
            if (s2 === w.INTERIOR)
              return w.EXTERIOR;
            if (s2 === w.BOUNDARY)
              return w.BOUNDARY;
          }
          return w.INTERIOR;
        }
        if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
          var a2 = arguments[0], u2 = arguments[1];
          if (!u2.getEnvelopeInternal().intersects(a2))
            return w.EXTERIOR;
          var l2 = u2.getCoordinates();
          return u2.isClosed() || !a2.equals(l2[0]) && !a2.equals(l2[l2.length - 1]) ? at.isOnLine(a2, l2) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;
        }
        if (arguments[0] instanceof C && arguments[1] instanceof Qt) {
          var c2 = arguments[0];
          return arguments[1].getCoordinate().equals2D(c2) ? w.INTERIOR : w.EXTERIOR;
        }
      }, Si.prototype.locateInPolygonRing = function(t2, e2) {
        return e2.getEnvelopeInternal().intersects(t2) ? at.locatePointInRing(t2, e2.getCoordinates()) : w.EXTERIOR;
      }, Si.prototype.intersects = function(t2, e2) {
        return this.locate(t2, e2) !== w.EXTERIOR;
      }, Si.prototype.updateLocationInfo = function(t2) {
        t2 === w.INTERIOR && (this._isIn = true), t2 === w.BOUNDARY && this._numBoundaries++;
      }, Si.prototype.computeLocation = function(t2, e2) {
        if (e2 instanceof Qt && this.updateLocationInfo(this.locateInternal(t2, e2)), e2 instanceof Kt)
          this.updateLocationInfo(this.locateInternal(t2, e2));
        else if (e2 instanceof $t)
          this.updateLocationInfo(this.locateInternal(t2, e2));
        else if (e2 instanceof Xt)
          for (var n2 = e2, i2 = 0; i2 < n2.getNumGeometries(); i2++) {
            var r2 = n2.getGeometryN(i2);
            this.updateLocationInfo(this.locateInternal(t2, r2));
          }
        else if (e2 instanceof ne)
          for (var o2 = e2, s2 = 0; s2 < o2.getNumGeometries(); s2++) {
            var a2 = o2.getGeometryN(s2);
            this.updateLocationInfo(this.locateInternal(t2, a2));
          }
        else if (e2 instanceof zt)
          for (var u2 = new Un(e2); u2.hasNext(); ) {
            var l2 = u2.next();
            l2 !== e2 && this.computeLocation(t2, l2);
          }
      }, Si.prototype.locate = function(t2, e2) {
        return e2.isEmpty() ? w.EXTERIOR : e2 instanceof Kt ? this.locateInternal(t2, e2) : e2 instanceof $t ? this.locateInternal(t2, e2) : (this._isIn = false, this._numBoundaries = 0, this.computeLocation(t2, e2), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);
      }, Si.prototype.interfaces_ = function() {
        return [];
      }, Si.prototype.getClass = function() {
        return Si;
      };
      var Li = function t2() {
        if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          t2.call(this, e2, t2.INSIDE_AREA, n2);
        } else if (3 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
          this._component = i2, this._segIndex = r2, this._pt = o2;
        }
      }, bi = { INSIDE_AREA: { configurable: true } };
      Li.prototype.isInsideArea = function() {
        return this._segIndex === Li.INSIDE_AREA;
      }, Li.prototype.getCoordinate = function() {
        return this._pt;
      }, Li.prototype.getGeometryComponent = function() {
        return this._component;
      }, Li.prototype.getSegmentIndex = function() {
        return this._segIndex;
      }, Li.prototype.interfaces_ = function() {
        return [];
      }, Li.prototype.getClass = function() {
        return Li;
      }, bi.INSIDE_AREA.get = function() {
        return -1;
      }, Object.defineProperties(Li, bi);
      var wi = function(t2) {
        this._pts = t2 || null;
      };
      wi.prototype.filter = function(t2) {
        t2 instanceof Qt && this._pts.add(t2);
      }, wi.prototype.interfaces_ = function() {
        return [Vt];
      }, wi.prototype.getClass = function() {
        return wi;
      }, wi.getPoints = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return t2 instanceof Qt ? $e.singletonList(t2) : wi.getPoints(t2, new Nt());
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return e2 instanceof Qt ? n2.add(e2) : e2 instanceof zt && e2.apply(new wi(n2)), n2;
        }
      };
      var Oi = function() {
        this._locations = null;
        var t2 = arguments[0];
        this._locations = t2;
      };
      Oi.prototype.filter = function(t2) {
        (t2 instanceof Qt || t2 instanceof Kt || t2 instanceof $t) && this._locations.add(new Li(t2, 0, t2.getCoordinate()));
      }, Oi.prototype.interfaces_ = function() {
        return [Vt];
      }, Oi.prototype.getClass = function() {
        return Oi;
      }, Oi.getLocations = function(t2) {
        var e2 = new Nt();
        return t2.apply(new Oi(e2)), e2;
      };
      var Ti = function() {
        if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this._geom = [t2, e2], this._terminateDistance = 0;
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
          this._geom = new Array(2).fill(null), this._geom[0] = n2, this._geom[1] = i2, this._terminateDistance = r2;
        }
      };
      Ti.prototype.computeContainmentDistance = function() {
        if (0 === arguments.length) {
          var t2 = new Array(2).fill(null);
          if (this.computeContainmentDistance(0, t2), this._minDistance <= this._terminateDistance)
            return null;
          this.computeContainmentDistance(1, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = 1 - e2, r2 = Ni.getPolygons(this._geom[e2]);
          if (r2.size() > 0) {
            var o2 = Oi.getLocations(this._geom[i2]);
            if (this.computeContainmentDistance(o2, r2, n2), this._minDistance <= this._terminateDistance)
              return this._minDistanceLocation[i2] = n2[0], this._minDistanceLocation[e2] = n2[1], null;
          }
        } else if (3 === arguments.length) {
          if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {
            for (var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2], l2 = 0; l2 < s2.size(); l2++)
              for (var c2 = s2.get(l2), p2 = 0; p2 < a2.size(); p2++)
                if (this.computeContainmentDistance(c2, a2.get(p2), u2), this._minDistance <= this._terminateDistance)
                  return null;
          } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {
            var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = h2.getCoordinate();
            if (w.EXTERIOR !== this._ptLocator.locate(d2, f2))
              return this._minDistance = 0, g2[0] = h2, g2[1] = new Li(f2, d2), null;
          }
        }
      }, Ti.prototype.computeMinDistanceLinesPoints = function(t2, e2, n2) {
        for (var i2 = 0; i2 < t2.size(); i2++)
          for (var r2 = t2.get(i2), o2 = 0; o2 < e2.size(); o2++) {
            var s2 = e2.get(o2);
            if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
              return null;
          }
      }, Ti.prototype.computeFacetDistance = function() {
        var t2 = new Array(2).fill(null), e2 = Ci.getLines(this._geom[0]), n2 = Ci.getLines(this._geom[1]), i2 = wi.getPoints(this._geom[0]), r2 = wi.getPoints(this._geom[1]);
        return this.computeMinDistanceLines(e2, n2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(e2, r2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(n2, i2, t2), this.updateMinDistance(t2, true), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistancePoints(i2, r2, t2), void this.updateMinDistance(t2, false))));
      }, Ti.prototype.nearestLocations = function() {
        return this.computeMinDistance(), this._minDistanceLocation;
      }, Ti.prototype.updateMinDistance = function(t2, e2) {
        if (null === t2[0])
          return null;
        e2 ? (this._minDistanceLocation[0] = t2[1], this._minDistanceLocation[1] = t2[0]) : (this._minDistanceLocation[0] = t2[0], this._minDistanceLocation[1] = t2[1]);
      }, Ti.prototype.nearestPoints = function() {
        this.computeMinDistance();
        return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
      }, Ti.prototype.computeMinDistance = function() {
        if (0 === arguments.length) {
          if (null !== this._minDistanceLocation)
            return null;
          if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)
            return null;
          this.computeFacetDistance();
        } else if (3 === arguments.length) {
          if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {
            var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
            if (t2.getEnvelopeInternal().distance(e2.getEnvelopeInternal()) > this._minDistance)
              return null;
            for (var i2 = t2.getCoordinates(), r2 = e2.getCoordinate(), o2 = 0; o2 < i2.length - 1; o2++) {
              var s2 = at.distancePointLine(r2, i2[o2], i2[o2 + 1]);
              if (s2 < this._minDistance) {
                this._minDistance = s2;
                var a2 = new dn(i2[o2], i2[o2 + 1]).closestPoint(r2);
                n2[0] = new Li(t2, o2, a2), n2[1] = new Li(e2, 0, r2);
              }
              if (this._minDistance <= this._terminateDistance)
                return null;
            }
          } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
            if (u2.getEnvelopeInternal().distance(l2.getEnvelopeInternal()) > this._minDistance)
              return null;
            for (var p2 = u2.getCoordinates(), h2 = l2.getCoordinates(), f2 = 0; f2 < p2.length - 1; f2++)
              for (var g2 = 0; g2 < h2.length - 1; g2++) {
                var d2 = at.distanceLineLine(p2[f2], p2[f2 + 1], h2[g2], h2[g2 + 1]);
                if (d2 < this._minDistance) {
                  this._minDistance = d2;
                  var y2 = new dn(p2[f2], p2[f2 + 1]), _2 = new dn(h2[g2], h2[g2 + 1]), m2 = y2.closestPoints(_2);
                  c2[0] = new Li(u2, f2, m2[0]), c2[1] = new Li(l2, g2, m2[1]);
                }
                if (this._minDistance <= this._terminateDistance)
                  return null;
              }
          }
        }
      }, Ti.prototype.computeMinDistancePoints = function(t2, e2, n2) {
        for (var i2 = 0; i2 < t2.size(); i2++)
          for (var r2 = t2.get(i2), o2 = 0; o2 < e2.size(); o2++) {
            var s2 = e2.get(o2), a2 = r2.getCoordinate().distance(s2.getCoordinate());
            if (a2 < this._minDistance && (this._minDistance = a2, n2[0] = new Li(r2, 0, r2.getCoordinate()), n2[1] = new Li(s2, 0, s2.getCoordinate())), this._minDistance <= this._terminateDistance)
              return null;
          }
      }, Ti.prototype.distance = function() {
        if (null === this._geom[0] || null === this._geom[1])
          throw new m("null geometries are not supported");
        return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
      }, Ti.prototype.computeMinDistanceLines = function(t2, e2, n2) {
        for (var i2 = 0; i2 < t2.size(); i2++)
          for (var r2 = t2.get(i2), o2 = 0; o2 < e2.size(); o2++) {
            var s2 = e2.get(o2);
            if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
              return null;
          }
      }, Ti.prototype.interfaces_ = function() {
        return [];
      }, Ti.prototype.getClass = function() {
        return Ti;
      }, Ti.distance = function(t2, e2) {
        return new Ti(t2, e2).distance();
      }, Ti.isWithinDistance = function(t2, e2, n2) {
        return new Ti(t2, e2, n2).distance() <= n2;
      }, Ti.nearestPoints = function(t2, e2) {
        return new Ti(t2, e2).nearestPoints();
      };
      var Ri = function() {
        this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
      };
      Ri.prototype.getCoordinates = function() {
        return this._pt;
      }, Ri.prototype.getCoordinate = function(t2) {
        return this._pt[t2];
      }, Ri.prototype.setMinimum = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setMinimum(t2._pt[0], t2._pt[1]);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (this._isNull)
            return this.initialize(e2, n2), null;
          var i2 = e2.distance(n2);
          i2 < this._distance && this.initialize(e2, n2, i2);
        }
      }, Ri.prototype.initialize = function() {
        if (0 === arguments.length)
          this._isNull = true;
        else if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e2), this._distance = t2.distance(e2), this._isNull = false;
        } else if (3 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
          this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
        }
      }, Ri.prototype.toString = function() {
        return Z.toLineString(this._pt[0], this._pt[1]);
      }, Ri.prototype.getDistance = function() {
        return this._distance;
      }, Ri.prototype.setMaximum = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          this.setMaximum(t2._pt[0], t2._pt[1]);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          if (this._isNull)
            return this.initialize(e2, n2), null;
          var i2 = e2.distance(n2);
          i2 > this._distance && this.initialize(e2, n2, i2);
        }
      }, Ri.prototype.interfaces_ = function() {
        return [];
      }, Ri.prototype.getClass = function() {
        return Ri;
      };
      var Pi = function() {
      };
      Pi.prototype.interfaces_ = function() {
        return [];
      }, Pi.prototype.getClass = function() {
        return Pi;
      }, Pi.computeDistance = function() {
        if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C)
          for (var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = new dn(), r2 = t2.getCoordinates(), o2 = 0; o2 < r2.length - 1; o2++) {
            i2.setCoordinates(r2[o2], r2[o2 + 1]);
            var s2 = i2.closestPoint(e2);
            n2.setMinimum(s2, e2);
          }
        else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {
          var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
          Pi.computeDistance(a2.getExteriorRing(), u2, l2);
          for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
            Pi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
        } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {
          var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
          if (p2 instanceof Kt)
            Pi.computeDistance(p2, h2, f2);
          else if (p2 instanceof $t)
            Pi.computeDistance(p2, h2, f2);
          else if (p2 instanceof zt)
            for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
              var y2 = g2.getGeometryN(d2);
              Pi.computeDistance(y2, h2, f2);
            }
          else
            f2.setMinimum(p2.getCoordinate(), h2);
        } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {
          var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
          v2.setMinimum(I2, m2);
        }
      };
      var Di = function() {
        this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;
        var t2 = arguments[0], e2 = arguments[1];
        this._g0 = t2, this._g1 = e2;
      }, Mi = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
      Di.prototype.getCoordinates = function() {
        return this._ptDist.getCoordinates();
      }, Di.prototype.setDensifyFraction = function(t2) {
        if (t2 > 1 || t2 <= 0)
          throw new m("Fraction is not in range (0.0 - 1.0]");
        this._densifyFrac = t2;
      }, Di.prototype.compute = function(t2, e2) {
        this.computeOrientedDistance(t2, e2, this._ptDist), this.computeOrientedDistance(e2, t2, this._ptDist);
      }, Di.prototype.distance = function() {
        return this.compute(this._g0, this._g1), this._ptDist.getDistance();
      }, Di.prototype.computeOrientedDistance = function(t2, e2, n2) {
        var i2 = new Ai(e2);
        if (t2.apply(i2), n2.setMaximum(i2.getMaxPointDistance()), this._densifyFrac > 0) {
          var r2 = new Fi(e2, this._densifyFrac);
          t2.apply(r2), n2.setMaximum(r2.getMaxPointDistance());
        }
      }, Di.prototype.orientedDistance = function() {
        return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
      }, Di.prototype.interfaces_ = function() {
        return [];
      }, Di.prototype.getClass = function() {
        return Di;
      }, Di.distance = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1];
          return new Di(t2, e2).distance();
        }
        if (3 === arguments.length) {
          var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new Di(n2, i2);
          return o2.setDensifyFraction(r2), o2.distance();
        }
      }, Mi.MaxPointDistanceFilter.get = function() {
        return Ai;
      }, Mi.MaxDensifiedByFractionDistanceFilter.get = function() {
        return Fi;
      }, Object.defineProperties(Di, Mi);
      var Ai = function() {
        this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;
        var t2 = arguments[0];
        this._geom = t2;
      };
      Ai.prototype.filter = function(t2) {
        this._minPtDist.initialize(), Pi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
      }, Ai.prototype.getMaxPointDistance = function() {
        return this._maxPtDist;
      }, Ai.prototype.interfaces_ = function() {
        return [ft];
      }, Ai.prototype.getClass = function() {
        return Ai;
      };
      var Fi = function() {
        this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;
        var t2 = arguments[0], e2 = arguments[1];
        this._geom = t2, this._numSubSegs = Math.trunc(Math.round(1 / e2));
      };
      Fi.prototype.filter = function(t2, e2) {
        if (0 === e2)
          return null;
        for (var n2 = t2.getCoordinate(e2 - 1), i2 = t2.getCoordinate(e2), r2 = (i2.x - n2.x) / this._numSubSegs, o2 = (i2.y - n2.y) / this._numSubSegs, s2 = 0; s2 < this._numSubSegs; s2++) {
          var a2 = n2.x + s2 * r2, u2 = n2.y + s2 * o2, l2 = new C(a2, u2);
          this._minPtDist.initialize(), Pi.computeDistance(this._geom, l2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }
      }, Fi.prototype.isDone = function() {
        return false;
      }, Fi.prototype.isGeometryChanged = function() {
        return false;
      }, Fi.prototype.getMaxPointDistance = function() {
        return this._maxPtDist;
      }, Fi.prototype.interfaces_ = function() {
        return [Ut];
      }, Fi.prototype.getClass = function() {
        return Fi;
      };
      var Gi = function(t2, e2, n2) {
        this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = true, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._bufDistance = e2 || null, this._result = n2 || null;
      }, qi = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
      Gi.prototype.checkMaximumDistance = function(t2, e2, n2) {
        var i2 = new Di(e2, t2);
        if (i2.setDensifyFraction(0.25), this._maxDistanceFound = i2.orientedDistance(), this._maxDistanceFound > n2) {
          this._isValid = false;
          var r2 = i2.getCoordinates();
          this._errorLocation = r2[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + ")";
        }
      }, Gi.prototype.isValid = function() {
        var t2 = Math.abs(this._bufDistance), e2 = Gi.MAX_DISTANCE_DIFF_FRAC * t2;
        return this._minValidDistance = t2 - e2, this._maxValidDistance = t2 + e2, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
      }, Gi.prototype.checkNegativeValid = function() {
        if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt))
          return null;
        var t2 = this.getPolygonLines(this._input);
        if (this.checkMinimumDistance(t2, this._result, this._minValidDistance), !this._isValid)
          return null;
        this.checkMaximumDistance(t2, this._result, this._maxValidDistance);
      }, Gi.prototype.getErrorIndicator = function() {
        return this._errorIndicator;
      }, Gi.prototype.checkMinimumDistance = function(t2, e2, n2) {
        var i2 = new Ti(t2, e2, n2);
        if (this._minDistanceFound = i2.distance(), this._minDistanceFound < n2) {
          this._isValid = false;
          var r2 = i2.nearestPoints();
          this._errorLocation = i2.nearestPoints()[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + " )";
        }
      }, Gi.prototype.checkPositiveValid = function() {
        var t2 = this._result.getBoundary();
        if (this.checkMinimumDistance(this._input, t2, this._minValidDistance), !this._isValid)
          return null;
        this.checkMaximumDistance(this._input, t2, this._maxValidDistance);
      }, Gi.prototype.getErrorLocation = function() {
        return this._errorLocation;
      }, Gi.prototype.getPolygonLines = function(t2) {
        for (var e2 = new Nt(), n2 = new Ci(e2), i2 = Ni.getPolygons(t2).iterator(); i2.hasNext(); ) {
          i2.next().apply(n2);
        }
        return t2.getFactory().buildGeometry(e2);
      }, Gi.prototype.getErrorMessage = function() {
        return this._errMsg;
      }, Gi.prototype.interfaces_ = function() {
        return [];
      }, Gi.prototype.getClass = function() {
        return Gi;
      }, qi.VERBOSE.get = function() {
        return false;
      }, qi.MAX_DISTANCE_DIFF_FRAC.get = function() {
        return 0.012;
      }, Object.defineProperties(Gi, qi);
      var Bi = function(t2, e2, n2) {
        this._isValid = true, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._distance = e2 || null, this._result = n2 || null;
      }, Vi = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
      Bi.prototype.isValid = function() {
        return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
      }, Bi.prototype.checkEnvelope = function() {
        if (this._distance < 0)
          return null;
        var t2 = this._distance * Bi.MAX_ENV_DIFF_FRAC;
        0 === t2 && (t2 = 1e-3);
        var e2 = new j(this._input.getEnvelopeInternal());
        e2.expandBy(this._distance);
        var n2 = new j(this._result.getEnvelopeInternal());
        n2.expandBy(t2), n2.contains(e2) || (this._isValid = false, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n2)), this.report("Envelope");
      }, Bi.prototype.checkDistance = function() {
        var t2 = new Gi(this._input, this._distance, this._result);
        t2.isValid() || (this._isValid = false, this._errorMsg = t2.getErrorMessage(), this._errorLocation = t2.getErrorLocation(), this._errorIndicator = t2.getErrorIndicator()), this.report("Distance");
      }, Bi.prototype.checkArea = function() {
        var t2 = this._input.getArea(), e2 = this._result.getArea();
        this._distance > 0 && t2 > e2 && (this._isValid = false, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t2 < e2 && (this._isValid = false, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
      }, Bi.prototype.checkPolygonal = function() {
        this._result instanceof $t || this._result instanceof ne || (this._isValid = false), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
      }, Bi.prototype.getErrorIndicator = function() {
        return this._errorIndicator;
      }, Bi.prototype.getErrorLocation = function() {
        return this._errorLocation;
      }, Bi.prototype.checkExpectedEmpty = function() {
        return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = false, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
      }, Bi.prototype.report = function(t2) {
        if (!Bi.VERBOSE)
          return null;
        Y.out.println("Check " + t2 + ": " + (this._isValid ? "passed" : "FAILED"));
      }, Bi.prototype.getErrorMessage = function() {
        return this._errorMsg;
      }, Bi.prototype.interfaces_ = function() {
        return [];
      }, Bi.prototype.getClass = function() {
        return Bi;
      }, Bi.isValidMsg = function(t2, e2, n2) {
        var i2 = new Bi(t2, e2, n2);
        return i2.isValid() ? null : i2.getErrorMessage();
      }, Bi.isValid = function(t2, e2, n2) {
        return !!new Bi(t2, e2, n2).isValid();
      }, Vi.VERBOSE.get = function() {
        return false;
      }, Vi.MAX_ENV_DIFF_FRAC.get = function() {
        return 0.012;
      }, Object.defineProperties(Bi, Vi);
      var Ui = function() {
        this._pts = null, this._data = null;
        var t2 = arguments[0], e2 = arguments[1];
        this._pts = t2, this._data = e2;
      };
      Ui.prototype.getCoordinates = function() {
        return this._pts;
      }, Ui.prototype.size = function() {
        return this._pts.length;
      }, Ui.prototype.getCoordinate = function(t2) {
        return this._pts[t2];
      }, Ui.prototype.isClosed = function() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
      }, Ui.prototype.getSegmentOctant = function(t2) {
        return t2 === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
      }, Ui.prototype.setData = function(t2) {
        this._data = t2;
      }, Ui.prototype.getData = function() {
        return this._data;
      }, Ui.prototype.toString = function() {
        return Z.toLineString(new ue(this._pts));
      }, Ui.prototype.interfaces_ = function() {
        return [hn];
      }, Ui.prototype.getClass = function() {
        return Ui;
      };
      var zi = function() {
        this._findAllIntersections = false, this._isCheckEndSegmentsOnly = false, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = true;
        var t2 = arguments[0];
        this._li = t2, this._interiorIntersection = null;
      };
      zi.prototype.getInteriorIntersection = function() {
        return this._interiorIntersection;
      }, zi.prototype.setCheckEndSegmentsOnly = function(t2) {
        this._isCheckEndSegmentsOnly = t2;
      }, zi.prototype.getIntersectionSegments = function() {
        return this._intSegments;
      }, zi.prototype.count = function() {
        return this._intersectionCount;
      }, zi.prototype.getIntersections = function() {
        return this._intersections;
      }, zi.prototype.setFindAllIntersections = function(t2) {
        this._findAllIntersections = t2;
      }, zi.prototype.setKeepIntersections = function(t2) {
        this._keepIntersections = t2;
      }, zi.prototype.processIntersections = function(t2, e2, n2, i2) {
        if (!this._findAllIntersections && this.hasIntersection())
          return null;
        if (t2 === n2 && e2 === i2)
          return null;
        if (this._isCheckEndSegmentsOnly) {
          if (!(this.isEndSegment(t2, e2) || this.isEndSegment(n2, i2)))
            return null;
        }
        var r2 = t2.getCoordinates()[e2], o2 = t2.getCoordinates()[e2 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
        this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r2, this._intSegments[1] = o2, this._intSegments[2] = s2, this._intSegments[3] = a2, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
      }, zi.prototype.isEndSegment = function(t2, e2) {
        return 0 === e2 || e2 >= t2.size() - 2;
      }, zi.prototype.hasIntersection = function() {
        return null !== this._interiorIntersection;
      }, zi.prototype.isDone = function() {
        return !this._findAllIntersections && null !== this._interiorIntersection;
      }, zi.prototype.interfaces_ = function() {
        return [Wn];
      }, zi.prototype.getClass = function() {
        return zi;
      }, zi.createAllIntersectionsFinder = function(t2) {
        var e2 = new zi(t2);
        return e2.setFindAllIntersections(true), e2;
      }, zi.createAnyIntersectionFinder = function(t2) {
        return new zi(t2);
      }, zi.createIntersectionCounter = function(t2) {
        var e2 = new zi(t2);
        return e2.setFindAllIntersections(true), e2.setKeepIntersections(false), e2;
      };
      var Xi = function() {
        this._li = new rt(), this._segStrings = null, this._findAllIntersections = false, this._segInt = null, this._isValid = true;
        var t2 = arguments[0];
        this._segStrings = t2;
      };
      Xi.prototype.execute = function() {
        if (null !== this._segInt)
          return null;
        this.checkInteriorIntersections();
      }, Xi.prototype.getIntersections = function() {
        return this._segInt.getIntersections();
      }, Xi.prototype.isValid = function() {
        return this.execute(), this._isValid;
      }, Xi.prototype.setFindAllIntersections = function(t2) {
        this._findAllIntersections = t2;
      }, Xi.prototype.checkInteriorIntersections = function() {
        this._isValid = true, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
        var t2 = new xn();
        if (t2.setSegmentIntersector(this._segInt), t2.computeNodes(this._segStrings), this._segInt.hasIntersection())
          return this._isValid = false, null;
      }, Xi.prototype.checkValid = function() {
        if (this.execute(), !this._isValid)
          throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());
      }, Xi.prototype.getErrorMessage = function() {
        if (this._isValid)
          return "no intersections found";
        var t2 = this._segInt.getIntersectionSegments();
        return "found non-noded intersection between " + Z.toLineString(t2[0], t2[1]) + " and " + Z.toLineString(t2[2], t2[3]);
      }, Xi.prototype.interfaces_ = function() {
        return [];
      }, Xi.prototype.getClass = function() {
        return Xi;
      }, Xi.computeIntersections = function(t2) {
        var e2 = new Xi(t2);
        return e2.setFindAllIntersections(true), e2.isValid(), e2.getIntersections();
      };
      var Yi = function t2() {
        this._nv = null;
        var e2 = arguments[0];
        this._nv = new Xi(t2.toSegmentStrings(e2));
      };
      Yi.prototype.checkValid = function() {
        this._nv.checkValid();
      }, Yi.prototype.interfaces_ = function() {
        return [];
      }, Yi.prototype.getClass = function() {
        return Yi;
      }, Yi.toSegmentStrings = function(t2) {
        for (var e2 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          e2.add(new Ui(i2.getCoordinates(), i2));
        }
        return e2;
      }, Yi.checkValid = function(t2) {
        new Yi(t2).checkValid();
      };
      var ki = function(t2) {
        this._mapOp = t2;
      };
      ki.prototype.map = function(t2) {
        for (var e2 = new Nt(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
          var i2 = this._mapOp.map(t2.getGeometryN(n2));
          i2.isEmpty() || e2.add(i2);
        }
        return t2.getFactory().createGeometryCollection(_e.toGeometryArray(e2));
      }, ki.prototype.interfaces_ = function() {
        return [];
      }, ki.prototype.getClass = function() {
        return ki;
      }, ki.map = function(t2, e2) {
        return new ki(e2).map(t2);
      };
      var ji = function() {
        this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this._op = t2, this._geometryFactory = e2, this._ptLocator = n2;
      };
      ji.prototype.collectLines = function(t2) {
        for (var e2 = this._op.getGraph().getEdgeEnds().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.collectLineEdge(n2, t2, this._lineEdgesList), this.collectBoundaryTouchEdge(n2, t2, this._lineEdgesList);
        }
      }, ji.prototype.labelIsolatedLine = function(t2, e2) {
        var n2 = this._ptLocator.locate(t2.getCoordinate(), this._op.getArgGeometry(e2));
        t2.getLabel().setLocation(e2, n2);
      }, ji.prototype.build = function(t2) {
        return this.findCoveredLineEdges(), this.collectLines(t2), this.buildLines(t2), this._resultLineList;
      }, ji.prototype.collectLineEdge = function(t2, e2, n2) {
        var i2 = t2.getLabel(), r2 = t2.getEdge();
        t2.isLineEdge() && (t2.isVisited() || !Lr.isResultOfOp(i2, e2) || r2.isCovered() || (n2.add(r2), t2.setVisitedEdge(true)));
      }, ji.prototype.findCoveredLineEdges = function() {
        for (var t2 = this._op.getGraph().getNodes().iterator(); t2.hasNext(); ) {
          t2.next().getEdges().findCoveredLineEdges();
        }
        for (var e2 = this._op.getGraph().getEdgeEnds().iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i2 = n2.getEdge();
          if (n2.isLineEdge() && !i2.isCoveredSet()) {
            var r2 = this._op.isCoveredByA(n2.getCoordinate());
            i2.setCovered(r2);
          }
        }
      }, ji.prototype.labelIsolatedLines = function(t2) {
        for (var e2 = t2.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i2 = n2.getLabel();
          n2.isIsolated() && (i2.isNull(0) ? this.labelIsolatedLine(n2, 0) : this.labelIsolatedLine(n2, 1));
        }
      }, ji.prototype.buildLines = function(t2) {
        for (var e2 = this._lineEdgesList.iterator(); e2.hasNext(); ) {
          var n2 = e2.next(), i2 = this._geometryFactory.createLineString(n2.getCoordinates());
          this._resultLineList.add(i2), n2.setInResult(true);
        }
      }, ji.prototype.collectBoundaryTouchEdge = function(t2, e2, n2) {
        var i2 = t2.getLabel();
        return t2.isLineEdge() ? null : t2.isVisited() ? null : t2.isInteriorAreaEdge() ? null : t2.getEdge().isInResult() ? null : (et.isTrue(!(t2.isInResult() || t2.getSym().isInResult()) || !t2.getEdge().isInResult()), void (Lr.isResultOfOp(i2, e2) && e2 === Lr.INTERSECTION && (n2.add(t2.getEdge()), t2.setVisitedEdge(true))));
      }, ji.prototype.interfaces_ = function() {
        return [];
      }, ji.prototype.getClass = function() {
        return ji;
      };
      var Hi = function() {
        this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();
        var t2 = arguments[0], e2 = arguments[1];
        this._op = t2, this._geometryFactory = e2;
      };
      Hi.prototype.filterCoveredNodeToPoint = function(t2) {
        var e2 = t2.getCoordinate();
        if (!this._op.isCoveredByLA(e2)) {
          var n2 = this._geometryFactory.createPoint(e2);
          this._resultPointList.add(n2);
        }
      }, Hi.prototype.extractNonCoveredResultNodes = function(t2) {
        for (var e2 = this._op.getGraph().getNodes().iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          if (!n2.isInResult() && (!n2.isIncidentEdgeInResult() && (0 === n2.getEdges().getDegree() || t2 === Lr.INTERSECTION))) {
            var i2 = n2.getLabel();
            Lr.isResultOfOp(i2, t2) && this.filterCoveredNodeToPoint(n2);
          }
        }
      }, Hi.prototype.build = function(t2) {
        return this.extractNonCoveredResultNodes(t2), this._resultPointList;
      }, Hi.prototype.interfaces_ = function() {
        return [];
      }, Hi.prototype.getClass = function() {
        return Hi;
      };
      var Wi = function() {
        this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = true, this._preserveGeometryCollectionType = true, this._preserveCollections = false, this._preserveType = false;
      };
      Wi.prototype.transformPoint = function(t2, e2) {
        return this._factory.createPoint(this.transformCoordinates(t2.getCoordinateSequence(), t2));
      }, Wi.prototype.transformPolygon = function(t2, e2) {
        var n2 = true, i2 = this.transformLinearRing(t2.getExteriorRing(), t2);
        null !== i2 && i2 instanceof ee && !i2.isEmpty() || (n2 = false);
        for (var r2 = new Nt(), o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
          var s2 = this.transformLinearRing(t2.getInteriorRingN(o2), t2);
          null === s2 || s2.isEmpty() || (s2 instanceof ee || (n2 = false), r2.add(s2));
        }
        if (n2)
          return this._factory.createPolygon(i2, r2.toArray([]));
        var a2 = new Nt();
        return null !== i2 && a2.add(i2), a2.addAll(r2), this._factory.buildGeometry(a2);
      }, Wi.prototype.createCoordinateSequence = function(t2) {
        return this._factory.getCoordinateSequenceFactory().create(t2);
      }, Wi.prototype.getInputGeometry = function() {
        return this._inputGeom;
      }, Wi.prototype.transformMultiLineString = function(t2, e2) {
        for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
          var r2 = this.transformLineString(t2.getGeometryN(i2), t2);
          null !== r2 && (r2.isEmpty() || n2.add(r2));
        }
        return this._factory.buildGeometry(n2);
      }, Wi.prototype.transformCoordinates = function(t2, e2) {
        return this.copy(t2);
      }, Wi.prototype.transformLineString = function(t2, e2) {
        return this._factory.createLineString(this.transformCoordinates(t2.getCoordinateSequence(), t2));
      }, Wi.prototype.transformMultiPoint = function(t2, e2) {
        for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
          var r2 = this.transformPoint(t2.getGeometryN(i2), t2);
          null !== r2 && (r2.isEmpty() || n2.add(r2));
        }
        return this._factory.buildGeometry(n2);
      }, Wi.prototype.transformMultiPolygon = function(t2, e2) {
        for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
          var r2 = this.transformPolygon(t2.getGeometryN(i2), t2);
          null !== r2 && (r2.isEmpty() || n2.add(r2));
        }
        return this._factory.buildGeometry(n2);
      }, Wi.prototype.copy = function(t2) {
        return t2.copy();
      }, Wi.prototype.transformGeometryCollection = function(t2, e2) {
        for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
          var r2 = this.transform(t2.getGeometryN(i2));
          null !== r2 && (this._pruneEmptyGeometry && r2.isEmpty() || n2.add(r2));
        }
        return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n2)) : this._factory.buildGeometry(n2);
      }, Wi.prototype.transform = function(t2) {
        if (this._inputGeom = t2, this._factory = t2.getFactory(), t2 instanceof Qt)
          return this.transformPoint(t2, null);
        if (t2 instanceof te)
          return this.transformMultiPoint(t2, null);
        if (t2 instanceof ee)
          return this.transformLinearRing(t2, null);
        if (t2 instanceof Kt)
          return this.transformLineString(t2, null);
        if (t2 instanceof Xt)
          return this.transformMultiLineString(t2, null);
        if (t2 instanceof $t)
          return this.transformPolygon(t2, null);
        if (t2 instanceof ne)
          return this.transformMultiPolygon(t2, null);
        if (t2 instanceof zt)
          return this.transformGeometryCollection(t2, null);
        throw new m("Unknown Geometry subtype: " + t2.getClass().getName());
      }, Wi.prototype.transformLinearRing = function(t2, e2) {
        var n2 = this.transformCoordinates(t2.getCoordinateSequence(), t2);
        if (null === n2)
          return this._factory.createLinearRing(null);
        var i2 = n2.size();
        return i2 > 0 && i2 < 4 && !this._preserveType ? this._factory.createLineString(n2) : this._factory.createLinearRing(n2);
      }, Wi.prototype.interfaces_ = function() {
        return [];
      }, Wi.prototype.getClass = function() {
        return Wi;
      };
      var Ki = function t2() {
        if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof Kt && "number" == typeof arguments[1]) {
          var e2 = arguments[0], n2 = arguments[1];
          t2.call(this, e2.getCoordinates(), n2);
        } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
          var i2 = arguments[0], r2 = arguments[1];
          this._srcPts = i2, this._isClosed = t2.isClosed(i2), this._snapTolerance = r2;
        }
      };
      Ki.prototype.snapVertices = function(t2, e2) {
        for (var n2 = this._isClosed ? t2.size() - 1 : t2.size(), i2 = 0; i2 < n2; i2++) {
          var r2 = t2.get(i2), o2 = this.findSnapForVertex(r2, e2);
          null !== o2 && (t2.set(i2, new C(o2)), 0 === i2 && this._isClosed && t2.set(t2.size() - 1, new C(o2)));
        }
      }, Ki.prototype.findSnapForVertex = function(t2, e2) {
        for (var n2 = 0; n2 < e2.length; n2++) {
          if (t2.equals2D(e2[n2]))
            return null;
          if (t2.distance(e2[n2]) < this._snapTolerance)
            return e2[n2];
        }
        return null;
      }, Ki.prototype.snapTo = function(t2) {
        var e2 = new St(this._srcPts);
        this.snapVertices(e2, t2), this.snapSegments(e2, t2);
        return e2.toCoordinateArray();
      }, Ki.prototype.snapSegments = function(t2, e2) {
        if (0 === e2.length)
          return null;
        var n2 = e2.length;
        e2[0].equals2D(e2[e2.length - 1]) && (n2 = e2.length - 1);
        for (var i2 = 0; i2 < n2; i2++) {
          var r2 = e2[i2], o2 = this.findSegmentIndexToSnap(r2, t2);
          o2 >= 0 && t2.add(o2 + 1, new C(r2), false);
        }
      }, Ki.prototype.findSegmentIndexToSnap = function(t2, e2) {
        for (var n2 = v.MAX_VALUE, i2 = -1, r2 = 0; r2 < e2.size() - 1; r2++) {
          if (this._seg.p0 = e2.get(r2), this._seg.p1 = e2.get(r2 + 1), this._seg.p0.equals2D(t2) || this._seg.p1.equals2D(t2)) {
            if (this._allowSnappingToSourceVertices)
              continue;
            return -1;
          }
          var o2 = this._seg.distance(t2);
          o2 < this._snapTolerance && o2 < n2 && (n2 = o2, i2 = r2);
        }
        return i2;
      }, Ki.prototype.setAllowSnappingToSourceVertices = function(t2) {
        this._allowSnappingToSourceVertices = t2;
      }, Ki.prototype.interfaces_ = function() {
        return [];
      }, Ki.prototype.getClass = function() {
        return Ki;
      }, Ki.isClosed = function(t2) {
        return !(t2.length <= 1) && t2[0].equals2D(t2[t2.length - 1]);
      };
      var Ji = function(t2) {
        this._srcGeom = t2 || null;
      }, Qi = { SNAP_PRECISION_FACTOR: { configurable: true } };
      Ji.prototype.snapTo = function(t2, e2) {
        var n2 = this.extractTargetCoordinates(t2);
        return new Zi(e2, n2).transform(this._srcGeom);
      }, Ji.prototype.snapToSelf = function(t2, e2) {
        var n2 = this.extractTargetCoordinates(this._srcGeom), i2 = new Zi(t2, n2, true).transform(this._srcGeom), r2 = i2;
        return e2 && T(r2, Zt) && (r2 = i2.buffer(0)), r2;
      }, Ji.prototype.computeSnapTolerance = function(t2) {
        return this.computeMinimumSegmentLength(t2) / 10;
      }, Ji.prototype.extractTargetCoordinates = function(t2) {
        for (var e2 = new f(), n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; i2++)
          e2.add(n2[i2]);
        return e2.toArray(new Array(0).fill(null));
      }, Ji.prototype.computeMinimumSegmentLength = function(t2) {
        for (var e2 = v.MAX_VALUE, n2 = 0; n2 < t2.length - 1; n2++) {
          var i2 = t2[n2].distance(t2[n2 + 1]);
          i2 < e2 && (e2 = i2);
        }
        return e2;
      }, Ji.prototype.interfaces_ = function() {
        return [];
      }, Ji.prototype.getClass = function() {
        return Ji;
      }, Ji.snap = function(t2, e2, n2) {
        var i2 = new Array(2).fill(null), r2 = new Ji(t2);
        i2[0] = r2.snapTo(e2, n2);
        var o2 = new Ji(e2);
        return i2[1] = o2.snapTo(i2[0], n2), i2;
      }, Ji.computeOverlaySnapTolerance = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = Ji.computeSizeBasedSnapTolerance(t2), n2 = t2.getPrecisionModel();
          if (n2.getType() === fe.FIXED) {
            var i2 = 1 / n2.getScale() * 2 / 1.415;
            i2 > e2 && (e2 = i2);
          }
          return e2;
        }
        if (2 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1];
          return Math.min(Ji.computeOverlaySnapTolerance(r2), Ji.computeOverlaySnapTolerance(o2));
        }
      }, Ji.computeSizeBasedSnapTolerance = function(t2) {
        var e2 = t2.getEnvelopeInternal();
        return Math.min(e2.getHeight(), e2.getWidth()) * Ji.SNAP_PRECISION_FACTOR;
      }, Ji.snapToSelf = function(t2, e2, n2) {
        return new Ji(t2).snapToSelf(e2, n2);
      }, Qi.SNAP_PRECISION_FACTOR.get = function() {
        return 1e-9;
      }, Object.defineProperties(Ji, Qi);
      var Zi = function(t2) {
        function e2(e3, n2, i2) {
          t2.call(this), this._snapTolerance = e3 || null, this._snapPts = n2 || null, this._isSelfSnap = void 0 !== i2 && i2;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.snapLine = function(t3, e3) {
          var n2 = new Ki(t3, this._snapTolerance);
          return n2.setAllowSnappingToSourceVertices(this._isSelfSnap), n2.snapTo(e3);
        }, e2.prototype.transformCoordinates = function(t3, e3) {
          var n2 = t3.toCoordinateArray(), i2 = this.snapLine(n2, this._snapPts);
          return this._factory.getCoordinateSequenceFactory().create(i2);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(Wi), $i = function() {
        this._isFirst = true, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
      };
      $i.prototype.getCommon = function() {
        return v.longBitsToDouble(this._commonBits);
      }, $i.prototype.add = function(t2) {
        var e2 = v.doubleToLongBits(t2);
        if (this._isFirst)
          return this._commonBits = e2, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = false, null;
        if ($i.signExpBits(e2) !== this._commonSignExp)
          return this._commonBits = 0, null;
        this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e2), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
      }, $i.prototype.toString = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0], e2 = v.longBitsToDouble(t2), n2 = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t2), i2 = n2.substring(n2.length - 64);
          return i2.substring(0, 1) + "  " + i2.substring(1, 12) + "(exp) " + i2.substring(12) + " [ " + e2 + " ]";
        }
      }, $i.prototype.interfaces_ = function() {
        return [];
      }, $i.prototype.getClass = function() {
        return $i;
      }, $i.getBit = function(t2, e2) {
        return 0 != (t2 & 1 << e2) ? 1 : 0;
      }, $i.signExpBits = function(t2) {
        return t2 >> 52;
      }, $i.zeroLowerBits = function(t2, e2) {
        return t2 & ~((1 << e2) - 1);
      }, $i.numCommonMostSigMantissaBits = function(t2, e2) {
        for (var n2 = 0, i2 = 52; i2 >= 0; i2--) {
          if ($i.getBit(t2, i2) !== $i.getBit(e2, i2))
            return n2;
          n2++;
        }
        return 52;
      };
      var tr = function() {
        this._commonCoord = null, this._ccFilter = new nr();
      }, er = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
      tr.prototype.addCommonBits = function(t2) {
        var e2 = new ir(this._commonCoord);
        t2.apply(e2), t2.geometryChanged();
      }, tr.prototype.removeCommonBits = function(t2) {
        if (0 === this._commonCoord.x && 0 === this._commonCoord.y)
          return t2;
        var e2 = new C(this._commonCoord);
        e2.x = -e2.x, e2.y = -e2.y;
        var n2 = new ir(e2);
        return t2.apply(n2), t2.geometryChanged(), t2;
      }, tr.prototype.getCommonCoordinate = function() {
        return this._commonCoord;
      }, tr.prototype.add = function(t2) {
        t2.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
      }, tr.prototype.interfaces_ = function() {
        return [];
      }, tr.prototype.getClass = function() {
        return tr;
      }, er.CommonCoordinateFilter.get = function() {
        return nr;
      }, er.Translater.get = function() {
        return ir;
      }, Object.defineProperties(tr, er);
      var nr = function() {
        this._commonBitsX = new $i(), this._commonBitsY = new $i();
      };
      nr.prototype.filter = function(t2) {
        this._commonBitsX.add(t2.x), this._commonBitsY.add(t2.y);
      }, nr.prototype.getCommonCoordinate = function() {
        return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
      }, nr.prototype.interfaces_ = function() {
        return [ft];
      }, nr.prototype.getClass = function() {
        return nr;
      };
      var ir = function() {
        this.trans = null;
        var t2 = arguments[0];
        this.trans = t2;
      };
      ir.prototype.filter = function(t2, e2) {
        var n2 = t2.getOrdinate(e2, 0) + this.trans.x, i2 = t2.getOrdinate(e2, 1) + this.trans.y;
        t2.setOrdinate(e2, 0, n2), t2.setOrdinate(e2, 1, i2);
      }, ir.prototype.isDone = function() {
        return false;
      }, ir.prototype.isGeometryChanged = function() {
        return true;
      }, ir.prototype.interfaces_ = function() {
        return [Ut];
      }, ir.prototype.getClass = function() {
        return ir;
      };
      var rr = function(t2, e2) {
        this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t2, this._geom[1] = e2, this.computeSnapTolerance();
      };
      rr.prototype.selfSnap = function(t2) {
        return new Ji(t2).snapTo(t2, this._snapTolerance);
      }, rr.prototype.removeCommonBits = function(t2) {
        this._cbr = new tr(), this._cbr.add(t2[0]), this._cbr.add(t2[1]);
        var e2 = new Array(2).fill(null);
        return e2[0] = this._cbr.removeCommonBits(t2[0].copy()), e2[1] = this._cbr.removeCommonBits(t2[1].copy()), e2;
      }, rr.prototype.prepareResult = function(t2) {
        return this._cbr.addCommonBits(t2), t2;
      }, rr.prototype.getResultGeometry = function(t2) {
        var e2 = this.snap(this._geom), n2 = Lr.overlayOp(e2[0], e2[1], t2);
        return this.prepareResult(n2);
      }, rr.prototype.checkValid = function(t2) {
        t2.isValid() || Y.out.println("Snapped geometry is invalid");
      }, rr.prototype.computeSnapTolerance = function() {
        this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
      }, rr.prototype.snap = function(t2) {
        var e2 = this.removeCommonBits(t2);
        return Ji.snap(e2[0], e2[1], this._snapTolerance);
      }, rr.prototype.interfaces_ = function() {
        return [];
      }, rr.prototype.getClass = function() {
        return rr;
      }, rr.overlayOp = function(t2, e2, n2) {
        return new rr(t2, e2).getResultGeometry(n2);
      }, rr.union = function(t2, e2) {
        return rr.overlayOp(t2, e2, Lr.UNION);
      }, rr.intersection = function(t2, e2) {
        return rr.overlayOp(t2, e2, Lr.INTERSECTION);
      }, rr.symDifference = function(t2, e2) {
        return rr.overlayOp(t2, e2, Lr.SYMDIFFERENCE);
      }, rr.difference = function(t2, e2) {
        return rr.overlayOp(t2, e2, Lr.DIFFERENCE);
      };
      var or = function(t2, e2) {
        this._geom = new Array(2).fill(null), this._geom[0] = t2, this._geom[1] = e2;
      };
      or.prototype.getResultGeometry = function(t2) {
        var e2 = null, n2 = false, i2 = null;
        try {
          e2 = Lr.overlayOp(this._geom[0], this._geom[1], t2);
          n2 = true;
        } catch (t3) {
          if (!(t3 instanceof $))
            throw t3;
          i2 = t3;
        }
        if (!n2)
          try {
            e2 = rr.overlayOp(this._geom[0], this._geom[1], t2);
          } catch (t3) {
            throw t3 instanceof $ ? i2 : t3;
          }
        return e2;
      }, or.prototype.interfaces_ = function() {
        return [];
      }, or.prototype.getClass = function() {
        return or;
      }, or.overlayOp = function(t2, e2, n2) {
        return new or(t2, e2).getResultGeometry(n2);
      }, or.union = function(t2, e2) {
        return or.overlayOp(t2, e2, Lr.UNION);
      }, or.intersection = function(t2, e2) {
        return or.overlayOp(t2, e2, Lr.INTERSECTION);
      }, or.symDifference = function(t2, e2) {
        return or.overlayOp(t2, e2, Lr.SYMDIFFERENCE);
      }, or.difference = function(t2, e2) {
        return or.overlayOp(t2, e2, Lr.DIFFERENCE);
      };
      var sr = function() {
        this.mce = null, this.chainIndex = null;
        var t2 = arguments[0], e2 = arguments[1];
        this.mce = t2, this.chainIndex = e2;
      };
      sr.prototype.computeIntersections = function(t2, e2) {
        this.mce.computeIntersectsForChain(this.chainIndex, t2.mce, t2.chainIndex, e2);
      }, sr.prototype.interfaces_ = function() {
        return [];
      }, sr.prototype.getClass = function() {
        return sr;
      };
      var ar = function t2() {
        if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          this._eventType = t2.DELETE, this._xValue = e2, this._insertEvent = n2;
        } else if (3 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
          this._eventType = t2.INSERT, this._label = i2, this._xValue = r2, this._obj = o2;
        }
      }, ur = { INSERT: { configurable: true }, DELETE: { configurable: true } };
      ar.prototype.isDelete = function() {
        return this._eventType === ar.DELETE;
      }, ar.prototype.setDeleteEventIndex = function(t2) {
        this._deleteEventIndex = t2;
      }, ar.prototype.getObject = function() {
        return this._obj;
      }, ar.prototype.compareTo = function(t2) {
        var e2 = t2;
        return this._xValue < e2._xValue ? -1 : this._xValue > e2._xValue ? 1 : this._eventType < e2._eventType ? -1 : this._eventType > e2._eventType ? 1 : 0;
      }, ar.prototype.getInsertEvent = function() {
        return this._insertEvent;
      }, ar.prototype.isInsert = function() {
        return this._eventType === ar.INSERT;
      }, ar.prototype.isSameLabel = function(t2) {
        return null !== this._label && this._label === t2._label;
      }, ar.prototype.getDeleteEventIndex = function() {
        return this._deleteEventIndex;
      }, ar.prototype.interfaces_ = function() {
        return [E];
      }, ar.prototype.getClass = function() {
        return ar;
      }, ur.INSERT.get = function() {
        return 1;
      }, ur.DELETE.get = function() {
        return 2;
      }, Object.defineProperties(ar, ur);
      var lr = function() {
      };
      lr.prototype.interfaces_ = function() {
        return [];
      }, lr.prototype.getClass = function() {
        return lr;
      };
      var cr = function() {
        this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = false, this._isDoneWhenProperInt = false;
        var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
        this._li = t2, this._includeProper = e2, this._recordIsolated = n2;
      };
      cr.prototype.isTrivialIntersection = function(t2, e2, n2, i2) {
        if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
          if (cr.isAdjacentSegments(e2, i2))
            return true;
          if (t2.isClosed()) {
            var r2 = t2.getNumPoints() - 1;
            if (0 === e2 && i2 === r2 || 0 === i2 && e2 === r2)
              return true;
          }
        }
        return false;
      }, cr.prototype.getProperIntersectionPoint = function() {
        return this._properIntersectionPoint;
      }, cr.prototype.setIsDoneIfProperInt = function(t2) {
        this._isDoneWhenProperInt = t2;
      }, cr.prototype.hasProperInteriorIntersection = function() {
        return this._hasProperInterior;
      }, cr.prototype.isBoundaryPointInternal = function(t2, e2) {
        for (var n2 = e2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next().getCoordinate();
          if (t2.isIntersection(i2))
            return true;
        }
        return false;
      }, cr.prototype.hasProperIntersection = function() {
        return this._hasProper;
      }, cr.prototype.hasIntersection = function() {
        return this._hasIntersection;
      }, cr.prototype.isDone = function() {
        return this._isDone;
      }, cr.prototype.isBoundaryPoint = function(t2, e2) {
        return null !== e2 && (!!this.isBoundaryPointInternal(t2, e2[0]) || !!this.isBoundaryPointInternal(t2, e2[1]));
      }, cr.prototype.setBoundaryNodes = function(t2, e2) {
        this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t2, this._bdyNodes[1] = e2;
      }, cr.prototype.addIntersections = function(t2, e2, n2, i2) {
        if (t2 === n2 && e2 === i2)
          return null;
        this.numTests++;
        var r2 = t2.getCoordinates()[e2], o2 = t2.getCoordinates()[e2 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
        this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this._recordIsolated && (t2.setIsolated(false), n2.setIsolated(false)), this._numIntersections++, this.isTrivialIntersection(t2, e2, n2, i2) || (this._hasIntersection = true, !this._includeProper && this._li.isProper() || (t2.addIntersections(this._li, e2, 0), n2.addIntersections(this._li, i2, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = true, this._isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = true))));
      }, cr.prototype.interfaces_ = function() {
        return [];
      }, cr.prototype.getClass = function() {
        return cr;
      }, cr.isAdjacentSegments = function(t2, e2) {
        return 1 === Math.abs(t2 - e2);
      };
      var pr = function(t2) {
        function e2() {
          t2.call(this), this.events = new Nt(), this.nOverlaps = null;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.prepareEvents = function() {
          $e.sort(this.events);
          for (var t3 = 0; t3 < this.events.size(); t3++) {
            var e3 = this.events.get(t3);
            e3.isDelete() && e3.getInsertEvent().setDeleteEventIndex(t3);
          }
        }, e2.prototype.computeIntersections = function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            this.nOverlaps = 0, this.prepareEvents();
            for (var e3 = 0; e3 < this.events.size(); e3++) {
              var n2 = this.events.get(e3);
              if (n2.isInsert() && this.processOverlaps(e3, n2.getDeleteEventIndex(), n2, t3), t3.isDone())
                break;
            }
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {
              var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
              this.addEdges(i2, i2), this.addEdges(r2, r2), this.computeIntersections(o2);
            } else if ("boolean" == typeof arguments[2] && T(arguments[0], xt) && arguments[1] instanceof cr) {
              var s2 = arguments[0], a2 = arguments[1];
              arguments[2] ? this.addEdges(s2, null) : this.addEdges(s2), this.computeIntersections(a2);
            }
          }
        }, e2.prototype.addEdge = function(t3, e3) {
          for (var n2 = t3.getMonotoneChainEdge(), i2 = n2.getStartIndexes(), r2 = 0; r2 < i2.length - 1; r2++) {
            var o2 = new sr(n2, r2), s2 = new ar(e3, n2.getMinX(r2), o2);
            this.events.add(s2), this.events.add(new ar(n2.getMaxX(r2), s2));
          }
        }, e2.prototype.processOverlaps = function(t3, e3, n2, i2) {
          for (var r2 = n2.getObject(), o2 = t3; o2 < e3; o2++) {
            var s2 = this.events.get(o2);
            if (s2.isInsert()) {
              var a2 = s2.getObject();
              n2.isSameLabel(s2) || (r2.computeIntersections(a2, i2), this.nOverlaps++);
            }
          }
        }, e2.prototype.addEdges = function() {
          if (1 === arguments.length)
            for (var t3 = arguments[0].iterator(); t3.hasNext(); ) {
              var e3 = t3.next();
              this.addEdge(e3, e3);
            }
          else if (2 === arguments.length)
            for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
              var o2 = r2.next();
              this.addEdge(o2, i2);
            }
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(lr), hr = function() {
        this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;
      }, fr = { NodeComparator: { configurable: true } };
      hr.prototype.getMin = function() {
        return this._min;
      }, hr.prototype.intersects = function(t2, e2) {
        return !(this._min > e2 || this._max < t2);
      }, hr.prototype.getMax = function() {
        return this._max;
      }, hr.prototype.toString = function() {
        return Z.toLineString(new C(this._min, 0), new C(this._max, 0));
      }, hr.prototype.interfaces_ = function() {
        return [];
      }, hr.prototype.getClass = function() {
        return hr;
      }, fr.NodeComparator.get = function() {
        return gr;
      }, Object.defineProperties(hr, fr);
      var gr = function() {
      };
      gr.prototype.compare = function(t2, e2) {
        var n2 = t2, i2 = e2, r2 = (n2._min + n2._max) / 2, o2 = (i2._min + i2._max) / 2;
        return r2 < o2 ? -1 : r2 > o2 ? 1 : 0;
      }, gr.prototype.interfaces_ = function() {
        return [N];
      }, gr.prototype.getClass = function() {
        return gr;
      };
      var dr = function(t2) {
        function e2() {
          t2.call(this), this._item = null;
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._min = e3, this._max = n2, this._item = i2;
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.query = function(t3, e3, n2) {
          if (!this.intersects(t3, e3))
            return null;
          n2.visitItem(this._item);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(hr), yr = function(t2) {
        function e2() {
          t2.call(this), this._node1 = null, this._node2 = null;
          var e3 = arguments[0], n2 = arguments[1];
          this._node1 = e3, this._node2 = n2, this.buildExtent(this._node1, this._node2);
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.buildExtent = function(t3, e3) {
          this._min = Math.min(t3._min, e3._min), this._max = Math.max(t3._max, e3._max);
        }, e2.prototype.query = function(t3, e3, n2) {
          if (!this.intersects(t3, e3))
            return null;
          null !== this._node1 && this._node1.query(t3, e3, n2), null !== this._node2 && this._node2.query(t3, e3, n2);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(hr), _r = function() {
        this._leaves = new Nt(), this._root = null, this._level = 0;
      };
      _r.prototype.buildTree = function() {
        $e.sort(this._leaves, new hr.NodeComparator());
        for (var t2 = this._leaves, e2 = null, n2 = new Nt(); ; ) {
          if (this.buildLevel(t2, n2), 1 === n2.size())
            return n2.get(0);
          e2 = t2, t2 = n2, n2 = e2;
        }
      }, _r.prototype.insert = function(t2, e2, n2) {
        if (null !== this._root)
          throw new Error("Index cannot be added to once it has been queried");
        this._leaves.add(new dr(t2, e2, n2));
      }, _r.prototype.query = function(t2, e2, n2) {
        this.init(), this._root.query(t2, e2, n2);
      }, _r.prototype.buildRoot = function() {
        if (null !== this._root)
          return null;
        this._root = this.buildTree();
      }, _r.prototype.printNode = function(t2) {
        Y.out.println(Z.toLineString(new C(t2._min, this._level), new C(t2._max, this._level)));
      }, _r.prototype.init = function() {
        if (null !== this._root)
          return null;
        this.buildRoot();
      }, _r.prototype.buildLevel = function(t2, e2) {
        this._level++, e2.clear();
        for (var n2 = 0; n2 < t2.size(); n2 += 2) {
          var i2 = t2.get(n2);
          if (null === (n2 + 1 < t2.size() ? t2.get(n2) : null))
            e2.add(i2);
          else {
            var r2 = new yr(t2.get(n2), t2.get(n2 + 1));
            e2.add(r2);
          }
        }
      }, _r.prototype.interfaces_ = function() {
        return [];
      }, _r.prototype.getClass = function() {
        return _r;
      };
      var mr = function() {
        this._items = new Nt();
      };
      mr.prototype.visitItem = function(t2) {
        this._items.add(t2);
      }, mr.prototype.getItems = function() {
        return this._items;
      }, mr.prototype.interfaces_ = function() {
        return [Ke];
      }, mr.prototype.getClass = function() {
        return mr;
      };
      var vr = function() {
        this._index = null;
        var t2 = arguments[0];
        if (!T(t2, Zt))
          throw new m("Argument must be Polygonal");
        this._index = new xr(t2);
      }, Ir = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
      vr.prototype.locate = function(t2) {
        var e2 = new st(t2), n2 = new Er(e2);
        return this._index.query(t2.y, t2.y, n2), e2.getLocation();
      }, vr.prototype.interfaces_ = function() {
        return [Vn];
      }, vr.prototype.getClass = function() {
        return vr;
      }, Ir.SegmentVisitor.get = function() {
        return Er;
      }, Ir.IntervalIndexedGeometry.get = function() {
        return xr;
      }, Object.defineProperties(vr, Ir);
      var Er = function() {
        this._counter = null;
        var t2 = arguments[0];
        this._counter = t2;
      };
      Er.prototype.visitItem = function(t2) {
        var e2 = t2;
        this._counter.countSegment(e2.getCoordinate(0), e2.getCoordinate(1));
      }, Er.prototype.interfaces_ = function() {
        return [Ke];
      }, Er.prototype.getClass = function() {
        return Er;
      };
      var xr = function() {
        this._index = new _r();
        var t2 = arguments[0];
        this.init(t2);
      };
      xr.prototype.init = function(t2) {
        for (var e2 = Ci.getLines(t2).iterator(); e2.hasNext(); ) {
          var n2 = e2.next().getCoordinates();
          this.addLine(n2);
        }
      }, xr.prototype.addLine = function(t2) {
        for (var e2 = 1; e2 < t2.length; e2++) {
          var n2 = new dn(t2[e2 - 1], t2[e2]), i2 = Math.min(n2.p0.y, n2.p1.y), r2 = Math.max(n2.p0.y, n2.p1.y);
          this._index.insert(i2, r2, n2);
        }
      }, xr.prototype.query = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = new mr();
          return this._index.query(t2, e2, n2), n2.getItems();
        }
        if (3 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
          this._index.query(i2, r2, o2);
        }
      }, xr.prototype.interfaces_ = function() {
        return [];
      }, xr.prototype.getClass = function() {
        return xr;
      };
      var Nr = function(t2) {
        function e2() {
          if (t2.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = true, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = false, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
            this._argIndex = e3, this._parentGeom = n2, this._boundaryNodeRule = i2, null !== n2 && this.add(n2);
          } else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            this._argIndex = r2, this._parentGeom = o2, this._boundaryNodeRule = s2, null !== o2 && this.add(o2);
          }
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.insertBoundaryPoint = function(t3, n2) {
          var i2 = this._nodes.addNode(n2).getLabel(), r2 = 1;
          w.NONE;
          i2.getLocation(t3, Se.ON) === w.BOUNDARY && r2++;
          var o2 = e2.determineBoundary(this._boundaryNodeRule, r2);
          i2.setLocation(t3, o2);
        }, e2.prototype.computeSelfNodes = function() {
          if (2 === arguments.length) {
            var t3 = arguments[0], e3 = arguments[1];
            return this.computeSelfNodes(t3, e3, false);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new cr(n2, true, false);
            o2.setIsDoneIfProperInt(r2);
            var s2 = this.createEdgeSetIntersector(), a2 = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne, u2 = i2 || !a2;
            return s2.computeIntersections(this._edges, o2, u2), this.addSelfIntersectionNodes(this._argIndex), o2;
          }
        }, e2.prototype.computeSplitEdges = function(t3) {
          for (var e3 = this._edges.iterator(); e3.hasNext(); ) {
            e3.next().eiList.addSplitEdges(t3);
          }
        }, e2.prototype.computeEdgeIntersections = function(t3, e3, n2) {
          var i2 = new cr(e3, n2, true);
          i2.setBoundaryNodes(this.getBoundaryNodes(), t3.getBoundaryNodes());
          return this.createEdgeSetIntersector().computeIntersections(this._edges, t3._edges, i2), i2;
        }, e2.prototype.getGeometry = function() {
          return this._parentGeom;
        }, e2.prototype.getBoundaryNodeRule = function() {
          return this._boundaryNodeRule;
        }, e2.prototype.hasTooFewPoints = function() {
          return this._hasTooFewPoints;
        }, e2.prototype.addPoint = function() {
          if (arguments[0] instanceof Qt) {
            var t3 = arguments[0].getCoordinate();
            this.insertPoint(this._argIndex, t3, w.INTERIOR);
          } else if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            this.insertPoint(this._argIndex, e3, w.INTERIOR);
          }
        }, e2.prototype.addPolygon = function(t3) {
          this.addPolygonRing(t3.getExteriorRing(), w.EXTERIOR, w.INTERIOR);
          for (var e3 = 0; e3 < t3.getNumInteriorRing(); e3++) {
            var n2 = t3.getInteriorRingN(e3);
            this.addPolygonRing(n2, w.INTERIOR, w.EXTERIOR);
          }
        }, e2.prototype.addEdge = function(t3) {
          this.insertEdge(t3);
          var e3 = t3.getCoordinates();
          this.insertPoint(this._argIndex, e3[0], w.BOUNDARY), this.insertPoint(this._argIndex, e3[e3.length - 1], w.BOUNDARY);
        }, e2.prototype.addLineString = function(t3) {
          var e3 = Lt.removeRepeatedPoints(t3.getCoordinates());
          if (e3.length < 2)
            return this._hasTooFewPoints = true, this._invalidPoint = e3[0], null;
          var n2 = new ni(e3, new Pe(this._argIndex, w.INTERIOR));
          this._lineEdgeMap.put(t3, n2), this.insertEdge(n2), et.isTrue(e3.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e3[0]), this.insertBoundaryPoint(this._argIndex, e3[e3.length - 1]);
        }, e2.prototype.getInvalidPoint = function() {
          return this._invalidPoint;
        }, e2.prototype.getBoundaryPoints = function() {
          for (var t3 = this.getBoundaryNodes(), e3 = new Array(t3.size()).fill(null), n2 = 0, i2 = t3.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            e3[n2++] = r2.getCoordinate().copy();
          }
          return e3;
        }, e2.prototype.getBoundaryNodes = function() {
          return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
        }, e2.prototype.addSelfIntersectionNode = function(t3, e3, n2) {
          if (this.isBoundaryNode(t3, e3))
            return null;
          n2 === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t3, e3) : this.insertPoint(t3, e3, n2);
        }, e2.prototype.addPolygonRing = function(t3, e3, n2) {
          if (t3.isEmpty())
            return null;
          var i2 = Lt.removeRepeatedPoints(t3.getCoordinates());
          if (i2.length < 4)
            return this._hasTooFewPoints = true, this._invalidPoint = i2[0], null;
          var r2 = e3, o2 = n2;
          at.isCCW(i2) && (r2 = n2, o2 = e3);
          var s2 = new ni(i2, new Pe(this._argIndex, w.BOUNDARY, r2, o2));
          this._lineEdgeMap.put(t3, s2), this.insertEdge(s2), this.insertPoint(this._argIndex, i2[0], w.BOUNDARY);
        }, e2.prototype.insertPoint = function(t3, e3, n2) {
          var i2 = this._nodes.addNode(e3), r2 = i2.getLabel();
          null === r2 ? i2._label = new Pe(t3, n2) : r2.setLocation(t3, n2);
        }, e2.prototype.createEdgeSetIntersector = function() {
          return new pr();
        }, e2.prototype.addSelfIntersectionNodes = function(t3) {
          for (var e3 = this._edges.iterator(); e3.hasNext(); )
            for (var n2 = e3.next(), i2 = n2.getLabel().getLocation(t3), r2 = n2.eiList.iterator(); r2.hasNext(); ) {
              var o2 = r2.next();
              this.addSelfIntersectionNode(t3, o2.coord, i2);
            }
        }, e2.prototype.add = function() {
          if (1 !== arguments.length)
            return t2.prototype.add.apply(this, arguments);
          var e3 = arguments[0];
          if (e3.isEmpty())
            return null;
          if (e3 instanceof ne && (this._useBoundaryDeterminationRule = false), e3 instanceof $t)
            this.addPolygon(e3);
          else if (e3 instanceof Kt)
            this.addLineString(e3);
          else if (e3 instanceof Qt)
            this.addPoint(e3);
          else if (e3 instanceof te)
            this.addCollection(e3);
          else if (e3 instanceof Xt)
            this.addCollection(e3);
          else if (e3 instanceof ne)
            this.addCollection(e3);
          else {
            if (!(e3 instanceof zt))
              throw new Error(e3.getClass().getName());
            this.addCollection(e3);
          }
        }, e2.prototype.addCollection = function(t3) {
          for (var e3 = 0; e3 < t3.getNumGeometries(); e3++) {
            var n2 = t3.getGeometryN(e3);
            this.add(n2);
          }
        }, e2.prototype.locate = function(t3) {
          return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t3)) : this._ptLocator.locate(t3, this._parentGeom);
        }, e2.prototype.findEdge = function() {
          if (1 === arguments.length) {
            var e3 = arguments[0];
            return this._lineEdgeMap.get(e3);
          }
          return t2.prototype.findEdge.apply(this, arguments);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2.determineBoundary = function(t3, e3) {
          return t3.isInBoundary(e3) ? w.BOUNDARY : w.INTERIOR;
        }, e2;
      }(Ye), Cr = function() {
        if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
          var t2 = arguments[0];
          this.setComputationPrecision(t2.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t2);
        } else if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
          e2.getPrecisionModel().compareTo(n2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e2.getPrecisionModel()) : this.setComputationPrecision(n2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e2, i2), this._arg[1] = new Nr(1, n2, i2);
        } else if (3 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
          r2.getPrecisionModel().compareTo(o2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r2.getPrecisionModel()) : this.setComputationPrecision(o2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r2, s2), this._arg[1] = new Nr(1, o2, s2);
        }
      };
      Cr.prototype.getArgGeometry = function(t2) {
        return this._arg[t2].getGeometry();
      }, Cr.prototype.setComputationPrecision = function(t2) {
        this._resultPrecisionModel = t2, this._li.setPrecisionModel(this._resultPrecisionModel);
      }, Cr.prototype.interfaces_ = function() {
        return [];
      }, Cr.prototype.getClass = function() {
        return Cr;
      };
      var Sr = function() {
      };
      Sr.prototype.interfaces_ = function() {
        return [];
      }, Sr.prototype.getClass = function() {
        return Sr;
      }, Sr.map = function() {
        if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {
          for (var t2 = arguments[0], e2 = arguments[1], n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = e2.map(t2.getGeometryN(i2));
            null !== r2 && n2.add(r2);
          }
          return t2.getFactory().buildGeometry(n2);
        }
        if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {
          for (var o2 = arguments[0], s2 = arguments[1], a2 = new Nt(), u2 = o2.iterator(); u2.hasNext(); ) {
            var l2 = u2.next(), c2 = s2.map(l2);
            null !== c2 && a2.add(c2);
          }
          return a2;
        }
      }, Sr.MapOp = function() {
      };
      var Lr = function(t2) {
        function e2() {
          var e3 = arguments[0], n2 = arguments[1];
          t2.call(this, e3, n2), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e3.getFactory();
        }
        return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.insertUniqueEdge = function(t3) {
          var e3 = this._edgeList.findEqualEdge(t3);
          if (null !== e3) {
            var n2 = e3.getLabel(), i2 = t3.getLabel();
            e3.isPointwiseEqual(t3) || (i2 = new Pe(t3.getLabel())).flip();
            var r2 = e3.getDepth();
            r2.isNull() && r2.add(n2), r2.add(i2), n2.merge(i2);
          } else
            this._edgeList.add(t3);
        }, e2.prototype.getGraph = function() {
          return this._graph;
        }, e2.prototype.cancelDuplicateResultEdges = function() {
          for (var t3 = this._graph.getEdgeEnds().iterator(); t3.hasNext(); ) {
            var e3 = t3.next(), n2 = e3.getSym();
            e3.isInResult() && n2.isInResult() && (e3.setInResult(false), n2.setInResult(false));
          }
        }, e2.prototype.isCoveredByLA = function(t3) {
          return !!this.isCovered(t3, this._resultLineList) || !!this.isCovered(t3, this._resultPolyList);
        }, e2.prototype.computeGeometry = function(t3, n2, i2, r2) {
          var o2 = new Nt();
          return o2.addAll(t3), o2.addAll(n2), o2.addAll(i2), o2.isEmpty() ? e2.createEmptyResult(r2, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o2);
        }, e2.prototype.mergeSymLabels = function() {
          for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
            t3.next().getEdges().mergeSymLabels();
          }
        }, e2.prototype.isCovered = function(t3, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (this._ptLocator.locate(t3, i2) !== w.EXTERIOR)
              return true;
          }
          return false;
        }, e2.prototype.replaceCollapsedEdges = function() {
          for (var t3 = new Nt(), e3 = this._edgeList.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            n2.isCollapsed() && (e3.remove(), t3.add(n2.getCollapsedEdge()));
          }
          this._edgeList.addAll(t3);
        }, e2.prototype.updateNodeLabelling = function() {
          for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
            var e3 = t3.next(), n2 = e3.getEdges().getLabel();
            e3.getLabel().merge(n2);
          }
        }, e2.prototype.getResultGeometry = function(t3) {
          return this.computeOverlay(t3), this._resultGeom;
        }, e2.prototype.insertUniqueEdges = function(t3) {
          for (var e3 = t3.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.insertUniqueEdge(n2);
          }
        }, e2.prototype.computeOverlay = function(t3) {
          this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, false), this._arg[1].computeSelfNodes(this._li, false), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
          var e3 = new Nt();
          this._arg[0].computeSplitEdges(e3), this._arg[1].computeSplitEdges(e3), this.insertUniqueEdges(e3), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t3), this.cancelDuplicateResultEdges();
          var n2 = new ke(this._geomFact);
          n2.add(this._graph), this._resultPolyList = n2.getPolygons();
          var i2 = new ji(this, this._geomFact, this._ptLocator);
          this._resultLineList = i2.build(t3);
          var r2 = new Hi(this, this._geomFact, this._ptLocator);
          this._resultPointList = r2.build(t3), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t3);
        }, e2.prototype.labelIncompleteNode = function(t3, e3) {
          var n2 = this._ptLocator.locate(t3.getCoordinate(), this._arg[e3].getGeometry());
          t3.getLabel().setLocation(e3, n2);
        }, e2.prototype.copyPoints = function(t3) {
          for (var e3 = this._arg[t3].getNodeIterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this._graph.addNode(n2.getCoordinate()).setLabel(t3, n2.getLabel().getLocation(t3));
          }
        }, e2.prototype.findResultAreaEdges = function(t3) {
          for (var n2 = this._graph.getEdgeEnds().iterator(); n2.hasNext(); ) {
            var i2 = n2.next(), r2 = i2.getLabel();
            r2.isArea() && !i2.isInteriorAreaEdge() && e2.isResultOfOp(r2.getLocation(0, Se.RIGHT), r2.getLocation(1, Se.RIGHT), t3) && i2.setInResult(true);
          }
        }, e2.prototype.computeLabelsFromDepths = function() {
          for (var t3 = this._edgeList.iterator(); t3.hasNext(); ) {
            var e3 = t3.next(), n2 = e3.getLabel(), i2 = e3.getDepth();
            if (!i2.isNull()) {
              i2.normalize();
              for (var r2 = 0; r2 < 2; r2++)
                n2.isNull(r2) || !n2.isArea() || i2.isNull(r2) || (0 === i2.getDelta(r2) ? n2.toLine(r2) : (et.isTrue(!i2.isNull(r2, Se.LEFT), "depth of LEFT side has not been initialized"), n2.setLocation(r2, Se.LEFT, i2.getLocation(r2, Se.LEFT)), et.isTrue(!i2.isNull(r2, Se.RIGHT), "depth of RIGHT side has not been initialized"), n2.setLocation(r2, Se.RIGHT, i2.getLocation(r2, Se.RIGHT))));
            }
          }
        }, e2.prototype.computeLabelling = function() {
          for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
            t3.next().getEdges().computeLabelling(this._arg);
          }
          this.mergeSymLabels(), this.updateNodeLabelling();
        }, e2.prototype.labelIncompleteNodes = function() {
          for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
            var e3 = t3.next(), n2 = e3.getLabel();
            e3.isIsolated() && (n2.isNull(0) ? this.labelIncompleteNode(e3, 0) : this.labelIncompleteNode(e3, 1)), e3.getEdges().updateLabelling(n2);
          }
        }, e2.prototype.isCoveredByA = function(t3) {
          return !!this.isCovered(t3, this._resultPolyList);
        }, e2.prototype.interfaces_ = function() {
          return [];
        }, e2.prototype.getClass = function() {
          return e2;
        }, e2;
      }(Cr);
      Lr.overlayOp = function(t2, e2, n2) {
        return new Lr(t2, e2).getResultGeometry(n2);
      }, Lr.intersection = function(t2, e2) {
        if (t2.isEmpty() || e2.isEmpty())
          return Lr.createEmptyResult(Lr.INTERSECTION, t2, e2, t2.getFactory());
        if (t2.isGeometryCollection()) {
          var n2 = e2;
          return ki.map(t2, { interfaces_: function() {
            return [Sr.MapOp];
          }, map: function(t3) {
            return t3.intersection(n2);
          } });
        }
        return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), or.overlayOp(t2, e2, Lr.INTERSECTION);
      }, Lr.symDifference = function(t2, e2) {
        if (t2.isEmpty() || e2.isEmpty()) {
          if (t2.isEmpty() && e2.isEmpty())
            return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t2, e2, t2.getFactory());
          if (t2.isEmpty())
            return e2.copy();
          if (e2.isEmpty())
            return t2.copy();
        }
        return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), or.overlayOp(t2, e2, Lr.SYMDIFFERENCE);
      }, Lr.resultDimension = function(t2, e2, n2) {
        var i2 = e2.getDimension(), r2 = n2.getDimension(), o2 = -1;
        switch (t2) {
          case Lr.INTERSECTION:
            o2 = Math.min(i2, r2);
            break;
          case Lr.UNION:
            o2 = Math.max(i2, r2);
            break;
          case Lr.DIFFERENCE:
            o2 = i2;
            break;
          case Lr.SYMDIFFERENCE:
            o2 = Math.max(i2, r2);
        }
        return o2;
      }, Lr.createEmptyResult = function(t2, e2, n2, i2) {
        var r2 = null;
        switch (Lr.resultDimension(t2, e2, n2)) {
          case -1:
            r2 = i2.createGeometryCollection(new Array(0).fill(null));
            break;
          case 0:
            r2 = i2.createPoint();
            break;
          case 1:
            r2 = i2.createLineString();
            break;
          case 2:
            r2 = i2.createPolygon();
        }
        return r2;
      }, Lr.difference = function(t2, e2) {
        return t2.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t2, e2, t2.getFactory()) : e2.isEmpty() ? t2.copy() : (t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), or.overlayOp(t2, e2, Lr.DIFFERENCE));
      }, Lr.isResultOfOp = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = t2.getLocation(0), i2 = t2.getLocation(1);
          return Lr.isResultOfOp(n2, i2, e2);
        }
        if (3 === arguments.length) {
          var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
          switch (r2 === w.BOUNDARY && (r2 = w.INTERIOR), o2 === w.BOUNDARY && (o2 = w.INTERIOR), s2) {
            case Lr.INTERSECTION:
              return r2 === w.INTERIOR && o2 === w.INTERIOR;
            case Lr.UNION:
              return r2 === w.INTERIOR || o2 === w.INTERIOR;
            case Lr.DIFFERENCE:
              return r2 === w.INTERIOR && o2 !== w.INTERIOR;
            case Lr.SYMDIFFERENCE:
              return r2 === w.INTERIOR && o2 !== w.INTERIOR || r2 !== w.INTERIOR && o2 === w.INTERIOR;
          }
          return false;
        }
      }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;
      var br = function() {
        this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();
        var t2 = arguments[0], e2 = arguments[1];
        this._g = t2, this._boundaryDistanceTolerance = e2, this._linework = this.extractLinework(t2);
      };
      br.prototype.isWithinToleranceOfBoundary = function(t2) {
        for (var e2 = 0; e2 < this._linework.getNumGeometries(); e2++)
          for (var n2 = this._linework.getGeometryN(e2).getCoordinateSequence(), i2 = 0; i2 < n2.size() - 1; i2++) {
            n2.getCoordinate(i2, this._seg.p0), n2.getCoordinate(i2 + 1, this._seg.p1);
            if (this._seg.distance(t2) <= this._boundaryDistanceTolerance)
              return true;
          }
        return false;
      }, br.prototype.getLocation = function(t2) {
        return this.isWithinToleranceOfBoundary(t2) ? w.BOUNDARY : this._ptLocator.locate(t2, this._g);
      }, br.prototype.extractLinework = function(t2) {
        var e2 = new wr();
        t2.apply(e2);
        var n2 = e2.getLinework(), i2 = _e.toLineStringArray(n2);
        return t2.getFactory().createMultiLineString(i2);
      }, br.prototype.interfaces_ = function() {
        return [];
      }, br.prototype.getClass = function() {
        return br;
      };
      var wr = function() {
        this._linework = null, this._linework = new Nt();
      };
      wr.prototype.getLinework = function() {
        return this._linework;
      }, wr.prototype.filter = function(t2) {
        if (t2 instanceof $t) {
          var e2 = t2;
          this._linework.add(e2.getExteriorRing());
          for (var n2 = 0; n2 < e2.getNumInteriorRing(); n2++)
            this._linework.add(e2.getInteriorRingN(n2));
        }
      }, wr.prototype.interfaces_ = function() {
        return [Vt];
      }, wr.prototype.getClass = function() {
        return wr;
      };
      var Or = function() {
        this._g = null, this._doLeft = true, this._doRight = true;
        var t2 = arguments[0];
        this._g = t2;
      };
      Or.prototype.extractPoints = function(t2, e2, n2) {
        for (var i2 = t2.getCoordinates(), r2 = 0; r2 < i2.length - 1; r2++)
          this.computeOffsetPoints(i2[r2], i2[r2 + 1], e2, n2);
      }, Or.prototype.setSidesToGenerate = function(t2, e2) {
        this._doLeft = t2, this._doRight = e2;
      }, Or.prototype.getPoints = function(t2) {
        for (var e2 = new Nt(), n2 = Ci.getLines(this._g).iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          this.extractPoints(i2, t2, e2);
        }
        return e2;
      }, Or.prototype.computeOffsetPoints = function(t2, e2, n2, i2) {
        var r2 = e2.x - t2.x, o2 = e2.y - t2.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = n2 * r2 / s2, u2 = n2 * o2 / s2, l2 = (e2.x + t2.x) / 2, c2 = (e2.y + t2.y) / 2;
        if (this._doLeft) {
          var p2 = new C(l2 - u2, c2 + a2);
          i2.add(p2);
        }
        if (this._doRight) {
          var h2 = new C(l2 + u2, c2 - a2);
          i2.add(h2);
        }
      }, Or.prototype.interfaces_ = function() {
        return [];
      }, Or.prototype.getClass = function() {
        return Or;
      };
      var Tr = function t2() {
        this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t2.TOLERANCE, this._testCoords = new Nt();
        var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2];
        this._boundaryDistanceTolerance = t2.computeBoundaryDistanceTolerance(e2, n2), this._geom = [e2, n2, i2], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];
      }, Rr = { TOLERANCE: { configurable: true } };
      Tr.prototype.reportResult = function(t2, e2, n2) {
        Y.out.println("Overlay result invalid - A:" + w.toLocationSymbol(e2[0]) + " B:" + w.toLocationSymbol(e2[1]) + " expected:" + (n2 ? "i" : "e") + " actual:" + w.toLocationSymbol(e2[2]));
      }, Tr.prototype.isValid = function(t2) {
        this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
        var e2 = this.checkValid(t2);
        return e2;
      }, Tr.prototype.checkValid = function() {
        if (1 === arguments.length) {
          for (var t2 = arguments[0], e2 = 0; e2 < this._testCoords.size(); e2++) {
            var n2 = this._testCoords.get(e2);
            if (!this.checkValid(t2, n2))
              return this._invalidLocation = n2, false;
          }
          return true;
        }
        if (2 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1];
          return this._location[0] = this._locFinder[0].getLocation(r2), this._location[1] = this._locFinder[1].getLocation(r2), this._location[2] = this._locFinder[2].getLocation(r2), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i2, this._location);
        }
      }, Tr.prototype.addTestPts = function(t2) {
        var e2 = new Or(t2);
        this._testCoords.addAll(e2.getPoints(5 * this._boundaryDistanceTolerance));
      }, Tr.prototype.isValidResult = function(t2, e2) {
        var n2 = Lr.isResultOfOp(e2[0], e2[1], t2), i2 = !(n2 ^ e2[2] === w.INTERIOR);
        return i2 || this.reportResult(t2, e2, n2), i2;
      }, Tr.prototype.getInvalidLocation = function() {
        return this._invalidLocation;
      }, Tr.prototype.interfaces_ = function() {
        return [];
      }, Tr.prototype.getClass = function() {
        return Tr;
      }, Tr.hasLocation = function(t2, e2) {
        for (var n2 = 0; n2 < 3; n2++)
          if (t2[n2] === e2)
            return true;
        return false;
      }, Tr.computeBoundaryDistanceTolerance = function(t2, e2) {
        return Math.min(Ji.computeSizeBasedSnapTolerance(t2), Ji.computeSizeBasedSnapTolerance(e2));
      }, Tr.isValid = function(t2, e2, n2, i2) {
        return new Tr(t2, e2, i2).isValid(n2);
      }, Rr.TOLERANCE.get = function() {
        return 1e-6;
      }, Object.defineProperties(Tr, Rr);
      var Pr = function t2(e2) {
        this._geomFactory = null, this._skipEmpty = false, this._inputGeoms = null, this._geomFactory = t2.extractFactory(e2), this._inputGeoms = e2;
      };
      Pr.prototype.extractElements = function(t2, e2) {
        if (null === t2)
          return null;
        for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
          var i2 = t2.getGeometryN(n2);
          this._skipEmpty && i2.isEmpty() || e2.add(i2);
        }
      }, Pr.prototype.combine = function() {
        for (var t2 = new Nt(), e2 = this._inputGeoms.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          this.extractElements(n2, t2);
        }
        return 0 === t2.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t2);
      }, Pr.prototype.interfaces_ = function() {
        return [];
      }, Pr.prototype.getClass = function() {
        return Pr;
      }, Pr.combine = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return new Pr(t2).combine();
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return new Pr(Pr.createList(e2, n2)).combine();
        }
        if (3 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
          return new Pr(Pr.createList(i2, r2, o2)).combine();
        }
      }, Pr.extractFactory = function(t2) {
        return t2.isEmpty() ? null : t2.iterator().next().getFactory();
      }, Pr.createList = function() {
        if (2 === arguments.length) {
          var t2 = arguments[0], e2 = arguments[1], n2 = new Nt();
          return n2.add(t2), n2.add(e2), n2;
        }
        if (3 === arguments.length) {
          var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = new Nt();
          return s2.add(i2), s2.add(r2), s2.add(o2), s2;
        }
      };
      var Dr = function() {
        this._inputPolys = null, this._geomFactory = null;
        var t2 = arguments[0];
        this._inputPolys = t2, null === this._inputPolys && (this._inputPolys = new Nt());
      }, Mr = { STRTREE_NODE_CAPACITY: { configurable: true } };
      Dr.prototype.reduceToGeometries = function(t2) {
        for (var e2 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next(), r2 = null;
          T(i2, xt) ? r2 = this.unionTree(i2) : i2 instanceof ct && (r2 = i2), e2.add(r2);
        }
        return e2;
      }, Dr.prototype.extractByEnvelope = function(t2, e2, n2) {
        for (var i2 = new Nt(), r2 = 0; r2 < e2.getNumGeometries(); r2++) {
          var o2 = e2.getGeometryN(r2);
          o2.getEnvelopeInternal().intersects(t2) ? i2.add(o2) : n2.add(o2);
        }
        return this._geomFactory.buildGeometry(i2);
      }, Dr.prototype.unionOptimized = function(t2, e2) {
        var n2 = t2.getEnvelopeInternal(), i2 = e2.getEnvelopeInternal();
        if (!n2.intersects(i2)) {
          return Pr.combine(t2, e2);
        }
        if (t2.getNumGeometries() <= 1 && e2.getNumGeometries() <= 1)
          return this.unionActual(t2, e2);
        var r2 = n2.intersection(i2);
        return this.unionUsingEnvelopeIntersection(t2, e2, r2);
      }, Dr.prototype.union = function() {
        if (null === this._inputPolys)
          throw new Error("union() method cannot be called twice");
        if (this._inputPolys.isEmpty())
          return null;
        this._geomFactory = this._inputPolys.iterator().next().getFactory();
        for (var t2 = new sn(Dr.STRTREE_NODE_CAPACITY), e2 = this._inputPolys.iterator(); e2.hasNext(); ) {
          var n2 = e2.next();
          t2.insert(n2.getEnvelopeInternal(), n2);
        }
        this._inputPolys = null;
        var i2 = t2.itemsTree();
        return this.unionTree(i2);
      }, Dr.prototype.binaryUnion = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return this.binaryUnion(t2, 0, t2.size());
        }
        if (3 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          if (i2 - n2 <= 1) {
            var r2 = Dr.getGeometry(e2, n2);
            return this.unionSafe(r2, null);
          }
          if (i2 - n2 == 2)
            return this.unionSafe(Dr.getGeometry(e2, n2), Dr.getGeometry(e2, n2 + 1));
          var o2 = Math.trunc((i2 + n2) / 2), s2 = this.binaryUnion(e2, n2, o2), a2 = this.binaryUnion(e2, o2, i2);
          return this.unionSafe(s2, a2);
        }
      }, Dr.prototype.repeatedUnion = function(t2) {
        for (var e2 = null, n2 = t2.iterator(); n2.hasNext(); ) {
          var i2 = n2.next();
          e2 = null === e2 ? i2.copy() : e2.union(i2);
        }
        return e2;
      }, Dr.prototype.unionSafe = function(t2, e2) {
        return null === t2 && null === e2 ? null : null === t2 ? e2.copy() : null === e2 ? t2.copy() : this.unionOptimized(t2, e2);
      }, Dr.prototype.unionActual = function(t2, e2) {
        return Dr.restrictToPolygons(t2.union(e2));
      }, Dr.prototype.unionTree = function(t2) {
        var e2 = this.reduceToGeometries(t2);
        return this.binaryUnion(e2);
      }, Dr.prototype.unionUsingEnvelopeIntersection = function(t2, e2, n2) {
        var i2 = new Nt(), r2 = this.extractByEnvelope(n2, t2, i2), o2 = this.extractByEnvelope(n2, e2, i2), s2 = this.unionActual(r2, o2);
        i2.add(s2);
        return Pr.combine(i2);
      }, Dr.prototype.bufferUnion = function() {
        if (1 === arguments.length) {
          var t2 = arguments[0];
          return t2.get(0).getFactory().buildGeometry(t2).buffer(0);
        }
        if (2 === arguments.length) {
          var e2 = arguments[0], n2 = arguments[1];
          return e2.getFactory().createGeometryCollection([e2, n2]).buffer(0);
        }
      }, Dr.prototype.interfaces_ = function() {
        return [];
      }, Dr.prototype.getClass = function() {
        return Dr;
      }, Dr.restrictToPolygons = function(t2) {
        if (T(t2, Zt))
          return t2;
        var e2 = Ni.getPolygons(t2);
        return 1 === e2.size() ? e2.get(0) : t2.getFactory().createMultiPolygon(_e.toPolygonArray(e2));
      }, Dr.getGeometry = function(t2, e2) {
        return e2 >= t2.size() ? null : t2.get(e2);
      }, Dr.union = function(t2) {
        return new Dr(t2).union();
      }, Mr.STRTREE_NODE_CAPACITY.get = function() {
        return 4;
      }, Object.defineProperties(Dr, Mr);
      var Ar = function() {
      };
      Ar.prototype.interfaces_ = function() {
        return [];
      }, Ar.prototype.getClass = function() {
        return Ar;
      }, Ar.union = function(t2, e2) {
        if (t2.isEmpty() || e2.isEmpty()) {
          if (t2.isEmpty() && e2.isEmpty())
            return Lr.createEmptyResult(Lr.UNION, t2, e2, t2.getFactory());
          if (t2.isEmpty())
            return e2.copy();
          if (e2.isEmpty())
            return t2.copy();
        }
        return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e2), or.overlayOp(t2, e2, Lr.UNION);
      }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, "__esModule", { value: true });
    });
  }
});

// node_modules/@turf/buffer/dist/js/index.js
var require_js28 = __commonJS({
  "node_modules/@turf/buffer/dist/js/index.js"(exports, module) {
    "use strict";
    var center = require_js17();
    var turfJsts = require_jsts_min();
    var meta = require_js2();
    var d3Geo = (init_d3_geo(), __toCommonJS(d3_geo_exports));
    var helpers = require_js();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var center__default = _interopDefaultLegacy(center);
    function buffer(geojson, radius, options) {
      options = options || {};
      var units = options.units || "kilometers";
      var steps = options.steps || 8;
      if (!geojson)
        throw new Error("geojson is required");
      if (typeof options !== "object")
        throw new Error("options must be an object");
      if (typeof steps !== "number")
        throw new Error("steps must be an number");
      if (radius === void 0)
        throw new Error("radius is required");
      if (steps <= 0)
        throw new Error("steps must be greater than 0");
      var results = [];
      switch (geojson.type) {
        case "GeometryCollection":
          meta.geomEach(geojson, function(geometry) {
            var buffered = bufferFeature(geometry, radius, units, steps);
            if (buffered)
              results.push(buffered);
          });
          return helpers.featureCollection(results);
        case "FeatureCollection":
          meta.featureEach(geojson, function(feature2) {
            var multiBuffered = bufferFeature(feature2, radius, units, steps);
            if (multiBuffered) {
              meta.featureEach(multiBuffered, function(buffered) {
                if (buffered)
                  results.push(buffered);
              });
            }
          });
          return helpers.featureCollection(results);
      }
      return bufferFeature(geojson, radius, units, steps);
    }
    function bufferFeature(geojson, radius, units, steps) {
      var properties = geojson.properties || {};
      var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;
      if (geometry.type === "GeometryCollection") {
        var results = [];
        meta.geomEach(geojson, function(geometry2) {
          var buffered2 = bufferFeature(geometry2, radius, units, steps);
          if (buffered2)
            results.push(buffered2);
        });
        return helpers.featureCollection(results);
      }
      var projection = defineProjection(geometry);
      var projected = {
        type: geometry.type,
        coordinates: projectCoords(geometry.coordinates, projection)
      };
      var reader = new turfJsts.GeoJSONReader();
      var geom = reader.read(projected);
      var distance = helpers.radiansToLength(helpers.lengthToRadians(radius, units), "meters");
      var buffered = turfJsts.BufferOp.bufferOp(geom, distance, steps);
      var writer = new turfJsts.GeoJSONWriter();
      buffered = writer.write(buffered);
      if (coordsIsNaN(buffered.coordinates))
        return void 0;
      var result = {
        type: buffered.type,
        coordinates: unprojectCoords(buffered.coordinates, projection)
      };
      return helpers.feature(result, properties);
    }
    function coordsIsNaN(coords) {
      if (Array.isArray(coords[0]))
        return coordsIsNaN(coords[0]);
      return isNaN(coords[0]);
    }
    function projectCoords(coords, proj) {
      if (typeof coords[0] !== "object")
        return proj(coords);
      return coords.map(function(coord) {
        return projectCoords(coord, proj);
      });
    }
    function unprojectCoords(coords, proj) {
      if (typeof coords[0] !== "object")
        return proj.invert(coords);
      return coords.map(function(coord) {
        return unprojectCoords(coord, proj);
      });
    }
    function defineProjection(geojson) {
      var coords = center__default["default"](geojson).geometry.coordinates;
      var rotation = [-coords[0], -coords[1]];
      return d3Geo.geoAzimuthalEquidistant().rotate(rotation).scale(helpers.earthRadius);
    }
    module.exports = buffer;
    module.exports.default = buffer;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/split-polygon-mode.js
var require_split_polygon_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/split-polygon-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SplitPolygonMode = void 0;
    var _booleanPointInPolygon = _interopRequireDefault(require_js27());
    var _difference = _interopRequireDefault(require_js6());
    var _buffer = _interopRequireDefault(require_js28());
    var _lineIntersect = _interopRequireDefault(require_js14());
    var _helpers = require_js();
    var _bearing = _interopRequireDefault(require_js9());
    var _distance = _interopRequireDefault(require_js10());
    var _destination = _interopRequireDefault(require_js8());
    var _polygonToLine = _interopRequireDefault(require_js23());
    var _nearestPointOnLine = _interopRequireDefault(require_js15());
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var SplitPolygonMode = function(_GeoJsonEditMode) {
      _inherits(SplitPolygonMode2, _GeoJsonEditMode);
      var _super = _createSuper(SplitPolygonMode2);
      function SplitPolygonMode2() {
        _classCallCheck(this, SplitPolygonMode2);
        return _super.apply(this, arguments);
      }
      _createClass(SplitPolygonMode2, [{
        key: "calculateMapCoords",
        value: function calculateMapCoords(clickSequence, mapCoords, props) {
          var modeConfig = props.modeConfig;
          if (!modeConfig || !modeConfig.lock90Degree || !clickSequence.length) {
            return mapCoords;
          }
          if (clickSequence.length === 1) {
            var firstPoint = clickSequence[0];
            var selectedGeometry = this.getSelectedGeometry(props);
            var feature2 = (0, _polygonToLine["default"])(selectedGeometry);
            var lines = feature2.type === "FeatureCollection" ? feature2.features : [feature2];
            var minDistance = Number.MAX_SAFE_INTEGER;
            var closestPoint = null;
            lines.forEach(function(line) {
              var snapPoint = (0, _nearestPointOnLine["default"])(line, firstPoint);
              var distanceFromOrigin = (0, _distance["default"])(snapPoint, firstPoint);
              if (minDistance > distanceFromOrigin) {
                minDistance = distanceFromOrigin;
                closestPoint = snapPoint;
              }
            });
            if (closestPoint) {
              var lastBearing = (0, _bearing["default"])(firstPoint, closestPoint);
              var currentDistance = (0, _distance["default"])(firstPoint, mapCoords, {
                units: "meters"
              });
              return (0, _destination["default"])(firstPoint, currentDistance, lastBearing, {
                units: "meters"
              }).geometry.coordinates;
            }
            return mapCoords;
          }
          var lastPoint = clickSequence[clickSequence.length - 1];
          var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(clickSequence[clickSequence.length - 2], lastPoint, mapCoords), _generatePointsParall2 = _slicedToArray(_generatePointsParall, 1), approximatePoint = _generatePointsParall2[0];
          var nearestPt = (0, _nearestPointOnLine["default"])((0, _helpers.lineString)([lastPoint, approximatePoint]), mapCoords).geometry.coordinates;
          return nearestPt;
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var clickSequence = this.getClickSequence();
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          if (clickSequence.length === 0 || !props.lastPointerMoveEvent) {
            return guides;
          }
          var mapCoords = props.lastPointerMoveEvent.mapCoords;
          guides.features.push({
            type: "Feature",
            properties: {
              guideType: "tentative"
            },
            geometry: {
              type: "LineString",
              coordinates: [].concat(_toConsumableArray(clickSequence), [this.calculateMapCoords(clickSequence, mapCoords, props)])
            }
          });
          return guides;
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
          var tentativeFeature = this.getTentativeGuide(props);
          var selectedGeometry = this.getSelectedGeometry(props);
          if (!selectedGeometry) {
            console.warn("A polygon must be selected for splitting");
            return;
          }
          var clickSequence = this.getClickSequence();
          if (tentativeFeature && tentativeFeature.geometry.type === "LineString") {
            clickSequence.push(tentativeFeature.geometry.coordinates[tentativeFeature.geometry.coordinates.length - 1]);
          } else {
            this.addClickSequence(event);
          }
          var pt = {
            type: "Point",
            coordinates: clickSequence[clickSequence.length - 1]
          };
          var isPointInPolygon = (0, _booleanPointInPolygon["default"])(pt, selectedGeometry);
          if (clickSequence.length > 1 && tentativeFeature && !isPointInPolygon) {
            this.resetClickSequence();
            var isLineInterectingWithPolygon = (0, _lineIntersect["default"])(tentativeFeature, selectedGeometry);
            if (isLineInterectingWithPolygon.features.length === 0) {
              return;
            }
            var editAction = this.splitPolygon(tentativeFeature, props);
            if (editAction) {
              props.onEdit(editAction);
            }
          }
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
        }
      }, {
        key: "splitPolygon",
        value: function splitPolygon(tentativeFeature, props) {
          var selectedGeometry = this.getSelectedGeometry(props);
          var featureIndex = props.selectedIndexes[0];
          var modeConfig = props.modeConfig || {};
          var _modeConfig$gap = modeConfig.gap, gap = _modeConfig$gap === void 0 ? 0.1 : _modeConfig$gap, _modeConfig$units = modeConfig.units, units = _modeConfig$units === void 0 ? "centimeters" : _modeConfig$units;
          if (gap === 0) {
            gap = 0.1;
            units = "centimeters";
          }
          var buffer = (0, _buffer["default"])(tentativeFeature, gap, {
            units
          });
          var updatedGeometry = (0, _difference["default"])(selectedGeometry, buffer);
          if (!updatedGeometry) {
            console.warn("Canceling edit. Split Polygon erased");
            return null;
          }
          var _updatedGeometry$geom = updatedGeometry.geometry, type = _updatedGeometry$geom.type, coordinates = _updatedGeometry$geom.coordinates;
          var updatedCoordinates = [];
          if (type === "Polygon") {
            updatedCoordinates = coordinates.map(function(c) {
              return [c];
            });
          } else {
            updatedCoordinates = coordinates.reduce(function(agg, prev) {
              prev.forEach(function(p) {
                agg.push([p]);
              });
              return agg;
            }, []);
          }
          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, {
            type: "MultiPolygon",
            coordinates: updatedCoordinates
          });
          var editAction = {
            updatedData: updatedData.getObject(),
            editType: "split",
            editContext: {
              featureIndexes: [featureIndex]
            }
          };
          return editAction;
        }
      }]);
      return SplitPolygonMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.SplitPolygonMode = SplitPolygonMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/extrude-mode.js
var require_extrude_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/extrude-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExtrudeMode = void 0;
    var _bearing = _interopRequireDefault(require_js9());
    var _utils = require_utils();
    var _modifyMode = require_modify_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ExtrudeMode = function(_ModifyMode) {
      _inherits(ExtrudeMode2, _ModifyMode);
      var _super = _createSuper(ExtrudeMode2);
      function ExtrudeMode2() {
        var _this;
        _classCallCheck(this, ExtrudeMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "isPointAdded", false);
        return _this;
      }
      _createClass(ExtrudeMode2, [{
        key: "handleDragging",
        value: function handleDragging(event, props) {
          var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);
          if (editHandle) {
            var featureIndex = editHandle.properties.featureIndex;
            var positionIndexes = editHandle.properties.positionIndexes;
            var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);
            positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes;
            var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);
            var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);
            if (p1 && p2) {
              var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords), _generatePointsParall2 = _slicedToArray(_generatePointsParall, 2), p3 = _generatePointsParall2[0], p4 = _generatePointsParall2[1];
              var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();
              props.onEdit({
                updatedData,
                editType: "extruding",
                editContext: {
                  featureIndexes: [featureIndex],
                  positionIndexes: this.nextPositionIndexes(positionIndexes, size),
                  position: p3
                }
              });
              event.cancelPan();
            }
          }
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          var selectedFeatureIndexes = props.selectedIndexes;
          var editHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);
          if (selectedFeatureIndexes.length && editHandle) {
            var _editHandle$propertie = editHandle.properties, positionIndexes = _editHandle$propertie.positionIndexes, featureIndex = _editHandle$propertie.featureIndex;
            var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);
            var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);
            var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);
            if (p1 && p2) {
              var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);
              if (!this.isOrthogonal(positionIndexes, featureIndex, size, props.data)) {
                updatedData = updatedData.addPosition(featureIndex, positionIndexes, p2);
              }
              if (!this.isOrthogonal(this.prevPositionIndexes(positionIndexes, size), featureIndex, size, props.data)) {
                updatedData = updatedData.addPosition(featureIndex, positionIndexes, p1);
                this.isPointAdded = true;
              }
              props.onEdit({
                updatedData: updatedData.getObject(),
                editType: "startExtruding",
                editContext: {
                  featureIndexes: [featureIndex],
                  positionIndexes,
                  position: p1
                }
              });
            }
          }
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          var selectedFeatureIndexes = props.selectedIndexes;
          var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);
          if (selectedFeatureIndexes.length && editHandle) {
            var featureIndex = editHandle.properties.featureIndex;
            var positionIndexes = editHandle.properties.positionIndexes;
            var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);
            positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes;
            var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);
            var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);
            if (p1 && p2) {
              var _generatePointsParall3 = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords), _generatePointsParall4 = _slicedToArray(_generatePointsParall3, 2), p3 = _generatePointsParall4[0], p4 = _generatePointsParall4[1];
              var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();
              props.onEdit({
                updatedData,
                editType: "extruded",
                editContext: {
                  featureIndexes: [featureIndex],
                  positionIndexes,
                  position: p3
                }
              });
            }
          }
          this.isPointAdded = false;
        }
      }, {
        key: "coordinatesSize",
        value: function coordinatesSize(positionIndexes, featureIndex, _ref) {
          var features = _ref.features;
          var size = 0;
          if (Array.isArray(positionIndexes)) {
            var feature2 = features[featureIndex];
            var coordinates = feature2.geometry.coordinates;
            if (positionIndexes.length === 3) {
              var _positionIndexes = _slicedToArray(positionIndexes, 2), a = _positionIndexes[0], b = _positionIndexes[1];
              if (coordinates.length && coordinates[a].length) {
                size = coordinates[a][b].length;
              }
            } else {
              var _positionIndexes2 = _slicedToArray(positionIndexes, 1), _b = _positionIndexes2[0];
              if (coordinates.length && coordinates[_b].length) {
                size = coordinates[_b].length;
              }
            }
          }
          return size;
        }
      }, {
        key: "getBearing",
        value: function getBearing(p1, p2) {
          var angle = (0, _bearing["default"])(p1, p2);
          if (angle < 0) {
            return Math.floor(360 + angle);
          }
          return Math.floor(angle);
        }
      }, {
        key: "isOrthogonal",
        value: function isOrthogonal(positionIndexes, featureIndex, size, features) {
          if (!Array.isArray(positionIndexes)) {
            return false;
          }
          if (positionIndexes[positionIndexes.length - 1] === size - 1) {
            positionIndexes[positionIndexes.length - 1] = 0;
          }
          var prevPoint = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, features);
          var nextPoint = this.getPointForPositionIndexes(this.nextPositionIndexes(positionIndexes, size), featureIndex, features);
          var currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex, features);
          var prevAngle = this.getBearing(currentPoint, prevPoint);
          var nextAngle = this.getBearing(currentPoint, nextPoint);
          return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));
        }
      }, {
        key: "nextPositionIndexes",
        value: function nextPositionIndexes(positionIndexes, size) {
          if (!Array.isArray(positionIndexes)) {
            return [];
          }
          var next = _toConsumableArray(positionIndexes);
          if (next.length) {
            next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;
          }
          return next;
        }
      }, {
        key: "prevPositionIndexes",
        value: function prevPositionIndexes(positionIndexes, size) {
          if (!Array.isArray(positionIndexes)) {
            return [];
          }
          var prev = _toConsumableArray(positionIndexes);
          if (prev.length) {
            prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;
          }
          return prev;
        }
      }, {
        key: "getPointForPositionIndexes",
        value: function getPointForPositionIndexes(positionIndexes, featureIndex, _ref2) {
          var features = _ref2.features;
          var p1;
          if (Array.isArray(positionIndexes)) {
            var feature2 = features[featureIndex];
            var coordinates = feature2.geometry.coordinates;
            if (positionIndexes.length === 3) {
              var _positionIndexes3 = _slicedToArray(positionIndexes, 3), a = _positionIndexes3[0], b = _positionIndexes3[1], c = _positionIndexes3[2];
              if (coordinates.length && coordinates[a].length) {
                p1 = coordinates[a][b][c];
              }
            } else {
              var _positionIndexes4 = _slicedToArray(positionIndexes, 2), _b2 = _positionIndexes4[0], _c = _positionIndexes4[1];
              if (coordinates.length && coordinates[_b2].length) {
                p1 = coordinates[_b2][_c];
              }
            }
          }
          return p1;
        }
      }]);
      return ExtrudeMode2;
    }(_modifyMode.ModifyMode);
    exports.ExtrudeMode = ExtrudeMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/elevation-mode.js
var require_elevation_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/elevation-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ElevationMode = void 0;
    var _utils = require_utils();
    var _modifyMode = require_modify_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function defaultCalculateElevationChange(_ref) {
      var pointerDownScreenCoords = _ref.pointerDownScreenCoords, screenCoords = _ref.screenCoords;
      return 10 * (pointerDownScreenCoords[1] - screenCoords[1]);
    }
    var ElevationMode = function(_ModifyMode) {
      _inherits(ElevationMode2, _ModifyMode);
      var _super = _createSuper(ElevationMode2);
      function ElevationMode2() {
        _classCallCheck(this, ElevationMode2);
        return _super.apply(this, arguments);
      }
      _createClass(ElevationMode2, [{
        key: "makeElevatedEvent",
        value: function makeElevatedEvent(event, position, props) {
          var _ref2 = props.modeConfig || {}, _ref2$minElevation = _ref2.minElevation, minElevation = _ref2$minElevation === void 0 ? 0 : _ref2$minElevation, _ref2$maxElevation = _ref2.maxElevation, maxElevation = _ref2$maxElevation === void 0 ? 2e4 : _ref2$maxElevation, _ref2$calculateElevat = _ref2.calculateElevationChange, calculateElevationChange = _ref2$calculateElevat === void 0 ? defaultCalculateElevationChange : _ref2$calculateElevat;
          if (!event.pointerDownScreenCoords) {
            return event;
          }
          var elevation = position.length === 3 ? position[2] : 0;
          elevation += calculateElevationChange({
            pointerDownScreenCoords: event.pointerDownScreenCoords,
            screenCoords: event.screenCoords
          });
          elevation = Math.min(elevation, maxElevation);
          elevation = Math.max(elevation, minElevation);
          return Object.assign({}, event, {
            mapCoords: [position[0], position[1], elevation]
          });
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);
          var position = editHandle ? editHandle.geometry.coordinates : event.mapCoords;
          _get(_getPrototypeOf(ElevationMode2.prototype), "handlePointerMove", this).call(this, this.makeElevatedEvent(event, position, props), props);
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          var editHandle = (0, _utils.getPickedEditHandle)(event.picks);
          var position = editHandle ? editHandle.geometry.coordinates : event.mapCoords;
          _get(_getPrototypeOf(ElevationMode2.prototype), "handleStopDragging", this).call(this, this.makeElevatedEvent(event, position, props), props);
        }
      }, {
        key: "getCursor",
        value: function getCursor(event) {
          var cursor = _get(_getPrototypeOf(ElevationMode2.prototype), "getCursor", this).call(this, event);
          if (cursor === "cell") {
            cursor = "ns-resize";
          }
          return cursor;
        }
      }], [{
        key: "calculateElevationChangeWithViewport",
        value: function calculateElevationChangeWithViewport(viewport, _ref3) {
          var pointerDownScreenCoords = _ref3.pointerDownScreenCoords, screenCoords = _ref3.screenCoords;
          var metersPerPixel = 156543.03392 * Math.cos(viewport.latitude * Math.PI / 180) / Math.pow(2, viewport.zoom);
          return metersPerPixel * (pointerDownScreenCoords[1] - screenCoords[1]) / 2;
        }
      }]);
      return ElevationMode2;
    }(_modifyMode.ModifyMode);
    exports.ElevationMode = ElevationMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/composite-mode.js
var require_composite_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/composite-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CompositeMode = void 0;
    var _geojsonEditMode = require_geojson_edit_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var CompositeMode = function(_GeoJsonEditMode) {
      _inherits(CompositeMode2, _GeoJsonEditMode);
      var _super = _createSuper(CompositeMode2);
      function CompositeMode2(modes) {
        var _this;
        _classCallCheck(this, CompositeMode2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "_modes", void 0);
        _this._modes = modes;
        return _this;
      }
      _createClass(CompositeMode2, [{
        key: "_coalesce",
        value: function _coalesce(callback) {
          var resultEval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var result;
          for (var i = 0; i < this._modes.length; i++) {
            result = callback(this._modes[i]);
            if (resultEval ? resultEval(result) : result) {
              break;
            }
          }
          return result;
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
          this._coalesce(function(handler) {
            return handler.handleClick(event, props);
          });
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          return this._coalesce(function(handler) {
            return handler.handlePointerMove(event, props);
          });
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          return this._coalesce(function(handler) {
            return handler.handleStartDragging(event, props);
          });
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          return this._coalesce(function(handler) {
            return handler.handleStopDragging(event, props);
          });
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
          return this._coalesce(function(handler) {
            return handler.handleDragging(event, props);
          });
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var allGuides = [];
          var _iterator = _createForOfIteratorHelper(this._modes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var mode = _step.value;
              allGuides.push.apply(allGuides, _toConsumableArray(mode.getGuides(props).features));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return {
            type: "FeatureCollection",
            features: allGuides
          };
        }
      }]);
      return CompositeMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.CompositeMode = CompositeMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/transform-mode.js
var require_transform_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/transform-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransformMode = void 0;
    var _helpers = require_js();
    var _translateMode = require_translate_mode();
    var _scaleMode = require_scale_mode();
    var _rotateMode = require_rotate_mode();
    var _compositeMode = require_composite_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var TransformMode = function(_CompositeMode) {
      _inherits(TransformMode2, _CompositeMode);
      var _super = _createSuper(TransformMode2);
      function TransformMode2() {
        _classCallCheck(this, TransformMode2);
        return _super.call(this, [new _translateMode.TranslateMode(), new _scaleMode.ScaleMode(), new _rotateMode.RotateMode()]);
      }
      _createClass(TransformMode2, [{
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          var updatedCursor = null;
          _get(_getPrototypeOf(TransformMode2.prototype), "handlePointerMove", this).call(this, event, _objectSpread({}, props, {
            onUpdateCursor: function onUpdateCursor(cursor) {
              updatedCursor = cursor || updatedCursor;
            }
          }));
          props.onUpdateCursor(updatedCursor);
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          var scaleMode = null;
          var translateMode = null;
          var filteredModes = [];
          this._modes.forEach(function(mode) {
            if (mode instanceof _translateMode.TranslateMode) {
              translateMode = mode;
            } else {
              if (mode instanceof _scaleMode.ScaleMode) {
                scaleMode = mode;
              }
              filteredModes.push(mode);
            }
          });
          if (scaleMode instanceof _scaleMode.ScaleMode && !scaleMode.isEditHandleSelected()) {
            filteredModes.push(translateMode);
          }
          filteredModes.filter(Boolean).forEach(function(mode) {
            return mode.handleStartDragging(event, props);
          });
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var compositeGuides = _get(_getPrototypeOf(TransformMode2.prototype), "getGuides", this).call(this, props);
          var rotateMode = (this._modes || []).find(function(mode) {
            return mode instanceof _rotateMode.RotateMode;
          });
          if (rotateMode instanceof _rotateMode.RotateMode) {
            var nonEnvelopeGuides = compositeGuides.features.filter(function(guide) {
              var _ref = guide.properties || {}, editHandleType = _ref.editHandleType, mode = _ref.mode;
              var guidesToFilterOut = [mode];
              if (rotateMode.getIsRotating()) {
                guidesToFilterOut.push(editHandleType);
              }
              return !guidesToFilterOut.includes("scale");
            });
            compositeGuides = (0, _helpers.featureCollection)(nonEnvelopeGuides);
          }
          return compositeGuides;
        }
      }]);
      return TransformMode2;
    }(_compositeMode.CompositeMode);
    exports.TransformMode = TransformMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-point-mode.js
var require_draw_point_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-point-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawPointMode = void 0;
    var _geojsonEditMode = require_geojson_edit_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawPointMode = function(_GeoJsonEditMode) {
      _inherits(DrawPointMode2, _GeoJsonEditMode);
      var _super = _createSuper(DrawPointMode2);
      function DrawPointMode2() {
        _classCallCheck(this, DrawPointMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawPointMode2, [{
        key: "createTentativeFeature",
        value: function createTentativeFeature(props) {
          var lastPointerMoveEvent = props.lastPointerMoveEvent;
          var lastCoords = lastPointerMoveEvent ? [lastPointerMoveEvent.mapCoords] : [];
          return {
            type: "Feature",
            properties: {
              guideType: "tentative"
            },
            geometry: {
              type: "Point",
              coordinates: lastCoords[0]
            }
          };
        }
      }, {
        key: "handleClick",
        value: function handleClick(_ref, props) {
          var mapCoords = _ref.mapCoords;
          var geometry = {
            type: "Point",
            coordinates: mapCoords
          };
          props.onEdit(this.getAddFeatureAction(geometry, props.data));
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
          _get(_getPrototypeOf(DrawPointMode2.prototype), "handlePointerMove", this).call(this, event, props);
        }
      }]);
      return DrawPointMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.DrawPointMode = DrawPointMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-line-string-mode.js
var require_draw_line_string_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-line-string-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawLineStringMode = void 0;
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawLineStringMode = function(_GeoJsonEditMode) {
      _inherits(DrawLineStringMode2, _GeoJsonEditMode);
      var _super = _createSuper(DrawLineStringMode2);
      function DrawLineStringMode2() {
        _classCallCheck(this, DrawLineStringMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawLineStringMode2, [{
        key: "handleClick",
        value: function handleClick(event, props) {
          var picks = event.picks;
          var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);
          var positionAdded = false;
          if (!clickedEditHandle) {
            this.addClickSequence(event);
            positionAdded = true;
          }
          var clickSequence = this.getClickSequence();
          if (clickSequence.length > 1 && clickedEditHandle && Array.isArray(clickedEditHandle.properties.positionIndexes) && clickedEditHandle.properties.positionIndexes[0] === clickSequence.length - 1) {
            var lineStringToAdd = {
              type: "LineString",
              coordinates: _toConsumableArray(clickSequence)
            };
            this.resetClickSequence();
            var editAction = this.getAddFeatureAction(lineStringToAdd, props.data);
            if (editAction) {
              props.onEdit(editAction);
            }
          } else if (positionAdded) {
            props.onEdit({
              // data is the same
              updatedData: props.data,
              editType: "addTentativePosition",
              editContext: {
                position: event.mapCoords
              }
            });
          }
        }
      }, {
        key: "handleKeyUp",
        value: function handleKeyUp(event, props) {
          var key = event.key;
          if (key === "Enter") {
            var clickSequence = this.getClickSequence();
            if (clickSequence.length > 1) {
              var lineStringToAdd = {
                type: "LineString",
                coordinates: _toConsumableArray(clickSequence)
              };
              this.resetClickSequence();
              var editAction = this.getAddFeatureAction(lineStringToAdd, props.data);
              if (editAction) {
                props.onEdit(editAction);
              }
            }
          }
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var _guides$features;
          var lastPointerMoveEvent = props.lastPointerMoveEvent;
          var clickSequence = this.getClickSequence();
          var lastCoords = lastPointerMoveEvent ? [lastPointerMoveEvent.mapCoords] : [];
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          var tentativeFeature;
          if (clickSequence.length > 0) {
            tentativeFeature = {
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "LineString",
                coordinates: [].concat(_toConsumableArray(clickSequence), lastCoords)
              }
            };
          }
          if (tentativeFeature) {
            guides.features.push(tentativeFeature);
          }
          var editHandles = clickSequence.map(function(clickedCoord, index) {
            return {
              type: "Feature",
              properties: {
                guideType: "editHandle",
                editHandleType: "existing",
                featureIndex: -1,
                positionIndexes: [index]
              },
              geometry: {
                type: "Point",
                coordinates: clickedCoord
              }
            };
          });
          (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(editHandles));
          return guides;
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
        }
      }]);
      return DrawLineStringMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.DrawLineStringMode = DrawLineStringMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-polygon-mode.js
var require_draw_polygon_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-polygon-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawPolygonMode = void 0;
    var _lineIntersect = _interopRequireDefault(require_js14());
    var _helpers = require_js();
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawPolygonMode = function(_GeoJsonEditMode) {
      _inherits(DrawPolygonMode2, _GeoJsonEditMode);
      var _super = _createSuper(DrawPolygonMode2);
      function DrawPolygonMode2() {
        _classCallCheck(this, DrawPolygonMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawPolygonMode2, [{
        key: "createTentativeFeature",
        value: function createTentativeFeature(props) {
          var lastPointerMoveEvent = props.lastPointerMoveEvent;
          var clickSequence = this.getClickSequence();
          var lastCoords = lastPointerMoveEvent ? [lastPointerMoveEvent.mapCoords] : [];
          var tentativeFeature;
          if (clickSequence.length === 1 || clickSequence.length === 2) {
            tentativeFeature = {
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "LineString",
                coordinates: [].concat(_toConsumableArray(clickSequence), lastCoords)
              }
            };
          } else if (clickSequence.length > 2) {
            tentativeFeature = {
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "Polygon",
                coordinates: [[].concat(_toConsumableArray(clickSequence), lastCoords, [clickSequence[0]])]
              }
            };
          }
          return tentativeFeature;
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var _guides$features;
          var clickSequence = this.getClickSequence();
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          var tentativeFeature = this.createTentativeFeature(props);
          if (tentativeFeature) {
            guides.features.push(tentativeFeature);
          }
          var editHandles = clickSequence.map(function(clickedCoord, index) {
            return {
              type: "Feature",
              properties: {
                guideType: "editHandle",
                editHandleType: "existing",
                featureIndex: -1,
                positionIndexes: [index]
              },
              geometry: {
                type: "Point",
                coordinates: clickedCoord
              }
            };
          });
          (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(editHandles));
          return guides;
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
          var picks = event.picks;
          var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);
          var clickSequence = this.getClickSequence();
          var overlappingLines = false;
          if (clickSequence.length > 2 && props.modeConfig && props.modeConfig.preventOverlappingLines) {
            var currentLine = (0, _helpers.lineString)([clickSequence[clickSequence.length - 1], event.mapCoords]);
            var otherLines = (0, _helpers.lineString)(_toConsumableArray(clickSequence.slice(0, clickSequence.length - 1)));
            var intersectingPoints = (0, _lineIntersect["default"])(currentLine, otherLines);
            if (intersectingPoints.features.length > 0) {
              overlappingLines = true;
            }
          }
          var positionAdded = false;
          if (!clickedEditHandle && !overlappingLines) {
            this.addClickSequence(event);
            positionAdded = true;
          }
          if (clickSequence.length > 2 && clickedEditHandle && Array.isArray(clickedEditHandle.properties.positionIndexes) && (clickedEditHandle.properties.positionIndexes[0] === 0 || clickedEditHandle.properties.positionIndexes[0] === clickSequence.length - 1)) {
            var polygonToAdd = {
              type: "Polygon",
              coordinates: [[].concat(_toConsumableArray(clickSequence), [clickSequence[0]])]
            };
            this.resetClickSequence();
            var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);
            if (editAction) {
              props.onEdit(editAction);
            }
          } else if (positionAdded) {
            props.onEdit({
              // data is the same
              updatedData: props.data,
              editType: "addTentativePosition",
              editContext: {
                position: event.mapCoords
              }
            });
          }
        }
      }, {
        key: "handleKeyUp",
        value: function handleKeyUp(event, props) {
          if (event.key === "Enter") {
            var clickSequence = this.getClickSequence();
            if (clickSequence.length > 2) {
              var polygonToAdd = {
                type: "Polygon",
                coordinates: [[].concat(_toConsumableArray(clickSequence), [clickSequence[0]])]
              };
              this.resetClickSequence();
              var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);
              if (editAction) {
                props.onEdit(editAction);
              }
            }
          }
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
          _get(_getPrototypeOf(DrawPolygonMode2.prototype), "handlePointerMove", this).call(this, event, props);
        }
      }]);
      return DrawPolygonMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.DrawPolygonMode = DrawPolygonMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/two-click-polygon-mode.js
var require_two_click_polygon_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/two-click-polygon-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TwoClickPolygonMode = void 0;
    var _geojsonEditMode = require_geojson_edit_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var TwoClickPolygonMode = function(_GeoJsonEditMode) {
      _inherits(TwoClickPolygonMode2, _GeoJsonEditMode);
      var _super = _createSuper(TwoClickPolygonMode2);
      function TwoClickPolygonMode2() {
        _classCallCheck(this, TwoClickPolygonMode2);
        return _super.apply(this, arguments);
      }
      _createClass(TwoClickPolygonMode2, [{
        key: "handleClick",
        value: function handleClick(event, props) {
          if (props.modeConfig && props.modeConfig.dragToDraw) {
            return;
          }
          this.addClickSequence(event);
          this.checkAndFinishPolygon(props);
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          if (!props.modeConfig || !props.modeConfig.dragToDraw) {
            return;
          }
          this.addClickSequence(event);
          event.cancelPan();
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          if (!props.modeConfig || !props.modeConfig.dragToDraw) {
            return;
          }
          this.addClickSequence(event);
          this.checkAndFinishPolygon(props);
        }
      }, {
        key: "checkAndFinishPolygon",
        value: function checkAndFinishPolygon(props) {
          var clickSequence = this.getClickSequence();
          var tentativeFeature = this.getTentativeGuide(props);
          if (clickSequence.length > 1 && tentativeFeature && tentativeFeature.geometry.type === "Polygon") {
            var feature2 = {
              type: "Feature",
              properties: {
                shape: tentativeFeature.properties.shape
              },
              geometry: {
                type: "Polygon",
                coordinates: tentativeFeature.geometry.coordinates
              }
            };
            var editAction = this.getAddFeatureOrBooleanPolygonAction(feature2, props);
            this.resetClickSequence();
            if (editAction) {
              props.onEdit(editAction);
            }
          }
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var lastPointerMoveEvent = props.lastPointerMoveEvent, modeConfig = props.modeConfig;
          var clickSequence = this.getClickSequence();
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          if (clickSequence.length === 0) {
            return guides;
          }
          var corner1 = clickSequence[0];
          var corner2 = lastPointerMoveEvent.mapCoords;
          var polygon = this.getTwoClickPolygon(corner1, corner2, modeConfig);
          if (polygon) {
            guides.features.push({
              type: "Feature",
              properties: {
                shape: polygon.properties && polygon.properties.shape,
                guideType: "tentative"
              },
              geometry: polygon.geometry
            });
          }
          return guides;
        }
      }, {
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          return null;
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
          _get(_getPrototypeOf(TwoClickPolygonMode2.prototype), "handlePointerMove", this).call(this, event, props);
        }
      }, {
        key: "createTentativeFeature",
        value: function createTentativeFeature(props) {
          var lastPointerMoveEvent = props.lastPointerMoveEvent;
          var clickSequence = this.getClickSequence();
          var lastCoords = lastPointerMoveEvent ? [lastPointerMoveEvent.mapCoords] : [];
          var tentativeFeature;
          if (clickSequence.length === 1) {
            tentativeFeature = this.getTwoClickPolygon(clickSequence[0], lastCoords[0], props.modeConfig);
          }
          return tentativeFeature;
        }
      }]);
      return TwoClickPolygonMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.TwoClickPolygonMode = TwoClickPolygonMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-rectangle-mode.js
var require_draw_rectangle_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-rectangle-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawRectangleMode = void 0;
    var _bboxPolygon = _interopRequireDefault(require_js22());
    var _twoClickPolygonMode = require_two_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawRectangleMode = function(_TwoClickPolygonMode) {
      _inherits(DrawRectangleMode2, _TwoClickPolygonMode);
      var _super = _createSuper(DrawRectangleMode2);
      function DrawRectangleMode2() {
        _classCallCheck(this, DrawRectangleMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawRectangleMode2, [{
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          var rectangle = (0, _bboxPolygon["default"])([coord1[0], coord1[1], coord2[0], coord2[1]]);
          rectangle.properties = rectangle.properties || {};
          rectangle.properties.shape = "Rectangle";
          return rectangle;
        }
      }]);
      return DrawRectangleMode2;
    }(_twoClickPolygonMode.TwoClickPolygonMode);
    exports.DrawRectangleMode = DrawRectangleMode;
  }
});

// node_modules/@turf/along/dist/js/index.js
var require_js29 = __commonJS({
  "node_modules/@turf/along/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bearing_1 = __importDefault(require_js9());
    var destination_1 = __importDefault(require_js8());
    var distance_1 = __importDefault(require_js10());
    var helpers_1 = require_js();
    var invariant_1 = require_js4();
    function along(line, distance, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = invariant_1.getGeom(line);
      var coords = geom.coordinates;
      var travelled = 0;
      for (var i = 0; i < coords.length; i++) {
        if (distance >= travelled && i === coords.length - 1) {
          break;
        } else if (travelled >= distance) {
          var overshot = distance - travelled;
          if (!overshot) {
            return helpers_1.point(coords[i]);
          } else {
            var direction = bearing_1.default(coords[i], coords[i - 1]) - 180;
            var interpolated = destination_1.default(coords[i], overshot, direction, options);
            return interpolated;
          }
        } else {
          travelled += distance_1.default(coords[i], coords[i + 1], options);
        }
      }
      return helpers_1.point(coords[coords.length - 1]);
    }
    exports.default = along;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-square-mode.js
var require_draw_square_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-square-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawSquareMode = void 0;
    var _bboxPolygon = _interopRequireDefault(require_js22());
    var _distance = _interopRequireDefault(require_js10());
    var _along = _interopRequireDefault(require_js29());
    var _helpers = require_js();
    var _twoClickPolygonMode = require_two_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawSquareMode = function(_TwoClickPolygonMode) {
      _inherits(DrawSquareMode2, _TwoClickPolygonMode);
      var _super = _createSuper(DrawSquareMode2);
      function DrawSquareMode2() {
        _classCallCheck(this, DrawSquareMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawSquareMode2, [{
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          var coord3 = [coord2[0], coord1[1]];
          var coord4 = [coord1[0], coord2[1]];
          var distance1 = (0, _distance["default"])((0, _helpers.point)(coord3), (0, _helpers.point)(coord1));
          var distance2 = (0, _distance["default"])((0, _helpers.point)(coord4), (0, _helpers.point)(coord1));
          var shortestDistance = distance1 <= distance2 ? distance1 : distance2;
          var closestPoint = distance1 <= distance2 ? coord3 : coord4;
          var line = (0, _helpers.lineString)([closestPoint, coord2]);
          var newPoint = (0, _along["default"])(line, shortestDistance);
          var corner = newPoint.geometry.coordinates;
          var square = (0, _bboxPolygon["default"])([coord1[0], coord1[1], corner[0], corner[1]]);
          square.properties = square.properties || {};
          square.properties.shape = "Square";
          return square;
        }
      }]);
      return DrawSquareMode2;
    }(_twoClickPolygonMode.TwoClickPolygonMode);
    exports.DrawSquareMode = DrawSquareMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-rectangle-from-center-mode.js
var require_draw_rectangle_from_center_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-rectangle-from-center-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawRectangleFromCenterMode = void 0;
    var _bboxPolygon = _interopRequireDefault(require_js22());
    var _twoClickPolygonMode = require_two_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawRectangleFromCenterMode = function(_TwoClickPolygonMode) {
      _inherits(DrawRectangleFromCenterMode2, _TwoClickPolygonMode);
      var _super = _createSuper(DrawRectangleFromCenterMode2);
      function DrawRectangleFromCenterMode2() {
        _classCallCheck(this, DrawRectangleFromCenterMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawRectangleFromCenterMode2, [{
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          var longitude = coord1[0] > coord2[0] ? coord1[0] + Math.abs(coord1[0] - coord2[0]) : coord1[0] - Math.abs(coord1[0] - coord2[0]);
          var latitude = coord1[1] > coord2[1] ? coord1[1] + Math.abs(coord1[1] - coord2[1]) : coord1[1] - Math.abs(coord1[1] - coord2[1]);
          var rectangle = (0, _bboxPolygon["default"])([longitude, latitude, coord2[0], coord2[1]]);
          rectangle.properties = rectangle.properties || {};
          rectangle.properties.shape = "Rectangle";
          return rectangle;
        }
      }]);
      return DrawRectangleFromCenterMode2;
    }(_twoClickPolygonMode.TwoClickPolygonMode);
    exports.DrawRectangleFromCenterMode = DrawRectangleFromCenterMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-square-from-center-mode.js
var require_draw_square_from_center_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-square-from-center-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawSquareFromCenterMode = void 0;
    var _bboxPolygon = _interopRequireDefault(require_js22());
    var _distance = _interopRequireDefault(require_js10());
    var _along = _interopRequireDefault(require_js29());
    var _helpers = require_js();
    var _twoClickPolygonMode = require_two_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawSquareFromCenterMode = function(_TwoClickPolygonMode) {
      _inherits(DrawSquareFromCenterMode2, _TwoClickPolygonMode);
      var _super = _createSuper(DrawSquareFromCenterMode2);
      function DrawSquareFromCenterMode2() {
        _classCallCheck(this, DrawSquareFromCenterMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawSquareFromCenterMode2, [{
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          var coord3 = [coord2[0], coord1[1]];
          var coord4 = [coord1[0], coord2[1]];
          var distance1 = (0, _distance["default"])((0, _helpers.point)(coord3), (0, _helpers.point)(coord1));
          var distance2 = (0, _distance["default"])((0, _helpers.point)(coord4), (0, _helpers.point)(coord1));
          var shortestDistance = distance1 <= distance2 ? distance1 : distance2;
          var closestPoint = distance1 <= distance2 ? coord3 : coord4;
          var line = (0, _helpers.lineString)([closestPoint, coord2]);
          var newPoint = (0, _along["default"])(line, shortestDistance);
          var corner = newPoint.geometry.coordinates;
          var longitude = coord1[0] > corner[0] ? coord1[0] + Math.abs(coord1[0] - corner[0]) : coord1[0] - Math.abs(coord1[0] - corner[0]);
          var latitude = coord1[1] > corner[1] ? coord1[1] + Math.abs(coord1[1] - corner[1]) : coord1[1] - Math.abs(coord1[1] - corner[1]);
          var square = (0, _bboxPolygon["default"])([longitude, latitude, corner[0], corner[1]]);
          square.properties = square.properties || {};
          square.properties.shape = "Square";
          return square;
        }
      }]);
      return DrawSquareFromCenterMode2;
    }(_twoClickPolygonMode.TwoClickPolygonMode);
    exports.DrawSquareFromCenterMode = DrawSquareFromCenterMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-circle-by-diameter-mode.js
var require_draw_circle_by_diameter_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-circle-by-diameter-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawCircleByDiameterMode = void 0;
    var _circle = _interopRequireDefault(require_js16());
    var _distance = _interopRequireDefault(require_js10());
    var _geojsonEditMode = require_geojson_edit_mode();
    var _twoClickPolygonMode = require_two_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawCircleByDiameterMode = function(_TwoClickPolygonMode) {
      _inherits(DrawCircleByDiameterMode2, _TwoClickPolygonMode);
      var _super = _createSuper(DrawCircleByDiameterMode2);
      function DrawCircleByDiameterMode2() {
        _classCallCheck(this, DrawCircleByDiameterMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawCircleByDiameterMode2, [{
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          var _ref = modeConfig || {}, _ref$steps = _ref.steps, steps = _ref$steps === void 0 ? 64 : _ref$steps;
          var options = {
            steps
          };
          if (steps < 4) {
            console.warn("Minimum steps to draw a circle is 4 ");
            options.steps = 4;
          }
          var centerCoordinates = (0, _geojsonEditMode.getIntermediatePosition)(coord1, coord2);
          var radius = Math.max((0, _distance["default"])(coord1, centerCoordinates), 1e-3);
          var geometry = (0, _circle["default"])(centerCoordinates, radius, options);
          geometry.properties = geometry.properties || {};
          geometry.properties.shape = "Circle";
          return geometry;
        }
      }]);
      return DrawCircleByDiameterMode2;
    }(_twoClickPolygonMode.TwoClickPolygonMode);
    exports.DrawCircleByDiameterMode = DrawCircleByDiameterMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-circle-from-center-mode.js
var require_draw_circle_from_center_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-circle-from-center-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawCircleFromCenterMode = void 0;
    var _circle = _interopRequireDefault(require_js16());
    var _distance = _interopRequireDefault(require_js10());
    var _twoClickPolygonMode = require_two_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawCircleFromCenterMode = function(_TwoClickPolygonMode) {
      _inherits(DrawCircleFromCenterMode2, _TwoClickPolygonMode);
      var _super = _createSuper(DrawCircleFromCenterMode2);
      function DrawCircleFromCenterMode2() {
        _classCallCheck(this, DrawCircleFromCenterMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawCircleFromCenterMode2, [{
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          var _ref = modeConfig || {}, _ref$steps = _ref.steps, steps = _ref$steps === void 0 ? 64 : _ref$steps;
          var options = {
            steps
          };
          if (steps < 4) {
            console.warn("Minimum steps to draw a circle is 4 ");
            options.steps = 4;
          }
          var radius = Math.max((0, _distance["default"])(coord1, coord2), 1e-3);
          var geometry = (0, _circle["default"])(coord1, radius, options);
          geometry.properties = geometry.properties || {};
          geometry.properties.shape = "Circle";
          return geometry;
        }
      }]);
      return DrawCircleFromCenterMode2;
    }(_twoClickPolygonMode.TwoClickPolygonMode);
    exports.DrawCircleFromCenterMode = DrawCircleFromCenterMode;
  }
});

// node_modules/@turf/ellipse/dist/js/index.js
var require_js30 = __commonJS({
  "node_modules/@turf/ellipse/dist/js/index.js"(exports, module) {
    "use strict";
    var helpers = require_js();
    var rhumbDestination = require_js19();
    var transformRotate = require_js26();
    var invariant = require_js4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var rhumbDestination__default = _interopDefaultLegacy(rhumbDestination);
    var transformRotate__default = _interopDefaultLegacy(transformRotate);
    function ellipse(center, xSemiAxis, ySemiAxis, options) {
      options = options || {};
      var steps = options.steps || 64;
      var units = options.units || "kilometers";
      var angle = options.angle || 0;
      var pivot = options.pivot || center;
      var properties = options.properties || center.properties || {};
      if (!center)
        throw new Error("center is required");
      if (!xSemiAxis)
        throw new Error("xSemiAxis is required");
      if (!ySemiAxis)
        throw new Error("ySemiAxis is required");
      if (!helpers.isObject(options))
        throw new Error("options must be an object");
      if (!helpers.isNumber(steps))
        throw new Error("steps must be a number");
      if (!helpers.isNumber(angle))
        throw new Error("angle must be a number");
      var centerCoords = invariant.getCoord(center);
      if (units === "degrees") {
        var angleRad = helpers.degreesToRadians(angle);
      } else {
        xSemiAxis = rhumbDestination__default["default"](center, xSemiAxis, 90, { units });
        ySemiAxis = rhumbDestination__default["default"](center, ySemiAxis, 0, { units });
        xSemiAxis = invariant.getCoord(xSemiAxis)[0] - centerCoords[0];
        ySemiAxis = invariant.getCoord(ySemiAxis)[1] - centerCoords[1];
      }
      var coordinates = [];
      for (var i = 0; i < steps; i += 1) {
        var stepAngle = i * -360 / steps;
        var x = xSemiAxis * ySemiAxis / Math.sqrt(
          Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)
        );
        var y = xSemiAxis * ySemiAxis / Math.sqrt(
          Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)
        );
        if (stepAngle < -90 && stepAngle >= -270)
          x = -x;
        if (stepAngle < -180 && stepAngle >= -360)
          y = -y;
        if (units === "degrees") {
          var newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);
          var newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);
          x = newx;
          y = newy;
        }
        coordinates.push([x + centerCoords[0], y + centerCoords[1]]);
      }
      coordinates.push(coordinates[0]);
      if (units === "degrees") {
        return helpers.polygon([coordinates], properties);
      } else {
        return transformRotate__default["default"](helpers.polygon([coordinates], properties), angle, {
          pivot
        });
      }
    }
    function getTanDeg(deg) {
      var rad = deg * Math.PI / 180;
      return Math.tan(rad);
    }
    module.exports = ellipse;
    module.exports.default = ellipse;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-ellipse-by-bounding-box-mode.js
var require_draw_ellipse_by_bounding_box_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-ellipse-by-bounding-box-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawEllipseByBoundingBoxMode = void 0;
    var _bboxPolygon = _interopRequireDefault(require_js22());
    var _distance = _interopRequireDefault(require_js10());
    var _ellipse = _interopRequireDefault(require_js30());
    var _helpers = require_js();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _twoClickPolygonMode = require_two_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawEllipseByBoundingBoxMode = function(_TwoClickPolygonMode) {
      _inherits(DrawEllipseByBoundingBoxMode2, _TwoClickPolygonMode);
      var _super = _createSuper(DrawEllipseByBoundingBoxMode2);
      function DrawEllipseByBoundingBoxMode2() {
        _classCallCheck(this, DrawEllipseByBoundingBoxMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawEllipseByBoundingBoxMode2, [{
        key: "getTwoClickPolygon",
        value: function getTwoClickPolygon(coord1, coord2, modeConfig) {
          var minX = Math.min(coord1[0], coord2[0]);
          var minY = Math.min(coord1[1], coord2[1]);
          var maxX = Math.max(coord1[0], coord2[0]);
          var maxY = Math.max(coord1[1], coord2[1]);
          var polygonPoints = (0, _bboxPolygon["default"])([minX, minY, maxX, maxY]).geometry.coordinates[0];
          var centerCoordinates = (0, _geojsonEditMode.getIntermediatePosition)(coord1, coord2);
          var xSemiAxis = Math.max((0, _distance["default"])((0, _helpers.point)(polygonPoints[0]), (0, _helpers.point)(polygonPoints[1])), 1e-3);
          var ySemiAxis = Math.max((0, _distance["default"])((0, _helpers.point)(polygonPoints[0]), (0, _helpers.point)(polygonPoints[3])), 1e-3);
          return (0, _ellipse["default"])(centerCoordinates, xSemiAxis, ySemiAxis);
        }
      }]);
      return DrawEllipseByBoundingBoxMode2;
    }(_twoClickPolygonMode.TwoClickPolygonMode);
    exports.DrawEllipseByBoundingBoxMode = DrawEllipseByBoundingBoxMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/three-click-polygon-mode.js
var require_three_click_polygon_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/three-click-polygon-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ThreeClickPolygonMode = void 0;
    var _geojsonEditMode = require_geojson_edit_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ThreeClickPolygonMode = function(_GeoJsonEditMode) {
      _inherits(ThreeClickPolygonMode2, _GeoJsonEditMode);
      var _super = _createSuper(ThreeClickPolygonMode2);
      function ThreeClickPolygonMode2() {
        _classCallCheck(this, ThreeClickPolygonMode2);
        return _super.apply(this, arguments);
      }
      _createClass(ThreeClickPolygonMode2, [{
        key: "handleClick",
        value: function handleClick(event, props) {
          this.addClickSequence(event);
          var clickSequence = this.getClickSequence();
          var tentativeFeature = this.getTentativeGuide(props);
          if (clickSequence.length > 2 && tentativeFeature && tentativeFeature.geometry.type === "Polygon") {
            var editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry, props);
            this.resetClickSequence();
            if (editAction) {
              props.onEdit(editAction);
            }
          }
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var lastPointerMoveEvent = props.lastPointerMoveEvent, modeConfig = props.modeConfig;
          var clickSequence = this.getClickSequence();
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          if (clickSequence.length === 0) {
            return guides;
          }
          var hoveredCoord = lastPointerMoveEvent.mapCoords;
          if (clickSequence.length === 1) {
            guides.features.push({
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "LineString",
                coordinates: [clickSequence[0], hoveredCoord]
              }
            });
          } else {
            var polygon = this.getThreeClickPolygon(clickSequence[0], clickSequence[1], hoveredCoord, modeConfig);
            if (polygon) {
              guides.features.push({
                type: "Feature",
                properties: {
                  guideType: "tentative"
                },
                geometry: polygon.geometry
              });
            }
          }
          return guides;
        }
      }, {
        key: "getThreeClickPolygon",
        value: function getThreeClickPolygon(coord1, coord2, coord3, modeConfig) {
          return null;
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
          _get(_getPrototypeOf(ThreeClickPolygonMode2.prototype), "handlePointerMove", this).call(this, event, props);
        }
      }, {
        key: "createTentativeFeature",
        value: function createTentativeFeature(props) {
          var lastPointerMoveEvent = props.lastPointerMoveEvent;
          var clickSequence = this.getClickSequence();
          var lastCoords = lastPointerMoveEvent ? [lastPointerMoveEvent.mapCoords] : [];
          var tentativeFeature;
          if (clickSequence.length === 2) {
            tentativeFeature = this.getThreeClickPolygon(clickSequence[0], clickSequence[1], lastCoords[0], props.modeConfig);
          }
          return tentativeFeature;
        }
      }]);
      return ThreeClickPolygonMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.ThreeClickPolygonMode = ThreeClickPolygonMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-ellipse-using-three-points-mode.js
var require_draw_ellipse_using_three_points_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-ellipse-using-three-points-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawEllipseUsingThreePointsMode = void 0;
    var _distance = _interopRequireDefault(require_js10());
    var _ellipse = _interopRequireDefault(require_js30());
    var _bearing = _interopRequireDefault(require_js9());
    var _helpers = require_js();
    var _geojsonEditMode = require_geojson_edit_mode();
    var _threeClickPolygonMode = require_three_click_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawEllipseUsingThreePointsMode = function(_ThreeClickPolygonMod) {
      _inherits(DrawEllipseUsingThreePointsMode2, _ThreeClickPolygonMod);
      var _super = _createSuper(DrawEllipseUsingThreePointsMode2);
      function DrawEllipseUsingThreePointsMode2() {
        _classCallCheck(this, DrawEllipseUsingThreePointsMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawEllipseUsingThreePointsMode2, [{
        key: "getThreeClickPolygon",
        value: function getThreeClickPolygon(coord1, coord2, coord3, modeConfig) {
          var centerCoordinates = (0, _geojsonEditMode.getIntermediatePosition)(coord1, coord2);
          var xSemiAxis = Math.max((0, _distance["default"])(centerCoordinates, (0, _helpers.point)(coord3)), 1e-3);
          var ySemiAxis = Math.max((0, _distance["default"])(coord1, coord2), 1e-3) / 2;
          var options = {
            angle: (0, _bearing["default"])(coord1, coord2)
          };
          return (0, _ellipse["default"])(centerCoordinates, xSemiAxis, ySemiAxis, options);
        }
      }]);
      return DrawEllipseUsingThreePointsMode2;
    }(_threeClickPolygonMode.ThreeClickPolygonMode);
    exports.DrawEllipseUsingThreePointsMode = DrawEllipseUsingThreePointsMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-rectangle-using-three-points-mode.js
var require_draw_rectangle_using_three_points_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-rectangle-using-three-points-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawRectangleUsingThreePointsMode = void 0;
    var _utils = require_utils();
    var _threeClickPolygonMode = require_three_click_polygon_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DrawRectangleUsingThreePointsMode = function(_ThreeClickPolygonMod) {
      _inherits(DrawRectangleUsingThreePointsMode2, _ThreeClickPolygonMod);
      var _super = _createSuper(DrawRectangleUsingThreePointsMode2);
      function DrawRectangleUsingThreePointsMode2() {
        _classCallCheck(this, DrawRectangleUsingThreePointsMode2);
        return _super.apply(this, arguments);
      }
      _createClass(DrawRectangleUsingThreePointsMode2, [{
        key: "getThreeClickPolygon",
        value: function getThreeClickPolygon(coord1, coord2, coord3, modeConfig) {
          var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(coord1, coord2, coord3), _generatePointsParall2 = _slicedToArray(_generatePointsParall, 2), p3 = _generatePointsParall2[0], p4 = _generatePointsParall2[1];
          return {
            type: "Feature",
            properties: {
              shape: "Rectangle"
            },
            geometry: {
              type: "Polygon",
              coordinates: [[
                // Draw a polygon containing all the points of the LineString,
                // then the points orthogonal to the lineString,
                // then back to the starting position
                coord1,
                coord2,
                p3,
                p4,
                coord1
              ]]
            }
          };
        }
      }]);
      return DrawRectangleUsingThreePointsMode2;
    }(_threeClickPolygonMode.ThreeClickPolygonMode);
    exports.DrawRectangleUsingThreePointsMode = DrawRectangleUsingThreePointsMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-90degree-polygon-mode.js
var require_draw_90degree_polygon_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-90degree-polygon-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Draw90DegreePolygonMode = void 0;
    var _destination = _interopRequireDefault(require_js8());
    var _bearing = _interopRequireDefault(require_js9());
    var _lineIntersect = _interopRequireDefault(require_js14());
    var _distance = _interopRequireDefault(require_js10());
    var _helpers = require_js();
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Draw90DegreePolygonMode = function(_GeoJsonEditMode) {
      _inherits(Draw90DegreePolygonMode2, _GeoJsonEditMode);
      var _super = _createSuper(Draw90DegreePolygonMode2);
      function Draw90DegreePolygonMode2() {
        _classCallCheck(this, Draw90DegreePolygonMode2);
        return _super.apply(this, arguments);
      }
      _createClass(Draw90DegreePolygonMode2, [{
        key: "createTentativeFeature",
        value: function createTentativeFeature(props) {
          var clickSequence = this.getClickSequence();
          var mapCoords = props.lastPointerMoveEvent.mapCoords;
          var p3;
          if (clickSequence.length === 1) {
            p3 = mapCoords;
          } else {
            var p1 = clickSequence[clickSequence.length - 2];
            var p2 = clickSequence[clickSequence.length - 1];
            var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, mapCoords);
            var _generatePointsParall2 = _slicedToArray(_generatePointsParall, 1);
            p3 = _generatePointsParall2[0];
          }
          var tentativeFeature;
          if (clickSequence.length < 3) {
            tentativeFeature = {
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "LineString",
                coordinates: [].concat(_toConsumableArray(clickSequence), [p3])
              }
            };
          } else {
            tentativeFeature = {
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "Polygon",
                coordinates: [[].concat(_toConsumableArray(clickSequence), [p3, clickSequence[0]])]
              }
            };
          }
          return tentativeFeature;
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          var clickSequence = this.getClickSequence();
          if (clickSequence.length === 0 || !props.lastPointerMoveEvent) {
            return guides;
          }
          var tentativeFeature = this.createTentativeFeature(props);
          guides.features.push(tentativeFeature);
          guides.features = guides.features.concat((0, _utils.getEditHandlesForGeometry)(tentativeFeature.geometry, -1));
          guides.features = guides.features.slice(0, -1);
          return guides;
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
          _get(_getPrototypeOf(Draw90DegreePolygonMode2.prototype), "handlePointerMove", this).call(this, event, props);
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
          var picks = event.picks;
          var tentativeFeature = this.getTentativeGuide(props);
          this.addClickSequence(event);
          var clickSequence = this.getClickSequence();
          if (!tentativeFeature) {
            return;
          }
          if (clickSequence.length === 3 && tentativeFeature.geometry.type === "LineString") {
            var lineString2 = tentativeFeature.geometry;
            clickSequence[clickSequence.length - 1] = lineString2.coordinates[lineString2.coordinates.length - 1];
          } else if (clickSequence.length > 3 && tentativeFeature.geometry.type === "Polygon") {
            var polygon = tentativeFeature.geometry;
            clickSequence[clickSequence.length - 1] = polygon.coordinates[0][polygon.coordinates[0].length - 2];
            var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);
            if (clickedEditHandle && Array.isArray(clickedEditHandle.properties.positionIndexes) && (clickedEditHandle.properties.positionIndexes[1] === 0 || clickedEditHandle.properties.positionIndexes[1] === polygon.coordinates[0].length - 3)) {
              var polygonToAdd = {
                type: "Polygon",
                coordinates: this.finalizedCoordinates(_toConsumableArray(polygon.coordinates[0]))
              };
              this.resetClickSequence();
              var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);
              if (editAction) {
                props.onEdit(editAction);
              }
            }
          }
          var fakePointerMoveEvent = {
            screenCoords: [-1, -1],
            mapCoords: event.mapCoords,
            picks: [],
            pointerDownPicks: null,
            pointerDownScreenCoords: null,
            pointerDownMapCoords: null,
            cancelPan: function cancelPan() {
            },
            sourceEvent: null
          };
          this.handlePointerMove(fakePointerMoveEvent, props);
        }
      }, {
        key: "finalizedCoordinates",
        value: function finalizedCoordinates(coords) {
          var coordinates = [[].concat(_toConsumableArray(coords.slice(0, -2)), [coords[0]])];
          var pt = this.getIntermediatePoint(_toConsumableArray(coords));
          if (!pt) {
            var tc = _toConsumableArray(coords);
            tc.splice(-3, 1);
            pt = this.getIntermediatePoint(_toConsumableArray(tc));
            if (pt) {
              coordinates = [[].concat(_toConsumableArray(coords.slice(0, -3)), [pt, coords[0]])];
            }
          } else {
            coordinates = [[].concat(_toConsumableArray(coords.slice(0, -2)), [pt, coords[0]])];
          }
          return coordinates;
        }
      }, {
        key: "getIntermediatePoint",
        value: function getIntermediatePoint(coordinates) {
          var pt;
          if (coordinates.length > 4) {
            var _ref = _toConsumableArray(coordinates), p1 = _ref[0], p2 = _ref[1];
            var angle1 = (0, _bearing["default"])(p1, p2);
            var p3 = coordinates[coordinates.length - 3];
            var p4 = coordinates[coordinates.length - 4];
            var angle2 = (0, _bearing["default"])(p3, p4);
            var angles = {
              first: [],
              second: []
            };
            [1, 2, 3].forEach(function(factor) {
              var newAngle1 = angle1 + factor * 90;
              angles.first.push(newAngle1 > 180 ? newAngle1 - 360 : newAngle1);
              var newAngle2 = angle2 + factor * 90;
              angles.second.push(newAngle2 > 180 ? newAngle2 - 360 : newAngle2);
            });
            var distance = (0, _distance["default"])((0, _helpers.point)(p1), (0, _helpers.point)(p3));
            [0, 1, 2].forEach(function(indexFirst) {
              var line1 = (0, _helpers.lineString)([p1, (0, _destination["default"])(p1, distance, angles.first[indexFirst]).geometry.coordinates]);
              [0, 1, 2].forEach(function(indexSecond) {
                var line2 = (0, _helpers.lineString)([p3, (0, _destination["default"])(p3, distance, angles.second[indexSecond]).geometry.coordinates]);
                var fc = (0, _lineIntersect["default"])(line1, line2);
                if (fc && fc.features.length) {
                  pt = fc.features[0].geometry.coordinates;
                }
              });
            });
          }
          return pt;
        }
      }]);
      return Draw90DegreePolygonMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.Draw90DegreePolygonMode = Draw90DegreePolygonMode;
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-polygon-by-dragging-mode.js
var require_draw_polygon_by_dragging_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/draw-polygon-by-dragging-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DrawPolygonByDraggingMode = void 0;
    var _lodash = _interopRequireDefault(require_lodash());
    var _utils = require_utils();
    var _drawPolygonMode = require_draw_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DrawPolygonByDraggingMode = function(_DrawPolygonMode) {
      _inherits(DrawPolygonByDraggingMode2, _DrawPolygonMode);
      var _super = _createSuper(DrawPolygonByDraggingMode2);
      function DrawPolygonByDraggingMode2() {
        var _this;
        _classCallCheck(this, DrawPolygonByDraggingMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "handleDraggingThrottled", null);
        return _this;
      }
      _createClass(DrawPolygonByDraggingMode2, [{
        key: "handleClick",
        value: function handleClick(event, props) {
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          event.cancelPan();
          if (props.modeConfig && props.modeConfig.throttleMs) {
            this.handleDraggingThrottled = (0, _lodash["default"])(this.handleDraggingAux, props.modeConfig.throttleMs);
          } else {
            this.handleDraggingThrottled = this.handleDraggingAux;
          }
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          this.addClickSequence(event);
          var clickSequence = this.getClickSequence();
          if (this.handleDraggingThrottled && this.handleDraggingThrottled.cancel) {
            this.handleDraggingThrottled.cancel();
          }
          if (clickSequence.length > 2) {
            var polygonToAdd = {
              type: "Polygon",
              coordinates: [[].concat(_toConsumableArray(clickSequence), [clickSequence[0]])]
            };
            this.resetClickSequence();
            var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);
            if (editAction) {
              props.onEdit(editAction);
            }
          }
        }
      }, {
        key: "handleDraggingAux",
        value: function handleDraggingAux(event, props) {
          var picks = event.picks;
          var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);
          if (!clickedEditHandle) {
            this.addClickSequence(event);
          }
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
          if (this.handleDraggingThrottled) {
            this.handleDraggingThrottled(event, props);
          }
        }
      }]);
      return DrawPolygonByDraggingMode2;
    }(_drawPolygonMode.DrawPolygonMode);
    exports.DrawPolygonByDraggingMode = DrawPolygonByDraggingMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/view-mode.js
var require_view_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/view-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ViewMode = void 0;
    var _geojsonEditMode = require_geojson_edit_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ViewMode = function(_GeoJsonEditMode) {
      _inherits(ViewMode2, _GeoJsonEditMode);
      var _super = _createSuper(ViewMode2);
      function ViewMode2() {
        _classCallCheck(this, ViewMode2);
        return _super.apply(this, arguments);
      }
      return ViewMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.ViewMode = ViewMode;
  }
});

// node_modules/@turf/midpoint/dist/js/index.js
var require_js31 = __commonJS({
  "node_modules/@turf/midpoint/dist/js/index.js"(exports, module) {
    "use strict";
    var bearing = require_js9();
    var destination = require_js8();
    var distance = require_js10();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var bearing__default = _interopDefaultLegacy(bearing);
    var destination__default = _interopDefaultLegacy(destination);
    var distance__default = _interopDefaultLegacy(distance);
    function midpoint(point1, point2) {
      var dist = distance__default["default"](point1, point2);
      var heading = bearing__default["default"](point1, point2);
      var midpoint2 = destination__default["default"](point1, dist / 2, heading);
      return midpoint2;
    }
    module.exports = midpoint;
    module.exports.default = midpoint;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/measure-distance-mode.js
var require_measure_distance_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/measure-distance-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MeasureDistanceMode = void 0;
    var _distance = _interopRequireDefault(require_js10());
    var _midpoint = _interopRequireDefault(require_js31());
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var MeasureDistanceMode = function(_GeoJsonEditMode) {
      _inherits(MeasureDistanceMode2, _GeoJsonEditMode);
      var _super = _createSuper(MeasureDistanceMode2);
      function MeasureDistanceMode2() {
        var _this;
        _classCallCheck(this, MeasureDistanceMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "_isMeasuringSessionFinished", false);
        _defineProperty(_assertThisInitialized(_this), "_currentTooltips", []);
        _defineProperty(_assertThisInitialized(_this), "_currentDistance", 0);
        _defineProperty(_assertThisInitialized(_this), "_calculateDistanceForTooltip", function(_ref) {
          var positionA = _ref.positionA, positionB = _ref.positionB, modeConfig = _ref.modeConfig;
          var _ref2 = modeConfig || {}, turfOptions = _ref2.turfOptions, measurementCallback = _ref2.measurementCallback;
          var distance = (0, _distance["default"])(positionA, positionB, turfOptions);
          if (measurementCallback) {
            measurementCallback(distance);
          }
          return distance;
        });
        return _this;
      }
      _createClass(MeasureDistanceMode2, [{
        key: "_formatTooltip",
        value: function _formatTooltip(distance, modeConfig) {
          var _ref3 = modeConfig || {}, formatTooltip = _ref3.formatTooltip, turfOptions = _ref3.turfOptions;
          var units = turfOptions && turfOptions.units || "kilometers";
          var text;
          if (formatTooltip) {
            text = formatTooltip(distance);
          } else {
            text = "".concat(parseFloat(distance).toFixed(2), " ").concat(units);
          }
          return text;
        }
      }, {
        key: "handleClick",
        value: function handleClick(event, props) {
          var modeConfig = props.modeConfig, data = props.data, onEdit = props.onEdit;
          var _ref4 = modeConfig || {}, _ref4$centerTooltipsO = _ref4.centerTooltipsOnLine, centerTooltipsOnLine = _ref4$centerTooltipsO === void 0 ? false : _ref4$centerTooltipsO;
          if (this._isMeasuringSessionFinished) {
            this._isMeasuringSessionFinished = false;
            this.resetClickSequence();
            this._currentTooltips = [];
            this._currentDistance = 0;
          }
          var picks = event.picks;
          var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);
          var positionAdded = false;
          if (!clickedEditHandle) {
            this.addClickSequence(event);
            positionAdded = true;
          }
          var clickSequence = this.getClickSequence();
          if (clickSequence.length > 1 && clickedEditHandle && Array.isArray(clickedEditHandle.properties.positionIndexes) && clickedEditHandle.properties.positionIndexes[0] === clickSequence.length - 1) {
            this._isMeasuringSessionFinished = true;
          } else if (positionAdded) {
            if (clickSequence.length > 1) {
              this._currentDistance += this._calculateDistanceForTooltip({
                positionA: clickSequence[clickSequence.length - 2],
                positionB: clickSequence[clickSequence.length - 1],
                modeConfig
              });
              var tooltipPosition = centerTooltipsOnLine ? (0, _midpoint["default"])(clickSequence[clickSequence.length - 2], clickSequence[clickSequence.length - 1]).geometry.coordinates : event.mapCoords;
              this._currentTooltips.push({
                position: tooltipPosition,
                text: this._formatTooltip(this._currentDistance, modeConfig)
              });
            }
            onEdit({
              // data is the same
              updatedData: data,
              editType: "addTentativePosition",
              editContext: {
                position: event.mapCoords
              }
            });
          }
        }
      }, {
        key: "handleKeyUp",
        value: function handleKeyUp(event, props) {
          if (this._isMeasuringSessionFinished)
            return;
          event.stopPropagation();
          var key = event.key;
          var clickSequenceLength = this.getClickSequence().length;
          switch (key) {
            case "Escape":
              this._isMeasuringSessionFinished = true;
              if (clickSequenceLength === 1) {
                this.resetClickSequence();
                this._currentTooltips = [];
              }
              props.onUpdateCursor("cell");
              break;
            case "Enter":
              this.handleClick(props.lastPointerMoveEvent, props);
              this._isMeasuringSessionFinished = true;
              break;
            default:
              break;
          }
        }
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var _guides$features;
          var lastPointerMoveEvent = props.lastPointerMoveEvent;
          var clickSequence = this.getClickSequence();
          var lastCoords = lastPointerMoveEvent && !this._isMeasuringSessionFinished ? [lastPointerMoveEvent.mapCoords] : [];
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          if (clickSequence.length > 0) {
            guides.features.push({
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "LineString",
                coordinates: [].concat(_toConsumableArray(clickSequence), lastCoords)
              }
            });
          }
          var editHandles = clickSequence.map(function(clickedCoord, index) {
            return {
              type: "Feature",
              properties: {
                guideType: "editHandle",
                editHandleType: "existing",
                featureIndex: -1,
                positionIndexes: [index]
              },
              geometry: {
                type: "Point",
                coordinates: clickedCoord
              }
            };
          });
          (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(editHandles));
          return guides;
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
        }
      }, {
        key: "getTooltips",
        value: function getTooltips(props) {
          var lastPointerMoveEvent = props.lastPointerMoveEvent, modeConfig = props.modeConfig;
          var _ref5 = modeConfig || {}, _ref5$centerTooltipsO = _ref5.centerTooltipsOnLine, centerTooltipsOnLine = _ref5$centerTooltipsO === void 0 ? false : _ref5$centerTooltipsO;
          var positions = this.getClickSequence();
          if (positions.length > 0 && lastPointerMoveEvent && !this._isMeasuringSessionFinished) {
            var distance = this._calculateDistanceForTooltip({
              positionA: positions[positions.length - 1],
              positionB: lastPointerMoveEvent.mapCoords,
              modeConfig: props.modeConfig
            });
            var tooltipPosition = centerTooltipsOnLine ? (0, _midpoint["default"])(positions[positions.length - 1], lastPointerMoveEvent.mapCoords).geometry.coordinates : lastPointerMoveEvent.mapCoords;
            return [].concat(_toConsumableArray(this._currentTooltips), [{
              position: tooltipPosition,
              text: this._formatTooltip(this._currentDistance + distance, modeConfig)
            }]);
          }
          return this._currentTooltips;
        }
      }]);
      return MeasureDistanceMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.MeasureDistanceMode = MeasureDistanceMode;
  }
});

// node_modules/@turf/area/dist/js/index.js
var require_js32 = __commonJS({
  "node_modules/@turf/area/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var meta_1 = require_js2();
    var RADIUS = 6378137;
    function area(geojson) {
      return meta_1.geomReduce(geojson, function(value, geom) {
        return value + calculateArea(geom);
      }, 0);
    }
    exports.default = area;
    function calculateArea(geom) {
      var total = 0;
      var i;
      switch (geom.type) {
        case "Polygon":
          return polygonArea(geom.coordinates);
        case "MultiPolygon":
          for (i = 0; i < geom.coordinates.length; i++) {
            total += polygonArea(geom.coordinates[i]);
          }
          return total;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
          return 0;
      }
      return 0;
    }
    function polygonArea(coords) {
      var total = 0;
      if (coords && coords.length > 0) {
        total += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
          total -= Math.abs(ringArea(coords[i]));
        }
      }
      return total;
    }
    function ringArea(coords) {
      var p1;
      var p2;
      var p3;
      var lowerIndex;
      var middleIndex;
      var upperIndex;
      var i;
      var total = 0;
      var coordsLength = coords.length;
      if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
          if (i === coordsLength - 2) {
            lowerIndex = coordsLength - 2;
            middleIndex = coordsLength - 1;
            upperIndex = 0;
          } else if (i === coordsLength - 1) {
            lowerIndex = coordsLength - 1;
            middleIndex = 0;
            upperIndex = 1;
          } else {
            lowerIndex = i;
            middleIndex = i + 1;
            upperIndex = i + 2;
          }
          p1 = coords[lowerIndex];
          p2 = coords[middleIndex];
          p3 = coords[upperIndex];
          total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
        }
        total = total * RADIUS * RADIUS / 2;
      }
      return total;
    }
    function rad(num) {
      return num * Math.PI / 180;
    }
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/measure-area-mode.js
var require_measure_area_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/measure-area-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MeasureAreaMode = void 0;
    var _area = _interopRequireDefault(require_js32());
    var _centroid = _interopRequireDefault(require_js21());
    var _drawPolygonMode = require_draw_polygon_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var DEFAULT_TOOLTIPS = [];
    var MeasureAreaMode = function(_DrawPolygonMode) {
      _inherits(MeasureAreaMode2, _DrawPolygonMode);
      var _super = _createSuper(MeasureAreaMode2);
      function MeasureAreaMode2() {
        _classCallCheck(this, MeasureAreaMode2);
        return _super.apply(this, arguments);
      }
      _createClass(MeasureAreaMode2, [{
        key: "handleClick",
        value: function handleClick(event, props) {
          var propsWithoutEdit = _objectSpread({}, props, {
            // @ts-ignore
            onEdit: function onEdit() {
            }
          });
          _get(_getPrototypeOf(MeasureAreaMode2.prototype), "handleClick", this).call(this, event, propsWithoutEdit);
        }
      }, {
        key: "getTooltips",
        value: function getTooltips(props) {
          var tentativeGuide = this.getTentativeGuide(props);
          if (tentativeGuide && tentativeGuide.geometry.type === "Polygon") {
            var modeConfig = props.modeConfig;
            var _ref = modeConfig || {}, formatTooltip = _ref.formatTooltip, measurementCallback = _ref.measurementCallback;
            var units = "sq. m";
            var centroid = (0, _centroid["default"])(tentativeGuide);
            var area = (0, _area["default"])(tentativeGuide);
            var text;
            if (formatTooltip) {
              text = formatTooltip(area);
            } else {
              text = "".concat(parseFloat(area).toFixed(2), " ").concat(units);
            }
            if (measurementCallback) {
              measurementCallback(area);
            }
            return [{
              position: centroid.geometry.coordinates,
              text
            }];
          }
          return DEFAULT_TOOLTIPS;
        }
      }]);
      return MeasureAreaMode2;
    }(_drawPolygonMode.DrawPolygonMode);
    exports.MeasureAreaMode = MeasureAreaMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/memoize.js
var require_memoize = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/memoize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = memoize;
    function isEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (Array.isArray(a)) {
        var len = a.length;
        if (!b || b.length !== len) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    function memoize(compute) {
      var cachedArgs = {};
      var cachedResult;
      return function(args) {
        for (var key in args) {
          if (!isEqual(args[key], cachedArgs[key])) {
            cachedResult = compute(args);
            cachedArgs = args;
            break;
          }
        }
        return cachedResult;
      };
    }
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/measure-angle-mode.js
var require_measure_angle_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/measure-angle-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MeasureAngleMode = void 0;
    var _bearing = _interopRequireDefault(require_js9());
    var _center = _interopRequireDefault(require_js17());
    var _memoize = _interopRequireDefault(require_memoize());
    var _geojsonEditMode = require_geojson_edit_mode();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DEFAULT_TOOLTIPS = [];
    var MeasureAngleMode = function(_GeoJsonEditMode) {
      _inherits(MeasureAngleMode2, _GeoJsonEditMode);
      var _super = _createSuper(MeasureAngleMode2);
      function MeasureAngleMode2() {
        var _this;
        _classCallCheck(this, MeasureAngleMode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "_getTooltips", (0, _memoize["default"])(function(_ref) {
          var modeConfig = _ref.modeConfig, vertex = _ref.vertex, point1 = _ref.point1, point2 = _ref.point2;
          var tooltips = DEFAULT_TOOLTIPS;
          if (vertex && point1 && point2) {
            var _ref2 = modeConfig || {}, formatTooltip = _ref2.formatTooltip, measurementCallback = _ref2.measurementCallback;
            var units = "deg";
            var angle1 = (0, _bearing["default"])(vertex, point1);
            var angle2 = (0, _bearing["default"])(vertex, point2);
            var angle = Math.abs(angle1 - angle2);
            if (angle > 180) {
              angle = 360 - angle;
            }
            var text;
            if (formatTooltip) {
              text = formatTooltip(angle);
            } else {
              text = "".concat(parseFloat(angle).toFixed(2), " ").concat(units);
            }
            if (measurementCallback) {
              measurementCallback(angle);
            }
            var position = (0, _center["default"])({
              type: "FeatureCollection",
              features: [point1, point2].map(function(p) {
                return {
                  type: "Feature",
                  geometry: {
                    type: "Point",
                    coordinates: p
                  }
                };
              })
            }).geometry.coordinates;
            tooltips = [{
              position,
              text
            }];
          }
          return tooltips;
        }));
        return _this;
      }
      _createClass(MeasureAngleMode2, [{
        key: "handleClick",
        value: function handleClick(event, props) {
          if (this.getClickSequence().length >= 3) {
            this.resetClickSequence();
          }
          this.addClickSequence(event);
        }
        // Called when the pointer moved, regardless of whether the pointer is down, up, and whether something was picked
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          props.onUpdateCursor("cell");
        }
      }, {
        key: "getPoints",
        value: function getPoints(props) {
          var clickSequence = this.getClickSequence();
          var points = _toConsumableArray(clickSequence);
          if (clickSequence.length < 3 && props.lastPointerMoveEvent) {
            points.push(props.lastPointerMoveEvent.mapCoords);
          }
          return points;
        }
        // Return features that can be used as a guide for editing the data
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var guides = {
            type: "FeatureCollection",
            features: []
          };
          var features = guides.features;
          var points = this.getPoints(props);
          if (points.length > 2) {
            features.push({
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "LineString",
                coordinates: [points[1], points[0], points[2]]
              }
            });
          } else if (points.length > 1) {
            features.push({
              type: "Feature",
              properties: {
                guideType: "tentative"
              },
              geometry: {
                type: "LineString",
                coordinates: [points[1], points[0]]
              }
            });
          }
          return guides;
        }
      }, {
        key: "getTooltips",
        value: function getTooltips(props) {
          var points = this.getPoints(props);
          return this._getTooltips({
            modeConfig: props.modeConfig,
            vertex: points[0],
            point1: points[1],
            point2: points[2]
          });
        }
      }]);
      return MeasureAngleMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.MeasureAngleMode = MeasureAngleMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/lib/snappable-mode.js
var require_snappable_mode = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/lib/snappable-mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SnappableMode = void 0;
    var _utils = require_utils();
    var _geojsonEditMode = require_geojson_edit_mode();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var SnappableMode = function(_GeoJsonEditMode) {
      _inherits(SnappableMode2, _GeoJsonEditMode);
      var _super = _createSuper(SnappableMode2);
      function SnappableMode2(handler) {
        var _this;
        _classCallCheck(this, SnappableMode2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "_handler", void 0);
        _this._handler = handler;
        return _this;
      }
      _createClass(SnappableMode2, [{
        key: "_getSnappedMouseEvent",
        value: function _getSnappedMouseEvent(event, snapSource, snapTarget) {
          return Object.assign(event, {
            mapCoords: snapTarget.geometry.coordinates,
            pointerDownMapCoords: snapSource && snapSource.geometry.coordinates
          });
        }
      }, {
        key: "_getPickedSnapTarget",
        value: function _getPickedSnapTarget(picks) {
          return (0, _utils.getPickedEditHandles)(picks).find(function(handle) {
            return handle.properties.editHandleType === "snap-target";
          });
        }
      }, {
        key: "_getPickedSnapSource",
        value: function _getPickedSnapSource(pointerDownPicks) {
          return (0, _utils.getPickedSnapSourceEditHandle)(pointerDownPicks);
        }
      }, {
        key: "_getUpdatedSnapSourceHandle",
        value: function _getUpdatedSnapSourceHandle(snapSourceHandle, data) {
          var _snapSourceHandle$pro = snapSourceHandle.properties, featureIndex = _snapSourceHandle$pro.featureIndex, positionIndexes = _snapSourceHandle$pro.positionIndexes;
          if (!Array.isArray(positionIndexes)) {
            return snapSourceHandle;
          }
          var snapSourceFeature = data.features[featureIndex];
          var snapSourceCoordinates = positionIndexes.reduce(function(a, b) {
            return a[b];
          }, snapSourceFeature.geometry.coordinates);
          return _objectSpread({}, snapSourceHandle, {
            geometry: {
              type: "Point",
              coordinates: snapSourceCoordinates
            }
          });
        }
        // If additionalSnapTargets is present in modeConfig and is populated, this
        // method will return those features along with the features
        // that live in the current layer. Otherwise, this method will simply return the
        // features from the current layer
      }, {
        key: "_getSnapTargets",
        value: function _getSnapTargets(props) {
          var _ref = props.modeConfig || {}, additionalSnapTargets = _ref.additionalSnapTargets;
          additionalSnapTargets = additionalSnapTargets || [];
          var features = [].concat(_toConsumableArray(props.data.features), _toConsumableArray(additionalSnapTargets));
          return features;
        }
      }, {
        key: "_getSnapTargetHandles",
        value: function _getSnapTargetHandles(props) {
          var handles = [];
          var features = this._getSnapTargets(props);
          for (var i = 0; i < features.length; i++) {
            var isCurrentIndexFeatureNotSelected = !props.selectedIndexes.includes(i);
            if (isCurrentIndexFeatureNotSelected) {
              var geometry = features[i].geometry;
              handles.push.apply(handles, _toConsumableArray((0, _utils.getEditHandlesForGeometry)(geometry, i, "snap-target")));
            }
          }
          return handles;
        }
        // If no snap handle has been picked, only display the edit handles of the
        // selected feature. If a snap handle has been picked, display said snap handle
        // along with all snappable points on all non-selected features.
      }, {
        key: "getGuides",
        value: function getGuides(props) {
          var modeConfig = props.modeConfig, lastPointerMoveEvent = props.lastPointerMoveEvent;
          var _ref2 = modeConfig || {}, enableSnapping = _ref2.enableSnapping;
          var guides = {
            type: "FeatureCollection",
            features: _toConsumableArray(this._handler.getGuides(props).features)
          };
          if (!enableSnapping) {
            return guides;
          }
          var snapSourceHandle = lastPointerMoveEvent && this._getPickedSnapSource(lastPointerMoveEvent.pointerDownPicks);
          if (snapSourceHandle) {
            var _guides$features;
            (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(this._getSnapTargetHandles(props)).concat([this._getUpdatedSnapSourceHandle(snapSourceHandle, props.data)]));
            return guides;
          }
          var features = props.data.features;
          var _iterator = _createForOfIteratorHelper(props.selectedIndexes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var index = _step.value;
              if (index < features.length) {
                var _guides$features2;
                var geometry = features[index].geometry;
                (_guides$features2 = guides.features).push.apply(_guides$features2, _toConsumableArray((0, _utils.getEditHandlesForGeometry)(geometry, index, "snap-source")));
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return guides;
        }
      }, {
        key: "_getSnapAwareEvent",
        value: function _getSnapAwareEvent(event, props) {
          var snapSource = this._getPickedSnapSource(props.lastPointerMoveEvent.pointerDownPicks);
          var snapTarget = this._getPickedSnapTarget(event.picks);
          return snapSource && snapTarget ? this._getSnappedMouseEvent(event, snapSource, snapTarget) : event;
        }
      }, {
        key: "handleStartDragging",
        value: function handleStartDragging(event, props) {
          this._handler.handleStartDragging(event, props);
        }
      }, {
        key: "handleStopDragging",
        value: function handleStopDragging(event, props) {
          this._handler.handleStopDragging(this._getSnapAwareEvent(event, props), props);
        }
      }, {
        key: "handleDragging",
        value: function handleDragging(event, props) {
          this._handler.handleDragging(this._getSnapAwareEvent(event, props), props);
        }
      }, {
        key: "handlePointerMove",
        value: function handlePointerMove(event, props) {
          this._handler.handlePointerMove(this._getSnapAwareEvent(event, props), props);
        }
      }]);
      return SnappableMode2;
    }(_geojsonEditMode.GeoJsonEditMode);
    exports.SnappableMode = SnappableMode;
  }
});

// node_modules/@nebula.gl/edit-modes/dist-es6/index.js
var require_dist_es6 = __commonJS({
  "node_modules/@nebula.gl/edit-modes/dist-es6/index.js"(exports) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GeoJsonEditMode", {
      enumerable: true,
      get: function get() {
        return _geojsonEditMode.GeoJsonEditMode;
      }
    });
    Object.defineProperty(exports, "ModifyMode", {
      enumerable: true,
      get: function get() {
        return _modifyMode.ModifyMode;
      }
    });
    Object.defineProperty(exports, "ResizeCircleMode", {
      enumerable: true,
      get: function get() {
        return _resizeCircleMode.ResizeCircleMode;
      }
    });
    Object.defineProperty(exports, "TranslateMode", {
      enumerable: true,
      get: function get() {
        return _translateMode.TranslateMode;
      }
    });
    Object.defineProperty(exports, "ScaleMode", {
      enumerable: true,
      get: function get() {
        return _scaleMode.ScaleMode;
      }
    });
    Object.defineProperty(exports, "RotateMode", {
      enumerable: true,
      get: function get() {
        return _rotateMode.RotateMode;
      }
    });
    Object.defineProperty(exports, "DuplicateMode", {
      enumerable: true,
      get: function get() {
        return _duplicateMode.DuplicateMode;
      }
    });
    Object.defineProperty(exports, "ExtendLineStringMode", {
      enumerable: true,
      get: function get() {
        return _extendLineStringMode.ExtendLineStringMode;
      }
    });
    Object.defineProperty(exports, "SplitPolygonMode", {
      enumerable: true,
      get: function get() {
        return _splitPolygonMode.SplitPolygonMode;
      }
    });
    Object.defineProperty(exports, "ExtrudeMode", {
      enumerable: true,
      get: function get() {
        return _extrudeMode.ExtrudeMode;
      }
    });
    Object.defineProperty(exports, "ElevationMode", {
      enumerable: true,
      get: function get() {
        return _elevationMode.ElevationMode;
      }
    });
    Object.defineProperty(exports, "TransformMode", {
      enumerable: true,
      get: function get() {
        return _transformMode.TransformMode;
      }
    });
    Object.defineProperty(exports, "DrawPointMode", {
      enumerable: true,
      get: function get() {
        return _drawPointMode.DrawPointMode;
      }
    });
    Object.defineProperty(exports, "DrawLineStringMode", {
      enumerable: true,
      get: function get() {
        return _drawLineStringMode.DrawLineStringMode;
      }
    });
    Object.defineProperty(exports, "DrawPolygonMode", {
      enumerable: true,
      get: function get() {
        return _drawPolygonMode.DrawPolygonMode;
      }
    });
    Object.defineProperty(exports, "DrawRectangleMode", {
      enumerable: true,
      get: function get() {
        return _drawRectangleMode.DrawRectangleMode;
      }
    });
    Object.defineProperty(exports, "DrawSquareMode", {
      enumerable: true,
      get: function get() {
        return _drawSquareMode.DrawSquareMode;
      }
    });
    Object.defineProperty(exports, "DrawRectangleFromCenterMode", {
      enumerable: true,
      get: function get() {
        return _drawRectangleFromCenterMode.DrawRectangleFromCenterMode;
      }
    });
    Object.defineProperty(exports, "DrawSquareFromCenterMode", {
      enumerable: true,
      get: function get() {
        return _drawSquareFromCenterMode.DrawSquareFromCenterMode;
      }
    });
    Object.defineProperty(exports, "DrawCircleByDiameterMode", {
      enumerable: true,
      get: function get() {
        return _drawCircleByDiameterMode.DrawCircleByDiameterMode;
      }
    });
    Object.defineProperty(exports, "DrawCircleFromCenterMode", {
      enumerable: true,
      get: function get() {
        return _drawCircleFromCenterMode.DrawCircleFromCenterMode;
      }
    });
    Object.defineProperty(exports, "DrawEllipseByBoundingBoxMode", {
      enumerable: true,
      get: function get() {
        return _drawEllipseByBoundingBoxMode.DrawEllipseByBoundingBoxMode;
      }
    });
    Object.defineProperty(exports, "DrawEllipseUsingThreePointsMode", {
      enumerable: true,
      get: function get() {
        return _drawEllipseUsingThreePointsMode.DrawEllipseUsingThreePointsMode;
      }
    });
    Object.defineProperty(exports, "DrawRectangleUsingThreePointsMode", {
      enumerable: true,
      get: function get() {
        return _drawRectangleUsingThreePointsMode.DrawRectangleUsingThreePointsMode;
      }
    });
    Object.defineProperty(exports, "Draw90DegreePolygonMode", {
      enumerable: true,
      get: function get() {
        return _draw90degreePolygonMode.Draw90DegreePolygonMode;
      }
    });
    Object.defineProperty(exports, "DrawPolygonByDraggingMode", {
      enumerable: true,
      get: function get() {
        return _drawPolygonByDraggingMode.DrawPolygonByDraggingMode;
      }
    });
    Object.defineProperty(exports, "ImmutableFeatureCollection", {
      enumerable: true,
      get: function get() {
        return _immutableFeatureCollection.ImmutableFeatureCollection;
      }
    });
    Object.defineProperty(exports, "ViewMode", {
      enumerable: true,
      get: function get() {
        return _viewMode.ViewMode;
      }
    });
    Object.defineProperty(exports, "MeasureDistanceMode", {
      enumerable: true,
      get: function get() {
        return _measureDistanceMode.MeasureDistanceMode;
      }
    });
    Object.defineProperty(exports, "MeasureAreaMode", {
      enumerable: true,
      get: function get() {
        return _measureAreaMode.MeasureAreaMode;
      }
    });
    Object.defineProperty(exports, "MeasureAngleMode", {
      enumerable: true,
      get: function get() {
        return _measureAngleMode.MeasureAngleMode;
      }
    });
    Object.defineProperty(exports, "CompositeMode", {
      enumerable: true,
      get: function get() {
        return _compositeMode.CompositeMode;
      }
    });
    Object.defineProperty(exports, "SnappableMode", {
      enumerable: true,
      get: function get() {
        return _snappableMode.SnappableMode;
      }
    });
    Object.defineProperty(exports, "_memoize", {
      enumerable: true,
      get: function get() {
        return _memoize["default"];
      }
    });
    exports.utils = void 0;
    var _geojsonEditMode = require_geojson_edit_mode();
    var _modifyMode = require_modify_mode();
    var _resizeCircleMode = require_resize_circle_mode();
    var _translateMode = require_translate_mode();
    var _scaleMode = require_scale_mode();
    var _rotateMode = require_rotate_mode();
    var _duplicateMode = require_duplicate_mode();
    var _extendLineStringMode = require_extend_line_string_mode();
    var _splitPolygonMode = require_split_polygon_mode();
    var _extrudeMode = require_extrude_mode();
    var _elevationMode = require_elevation_mode();
    var _transformMode = require_transform_mode();
    var _drawPointMode = require_draw_point_mode();
    var _drawLineStringMode = require_draw_line_string_mode();
    var _drawPolygonMode = require_draw_polygon_mode();
    var _drawRectangleMode = require_draw_rectangle_mode();
    var _drawSquareMode = require_draw_square_mode();
    var _drawRectangleFromCenterMode = require_draw_rectangle_from_center_mode();
    var _drawSquareFromCenterMode = require_draw_square_from_center_mode();
    var _drawCircleByDiameterMode = require_draw_circle_by_diameter_mode();
    var _drawCircleFromCenterMode = require_draw_circle_from_center_mode();
    var _drawEllipseByBoundingBoxMode = require_draw_ellipse_by_bounding_box_mode();
    var _drawEllipseUsingThreePointsMode = require_draw_ellipse_using_three_points_mode();
    var _drawRectangleUsingThreePointsMode = require_draw_rectangle_using_three_points_mode();
    var _draw90degreePolygonMode = require_draw_90degree_polygon_mode();
    var _drawPolygonByDraggingMode = require_draw_polygon_by_dragging_mode();
    var _immutableFeatureCollection = require_immutable_feature_collection();
    var _viewMode = require_view_mode();
    var _measureDistanceMode = require_measure_distance_mode();
    var _measureAreaMode = require_measure_area_mode();
    var _measureAngleMode = require_measure_angle_mode();
    var _compositeMode = require_composite_mode();
    var _snappableMode = require_snappable_mode();
    var _memoize = _interopRequireDefault(require_memoize());
    var utils = _interopRequireWildcard(require_utils());
    exports.utils = utils;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

export {
  require_js6 as require_js,
  init_main_es8 as init_main_es,
  require_js8 as require_js2,
  require_js9 as require_js3,
  require_js12 as require_js4,
  module_exports,
  init_module,
  require_js28 as require_js5,
  require_dist_es6
};
/*! Bundled license information:

polygon-clipping/dist/polygon-clipping.umd.js:
  (**
   * splaytree v3.1.0
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)
*/
//# sourceMappingURL=chunk-MQHQNYV5.js.map
