import {
  init_main_es,
  init_module,
  module_exports,
  require_dist_es6,
  require_js as require_js2,
  require_js2 as require_js3,
  require_js3 as require_js4,
  require_js4 as require_js5,
  require_js5 as require_js6
} from "./chunk-MQHQNYV5.js";
import {
  Accessor,
  Buffer as Buffer2,
  COORDINATE_SYSTEM,
  CompositeLayer,
  CubeGeometry,
  Euler,
  FEATURES,
  Framebuffer,
  Geometry,
  GlobeViewport,
  ImageLoader,
  Layer,
  LayerExtension,
  LayersPass,
  Matrix3,
  Matrix4,
  Model,
  OrthographicViewport,
  PickLayersPass,
  Pose,
  ProgramManager,
  Quaternion,
  Renderbuffer,
  RequestScheduler,
  SphericalCoordinates,
  Stats,
  Tesselator,
  Texture2D,
  UNIT,
  Vector2,
  Vector3,
  Vector4,
  WebMercatorViewport,
  _isImageFormatSupported,
  acos,
  asin,
  assert as assert2,
  assert2 as assert3,
  assert3 as assert4,
  atan,
  clamp,
  clear,
  clone,
  concatenateTypedArrays,
  config,
  configure,
  copyToArray,
  copyToTexture,
  cos,
  createIterable,
  cssToDeviceRatio,
  deepEqual,
  degrees,
  equals,
  esm_exports,
  esm_exports2,
  exactEquals,
  fetchFile,
  flatten,
  formatValue,
  fp64,
  fp64LowPart,
  getBinaryImageMetadata,
  gouraudLighting,
  hasFeature,
  hasFeatures,
  init_esm,
  init_esm10,
  init_esm11,
  init_esm12 as init_esm13,
  init_esm2,
  init_esm3,
  init_esm4,
  init_esm5,
  init_esm6,
  init_esm7,
  init_esm8,
  init_esm9,
  isArray,
  isBrowser,
  isWebGL2,
  lerp,
  load,
  loadLibrary,
  log,
  log_default,
  math_utils_default,
  memoize,
  mergeShaders,
  padToNBytes,
  parseJSON,
  path_exports,
  pbr,
  phongLighting,
  picking_default,
  project32_default,
  project_default,
  radians,
  readPixelsToArray,
  sin,
  sliceArrayBuffer,
  tan,
  toDegrees,
  toRadians,
  uid,
  withEpsilon,
  withParameters
} from "./chunk-T5R6RA5R.js";
import {
  _defineProperty,
  dist,
  dot,
  getScaling,
  init_defineProperty,
  init_esm as init_esm12,
  init_mat4,
  init_vec3,
  length,
  lngLatToWorld,
  worldToLngLat
} from "./chunk-YAGFDRXW.js";
import {
  require_earcut
} from "./chunk-GED75EK3.js";
import {
  require_js
} from "./chunk-EXNR5W7M.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@nebula.gl/layers/dist-es6/style.js
var require_style = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/style.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MAX_ARROWS = exports.DEFAULT_ARROWS = exports.ArrowStyles = void 0;
    var ArrowStyles = {
      NONE: 0,
      FORWARD: 1,
      BACKWARD: 2,
      BOTH: 3
    };
    exports.ArrowStyles = ArrowStyles;
    var DEFAULT_ARROWS = 1;
    exports.DEFAULT_ARROWS = DEFAULT_ARROWS;
    var MAX_ARROWS = 3;
    exports.MAX_ARROWS = MAX_ARROWS;
  }
});

// node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js
var arc_layer_vertex_glsl_default;
var init_arc_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js"() {
    arc_layer_vertex_glsl_default = "#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js
var arc_layer_fragment_glsl_default;
var init_arc_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js"() {
    arc_layer_fragment_glsl_default = "#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js
var DEFAULT_COLOR, defaultProps, ArcLayer;
var init_arc_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_arc_layer_vertex_glsl();
    init_arc_layer_fragment_glsl();
    DEFAULT_COLOR = [0, 0, 0, 255];
    defaultProps = {
      getSourcePosition: {
        type: "accessor",
        value: (x2) => x2.sourcePosition
      },
      getTargetPosition: {
        type: "accessor",
        value: (x2) => x2.targetPosition
      },
      getSourceColor: {
        type: "accessor",
        value: DEFAULT_COLOR
      },
      getTargetColor: {
        type: "accessor",
        value: DEFAULT_COLOR
      },
      getWidth: {
        type: "accessor",
        value: 1
      },
      getHeight: {
        type: "accessor",
        value: 1
      },
      getTilt: {
        type: "accessor",
        value: 0
      },
      greatCircle: false,
      widthUnits: "pixels",
      widthScale: {
        type: "number",
        value: 1,
        min: 0
      },
      widthMinPixels: {
        type: "number",
        value: 0,
        min: 0
      },
      widthMaxPixels: {
        type: "number",
        value: Number.MAX_SAFE_INTEGER,
        min: 0
      }
    };
    ArcLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getBounds() {
        var _this$getAttributeMan;
        return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(["instanceSourcePositions", "instanceTargetPositions"]);
      }
      getShaders() {
        return super.getShaders({
          vs: arc_layer_vertex_glsl_default,
          fs: arc_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
      get wrapLongitude() {
        return false;
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instanceSourcePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getSourcePosition"
          },
          instanceTargetPositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getTargetPosition"
          },
          instanceSourceColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getSourceColor",
            defaultValue: DEFAULT_COLOR
          },
          instanceTargetColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getTargetColor",
            defaultValue: DEFAULT_COLOR
          },
          instanceWidths: {
            size: 1,
            transition: true,
            accessor: "getWidth",
            defaultValue: 1
          },
          instanceHeights: {
            size: 1,
            transition: true,
            accessor: "getHeight",
            defaultValue: 1
          },
          instanceTilts: {
            size: 1,
            transition: true,
            accessor: "getTilt",
            defaultValue: 0
          }
        });
      }
      updateState(opts) {
        super.updateState(opts);
        if (opts.changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          this.getAttributeManager().invalidateAll();
        }
      }
      draw({
        uniforms
      }) {
        const {
          widthUnits,
          widthScale,
          widthMinPixels,
          widthMaxPixels,
          greatCircle,
          wrapLongitude
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          greatCircle,
          widthUnits: UNIT[widthUnits],
          widthScale,
          widthMinPixels,
          widthMaxPixels,
          useShortestPath: wrapLongitude
        }).draw();
      }
      _getModel(gl) {
        let positions = [];
        const NUM_SEGMENTS = 50;
        for (let i3 = 0; i3 < NUM_SEGMENTS; i3++) {
          positions = positions.concat([i3, 1, 0, i3, -1, 0]);
        }
        const model = new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 5,
            attributes: {
              positions: new Float32Array(positions)
            }
          }),
          isInstanced: true
        });
        model.setUniforms({
          numSegments: NUM_SEGMENTS
        });
        return model;
      }
    };
    _defineProperty(ArcLayer, "layerName", "ArcLayer");
    _defineProperty(ArcLayer, "defaultProps", defaultProps);
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex = 0;
  let index = 0;
  for (let u = 0; u < uCount; u++) {
    const ut = u / (uCount - 1);
    for (let v = 0; v < vCount; v++) {
      const vt = v / (vCount - 1);
      const p2 = interpolateQuad(bounds, ut, vt);
      positions[vertex * 3 + 0] = p2[0];
      positions[vertex * 3 + 1] = p2[1];
      positions[vertex * 3 + 2] = p2[2] || 0;
      texCoords[vertex * 2 + 0] = ut;
      texCoords[vertex * 2 + 1] = 1 - vt;
      if (u > 0 && v > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }
      vertex++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i3 = 0; i3 < bounds.length; i3++) {
    positions[i3 * 3 + 0] = bounds[i3][0];
    positions[i3 * 3 + 1] = bounds[i3][1];
    positions[i3 * 3 + 2] = bounds[i3][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut, vt) {
  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
}
var DEFAULT_INDICES, DEFAULT_TEX_COORDS;
var init_create_mesh = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js"() {
    init_esm8();
    DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);
    DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default;
var init_bitmap_layer_vertex = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js"() {
    bitmap_layer_vertex_default = "\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js
var packUVsIntoRGB, bitmap_layer_fragment_default;
var init_bitmap_layer_fragment = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js"() {
    packUVsIntoRGB = "\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n";
    bitmap_layer_fragment_default = "\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n".concat(packUVsIntoRGB, "\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive && !picking_uAttribute) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n");
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js
function unpackUVsFromRGB(color) {
  const [u, v, fracUV] = color;
  const vFrac = (fracUV & 240) / 256;
  const uFrac = (fracUV & 15) / 16;
  return [(u + uFrac) / 256, (v + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}
var defaultProps2, BitmapLayer;
var init_bitmap_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_esm12();
    init_create_mesh();
    init_bitmap_layer_vertex();
    init_bitmap_layer_fragment();
    defaultProps2 = {
      image: {
        type: "image",
        value: null,
        async: true
      },
      bounds: {
        type: "array",
        value: [1, 0, 0, 1],
        compare: true
      },
      _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
      desaturate: {
        type: "number",
        min: 0,
        max: 1,
        value: 0
      },
      transparentColor: {
        type: "color",
        value: [0, 0, 0, 0]
      },
      tintColor: {
        type: "color",
        value: [255, 255, 255]
      },
      textureParameters: {
        type: "object",
        ignore: true
      }
    };
    BitmapLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        return super.getShaders({
          vs: bitmap_layer_vertex_default,
          fs: bitmap_layer_fragment_default,
          modules: [project32_default, picking_default]
        });
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.remove(["instancePickingColors"]);
        const noAlloc = true;
        attributeManager.add({
          indices: {
            size: 1,
            isIndexed: true,
            update: (attribute) => attribute.value = this.state.mesh.indices,
            noAlloc
          },
          positions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            update: (attribute) => attribute.value = this.state.mesh.positions,
            noAlloc
          },
          texCoords: {
            size: 2,
            update: (attribute) => attribute.value = this.state.mesh.texCoords,
            noAlloc
          }
        });
      }
      updateState({
        props,
        oldProps,
        changeFlags
      }) {
        const attributeManager = this.getAttributeManager();
        if (changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          attributeManager.invalidateAll();
        }
        if (props.bounds !== oldProps.bounds) {
          const oldMesh = this.state.mesh;
          const mesh = this._createMesh();
          this.state.model.setVertexCount(mesh.vertexCount);
          for (const key in mesh) {
            if (oldMesh && oldMesh[key] !== mesh[key]) {
              attributeManager.invalidate(key);
            }
          }
          this.setState({
            mesh,
            ...this._getCoordinateUniforms()
          });
        } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
          this.setState(this._getCoordinateUniforms());
        }
      }
      getPickingInfo(params) {
        const {
          image
        } = this.props;
        const info = params.info;
        if (!info.color || !image) {
          info.bitmap = null;
          return info;
        }
        const {
          width,
          height
        } = image;
        info.index = 0;
        const uv = unpackUVsFromRGB(info.color);
        const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];
        info.bitmap = {
          size: {
            width,
            height
          },
          uv,
          pixel
        };
        return info;
      }
      disablePickingIndex() {
        this.setState({
          disablePicking: true
        });
      }
      restorePickingColors() {
        this.setState({
          disablePicking: false
        });
      }
      _updateAutoHighlight(info) {
        super._updateAutoHighlight({
          ...info,
          color: this.encodePickingColor(0)
        });
      }
      _createMesh() {
        const {
          bounds
        } = this.props;
        let normalizedBounds = bounds;
        if (isRectangularBounds(bounds)) {
          normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];
        }
        return createMesh(normalizedBounds, this.context.viewport.resolution);
      }
      _getModel(gl) {
        if (!gl) {
          return null;
        }
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 4,
            vertexCount: 6
          }),
          isInstanced: false
        });
      }
      draw(opts) {
        const {
          uniforms,
          moduleParameters
        } = opts;
        const {
          model,
          coordinateConversion,
          bounds,
          disablePicking
        } = this.state;
        const {
          image,
          desaturate,
          transparentColor,
          tintColor
        } = this.props;
        if (moduleParameters.pickingActive && disablePicking) {
          return;
        }
        if (image && model) {
          model.setUniforms(uniforms).setUniforms({
            bitmapTexture: image,
            desaturate,
            transparentColor: transparentColor.map((x2) => x2 / 255),
            tintColor: tintColor.slice(0, 3).map((x2) => x2 / 255),
            coordinateConversion,
            bounds
          }).draw();
        }
      }
      _getCoordinateUniforms() {
        const {
          LNGLAT,
          CARTESIAN,
          DEFAULT
        } = COORDINATE_SYSTEM;
        let {
          _imageCoordinateSystem: imageCoordinateSystem
        } = this.props;
        if (imageCoordinateSystem !== DEFAULT) {
          const {
            bounds
          } = this.props;
          if (!isRectangularBounds(bounds)) {
            throw new Error("_imageCoordinateSystem only supports rectangular bounds");
          }
          const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
          imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
          if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
            return {
              coordinateConversion: -1,
              bounds
            };
          }
          if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
            const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
            const topRight = lngLatToWorld([bounds[2], bounds[3]]);
            return {
              coordinateConversion: 1,
              bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
            };
          }
        }
        return {
          coordinateConversion: 0,
          bounds: [0, 0, 0, 0]
        };
      }
    };
    _defineProperty(BitmapLayer, "layerName", "BitmapLayer");
    _defineProperty(BitmapLayer, "defaultProps", defaultProps2);
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default;
var init_icon_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js"() {
    icon_layer_vertex_glsl_default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default;
var init_icon_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js"() {
    icon_layer_fragment_glsl_default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return {
      data: imageData,
      width,
      height
    };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return {
    data: ctx.canvas,
    width,
    height
  };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, parameters2) {
  const oldWidth = texture.width;
  const oldHeight = texture.height;
  const newTexture = new Texture2D(texture.gl, {
    width,
    height,
    parameters: parameters2
  });
  copyToTexture(texture, newTexture, {
    targetY: 0,
    width: oldWidth,
    height: oldHeight
  });
  texture.delete();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i3 = 0; i3 < columns.length; i3++) {
    const {
      icon,
      xOffset
    } = columns[i3];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({
  icons,
  buffer,
  mapping = {},
  xOffset = 0,
  yOffset = 0,
  rowHeight = 0,
  canvasWidth
}) {
  let columns = [];
  for (let i3 = 0; i3 < icons.length; i3++) {
    const icon = icons[i3];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const {
        height,
        width
      } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const {
    iterable,
    objectInfo
  } = createIterable(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = {
        ...icon,
        source: object,
        sourceIndex: objectInfo.index
      };
    }
  }
  return icons;
}
var DEFAULT_CANVAS_WIDTH, DEFAULT_BUFFER, noop, DEFAULT_TEXTURE_PARAMETERS, IconManager;
var init_icon_manager = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js"() {
    init_defineProperty();
    init_esm11();
    init_esm4();
    init_esm13();
    DEFAULT_CANVAS_WIDTH = 1024;
    DEFAULT_BUFFER = 4;
    noop = () => {
    };
    DEFAULT_TEXTURE_PARAMETERS = {
      [10241]: 9987,
      [10240]: 9729,
      [10242]: 33071,
      [10243]: 33071
    };
    IconManager = class {
      constructor(gl, {
        onUpdate = noop,
        onError = noop
      }) {
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "onUpdate", void 0);
        _defineProperty(this, "onError", void 0);
        _defineProperty(this, "_loadOptions", null);
        _defineProperty(this, "_texture", null);
        _defineProperty(this, "_externalTexture", null);
        _defineProperty(this, "_mapping", {});
        _defineProperty(this, "_textureParameters", null);
        _defineProperty(this, "_pendingCount", 0);
        _defineProperty(this, "_autoPacking", false);
        _defineProperty(this, "_xOffset", 0);
        _defineProperty(this, "_yOffset", 0);
        _defineProperty(this, "_rowHeight", 0);
        _defineProperty(this, "_buffer", DEFAULT_BUFFER);
        _defineProperty(this, "_canvasWidth", DEFAULT_CANVAS_WIDTH);
        _defineProperty(this, "_canvasHeight", 0);
        _defineProperty(this, "_canvas", null);
        this.gl = gl;
        this.onUpdate = onUpdate;
        this.onError = onError;
      }
      finalize() {
        var _this$_texture;
        (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();
      }
      getTexture() {
        return this._texture || this._externalTexture;
      }
      getIconMapping(icon) {
        const id = this._autoPacking ? getIconId(icon) : icon;
        return this._mapping[id] || {};
      }
      setProps({
        loadOptions,
        autoPacking,
        iconAtlas,
        iconMapping,
        textureParameters
      }) {
        if (loadOptions) {
          this._loadOptions = loadOptions;
        }
        if (autoPacking !== void 0) {
          this._autoPacking = autoPacking;
        }
        if (iconMapping) {
          this._mapping = iconMapping;
        }
        if (iconAtlas) {
          var _this$_texture2;
          (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();
          this._texture = null;
          this._externalTexture = iconAtlas;
        }
        if (textureParameters) {
          this._textureParameters = textureParameters;
        }
      }
      get isLoaded() {
        return this._pendingCount === 0;
      }
      packIcons(data, getIcon) {
        if (!this._autoPacking || typeof document === "undefined") {
          return;
        }
        const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
        if (icons.length > 0) {
          const {
            mapping,
            xOffset,
            yOffset,
            rowHeight,
            canvasHeight
          } = buildMapping({
            icons,
            buffer: this._buffer,
            canvasWidth: this._canvasWidth,
            mapping: this._mapping,
            rowHeight: this._rowHeight,
            xOffset: this._xOffset,
            yOffset: this._yOffset
          });
          this._rowHeight = rowHeight;
          this._mapping = mapping;
          this._xOffset = xOffset;
          this._yOffset = yOffset;
          this._canvasHeight = canvasHeight;
          if (!this._texture) {
            this._texture = new Texture2D(this.gl, {
              width: this._canvasWidth,
              height: this._canvasHeight,
              parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS
            });
          }
          if (this._texture.height !== this._canvasHeight) {
            this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS);
          }
          this.onUpdate();
          this._canvas = this._canvas || document.createElement("canvas");
          this._loadIcons(icons);
        }
      }
      _loadIcons(icons) {
        const ctx = this._canvas.getContext("2d", {
          willReadFrequently: true
        });
        for (const icon of icons) {
          this._pendingCount++;
          load(icon.url, this._loadOptions).then((imageData) => {
            const id = getIconId(icon);
            const iconDef = this._mapping[id];
            const {
              x: x2,
              y: y2,
              width: maxWidth,
              height: maxHeight
            } = iconDef;
            const {
              data,
              width,
              height
            } = resizeImage(ctx, imageData, maxWidth, maxHeight);
            this._texture.setSubImageData({
              data,
              x: x2 + (maxWidth - width) / 2,
              y: y2 + (maxHeight - height) / 2,
              width,
              height
            });
            iconDef.width = width;
            iconDef.height = height;
            this._texture.generateMipmap();
            this.onUpdate();
          }).catch((error) => {
            this.onError({
              url: icon.url,
              source: icon.source,
              sourceIndex: icon.sourceIndex,
              loadOptions: this._loadOptions,
              error
            });
          }).finally(() => {
            this._pendingCount--;
          });
        }
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js
var DEFAULT_COLOR2, defaultProps3, IconLayer;
var init_icon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_icon_layer_vertex_glsl();
    init_icon_layer_fragment_glsl();
    init_icon_manager();
    DEFAULT_COLOR2 = [0, 0, 0, 255];
    defaultProps3 = {
      iconAtlas: {
        type: "image",
        value: null,
        async: true
      },
      iconMapping: {
        type: "object",
        value: {},
        async: true
      },
      sizeScale: {
        type: "number",
        value: 1,
        min: 0
      },
      billboard: true,
      sizeUnits: "pixels",
      sizeMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      sizeMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      alphaCutoff: {
        type: "number",
        value: 0.05,
        min: 0,
        max: 1
      },
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getIcon: {
        type: "accessor",
        value: (x2) => x2.icon
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR2
      },
      getSize: {
        type: "accessor",
        value: 1
      },
      getAngle: {
        type: "accessor",
        value: 0
      },
      getPixelOffset: {
        type: "accessor",
        value: [0, 0]
      },
      onIconError: {
        type: "function",
        value: null,
        optional: true
      },
      textureParameters: {
        type: "object",
        ignore: true
      }
    };
    IconLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        return super.getShaders({
          vs: icon_layer_vertex_glsl_default,
          fs: icon_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
      initializeState() {
        this.state = {
          iconManager: new IconManager(this.context.gl, {
            onUpdate: this._onUpdate.bind(this),
            onError: this._onError.bind(this)
          })
        };
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getPosition"
          },
          instanceSizes: {
            size: 1,
            transition: true,
            accessor: "getSize",
            defaultValue: 1
          },
          instanceOffsets: {
            size: 2,
            accessor: "getIcon",
            transform: this.getInstanceOffset
          },
          instanceIconFrames: {
            size: 4,
            accessor: "getIcon",
            transform: this.getInstanceIconFrame
          },
          instanceColorModes: {
            size: 1,
            type: 5121,
            accessor: "getIcon",
            transform: this.getInstanceColorMode
          },
          instanceColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getColor",
            defaultValue: DEFAULT_COLOR2
          },
          instanceAngles: {
            size: 1,
            transition: true,
            accessor: "getAngle"
          },
          instancePixelOffset: {
            size: 2,
            transition: true,
            accessor: "getPixelOffset"
          }
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps,
          changeFlags
        } = params;
        const attributeManager = this.getAttributeManager();
        const {
          iconAtlas,
          iconMapping,
          data,
          getIcon,
          textureParameters
        } = props;
        const {
          iconManager
        } = this.state;
        const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
        iconManager.setProps({
          loadOptions: props.loadOptions,
          autoPacking: !prePacked,
          iconAtlas,
          iconMapping: prePacked ? iconMapping : null,
          textureParameters
        });
        if (prePacked) {
          if (oldProps.iconMapping !== props.iconMapping) {
            attributeManager.invalidate("getIcon");
          }
        } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
          iconManager.packIcons(data, getIcon);
        }
        if (changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          attributeManager.invalidateAll();
        }
      }
      get isLoaded() {
        return super.isLoaded && this.state.iconManager.isLoaded;
      }
      finalizeState(context) {
        super.finalizeState(context);
        this.state.iconManager.finalize();
      }
      draw({
        uniforms
      }) {
        const {
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          sizeUnits,
          billboard,
          alphaCutoff
        } = this.props;
        const {
          iconManager
        } = this.state;
        const iconsTexture = iconManager.getTexture();
        if (iconsTexture) {
          this.state.model.setUniforms(uniforms).setUniforms({
            iconsTexture,
            iconsTextureDim: [iconsTexture.width, iconsTexture.height],
            sizeUnits: UNIT[sizeUnits],
            sizeScale,
            sizeMinPixels,
            sizeMaxPixels,
            billboard,
            alphaCutoff
          }).draw();
        }
      }
      _getModel(gl) {
        const positions = [-1, -1, -1, 1, 1, 1, 1, -1];
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 6,
            attributes: {
              positions: {
                size: 2,
                value: new Float32Array(positions)
              }
            }
          }),
          isInstanced: true
        });
      }
      _onUpdate() {
        this.setNeedsRedraw();
      }
      _onError(evt) {
        var _this$getCurrentLayer;
        const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;
        if (onIconError) {
          onIconError(evt);
        } else {
          log_default.error(evt.error.message)();
        }
      }
      getInstanceOffset(icon) {
        const {
          width,
          height,
          anchorX = width / 2,
          anchorY = height / 2
        } = this.state.iconManager.getIconMapping(icon);
        return [width / 2 - anchorX, height / 2 - anchorY];
      }
      getInstanceColorMode(icon) {
        const mapping = this.state.iconManager.getIconMapping(icon);
        return mapping.mask ? 1 : 0;
      }
      getInstanceIconFrame(icon) {
        const {
          x: x2,
          y: y2,
          width,
          height
        } = this.state.iconManager.getIconMapping(icon);
        return [x2, y2, width, height];
      }
    };
    _defineProperty(IconLayer, "defaultProps", defaultProps3);
    _defineProperty(IconLayer, "layerName", "IconLayer");
  }
});

// node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default;
var init_line_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js"() {
    line_layer_vertex_glsl_default = "#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(p, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default;
var init_line_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js"() {
    line_layer_fragment_glsl_default = "#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js
var DEFAULT_COLOR3, defaultProps4, LineLayer;
var init_line_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_line_layer_vertex_glsl();
    init_line_layer_fragment_glsl();
    DEFAULT_COLOR3 = [0, 0, 0, 255];
    defaultProps4 = {
      getSourcePosition: {
        type: "accessor",
        value: (x2) => x2.sourcePosition
      },
      getTargetPosition: {
        type: "accessor",
        value: (x2) => x2.targetPosition
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR3
      },
      getWidth: {
        type: "accessor",
        value: 1
      },
      widthUnits: "pixels",
      widthScale: {
        type: "number",
        value: 1,
        min: 0
      },
      widthMinPixels: {
        type: "number",
        value: 0,
        min: 0
      },
      widthMaxPixels: {
        type: "number",
        value: Number.MAX_SAFE_INTEGER,
        min: 0
      }
    };
    LineLayer = class extends Layer {
      getBounds() {
        var _this$getAttributeMan;
        return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(["instanceSourcePositions", "instanceTargetPositions"]);
      }
      getShaders() {
        return super.getShaders({
          vs: line_layer_vertex_glsl_default,
          fs: line_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
      get wrapLongitude() {
        return false;
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instanceSourcePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getSourcePosition"
          },
          instanceTargetPositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getTargetPosition"
          },
          instanceColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceWidths: {
            size: 1,
            transition: true,
            accessor: "getWidth",
            defaultValue: 1
          }
        });
      }
      updateState(params) {
        super.updateState(params);
        if (params.changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          this.getAttributeManager().invalidateAll();
        }
      }
      draw({
        uniforms
      }) {
        const {
          widthUnits,
          widthScale,
          widthMinPixels,
          widthMaxPixels,
          wrapLongitude
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          widthUnits: UNIT[widthUnits],
          widthScale,
          widthMinPixels,
          widthMaxPixels,
          useShortestPath: wrapLongitude ? 1 : 0
        }).draw();
        if (wrapLongitude) {
          this.state.model.setUniforms({
            useShortestPath: -1
          }).draw();
        }
      }
      _getModel(gl) {
        const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 5,
            attributes: {
              positions: new Float32Array(positions)
            }
          }),
          isInstanced: true
        });
      }
    };
    _defineProperty(LineLayer, "layerName", "LineLayer");
    _defineProperty(LineLayer, "defaultProps", defaultProps4);
  }
});

// node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js
var point_cloud_layer_vertex_glsl_default;
var init_point_cloud_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js"() {
    point_cloud_layer_vertex_glsl_default = "#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js
var point_cloud_layer_fragment_glsl_default;
var init_point_cloud_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js"() {
    point_cloud_layer_fragment_glsl_default = "#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js
function normalizeData(data) {
  const {
    header,
    attributes
  } = data;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    attributes.instanceColors = attributes.COLOR_0;
  }
}
var DEFAULT_COLOR4, DEFAULT_NORMAL, defaultProps5, PointCloudLayer;
var init_point_cloud_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_point_cloud_layer_vertex_glsl();
    init_point_cloud_layer_fragment_glsl();
    DEFAULT_COLOR4 = [0, 0, 0, 255];
    DEFAULT_NORMAL = [0, 0, 1];
    defaultProps5 = {
      sizeUnits: "pixels",
      pointSize: {
        type: "number",
        min: 0,
        value: 10
      },
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getNormal: {
        type: "accessor",
        value: DEFAULT_NORMAL
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR4
      },
      material: true,
      radiusPixels: {
        deprecatedFor: "pointSize"
      }
    };
    PointCloudLayer = class extends Layer {
      getShaders() {
        return super.getShaders({
          vs: point_cloud_layer_vertex_glsl_default,
          fs: point_cloud_layer_fragment_glsl_default,
          modules: [project32_default, gouraudLighting, picking_default]
        });
      }
      initializeState() {
        this.getAttributeManager().addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getPosition"
          },
          instanceNormals: {
            size: 3,
            transition: true,
            accessor: "getNormal",
            defaultValue: DEFAULT_NORMAL
          },
          instanceColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getColor",
            defaultValue: DEFAULT_COLOR4
          }
        });
      }
      updateState(params) {
        const {
          changeFlags,
          props
        } = params;
        super.updateState(params);
        if (changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          this.getAttributeManager().invalidateAll();
        }
        if (changeFlags.dataChanged) {
          normalizeData(props.data);
        }
      }
      draw({
        uniforms
      }) {
        const {
          pointSize,
          sizeUnits
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          sizeUnits: UNIT[sizeUnits],
          radiusPixels: pointSize
        }).draw();
      }
      _getModel(gl) {
        const positions = [];
        for (let i3 = 0; i3 < 3; i3++) {
          const angle = i3 / 3 * Math.PI * 2;
          positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
        }
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 4,
            attributes: {
              positions: new Float32Array(positions)
            }
          }),
          isInstanced: true
        });
      }
    };
    _defineProperty(PointCloudLayer, "layerName", "PointCloudLayer");
    _defineProperty(PointCloudLayer, "defaultProps", defaultProps5);
  }
});

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default;
var init_scatterplot_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js"() {
    scatterplot_layer_vertex_glsl_default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default;
var init_scatterplot_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js"() {
    scatterplot_layer_fragment_glsl_default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR5, defaultProps6, ScatterplotLayer;
var init_scatterplot_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_scatterplot_layer_vertex_glsl();
    init_scatterplot_layer_fragment_glsl();
    DEFAULT_COLOR5 = [0, 0, 0, 255];
    defaultProps6 = {
      radiusUnits: "meters",
      radiusScale: {
        type: "number",
        min: 0,
        value: 1
      },
      radiusMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      radiusMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      lineWidthUnits: "meters",
      lineWidthScale: {
        type: "number",
        min: 0,
        value: 1
      },
      lineWidthMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      lineWidthMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      stroked: false,
      filled: true,
      billboard: false,
      antialiasing: true,
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getRadius: {
        type: "accessor",
        value: 1
      },
      getFillColor: {
        type: "accessor",
        value: DEFAULT_COLOR5
      },
      getLineColor: {
        type: "accessor",
        value: DEFAULT_COLOR5
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      },
      strokeWidth: {
        deprecatedFor: "getLineWidth"
      },
      outline: {
        deprecatedFor: "stroked"
      },
      getColor: {
        deprecatedFor: ["getFillColor", "getLineColor"]
      }
    };
    ScatterplotLayer = class extends Layer {
      getShaders() {
        return super.getShaders({
          vs: scatterplot_layer_vertex_glsl_default,
          fs: scatterplot_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
      initializeState() {
        this.getAttributeManager().addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getPosition"
          },
          instanceRadius: {
            size: 1,
            transition: true,
            accessor: "getRadius",
            defaultValue: 1
          },
          instanceFillColors: {
            size: this.props.colorFormat.length,
            transition: true,
            normalized: true,
            type: 5121,
            accessor: "getFillColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceLineColors: {
            size: this.props.colorFormat.length,
            transition: true,
            normalized: true,
            type: 5121,
            accessor: "getLineColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceLineWidths: {
            size: 1,
            transition: true,
            accessor: "getLineWidth",
            defaultValue: 1
          }
        });
      }
      updateState(params) {
        super.updateState(params);
        if (params.changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          this.getAttributeManager().invalidateAll();
        }
      }
      draw({
        uniforms
      }) {
        const {
          radiusUnits,
          radiusScale,
          radiusMinPixels,
          radiusMaxPixels,
          stroked,
          filled,
          billboard,
          antialiasing,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          stroked: stroked ? 1 : 0,
          filled,
          billboard,
          antialiasing,
          radiusUnits: UNIT[radiusUnits],
          radiusScale,
          radiusMinPixels,
          radiusMaxPixels,
          lineWidthUnits: UNIT[lineWidthUnits],
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels
        }).draw();
      }
      _getModel(gl) {
        const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 6,
            vertexCount: 4,
            attributes: {
              positions: {
                size: 3,
                value: new Float32Array(positions)
              }
            }
          }),
          isInstanced: true
        });
      }
    };
    _defineProperty(ScatterplotLayer, "defaultProps", defaultProps6);
    _defineProperty(ScatterplotLayer, "layerName", "ScatterplotLayer");
  }
});

// node_modules/@math.gl/polygon/dist/esm/polygon-utils.js
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
function getPolygonSignedArea(points, options = {}) {
  const {
    start = 0,
    end = points.length
  } = options;
  const dim = options.size || 2;
  let area2 = 0;
  for (let i3 = start, j = end - dim; i3 < end; i3 += dim) {
    area2 += (points[i3] - points[j]) * (points[i3 + 1] + points[j + 1]);
    j = i3;
  }
  return area2 / 2;
}
function reversePolygon(points, options) {
  const {
    start = 0,
    end = points.length,
    size = 2
  } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i3 = 0; i3 < numSwaps; ++i3) {
    const b1 = start + i3 * size;
    const b2 = start + (numPoints - 1 - i3) * size;
    for (let j = 0; j < size; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}
var WINDING;
var init_polygon_utils = __esm({
  "node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"() {
    init_esm8();
    WINDING = {
      CLOCKWISE: 1,
      COUNTER_CLOCKWISE: -1
    };
  }
});

// node_modules/@math.gl/polygon/dist/esm/polygon.js
var init_polygon = __esm({
  "node_modules/@math.gl/polygon/dist/esm/polygon.js"() {
    init_defineProperty();
    init_esm8();
    init_polygon_utils();
  }
});

// node_modules/@math.gl/polygon/dist/esm/earcut.js
function earcut(positions, holeIndices, dim = 2, areas) {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  let invSize;
  let maxX;
  let maxY;
  let minX;
  let minY;
  let x2;
  let y2;
  if (hasHoles)
    outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);
  if (positions.length > 80 * dim) {
    minX = maxX = positions[0];
    minY = maxY = positions[1];
    for (let i3 = dim; i3 < outerLen; i3 += dim) {
      x2 = positions[i3];
      y2 = positions[i3 + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise, area2) {
  let i3;
  let last;
  if (area2 === void 0) {
    area2 = getPolygonSignedArea(data, {
      start,
      end,
      size: dim
    });
  }
  if (clockwise === area2 < 0) {
    for (i3 = start; i3 < end; i3 += dim)
      last = insertNode(i3, data[i3], data[i3 + 1], last);
  } else {
    for (i3 = end - dim; i3 >= start; i3 -= dim)
      last = insertNode(i3, data[i3], data[i3 + 1], last);
  }
  if (last && equals2(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p2 = start;
  let again;
  do {
    again = false;
    if (!p2.steiner && (equals2(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  let prev;
  let next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev;
  const b = ear;
  const c2 = ear.next;
  if (area(a2, b, c2) >= 0)
    return false;
  let p2 = ear.next.next;
  while (p2 !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b.x, b.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev;
  const b = ear;
  const c2 = ear.next;
  if (area(a2, b, c2) >= 0)
    return false;
  const minTX = a2.x < b.x ? a2.x < c2.x ? a2.x : c2.x : b.x < c2.x ? b.x : c2.x;
  const minTY = a2.y < b.y ? a2.y < c2.y ? a2.y : c2.y : b.y < c2.y ? b.y : c2.y;
  const maxTX = a2.x > b.x ? a2.x > c2.x ? a2.x : c2.x : b.x > c2.x ? b.x : c2.x;
  const maxTY = a2.y > b.y ? a2.y > c2.y ? a2.y : c2.y : b.y > c2.y ? b.y : c2.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize);
  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p2 = ear.prevZ;
  let n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a2 = p2.prev;
    const b = p2.next.next;
    if (!equals2(a2, b) && intersects(a2, p2, p2.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p2.i / dim);
      triangles.push(b.i / dim);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b = a2.next.next;
    while (b !== a2.prev) {
      if (a2.i !== b.i && isValidDiagonal(a2, b)) {
        let c2 = splitPolygon(a2, b);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim, areas) {
  const queue = [];
  let i3;
  let len;
  let start;
  let end;
  let list;
  for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
    start = holeIndices[i3] * dim;
    end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false, areas && areas[i3 + 1]);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i3 = 0; i3 < queue.length; i3++) {
    eliminateHole(queue[i3], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b) {
  return a2.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p2.y)
            return p2;
          if (hy === p2.next.y)
            return p2.next;
        }
        m = p2.x < p2.next.x ? p2 : p2.next;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m)
    return null;
  if (hx === qx)
    return m;
  const stop = m;
  const mx = m.x;
  const my = m.y;
  let tanMin = Infinity;
  let tan2;
  p2 = m;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector(m, p2)))) {
        m = p2;
        tanMin = tan2;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m;
}
function sectorContainsSector(m, p2) {
  return area(m.prev, m, p2.prev) < 0 && area(p2.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === null)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let e2;
  let i3;
  let inSize = 1;
  let numMerges;
  let p2;
  let pSize;
  let q;
  let qSize;
  let tail;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q = p2;
      pSize = 0;
      for (i3 = 0; i3 < inSize; i3++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start;
  let leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
function isValidDiagonal(a2, b) {
  return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && (area(a2.prev, a2, b.prev) || area(a2, b.prev, b)) || equals2(a2, b) && area(a2.prev, a2, a2.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals2(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q, r2) {
  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a2, b))
      return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b, a2.next) >= 0 && area(a2, a2.prev, b) >= 0 : area(a2, b, a2.prev) < 0 || area(a2, a2.next, b) < 0;
}
function middleInside(a2, b) {
  let p2 = a2;
  let inside = false;
  const px = (a2.x + b.x) / 2;
  const py = (a2.y + b.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b) {
  const a22 = new Node(a2.i, a2.x, a2.y);
  const b2 = new Node(b.i, b.x, b.y);
  const an = a2.next;
  const bp = b.prev;
  a2.next = b;
  b.prev = a2;
  a22.next = an;
  an.prev = a22;
  b2.next = a22;
  a22.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i3, x2, y2, last) {
  const p2 = new Node(i3, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node(i3, x2, y2) {
  this.i = i3;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
var init_earcut = __esm({
  "node_modules/@math.gl/polygon/dist/esm/earcut.js"() {
    init_polygon_utils();
  }
});

// node_modules/@math.gl/polygon/dist/esm/utils.js
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i3 = 0; i3 < size; i3++) {
      if (target[startIndex - size + i3] !== source[i3]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i3 = 0; i3 < size; i3++) {
    target[startIndex + i3] = source[i3];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i3 = 0; i3 < size; i3++) {
    target[i3] = source[i3];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i3 = 0; i3 < size; i3++) {
    out[i3] = positions[startI + i3];
  }
  return out;
}
var init_utils = __esm({
  "node_modules/@math.gl/polygon/dist/esm/utils.js"() {
  }
});

// node_modules/@math.gl/polygon/dist/esm/lineclip.js
function intersect(a2, b, edge, bbox, out = []) {
  let t2;
  let snap;
  if (edge & 8) {
    t2 = (bbox[3] - a2[1]) / (b[1] - a2[1]);
    snap = 3;
  } else if (edge & 4) {
    t2 = (bbox[1] - a2[1]) / (b[1] - a2[1]);
    snap = 1;
  } else if (edge & 2) {
    t2 = (bbox[2] - a2[0]) / (b[0] - a2[0]);
    snap = 2;
  } else if (edge & 1) {
    t2 = (bbox[0] - a2[0]) / (b[0] - a2[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i3 = 0; i3 < a2.length; i3++) {
    out[i3] = (snap & 1) === i3 ? bbox[snap] : t2 * (b[i3] - a2[i3]) + a2[i3];
  }
  return out;
}
function bitCode(p2, bbox) {
  let code = 0;
  if (p2[0] < bbox[0])
    code |= 1;
  else if (p2[0] > bbox[2])
    code |= 2;
  if (p2[1] < bbox[1])
    code |= 4;
  else if (p2[1] > bbox[3])
    code |= 8;
  return code;
}
var init_lineclip = __esm({
  "node_modules/@math.gl/polygon/dist/esm/lineclip.js"() {
    init_utils();
  }
});

// node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const {
    size = 2,
    broken = false,
    gridResolution = 10,
    gridOffset = [0, 0],
    startIndex = 0,
    endIndex = positions.length
  } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a2 = getPointAtIndex(positions, 0, size, startIndex);
  let b;
  let codeB;
  const cell = getGridCell(a2, gridResolution, gridOffset, []);
  const scratchPoint2 = [];
  push(part, a2);
  for (let i3 = 1; i3 < numPoints; i3++) {
    b = getPointAtIndex(positions, i3, size, startIndex, b);
    codeB = bitCode(b, cell);
    while (codeB) {
      intersect(a2, b, codeB, cell, scratchPoint2);
      const codeAlt = bitCode(scratchPoint2, cell);
      if (codeAlt) {
        intersect(a2, scratchPoint2, codeAlt, cell, scratchPoint2);
        codeB = codeAlt;
      }
      push(part, scratchPoint2);
      copy(a2, scratchPoint2);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a2);
      }
      codeB = bitCode(b, cell);
    }
    push(part, b);
    copy(a2, b);
  }
  return broken ? result : result[0];
}
function concatInPlace(arr1, arr2) {
  for (let i3 = 0; i3 < arr2.length; i3++) {
    arr1.push(arr2[i3]);
  }
  return arr1;
}
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const {
    size = 2,
    gridResolution = 10,
    gridOffset = [0, 0],
    edgeTypes = false
  } = options || {};
  const result = [];
  const queue = [{
    pos: positions,
    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
    holes: holeIndices || []
  }];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const {
      pos,
      types,
      holes
    } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = {
        pos: parts[0].pos,
        types: parts[0].types,
        holes: []
      };
      const polygonHigh = {
        pos: parts[1].pos,
        types: parts[1].types,
        holes: []
      };
      queue.push(polygonLow, polygonHigh);
      for (let i3 = 0; i3 < holes.length; i3++) {
        parts = bisectPolygon(pos, types, size, holes[i3], holes[i3 + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = {
        positions: pos
      };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint2 = [];
  let p2;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i3 = 0; i3 < numPoints; i3++) {
    p2 = getPointAtIndex(positions, i3, size, startIndex, p2);
    side = Math.sign(edge & 8 ? p2[1] - bbox[3] : p2[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i3];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p2, edge, bbox, scratchPoint2);
      push(resultLow, scratchPoint2) && typesLow.push(prevType);
      push(resultHigh, scratchPoint2) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p2) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p2) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy(prev, p2);
    prevSide = side;
    prevType = type;
  }
  return [lowPointCount ? {
    pos: resultLow,
    types: edgeTypes && typesLow
  } : null, highPointCount ? {
    pos: resultHigh,
    types: edgeTypes && typesHigh
  } : null];
}
function getGridCell(p2, gridResolution, gridOffset, out) {
  const left = Math.floor((p2[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p2[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i3 = 0; i3 < endIndex; i3 += size) {
    const x2 = positions[i3];
    const y2 = positions[i3 + 1];
    minX = x2 < minX ? x2 : minX;
    maxX = x2 > maxX ? x2 : maxX;
    minY = y2 < minY ? y2 : minY;
    maxY = y2 > maxY ? y2 : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
var TYPE_INSIDE, TYPE_BORDER;
var init_cut_by_grid = __esm({
  "node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js"() {
    init_lineclip();
    init_utils();
    TYPE_INSIDE = 0;
    TYPE_BORDER = 1;
  }
});

// node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js
function cutPolylineByMercatorBounds(positions, options) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length,
    normalize: normalize3 = true
  } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize3) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const {
    size = 2,
    normalize: normalize3 = true,
    edgeTypes = false
  } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i3 = splitIndex; i3 < srcEndIndex; i3++) {
      newPositions[targetIndex++] = positions[i3];
    }
    for (let i3 = srcStartIndex; i3 < splitIndex; i3++) {
      newPositions[targetIndex++] = positions[i3];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize3) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i3 = startIndex + 1; i3 < endIndex; i3 += size) {
    const lat = Math.abs(positions[i3]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i3 - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p2 = getPointAtIndex(positions, 0, size, startIndex);
    p2[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p2);
    p2[1] = Math.sign(p2[1]) * maxLatitude;
    push(positions, p2);
    p2[0] = firstLng;
    push(positions, p2);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i3 = startIndex; i3 < endIndex; i3 += size) {
    lng = positions[i3];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i3] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i3 = 0; i3 < pointCount; i3++) {
    refLng = positions[i3 * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i3 = 0; i3 < pointCount; i3++) {
    positions[i3 * size] += delta;
  }
}
var DEFAULT_MAX_LATITUDE;
var init_cut_by_mercator_bounds = __esm({
  "node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"() {
    init_cut_by_grid();
    init_utils();
    DEFAULT_MAX_LATITUDE = 85.051129;
  }
});

// node_modules/@math.gl/polygon/dist/esm/index.js
var init_esm14 = __esm({
  "node_modules/@math.gl/polygon/dist/esm/index.js"() {
    init_polygon();
    init_polygon_utils();
    init_earcut();
    init_lineclip();
    init_cut_by_grid();
    init_cut_by_mercator_bounds();
    init_polygon();
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js
function tesselateColumn(props) {
  const {
    radius,
    height = 1,
    nradial = 10
  } = props;
  let {
    vertices
  } = props;
  if (vertices) {
    log_default.assert(vertices.length >= nradial);
    vertices = vertices.flatMap((v) => [v[0], v[1]]);
    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
  }
  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i3 = 0;
  if (isExtruded) {
    for (let j = 0; j < vertsAroundEdge; j++) {
      const a2 = j * stepAngle;
      const vertexIndex = j % nradial;
      const sin2 = Math.sin(a2);
      const cos2 = Math.cos(a2);
      for (let k = 0; k < 2; k++) {
        positions[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
        positions[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
        positions[i3 + 2] = (1 / 2 - k) * height;
        normals[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos2;
        normals[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2;
        i3 += 3;
      }
    }
    positions[i3 + 0] = positions[i3 - 3];
    positions[i3 + 1] = positions[i3 - 2];
    positions[i3 + 2] = positions[i3 - 1];
    i3 += 3;
  }
  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {
    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);
    const a2 = v * stepAngle;
    const vertexIndex = (v + nradial) % nradial;
    const sin2 = Math.sin(a2);
    const cos2 = Math.cos(a2);
    positions[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
    positions[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
    positions[i3 + 2] = height / 2;
    normals[i3 + 2] = 1;
    i3 += 3;
  }
  if (isExtruded) {
    let index = 0;
    for (let j = 0; j < nradial; j++) {
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 2;
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 3;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      }
    }
  };
}
var ColumnGeometry;
var init_column_geometry = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js"() {
    init_esm13();
    init_esm11();
    init_esm14();
    ColumnGeometry = class extends Geometry {
      constructor(props) {
        const {
          id = uid("column-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselateColumn(props);
        super({
          ...props,
          id,
          indices,
          attributes
        });
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js
var column_layer_vertex_glsl_default;
var init_column_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js"() {
    column_layer_vertex_glsl_default = "#version 300 es\n\n#define SHADER_NAME column-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\n\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool stroked;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int radiusUnits;\nuniform int widthUnits;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (stroked) {\n    float widthPixels = clamp(\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n    if (isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.pickingColor = instancePickingColors;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\n  if (radiusUnits == UNIT_METERS) {\n    offset = project_size(offset);\n  }\n  vec3 pos = vec3(offset, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded && !isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js
var column_layer_fragment_glsl_default;
var init_column_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js"() {
    column_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec3 project_uCameraPosition;\nuniform bool extruded;\nuniform bool isStroke;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  fragColor = vColor;\n#ifdef FLAT_SHADING\n  if (extruded && !isStroke && !picking_uActive) {\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n  }\n#endif\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js
var DEFAULT_COLOR6, defaultProps7, ColumnLayer;
var init_column_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_column_geometry();
    init_column_layer_vertex_glsl();
    init_column_layer_fragment_glsl();
    DEFAULT_COLOR6 = [0, 0, 0, 255];
    defaultProps7 = {
      diskResolution: {
        type: "number",
        min: 4,
        value: 20
      },
      vertices: null,
      radius: {
        type: "number",
        min: 0,
        value: 1e3
      },
      angle: {
        type: "number",
        value: 0
      },
      offset: {
        type: "array",
        value: [0, 0]
      },
      coverage: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
      },
      elevationScale: {
        type: "number",
        min: 0,
        value: 1
      },
      radiusUnits: "meters",
      lineWidthUnits: "meters",
      lineWidthScale: 1,
      lineWidthMinPixels: 0,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      extruded: true,
      wireframe: false,
      filled: true,
      stroked: false,
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getFillColor: {
        type: "accessor",
        value: DEFAULT_COLOR6
      },
      getLineColor: {
        type: "accessor",
        value: DEFAULT_COLOR6
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      },
      getElevation: {
        type: "accessor",
        value: 1e3
      },
      material: true,
      getColor: {
        deprecatedFor: ["getFillColor", "getLineColor"]
      }
    };
    ColumnLayer = class extends Layer {
      getShaders() {
        const {
          gl
        } = this.context;
        const transpileToGLSL100 = !isWebGL2(gl);
        const defines = {};
        const useDerivatives = this.props.flatShading && hasFeature(gl, FEATURES.GLSL_DERIVATIVES);
        if (useDerivatives) {
          defines.FLAT_SHADING = 1;
        }
        return super.getShaders({
          vs: column_layer_vertex_glsl_default,
          fs: column_layer_fragment_glsl_default,
          defines,
          transpileToGLSL100,
          modules: [project32_default, useDerivatives ? phongLighting : gouraudLighting, picking_default]
        });
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getPosition"
          },
          instanceElevations: {
            size: 1,
            transition: true,
            accessor: "getElevation"
          },
          instanceFillColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getFillColor",
            defaultValue: DEFAULT_COLOR6
          },
          instanceLineColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: true,
            accessor: "getLineColor",
            defaultValue: DEFAULT_COLOR6
          },
          instanceStrokeWidths: {
            size: 1,
            accessor: "getLineWidth",
            transition: true
          }
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps,
          changeFlags
        } = params;
        const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
        if (regenerateModels) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          this.getAttributeManager().invalidateAll();
        }
        if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
          this._updateGeometry(props);
        }
      }
      getGeometry(diskResolution, vertices, hasThinkness) {
        const geometry = new ColumnGeometry({
          radius: 1,
          height: hasThinkness ? 2 : 0,
          vertices,
          nradial: diskResolution
        });
        let meanVertexDistance = 0;
        if (vertices) {
          for (let i3 = 0; i3 < diskResolution; i3++) {
            const p2 = vertices[i3];
            const d = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1]);
            meanVertexDistance += d / diskResolution;
          }
        } else {
          meanVertexDistance = 1;
        }
        this.setState({
          edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
        });
        return geometry;
      }
      _getModel(gl) {
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          isInstanced: true
        });
      }
      _updateGeometry({
        diskResolution,
        vertices,
        extruded,
        stroked
      }) {
        const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
        this.setState({
          fillVertexCount: geometry.attributes.POSITION.value.length / 3,
          wireframeVertexCount: geometry.indices.value.length
        });
        this.state.model.setProps({
          geometry
        });
      }
      draw({
        uniforms
      }) {
        const {
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          radiusUnits,
          elevationScale,
          extruded,
          filled,
          stroked,
          wireframe,
          offset,
          coverage,
          radius,
          angle
        } = this.props;
        const {
          model,
          fillVertexCount,
          wireframeVertexCount,
          edgeDistance
        } = this.state;
        model.setUniforms(uniforms).setUniforms({
          radius,
          angle: angle / 180 * Math.PI,
          offset,
          extruded,
          stroked,
          coverage,
          elevationScale,
          edgeDistance,
          radiusUnits: UNIT[radiusUnits],
          widthUnits: UNIT[lineWidthUnits],
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels
        });
        if (extruded && wireframe) {
          model.setProps({
            isIndexed: true
          });
          model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({
            isStroke: true
          }).draw();
        }
        if (filled) {
          model.setProps({
            isIndexed: false
          });
          model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({
            isStroke: false
          }).draw();
        }
        if (!extruded && stroked) {
          model.setProps({
            isIndexed: false
          });
          model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({
            isStroke: true
          }).draw();
        }
      }
    };
    _defineProperty(ColumnLayer, "layerName", "ColumnLayer");
    _defineProperty(ColumnLayer, "defaultProps", defaultProps7);
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js
var defaultProps8, GridCellLayer;
var init_grid_cell_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js"() {
    init_defineProperty();
    init_esm11();
    init_esm13();
    init_column_layer();
    defaultProps8 = {
      cellSize: {
        type: "number",
        min: 0,
        value: 1e3
      },
      offset: {
        type: "array",
        value: [1, 1]
      }
    };
    GridCellLayer = class extends ColumnLayer {
      getGeometry(diskResolution) {
        return new CubeGeometry();
      }
      draw({
        uniforms
      }) {
        const {
          elevationScale,
          extruded,
          offset,
          coverage,
          cellSize,
          angle,
          radiusUnits
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          radius: cellSize / 2,
          radiusUnits: UNIT[radiusUnits],
          angle,
          offset,
          extruded,
          coverage,
          elevationScale,
          edgeDistance: 1,
          isWireframe: false
        }).draw();
      }
    };
    _defineProperty(GridCellLayer, "layerName", "GridCellLayer");
    _defineProperty(GridCellLayer, "defaultProps", defaultProps8);
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path.js
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length3 = path.length * size;
    flatPath = new Array(length3);
    for (let i3 = 0; i3 < path.length; i3++) {
      for (let j = 0; j < size; j++) {
        flatPath[i3 * size + j] = path[i3][j] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, {
      size,
      gridResolution
    });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, {
      size
    });
  }
  return flatPath;
}
var init_path = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path.js"() {
    init_esm14();
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js
function isCut(path) {
  return Array.isArray(path[0]);
}
var START_CAP, END_CAP, INVALID, PathTesselator;
var init_path_tesselator = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js"() {
    init_esm13();
    init_path();
    START_CAP = 1;
    END_CAP = 2;
    INVALID = 4;
    PathTesselator = class extends Tesselator {
      constructor(opts) {
        super({
          ...opts,
          attributes: {
            positions: {
              size: 3,
              padding: 18,
              initialize: true,
              type: opts.fp64 ? Float64Array : Float32Array
            },
            segmentTypes: {
              size: 1,
              type: Uint8ClampedArray
            }
          }
        });
      }
      get(attributeName) {
        return this.attributes[attributeName];
      }
      getGeometryFromBuffer(buffer) {
        if (this.normalize) {
          return super.getGeometryFromBuffer(buffer);
        }
        return null;
      }
      normalizeGeometry(path) {
        if (this.normalize) {
          return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
        }
        return path;
      }
      getGeometrySize(path) {
        if (isCut(path)) {
          let size = 0;
          for (const subPath of path) {
            size += this.getGeometrySize(subPath);
          }
          return size;
        }
        const numPoints = this.getPathLength(path);
        if (numPoints < 2) {
          return 0;
        }
        if (this.isClosed(path)) {
          return numPoints < 3 ? 0 : numPoints + 2;
        }
        return numPoints;
      }
      updateGeometryAttributes(path, context) {
        if (context.geometrySize === 0) {
          return;
        }
        if (path && isCut(path)) {
          for (const subPath of path) {
            const geometrySize = this.getGeometrySize(subPath);
            context.geometrySize = geometrySize;
            this.updateGeometryAttributes(subPath, context);
            context.vertexStart += geometrySize;
          }
        } else {
          this._updateSegmentTypes(path, context);
          this._updatePositions(path, context);
        }
      }
      _updateSegmentTypes(path, context) {
        const segmentTypes = this.attributes.segmentTypes;
        const isPathClosed = path ? this.isClosed(path) : false;
        const {
          vertexStart,
          geometrySize
        } = context;
        segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
        if (isPathClosed) {
          segmentTypes[vertexStart] = INVALID;
          segmentTypes[vertexStart + geometrySize - 2] = INVALID;
        } else {
          segmentTypes[vertexStart] += START_CAP;
          segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
        }
        segmentTypes[vertexStart + geometrySize - 1] = INVALID;
      }
      _updatePositions(path, context) {
        const {
          positions
        } = this.attributes;
        if (!positions || !path) {
          return;
        }
        const {
          vertexStart,
          geometrySize
        } = context;
        const p2 = new Array(3);
        for (let i3 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i3++, ptIndex++) {
          this.getPointOnPath(path, ptIndex, p2);
          positions[i3 * 3] = p2[0];
          positions[i3 * 3 + 1] = p2[1];
          positions[i3 * 3 + 2] = p2[2];
        }
      }
      getPathLength(path) {
        return path.length / this.positionSize;
      }
      getPointOnPath(path, index, target = []) {
        const {
          positionSize
        } = this;
        if (index * positionSize >= path.length) {
          index += 1 - path.length / positionSize;
        }
        const i3 = index * positionSize;
        target[0] = path[i3];
        target[1] = path[i3 + 1];
        target[2] = positionSize === 3 && path[i3 + 2] || 0;
        return target;
      }
      isClosed(path) {
        if (!this.normalize) {
          return Boolean(this.opts.loop);
        }
        const {
          positionSize
        } = this;
        const lastPointIndex = path.length - positionSize;
        return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default;
var init_path_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js"() {
    path_layer_vertex_glsl_default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default;
var init_path_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"() {
    path_layer_fragment_glsl_default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js
var DEFAULT_COLOR7, defaultProps9, ATTRIBUTE_TRANSITION, PathLayer;
var init_path_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_path_tesselator();
    init_path_layer_vertex_glsl();
    init_path_layer_fragment_glsl();
    DEFAULT_COLOR7 = [0, 0, 0, 255];
    defaultProps9 = {
      widthUnits: "meters",
      widthScale: {
        type: "number",
        min: 0,
        value: 1
      },
      widthMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      widthMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      jointRounded: false,
      capRounded: false,
      miterLimit: {
        type: "number",
        min: 0,
        value: 4
      },
      billboard: false,
      _pathType: null,
      getPath: {
        type: "accessor",
        value: (object) => object.path
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR7
      },
      getWidth: {
        type: "accessor",
        value: 1
      },
      rounded: {
        deprecatedFor: ["jointRounded", "capRounded"]
      }
    };
    ATTRIBUTE_TRANSITION = {
      enter: (value, chunk) => {
        return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
      }
    };
    PathLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        return super.getShaders({
          vs: path_layer_vertex_glsl_default,
          fs: path_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
      get wrapLongitude() {
        return false;
      }
      initializeState() {
        const noAlloc = true;
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          positions: {
            size: 3,
            vertexOffset: 1,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: ATTRIBUTE_TRANSITION,
            accessor: "getPath",
            update: this.calculatePositions,
            noAlloc,
            shaderAttributes: {
              instanceLeftPositions: {
                vertexOffset: 0
              },
              instanceStartPositions: {
                vertexOffset: 1
              },
              instanceEndPositions: {
                vertexOffset: 2
              },
              instanceRightPositions: {
                vertexOffset: 3
              }
            }
          },
          instanceTypes: {
            size: 1,
            type: 5121,
            update: this.calculateSegmentTypes,
            noAlloc
          },
          instanceStrokeWidths: {
            size: 1,
            accessor: "getWidth",
            transition: ATTRIBUTE_TRANSITION,
            defaultValue: 1
          },
          instanceColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            accessor: "getColor",
            transition: ATTRIBUTE_TRANSITION,
            defaultValue: DEFAULT_COLOR7
          },
          instancePickingColors: {
            size: 3,
            type: 5121,
            accessor: (object, {
              index,
              target: value
            }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
          }
        });
        this.setState({
          pathTesselator: new PathTesselator({
            fp64: this.use64bitPositions()
          })
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          changeFlags
        } = params;
        const attributeManager = this.getAttributeManager();
        const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
        if (geometryChanged) {
          const {
            pathTesselator
          } = this.state;
          const buffers = props.data.attributes || {};
          pathTesselator.updateGeometry({
            data: props.data,
            geometryBuffer: buffers.getPath,
            buffers,
            normalize: !props._pathType,
            loop: props._pathType === "loop",
            getGeometry: props.getPath,
            positionFormat: props.positionFormat,
            wrapLongitude: props.wrapLongitude,
            resolution: this.context.viewport.resolution,
            dataChanged: changeFlags.dataChanged
          });
          this.setState({
            numInstances: pathTesselator.instanceCount,
            startIndices: pathTesselator.vertexStarts
          });
          if (!changeFlags.dataChanged) {
            attributeManager.invalidateAll();
          }
        }
        if (changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          attributeManager.invalidateAll();
        }
      }
      getPickingInfo(params) {
        const info = super.getPickingInfo(params);
        const {
          index
        } = info;
        const {
          data
        } = this.props;
        if (data[0] && data[0].__source) {
          info.object = data.find((d) => d.__source.index === index);
        }
        return info;
      }
      disablePickingIndex(objectIndex) {
        const {
          data
        } = this.props;
        if (data[0] && data[0].__source) {
          for (let i3 = 0; i3 < data.length; i3++) {
            if (data[i3].__source.index === objectIndex) {
              this._disablePickingIndex(i3);
            }
          }
        } else {
          super.disablePickingIndex(objectIndex);
        }
      }
      draw({
        uniforms
      }) {
        const {
          jointRounded,
          capRounded,
          billboard,
          miterLimit,
          widthUnits,
          widthScale,
          widthMinPixels,
          widthMaxPixels
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          jointType: Number(jointRounded),
          capType: Number(capRounded),
          billboard,
          widthUnits: UNIT[widthUnits],
          widthScale,
          miterLimit,
          widthMinPixels,
          widthMaxPixels
        }).draw();
      }
      _getModel(gl) {
        const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
        const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 4,
            attributes: {
              indices: new Uint16Array(SEGMENT_INDICES),
              positions: {
                value: new Float32Array(SEGMENT_POSITIONS),
                size: 2
              }
            }
          }),
          isInstanced: true
        });
      }
      calculatePositions(attribute) {
        const {
          pathTesselator
        } = this.state;
        attribute.startIndices = pathTesselator.vertexStarts;
        attribute.value = pathTesselator.get("positions");
      }
      calculateSegmentTypes(attribute) {
        const {
          pathTesselator
        } = this.state;
        attribute.startIndices = pathTesselator.vertexStarts;
        attribute.value = pathTesselator.get("segmentTypes");
      }
    };
    _defineProperty(PathLayer, "defaultProps", defaultProps9);
    _defineProperty(PathLayer, "layerName", "PathLayer");
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i3 = 0; i3 < size; i3++) {
    if (positions[startIndex + i3] !== positions[endIndex - size + i3]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i3 = 0; i3 < len; i3++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i3][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i3 = 0; i3 < srcLength; i3++) {
    target[targetIndex++] = positions[srcStartIndex + i3];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i3 = 0; i3 < size; i3++) {
      target[targetIndex++] = positions[srcStartIndex + i3];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const {
      positions: srcPositions,
      holeIndices: srcHoleIndices
    } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i3 = 0; i3 <= srcHoleIndices.length; i3++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i3 - 1], srcHoleIndices[i3], i3 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return {
      positions,
      holeIndices
    };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area2 = 0;
  for (let i3 = 0; i3 < numVerts; i3++) {
    const j = (i3 + 1) % numVerts;
    area2 += positions[i3 * 3 + xIndex] * positions[j * 3 + yIndex];
    area2 -= positions[j * 3 + xIndex] * positions[i3 * 3 + yIndex];
  }
  return Math.abs(area2 / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i3 = 0; i3 < numVerts; i3++) {
    const o2 = i3 * 3;
    const x2 = positions[o2 + 0];
    const y2 = positions[o2 + 1];
    const z = positions[o2 + 2];
    positions[o2 + xIndex] = x2;
    positions[o2 + yIndex] = y2;
    positions[o2 + zIndex] = z;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n2 = positions.length;
    positions = positions.slice();
    const p2 = [];
    for (let i3 = 0; i3 < n2; i3 += positionSize) {
      p2[0] = positions[i3];
      p2[1] = positions[i3 + 1];
      if (is3d) {
        p2[2] = positions[i3 + 2];
      }
      const xy = preproject(p2);
      positions[i3] = xy[0];
      positions[i3 + 1] = xy[1];
      if (is3d) {
        positions[i3 + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {
    } else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 1, 2, 0);
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}
var import_earcut2, OUTER_POLYGON_WINDING, HOLE_POLYGON_WINDING, windingOptions;
var init_polygon2 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js"() {
    import_earcut2 = __toESM(require_earcut());
    init_esm14();
    OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
    HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
    windingOptions = {
      isClosed: true
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js
function isCut2(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}
var PolygonTesselator;
var init_polygon_tesselator = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js"() {
    init_polygon2();
    init_esm13();
    init_esm14();
    PolygonTesselator = class extends Tesselator {
      constructor(opts) {
        const {
          fp64: fp642,
          IndexType = Uint32Array
        } = opts;
        super({
          ...opts,
          attributes: {
            positions: {
              size: 3,
              type: fp642 ? Float64Array : Float32Array
            },
            vertexValid: {
              type: Uint8ClampedArray,
              size: 1
            },
            indices: {
              type: IndexType,
              size: 1
            }
          }
        });
      }
      get(attributeName) {
        const {
          attributes
        } = this;
        if (attributeName === "indices") {
          return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
        }
        return attributes[attributeName];
      }
      updateGeometry(opts) {
        super.updateGeometry(opts);
        const externalIndices = this.buffers.indices;
        if (externalIndices) {
          this.vertexCount = (externalIndices.value || externalIndices).length;
        } else if (this.data && !this.getGeometry) {
          throw new Error("missing indices buffer");
        }
      }
      normalizeGeometry(polygon) {
        if (this.normalize) {
          const normalizedPolygon = normalize(polygon, this.positionSize);
          if (this.opts.resolution) {
            return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
              size: this.positionSize,
              gridResolution: this.opts.resolution,
              edgeTypes: true
            });
          }
          if (this.opts.wrapLongitude) {
            return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
              size: this.positionSize,
              maxLatitude: 86,
              edgeTypes: true
            });
          }
          return normalizedPolygon;
        }
        return polygon;
      }
      getGeometrySize(polygon) {
        if (isCut2(polygon)) {
          let size = 0;
          for (const subPolygon of polygon) {
            size += this.getGeometrySize(subPolygon);
          }
          return size;
        }
        return getPositions(polygon).length / this.positionSize;
      }
      getGeometryFromBuffer(buffer) {
        if (this.normalize || !this.buffers.indices) {
          return super.getGeometryFromBuffer(buffer);
        }
        return null;
      }
      updateGeometryAttributes(polygon, context) {
        if (polygon && isCut2(polygon)) {
          for (const subPolygon of polygon) {
            const geometrySize = this.getGeometrySize(subPolygon);
            context.geometrySize = geometrySize;
            this.updateGeometryAttributes(subPolygon, context);
            context.vertexStart += geometrySize;
            context.indexStart = this.indexStarts[context.geometryIndex + 1];
          }
        } else {
          this._updateIndices(polygon, context);
          this._updatePositions(polygon, context);
          this._updateVertexValid(polygon, context);
        }
      }
      _updateIndices(polygon, {
        geometryIndex,
        vertexStart: offset,
        indexStart
      }) {
        const {
          attributes,
          indexStarts,
          typedArrayManager
        } = this;
        let target = attributes.indices;
        if (!target || !polygon) {
          return;
        }
        let i3 = indexStart;
        const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
        target = typedArrayManager.allocate(target, indexStart + indices.length, {
          copy: true
        });
        for (let j = 0; j < indices.length; j++) {
          target[i3++] = indices[j] + offset;
        }
        indexStarts[geometryIndex + 1] = indexStart + indices.length;
        attributes.indices = target;
      }
      _updatePositions(polygon, {
        vertexStart,
        geometrySize
      }) {
        const {
          attributes: {
            positions
          },
          positionSize
        } = this;
        if (!positions || !polygon) {
          return;
        }
        const polygonPositions = getPositions(polygon);
        for (let i3 = vertexStart, j = 0; j < geometrySize; i3++, j++) {
          const x2 = polygonPositions[j * positionSize];
          const y2 = polygonPositions[j * positionSize + 1];
          const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
          positions[i3 * 3] = x2;
          positions[i3 * 3 + 1] = y2;
          positions[i3 * 3 + 2] = z;
        }
      }
      _updateVertexValid(polygon, {
        vertexStart,
        geometrySize
      }) {
        const {
          positionSize
        } = this;
        const vertexValid = this.attributes.vertexValid;
        const holeIndices = polygon && getHoleIndices(polygon);
        if (polygon && polygon.edgeTypes) {
          vertexValid.set(polygon.edgeTypes, vertexStart);
        } else {
          vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
        }
        if (holeIndices) {
          for (let j = 0; j < holeIndices.length; j++) {
            vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
          }
        }
        vertexValid[vertexStart + geometrySize - 1] = 0;
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default;
var init_solid_polygon_layer_vertex_main_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"() {
    solid_polygon_layer_vertex_main_glsl_default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default;
var init_solid_polygon_layer_vertex_top_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js"() {
    init_solid_polygon_layer_vertex_main_glsl();
    solid_polygon_layer_vertex_top_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default;
var init_solid_polygon_layer_vertex_side_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js"() {
    init_solid_polygon_layer_vertex_main_glsl();
    solid_polygon_layer_vertex_side_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default;
var init_solid_polygon_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js"() {
    solid_polygon_layer_fragment_glsl_default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR8, defaultProps10, ATTRIBUTE_TRANSITION2, SolidPolygonLayer;
var init_solid_polygon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_polygon_tesselator();
    init_solid_polygon_layer_vertex_top_glsl();
    init_solid_polygon_layer_vertex_side_glsl();
    init_solid_polygon_layer_fragment_glsl();
    DEFAULT_COLOR8 = [0, 0, 0, 255];
    defaultProps10 = {
      filled: true,
      extruded: false,
      wireframe: false,
      _normalize: true,
      _windingOrder: "CW",
      _full3d: false,
      elevationScale: {
        type: "number",
        min: 0,
        value: 1
      },
      getPolygon: {
        type: "accessor",
        value: (f2) => f2.polygon
      },
      getElevation: {
        type: "accessor",
        value: 1e3
      },
      getFillColor: {
        type: "accessor",
        value: DEFAULT_COLOR8
      },
      getLineColor: {
        type: "accessor",
        value: DEFAULT_COLOR8
      },
      material: true
    };
    ATTRIBUTE_TRANSITION2 = {
      enter: (value, chunk) => {
        return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
      }
    };
    SolidPolygonLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders(type) {
        return super.getShaders({
          vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
          fs: solid_polygon_layer_fragment_glsl_default,
          defines: {
            RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
          },
          modules: [project32_default, gouraudLighting, picking_default]
        });
      }
      get wrapLongitude() {
        return false;
      }
      initializeState() {
        const {
          gl,
          viewport
        } = this.context;
        let {
          coordinateSystem
        } = this.props;
        const {
          _full3d
        } = this.props;
        if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
          coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
        }
        let preproject;
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          if (_full3d) {
            preproject = viewport.projectPosition.bind(viewport);
          } else {
            preproject = viewport.projectFlat.bind(viewport);
          }
        }
        this.setState({
          numInstances: 0,
          polygonTesselator: new PolygonTesselator({
            preproject,
            fp64: this.use64bitPositions(),
            IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
          })
        });
        const attributeManager = this.getAttributeManager();
        const noAlloc = true;
        attributeManager.remove(["instancePickingColors"]);
        attributeManager.add({
          indices: {
            size: 1,
            isIndexed: true,
            update: this.calculateIndices,
            noAlloc
          },
          positions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getPolygon",
            update: this.calculatePositions,
            noAlloc,
            shaderAttributes: {
              positions: {
                vertexOffset: 0,
                divisor: 0
              },
              instancePositions: {
                vertexOffset: 0,
                divisor: 1
              },
              nextPositions: {
                vertexOffset: 1,
                divisor: 1
              }
            }
          },
          vertexValid: {
            size: 1,
            divisor: 1,
            type: 5121,
            update: this.calculateVertexValid,
            noAlloc
          },
          elevations: {
            size: 1,
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getElevation",
            shaderAttributes: {
              elevations: {
                divisor: 0
              },
              instanceElevations: {
                divisor: 1
              }
            }
          },
          fillColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getFillColor",
            defaultValue: DEFAULT_COLOR8,
            shaderAttributes: {
              fillColors: {
                divisor: 0
              },
              instanceFillColors: {
                divisor: 1
              }
            }
          },
          lineColors: {
            size: this.props.colorFormat.length,
            type: 5121,
            normalized: true,
            transition: ATTRIBUTE_TRANSITION2,
            accessor: "getLineColor",
            defaultValue: DEFAULT_COLOR8,
            shaderAttributes: {
              lineColors: {
                divisor: 0
              },
              instanceLineColors: {
                divisor: 1
              }
            }
          },
          pickingColors: {
            size: 3,
            type: 5121,
            accessor: (object, {
              index,
              target: value
            }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),
            shaderAttributes: {
              pickingColors: {
                divisor: 0
              },
              instancePickingColors: {
                divisor: 1
              }
            }
          }
        });
      }
      getPickingInfo(params) {
        const info = super.getPickingInfo(params);
        const {
          index
        } = info;
        const {
          data
        } = this.props;
        if (data[0] && data[0].__source) {
          info.object = data.find((d) => d.__source.index === index);
        }
        return info;
      }
      disablePickingIndex(objectIndex) {
        const {
          data
        } = this.props;
        if (data[0] && data[0].__source) {
          for (let i3 = 0; i3 < data.length; i3++) {
            if (data[i3].__source.index === objectIndex) {
              this._disablePickingIndex(i3);
            }
          }
        } else {
          super.disablePickingIndex(objectIndex);
        }
      }
      draw({
        uniforms
      }) {
        const {
          extruded,
          filled,
          wireframe,
          elevationScale
        } = this.props;
        const {
          topModel,
          sideModel,
          polygonTesselator
        } = this.state;
        const renderUniforms = {
          ...uniforms,
          extruded: Boolean(extruded),
          elevationScale
        };
        if (sideModel) {
          sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
          sideModel.setUniforms(renderUniforms);
          if (wireframe) {
            sideModel.setDrawMode(3);
            sideModel.setUniforms({
              isWireframe: true
            }).draw();
          }
          if (filled) {
            sideModel.setDrawMode(6);
            sideModel.setUniforms({
              isWireframe: false
            }).draw();
          }
        }
        if (topModel) {
          topModel.setVertexCount(polygonTesselator.vertexCount);
          topModel.setUniforms(renderUniforms).draw();
        }
      }
      updateState(updateParams) {
        super.updateState(updateParams);
        this.updateGeometry(updateParams);
        const {
          props,
          oldProps,
          changeFlags
        } = updateParams;
        const attributeManager = this.getAttributeManager();
        const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
        if (regenerateModels) {
          var _this$state$models;
          (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach((model) => model.delete());
          this.setState(this._getModels(this.context.gl));
          attributeManager.invalidateAll();
        }
      }
      updateGeometry({
        props,
        oldProps,
        changeFlags
      }) {
        const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
        if (geometryConfigChanged) {
          const {
            polygonTesselator
          } = this.state;
          const buffers = props.data.attributes || {};
          polygonTesselator.updateGeometry({
            data: props.data,
            normalize: props._normalize,
            geometryBuffer: buffers.getPolygon,
            buffers,
            getGeometry: props.getPolygon,
            positionFormat: props.positionFormat,
            wrapLongitude: props.wrapLongitude,
            resolution: this.context.viewport.resolution,
            fp64: this.use64bitPositions(),
            dataChanged: changeFlags.dataChanged,
            full3d: props._full3d
          });
          this.setState({
            numInstances: polygonTesselator.instanceCount,
            startIndices: polygonTesselator.vertexStarts
          });
          if (!changeFlags.dataChanged) {
            this.getAttributeManager().invalidateAll();
          }
        }
      }
      _getModels(gl) {
        const {
          id,
          filled,
          extruded
        } = this.props;
        let topModel;
        let sideModel;
        if (filled) {
          const shaders = this.getShaders("top");
          shaders.defines.NON_INSTANCED_MODEL = 1;
          topModel = new Model(gl, {
            ...shaders,
            id: "".concat(id, "-top"),
            drawMode: 4,
            attributes: {
              vertexPositions: new Float32Array([0, 1])
            },
            uniforms: {
              isWireframe: false,
              isSideVertex: false
            },
            vertexCount: 0,
            isIndexed: true
          });
        }
        if (extruded) {
          sideModel = new Model(gl, {
            ...this.getShaders("side"),
            id: "".concat(id, "-side"),
            geometry: new Geometry({
              drawMode: 1,
              vertexCount: 4,
              attributes: {
                vertexPositions: {
                  size: 2,
                  value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
                }
              }
            }),
            instanceCount: 0,
            isInstanced: 1
          });
          sideModel.userData.excludeAttributes = {
            indices: true
          };
        }
        return {
          models: [sideModel, topModel].filter(Boolean),
          topModel,
          sideModel
        };
      }
      calculateIndices(attribute) {
        const {
          polygonTesselator
        } = this.state;
        attribute.startIndices = polygonTesselator.indexStarts;
        attribute.value = polygonTesselator.get("indices");
      }
      calculatePositions(attribute) {
        const {
          polygonTesselator
        } = this.state;
        attribute.startIndices = polygonTesselator.vertexStarts;
        attribute.value = polygonTesselator.get("positions");
      }
      calculateVertexValid(attribute) {
        attribute.value = this.state.polygonTesselator.get("vertexValid");
      }
    };
    _defineProperty(SolidPolygonLayer, "defaultProps", defaultProps10);
    _defineProperty(SolidPolygonLayer, "layerName", "SolidPolygonLayer");
  }
});

// node_modules/@deck.gl/layers/dist/esm/utils.js
function replaceInRange({
  data,
  getIndex,
  dataRange,
  replace
}) {
  const {
    startRow = 0,
    endRow = Infinity
  } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;
  for (let i3 = 0; i3 < count; i3++) {
    const row = getIndex(data[i3]);
    if (replaceStart > i3 && row >= startRow) {
      replaceStart = i3;
    }
    if (row >= endRow) {
      replaceEnd = i3;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
  for (let i3 = 0; i3 < replace.length; i3++) {
    data[index++] = replace[i3];
  }
  if (endChunk) {
    for (let i3 = 0; i3 < endChunk.length; i3++) {
      data[index++] = endChunk[i3];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}
var init_utils2 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/utils.js"() {
  }
});

// node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js
var defaultLineColor, defaultFillColor, defaultProps11, PolygonLayer;
var init_polygon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_solid_polygon_layer();
    init_path_layer();
    init_polygon2();
    init_utils2();
    defaultLineColor = [0, 0, 0, 255];
    defaultFillColor = [0, 0, 0, 255];
    defaultProps11 = {
      stroked: true,
      filled: true,
      extruded: false,
      elevationScale: 1,
      wireframe: false,
      _normalize: true,
      _windingOrder: "CW",
      lineWidthUnits: "meters",
      lineWidthScale: 1,
      lineWidthMinPixels: 0,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      lineJointRounded: false,
      lineMiterLimit: 4,
      getPolygon: {
        type: "accessor",
        value: (f2) => f2.polygon
      },
      getFillColor: {
        type: "accessor",
        value: defaultFillColor
      },
      getLineColor: {
        type: "accessor",
        value: defaultLineColor
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      },
      getElevation: {
        type: "accessor",
        value: 1e3
      },
      material: true
    };
    PolygonLayer = class extends CompositeLayer {
      initializeState() {
        this.state = {
          paths: []
        };
        if (this.props.getLineDashArray) {
          log_default.removed("getLineDashArray", "PathStyleExtension")();
        }
      }
      updateState({
        changeFlags
      }) {
        const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
        if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
          const paths = this.state.paths.slice();
          const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
            data: paths,
            getIndex: (p2) => p2.__source.index,
            dataRange,
            replace: this._getPaths(dataRange)
          }));
          this.setState({
            paths,
            pathsDiff
          });
        } else if (geometryChanged) {
          this.setState({
            paths: this._getPaths(),
            pathsDiff: null
          });
        }
      }
      _getPaths(dataRange = {}) {
        const {
          data,
          getPolygon,
          positionFormat,
          _normalize
        } = this.props;
        const paths = [];
        const positionSize = positionFormat === "XY" ? 2 : 3;
        const {
          startRow,
          endRow
        } = dataRange;
        const {
          iterable,
          objectInfo
        } = createIterable(data, startRow, endRow);
        for (const object of iterable) {
          objectInfo.index++;
          let polygon = getPolygon(object, objectInfo);
          if (_normalize) {
            polygon = normalize(polygon, positionSize);
          }
          const {
            holeIndices
          } = polygon;
          const positions = polygon.positions || polygon;
          if (holeIndices) {
            for (let i3 = 0; i3 <= holeIndices.length; i3++) {
              const path = positions.slice(holeIndices[i3 - 1] || 0, holeIndices[i3] || positions.length);
              paths.push(this.getSubLayerRow({
                path
              }, object, objectInfo.index));
            }
          } else {
            paths.push(this.getSubLayerRow({
              path: positions
            }, object, objectInfo.index));
          }
        }
        return paths;
      }
      renderLayers() {
        const {
          data,
          _dataDiff,
          stroked,
          filled,
          extruded,
          wireframe,
          _normalize,
          _windingOrder,
          elevationScale,
          transitions,
          positionFormat
        } = this.props;
        const {
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          lineJointRounded,
          lineMiterLimit,
          lineDashJustified
        } = this.props;
        const {
          getFillColor,
          getLineColor,
          getLineWidth,
          getLineDashArray,
          getElevation,
          getPolygon,
          updateTriggers,
          material
        } = this.props;
        const {
          paths,
          pathsDiff
        } = this.state;
        const FillLayer = this.getSubLayerClass("fill", SolidPolygonLayer);
        const StrokeLayer = this.getSubLayerClass("stroke", PathLayer);
        const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
          _dataDiff,
          extruded,
          elevationScale,
          filled,
          wireframe,
          _normalize,
          _windingOrder,
          getElevation,
          getFillColor,
          getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
          material,
          transitions
        }, this.getSubLayerProps({
          id: "fill",
          updateTriggers: updateTriggers && {
            getPolygon: updateTriggers.getPolygon,
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            lineColors: extruded && wireframe,
            getLineColor: updateTriggers.getLineColor
          }
        }), {
          data,
          positionFormat,
          getPolygon
        });
        const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
          _dataDiff: pathsDiff && (() => pathsDiff),
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          jointRounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,
          _pathType: "loop",
          transitions: transitions && {
            getWidth: transitions.getLineWidth,
            getColor: transitions.getLineColor,
            getPath: transitions.getPolygon
          },
          getColor: this.getSubLayerAccessor(getLineColor),
          getWidth: this.getSubLayerAccessor(getLineWidth),
          getDashArray: this.getSubLayerAccessor(getLineDashArray)
        }, this.getSubLayerProps({
          id: "stroke",
          updateTriggers: updateTriggers && {
            getWidth: updateTriggers.getLineWidth,
            getColor: updateTriggers.getLineColor,
            getDashArray: updateTriggers.getLineDashArray
          }
        }), {
          data: paths,
          positionFormat,
          getPath: (x2) => x2.path
        });
        return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];
      }
    };
    _defineProperty(PolygonLayer, "layerName", "PolygonLayer");
    _defineProperty(PolygonLayer, "defaultProps", defaultProps11);
  }
});

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: {
      ...data.properties[propertiesIndex]
    }
  };
  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
    const pickingColor = [];
    for (let i3 = 0; i3 < featureIds.length; i3++) {
      encodePickingColor(featureIds[i3], pickingColor);
      pickingColors[key][i3 * 3 + 0] = pickingColor[0];
      pickingColors[key][i3 * 3 + 1] = pickingColor[1];
      pickingColors[key][i3 * 3 + 2] = pickingColor[2];
    }
  }
  return pickingColors;
}
var init_geojson_binary = __esm({
  "node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js"() {
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default;
var init_multi_icon_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js"() {
    multi_icon_layer_fragment_glsl_default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER2, EMPTY_ARRAY, defaultProps12, MultiIconLayer;
var init_multi_icon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_icon_layer();
    init_multi_icon_layer_fragment_glsl();
    DEFAULT_BUFFER2 = 192 / 256;
    EMPTY_ARRAY = [];
    defaultProps12 = {
      getIconOffsets: {
        type: "accessor",
        value: (x2) => x2.offsets
      },
      alphaCutoff: 1e-3,
      smoothing: 0.1,
      outlineWidth: 0,
      outlineColor: {
        type: "color",
        value: [0, 0, 0, 255]
      }
    };
    MultiIconLayer = class extends IconLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        return {
          ...super.getShaders(),
          fs: multi_icon_layer_fragment_glsl_default
        };
      }
      initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instanceOffsets: {
            size: 2,
            accessor: "getIconOffsets"
          },
          instancePickingColors: {
            type: 5121,
            size: 3,
            accessor: (object, {
              index,
              target: value
            }) => this.encodePickingColor(index, value)
          }
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps
        } = params;
        let {
          outlineColor
        } = props;
        if (outlineColor !== oldProps.outlineColor) {
          outlineColor = outlineColor.map((x2) => x2 / 255);
          outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
          this.setState({
            outlineColor
          });
        }
        if (!props.sdf && props.outlineWidth) {
          log_default.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))();
        }
      }
      draw(params) {
        const {
          sdf,
          smoothing,
          outlineWidth
        } = this.props;
        const {
          outlineColor
        } = this.state;
        const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
        params.uniforms = {
          ...params.uniforms,
          sdfBuffer: DEFAULT_BUFFER2,
          outlineBuffer,
          gamma: smoothing,
          sdf: Boolean(sdf),
          outlineColor
        };
        super.draw(params);
        if (sdf && outlineWidth) {
          const {
            iconManager
          } = this.state;
          const iconsTexture = iconManager.getTexture();
          if (iconsTexture) {
            this.state.model.draw({
              uniforms: {
                outlineBuffer: DEFAULT_BUFFER2
              }
            });
          }
        }
      }
      getInstanceOffset(icons) {
        return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
      }
      getInstanceColorMode(icons) {
        return 1;
      }
      getInstanceIconFrame(icons) {
        return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
      }
    };
    _defineProperty(MultiIconLayer, "defaultProps", defaultProps12);
    _defineProperty(MultiIconLayer, "layerName", "MultiIconLayer");
  }
});

// node_modules/@mapbox/tiny-sdf/index.js
function edt(data, x0, y0, width, height, gridSize, f2, v, z) {
  for (let x2 = x0; x2 < x0 + width; x2++)
    edt1d(data, y0 * gridSize + x2, gridSize, height, f2, v, z);
  for (let y2 = y0; y2 < y0 + height; y2++)
    edt1d(data, y2 * gridSize + x0, 1, width, f2, v, z);
}
function edt1d(grid, offset, stride, length3, f2, v, z) {
  v[0] = 0;
  z[0] = -INF;
  z[1] = INF;
  f2[0] = grid[offset];
  for (let q = 1, k = 0, s2 = 0; q < length3; q++) {
    f2[q] = grid[offset + q * stride];
    const q2 = q * q;
    do {
      const r2 = v[k];
      s2 = (f2[q] - f2[r2] + q2 - r2 * r2) / (q - r2) / 2;
    } while (s2 <= z[k] && --k > -1);
    k++;
    v[k] = q;
    z[k] = s2;
    z[k + 1] = INF;
  }
  for (let q = 0, k = 0; q < length3; q++) {
    while (z[k + 1] < q)
      k++;
    const r2 = v[k];
    const qr = q - r2;
    grid[offset + q * stride] = f2[r2] + qr * qr;
  }
}
var INF, TinySDF;
var init_tiny_sdf = __esm({
  "node_modules/@mapbox/tiny-sdf/index.js"() {
    INF = 1e20;
    TinySDF = class {
      constructor({
        fontSize = 24,
        buffer = 3,
        radius = 8,
        cutoff = 0.25,
        fontFamily = "sans-serif",
        fontWeight = "normal",
        fontStyle = "normal"
      } = {}) {
        this.buffer = buffer;
        this.cutoff = cutoff;
        this.radius = radius;
        const size = this.size = fontSize + buffer * 4;
        const canvas = this._createCanvas(size);
        const ctx = this.ctx = canvas.getContext("2d", { willReadFrequently: true });
        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
        ctx.textBaseline = "alphabetic";
        ctx.textAlign = "left";
        ctx.fillStyle = "black";
        this.gridOuter = new Float64Array(size * size);
        this.gridInner = new Float64Array(size * size);
        this.f = new Float64Array(size);
        this.z = new Float64Array(size + 1);
        this.v = new Uint16Array(size);
      }
      _createCanvas(size) {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = size;
        return canvas;
      }
      draw(char) {
        const {
          width: glyphAdvance,
          actualBoundingBoxAscent,
          actualBoundingBoxDescent,
          actualBoundingBoxLeft,
          actualBoundingBoxRight
        } = this.ctx.measureText(char);
        const glyphTop = Math.ceil(actualBoundingBoxAscent);
        const glyphLeft = 0;
        const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
        const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
        const width = glyphWidth + 2 * this.buffer;
        const height = glyphHeight + 2 * this.buffer;
        const len = Math.max(width * height, 0);
        const data = new Uint8ClampedArray(len);
        const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
        if (glyphWidth === 0 || glyphHeight === 0)
          return glyph;
        const { ctx, buffer, gridInner, gridOuter } = this;
        ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
        ctx.fillText(char, buffer, buffer + glyphTop);
        const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
        gridOuter.fill(INF, 0, len);
        gridInner.fill(0, 0, len);
        for (let y2 = 0; y2 < glyphHeight; y2++) {
          for (let x2 = 0; x2 < glyphWidth; x2++) {
            const a2 = imgData.data[4 * (y2 * glyphWidth + x2) + 3] / 255;
            if (a2 === 0)
              continue;
            const j = (y2 + buffer) * width + x2 + buffer;
            if (a2 === 1) {
              gridOuter[j] = 0;
              gridInner[j] = INF;
            } else {
              const d = 0.5 - a2;
              gridOuter[j] = d > 0 ? d * d : 0;
              gridInner[j] = d < 0 ? d * d : 0;
            }
          }
        }
        edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
        edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
        for (let i3 = 0; i3 < len; i3++) {
          const d = Math.sqrt(gridOuter[i3]) - Math.sqrt(gridInner[i3]);
          data[i3] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
        }
        return glyph;
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2({
  characterSet,
  getFontWidth,
  fontHeight,
  buffer,
  maxCanvasWidth,
  mapping = {},
  xOffset = 0,
  yOffset = 0
}) {
  let row = 0;
  let x2 = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x2 + width + buffer * 2 > maxCanvasWidth) {
        x2 = 0;
        row++;
      }
      mapping[char] = {
        x: x2 + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x2 += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x2,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    var _mapping$character;
    const character = text[i3];
    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const textWidth = getTextWidth(text, i3, i3 + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i3) {
        target.push(i3);
      }
      rowStartCharIndex = i3;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    if (text[i3] === " ") {
      groupEndCharIndex = i3 + 1;
    } else if (text[i3 + 1] === " " || i3 + 1 === endIndex) {
      groupEndCharIndex = i3 + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x2 = 0;
  let rowHeight = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const character = line[i3];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i3] = x2 + frame.layoutWidth / 2;
      x2 += frame.layoutWidth;
    } else {
      log_default.warn("Missing character: ".concat(character, " (").concat(character.codePointAt(0), ")"))();
      leftOffsets[i3] = x2;
      x2 += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x2;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x2 = new Array(numCharacters);
  const y2 = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i3 = 0; i3 <= numCharacters; i3++) {
    const char = characters[i3];
    if (char === "\n" || i3 === numCharacters) {
      lineEndIndex = i3;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x2, rowSize);
        for (let j = rowStart; j < rowEnd; j++) {
          var _iconMapping$char;
          const char2 = characters[j];
          const layoutOffsetY = ((_iconMapping$char = iconMapping[char2]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;
          y2[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x2[lineStartIndex] = 0;
      y2[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return {
    x: x2,
    y: y2,
    rowWidth,
    size
  };
}
function getTextFromBuffer({
  value,
  length: length3,
  stride,
  offset,
  startIndices,
  characterSet
}) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length3] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length3);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i3 = 0; i3 < characterCount; i3++) {
      codes[i3] = value[i3 * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length3; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return {
    texts,
    characterCount
  };
}
var MISSING_CHAR_WIDTH, SINGLE_LINE;
var init_utils3 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js"() {
    init_esm13();
    MISSING_CHAR_WIDTH = 32;
    SINGLE_LINE = [];
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js
var LRUCache;
var init_lru_cache = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js"() {
    init_defineProperty();
    LRUCache = class {
      constructor(limit = 5) {
        _defineProperty(this, "limit", void 0);
        _defineProperty(this, "_cache", {});
        _defineProperty(this, "_order", []);
        this.limit = limit;
      }
      get(key) {
        const value = this._cache[key];
        if (value) {
          this._deleteOrder(key);
          this._appendOrder(key);
        }
        return value;
      }
      set(key, value) {
        if (!this._cache[key]) {
          if (Object.keys(this._cache).length === this.limit) {
            this.delete(this._order[0]);
          }
          this._cache[key] = value;
          this._appendOrder(key);
        } else {
          this.delete(key);
          this._cache[key] = value;
          this._appendOrder(key);
        }
      }
      delete(key) {
        const value = this._cache[key];
        if (value) {
          delete this._cache[key];
          this._deleteOrder(key);
        }
      }
      _deleteOrder(key) {
        const index = this._order.indexOf(key);
        if (index >= 0) {
          this._order.splice(index, 1);
        }
      }
      _appendOrder(key) {
        this._order.push(key);
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i3 = 32; i3 < 128; i3++) {
    charSet.push(String.fromCharCode(i3));
  }
  return charSet;
}
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i3 = 0; i3 < alphaChannel.length; i3++) {
    imageData.data[4 * i3 + 3] = alphaChannel[i3];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache = new LRUCache(limit);
}
var DEFAULT_FONT_SETTINGS, MAX_CANVAS_WIDTH, BASELINE_SCALE, HEIGHT_SCALE, CACHE_LIMIT, cache, FontAtlasManager;
var init_font_atlas_manager = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js"() {
    init_defineProperty();
    init_tiny_sdf();
    init_esm13();
    init_utils3();
    init_lru_cache();
    DEFAULT_FONT_SETTINGS = {
      fontFamily: "Monaco, monospace",
      fontWeight: "normal",
      characterSet: getDefaultCharacterSet(),
      fontSize: 64,
      buffer: 4,
      sdf: false,
      cutoff: 0.25,
      radius: 12,
      smoothing: 0.1
    };
    MAX_CANVAS_WIDTH = 1024;
    BASELINE_SCALE = 0.9;
    HEIGHT_SCALE = 1.2;
    CACHE_LIMIT = 3;
    cache = new LRUCache(CACHE_LIMIT);
    FontAtlasManager = class {
      constructor() {
        _defineProperty(this, "props", {
          ...DEFAULT_FONT_SETTINGS
        });
        _defineProperty(this, "_key", void 0);
        _defineProperty(this, "_atlas", void 0);
      }
      get texture() {
        return this._atlas;
      }
      get mapping() {
        return this._atlas && this._atlas.mapping;
      }
      get scale() {
        const {
          fontSize,
          buffer
        } = this.props;
        return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
      }
      setProps(props = {}) {
        Object.assign(this.props, props);
        this._key = this._getKey();
        const charSet = getNewChars(this._key, this.props.characterSet);
        const cachedFontAtlas = cache.get(this._key);
        if (cachedFontAtlas && charSet.size === 0) {
          if (this._atlas !== cachedFontAtlas) {
            this._atlas = cachedFontAtlas;
          }
          return;
        }
        const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
        this._atlas = fontAtlas;
        cache.set(this._key, fontAtlas);
      }
      _generateFontAtlas(characterSet, cachedFontAtlas) {
        const {
          fontFamily,
          fontWeight,
          fontSize,
          buffer,
          sdf,
          radius,
          cutoff
        } = this.props;
        let canvas = cachedFontAtlas && cachedFontAtlas.data;
        if (!canvas) {
          canvas = document.createElement("canvas");
          canvas.width = MAX_CANVAS_WIDTH;
        }
        const ctx = canvas.getContext("2d", {
          willReadFrequently: true
        });
        setTextStyle(ctx, fontFamily, fontSize, fontWeight);
        const {
          mapping,
          canvasHeight,
          xOffset,
          yOffset
        } = buildMapping2({
          getFontWidth: (char) => ctx.measureText(char).width,
          fontHeight: fontSize * HEIGHT_SCALE,
          buffer,
          characterSet,
          maxCanvasWidth: MAX_CANVAS_WIDTH,
          ...cachedFontAtlas && {
            mapping: cachedFontAtlas.mapping,
            xOffset: cachedFontAtlas.xOffset,
            yOffset: cachedFontAtlas.yOffset
          }
        });
        if (canvas.height !== canvasHeight) {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          canvas.height = canvasHeight;
          ctx.putImageData(imageData, 0, 0);
        }
        setTextStyle(ctx, fontFamily, fontSize, fontWeight);
        if (sdf) {
          const tinySDF = new TinySDF({
            fontSize,
            buffer,
            radius,
            cutoff,
            fontFamily,
            fontWeight: "".concat(fontWeight)
          });
          for (const char of characterSet) {
            const {
              data,
              width,
              height,
              glyphTop
            } = tinySDF.draw(char);
            mapping[char].width = width;
            mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
            const imageData = ctx.createImageData(width, height);
            populateAlphaChannel(data, imageData);
            ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
          }
        } else {
          for (const char of characterSet) {
            ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
          }
        }
        return {
          xOffset,
          yOffset,
          mapping,
          data: canvas,
          width: canvas.width,
          height: canvas.height
        };
      }
      _getKey() {
        const {
          fontFamily,
          fontWeight,
          fontSize,
          buffer,
          sdf,
          radius,
          cutoff
        } = this.props;
        if (sdf) {
          return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
        }
        return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default;
var init_text_background_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js"() {
    text_background_layer_vertex_glsl_default = "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default;
var init_text_background_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js"() {
    text_background_layer_fragment_glsl_default = "#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js
var defaultProps13, TextBackgroundLayer;
var init_text_background_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_text_background_layer_vertex_glsl();
    init_text_background_layer_fragment_glsl();
    defaultProps13 = {
      billboard: true,
      sizeScale: 1,
      sizeUnits: "pixels",
      sizeMinPixels: 0,
      sizeMaxPixels: Number.MAX_SAFE_INTEGER,
      padding: {
        type: "array",
        value: [0, 0, 0, 0]
      },
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getSize: {
        type: "accessor",
        value: 1
      },
      getAngle: {
        type: "accessor",
        value: 0
      },
      getPixelOffset: {
        type: "accessor",
        value: [0, 0]
      },
      getBoundingRect: {
        type: "accessor",
        value: [0, 0, 0, 0]
      },
      getFillColor: {
        type: "accessor",
        value: [0, 0, 0, 255]
      },
      getLineColor: {
        type: "accessor",
        value: [0, 0, 0, 255]
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      }
    };
    TextBackgroundLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        return super.getShaders({
          vs: text_background_layer_vertex_glsl_default,
          fs: text_background_layer_fragment_glsl_default,
          modules: [project32_default, picking_default]
        });
      }
      initializeState() {
        this.getAttributeManager().addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            transition: true,
            accessor: "getPosition"
          },
          instanceSizes: {
            size: 1,
            transition: true,
            accessor: "getSize",
            defaultValue: 1
          },
          instanceAngles: {
            size: 1,
            transition: true,
            accessor: "getAngle"
          },
          instanceRects: {
            size: 4,
            accessor: "getBoundingRect"
          },
          instancePixelOffsets: {
            size: 2,
            transition: true,
            accessor: "getPixelOffset"
          },
          instanceFillColors: {
            size: 4,
            transition: true,
            normalized: true,
            type: 5121,
            accessor: "getFillColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceLineColors: {
            size: 4,
            transition: true,
            normalized: true,
            type: 5121,
            accessor: "getLineColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceLineWidths: {
            size: 1,
            transition: true,
            accessor: "getLineWidth",
            defaultValue: 1
          }
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          changeFlags
        } = params;
        if (changeFlags.extensionsChanged) {
          var _this$state$model;
          const {
            gl
          } = this.context;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          this.state.model = this._getModel(gl);
          this.getAttributeManager().invalidateAll();
        }
      }
      draw({
        uniforms
      }) {
        const {
          billboard,
          sizeScale,
          sizeUnits,
          sizeMinPixels,
          sizeMaxPixels,
          getLineWidth
        } = this.props;
        let {
          padding
        } = this.props;
        if (padding.length < 4) {
          padding = [padding[0], padding[1], padding[0], padding[1]];
        }
        this.state.model.setUniforms(uniforms).setUniforms({
          billboard,
          stroked: Boolean(getLineWidth),
          padding,
          sizeUnits: UNIT[sizeUnits],
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels
        }).draw();
      }
      _getModel(gl) {
        const positions = [0, 0, 1, 0, 1, 1, 0, 1];
        return new Model(gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: new Geometry({
            drawMode: 6,
            vertexCount: 4,
            attributes: {
              positions: {
                size: 2,
                value: new Float32Array(positions)
              }
            }
          }),
          isInstanced: true
        });
      }
    };
    _defineProperty(TextBackgroundLayer, "defaultProps", defaultProps13);
    _defineProperty(TextBackgroundLayer, "layerName", "TextBackgroundLayer");
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js
var TEXT_ANCHOR, ALIGNMENT_BASELINE, DEFAULT_COLOR9, DEFAULT_LINE_HEIGHT, defaultProps14, TextLayer;
var init_text_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_multi_icon_layer();
    init_font_atlas_manager();
    init_utils3();
    init_text_background_layer();
    TEXT_ANCHOR = {
      start: 1,
      middle: 0,
      end: -1
    };
    ALIGNMENT_BASELINE = {
      top: 1,
      center: 0,
      bottom: -1
    };
    DEFAULT_COLOR9 = [0, 0, 0, 255];
    DEFAULT_LINE_HEIGHT = 1;
    defaultProps14 = {
      billboard: true,
      sizeScale: 1,
      sizeUnits: "pixels",
      sizeMinPixels: 0,
      sizeMaxPixels: Number.MAX_SAFE_INTEGER,
      background: false,
      getBackgroundColor: {
        type: "accessor",
        value: [255, 255, 255, 255]
      },
      getBorderColor: {
        type: "accessor",
        value: DEFAULT_COLOR9
      },
      getBorderWidth: {
        type: "accessor",
        value: 0
      },
      backgroundPadding: {
        type: "array",
        value: [0, 0, 0, 0]
      },
      characterSet: {
        type: "object",
        value: DEFAULT_FONT_SETTINGS.characterSet
      },
      fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
      fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
      lineHeight: DEFAULT_LINE_HEIGHT,
      outlineWidth: {
        type: "number",
        value: 0,
        min: 0
      },
      outlineColor: {
        type: "color",
        value: DEFAULT_COLOR9
      },
      fontSettings: {
        type: "object",
        value: {},
        compare: 1
      },
      wordBreak: "break-word",
      maxWidth: {
        type: "number",
        value: -1
      },
      getText: {
        type: "accessor",
        value: (x2) => x2.text
      },
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR9
      },
      getSize: {
        type: "accessor",
        value: 32
      },
      getAngle: {
        type: "accessor",
        value: 0
      },
      getTextAnchor: {
        type: "accessor",
        value: "middle"
      },
      getAlignmentBaseline: {
        type: "accessor",
        value: "center"
      },
      getPixelOffset: {
        type: "accessor",
        value: [0, 0]
      },
      backgroundColor: {
        deprecatedFor: ["background", "getBackgroundColor"]
      }
    };
    TextLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
        _defineProperty(this, "getBoundingRect", (object, objectInfo) => {
          let {
            size: [width, height]
          } = this.transformParagraph(object, objectInfo);
          const {
            fontSize
          } = this.state.fontAtlasManager.props;
          width /= fontSize;
          height /= fontSize;
          const {
            getTextAnchor,
            getAlignmentBaseline
          } = this.props;
          const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
          const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
          return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
        });
        _defineProperty(this, "getIconOffsets", (object, objectInfo) => {
          const {
            getTextAnchor,
            getAlignmentBaseline
          } = this.props;
          const {
            x: x2,
            y: y2,
            rowWidth,
            size: [width, height]
          } = this.transformParagraph(object, objectInfo);
          const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
          const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
          const numCharacters = x2.length;
          const offsets = new Array(numCharacters * 2);
          let index = 0;
          for (let i3 = 0; i3 < numCharacters; i3++) {
            const rowOffset = (1 - anchorX) * (width - rowWidth[i3]) / 2;
            offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x2[i3];
            offsets[index++] = (anchorY - 1) * height / 2 + y2[i3];
          }
          return offsets;
        });
      }
      initializeState() {
        this.state = {
          styleVersion: 0,
          fontAtlasManager: new FontAtlasManager()
        };
        if (this.props.maxWidth > 0) {
          log_default.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
        }
      }
      updateState(params) {
        const {
          props,
          oldProps,
          changeFlags
        } = params;
        const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
        if (textChanged) {
          this._updateText();
        }
        const fontChanged = this._updateFontAtlas();
        const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
        if (styleChanged) {
          this.setState({
            styleVersion: this.state.styleVersion + 1
          });
        }
      }
      getPickingInfo({
        info
      }) {
        info.object = info.index >= 0 ? this.props.data[info.index] : null;
        return info;
      }
      _updateFontAtlas() {
        const {
          fontSettings,
          fontFamily,
          fontWeight
        } = this.props;
        const {
          fontAtlasManager,
          characterSet
        } = this.state;
        const fontProps = {
          ...fontSettings,
          characterSet,
          fontFamily,
          fontWeight
        };
        if (!fontAtlasManager.mapping) {
          fontAtlasManager.setProps(fontProps);
          return true;
        }
        for (const key in fontProps) {
          if (fontProps[key] !== fontAtlasManager.props[key]) {
            fontAtlasManager.setProps(fontProps);
            return true;
          }
        }
        return false;
      }
      _updateText() {
        var _attributes;
        const {
          data,
          characterSet
        } = this.props;
        const textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;
        let {
          getText
        } = this.props;
        let startIndices = data.startIndices;
        let numInstances;
        const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
        if (textBuffer && startIndices) {
          const {
            texts,
            characterCount
          } = getTextFromBuffer({
            ...ArrayBuffer.isView(textBuffer) ? {
              value: textBuffer
            } : textBuffer,
            length: data.length,
            startIndices,
            characterSet: autoCharacterSet
          });
          numInstances = characterCount;
          getText = (_2, {
            index
          }) => texts[index];
        } else {
          const {
            iterable,
            objectInfo
          } = createIterable(data);
          startIndices = [0];
          numInstances = 0;
          for (const object of iterable) {
            objectInfo.index++;
            const text = Array.from(getText(object, objectInfo) || "");
            if (autoCharacterSet) {
              text.forEach(autoCharacterSet.add, autoCharacterSet);
            }
            numInstances += text.length;
            startIndices.push(numInstances);
          }
        }
        this.setState({
          getText,
          startIndices,
          numInstances,
          characterSet: autoCharacterSet || characterSet
        });
      }
      transformParagraph(object, objectInfo) {
        const {
          fontAtlasManager
        } = this.state;
        const iconMapping = fontAtlasManager.mapping;
        const getText = this.state.getText;
        const {
          wordBreak,
          lineHeight,
          maxWidth
        } = this.props;
        const paragraph = getText(object, objectInfo) || "";
        return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
      }
      renderLayers() {
        const {
          startIndices,
          numInstances,
          getText,
          fontAtlasManager: {
            scale,
            texture,
            mapping
          },
          styleVersion
        } = this.state;
        const {
          data,
          _dataDiff,
          getPosition,
          getColor,
          getSize,
          getAngle,
          getPixelOffset,
          getBackgroundColor,
          getBorderColor,
          getBorderWidth,
          backgroundPadding,
          background,
          billboard,
          fontSettings,
          outlineWidth,
          outlineColor,
          sizeScale,
          sizeUnits,
          sizeMinPixels,
          sizeMaxPixels,
          transitions,
          updateTriggers
        } = this.props;
        const CharactersLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
        const BackgroundLayerClass = this.getSubLayerClass("background", TextBackgroundLayer);
        return [background && new BackgroundLayerClass({
          getFillColor: getBackgroundColor,
          getLineColor: getBorderColor,
          getLineWidth: getBorderWidth,
          padding: backgroundPadding,
          getPosition,
          getSize,
          getAngle,
          getPixelOffset,
          billboard,
          sizeScale,
          sizeUnits,
          sizeMinPixels,
          sizeMaxPixels,
          transitions: transitions && {
            getPosition: transitions.getPosition,
            getAngle: transitions.getAngle,
            getSize: transitions.getSize,
            getFillColor: transitions.getBackgroundColor,
            getLineColor: transitions.getBorderColor,
            getLineWidth: transitions.getBorderWidth,
            getPixelOffset: transitions.getPixelOffset
          }
        }, this.getSubLayerProps({
          id: "background",
          updateTriggers: {
            getPosition: updateTriggers.getPosition,
            getAngle: updateTriggers.getAngle,
            getSize: updateTriggers.getSize,
            getFillColor: updateTriggers.getBackgroundColor,
            getLineColor: updateTriggers.getBorderColor,
            getLineWidth: updateTriggers.getBorderWidth,
            getPixelOffset: updateTriggers.getPixelOffset,
            getBoundingRect: {
              getText: updateTriggers.getText,
              getTextAnchor: updateTriggers.getTextAnchor,
              getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
              styleVersion
            }
          }
        }), {
          data: data.attributes && data.attributes.background ? {
            length: data.length,
            attributes: data.attributes.background
          } : data,
          _dataDiff,
          autoHighlight: false,
          getBoundingRect: this.getBoundingRect
        }), new CharactersLayerClass({
          sdf: fontSettings.sdf,
          smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
          outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
          outlineColor,
          iconAtlas: texture,
          iconMapping: mapping,
          getPosition,
          getColor,
          getSize,
          getAngle,
          getPixelOffset,
          billboard,
          sizeScale: sizeScale * scale,
          sizeUnits,
          sizeMinPixels: sizeMinPixels * scale,
          sizeMaxPixels: sizeMaxPixels * scale,
          transitions: transitions && {
            getPosition: transitions.getPosition,
            getAngle: transitions.getAngle,
            getColor: transitions.getColor,
            getSize: transitions.getSize,
            getPixelOffset: transitions.getPixelOffset
          }
        }, this.getSubLayerProps({
          id: "characters",
          updateTriggers: {
            all: updateTriggers.getText,
            getPosition: updateTriggers.getPosition,
            getAngle: updateTriggers.getAngle,
            getColor: updateTriggers.getColor,
            getSize: updateTriggers.getSize,
            getPixelOffset: updateTriggers.getPixelOffset,
            getIconOffsets: {
              getTextAnchor: updateTriggers.getTextAnchor,
              getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
              styleVersion
            }
          }
        }), {
          data,
          _dataDiff,
          startIndices,
          numInstances,
          getIconOffsets: this.getIconOffsets,
          getIcon: getText
        })];
      }
      static set fontAtlasCacheLimit(limit) {
        setFontAtlasCacheLimit(limit);
      }
    };
    _defineProperty(TextLayer, "defaultProps", defaultProps14);
    _defineProperty(TextLayer, "layerName", "TextLayer");
  }
});

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js
function getDefaultProps({
  type,
  props
}) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const {
    transitions,
    updateTriggers
  } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}
var POINT_LAYER, LINE_LAYER, POLYGON_LAYER;
var init_sub_layer_map = __esm({
  "node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js"() {
    init_icon_layer();
    init_scatterplot_layer();
    init_text_layer();
    init_path_layer();
    init_solid_polygon_layer();
    POINT_LAYER = {
      circle: {
        type: ScatterplotLayer,
        props: {
          filled: "filled",
          stroked: "stroked",
          lineWidthMaxPixels: "lineWidthMaxPixels",
          lineWidthMinPixels: "lineWidthMinPixels",
          lineWidthScale: "lineWidthScale",
          lineWidthUnits: "lineWidthUnits",
          pointRadiusMaxPixels: "radiusMaxPixels",
          pointRadiusMinPixels: "radiusMinPixels",
          pointRadiusScale: "radiusScale",
          pointRadiusUnits: "radiusUnits",
          pointAntialiasing: "antialiasing",
          pointBillboard: "billboard",
          getFillColor: "getFillColor",
          getLineColor: "getLineColor",
          getLineWidth: "getLineWidth",
          getPointRadius: "getRadius"
        }
      },
      icon: {
        type: IconLayer,
        props: {
          iconAtlas: "iconAtlas",
          iconMapping: "iconMapping",
          iconSizeMaxPixels: "sizeMaxPixels",
          iconSizeMinPixels: "sizeMinPixels",
          iconSizeScale: "sizeScale",
          iconSizeUnits: "sizeUnits",
          iconAlphaCutoff: "alphaCutoff",
          iconBillboard: "billboard",
          getIcon: "getIcon",
          getIconAngle: "getAngle",
          getIconColor: "getColor",
          getIconPixelOffset: "getPixelOffset",
          getIconSize: "getSize"
        }
      },
      text: {
        type: TextLayer,
        props: {
          textSizeMaxPixels: "sizeMaxPixels",
          textSizeMinPixels: "sizeMinPixels",
          textSizeScale: "sizeScale",
          textSizeUnits: "sizeUnits",
          textBackground: "background",
          textBackgroundPadding: "backgroundPadding",
          textFontFamily: "fontFamily",
          textFontWeight: "fontWeight",
          textLineHeight: "lineHeight",
          textMaxWidth: "maxWidth",
          textOutlineColor: "outlineColor",
          textOutlineWidth: "outlineWidth",
          textWordBreak: "wordBreak",
          textCharacterSet: "characterSet",
          textBillboard: "billboard",
          textFontSettings: "fontSettings",
          getText: "getText",
          getTextAngle: "getAngle",
          getTextColor: "getColor",
          getTextPixelOffset: "getPixelOffset",
          getTextSize: "getSize",
          getTextAnchor: "getTextAnchor",
          getTextAlignmentBaseline: "getAlignmentBaseline",
          getTextBackgroundColor: "getBackgroundColor",
          getTextBorderColor: "getBorderColor",
          getTextBorderWidth: "getBorderWidth"
        }
      }
    };
    LINE_LAYER = {
      type: PathLayer,
      props: {
        lineWidthUnits: "widthUnits",
        lineWidthScale: "widthScale",
        lineWidthMinPixels: "widthMinPixels",
        lineWidthMaxPixels: "widthMaxPixels",
        lineJointRounded: "jointRounded",
        lineCapRounded: "capRounded",
        lineMiterLimit: "miterLimit",
        lineBillboard: "billboard",
        getLineColor: "getColor",
        getLineWidth: "getWidth"
      }
    };
    POLYGON_LAYER = {
      type: SolidPolygonLayer,
      props: {
        extruded: "extruded",
        filled: "filled",
        wireframe: "wireframe",
        elevationScale: "elevationScale",
        material: "material",
        _full3d: "_full3d",
        getElevation: "getElevation",
        getFillColor: "getFillColor",
        getLineColor: "getLineColor"
      }
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{
        geometry: geojson
      }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const {
    startRow = 0,
    endRow = features.length
  } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const {
      geometry
    } = feature;
    if (!geometry) {
      continue;
    }
    if (geometry.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
      const {
        geometries
      } = geometry;
      for (let i3 = 0; i3 < geometries.length; i3++) {
        const subGeometry = geometries[i3];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const {
    type,
    coordinates
  } = geometry;
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = separated;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn("".concat(type, " coordinates are malformed"))();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point) => {
        pointFeatures.push(wrapFeature({
          geometry: {
            type: "Point",
            coordinates: point
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: {
            type: "LineString",
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: {
            type: "LineString",
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: {
            type: "Polygon",
            coordinates: polygon
          }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, "Unknown GeoJSON type ".concat(type));
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}
var COORDINATE_NEST_LEVEL;
var init_geojson = __esm({
  "node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js"() {
    init_esm13();
    COORDINATE_NEST_LEVEL = {
      Point: 1,
      MultiPoint: 2,
      LineString: 2,
      MultiLineString: 3,
      Polygon: 3,
      MultiPolygon: 4
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f2) {
  return f2.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const {
    points,
    lines,
    polygons
  } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}
var init_geojson_layer_props = __esm({
  "node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js"() {
    init_geojson_binary();
  }
});

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js
var FEATURE_TYPES, defaultProps15, GeoJsonLayer;
var init_geojson_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_utils2();
    init_geojson_binary();
    init_sub_layer_map();
    init_geojson();
    init_geojson_layer_props();
    FEATURE_TYPES = ["points", "linestrings", "polygons"];
    defaultProps15 = {
      ...getDefaultProps(POINT_LAYER.circle),
      ...getDefaultProps(POINT_LAYER.icon),
      ...getDefaultProps(POINT_LAYER.text),
      ...getDefaultProps(LINE_LAYER),
      ...getDefaultProps(POLYGON_LAYER),
      stroked: true,
      filled: true,
      extruded: false,
      wireframe: false,
      _full3d: false,
      iconAtlas: {
        type: "object",
        value: null
      },
      iconMapping: {
        type: "object",
        value: {}
      },
      getIcon: {
        type: "accessor",
        value: (f2) => f2.properties.icon
      },
      getText: {
        type: "accessor",
        value: (f2) => f2.properties.text
      },
      pointType: "circle",
      getRadius: {
        deprecatedFor: "getPointRadius"
      }
    };
    GeoJsonLayer = class extends CompositeLayer {
      initializeState() {
        this.state = {
          layerProps: {},
          features: {}
        };
      }
      updateState({
        props,
        changeFlags
      }) {
        if (!changeFlags.dataChanged) {
          return;
        }
        const {
          data
        } = this.props;
        const binary = data && "points" in data && "polygons" in data && "lines" in data;
        this.setState({
          binary
        });
        if (binary) {
          this._updateStateBinary({
            props,
            changeFlags
          });
        } else {
          this._updateStateJSON({
            props,
            changeFlags
          });
        }
      }
      _updateStateBinary({
        props,
        changeFlags
      }) {
        const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
        this.setState({
          layerProps
        });
      }
      _updateStateJSON({
        props,
        changeFlags
      }) {
        const features = getGeojsonFeatures(props.data);
        const wrapFeature = this.getSubLayerRow.bind(this);
        let newFeatures = {};
        const featuresDiff = {};
        if (Array.isArray(changeFlags.dataChanged)) {
          const oldFeatures = this.state.features;
          for (const key in oldFeatures) {
            newFeatures[key] = oldFeatures[key].slice();
            featuresDiff[key] = [];
          }
          for (const dataRange of changeFlags.dataChanged) {
            const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
            for (const key in oldFeatures) {
              featuresDiff[key].push(replaceInRange({
                data: newFeatures[key],
                getIndex: (f2) => f2.__source.index,
                dataRange,
                replace: partialFeatures[key]
              }));
            }
          }
        } else {
          newFeatures = separateGeojsonFeatures(features, wrapFeature);
        }
        const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
        this.setState({
          features: newFeatures,
          featuresDiff,
          layerProps
        });
      }
      getPickingInfo(params) {
        const info = super.getPickingInfo(params);
        const {
          index,
          sourceLayer
        } = info;
        info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith("".concat(this.id, "-").concat(ft, "-")));
        if (index >= 0 && sourceLayer.id.startsWith("".concat(this.id, "-points-text")) && this.state.binary) {
          info.index = this.props.data.points.globalFeatureIds.value[index];
        }
        return info;
      }
      _updateAutoHighlight(info) {
        const pointLayerIdPrefix = "".concat(this.id, "-points-");
        const sourceIsPoints = info.featureType === "points";
        for (const layer of this.getSubLayers()) {
          if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
            layer.updateAutoHighlight(info);
          }
        }
      }
      _renderPolygonLayer() {
        const {
          extruded,
          wireframe
        } = this.props;
        const {
          layerProps
        } = this.state;
        const id = "polygons-fill";
        const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
        if (PolygonFillLayer) {
          const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
          const useLineColor = extruded && wireframe;
          if (!useLineColor) {
            delete forwardedProps.getLineColor;
          }
          forwardedProps.updateTriggers.lineColors = useLineColor;
          return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
            id,
            updateTriggers: forwardedProps.updateTriggers
          }), layerProps.polygons);
        }
        return null;
      }
      _renderLineLayers() {
        const {
          extruded,
          stroked
        } = this.props;
        const {
          layerProps
        } = this.state;
        const polygonStrokeLayerId = "polygons-stroke";
        const lineStringsLayerId = "linestrings";
        const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
        const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
        if (PolygonStrokeLayer || LineStringsLayer) {
          const forwardedProps = forwardProps(this, LINE_LAYER.props);
          return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
            id: polygonStrokeLayerId,
            updateTriggers: forwardedProps.updateTriggers
          }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
            id: lineStringsLayerId,
            updateTriggers: forwardedProps.updateTriggers
          }), layerProps.lines)];
        }
        return null;
      }
      _renderPointLayers() {
        const {
          pointType
        } = this.props;
        const {
          layerProps,
          binary
        } = this.state;
        let {
          highlightedObjectIndex
        } = this.props;
        if (!binary && Number.isFinite(highlightedObjectIndex)) {
          highlightedObjectIndex = layerProps.points.data.findIndex((d) => d.__source.index === highlightedObjectIndex);
        }
        const types = new Set(pointType.split("+"));
        const pointLayers = [];
        for (const type of types) {
          const id = "points-".concat(type);
          const PointLayerMapping = POINT_LAYER[type];
          const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);
          if (PointsLayer) {
            const forwardedProps = forwardProps(this, PointLayerMapping.props);
            let pointsLayerProps = layerProps.points;
            if (type === "text" && binary) {
              const {
                instancePickingColors,
                ...rest
              } = pointsLayerProps.data.attributes;
              pointsLayerProps = {
                ...pointsLayerProps,
                data: {
                  ...pointsLayerProps.data,
                  attributes: rest
                }
              };
            }
            pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
              id,
              updateTriggers: forwardedProps.updateTriggers,
              highlightedObjectIndex
            }), pointsLayerProps));
          }
        }
        return pointLayers;
      }
      renderLayers() {
        const {
          extruded
        } = this.props;
        const polygonFillLayer = this._renderPolygonLayer();
        const lineLayers = this._renderLineLayers();
        const pointLayers = this._renderPointLayers();
        return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];
      }
      getSubLayerAccessor(accessor) {
        const {
          binary
        } = this.state;
        if (!binary || typeof accessor !== "function") {
          return super.getSubLayerAccessor(accessor);
        }
        return (object, info) => {
          const {
            data,
            index
          } = info;
          const feature = binaryToFeatureForAccesor(data, index);
          return accessor(feature, info);
        };
      }
    };
    _defineProperty(GeoJsonLayer, "layerName", "GeoJsonLayer");
    _defineProperty(GeoJsonLayer, "defaultProps", defaultProps15);
  }
});

// node_modules/@deck.gl/layers/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  ArcLayer: () => ArcLayer,
  BitmapLayer: () => BitmapLayer,
  ColumnLayer: () => ColumnLayer,
  GeoJsonLayer: () => GeoJsonLayer,
  GridCellLayer: () => GridCellLayer,
  IconLayer: () => IconLayer,
  LineLayer: () => LineLayer,
  PathLayer: () => PathLayer,
  PointCloudLayer: () => PointCloudLayer,
  PolygonLayer: () => PolygonLayer,
  ScatterplotLayer: () => ScatterplotLayer,
  SolidPolygonLayer: () => SolidPolygonLayer,
  TextLayer: () => TextLayer,
  _MultiIconLayer: () => MultiIconLayer,
  _TextBackgroundLayer: () => TextBackgroundLayer
});
var init_esm15 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/index.js"() {
    init_arc_layer();
    init_bitmap_layer();
    init_icon_layer();
    init_line_layer();
    init_point_cloud_layer();
    init_scatterplot_layer();
    init_column_layer();
    init_grid_cell_layer();
    init_path_layer();
    init_polygon_layer();
    init_geojson_layer();
    init_text_layer();
    init_solid_polygon_layer();
    init_multi_icon_layer();
    init_text_background_layer();
  }
});

// node_modules/@nebula.gl/layers/dist-es6/constants.js
var require_constants = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UNIT = exports.PROJECTED_PIXEL_SIZE_MULTIPLIER = void 0;
    var PROJECTED_PIXEL_SIZE_MULTIPLIER = 2 / 3;
    exports.PROJECTED_PIXEL_SIZE_MULTIPLIER = PROJECTED_PIXEL_SIZE_MULTIPLIER;
    var UNIT2 = {
      common: 0,
      meters: 1,
      pixels: 2
    };
    exports.UNIT = UNIT2;
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-layer.js
var require_editable_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm13(), __toCommonJS(esm_exports2));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3] != null ? arguments[i3] : {};
        if (i3 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _createForOfIteratorHelper(o2) {
      if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
        if (Array.isArray(o2) || (o2 = _unsupportedIterableToArray(o2))) {
          var i3 = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i3 >= o2.length)
              return { done: true };
            return { done: false, value: o2[i3++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s2() {
        it = o2[Symbol.iterator]();
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f2() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var EVENT_TYPES = ["anyclick", "pointermove", "panstart", "panmove", "panend", "keyup"];
    var EditableLayer = function(_CompositeLayer) {
      _inherits(EditableLayer2, _CompositeLayer);
      var _super = _createSuper(EditableLayer2);
      function EditableLayer2() {
        _classCallCheck(this, EditableLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditableLayer2, [{
        key: "onLayerClick",
        // Overridable interaction event handlers
        value: function onLayerClick(event) {
        }
      }, {
        key: "onStartDragging",
        value: function onStartDragging(event) {
        }
      }, {
        key: "onStopDragging",
        value: function onStopDragging(event) {
        }
      }, {
        key: "onDragging",
        value: function onDragging(event) {
        }
      }, {
        key: "onPointerMove",
        value: function onPointerMove(event) {
        }
      }, {
        key: "onLayerKeyUp",
        value: function onLayerKeyUp(event) {
        }
        // default implementation - do nothing;
        // TODO: implement onCancelDragging (e.g. drag off screen)
      }, {
        key: "initializeState",
        value: function initializeState() {
          this.setState({
            _editableLayerState: {
              // Picked objects at the time the pointer went down
              pointerDownPicks: null,
              // Screen coordinates where the pointer went down
              pointerDownScreenCoords: null,
              // Ground coordinates where the pointer went down
              pointerDownMapCoords: null,
              // Keep track of the mjolnir.js event handler so it can be deregistered
              eventHandler: this._forwardEventToCurrentLayer.bind(this)
            }
          });
          this._addEventHandlers();
        }
      }, {
        key: "finalizeState",
        value: function finalizeState() {
          this._removeEventHandlers();
        }
      }, {
        key: "_addEventHandlers",
        value: function _addEventHandlers() {
          var eventManager = this.context.deck.eventManager;
          var eventHandler = this.state._editableLayerState.eventHandler;
          var _iterator = _createForOfIteratorHelper(EVENT_TYPES), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var eventType = _step.value;
              eventManager.on(eventType, eventHandler, {
                // give nebula a higher priority so that it can stop propagation to deck.gl's map panning handlers
                priority: 100
              });
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          var eventManager = this.context.deck.eventManager;
          var eventHandler = this.state._editableLayerState.eventHandler;
          var _iterator2 = _createForOfIteratorHelper(EVENT_TYPES), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var eventType = _step2.value;
              eventManager.off(eventType, eventHandler);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        // A new layer instance is created on every render, so forward the event to the current layer
        // This means that the first layer instance will stick around to be the event listener, but will forward the event
        // to the latest layer instance.
      }, {
        key: "_forwardEventToCurrentLayer",
        value: function _forwardEventToCurrentLayer(event) {
          var currentLayer = this.getCurrentLayer();
          var func = currentLayer["_on".concat(event.type)].bind(currentLayer);
          if (!func) {
            console.warn("no handler for mjolnir.js event ".concat(event.type));
            return;
          }
          func(event);
        }
      }, {
        key: "_onanyclick",
        value: function _onanyclick(_ref) {
          var srcEvent = _ref.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var picks = this.getPicks(screenCoords);
          this.onLayerClick({
            mapCoords,
            // @ts-ignore
            screenCoords,
            picks,
            sourceEvent: srcEvent
          });
        }
      }, {
        key: "_onkeyup",
        value: function _onkeyup(_ref2) {
          var srcEvent = _ref2.srcEvent;
          this.onLayerKeyUp(srcEvent);
        }
      }, {
        key: "_onpanstart",
        value: function _onpanstart(event) {
          var screenCoords = this.getScreenCoords(event.srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var picks = this.getPicks(screenCoords);
          this.setState({
            _editableLayerState: _objectSpread({}, this.state._editableLayerState, {
              pointerDownScreenCoords: screenCoords,
              pointerDownMapCoords: mapCoords,
              pointerDownPicks: picks
            })
          });
          this.onStartDragging({
            picks,
            // @ts-ignore
            screenCoords,
            // @ts-ignore
            mapCoords,
            // @ts-ignore
            pointerDownScreenCoords: screenCoords,
            pointerDownMapCoords: mapCoords,
            cancelPan: event.stopImmediatePropagation,
            sourceEvent: event.srcEvent
          });
        }
      }, {
        key: "_onpanmove",
        value: function _onpanmove(event) {
          var srcEvent = event.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var _this$state$_editable = this.state._editableLayerState, pointerDownPicks = _this$state$_editable.pointerDownPicks, pointerDownScreenCoords = _this$state$_editable.pointerDownScreenCoords, pointerDownMapCoords = _this$state$_editable.pointerDownMapCoords;
          var picks = this.getPicks(screenCoords);
          this.onDragging({
            // @ts-ignore
            screenCoords,
            mapCoords,
            picks,
            pointerDownPicks,
            pointerDownScreenCoords,
            pointerDownMapCoords,
            sourceEvent: srcEvent,
            cancelPan: event.stopImmediatePropagation
            // another (hacky) approach for cancelling map panning
            // const controller = this.context.deck.viewManager.controllers[
            //   Object.keys(this.context.deck.viewManager.controllers)[0]
            // ];
            // controller._state.isDragging = false;
          });
        }
      }, {
        key: "_onpanend",
        value: function _onpanend(_ref3) {
          var srcEvent = _ref3.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var _this$state$_editable2 = this.state._editableLayerState, pointerDownPicks = _this$state$_editable2.pointerDownPicks, pointerDownScreenCoords = _this$state$_editable2.pointerDownScreenCoords, pointerDownMapCoords = _this$state$_editable2.pointerDownMapCoords;
          var picks = this.getPicks(screenCoords);
          this.onStopDragging({
            picks,
            // @ts-ignore
            screenCoords,
            mapCoords,
            pointerDownPicks,
            pointerDownScreenCoords,
            pointerDownMapCoords,
            sourceEvent: srcEvent
          });
          this.setState({
            _editableLayerState: _objectSpread({}, this.state._editableLayerState, {
              pointerDownScreenCoords: null,
              pointerDownMapCoords: null,
              pointerDownPicks: null
            })
          });
        }
      }, {
        key: "_onpointermove",
        value: function _onpointermove(event) {
          var srcEvent = event.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var _this$state$_editable3 = this.state._editableLayerState, pointerDownPicks = _this$state$_editable3.pointerDownPicks, pointerDownScreenCoords = _this$state$_editable3.pointerDownScreenCoords, pointerDownMapCoords = _this$state$_editable3.pointerDownMapCoords;
          var picks = this.getPicks(screenCoords);
          this.onPointerMove({
            // @ts-ignore
            screenCoords,
            mapCoords,
            picks,
            pointerDownPicks,
            pointerDownScreenCoords,
            pointerDownMapCoords,
            sourceEvent: srcEvent
          });
        }
      }, {
        key: "getPicks",
        value: function getPicks(screenCoords) {
          return this.context.deck.pickMultipleObjects({
            x: screenCoords[0],
            y: screenCoords[1],
            layerIds: [this.props.id],
            radius: this.props.pickingRadius,
            depth: this.props.pickingDepth
          });
        }
      }, {
        key: "getScreenCoords",
        value: function getScreenCoords(pointerEvent) {
          return [pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().left, pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().top];
        }
      }, {
        key: "getMapCoords",
        value: function getMapCoords(screenCoords) {
          return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);
        }
      }]);
      return EditableLayer2;
    }(_core.CompositeLayer);
    exports["default"] = EditableLayer;
    _defineProperty2(EditableLayer, "layerName", "EditableLayer");
  }
});

// node_modules/@nebula.gl/layers/dist-es6/utils.js
var require_utils = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toDeckColor = toDeckColor;
    exports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;
    exports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;
    exports.distance2d = distance2d;
    exports.mix = mix;
    exports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;
    exports.insertBefore = insertBefore;
    var _destination = _interopRequireDefault(require_js3());
    var _bearing = _interopRequireDefault(require_js4());
    var _pointToLineDistance = _interopRequireDefault(require_js5());
    var _helpers = require_js();
    var _viewportMercatorProject = _interopRequireDefault((init_module(), __toCommonJS(module_exports)));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _slicedToArray(arr, i3) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i3) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i3 && _arr.length === i3)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function toDeckColor(color) {
      var defaultColor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [255, 0, 0, 255];
      if (!Array.isArray(color)) {
        return defaultColor;
      }
      return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];
    }
    function recursivelyTraverseNestedArrays(array, prefix, fn) {
      if (!Array.isArray(array[0])) {
        return true;
      }
      for (var i3 = 0; i3 < array.length; i3++) {
        if (recursivelyTraverseNestedArrays(array[i3], [].concat(_toConsumableArray(prefix), [i3]), fn)) {
          fn(array, prefix);
          break;
        }
      }
      return false;
    }
    function generatePointsParallelToLinePoints(p1, p2, groundCoords) {
      var lineString = {
        type: "LineString",
        coordinates: [p1, p2]
      };
      var pt = (0, _helpers.point)(groundCoords);
      var ddistance = (0, _pointToLineDistance["default"])(pt, lineString);
      var lineBearing = (0, _bearing["default"])(p1, p2);
      var isPointToLeftOfLine = (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]);
      var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;
      var p3 = (0, _destination["default"])(p2, ddistance, orthogonalBearing);
      var p4 = (0, _destination["default"])(p1, ddistance, orthogonalBearing);
      return [p3.geometry.coordinates, p4.geometry.coordinates];
    }
    function distance2d(x1, y1, x2, y2) {
      var dx = x1 - x2;
      var dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function mix(a2, b, ratio) {
      return b * ratio + a2 * (1 - ratio);
    }
    function nearestPointOnProjectedLine(line, inPoint, viewport) {
      var wmViewport = new _viewportMercatorProject["default"](viewport);
      var coordinates = line.geometry.coordinates;
      var projectedCoords = coordinates.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 3), x3 = _ref2[0], y3 = _ref2[1], _ref2$ = _ref2[2], z = _ref2$ === void 0 ? 0 : _ref2$;
        return wmViewport.project([x3, y3, z]);
      });
      var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates), _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2), x2 = _wmViewport$project2[0], y2 = _wmViewport$project2[1];
      var minDistance = Infinity;
      var minPointInfo = {};
      projectedCoords.forEach(function(_ref3, index2) {
        var _ref4 = _slicedToArray(_ref3, 2), x23 = _ref4[0], y23 = _ref4[1];
        if (index2 === 0) {
          return;
        }
        var _projectedCoords = _slicedToArray(projectedCoords[index2 - 1], 2), x12 = _projectedCoords[0], y12 = _projectedCoords[1];
        var A = y12 - y23;
        var B = x23 - x12;
        var C = x12 * y23 - x23 * y12;
        var div = A * A + B * B;
        var distance = Math.abs(A * x2 + B * y2 + C) / Math.sqrt(div);
        if (distance < minDistance) {
          minDistance = distance;
          minPointInfo = {
            index: index2,
            x0: (B * (B * x2 - A * y2) - A * C) / div,
            y0: (A * (-B * x2 + A * y2) - B * C) / div
          };
        }
      });
      var _minPointInfo = minPointInfo, index = _minPointInfo.index, x0 = _minPointInfo.x0, y0 = _minPointInfo.y0;
      var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3), x1 = _projectedCoords2[0], y1 = _projectedCoords2[1], _projectedCoords2$ = _projectedCoords2[2], z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;
      var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3), x22 = _projectedCoords$inde[0], y22 = _projectedCoords$inde[1], _projectedCoords$inde2 = _projectedCoords$inde[2], z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2;
      var lineLength = distance2d(x1, y1, x22, y22);
      var startToPointLength = distance2d(x1, y1, x0, y0);
      var ratio = startToPointLength / lineLength;
      var z0 = mix(z1, z2, ratio);
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: wmViewport.unproject([x0, y0, z0])
        },
        properties: {
          // TODO: calculate the distance in proper units
          dist: minDistance,
          index: index - 1
        }
      };
    }
    function insertBefore(base, insertBefore2, toInsert) {
      var at = base.indexOf(insertBefore2);
      if (at < 0) {
        return base;
      }
      return base.slice(0, at) + toInsert + base.slice(at);
    }
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-path-layer.js
var require_editable_path_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-path-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _layers = (init_esm15(), __toCommonJS(esm_exports3));
    var _utils = require_utils();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3] != null ? arguments[i3] : {};
        if (i3 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defaultProps40 = _objectSpread({}, _layers.PathLayer.defaultProps, {
      pickingLineWidthExtraPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      }
    });
    var EditablePathLayer = function(_PathLayer) {
      _inherits(EditablePathLayer2, _PathLayer);
      var _super = _createSuper(EditablePathLayer2);
      function EditablePathLayer2() {
        _classCallCheck(this, EditablePathLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditablePathLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          var _shaders$inject;
          var shaders = _get(_getPrototypeOf(EditablePathLayer2.prototype), "getShaders", this).call(this);
          shaders.vs = (0, _utils.insertBefore)(shaders.vs, "vec3 width;", "\n       if(picking_uActive){\n        widthPixels.xy += pickingLineWidthExtraPixels;\n       }\n      ");
          return _objectSpread({}, shaders, {
            inject: _objectSpread({}, shaders.inject || {}, {
              "vs:#decl": (((_shaders$inject = shaders.inject) === null || _shaders$inject === void 0 ? void 0 : _shaders$inject["vs:#decl"]) || "").concat("uniform float pickingLineWidthExtraPixels;")
            })
          });
        }
      }, {
        key: "draw",
        value: function draw(props) {
          _get(_getPrototypeOf(EditablePathLayer2.prototype), "draw", this).call(this, _objectSpread({}, props, {
            uniforms: _objectSpread({}, props.uniforms, {
              pickingLineWidthExtraPixels: this.props.pickingLineWidthExtraPixels
            })
          }));
        }
      }]);
      return EditablePathLayer2;
    }(_layers.PathLayer);
    exports["default"] = EditablePathLayer;
    EditablePathLayer.defaultProps = defaultProps40;
    EditablePathLayer.layerName = "EditablePathLayer";
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-geojson-layer.js
var require_editable_geojson_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-geojson-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _layers = (init_esm15(), __toCommonJS(esm_exports3));
    var _editModes = require_dist_es6();
    var _constants = require_constants();
    var _editableLayer = _interopRequireDefault(require_editable_layer());
    var _editablePathLayer = _interopRequireDefault(require_editable_path_layer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3] != null ? arguments[i3] : {};
        if (i3 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _createForOfIteratorHelper(o2) {
      if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
        if (Array.isArray(o2) || (o2 = _unsupportedIterableToArray(o2))) {
          var i3 = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i3 >= o2.length)
              return { done: true };
            return { done: false, value: o2[i3++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s2() {
        it = o2[Symbol.iterator]();
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f2() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DEFAULT_LINE_COLOR = [0, 0, 0, 153];
    var DEFAULT_FILL_COLOR = [0, 0, 0, 144];
    var DEFAULT_SELECTED_LINE_COLOR = [0, 0, 0, 255];
    var DEFAULT_SELECTED_FILL_COLOR = [0, 0, 144, 144];
    var DEFAULT_TENTATIVE_LINE_COLOR = [144, 144, 144, 255];
    var DEFAULT_TENTATIVE_FILL_COLOR = [144, 144, 144, 144];
    var DEFAULT_EDITING_EXISTING_POINT_COLOR = [192, 0, 0, 255];
    var DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0, 0, 0, 128];
    var DEFAULT_EDITING_SNAP_POINT_COLOR = [124, 0, 192, 255];
    var DEFAULT_EDITING_POINT_OUTLINE_COLOR = [255, 255, 255, 255];
    var DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;
    var DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;
    var DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;
    var DEFAULT_TOOLTIP_FONT_SIZE = 32 * _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER;
    var DEFAULT_EDIT_MODE = _editModes.DrawPolygonMode;
    function guideAccessor(accessor) {
      if (!accessor || typeof accessor !== "function") {
        return accessor;
      }
      return function(guideMaybeWrapped) {
        return accessor(unwrapGuide(guideMaybeWrapped));
      };
    }
    function unwrapGuide(guideMaybeWrapped) {
      if (guideMaybeWrapped.__source) {
        return guideMaybeWrapped.__source.object;
      } else if (guideMaybeWrapped.sourceFeature) {
        return guideMaybeWrapped.sourceFeature.feature;
      }
      return guideMaybeWrapped;
    }
    function getEditHandleColor(handle) {
      switch (handle.properties.editHandleType) {
        case "existing":
          return DEFAULT_EDITING_EXISTING_POINT_COLOR;
        case "snap-source":
          return DEFAULT_EDITING_SNAP_POINT_COLOR;
        case "intermediate":
        default:
          return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;
      }
    }
    function getEditHandleOutlineColor(handle) {
      return DEFAULT_EDITING_POINT_OUTLINE_COLOR;
    }
    function getEditHandleRadius(handle) {
      switch (handle.properties.editHandleType) {
        case "existing":
          return DEFAULT_EDITING_EXISTING_POINT_RADIUS;
        case "snap":
          return DEFAULT_EDITING_SNAP_POINT_RADIUS;
        case "intermediate":
        default:
          return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;
      }
    }
    var defaultProps40 = {
      mode: DEFAULT_EDIT_MODE,
      // Edit and interaction events
      onEdit: function onEdit() {
      },
      pickable: true,
      pickingRadius: 10,
      pickingDepth: 5,
      fp64: false,
      filled: true,
      stroked: true,
      lineWidthScale: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,
      lineWidthMinPixels: 1,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      pickingLineWidthExtraPixels: 0,
      lineWidthUnits: "pixels",
      lineJointRounded: false,
      lineCapRounded: false,
      lineMiterLimit: 4,
      pointRadiusScale: 1,
      pointRadiusMinPixels: 2,
      pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,
      getLineColor: function getLineColor(feature, isSelected, mode) {
        return isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR;
      },
      getFillColor: function getFillColor(feature, isSelected, mode) {
        return isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR;
      },
      getRadius: function getRadius(f2) {
        return f2 && f2.properties && f2.properties.radius || f2 && f2.properties && f2.properties.size || 1;
      },
      getLineWidth: function getLineWidth(f2) {
        return f2 && f2.properties && f2.properties.lineWidth || 3;
      },
      // Tentative feature rendering
      getTentativeLineColor: function getTentativeLineColor(f2) {
        return DEFAULT_TENTATIVE_LINE_COLOR;
      },
      getTentativeFillColor: function getTentativeFillColor(f2) {
        return DEFAULT_TENTATIVE_FILL_COLOR;
      },
      getTentativeLineWidth: function getTentativeLineWidth(f2) {
        return f2 && f2.properties && f2.properties.lineWidth || 3;
      },
      editHandleType: "point",
      // point handles
      editHandlePointRadiusScale: 1,
      editHandlePointOutline: true,
      editHandlePointStrokeWidth: 2,
      editHandlePointRadiusUnits: "pixels",
      editHandlePointRadiusMinPixels: 4,
      editHandlePointRadiusMaxPixels: 8,
      getEditHandlePointColor: getEditHandleColor,
      getEditHandlePointOutlineColor: getEditHandleOutlineColor,
      getEditHandlePointRadius: getEditHandleRadius,
      // icon handles
      editHandleIconAtlas: null,
      editHandleIconMapping: null,
      editHandleIconSizeScale: 1,
      editHandleIconSizeUnits: "pixels",
      getEditHandleIcon: function getEditHandleIcon(handle) {
        return handle.properties.editHandleType;
      },
      getEditHandleIconSize: 10,
      getEditHandleIconColor: getEditHandleColor,
      getEditHandleIconAngle: 0,
      // misc
      billboard: true
    };
    var modeNameMapping = {
      view: _editModes.ViewMode,
      // Alter modes
      modify: _editModes.ModifyMode,
      translate: new _editModes.SnappableMode(new _editModes.TranslateMode()),
      transform: new _editModes.SnappableMode(new _editModes.TransformMode()),
      scale: _editModes.ScaleMode,
      rotate: _editModes.RotateMode,
      duplicate: _editModes.DuplicateMode,
      split: _editModes.SplitPolygonMode,
      extrude: _editModes.ExtrudeMode,
      elevation: _editModes.ElevationMode,
      // Draw modes
      drawPoint: _editModes.DrawPointMode,
      drawLineString: _editModes.DrawLineStringMode,
      drawPolygon: _editModes.DrawPolygonMode,
      drawRectangle: _editModes.DrawRectangleMode,
      drawSquare: _editModes.DrawSquareMode,
      drawRectangleFromCenter: _editModes.DrawRectangleFromCenterMode,
      drawSquareFromCenter: _editModes.DrawSquareFromCenterMode,
      drawCircleFromCenter: _editModes.DrawCircleFromCenterMode,
      drawCircleByBoundingBox: _editModes.DrawCircleByDiameterMode,
      drawEllipseByBoundingBox: _editModes.DrawEllipseByBoundingBoxMode,
      drawRectangleUsing3Points: _editModes.DrawRectangleUsingThreePointsMode,
      drawEllipseUsing3Points: _editModes.DrawEllipseUsingThreePointsMode,
      draw90DegreePolygon: _editModes.Draw90DegreePolygonMode,
      drawPolygonByDragging: _editModes.DrawPolygonByDraggingMode
    };
    var EditableGeoJsonLayer = function(_EditableLayer) {
      _inherits(EditableGeoJsonLayer2, _EditableLayer);
      var _super = _createSuper(EditableGeoJsonLayer2);
      function EditableGeoJsonLayer2() {
        _classCallCheck(this, EditableGeoJsonLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditableGeoJsonLayer2, [{
        key: "renderLayers",
        // setState: ($Shape<State>) => void;
        value: function renderLayers() {
          var subLayerProps = this.getSubLayerProps({
            id: "geojson",
            // Proxy most GeoJsonLayer props as-is
            data: this.props.data,
            fp64: this.props.fp64,
            filled: this.props.filled,
            stroked: this.props.stroked,
            lineWidthScale: this.props.lineWidthScale,
            lineWidthMinPixels: this.props.lineWidthMinPixels,
            lineWidthMaxPixels: this.props.lineWidthMaxPixels,
            lineWidthUnits: this.props.lineWidthUnits,
            lineJointRounded: this.props.lineJointRounded,
            lineCapRounded: this.props.lineCapRounded,
            lineMiterLimit: this.props.lineMiterLimit,
            pointRadiusScale: this.props.pointRadiusScale,
            pointRadiusMinPixels: this.props.pointRadiusMinPixels,
            pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,
            getLineColor: this.selectionAwareAccessor(this.props.getLineColor),
            getFillColor: this.selectionAwareAccessor(this.props.getFillColor),
            getPointRadius: this.selectionAwareAccessor(this.props.getRadius),
            getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),
            _subLayerProps: {
              linestrings: {
                billboard: this.props.billboard,
                updateTriggers: {
                  // required to update dashed array attribute
                  all: [this.props.selectedFeatureIndexes, this.props.mode]
                }
              },
              "polygons-stroke": {
                billboard: this.props.billboard,
                pickingLineWidthExtraPixels: this.props.pickingLineWidthExtraPixels,
                type: _editablePathLayer["default"],
                updateTriggers: {
                  // required to update dashed array attribute
                  all: [this.props.selectedFeatureIndexes, this.props.mode]
                }
              }
            },
            updateTriggers: {
              getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],
              getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],
              getPointRadius: [this.props.selectedFeatureIndexes, this.props.mode],
              getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode]
            }
          });
          var layers = [new _layers.GeoJsonLayer(subLayerProps)];
          layers = layers.concat(this.createGuidesLayers(), this.createTooltipsLayers());
          return layers;
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          _get(_getPrototypeOf(EditableGeoJsonLayer2.prototype), "initializeState", this).call(this);
          this.setState({
            selectedFeatures: [],
            editHandles: []
          });
        }
        // TODO: is this the best way to properly update state from an outside event handler?
      }, {
        key: "shouldUpdateState",
        value: function shouldUpdateState(opts) {
          return _get(_getPrototypeOf(EditableGeoJsonLayer2.prototype), "shouldUpdateState", this).call(this, opts) || opts.changeFlags.stateChanged;
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags, context = _ref.context;
          _get(_getPrototypeOf(EditableGeoJsonLayer2.prototype), "updateState", this).call(this, {
            oldProps,
            props,
            changeFlags,
            context
          });
          if (changeFlags.propsOrDataChanged) {
            var modePropChanged = Object.keys(oldProps).length === 0 || props.mode !== oldProps.mode;
            if (modePropChanged) {
              var _mode;
              if (typeof props.mode === "function") {
                var ModeConstructor = props.mode;
                _mode = new ModeConstructor();
              } else if (typeof props.mode === "string") {
                _mode = modeNameMapping[props.mode];
                console.warn("Deprecated use of passing `mode` as a string. Pass the mode's class constructor instead.");
              } else {
                _mode = props.mode;
              }
              if (!_mode) {
                console.warn("No mode configured for ".concat(String(props.mode)));
                _mode = new DEFAULT_EDIT_MODE();
              }
              if (_mode !== this.state.mode) {
                this.setState({
                  mode: _mode,
                  cursor: null
                });
              }
            }
          }
          var selectedFeatures = [];
          if (Array.isArray(props.selectedFeatureIndexes)) {
            selectedFeatures = props.selectedFeatureIndexes.map(function(elem) {
              return props.data.features[elem];
            });
          }
          this.setState({
            selectedFeatures
          });
        }
      }, {
        key: "getModeProps",
        value: function getModeProps(props) {
          var _this = this;
          return {
            modeConfig: props.modeConfig,
            data: props.data,
            selectedIndexes: props.selectedFeatureIndexes,
            lastPointerMoveEvent: this.state.lastPointerMoveEvent,
            cursor: this.state.cursor,
            onEdit: function onEdit(editAction) {
              _this.setNeedsUpdate();
              props.onEdit(editAction);
            },
            onUpdateCursor: function onUpdateCursor(cursor) {
              _this.setState({
                cursor
              });
            }
          };
        }
      }, {
        key: "selectionAwareAccessor",
        value: function selectionAwareAccessor(accessor) {
          var _this2 = this;
          if (typeof accessor !== "function") {
            return accessor;
          }
          return function(feature) {
            return accessor(feature, _this2.isFeatureSelected(feature), _this2.props.mode);
          };
        }
      }, {
        key: "isFeatureSelected",
        value: function isFeatureSelected(feature) {
          if (!this.props.data || !this.props.selectedFeatureIndexes) {
            return false;
          }
          if (!this.props.selectedFeatureIndexes.length) {
            return false;
          }
          var featureIndex = this.props.data.features.indexOf(feature);
          return this.props.selectedFeatureIndexes.includes(featureIndex);
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(_ref2) {
          var info = _ref2.info, sourceLayer = _ref2.sourceLayer;
          if (sourceLayer.id.endsWith("guides")) {
            info.isGuide = true;
          }
          return info;
        }
      }, {
        key: "_updateAutoHighlight",
        value: function _updateAutoHighlight(info) {
          if (info === null || info === void 0 ? void 0 : info.sourceLayer) {
            if (info.isGuide) {
              var _iterator = _createForOfIteratorHelper(info.sourceLayer.getSubLayers()), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var layer = _step.value;
                  layer.updateAutoHighlight(info);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            } else {
              info.sourceLayer.updateAutoHighlight(info);
            }
          }
        }
      }, {
        key: "createGuidesLayers",
        value: function createGuidesLayers() {
          var mode = this.getActiveMode();
          var guides = mode.getGuides(this.getModeProps(this.props));
          if (!guides || !guides.features.length) {
            return [];
          }
          var subLayerProps = {
            linestrings: {
              billboard: this.props.billboard,
              autoHighlight: false
            },
            "polygons-fill": {
              autoHighlight: false
            },
            "polygons-stroke": {
              billboard: this.props.billboard
            }
          };
          if (this.props.editHandleType === "icon") {
            subLayerProps["points-icon"] = {
              type: _layers.IconLayer,
              iconAtlas: this.props.editHandleIconAtlas,
              iconMapping: this.props.editHandleIconMapping,
              sizeUnits: this.props.editHandleIconSizeUnits,
              sizeScale: this.props.editHandleIconSizeScale,
              getIcon: guideAccessor(this.props.getEditHandleIcon),
              getSize: guideAccessor(this.props.getEditHandleIconSize),
              getColor: guideAccessor(this.props.getEditHandleIconColor),
              getAngle: guideAccessor(this.props.getEditHandleIconAngle)
            };
          } else {
            subLayerProps["points-circle"] = {
              type: _layers.ScatterplotLayer,
              radiusScale: this.props.editHandlePointRadiusScale,
              stroked: this.props.editHandlePointOutline,
              getLineWidth: this.props.editHandlePointStrokeWidth,
              radiusUnits: this.props.editHandlePointRadiusUnits,
              radiusMinPixels: this.props.editHandlePointRadiusMinPixels,
              radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,
              getRadius: guideAccessor(this.props.getEditHandlePointRadius),
              getFillColor: guideAccessor(this.props.getEditHandlePointColor),
              getLineColor: guideAccessor(this.props.getEditHandlePointOutlineColor)
            };
          }
          var layer = new _layers.GeoJsonLayer(this.getSubLayerProps({
            id: "guides",
            data: guides,
            fp64: this.props.fp64,
            _subLayerProps: subLayerProps,
            lineWidthScale: this.props.lineWidthScale,
            lineWidthMinPixels: this.props.lineWidthMinPixels,
            lineWidthMaxPixels: this.props.lineWidthMaxPixels,
            lineWidthUnits: this.props.lineWidthUnits,
            lineJointRounded: this.props.lineJointRounded,
            lineCapRounded: this.props.lineCapRounded,
            lineMiterLimit: this.props.lineMiterLimit,
            getLineColor: guideAccessor(this.props.getTentativeLineColor),
            getLineWidth: guideAccessor(this.props.getTentativeLineWidth),
            getFillColor: guideAccessor(this.props.getTentativeFillColor),
            pointType: this.props.editHandleType === "icon" ? "icon" : "circle",
            iconAtlas: this.props.editHandleIconAtlas
          }));
          return [layer];
        }
      }, {
        key: "createTooltipsLayers",
        value: function createTooltipsLayers() {
          var mode = this.getActiveMode();
          var tooltips = mode.getTooltips(this.getModeProps(this.props));
          var layer = new _layers.TextLayer(_objectSpread({
            getSize: DEFAULT_TOOLTIP_FONT_SIZE
          }, this.getSubLayerProps({
            id: "tooltips",
            data: tooltips
          })));
          return [layer];
        }
      }, {
        key: "onLayerClick",
        value: function onLayerClick(event) {
          this.getActiveMode().handleClick(event, this.getModeProps(this.props));
        }
      }, {
        key: "onLayerKeyUp",
        value: function onLayerKeyUp(event) {
          this.getActiveMode().handleKeyUp(event, this.getModeProps(this.props));
        }
      }, {
        key: "onStartDragging",
        value: function onStartDragging(event) {
          this.getActiveMode().handleStartDragging(event, this.getModeProps(this.props));
        }
      }, {
        key: "onDragging",
        value: function onDragging(event) {
          this.getActiveMode().handleDragging(event, this.getModeProps(this.props));
        }
      }, {
        key: "onStopDragging",
        value: function onStopDragging(event) {
          this.getActiveMode().handleStopDragging(event, this.getModeProps(this.props));
        }
      }, {
        key: "onPointerMove",
        value: function onPointerMove(event) {
          this.setState({
            lastPointerMoveEvent: event
          });
          this.getActiveMode().handlePointerMove(event, this.getModeProps(this.props));
        }
      }, {
        key: "getCursor",
        value: function getCursor(_ref3) {
          var isDragging = _ref3.isDragging;
          if (this.state === null || this.state === void 0) {
            return null;
          }
          var cursor = this.state.cursor;
          if (!cursor) {
            cursor = isDragging ? "grabbing" : "grab";
          }
          return cursor;
        }
      }, {
        key: "getActiveMode",
        value: function getActiveMode() {
          return this.state.mode;
        }
      }]);
      return EditableGeoJsonLayer2;
    }(_editableLayer["default"]);
    exports["default"] = EditableGeoJsonLayer;
    _defineProperty2(EditableGeoJsonLayer, "layerName", "EditableGeoJsonLayer");
    _defineProperty2(EditableGeoJsonLayer, "defaultProps", defaultProps40);
  }
});

// node_modules/@loaders.gl/xml/dist/esm/sax-ts/sax.js
var DEFAULT_SAX_EVENTS, DEFAULT_SAX_PARSER_OPTIONS, EVENTS, BUFFERS, nameStart, nameBody, entityStart, entityBody, ENTITIES, SAX, SAXParser;
var init_sax = __esm({
  "node_modules/@loaders.gl/xml/dist/esm/sax-ts/sax.js"() {
    init_defineProperty();
    DEFAULT_SAX_EVENTS = {
      ontext: () => {
      },
      onprocessinginstruction: () => {
      },
      onsgmldeclaration: () => {
      },
      ondoctype: () => {
      },
      oncomment: () => {
      },
      onopentagstart: () => {
      },
      onattribute: () => {
      },
      onopentag: () => {
      },
      onclosetag: () => {
      },
      onopencdata: () => {
      },
      oncdata: () => {
      },
      onclosecdata: () => {
      },
      onerror: () => {
      },
      onend: () => {
      },
      onready: () => {
      },
      onscript: () => {
      },
      onopennamespace: () => {
      },
      onclosenamespace: () => {
      }
    };
    DEFAULT_SAX_PARSER_OPTIONS = {
      ...DEFAULT_SAX_EVENTS,
      strict: false,
      MAX_BUFFER_LENGTH: 64 * 1024,
      lowercase: false,
      lowercasetags: false,
      noscript: false,
      strictEntities: false,
      xmlns: void 0,
      position: void 0,
      trim: void 0,
      normalize: void 0
    };
    EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"];
    BUFFERS = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];
    nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(ENTITIES).forEach((key) => {
      const e2 = ENTITIES[key];
      ENTITIES[key] = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
    });
    SAX = class {
      constructor() {
        _defineProperty(this, "EVENTS", EVENTS);
        _defineProperty(this, "ENTITIES", {
          ...ENTITIES
        });
        _defineProperty(this, "events", void 0);
        _defineProperty(this, "XML_ENTITIES", {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'"
        });
        _defineProperty(this, "S", 0);
        _defineProperty(this, "opt", void 0);
        _defineProperty(this, "trackPosition", false);
        _defineProperty(this, "column", 0);
        _defineProperty(this, "line", 0);
        _defineProperty(this, "c", "");
        _defineProperty(this, "error", void 0);
        _defineProperty(this, "q", "");
        _defineProperty(this, "bufferCheckPosition", void 0);
        _defineProperty(this, "closed", false);
        _defineProperty(this, "tags", []);
        _defineProperty(this, "looseCase", "");
        _defineProperty(this, "closedRoot", false);
        _defineProperty(this, "sawRoot", false);
        _defineProperty(this, "strict", false);
        _defineProperty(this, "tag", void 0);
        _defineProperty(this, "strictEntities", void 0);
        _defineProperty(this, "state", void 0);
        _defineProperty(this, "noscript", false);
        _defineProperty(this, "attribList", []);
        _defineProperty(this, "ns", void 0);
        _defineProperty(this, "position", 0);
        _defineProperty(this, "STATE", {
          BEGIN: this.S++,
          BEGIN_WHITESPACE: this.S++,
          TEXT: this.S++,
          TEXT_ENTITY: this.S++,
          OPEN_WAKA: this.S++,
          SGML_DECL: this.S++,
          SGML_DECL_QUOTED: this.S++,
          DOCTYPE: this.S++,
          DOCTYPE_QUOTED: this.S++,
          DOCTYPE_DTD: this.S++,
          DOCTYPE_DTD_QUOTED: this.S++,
          COMMENT_STARTING: this.S++,
          COMMENT: this.S++,
          COMMENT_ENDING: this.S++,
          COMMENT_ENDED: this.S++,
          CDATA: this.S++,
          CDATA_ENDING: this.S++,
          CDATA_ENDING_2: this.S++,
          PROC_INST: this.S++,
          PROC_INST_BODY: this.S++,
          PROC_INST_ENDING: this.S++,
          OPEN_TAG: this.S++,
          OPEN_TAG_SLASH: this.S++,
          ATTRIB: this.S++,
          ATTRIB_NAME: this.S++,
          ATTRIB_NAME_SAW_WHITE: this.S++,
          ATTRIB_VALUE: this.S++,
          ATTRIB_VALUE_QUOTED: this.S++,
          ATTRIB_VALUE_CLOSED: this.S++,
          ATTRIB_VALUE_UNQUOTED: this.S++,
          ATTRIB_VALUE_ENTITY_Q: this.S++,
          ATTRIB_VALUE_ENTITY_U: this.S++,
          CLOSE_TAG: this.S++,
          CLOSE_TAG_SAW_WHITE: this.S++,
          SCRIPT: this.S++,
          SCRIPT_ENDING: this.S++
        });
        _defineProperty(this, "BUFFERS", BUFFERS);
        _defineProperty(this, "CDATA", "[CDATA[");
        _defineProperty(this, "DOCTYPE", "DOCTYPE");
        _defineProperty(this, "XML_NAMESPACE", "http://www.w3.org/XML/1998/namespace");
        _defineProperty(this, "XMLNS_NAMESPACE", "http://www.w3.org/2000/xmlns/");
        _defineProperty(this, "rootNS", {
          xml: this.XML_NAMESPACE,
          xmlns: this.XMLNS_NAMESPACE
        });
        _defineProperty(this, "comment", void 0);
        _defineProperty(this, "sgmlDecl", void 0);
        _defineProperty(this, "textNode", "");
        _defineProperty(this, "tagName", void 0);
        _defineProperty(this, "doctype", void 0);
        _defineProperty(this, "procInstName", void 0);
        _defineProperty(this, "procInstBody", void 0);
        _defineProperty(this, "entity", "");
        _defineProperty(this, "attribName", void 0);
        _defineProperty(this, "attribValue", void 0);
        _defineProperty(this, "cdata", "");
        _defineProperty(this, "script", "");
        _defineProperty(this, "startTagPosition", 0);
        this.S = 0;
        for (const s2 in this.STATE) {
          if (this.STATE.hasOwnProperty(s2)) {
            this.STATE[this.STATE[s2]] = s2;
          }
        }
        this.S = this.STATE;
      }
      static charAt(chunk, i3) {
        let result = "";
        if (i3 < chunk.length) {
          result = chunk.charAt(i3);
        }
        return result;
      }
      static isWhitespace(c2) {
        return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
      }
      static isQuote(c2) {
        return c2 === '"' || c2 === "'";
      }
      static isAttribEnd(c2) {
        return c2 === ">" || SAX.isWhitespace(c2);
      }
      static isMatch(regex, c2) {
        return regex.test(c2);
      }
      static notMatch(regex, c2) {
        return !SAX.isMatch(regex, c2);
      }
      static qname(name10, attribute) {
        const i3 = name10.indexOf(":");
        const qualName = i3 < 0 ? ["", name10] : name10.split(":");
        let prefix = qualName[0];
        let local = qualName[1];
        if (attribute && name10 === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return {
          prefix,
          local
        };
      }
      write(chunk) {
        if (this.error) {
          throw this.error;
        }
        if (this.closed) {
          return this.errorFunction("Cannot write after close. Assign an onready handler.");
        }
        if (chunk === null) {
          return this.end();
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        let i3 = 0;
        let c2;
        while (true) {
          c2 = SAX.charAt(chunk, i3++);
          this.c = c2;
          if (!c2) {
            break;
          }
          if (this.trackPosition) {
            this.position++;
            if (c2 === "\n") {
              this.line++;
              this.column = 0;
            } else {
              this.column++;
            }
          }
          switch (this.state) {
            case this.S.BEGIN:
              this.state = this.S.BEGIN_WHITESPACE;
              if (c2 === "\uFEFF") {
                continue;
              }
              this.beginWhiteSpace(c2);
              continue;
            case this.S.BEGIN_WHITESPACE:
              this.beginWhiteSpace(c2);
              continue;
            case this.S.TEXT:
              if (this.sawRoot && !this.closedRoot) {
                const starti = i3 - 1;
                while (c2 && c2 !== "<" && c2 !== "&") {
                  c2 = SAX.charAt(chunk, i3++);
                  if (c2 && this.trackPosition) {
                    this.position++;
                    if (c2 === "\n") {
                      this.line++;
                      this.column = 0;
                    } else {
                      this.column++;
                    }
                  }
                }
                this.textNode += chunk.substring(starti, i3 - 1);
              }
              if (c2 === "<" && !(this.sawRoot && this.closedRoot && !this.strict)) {
                this.state = this.S.OPEN_WAKA;
                this.startTagPosition = this.position;
              } else {
                if (!SAX.isWhitespace(c2) && (!this.sawRoot || this.closedRoot)) {
                  this.strictFail("Text data outside of root node.");
                }
                if (c2 === "&") {
                  this.state = this.S.TEXT_ENTITY;
                } else {
                  this.textNode += c2;
                }
              }
              continue;
            case this.S.SCRIPT:
              if (c2 === "<") {
                this.state = this.S.SCRIPT_ENDING;
              } else {
                this.script += c2;
              }
              continue;
            case this.S.SCRIPT_ENDING:
              if (c2 === "/") {
                this.state = this.S.CLOSE_TAG;
              } else {
                this.script += "<".concat(c2);
                this.state = this.S.SCRIPT;
              }
              continue;
            case this.S.OPEN_WAKA:
              if (c2 === "!") {
                this.state = this.S.SGML_DECL;
                this.sgmlDecl = "";
              } else if (SAX.isWhitespace(c2)) {
              } else if (SAX.isMatch(nameStart, c2)) {
                this.state = this.S.OPEN_TAG;
                this.tagName = c2;
              } else if (c2 === "/") {
                this.state = this.S.CLOSE_TAG;
                this.tagName = "";
              } else if (c2 === "?") {
                this.state = this.S.PROC_INST;
                this.procInstName = this.procInstBody = "";
              } else {
                this.strictFail("Unencoded <");
                if (this.startTagPosition + 1 < this.position) {
                  const pad = this.position - this.startTagPosition;
                  c2 = new Array(pad).join(" ") + c2;
                }
                this.textNode += "<".concat(c2);
                this.state = this.S.TEXT;
              }
              continue;
            case this.S.SGML_DECL:
              if ((this.sgmlDecl + c2).toUpperCase() === this.CDATA) {
                this.emitNode("onopencdata");
                this.state = this.S.CDATA;
                this.sgmlDecl = "";
                this.cdata = "";
              } else if (this.sgmlDecl + c2 === "--") {
                this.state = this.S.COMMENT;
                this.comment = "";
                this.sgmlDecl = "";
              } else if ((this.sgmlDecl + c2).toUpperCase() === this.DOCTYPE) {
                this.state = this.S.DOCTYPE;
                if (this.doctype || this.sawRoot) {
                  this.strictFail("Inappropriately located doctype declaration");
                }
                this.doctype = "";
                this.sgmlDecl = "";
              } else if (c2 === ">") {
                this.emitNode("onsgmldeclaration", this.sgmlDecl);
                this.sgmlDecl = "";
                this.state = this.S.TEXT;
              } else if (SAX.isQuote(c2)) {
                this.state = this.S.SGML_DECL_QUOTED;
                this.sgmlDecl += c2;
              } else {
                this.sgmlDecl += c2;
              }
              continue;
            case this.S.SGML_DECL_QUOTED:
              if (c2 === this.q) {
                this.state = this.S.SGML_DECL;
                this.q = "";
              }
              this.sgmlDecl += c2;
              continue;
            case this.S.DOCTYPE:
              if (c2 === ">") {
                this.state = this.S.TEXT;
                this.emitNode("ondoctype", this.doctype);
                this.doctype = true;
              } else {
                this.doctype += c2;
                if (c2 === "[") {
                  this.state = this.S.DOCTYPE_DTD;
                } else if (SAX.isQuote(c2)) {
                  this.state = this.S.DOCTYPE_QUOTED;
                  this.q = c2;
                }
              }
              continue;
            case this.S.DOCTYPE_QUOTED:
              this.doctype += c2;
              if (c2 === this.q) {
                this.q = "";
                this.state = this.S.DOCTYPE;
              }
              continue;
            case this.S.DOCTYPE_DTD:
              this.doctype += c2;
              if (c2 === "]") {
                this.state = this.S.DOCTYPE;
              } else if (SAX.isQuote(c2)) {
                this.state = this.S.DOCTYPE_DTD_QUOTED;
                this.q = c2;
              }
              continue;
            case this.S.DOCTYPE_DTD_QUOTED:
              this.doctype += c2;
              if (c2 === this.q) {
                this.state = this.S.DOCTYPE_DTD;
                this.q = "";
              }
              continue;
            case this.S.COMMENT:
              if (c2 === "-") {
                this.state = this.S.COMMENT_ENDING;
              } else {
                this.comment += c2;
              }
              continue;
            case this.S.COMMENT_ENDING:
              if (c2 === "-") {
                this.state = this.S.COMMENT_ENDED;
                this.comment = this.textApplyOptions(this.comment);
                if (this.comment) {
                  this.emitNode("oncomment", this.comment);
                }
                this.comment = "";
              } else {
                this.comment += "-".concat(c2);
                this.state = this.S.COMMENT;
              }
              continue;
            case this.S.COMMENT_ENDED:
              if (c2 !== ">") {
                this.strictFail("Malformed comment");
                this.comment += "--".concat(c2);
                this.state = this.S.COMMENT;
              } else {
                this.state = this.S.TEXT;
              }
              continue;
            case this.S.CDATA:
              if (c2 === "]") {
                this.state = this.S.CDATA_ENDING;
              } else {
                this.cdata += c2;
              }
              continue;
            case this.S.CDATA_ENDING:
              if (c2 === "]") {
                this.state = this.S.CDATA_ENDING_2;
              } else {
                this.cdata += "]".concat(c2);
                this.state = this.S.CDATA;
              }
              continue;
            case this.S.CDATA_ENDING_2:
              if (c2 === ">") {
                if (this.cdata) {
                  this.emitNode("oncdata", this.cdata);
                }
                this.emitNode("onclosecdata");
                this.cdata = "";
                this.state = this.S.TEXT;
              } else if (c2 === "]") {
                this.cdata += "]";
              } else {
                this.cdata += "]]".concat(c2);
                this.state = this.S.CDATA;
              }
              continue;
            case this.S.PROC_INST:
              if (c2 === "?") {
                this.state = this.S.PROC_INST_ENDING;
              } else if (SAX.isWhitespace(c2)) {
                this.state = this.S.PROC_INST_BODY;
              } else {
                this.procInstName += c2;
              }
              continue;
            case this.S.PROC_INST_BODY:
              if (!this.procInstBody && SAX.isWhitespace(c2)) {
                continue;
              } else if (c2 === "?") {
                this.state = this.S.PROC_INST_ENDING;
              } else {
                this.procInstBody += c2;
              }
              continue;
            case this.S.PROC_INST_ENDING:
              if (c2 === ">") {
                this.emitNode("onprocessinginstruction", {
                  name: this.procInstName,
                  body: this.procInstBody
                });
                this.procInstName = this.procInstBody = "";
                this.state = this.S.TEXT;
              } else {
                this.procInstBody += "?".concat(c2);
                this.state = this.S.PROC_INST_BODY;
              }
              continue;
            case this.S.OPEN_TAG:
              if (SAX.isMatch(nameBody, c2)) {
                this.tagName += c2;
              } else {
                this.newTag();
                if (c2 === ">") {
                  this.openTag();
                } else if (c2 === "/") {
                  this.state = this.S.OPEN_TAG_SLASH;
                } else {
                  if (!SAX.isWhitespace(c2)) {
                    this.strictFail("Invalid character in tag name");
                  }
                  this.state = this.S.ATTRIB;
                }
              }
              continue;
            case this.S.OPEN_TAG_SLASH:
              if (c2 === ">") {
                this.openTag(true);
                this.closeTag();
              } else {
                this.strictFail("Forward-slash in opening tag not followed by >");
                this.state = this.S.ATTRIB;
              }
              continue;
            case this.S.ATTRIB:
              if (SAX.isWhitespace(c2)) {
                continue;
              } else if (c2 === ">") {
                this.openTag();
              } else if (c2 === "/") {
                this.state = this.S.OPEN_TAG_SLASH;
              } else if (SAX.isMatch(nameStart, c2)) {
                this.attribName = c2;
                this.attribValue = "";
                this.state = this.S.ATTRIB_NAME;
              } else {
                this.strictFail("Invalid attribute name");
              }
              continue;
            case this.S.ATTRIB_NAME:
              if (c2 === "=") {
                this.state = this.S.ATTRIB_VALUE;
              } else if (c2 === ">") {
                this.strictFail("Attribute without value");
                this.attribValue = this.attribName;
                this.attrib();
                this.openTag();
              } else if (SAX.isWhitespace(c2)) {
                this.state = this.S.ATTRIB_NAME_SAW_WHITE;
              } else if (SAX.isMatch(nameBody, c2)) {
                this.attribName += c2;
              } else {
                this.strictFail("Invalid attribute name");
              }
              continue;
            case this.S.ATTRIB_NAME_SAW_WHITE:
              if (c2 === "=") {
                this.state = this.S.ATTRIB_VALUE;
              } else if (SAX.isWhitespace(c2)) {
                continue;
              } else {
                this.strictFail("Attribute without value");
                this.tag.attributes[this.attribName] = "";
                this.attribValue = "";
                this.emitNode("onattribute", {
                  name: this.attribName,
                  value: ""
                });
                this.attribName = "";
                if (c2 === ">") {
                  this.openTag();
                } else if (SAX.isMatch(nameStart, c2)) {
                  this.attribName = c2;
                  this.state = this.S.ATTRIB_NAME;
                } else {
                  this.strictFail("Invalid attribute name");
                  this.state = this.S.ATTRIB;
                }
              }
              continue;
            case this.S.ATTRIB_VALUE:
              if (SAX.isWhitespace(c2)) {
                continue;
              } else if (SAX.isQuote(c2)) {
                this.q = c2;
                this.state = this.S.ATTRIB_VALUE_QUOTED;
              } else {
                this.strictFail("Unquoted attribute value");
                this.state = this.S.ATTRIB_VALUE_UNQUOTED;
                this.attribValue = c2;
              }
              continue;
            case this.S.ATTRIB_VALUE_QUOTED:
              if (c2 !== this.q) {
                if (c2 === "&") {
                  this.state = this.S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  this.attribValue += c2;
                }
                continue;
              }
              this.attrib();
              this.q = "";
              this.state = this.S.ATTRIB_VALUE_CLOSED;
              continue;
            case this.S.ATTRIB_VALUE_CLOSED:
              if (SAX.isWhitespace(c2)) {
                this.state = this.S.ATTRIB;
              } else if (c2 === ">") {
                this.openTag();
              } else if (c2 === "/") {
                this.state = this.S.OPEN_TAG_SLASH;
              } else if (SAX.isMatch(nameStart, c2)) {
                this.strictFail("No whitespace between attributes");
                this.attribName = c2;
                this.attribValue = "";
                this.state = this.S.ATTRIB_NAME;
              } else {
                this.strictFail("Invalid attribute name");
              }
              continue;
            case this.S.ATTRIB_VALUE_UNQUOTED:
              if (!SAX.isAttribEnd(c2)) {
                if (c2 === "&") {
                  this.state = this.S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  this.attribValue += c2;
                }
                continue;
              }
              this.attrib();
              if (c2 === ">") {
                this.openTag();
              } else {
                this.state = this.S.ATTRIB;
              }
              continue;
            case this.S.CLOSE_TAG:
              if (!this.tagName) {
                if (SAX.isWhitespace(c2)) {
                  continue;
                } else if (SAX.notMatch(nameStart, c2)) {
                  if (this.script) {
                    this.script += "</".concat(c2);
                    this.state = this.S.SCRIPT;
                  } else {
                    this.strictFail("Invalid tagname in closing tag.");
                  }
                } else {
                  this.tagName = c2;
                }
              } else if (c2 === ">") {
                this.closeTag();
              } else if (SAX.isMatch(nameBody, c2)) {
                this.tagName += c2;
              } else if (this.script) {
                this.script += "</".concat(this.tagName);
                this.tagName = "";
                this.state = this.S.SCRIPT;
              } else {
                if (!SAX.isWhitespace(c2)) {
                  this.strictFail("Invalid tagname in closing tag");
                }
                this.state = this.S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case this.S.CLOSE_TAG_SAW_WHITE:
              if (SAX.isWhitespace(c2)) {
                continue;
              }
              if (c2 === ">") {
                this.closeTag();
              } else {
                this.strictFail("Invalid characters in closing tag");
              }
              continue;
            case this.S.TEXT_ENTITY:
            case this.S.ATTRIB_VALUE_ENTITY_Q:
            case this.S.ATTRIB_VALUE_ENTITY_U:
              let returnState;
              let buffer;
              switch (this.state) {
                case this.S.TEXT_ENTITY:
                  returnState = this.S.TEXT;
                  buffer = "textNode";
                  break;
                case this.S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = this.S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case this.S.ATTRIB_VALUE_ENTITY_U:
                  returnState = this.S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
                default:
                  throw new Error("Unknown state: ".concat(this.state));
              }
              if (c2 === ";") {
                this[buffer] += this.parseEntity();
                this.entity = "";
                this.state = returnState;
              } else if (SAX.isMatch(this.entity.length ? entityBody : entityStart, c2)) {
                this.entity += c2;
              } else {
                this.strictFail("Invalid character in entity name");
                this[buffer] += "&".concat(this.entity).concat(c2);
                this.entity = "";
                this.state = returnState;
              }
              continue;
            default:
              throw new Error("Unknown state: ".concat(this.state));
          }
        }
        if (this.position >= this.bufferCheckPosition) {
          this.checkBufferLength();
        }
        return this;
      }
      emit(event, data) {
        if (this.events.hasOwnProperty(event)) {
          const eventName = event.replace(/^on/, "");
          this.events[event](data, eventName, this);
        }
      }
      clearBuffers() {
        for (let i3 = 0, l2 = this.BUFFERS.length; i3 < l2; i3++) {
          this[this[i3]] = "";
        }
      }
      flushBuffers() {
        this.closeText();
        if (this.cdata !== "") {
          this.emitNode("oncdata", this.cdata);
          this.cdata = "";
        }
        if (this.script !== "") {
          this.emitNode("onscript", this.script);
          this.script = "";
        }
      }
      end() {
        if (this.sawRoot && !this.closedRoot)
          this.strictFail("Unclosed root tag");
        if (this.state !== this.S.BEGIN && this.state !== this.S.BEGIN_WHITESPACE && this.state !== this.S.TEXT) {
          this.errorFunction("Unexpected end");
        }
        this.closeText();
        this.c = "";
        this.closed = true;
        this.emit("onend");
        return new SAXParser(this.opt);
      }
      errorFunction(er) {
        this.closeText();
        if (this.trackPosition) {
          er += "\nLine: ".concat(this.line, "\nColumn: ").concat(this.column, "\nChar: ").concat(this.c);
        }
        const error = new Error(er);
        this.error = error;
        this.emit("onerror", error);
        return this;
      }
      attrib() {
        if (!this.strict) {
          this.attribName = this.attribName[this.looseCase]();
        }
        if (this.attribList.indexOf(this.attribName) !== -1 || this.tag.attributes.hasOwnProperty(this.attribName)) {
          this.attribName = this.attribValue = "";
          return;
        }
        if (this.opt.xmlns) {
          const qn = SAX.qname(this.attribName, true);
          const prefix = qn.prefix;
          const local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && this.attribValue !== this.XML_NAMESPACE) {
              this.strictFail("xml: prefix must be bound to ".concat(this.XML_NAMESPACE, "\n") + "Actual: ".concat(this.attribValue));
            } else if (local === "xmlns" && this.attribValue !== this.XMLNS_NAMESPACE) {
              this.strictFail("xmlns: prefix must be bound to ".concat(this.XMLNS_NAMESPACE, "\n") + "Actual: ".concat(this.attribValue));
            } else {
              const tag = this.tag;
              const parent = this.tags[this.tags.length - 1] || this;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = this.attribValue;
            }
          }
          this.attribList.push([this.attribName, this.attribValue]);
        } else {
          this.tag.attributes[this.attribName] = this.attribValue;
          this.emitNode("onattribute", {
            name: this.attribName,
            value: this.attribValue
          });
        }
        this.attribName = this.attribValue = "";
      }
      newTag() {
        if (!this.strict)
          this.tagName = this.tagName[this.looseCase]();
        const parent = this.tags[this.tags.length - 1] || this;
        const tag = this.tag = {
          name: this.tagName,
          attributes: {}
        };
        if (this.opt.xmlns) {
          tag.ns = parent.ns;
        }
        this.attribList.length = 0;
        this.emitNode("onopentagstart", tag);
      }
      parseEntity() {
        let entity = this.entity;
        const entityLC = entity.toLowerCase();
        let num = NaN;
        let numStr = "";
        if (this.ENTITIES[entity]) {
          return this.ENTITIES[entity];
        }
        if (this.ENTITIES[entityLC]) {
          return this.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          this.strictFail("Invalid character entity");
          return "&".concat(this.entity, ";");
        }
        return String.fromCodePoint(num);
      }
      beginWhiteSpace(c2) {
        if (c2 === "<") {
          this.state = this.S.OPEN_WAKA;
          this.startTagPosition = this.position;
        } else if (!SAX.isWhitespace(c2)) {
          this.strictFail("Non-whitespace before first tag.");
          this.textNode = c2;
          this.state = this.S.TEXT;
        } else {
        }
      }
      strictFail(message) {
        if (typeof this !== "object" || !(this instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (this.strict) {
          this.errorFunction(message);
        }
      }
      textApplyOptions(text) {
        if (this.opt.trim)
          text = text.trim();
        if (this.opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      emitNode(nodeType, data) {
        if (this.textNode)
          this.closeText();
        this.emit(nodeType, data);
      }
      closeText() {
        this.textNode = this.textApplyOptions(this.textNode);
        if (this.textNode !== void 0 && this.textNode !== "" && this.textNode !== "undefined") {
          this.emit("ontext", this.textNode);
        }
        this.textNode = "";
      }
      checkBufferLength() {
        const maxAllowed = Math.max(this.opt.MAX_BUFFER_LENGTH, 10);
        let maxActual = 0;
        for (let i3 = 0, l2 = this.BUFFERS.length; i3 < l2; i3++) {
          var _this$this$BUFFERS$i;
          const len = ((_this$this$BUFFERS$i = this[this.BUFFERS[i3]]) === null || _this$this$BUFFERS$i === void 0 ? void 0 : _this$this$BUFFERS$i.length) || 0;
          if (len > maxAllowed) {
            switch (this.BUFFERS[i3]) {
              case "textNode":
                this.closeText();
                break;
              case "cdata":
                this.emitNode("oncdata", this.cdata);
                this.cdata = "";
                break;
              case "script":
                this.emitNode("onscript", this.script);
                this.script = "";
                break;
              default:
                this.errorFunction("Max buffer length exceeded: ".concat(this.BUFFERS[i3]));
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        const m = this.opt.MAX_BUFFER_LENGTH - maxActual;
        this.bufferCheckPosition = m + this.position;
      }
      openTag(selfClosing) {
        if (this.opt.xmlns) {
          const tag = this.tag;
          const qn = SAX.qname(this.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            this.strictFail("Unbound namespace prefix: ".concat(JSON.stringify(this.tagName)));
            tag.uri = qn.prefix;
          }
          const parent = this.tags[this.tags.length - 1] || this;
          if (tag.ns && parent.ns !== tag.ns) {
            const that = this;
            Object.keys(tag.ns).forEach((p2) => {
              that.emitNode("onopennamespace", {
                prefix: p2,
                uri: tag.ns[p2]
              });
            });
          }
          for (let i3 = 0, l2 = this.attribList.length; i3 < l2; i3++) {
            const nv = this.attribList[i3];
            const name10 = nv[0];
            const value = nv[1];
            const qualName = SAX.qname(name10, true);
            const prefix = qualName.prefix;
            const local = qualName.local;
            const uri = prefix === "" ? "" : tag.ns[prefix] || "";
            const a2 = {
              name: name10,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              this.strictFail("Unbound namespace prefix: ".concat(JSON.stringify(prefix)));
              a2.uri = prefix;
            }
            this.tag.attributes[name10] = a2;
            this.emitNode("onattribute", a2);
          }
          this.attribList.length = 0;
        }
        this.tag.isSelfClosing = Boolean(selfClosing);
        this.sawRoot = true;
        this.tags.push(this.tag);
        this.emitNode("onopentag", this.tag);
        if (!selfClosing) {
          if (!this.noscript && this.tagName.toLowerCase() === "script") {
            this.state = this.S.SCRIPT;
          } else {
            this.state = this.S.TEXT;
          }
          this.tag = null;
          this.tagName = "";
        }
        this.attribName = this.attribValue = "";
        this.attribList.length = 0;
      }
      closeTag() {
        if (!this.tagName) {
          this.strictFail("Weird empty close tag.");
          this.textNode += "</>";
          this.state = this.S.TEXT;
          return;
        }
        if (this.script) {
          if (this.tagName !== "script") {
            this.script += "</".concat(this.tagName, ">");
            this.tagName = "";
            this.state = this.S.SCRIPT;
            return;
          }
          this.emitNode("onscript", this.script);
          this.script = "";
        }
        let t2 = this.tags.length;
        let tagName = this.tagName;
        if (!this.strict) {
          tagName = tagName[this.looseCase]();
        }
        while (t2--) {
          const close = this.tags[t2];
          if (close.name !== tagName) {
            this.strictFail("Unexpected close tag");
          } else {
            break;
          }
        }
        if (t2 < 0) {
          this.strictFail("Unmatched closing tag: ".concat(this.tagName));
          this.textNode += "</".concat(this.tagName, ">");
          this.state = this.S.TEXT;
          return;
        }
        this.tagName = tagName;
        let s2 = this.tags.length;
        while (s2-- > t2) {
          const tag = this.tag = this.tags.pop();
          this.tagName = this.tag.name;
          this.emitNode("onclosetag", this.tagName);
          const x2 = {};
          for (const i3 in tag.ns) {
            if (tag.ns.hasOwnProperty(i3)) {
              x2[i3] = tag.ns[i3];
            }
          }
          const parent = this.tags[this.tags.length - 1] || this;
          if (this.opt.xmlns && tag.ns !== parent.ns) {
            const that = this;
            Object.keys(tag.ns).forEach((p2) => {
              const n2 = tag.ns[p2];
              that.emitNode("onclosenamespace", {
                prefix: p2,
                uri: n2
              });
            });
          }
        }
        if (t2 === 0)
          this.closedRoot = true;
        this.tagName = this.attribValue = this.attribName = "";
        this.attribList.length = 0;
        this.state = this.S.TEXT;
      }
    };
    SAXParser = class extends SAX {
      constructor(opt) {
        super();
        _defineProperty(this, "opt", DEFAULT_SAX_PARSER_OPTIONS);
        _defineProperty(this, "events", DEFAULT_SAX_EVENTS);
        this.clearBuffers();
        this.opt = opt = {
          ...this.opt,
          ...opt
        };
        this.events = {
          ...this.events,
          ...opt
        };
        this.q = this.c = "";
        this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags;
        this.bufferCheckPosition = this.opt.MAX_BUFFER_LENGTH;
        this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase";
        this.tags = [];
        this.closed = this.closedRoot = this.sawRoot = false;
        this.tag = this.error = null;
        this.strict = Boolean(this.opt.strict);
        this.noscript = Boolean(this.opt.strict || this.opt.noscript);
        this.state = this.S.BEGIN;
        this.strictEntities = this.opt.strictEntities;
        this.ENTITIES = this.strictEntities ? Object.create(this.XML_ENTITIES) : Object.create(this.ENTITIES);
        this.attribList = [];
        if (this.opt.xmlns) {
          this.ns = Object.create(this.rootNS);
        }
        this.trackPosition = this.opt.position !== false;
        if (this.trackPosition) {
          this.position = this.line = this.column = 0;
        }
        this.emit("onready");
      }
      resume() {
        this.error = null;
        return this;
      }
      close() {
        return this.write(null);
      }
      flush() {
        this.flushBuffers();
      }
    };
    _defineProperty(SAXParser, "ENTITIES", ENTITIES);
  }
});

// node_modules/@loaders.gl/xml/dist/esm/lib/parser/xml-parser.js
var init_xml_parser = __esm({
  "node_modules/@loaders.gl/xml/dist/esm/lib/parser/xml-parser.js"() {
    init_defineProperty();
    init_sax();
  }
});

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v) {
      return typeof v !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a2, arrayMode) {
      if (a2) {
        const keys = Object.keys(a2);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          if (arrayMode === "strict") {
            target[keys[i3]] = [a2[keys[i3]]];
          } else {
            target[keys[i3]] = a2[keys[i3]];
          }
        }
      }
    };
    exports.getValue = function(v) {
      if (exports.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
          i3 += 2;
          i3 = readPI(xmlData, i3);
          if (i3.err)
            return i3;
        } else if (xmlData[i3] === "<") {
          let tagStartPos = i3;
          i3++;
          if (xmlData[i3] === "!") {
            i3 = readCommentAndCDATA(xmlData, i3);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i3] === "/") {
              closingTag = true;
              i3++;
            }
            let tagName = "";
            for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
              tagName += xmlData[i3];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i3--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
            }
            const result = readAttributeStr(xmlData, i3);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
            }
            let attrStr = result.value;
            i3 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i3 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i3++; i3 < xmlData.length; i3++) {
              if (xmlData[i3] === "<") {
                if (xmlData[i3 + 1] === "!") {
                  i3++;
                  i3 = readCommentAndCDATA(xmlData, i3);
                  continue;
                } else if (xmlData[i3 + 1] === "?") {
                  i3 = readPI(xmlData, ++i3);
                  if (i3.err)
                    return i3;
                } else {
                  break;
                }
              } else if (xmlData[i3] === "&") {
                const afterAmp = validateAmpersand(xmlData, i3);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                i3 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                }
              }
            }
            if (xmlData[i3] === "<") {
              i3--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i3])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i3) {
      const start = i3;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] == "?" || xmlData[i3] == " ") {
          const tagname = xmlData.substr(start, i3 - start);
          if (i3 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
          } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
            i3++;
            break;
          } else {
            continue;
          }
        }
      }
      return i3;
    }
    function readCommentAndCDATA(xmlData, i3) {
      if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
        for (i3 += 3; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i3] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      }
      return i3;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i3) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i3];
          } else if (startChar !== xmlData[i3]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i3] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i3];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i3,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i3 = 0; i3 < matches.length; i3++) {
        if (matches[i3][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' has no space in starting.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] !== void 0 && matches[i3][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' is without value.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i3][2] + "' is not allowed.", getPositionFromMatch(matches[i3]));
        }
        const attrName = matches[i3][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i3]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i3]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i3) {
      let re = /\d/;
      if (xmlData[i3] === "x") {
        i3++;
        re = /[\da-fA-F]/;
      }
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === ";")
          return i3;
        if (!xmlData[i3].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i3) {
      i3++;
      if (xmlData[i3] === ";")
        return -1;
      if (xmlData[i3] === "#") {
        i3++;
        return validateNumberAmpersand(xmlData, i3);
      }
      let count = 0;
      for (; i3 < xmlData.length; i3++, count++) {
        if (xmlData[i3].match(/\w/) && count < 20)
          continue;
        if (xmlData[i3] === ";")
          break;
        return -1;
      }
      return i3;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    function readDocType(xmlData, i3) {
      const entities = {};
      if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
        i3 = i3 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i3)) {
              i3 += 7;
              [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
              if (val.indexOf("&") === -1)
                entities[entityName] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i3))
              i3 += 8;
            else if (hasBody && isAttlist(xmlData, i3))
              i3 += 8;
            else if (hasBody && isNotation(xmlData, i3))
              i3 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i3] === ">") {
            if (comment) {
              if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i3] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i3];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i3 };
    }
    function readEntityExp(xmlData, i3) {
      let entityName2 = "";
      for (; i3 < xmlData.length && (xmlData[i3] !== "'" && xmlData[i3] !== '"'); i3++) {
        entityName2 += xmlData[i3];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i3++];
      let val2 = "";
      for (; i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
        val2 += xmlData[i3];
      }
      return [entityName2, val2, i3];
    }
    function isComment(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N")
        return true;
      return false;
    }
    module.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign2 = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign2 && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign2 + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign2 + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module.exports = toNumber;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "" },
          "pound": { regex: /&(pound|#163);/g, val: "" },
          "yen": { regex: /&(yen|#165);/g, val: "" },
          "euro": { regex: /&(euro|#8364);/g, val: "" },
          "copyright": { regex: /&(copy|#169);/g, val: "" },
          "reg": { regex: /&(reg|#174);/g, val: "" },
          "inr": { regex: /&(inr|#8377);/g, val: "" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i3 = 0; i3 < entKeys.length; i3++) {
        const ent = entKeys[i3];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i3 = 0; i3 < len; i3++) {
          const attrName = this.resolveNameSpace(matches[i3][1]);
          let oldVal = matches[i3][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        const ch = xmlData[i3];
        if (ch === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            let tagData = readTagExp(xmlData, i3, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i3 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i3 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i3 = endIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i3);
            this.docTypeEntities = result.entities;
            i3 = result.i;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i3 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val2 == void 0)
                val2 = "";
              currentNode.add(this.options.textNodeName, val2);
            }
            i3 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i3 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i3 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i3 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i3 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i3];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i3; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i3, errMsg) {
      const closingIndex = xmlData.indexOf(str, i3);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i3) {
      const startIndex = i3;
      let openTagCount = 1;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i3),
                  i: closeIndex
                };
              }
            }
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
            i3 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i3, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i3 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          const atrrName = keys[i3];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser2 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser2;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i3 = 0; i3 < options.entities.length; i3++) {
          const entity = options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a2) {
        return a2;
      },
      attributeValueProcessor: function(attrName, a2) {
        return a2;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if (attrStr && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i3 = 0; i3 < this.options.entities.length; i3++) {
          const entity = this.options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name10) {
      if (name10.startsWith(this.options.attributeNamePrefix)) {
        return name10.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    var validator = require_validator();
    var XMLParser2 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser: XMLParser2,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// node_modules/@loaders.gl/xml/dist/esm/lib/parse-xml.js
function parseXML(text, options) {
  const parser = new import_fast_xml_parser.XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    ...options === null || options === void 0 ? void 0 : options.xml
  });
  const parsedXML = parser.parse(text);
  return parsedXML;
}
var import_fast_xml_parser;
var init_parse_xml = __esm({
  "node_modules/@loaders.gl/xml/dist/esm/lib/parse-xml.js"() {
    init_xml_parser();
    import_fast_xml_parser = __toESM(require_fxp());
  }
});

// node_modules/@loaders.gl/xml/dist/esm/xml-loader.js
function testXMLFile(text) {
  return text.startsWith("<?xml");
}
var VERSION, XMLLoader;
var init_xml_loader = __esm({
  "node_modules/@loaders.gl/xml/dist/esm/xml-loader.js"() {
    init_parse_xml();
    VERSION = true ? "3.3.3" : "latest";
    XMLLoader = {
      name: "XML",
      id: "xml",
      module: "xml",
      version: VERSION,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/xml", "text/xml"],
      testText: testXMLFile,
      options: {
        xml: {}
      },
      parse: async (arrayBuffer, options) => parseXML(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseXML(text, options)
    };
  }
});

// node_modules/@loaders.gl/xml/dist/esm/index.js
var init_esm16 = __esm({
  "node_modules/@loaders.gl/xml/dist/esm/index.js"() {
    init_xml_loader();
    init_sax();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/wms/parse-wms.js
function parseWMSCapabilities(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  return extractCapabilities(xmlCapabilities);
}
function extractCapabilities(xml) {
  var _xml$Service, _xml$Service2, _xml$Capability;
  const capabilities = {
    name: ((_xml$Service = xml.Service) === null || _xml$Service === void 0 ? void 0 : _xml$Service.Name) || "unnamed",
    title: (_xml$Service2 = xml.Service) === null || _xml$Service2 === void 0 ? void 0 : _xml$Service2.Title,
    keywords: [],
    requests: {},
    layer: extractLayer((_xml$Capability = xml.Capability) === null || _xml$Capability === void 0 ? void 0 : _xml$Capability.Layer),
    raw: xml
  };
  for (const keyword of ((_xml$Service3 = xml.Service) === null || _xml$Service3 === void 0 ? void 0 : (_xml$Service3$Keyword = _xml$Service3.KeywordList) === null || _xml$Service3$Keyword === void 0 ? void 0 : _xml$Service3$Keyword.Keyword) || []) {
    var _xml$Service3, _xml$Service3$Keyword;
    capabilities.keywords.push(keyword);
  }
  for (const [name10, xmlRequest] of Object.entries(((_xml$Capability2 = xml.Capability) === null || _xml$Capability2 === void 0 ? void 0 : _xml$Capability2.Request) || {})) {
    var _xml$Capability2;
    capabilities.requests[name10] = extractRequest(name10, xmlRequest);
  }
  return capabilities;
}
function extractRequest(name10, xmlRequest) {
  const format = xmlRequest === null || xmlRequest === void 0 ? void 0 : xmlRequest.Format;
  const mimeTypes = Array.isArray(format) ? format : [format];
  return {
    name: name10,
    mimeTypes
  };
}
function extractLayer(xmlLayer) {
  const layer = {
    name: xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name,
    title: xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Title,
    srs: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.SRS) || [],
    layers: []
  };
  const xmlLayers = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Layer);
  for (const xmlSubLayer of xmlLayers) {
    var _layer$layers;
    (_layer$layers = layer.layers) === null || _layer$layers === void 0 ? void 0 : _layer$layers.push(extractLayer(xmlSubLayer));
  }
  return layer;
}
function getXMLArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function parseWMSFeatureInfo(text, options) {
  var _parsedXML$FeatureInf;
  const parsedXML = XMLLoader.parseTextSync(text, options);
  const xmlFeatureInfo = ((_parsedXML$FeatureInf = parsedXML.FeatureInfoResponse) === null || _parsedXML$FeatureInf === void 0 ? void 0 : _parsedXML$FeatureInf.FIELDS) || [];
  const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
  return {
    features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
  };
}
function extractFeature(xmlFeature) {
  const xmlFields = xmlFeature || {};
  return {
    attributes: xmlFields,
    type: "",
    bounds: {
      bottom: 0,
      top: 0,
      left: 0,
      right: 0
    }
  };
}
function parseWMSLayerDescription(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, options);
  return parsedXML;
}
function parseWMSError(text, options) {
  var _XMLLoader$parseTextS, _parsedXML$ServiceExc, _parsedXML$ogcServic;
  const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
  const serviceExceptionXML = (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ServiceExc = parsedXML.ServiceExceptionReport) === null || _parsedXML$ServiceExc === void 0 ? void 0 : _parsedXML$ServiceExc.ServiceException) || (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ogcServic = parsedXML["ogc:ServiceExceptionReport"]) === null || _parsedXML$ogcServic === void 0 ? void 0 : _parsedXML$ogcServic["ogc:ServiceException"]);
  const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML["#text"] || serviceExceptionXML.code || "Unknown error";
  return message;
}
var init_parse_wms = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/wms/parse-wms.js"() {
    init_esm16();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/wms-error-loader.js
function testXMLFile2(text) {
  return text.startsWith("<?xml");
}
function parseTextSync(text, options) {
  const wmsOptions = {
    ...WMSErrorLoader.options.wms,
    ...options === null || options === void 0 ? void 0 : options.wms
  };
  const error = parseWMSError(text, wmsOptions);
  const message = wmsOptions.minimalErrors ? error : "WMS Service error: ".concat(error);
  if (wmsOptions.throwOnError) {
    throw new Error(message);
  }
  return message;
}
var VERSION2, WMSErrorLoader;
var init_wms_error_loader = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/wms-error-loader.js"() {
    init_parse_wms();
    VERSION2 = true ? "3.3.3" : "latest";
    WMSErrorLoader = {
      id: "wms-error",
      name: "WMS Error",
      module: "wms",
      version: VERSION2,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
      testText: testXMLFile2,
      options: {
        wms: {
          throwOnError: false
        }
      },
      parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
      parseSync: (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseTextSync(text, options)
    };
  }
});

// node_modules/@loaders.gl/wms/dist/esm/wms-capabilities-loader.js
function testXMLFile3(text) {
  return text.startsWith("<?xml");
}
var VERSION3, WMSCapabilitiesLoader;
var init_wms_capabilities_loader = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/wms-capabilities-loader.js"() {
    init_parse_wms();
    VERSION3 = true ? "3.3.3" : "latest";
    WMSCapabilitiesLoader = {
      id: "wms-capabilities",
      name: "WMS Capabilities",
      module: "wms",
      version: VERSION3,
      worker: false,
      extensions: ["xml"],
      mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
      testText: testXMLFile3,
      options: {
        wms: {}
      },
      parse: async (arrayBuffer, options) => parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWMSCapabilities(text, options)
    };
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-source.js
var ImageSource;
var init_image_source = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-source.js"() {
    ImageSource = class {
    };
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/image-service.js
function getFetchFunction(options) {
  const fetchFunction = options === null || options === void 0 ? void 0 : options.fetch;
  if (fetchFunction && typeof fetchFunction === "function") {
    return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
  }
  const fetchOptions = options === null || options === void 0 ? void 0 : options.fetch;
  if (fetchOptions && typeof fetchOptions !== "function") {
    return (url) => fetch(url, fetchOptions);
  }
  return (url) => fetch(url);
}
function mergeImageServiceProps(props) {
  return {
    ...props,
    loadOptions: {
      ...props.loadOptions,
      fetch: getFetchFunction(props.loadOptions)
    }
  };
}
var ImageService;
var init_image_service = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/image-service.js"() {
    init_defineProperty();
    init_esm5();
    init_image_source();
    ImageService = class extends ImageSource {
      constructor(props) {
        super();
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "fetch", void 0);
        this.props = mergeImageServiceProps(props);
        this.fetch = getFetchFunction(props);
      }
      async getMetadata() {
        throw new Error("ImageSource.getMetadata not implemented");
      }
      async getImage(parameters2) {
        const granularParameters = this.getGranularParameters(parameters2);
        const url = this.getURLFromTemplate(granularParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        return await ImageLoader.parse(arrayBuffer);
      }
      getGranularParameters(parameters2) {
        const [east, north, west, south] = parameters2.bbox;
        return {
          ...parameters2,
          east,
          north,
          south,
          west
        };
      }
      getURLFromTemplate(parameters2) {
        let url = this.props.url;
        for (const [key, value] of Object.entries(parameters2)) {
          url = url.replace("${".concat(key, "}"), String(value));
          url = url.replace("{".concat(key, "}"), String(value));
        }
        return url;
      }
    };
    _defineProperty(ImageService, "type", "template");
    _defineProperty(ImageService, "testURL", (url) => url.toLowerCase().includes("{"));
  }
});

// node_modules/@loaders.gl/wms/dist/esm/wip/wms-feature-info-loader.js
var WMSFeatureInfoLoader;
var init_wms_feature_info_loader = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/wip/wms-feature-info-loader.js"() {
    init_wms_capabilities_loader();
    init_parse_wms();
    WMSFeatureInfoLoader = {
      ...WMSCapabilitiesLoader,
      id: "wms-feature-info",
      name: "WMS FeatureInfo",
      parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
    };
  }
});

// node_modules/@loaders.gl/wms/dist/esm/wip/wms-layer-description-loader.js
var WMSLayerDescriptionLoader;
var init_wms_layer_description_loader = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/wip/wms-layer-description-loader.js"() {
    init_wms_capabilities_loader();
    init_parse_wms();
    WMSLayerDescriptionLoader = {
      ...WMSCapabilitiesLoader,
      id: "wms-layer-description",
      name: "WMS DescribeLayer",
      parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
      parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
    };
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/wms-service.js
var WMSService;
var init_wms_service = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/wms-service.js"() {
    init_defineProperty();
    init_esm5();
    init_image_source();
    init_image_service();
    init_wms_capabilities_loader();
    init_wms_feature_info_loader();
    init_wms_layer_description_loader();
    init_wms_error_loader();
    WMSService = class extends ImageSource {
      constructor(props) {
        var _this$props$loadOptio;
        super();
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "fetch", void 0);
        _defineProperty(this, "capabilities", null);
        _defineProperty(this, "loaders", [ImageLoader, WMSErrorLoader, WMSCapabilitiesLoader, WMSFeatureInfoLoader, WMSLayerDescriptionLoader]);
        this.props = mergeImageServiceProps(props);
        this.fetch = getFetchFunction(this.props);
        this.props.loadOptions = {
          ...this.props.loadOptions,
          wms: {
            ...(_this$props$loadOptio = this.props.loadOptions) === null || _this$props$loadOptio === void 0 ? void 0 : _this$props$loadOptio.wms,
            throwOnError: true
          }
        };
      }
      getMetadata() {
        return this.getCapabilities();
      }
      getImage(parameters2) {
        return this.getMap(parameters2);
      }
      async getCapabilities(wmsParameters, vendorParameters) {
        const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.props.loadOptions);
        this.capabilities = capabilities;
        return capabilities;
      }
      async getMap(options, vendorParameters) {
        const url = this.getMapURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        try {
          return await ImageLoader.parse(arrayBuffer, this.props.loadOptions);
        } catch {
          throw this._parseError(arrayBuffer);
        }
      }
      async getFeatureInfo(options, vendorParameters) {
        const url = this.getFeatureInfoURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        return await WMSFeatureInfoLoader.parse(arrayBuffer, this.props.loadOptions);
      }
      async getFeatureInfoText(options, vendorParameters) {
        options = {
          ...options,
          info_format: "text/plain"
        };
        const url = this.getFeatureInfoURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        return new TextDecoder().decode(arrayBuffer);
      }
      async describeLayer(options, vendorParameters) {
        const url = this.describeLayerURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.props.loadOptions);
      }
      async getLegendGraphic(options, vendorParameters) {
        const url = this.getLegendGraphicURL(options, vendorParameters);
        const response = await this.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        this._checkResponse(response, arrayBuffer);
        try {
          return await ImageLoader.parse(arrayBuffer, this.props.loadOptions);
        } catch {
          throw this._parseError(arrayBuffer);
        }
      }
      getCapabilitiesURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetCapabilities",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      getMapURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetMap",
          styles: void 0,
          srs: "EPSG:4326",
          format: "image/png",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      getFeatureInfoURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetFeatureInfo",
          srs: "EPSG:4326",
          format: "image/png",
          info_format: "text/plain",
          styles: void 0,
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      describeLayerURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "DescribeLayer",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      getLegendGraphicURL(wmsParameters, vendorParameters) {
        const options = {
          service: "WMS",
          version: "1.1.1",
          request: "GetLegendGraphic",
          ...wmsParameters,
          ...vendorParameters
        };
        return this._getWMSUrl(options, vendorParameters);
      }
      _getWMSUrl(options, vendorParameters) {
        let url = this.props.url;
        let first = true;
        for (const [key, value] of Object.entries(options)) {
          url += first ? "?" : "&";
          first = false;
          if (Array.isArray(value)) {
            url += "".concat(key.toUpperCase(), "=").concat(value.join(","));
          } else {
            url += "".concat(key.toUpperCase(), "=").concat(value ? String(value) : "");
          }
        }
        return encodeURI(url);
      }
      _checkResponse(response, arrayBuffer) {
        const contentType = response.headers["content-type"];
        if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
          const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
          throw new Error(error);
        }
      }
      _parseError(arrayBuffer) {
        const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
        return new Error(error);
      }
    };
    _defineProperty(WMSService, "type", "wms");
    _defineProperty(WMSService, "testURL", (url) => url.toLowerCase().includes("wms"));
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/arcgis-image-service.js
var ArcGISImageService;
var init_arcgis_image_service = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/image-services/arcgis-image-service.js"() {
    init_defineProperty();
    init_image_source();
    init_image_service();
    ArcGISImageService = class extends ImageSource {
      constructor(props) {
        super();
        _defineProperty(this, "props", void 0);
        _defineProperty(this, "fetch", void 0);
        this.props = mergeImageServiceProps(props);
        this.fetch = getFetchFunction(this.props);
      }
      async getMetadata() {
        return await this.info();
      }
      async getImage(parameters2) {
        throw new Error("not implemented");
      }
      async info() {
        throw new Error("not implemented");
      }
      exportImage(options) {
        throw new Error("not implemented");
      }
      infoURL(options) {
        return this.props.url;
      }
      exportImageURL(options) {
        return this.props.url;
      }
      getUrl(options, extra) {
        let url = "".concat(this.props.url);
        let first = true;
        for (const [key, value] of Object.entries(options)) {
          url += first ? "?" : "&";
          first = false;
          if (Array.isArray(value)) {
            url += "".concat(key.toUpperCase(), "=").concat(value.join(","));
          } else {
            url += "".concat(key.toUpperCase(), "=").concat(value ? String(value) : "");
          }
        }
        return url;
      }
      async checkResponse(response) {
        if (!response.ok) {
          throw new Error("error");
        }
      }
    };
    _defineProperty(ArcGISImageService, "type", "arcgis-image-server");
    _defineProperty(ArcGISImageService, "testURL", (url) => url.toLowerCase().includes("ImageServer"));
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/create-image-source.js
function createImageSource(props) {
  const {
    type = "auto"
  } = props;
  const serviceType = type === "auto" ? guessServiceType(props.url) : type;
  switch (serviceType) {
    case "template":
      return new ImageService(props);
    case "wms":
      return new WMSService(props);
    default:
      throw new Error("Not a valid image source type");
  }
}
function guessServiceType(url) {
  for (const Service of SERVICES) {
    if (Service.testURL && Service.testURL(url)) {
      return Service.type;
    }
  }
  return "wms";
}
var SERVICES;
var init_create_image_source = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/data-sources/create-image-source.js"() {
    init_image_service();
    init_wms_service();
    init_arcgis_image_service();
    SERVICES = [WMSService, ArcGISImageService, ImageService];
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/wmts/parse-wmts.js
var init_parse_wmts = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/wmts/parse-wmts.js"() {
    init_esm16();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/wip/wmts-capabilities-loader.js
var init_wmts_capabilities_loader = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/wip/wmts-capabilities-loader.js"() {
    init_parse_wmts();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/wfs/parse-wfs.js
var init_parse_wfs = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/wfs/parse-wfs.js"() {
    init_esm16();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/wip/wfs-capabilities-loader.js
var init_wfs_capabilities_loader = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/wip/wfs-capabilities-loader.js"() {
    init_parse_wfs();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/gml/deep-strict-equal.js
var pSlice;
var init_deep_strict_equal = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/gml/deep-strict-equal.js"() {
    pSlice = Array.prototype.slice;
  }
});

// node_modules/@loaders.gl/wms/dist/esm/lib/gml/parse-gml.js
var init_parse_gml = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/lib/gml/parse-gml.js"() {
    init_esm16();
    init_deep_strict_equal();
    init_main_es();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/wip/gml-loader.js
var init_gml_loader = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/wip/gml-loader.js"() {
    init_parse_gml();
  }
});

// node_modules/@loaders.gl/wms/dist/esm/index.js
var init_esm17 = __esm({
  "node_modules/@loaders.gl/wms/dist/esm/index.js"() {
    init_wms_error_loader();
    init_wms_capabilities_loader();
    init_image_source();
    init_create_image_source();
    init_image_service();
    init_wms_service();
    init_arcgis_image_service();
    init_wms_feature_info_loader();
    init_wms_layer_description_loader();
    init_wmts_capabilities_loader();
    init_wfs_capabilities_loader();
    init_gml_loader();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/utils.js
function WGS84ToPseudoMercator(coord) {
  const mercator = lngLatToWorld(coord);
  mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  return mercator;
}
var HALF_EARTH_CIRCUMFERENCE;
var init_utils4 = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/utils.js"() {
    init_esm12();
    HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/wms-layer.js
var defaultProps16, WMSLayer;
var init_wms_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/wms-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm15();
    init_esm17();
    init_utils4();
    defaultProps16 = {
      id: "imagery-layer",
      data: "",
      serviceType: "auto",
      srs: "auto",
      layers: {
        type: "array",
        compare: true,
        value: []
      },
      onMetadataLoad: {
        type: "function",
        value: () => {
        }
      },
      onMetadataLoadError: {
        type: "function",
        value: console.error
      },
      onImageLoadStart: {
        type: "function",
        value: () => {
        }
      },
      onImageLoad: {
        type: "function",
        value: () => {
        }
      },
      onImageLoadError: {
        type: "function",
        compare: false,
        value: (requestId, error) => console.error(error, requestId)
      }
    };
    WMSLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      get isLoaded() {
        return Boolean(this.state) && this.state.loadCounter === 0 && super.isLoaded;
      }
      shouldUpdateState() {
        return true;
      }
      initializeState() {
        this.state._nextRequestId = 0;
        this.state.lastRequestId = -1;
        this.state.loadCounter = 0;
      }
      updateState({
        changeFlags,
        props,
        oldProps
      }) {
        const {
          viewport
        } = this.context;
        if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
          this.state.imageSource = this._createImageSource(props);
          this._loadMetadata();
          this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
        } else if (!deepEqual(props.layers, oldProps.layers, 1)) {
          this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
        } else if (changeFlags.viewportChanged) {
          this.debounce(() => this.loadImage(viewport, "viewport changed"));
        }
      }
      finalizeState() {
      }
      renderLayers() {
        const {
          bounds,
          image,
          lastRequestParameters
        } = this.state;
        return image && new BitmapLayer({
          ...this.getSubLayerProps({
            id: "bitmap"
          }),
          _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
          bounds,
          image
        });
      }
      async getFeatureInfoText(x2, y2) {
        const {
          lastRequestParameters
        } = this.state;
        if (lastRequestParameters) {
          var _this$state$imageSour, _this$state$imageSour2;
          const featureInfo = await ((_this$state$imageSour = (_this$state$imageSour2 = this.state.imageSource).getFeatureInfoText) === null || _this$state$imageSour === void 0 ? void 0 : _this$state$imageSour.call(_this$state$imageSour2, {
            ...lastRequestParameters,
            query_layers: lastRequestParameters.layers,
            x: x2,
            y: y2,
            info_format: "application/vnd.ogc.gml"
          }));
          return featureInfo;
        }
        return "";
      }
      _createImageSource(props) {
        if (props.data instanceof ImageSource) {
          return props.data;
        }
        if (typeof props.data === "string") {
          return createImageSource({
            url: props.data,
            loadOptions: props.loadOptions,
            type: props.serviceType
          });
        }
        throw new Error("invalid image source in props.data");
      }
      async _loadMetadata() {
        const {
          imageSource
        } = this.state;
        try {
          this.state.loadCounter++;
          const metadata = await imageSource.getMetadata();
          if (this.state.imageSource === imageSource) {
            var _this$getCurrentLayer;
            (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onMetadataLoad(metadata);
          }
        } catch (error) {
          var _this$getCurrentLayer2;
          (_this$getCurrentLayer2 = this.getCurrentLayer()) === null || _this$getCurrentLayer2 === void 0 ? void 0 : _this$getCurrentLayer2.props.onMetadataLoadError(error);
        } finally {
          this.state.loadCounter--;
        }
      }
      async loadImage(viewport, reason) {
        const {
          layers,
          serviceType
        } = this.props;
        if (serviceType === "wms" && layers.length === 0) {
          return;
        }
        const bounds = viewport.getBounds();
        const {
          width,
          height
        } = viewport;
        const requestId = this.getRequestId();
        let {
          srs
        } = this.props;
        if (srs === "auto") {
          srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
        }
        const requestParams = {
          width,
          height,
          bbox: bounds,
          layers,
          srs
        };
        if (srs === "EPSG:3857") {
          const [minX, minY] = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
          const [maxX, maxY] = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
          requestParams.bbox = [minX, minY, maxX, maxY];
        }
        try {
          this.state.loadCounter++;
          this.props.onImageLoadStart(requestId);
          const image = await this.state.imageSource.getImage(requestParams);
          if (this.state.lastRequestId < requestId) {
            var _this$getCurrentLayer3;
            (_this$getCurrentLayer3 = this.getCurrentLayer()) === null || _this$getCurrentLayer3 === void 0 ? void 0 : _this$getCurrentLayer3.props.onImageLoad(requestId);
            this.setState({
              image,
              bounds,
              lastRequestParameters: requestParams,
              lastRequestId: requestId
            });
          }
        } catch (error) {
          var _this$getCurrentLayer4;
          this.raiseError(error, "Load image");
          (_this$getCurrentLayer4 = this.getCurrentLayer()) === null || _this$getCurrentLayer4 === void 0 ? void 0 : _this$getCurrentLayer4.props.onImageLoadError(requestId, error);
        } finally {
          this.state.loadCounter--;
        }
      }
      getRequestId() {
        return this.state._nextRequestId++;
      }
      debounce(fn, ms = 500) {
        clearTimeout(this.state._timeoutId);
        this.state._timeoutId = setTimeout(() => fn(), ms);
      }
    };
    _defineProperty(WMSLayer, "layerName", "WMSLayer");
    _defineProperty(WMSLayer, "defaultProps", defaultProps16);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/great-circle-layer/great-circle-layer.js
var defaultProps17, GreatCircleLayer;
var init_great_circle_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/great-circle-layer/great-circle-layer.js"() {
    init_defineProperty();
    init_esm15();
    defaultProps17 = {
      getHeight: {
        type: "accessor",
        value: 0
      },
      greatCircle: true
    };
    GreatCircleLayer = class extends ArcLayer {
    };
    _defineProperty(GreatCircleLayer, "layerName", "GreatCircleLayer");
    _defineProperty(GreatCircleLayer, "defaultProps", defaultProps17);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/geo-cell-layer/GeoCellLayer.js
var defaultProps18, GeoCellLayer;
var init_GeoCellLayer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/geo-cell-layer/GeoCellLayer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm15();
    defaultProps18 = {
      ...PolygonLayer.defaultProps
    };
    GeoCellLayer = class extends CompositeLayer {
      indexToBounds() {
        return null;
      }
      renderLayers() {
        const {
          elevationScale,
          extruded,
          wireframe,
          filled,
          stroked,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          lineJointRounded,
          lineMiterLimit,
          lineDashJustified,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        } = this.props;
        const {
          updateTriggers,
          material,
          transitions
        } = this.props;
        const CellLayer = this.getSubLayerClass("cell", PolygonLayer);
        return new CellLayer({
          filled,
          wireframe,
          extruded,
          elevationScale,
          stroked,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          lineJointRounded,
          lineMiterLimit,
          lineDashJustified,
          material,
          transitions,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        }, this.getSubLayerProps({
          id: "cell",
          updateTriggers: updateTriggers && {
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor,
            getLineWidth: updateTriggers.getLineWidth
          }
        }), this.indexToBounds());
      }
    };
    _defineProperty(GeoCellLayer, "layerName", "GeoCellLayer");
    _defineProperty(GeoCellLayer, "defaultProps", defaultProps18);
  }
});

// node_modules/long/dist/long.js
var require_long = __commonJS({
  "node_modules/long/dist/long.js"(exports, module) {
    (function(global, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
      else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
    })(exports, function() {
      "use strict";
      function Long3(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long3.prototype.__isLong__;
      Object.defineProperty(Long3.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long3.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache2;
        if (unsigned) {
          value >>>= 0;
          if (cache2 = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache2)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache2 = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache2)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long3.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
          return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long3.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long3(lowBits, highBits, unsigned);
      }
      Long3.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return ZERO;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p2;
        if ((p2 = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p2 === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i3 = 0; i3 < str.length; i3 += 8) {
          var size = Math.min(8, str.length - i3), value = parseInt(str.substring(i3, i3 + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long3.fromString = fromString;
      function fromValue(val2) {
        if (val2 instanceof Long3)
          return val2;
        if (typeof val2 === "number")
          return fromNumber(val2);
        if (typeof val2 === "string")
          return fromString(val2);
        return fromBits(val2.low, val2.high, val2.unsigned);
      }
      Long3.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long3.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long3.UZERO = UZERO;
      var ONE = fromInt(1);
      Long3.ONE = ONE;
      var UONE = fromInt(1, true);
      Long3.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long3.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long3.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long3.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long3.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val2 = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val2 & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals3(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return ZERO;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (multiplier.isZero())
          return ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
          else
            return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24 & 255,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24 & 255
        ];
      };
      LongPrototype.toBytesBE = function() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24 & 255,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24 & 255,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      return Long3;
    });
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-geometry.js
function IJToST(ij, order, offsets) {
  const maxSize = 1 << order;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV(st) {
  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
}
function FaceUVToXYZ(face, [u, v]) {
  switch (face) {
    case 0:
      return [1, u, v];
    case 1:
      return [-u, 1, v];
    case 2:
      return [-u, -v, 1];
    case 3:
      return [-1, -v, -u];
    case 4:
      return [v, -1, -u];
    case 5:
      return [v, u, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat([x2, y2, z]) {
  const lat = Math.atan2(z, Math.sqrt(x2 * x2 + y2 * y2));
  const lng = Math.atan2(y2, x2);
  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
}
function toHilbertQuadkey(idS) {
  let bin = import_long.default.fromString(idS, true, 10).toString(2);
  while (bin.length < FACE_BITS + POS_BITS) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
  let posS = import_long.default.fromString(posB, true, 2).toString(4);
  while (posS.length < levelN) {
    posS = "0" + posS;
  }
  return "".concat(faceS, "/").concat(posS);
}
function rotateAndFlipQuadrant(n2, point, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point[0] = n2 - 1 - point[0];
      point[1] = n2 - 1 - point[1];
    }
    const x2 = point[0];
    point[0] = point[1];
    point[1] = x2;
  }
}
function FromHilbertQuadKey(hilbertQuadkey) {
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  const point = [0, 0];
  let level;
  for (let i3 = maxLevel - 1; i3 >= 0; i3--) {
    level = maxLevel - i3;
    const bit = position[i3];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val2 = Math.pow(2, level - 1);
    rotateAndFlipQuadrant(val2, point, rx, ry);
    point[0] += val2 * rx;
    point[1] += val2 * ry;
  }
  if (face % 2 === 1) {
    const t2 = point[0];
    point[0] = point[1];
    point[1] = t2;
  }
  return {
    face,
    ij: point,
    level
  };
}
var import_long, FACE_BITS, MAX_LEVEL, POS_BITS, RADIAN_TO_DEGREE;
var init_s2_geometry = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-geometry.js"() {
    import_long = __toESM(require_long());
    FACE_BITS = 3;
    MAX_LEVEL = 30;
    POS_BITS = 2 * MAX_LEVEL + 1;
    RADIAN_TO_DEGREE = 180 / Math.PI;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-utils.js
function getIdFromToken(token) {
  const paddedToken = token.padEnd(16, "0");
  return import_long2.default.fromString(paddedToken, 16);
}
function getGeoBounds({
  face,
  ij,
  level
}) {
  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i3 = 0; i3 < 4; i3++) {
    const offset = offsets[i3].slice(0);
    const nextOffset = offsets[i3 + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST(ij, level, offset);
      const uv = STToUV(st);
      const xyz = FaceUVToXYZ(face, uv);
      const lngLat = XYZToLngLat(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}
function getS2QuadKey(token) {
  if (typeof token === "string") {
    if (token.indexOf("/") > 0) {
      return token;
    }
    token = getIdFromToken(token);
  }
  return toHilbertQuadkey(token.toString());
}
function getS2Polygon(token) {
  const key = getS2QuadKey(token);
  const s2cell = FromHilbertQuadKey(key);
  return getGeoBounds(s2cell);
}
var import_long2, MAX_RESOLUTION;
var init_s2_utils = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-utils.js"() {
    init_s2_geometry();
    import_long2 = __toESM(require_long());
    MAX_RESOLUTION = 100;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-layer.js
var defaultProps19, S2Layer;
var init_s2_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-layer.js"() {
    init_defineProperty();
    init_GeoCellLayer();
    init_s2_utils();
    defaultProps19 = {
      getS2Token: {
        type: "accessor",
        value: (d) => d.token
      }
    };
    S2Layer = class extends GeoCellLayer {
      indexToBounds() {
        const {
          data,
          getS2Token
        } = this.props;
        return {
          data,
          _normalize: false,
          positionFormat: "XY",
          getPolygon: (x2, objectInfo) => getS2Polygon(getS2Token(x2, objectInfo))
        };
      }
    };
    _defineProperty(S2Layer, "layerName", "S2Layer");
    _defineProperty(S2Layer, "defaultProps", defaultProps19);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-utils.js
function quadkeyToWorldBounds(quadkey) {
  let x2 = 0;
  let y2 = 0;
  let mask = 1 << quadkey.length;
  const scale = mask / TILE_SIZE;
  for (let i3 = 0; i3 < quadkey.length; i3++) {
    mask >>= 1;
    const q = parseInt(quadkey[i3]);
    if (q % 2)
      x2 |= mask;
    if (q > 1)
      y2 |= mask;
  }
  return [[x2 / scale, TILE_SIZE - y2 / scale], [(x2 + 0.99) / scale, TILE_SIZE - (y2 + 0.99) / scale]];
}
function getQuadkeyPolygon(quadkey) {
  const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey);
  const [w, n2] = worldToLngLat(topLeft);
  const [e2, s2] = worldToLngLat(bottomRight);
  return [e2, n2, e2, s2, w, s2, w, n2, e2, n2];
}
var TILE_SIZE;
var init_quadkey_utils = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-utils.js"() {
    init_esm12();
    TILE_SIZE = 512;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-layer.js
var defaultProps20, QuadkeyLayer;
var init_quadkey_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-layer.js"() {
    init_defineProperty();
    init_GeoCellLayer();
    init_quadkey_utils();
    defaultProps20 = {
      getQuadkey: {
        type: "accessor",
        value: (d) => d.quadkey
      }
    };
    QuadkeyLayer = class extends GeoCellLayer {
      indexToBounds() {
        const {
          data,
          getQuadkey
        } = this.props;
        return {
          data,
          _normalize: false,
          positionFormat: "XY",
          getPolygon: (x2, objectInfo) => getQuadkeyPolygon(getQuadkey(x2, objectInfo))
        };
      }
    };
    _defineProperty(QuadkeyLayer, "layerName", "QuadkeyLayer");
    _defineProperty(QuadkeyLayer, "defaultProps", defaultProps20);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-header.js
var Tile2DHeader;
var init_tile_2d_header = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-header.js"() {
    init_defineProperty();
    Tile2DHeader = class {
      constructor(index) {
        _defineProperty(this, "index", void 0);
        _defineProperty(this, "isVisible", void 0);
        _defineProperty(this, "isSelected", void 0);
        _defineProperty(this, "parent", void 0);
        _defineProperty(this, "children", void 0);
        _defineProperty(this, "content", void 0);
        _defineProperty(this, "state", void 0);
        _defineProperty(this, "layers", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "zoom", void 0);
        _defineProperty(this, "userData", void 0);
        _defineProperty(this, "boundingBox", void 0);
        _defineProperty(this, "_abortController", void 0);
        _defineProperty(this, "_loader", void 0);
        _defineProperty(this, "_loaderId", void 0);
        _defineProperty(this, "_isLoaded", void 0);
        _defineProperty(this, "_isCancelled", void 0);
        _defineProperty(this, "_needsReload", void 0);
        _defineProperty(this, "_bbox", void 0);
        this.index = index;
        this.isVisible = false;
        this.isSelected = false;
        this.parent = null;
        this.children = [];
        this.content = null;
        this._loader = void 0;
        this._abortController = null;
        this._loaderId = 0;
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
      }
      get bbox() {
        return this._bbox;
      }
      set bbox(value) {
        if (this._bbox)
          return;
        this._bbox = value;
        if ("west" in value) {
          this.boundingBox = [[value.west, value.south], [value.east, value.north]];
        } else {
          this.boundingBox = [[value.left, value.top], [value.right, value.bottom]];
        }
      }
      get data() {
        return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
      }
      get isLoaded() {
        return this._isLoaded && !this._needsReload;
      }
      get isLoading() {
        return Boolean(this._loader) && !this._isCancelled;
      }
      get needsReload() {
        return this._needsReload || this._isCancelled;
      }
      get byteLength() {
        const result = this.content ? this.content.byteLength : 0;
        if (!Number.isFinite(result)) {
          console.error("byteLength not defined in tile data");
        }
        return result;
      }
      async _loadData({
        getData,
        requestScheduler,
        onLoad,
        onError
      }) {
        const {
          index,
          id,
          bbox,
          userData,
          zoom
        } = this;
        const loaderId = this._loaderId;
        this._abortController = new AbortController();
        const {
          signal
        } = this._abortController;
        const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
          return tile.isSelected ? 1 : -1;
        });
        if (!requestToken) {
          this._isCancelled = true;
          return;
        }
        if (this._isCancelled) {
          requestToken.done();
          return;
        }
        let tileData = null;
        let error;
        try {
          tileData = await getData({
            index,
            id,
            bbox,
            userData,
            zoom,
            signal
          });
        } catch (err) {
          error = err || true;
        } finally {
          requestToken.done();
        }
        if (loaderId !== this._loaderId) {
          return;
        }
        this._loader = void 0;
        this.content = tileData;
        if (this._isCancelled && !tileData) {
          this._isLoaded = false;
          return;
        }
        this._isLoaded = true;
        this._isCancelled = false;
        if (error) {
          onError(error, this);
        } else {
          onLoad(this);
        }
      }
      loadData(opts) {
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
        this._loaderId++;
        this._loader = this._loadData(opts);
        return this._loader;
      }
      setNeedsReload() {
        if (this.isLoading) {
          this.abort();
          this._loader = void 0;
        }
        this._needsReload = true;
      }
      abort() {
        var _this$_abortControlle;
        if (this.isLoaded) {
          return;
        }
        this._isCancelled = true;
        (_this$_abortControlle = this._abortController) === null || _this$_abortControlle === void 0 ? void 0 : _this$_abortControlle.abort();
      }
    };
  }
});

// node_modules/@math.gl/culling/dist/esm/constants.js
var INTERSECTION;
var init_constants = __esm({
  "node_modules/@math.gl/culling/dist/esm/constants.js"() {
    INTERSECTION = {
      OUTSIDE: -1,
      INTERSECTING: 0,
      INSIDE: 1
    };
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/axis-aligned-bounding-box.js
var scratchVector, scratchNormal, AxisAlignedBoundingBox;
var init_axis_aligned_bounding_box = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/axis-aligned-bounding-box.js"() {
    init_defineProperty();
    init_esm8();
    init_constants();
    scratchVector = new Vector3();
    scratchNormal = new Vector3();
    AxisAlignedBoundingBox = class {
      constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {
        _defineProperty(this, "center", void 0);
        _defineProperty(this, "halfDiagonal", void 0);
        _defineProperty(this, "minimum", void 0);
        _defineProperty(this, "maximum", void 0);
        center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
        this.center = new Vector3(center);
        this.halfDiagonal = new Vector3(maximum).subtract(this.center);
        this.minimum = new Vector3(minimum);
        this.maximum = new Vector3(maximum);
      }
      clone() {
        return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
      }
      equals(right) {
        return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
      }
      transform(transform2) {
        this.center.transformAsPoint(transform2);
        this.halfDiagonal.transform(transform2);
        this.minimum.transform(transform2);
        this.maximum.transform(transform2);
        return this;
      }
      intersectPlane(plane) {
        const {
          halfDiagonal
        } = this;
        const normal = scratchNormal.from(plane.normal);
        const e2 = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
        const s2 = this.center.dot(normal) + plane.distance;
        if (s2 - e2 > 0) {
          return INTERSECTION.INSIDE;
        }
        if (s2 + e2 < 0) {
          return INTERSECTION.OUTSIDE;
        }
        return INTERSECTION.INTERSECTING;
      }
      distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
      }
      distanceSquaredTo(point) {
        const offset = scratchVector.from(point).subtract(this.center);
        const {
          halfDiagonal
        } = this;
        let distanceSquared = 0;
        let d;
        d = Math.abs(offset.x) - halfDiagonal.x;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.y) - halfDiagonal.y;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.z) - halfDiagonal.z;
        if (d > 0) {
          distanceSquared += d * d;
        }
        return distanceSquared;
      }
    };
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/bounding-sphere.js
var scratchVector2, scratchVector22, BoundingSphere;
var init_bounding_sphere = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/bounding-sphere.js"() {
    init_defineProperty();
    init_esm8();
    init_mat4();
    init_constants();
    scratchVector2 = new Vector3();
    scratchVector22 = new Vector3();
    BoundingSphere = class {
      constructor(center = [0, 0, 0], radius = 0) {
        _defineProperty(this, "center", void 0);
        _defineProperty(this, "radius", void 0);
        this.radius = -0;
        this.center = new Vector3();
        this.fromCenterRadius(center, radius);
      }
      fromCenterRadius(center, radius) {
        this.center.from(center);
        this.radius = radius;
        return this;
      }
      fromCornerPoints(corner, oppositeCorner) {
        oppositeCorner = scratchVector2.from(oppositeCorner);
        this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
        this.radius = this.center.distance(oppositeCorner);
        return this;
      }
      equals(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
      }
      clone() {
        return new BoundingSphere(this.center, this.radius);
      }
      union(boundingSphere) {
        const leftCenter = this.center;
        const leftRadius = this.radius;
        const rightCenter = boundingSphere.center;
        const rightRadius = boundingSphere.radius;
        const toRightCenter = scratchVector2.copy(rightCenter).subtract(leftCenter);
        const centerSeparation = toRightCenter.magnitude();
        if (leftRadius >= centerSeparation + rightRadius) {
          return this.clone();
        }
        if (rightRadius >= centerSeparation + leftRadius) {
          return boundingSphere.clone();
        }
        const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
        scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
        this.center.copy(scratchVector22);
        this.radius = halfDistanceBetweenTangentPoints;
        return this;
      }
      expand(point) {
        const scratchPoint2 = scratchVector2.from(point);
        const radius = scratchPoint2.subtract(this.center).magnitude();
        if (radius > this.radius) {
          this.radius = radius;
        }
        return this;
      }
      transform(transform2) {
        this.center.transform(transform2);
        const scale = getScaling(scratchVector2, transform2);
        this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;
        return this;
      }
      distanceSquaredTo(point) {
        const d = this.distanceTo(point);
        return d * d;
      }
      distanceTo(point) {
        const scratchPoint2 = scratchVector2.from(point);
        const delta = scratchPoint2.subtract(this.center);
        return Math.max(0, delta.len() - this.radius);
      }
      intersectPlane(plane) {
        const center = this.center;
        const radius = this.radius;
        const normal = plane.normal;
        const distanceToPlane = normal.dot(center) + plane.distance;
        if (distanceToPlane < -radius) {
          return INTERSECTION.OUTSIDE;
        }
        if (distanceToPlane < radius) {
          return INTERSECTION.INTERSECTING;
        }
        return INTERSECTION.INSIDE;
      }
    };
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/oriented-bounding-box.js
var scratchVector3, scratchOffset, scratchVectorU, scratchVectorV, scratchVectorW, scratchCorner, scratchToCenter, MATRIX3, OrientedBoundingBox;
var init_oriented_bounding_box = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/oriented-bounding-box.js"() {
    init_defineProperty();
    init_esm8();
    init_bounding_sphere();
    init_constants();
    scratchVector3 = new Vector3();
    scratchOffset = new Vector3();
    scratchVectorU = new Vector3();
    scratchVectorV = new Vector3();
    scratchVectorW = new Vector3();
    scratchCorner = new Vector3();
    scratchToCenter = new Vector3();
    MATRIX3 = {
      COLUMN0ROW0: 0,
      COLUMN0ROW1: 1,
      COLUMN0ROW2: 2,
      COLUMN1ROW0: 3,
      COLUMN1ROW1: 4,
      COLUMN1ROW2: 5,
      COLUMN2ROW0: 6,
      COLUMN2ROW1: 7,
      COLUMN2ROW2: 8
    };
    OrientedBoundingBox = class {
      constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
        _defineProperty(this, "center", void 0);
        _defineProperty(this, "halfAxes", void 0);
        this.center = new Vector3().from(center);
        this.halfAxes = new Matrix3(halfAxes);
      }
      get halfSize() {
        const xAxis = this.halfAxes.getColumn(0);
        const yAxis = this.halfAxes.getColumn(1);
        const zAxis = this.halfAxes.getColumn(2);
        return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
      }
      get quaternion() {
        const xAxis = this.halfAxes.getColumn(0);
        const yAxis = this.halfAxes.getColumn(1);
        const zAxis = this.halfAxes.getColumn(2);
        const normXAxis = new Vector3(xAxis).normalize();
        const normYAxis = new Vector3(yAxis).normalize();
        const normZAxis = new Vector3(zAxis).normalize();
        return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
      }
      fromCenterHalfSizeQuaternion(center, halfSize, quaternion2) {
        const quaternionObject = new Quaternion(quaternion2);
        const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
        directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
        directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
        directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
        directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
        directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
        directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
        directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
        directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
        directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
        this.center = new Vector3().from(center);
        this.halfAxes = directionsMatrix;
        return this;
      }
      clone() {
        return new OrientedBoundingBox(this.center, this.halfAxes);
      }
      equals(right) {
        return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
      }
      getBoundingSphere(result = new BoundingSphere()) {
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        const cornerVector = scratchVector3.copy(u).add(v).add(w);
        result.center.copy(this.center);
        result.radius = cornerVector.magnitude();
        return result;
      }
      intersectPlane(plane) {
        const center = this.center;
        const normal = plane.normal;
        const halfAxes = this.halfAxes;
        const normalX = normal.x;
        const normalY = normal.y;
        const normalZ = normal.z;
        const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
        const distanceToPlane = normal.dot(center) + plane.distance;
        if (distanceToPlane <= -radEffective) {
          return INTERSECTION.OUTSIDE;
        } else if (distanceToPlane >= radEffective) {
          return INTERSECTION.INSIDE;
        }
        return INTERSECTION.INTERSECTING;
      }
      distanceTo(point) {
        return Math.sqrt(this.distanceSquaredTo(point));
      }
      distanceSquaredTo(point) {
        const offset = scratchOffset.from(point).subtract(this.center);
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        const uHalf = u.magnitude();
        const vHalf = v.magnitude();
        const wHalf = w.magnitude();
        u.normalize();
        v.normalize();
        w.normalize();
        let distanceSquared = 0;
        let d;
        d = Math.abs(offset.dot(u)) - uHalf;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(v)) - vHalf;
        if (d > 0) {
          distanceSquared += d * d;
        }
        d = Math.abs(offset.dot(w)) - wHalf;
        if (d > 0) {
          distanceSquared += d * d;
        }
        return distanceSquared;
      }
      computePlaneDistances(position, direction, result = [-0, -0]) {
        let minDist = Number.POSITIVE_INFINITY;
        let maxDist = Number.NEGATIVE_INFINITY;
        const center = this.center;
        const halfAxes = this.halfAxes;
        const u = halfAxes.getColumn(0, scratchVectorU);
        const v = halfAxes.getColumn(1, scratchVectorV);
        const w = halfAxes.getColumn(2, scratchVectorW);
        const corner = scratchCorner.copy(u).add(v).add(w).add(center);
        const toCenter = scratchToCenter.copy(corner).subtract(position);
        let mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        corner.copy(center).add(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        corner.copy(center).add(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        corner.copy(center).add(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).add(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).add(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).subtract(v).add(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        center.copy(corner).subtract(u).subtract(v).subtract(w);
        toCenter.copy(corner).subtract(position);
        mag = direction.dot(toCenter);
        minDist = Math.min(mag, minDist);
        maxDist = Math.max(mag, maxDist);
        result[0] = minDist;
        result[1] = maxDist;
        return result;
      }
      transform(transformation) {
        this.center.transformAsPoint(transformation);
        const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
        xAxis.transformAsPoint(transformation);
        const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
        yAxis.transformAsPoint(transformation);
        const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
        zAxis.transformAsPoint(transformation);
        this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
        return this;
      }
      getTransform() {
        throw new Error("not implemented");
      }
    };
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/plane.js
var scratchPosition, scratchNormal2, Plane;
var init_plane = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/plane.js"() {
    init_defineProperty();
    init_esm8();
    scratchPosition = new Vector3();
    scratchNormal2 = new Vector3();
    Plane = class {
      constructor(normal = [0, 0, 1], distance = 0) {
        _defineProperty(this, "normal", void 0);
        _defineProperty(this, "distance", void 0);
        this.normal = new Vector3();
        this.distance = -0;
        this.fromNormalDistance(normal, distance);
      }
      fromNormalDistance(normal, distance) {
        assert4(Number.isFinite(distance));
        this.normal.from(normal).normalize();
        this.distance = distance;
        return this;
      }
      fromPointNormal(point, normal) {
        point = scratchPosition.from(point);
        this.normal.from(normal).normalize();
        const distance = -this.normal.dot(point);
        this.distance = distance;
        return this;
      }
      fromCoefficients(a2, b, c2, d) {
        this.normal.set(a2, b, c2);
        assert4(equals(this.normal.len(), 1));
        this.distance = d;
        return this;
      }
      clone() {
        return new Plane(this.normal, this.distance);
      }
      equals(right) {
        return equals(this.distance, right.distance) && equals(this.normal, right.normal);
      }
      getPointDistance(point) {
        return this.normal.dot(point) + this.distance;
      }
      transform(matrix4) {
        const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
        const point = this.normal.scale(-this.distance).transform(matrix4);
        return this.fromPointNormal(point, normal);
      }
      projectPointOntoPlane(point, result = [0, 0, 0]) {
        point = scratchPosition.from(point);
        const pointDistance = this.getPointDistance(point);
        const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
        return point.subtract(scaledNormal).to(result);
      }
    };
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js
var faces, scratchPlaneCenter, scratchPlaneNormal, scratchPlane, CullingVolume;
var init_culling_volume = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js"() {
    init_defineProperty();
    init_esm8();
    init_constants();
    init_plane();
    faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
    scratchPlaneCenter = new Vector3();
    scratchPlaneNormal = new Vector3();
    scratchPlane = new Plane(new Vector3(1, 0, 0), 0);
    CullingVolume = class {
      constructor(planes = []) {
        _defineProperty(this, "planes", void 0);
        this.planes = planes;
      }
      fromBoundingSphere(boundingSphere) {
        this.planes.length = 2 * faces.length;
        const center = boundingSphere.center;
        const radius = boundingSphere.radius;
        let planeIndex = 0;
        for (const faceNormal of faces) {
          let plane0 = this.planes[planeIndex];
          let plane1 = this.planes[planeIndex + 1];
          if (!plane0) {
            plane0 = this.planes[planeIndex] = new Plane();
          }
          if (!plane1) {
            plane1 = this.planes[planeIndex + 1] = new Plane();
          }
          const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
          const plane0Distance = -faceNormal.dot(plane0Center);
          plane0.fromPointNormal(plane0Center, faceNormal);
          const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
          const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
          const plane1Distance = -negatedFaceNormal.dot(plane1Center);
          plane1.fromPointNormal(plane1Center, negatedFaceNormal);
          planeIndex += 2;
        }
        return this;
      }
      computeVisibility(boundingVolume) {
        let intersect3 = INTERSECTION.INSIDE;
        for (const plane of this.planes) {
          const result = boundingVolume.intersectPlane(plane);
          switch (result) {
            case INTERSECTION.OUTSIDE:
              return INTERSECTION.OUTSIDE;
            case INTERSECTION.INTERSECTING:
              intersect3 = INTERSECTION.INTERSECTING;
              break;
            default:
          }
        }
        return intersect3;
      }
      computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
        assert4(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
        if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
          return parentPlaneMask;
        }
        let mask = CullingVolume.MASK_INSIDE;
        const planes = this.planes;
        for (let k = 0; k < this.planes.length; ++k) {
          const flag = k < 31 ? 1 << k : 0;
          if (k < 31 && (parentPlaneMask & flag) === 0) {
            continue;
          }
          const plane = planes[k];
          const result = boundingVolume.intersectPlane(plane);
          if (result === INTERSECTION.OUTSIDE) {
            return CullingVolume.MASK_OUTSIDE;
          } else if (result === INTERSECTION.INTERSECTING) {
            mask |= flag;
          }
        }
        return mask;
      }
    };
    _defineProperty(CullingVolume, "MASK_OUTSIDE", 4294967295);
    _defineProperty(CullingVolume, "MASK_INSIDE", 0);
    _defineProperty(CullingVolume, "MASK_INDETERMINATE", 2147483647);
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js
var scratchPlaneUpVector, scratchPlaneRightVector, scratchPlaneNearCenter, scratchPlaneFarCenter, scratchPlaneNormal2;
var init_perspective_off_center_frustum = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js"() {
    init_defineProperty();
    init_esm8();
    init_culling_volume();
    init_plane();
    scratchPlaneUpVector = new Vector3();
    scratchPlaneRightVector = new Vector3();
    scratchPlaneNearCenter = new Vector3();
    scratchPlaneFarCenter = new Vector3();
    scratchPlaneNormal2 = new Vector3();
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js
var init_perspective_frustum = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js"() {
    init_defineProperty();
    init_esm8();
    init_perspective_off_center_frustum();
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-sphere-from-points.js
var fromPointsXMin, fromPointsYMin, fromPointsZMin, fromPointsXMax, fromPointsYMax, fromPointsZMax, fromPointsCurrentPos, fromPointsScratch, fromPointsRitterCenter, fromPointsMinBoxPt, fromPointsMaxBoxPt, fromPointsNaiveCenterScratch, volumeConstant;
var init_bounding_sphere_from_points = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-sphere-from-points.js"() {
    init_esm8();
    init_bounding_sphere();
    fromPointsXMin = new Vector3();
    fromPointsYMin = new Vector3();
    fromPointsZMin = new Vector3();
    fromPointsXMax = new Vector3();
    fromPointsYMax = new Vector3();
    fromPointsZMax = new Vector3();
    fromPointsCurrentPos = new Vector3();
    fromPointsScratch = new Vector3();
    fromPointsRitterCenter = new Vector3();
    fromPointsMinBoxPt = new Vector3();
    fromPointsMaxBoxPt = new Vector3();
    fromPointsNaiveCenterScratch = new Vector3();
    volumeConstant = 4 / 3 * Math.PI;
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/algorithms/compute-eigen-decomposition.js
function computeEigenDecomposition(matrix, result = {}) {
  const EIGEN_TOLERANCE = math_utils_default.EPSILON20;
  const EIGEN_MAX_SWEEPS = 10;
  let count = 0;
  let sweep = 0;
  const unitaryMatrix = scratchUnitary;
  const diagonalMatrix = scratchDiagonal;
  unitaryMatrix.identity();
  diagonalMatrix.copy(matrix);
  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
    shurDecomposition(diagonalMatrix, jMatrix);
    jMatrixTranspose.copy(jMatrix).transpose();
    diagonalMatrix.multiplyRight(jMatrix);
    diagonalMatrix.multiplyLeft(jMatrixTranspose);
    unitaryMatrix.multiplyRight(jMatrix);
    if (++count > 2) {
      ++sweep;
      count = 0;
    }
  }
  result.unitary = unitaryMatrix.toTarget(result.unitary);
  result.diagonal = diagonalMatrix.toTarget(result.diagonal);
  return result;
}
function computeFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i3 = 0; i3 < 9; ++i3) {
    const temp = matrix[i3];
    norm += temp * temp;
  }
  return Math.sqrt(norm);
}
function offDiagonalFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i3 = 0; i3 < 3; ++i3) {
    const temp = matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])];
    norm += 2 * temp * temp;
  }
  return Math.sqrt(norm);
}
function shurDecomposition(matrix, result) {
  const tolerance = math_utils_default.EPSILON15;
  let maxDiagonal = 0;
  let rotAxis = 1;
  for (let i3 = 0; i3 < 3; ++i3) {
    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])]);
    if (temp > maxDiagonal) {
      rotAxis = i3;
      maxDiagonal = temp;
    }
  }
  const p2 = rowVal[rotAxis];
  const q = colVal[rotAxis];
  let c2 = 1;
  let s2 = 0;
  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p2)]) > tolerance) {
    const qq = matrix[scratchMatrix.getElementIndex(q, q)];
    const pp = matrix[scratchMatrix.getElementIndex(p2, p2)];
    const qp = matrix[scratchMatrix.getElementIndex(q, p2)];
    const tau = (qq - pp) / 2 / qp;
    let t2;
    if (tau < 0) {
      t2 = -1 / (-tau + Math.sqrt(1 + tau * tau));
    } else {
      t2 = 1 / (tau + Math.sqrt(1 + tau * tau));
    }
    c2 = 1 / Math.sqrt(1 + t2 * t2);
    s2 = t2 * c2;
  }
  Matrix3.IDENTITY.to(result);
  result[scratchMatrix.getElementIndex(p2, p2)] = result[scratchMatrix.getElementIndex(q, q)] = c2;
  result[scratchMatrix.getElementIndex(q, p2)] = s2;
  result[scratchMatrix.getElementIndex(p2, q)] = -s2;
  return result;
}
var scratchMatrix, scratchUnitary, scratchDiagonal, jMatrix, jMatrixTranspose, rowVal, colVal;
var init_compute_eigen_decomposition = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/algorithms/compute-eigen-decomposition.js"() {
    init_esm8();
    scratchMatrix = new Matrix3();
    scratchUnitary = new Matrix3();
    scratchDiagonal = new Matrix3();
    jMatrix = new Matrix3();
    jMatrixTranspose = new Matrix3();
    rowVal = [1, 0, 0];
    colVal = [2, 2, 1];
  }
});

// node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-box-from-points.js
function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
  if (!positions || positions.length === 0) {
    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    result.center = new Vector3();
    return result;
  }
  const length3 = positions.length;
  const meanPoint = new Vector3(0, 0, 0);
  for (const position of positions) {
    meanPoint.add(position);
  }
  const invLength = 1 / length3;
  meanPoint.multiplyByScalar(invLength);
  let exx = 0;
  let exy = 0;
  let exz = 0;
  let eyy = 0;
  let eyz = 0;
  let ezz = 0;
  for (const position of positions) {
    const p2 = scratchVector23.copy(position).subtract(meanPoint);
    exx += p2.x * p2.x;
    exy += p2.x * p2.y;
    exz += p2.x * p2.z;
    eyy += p2.y * p2.y;
    eyz += p2.y * p2.z;
    ezz += p2.z * p2.z;
  }
  exx *= invLength;
  exy *= invLength;
  exz *= invLength;
  eyy *= invLength;
  eyz *= invLength;
  ezz *= invLength;
  const covarianceMatrix = scratchCovarianceResult;
  covarianceMatrix[0] = exx;
  covarianceMatrix[1] = exy;
  covarianceMatrix[2] = exz;
  covarianceMatrix[3] = exy;
  covarianceMatrix[4] = eyy;
  covarianceMatrix[5] = eyz;
  covarianceMatrix[6] = exz;
  covarianceMatrix[7] = eyz;
  covarianceMatrix[8] = ezz;
  const {
    unitary
  } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
  const rotation = result.halfAxes.copy(unitary);
  let v1 = rotation.getColumn(0, scratchVector4);
  let v2 = rotation.getColumn(1, scratchVector5);
  let v3 = rotation.getColumn(2, scratchVector6);
  let u1 = -Number.MAX_VALUE;
  let u2 = -Number.MAX_VALUE;
  let u3 = -Number.MAX_VALUE;
  let l1 = Number.MAX_VALUE;
  let l2 = Number.MAX_VALUE;
  let l3 = Number.MAX_VALUE;
  for (const position of positions) {
    scratchVector23.copy(position);
    u1 = Math.max(scratchVector23.dot(v1), u1);
    u2 = Math.max(scratchVector23.dot(v2), u2);
    u3 = Math.max(scratchVector23.dot(v3), u3);
    l1 = Math.min(scratchVector23.dot(v1), l1);
    l2 = Math.min(scratchVector23.dot(v2), l2);
    l3 = Math.min(scratchVector23.dot(v3), l3);
  }
  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
  result.center.copy(v1).add(v2).add(v3);
  const scale = scratchVector32.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);
  result.halfAxes.multiplyRight(scaleMatrix);
  return result;
}
var scratchVector23, scratchVector32, scratchVector4, scratchVector5, scratchVector6, scratchCovarianceResult, scratchEigenResult;
var init_bounding_box_from_points = __esm({
  "node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-box-from-points.js"() {
    init_esm8();
    init_compute_eigen_decomposition();
    init_oriented_bounding_box();
    init_axis_aligned_bounding_box();
    scratchVector23 = new Vector3();
    scratchVector32 = new Vector3();
    scratchVector4 = new Vector3();
    scratchVector5 = new Vector3();
    scratchVector6 = new Vector3();
    scratchCovarianceResult = new Matrix3();
    scratchEigenResult = {
      diagonal: new Matrix3(),
      unitary: new Matrix3()
    };
  }
});

// node_modules/@math.gl/culling/dist/esm/index.js
var init_esm18 = __esm({
  "node_modules/@math.gl/culling/dist/esm/index.js"() {
    init_constants();
    init_axis_aligned_bounding_box();
    init_bounding_sphere();
    init_oriented_bounding_box();
    init_culling_volume();
    init_plane();
    init_perspective_off_center_frustum();
    init_perspective_frustum();
    init_bounding_sphere_from_points();
    init_bounding_box_from_points();
    init_compute_eigen_decomposition();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-traversal.js
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
  const project2 = viewport instanceof GlobeViewport && viewport.resolution ? viewport.projectPosition : null;
  const planes = Object.values(viewport.getFrustumPlanes()).map(({
    normal,
    distance
  }) => new Plane(normal.clone().negate(), distance));
  const cullingVolume2 = new CullingVolume(planes);
  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
  const minZ = viewport instanceof WebMercatorViewport && viewport.pitch <= 60 ? maxZ : 0;
  if (bounds) {
    const [minLng, minLat, maxLng, maxLat] = bounds;
    const topLeft = lngLatToWorld([minLng, maxLat]);
    const bottomRight = lngLatToWorld([maxLng, minLat]);
    bounds = [topLeft[0], TILE_SIZE2 - topLeft[1], bottomRight[0], TILE_SIZE2 - bottomRight[1]];
  }
  const root = new OSMNode(0, 0, 0);
  const traversalParams = {
    viewport,
    project: project2,
    cullingVolume: cullingVolume2,
    elevationBounds: [elevationMin, elevationMax],
    minZ,
    maxZ,
    bounds,
    offset: 0
  };
  root.update(traversalParams);
  if (viewport instanceof WebMercatorViewport && viewport.subViewports && viewport.subViewports.length > 1) {
    traversalParams.offset = -1;
    while (root.update(traversalParams)) {
      if (--traversalParams.offset < -MAX_MAPS) {
        break;
      }
    }
    traversalParams.offset = 1;
    while (root.update(traversalParams)) {
      if (++traversalParams.offset > MAX_MAPS) {
        break;
      }
    }
  }
  return root.getSelected();
}
var TILE_SIZE2, MAX_MAPS, REF_POINTS_5, REF_POINTS_9, REF_POINTS_11, OSMNode;
var init_tile_2d_traversal = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-traversal.js"() {
    init_defineProperty();
    init_esm13();
    init_esm18();
    init_esm12();
    init_utils5();
    TILE_SIZE2 = 512;
    MAX_MAPS = 3;
    REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];
    REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);
    REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);
    OSMNode = class {
      constructor(x2, y2, z) {
        _defineProperty(this, "x", void 0);
        _defineProperty(this, "y", void 0);
        _defineProperty(this, "z", void 0);
        _defineProperty(this, "childVisible", void 0);
        _defineProperty(this, "selected", void 0);
        _defineProperty(this, "_children", void 0);
        this.x = x2;
        this.y = y2;
        this.z = z;
      }
      get children() {
        if (!this._children) {
          const x2 = this.x * 2;
          const y2 = this.y * 2;
          const z = this.z + 1;
          this._children = [new OSMNode(x2, y2, z), new OSMNode(x2, y2 + 1, z), new OSMNode(x2 + 1, y2, z), new OSMNode(x2 + 1, y2 + 1, z)];
        }
        return this._children;
      }
      update(params) {
        const {
          viewport,
          cullingVolume: cullingVolume2,
          elevationBounds,
          minZ,
          maxZ,
          bounds,
          offset,
          project: project2
        } = params;
        const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project2);
        if (bounds && !this.insideBounds(bounds)) {
          return false;
        }
        const isInside = cullingVolume2.computeVisibility(boundingVolume);
        if (isInside < 0) {
          return false;
        }
        if (!this.childVisible) {
          let {
            z
          } = this;
          if (z < maxZ && z >= minZ) {
            const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
            z += Math.floor(Math.log2(distance));
          }
          if (z >= maxZ) {
            this.selected = true;
            return true;
          }
        }
        this.selected = false;
        this.childVisible = true;
        for (const child of this.children) {
          child.update(params);
        }
        return true;
      }
      getSelected(result = []) {
        if (this.selected) {
          result.push(this);
        }
        if (this._children) {
          for (const node of this._children) {
            node.getSelected(result);
          }
        }
        return result;
      }
      insideBounds([minX, minY, maxX, maxY]) {
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE2 / scale;
        return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
      }
      getBoundingVolume(zRange, worldOffset, project2) {
        if (project2) {
          const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
          const refPointPositions = [];
          for (const p2 of refPoints) {
            const lngLat = osmTile2lngLat(this.x + p2[0], this.y + p2[1], this.z);
            lngLat[2] = zRange[0];
            refPointPositions.push(project2(lngLat));
            if (zRange[0] !== zRange[1]) {
              lngLat[2] = zRange[1];
              refPointPositions.push(project2(lngLat));
            }
          }
          return makeOrientedBoundingBoxFromPoints(refPointPositions);
        }
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE2 / scale;
        const originX = this.x * extent + worldOffset * TILE_SIZE2;
        const originY = TILE_SIZE2 - (this.y + 1) * extent;
        return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
      }
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/utils.js
function transformBox(bbox, modelMatrix2) {
  const transformedCoords = [modelMatrix2.transformAsPoint([bbox[0], bbox[1]]), modelMatrix2.transformAsPoint([bbox[2], bbox[1]]), modelMatrix2.transformAsPoint([bbox[0], bbox[3]]), modelMatrix2.transformAsPoint([bbox[2], bbox[3]])];
  const transformedBox = [Math.min(...transformedCoords.map((i3) => i3[0])), Math.min(...transformedCoords.map((i3) => i3[1])), Math.max(...transformedCoords.map((i3) => i3[0])), Math.max(...transformedCoords.map((i3) => i3[1]))];
  return transformedBox;
}
function stringHash(s2) {
  return Math.abs(s2.split("").reduce((a2, b) => (a2 << 5) - a2 + b.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
  if (!template || !template.length) {
    return null;
  }
  const {
    index,
    id
  } = tile;
  if (Array.isArray(template)) {
    const i3 = stringHash(id) % template.length;
    template = template[i3];
  }
  let url = template;
  for (const key of Object.keys(index)) {
    const regex = new RegExp("{".concat(key, "}"), "g");
    url = url.replace(regex, String(index[key]));
  }
  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
  }
  return url;
}
function getBoundingBox2(viewport, zRange, extent) {
  let bounds;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({
      z: minZ
    });
    const bounds1 = viewport.getBounds({
      z: maxZ
    });
    bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  } else {
    bounds = viewport.getBounds();
  }
  if (!viewport.isGeospatial) {
    return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];
  }
  return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];
}
function getCullBounds({
  viewport,
  z = 0,
  cullRect
}) {
  const subViewports = viewport.subViewports || [viewport];
  return subViewports.map((v) => getCullBoundsInViewport(v, z, cullRect));
}
function getCullBoundsInViewport(viewport, z, cullRect) {
  if (!Array.isArray(z)) {
    const x2 = cullRect.x - viewport.x;
    const y2 = cullRect.y - viewport.y;
    const {
      width,
      height
    } = cullRect;
    const unprojectOption = {
      targetZ: z
    };
    const topLeft = viewport.unproject([x2, y2], unprojectOption);
    const topRight = viewport.unproject([x2 + width, y2], unprojectOption);
    const bottomLeft = viewport.unproject([x2, y2 + height], unprojectOption);
    const bottomRight = viewport.unproject([x2 + width, y2 + height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }
  const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
  const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
  return [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
}
function getIndexingCoords(bbox, scale, modelMatrixInverse) {
  if (modelMatrixInverse) {
    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i3) => i3 * scale / TILE_SIZE3);
    return transformedTileIndex;
  }
  return bbox.map((i3) => i3 * scale / TILE_SIZE3);
}
function getScale(z, tileSize) {
  return Math.pow(2, z) * TILE_SIZE3 / tileSize;
}
function osmTile2lngLat(x2, y2, z) {
  const scale = getScale(z, TILE_SIZE3);
  const lng = x2 / scale * 360 - 180;
  const n2 = Math.PI - 2 * Math.PI * y2 / scale;
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2)));
  return [lng, lat];
}
function tile2XY(x2, y2, z, tileSize) {
  const scale = getScale(z, tileSize);
  return [x2 / scale * TILE_SIZE3, y2 / scale * TILE_SIZE3];
}
function tileToBoundingBox(viewport, x2, y2, z, tileSize = TILE_SIZE3) {
  if (viewport.isGeospatial) {
    const [west, north] = osmTile2lngLat(x2, y2, z);
    const [east, south] = osmTile2lngLat(x2 + 1, y2 + 1, z);
    return {
      west,
      north,
      east,
      south
    };
  }
  const [left, top] = tile2XY(x2, y2, z, tileSize);
  const [right, bottom] = tile2XY(x2 + 1, y2 + 1, z, tileSize);
  return {
    left,
    top,
    right,
    bottom
  };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
  const bbox = getBoundingBox2(viewport, null, extent);
  const scale = getScale(z, tileSize);
  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);
  const indices = [];
  for (let x2 = Math.floor(minX); x2 < maxX; x2++) {
    for (let y2 = Math.floor(minY); y2 < maxY; y2++) {
      indices.push({
        x: x2,
        y: y2,
        z
      });
    }
  }
  return indices;
}
function getTileIndices({
  viewport,
  maxZoom,
  minZoom,
  zRange,
  extent,
  tileSize = TILE_SIZE3,
  modelMatrix: modelMatrix2,
  modelMatrixInverse,
  zoomOffset = 0
}) {
  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE3 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
  if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
    if (!extent) {
      return [];
    }
    z = minZoom;
  }
  if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  let transformedExtent = extent;
  if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
    transformedExtent = transformBox(extent, modelMatrix2);
  }
  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s2) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s2);
}
function isGeoBoundingBox(v) {
  return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
}
var TILE_SIZE3, DEFAULT_EXTENT, urlType;
var init_utils5 = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/utils.js"() {
    init_tile_2d_traversal();
    TILE_SIZE3 = 512;
    DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
    urlType = {
      type: "object",
      value: null,
      validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
      equal: (value1, value2) => {
        if (value1 === value2) {
          return true;
        }
        if (!Array.isArray(value1) || !Array.isArray(value2)) {
          return false;
        }
        const len = value1.length;
        if (len !== value2.length) {
          return false;
        }
        for (let i3 = 0; i3 < len; i3++) {
          if (value1[i3] !== value2[i3]) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/memoize.js
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
function isEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (Array.isArray(a2)) {
    const len = a2.length;
    if (!b || b.length !== len) {
      return false;
    }
    for (let i3 = 0; i3 < len; i3++) {
      if (a2[i3] !== b[i3]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var init_memoize = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/memoize.js"() {
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tileset-2d.js
function updateTileStateDefault(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  }
  for (const tile of allTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
  }
}
function updateTileStateReplace(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected) {
      getPlaceholderInAncestors(tile);
    }
  }
  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
  for (const tile of sortedTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
      for (const child of tile.children) {
        child.state = TILE_STATE_VISITED;
      }
    } else if (tile.isSelected) {
      getPlaceholderInChildren(tile);
    }
  }
}
function getPlaceholderInAncestors(startTile) {
  let tile = startTile;
  while (tile) {
    if (tile.isLoaded || tile.content) {
      tile.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  for (const child of tile.children) {
    if (child.isLoaded || child.content) {
      child.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  }
}
var TILE_STATE_VISITED, TILE_STATE_VISIBLE, STRATEGY_NEVER, STRATEGY_REPLACE, STRATEGY_DEFAULT, DEFAULT_CACHE_SCALE, STRATEGIES, DEFAULT_TILESET2D_PROPS, Tileset2D;
var init_tileset_2d = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tileset-2d.js"() {
    init_defineProperty();
    init_esm3();
    init_esm8();
    init_tile_2d_header();
    init_utils5();
    init_memoize();
    TILE_STATE_VISITED = 1;
    TILE_STATE_VISIBLE = 2;
    STRATEGY_NEVER = "never";
    STRATEGY_REPLACE = "no-overlap";
    STRATEGY_DEFAULT = "best-available";
    DEFAULT_CACHE_SCALE = 5;
    STRATEGIES = {
      [STRATEGY_DEFAULT]: updateTileStateDefault,
      [STRATEGY_REPLACE]: updateTileStateReplace,
      [STRATEGY_NEVER]: () => {
      }
    };
    DEFAULT_TILESET2D_PROPS = {
      extent: null,
      tileSize: 512,
      maxZoom: null,
      minZoom: null,
      maxCacheSize: null,
      maxCacheByteSize: null,
      refinementStrategy: "best-available",
      zRange: null,
      maxRequests: 6,
      zoomOffset: 0,
      onTileLoad: () => {
      },
      onTileUnload: () => {
      },
      onTileError: () => {
      }
    };
    Tileset2D = class {
      constructor(opts) {
        _defineProperty(this, "opts", void 0);
        _defineProperty(this, "_requestScheduler", void 0);
        _defineProperty(this, "_cache", void 0);
        _defineProperty(this, "_dirty", void 0);
        _defineProperty(this, "_tiles", void 0);
        _defineProperty(this, "_cacheByteSize", void 0);
        _defineProperty(this, "_viewport", void 0);
        _defineProperty(this, "_zRange", void 0);
        _defineProperty(this, "_selectedTiles", void 0);
        _defineProperty(this, "_frameNumber", void 0);
        _defineProperty(this, "_modelMatrix", void 0);
        _defineProperty(this, "_modelMatrixInverse", void 0);
        _defineProperty(this, "_maxZoom", void 0);
        _defineProperty(this, "_minZoom", void 0);
        _defineProperty(this, "onTileLoad", void 0);
        _defineProperty(this, "_getCullBounds", memoize2(getCullBounds));
        this.opts = {
          ...DEFAULT_TILESET2D_PROPS,
          ...opts
        };
        this.onTileLoad = (tile) => {
          var _this$opts$onTileLoad, _this$opts;
          (_this$opts$onTileLoad = (_this$opts = this.opts).onTileLoad) === null || _this$opts$onTileLoad === void 0 ? void 0 : _this$opts$onTileLoad.call(_this$opts, tile);
          if (this.opts.maxCacheByteSize) {
            this._cacheByteSize += tile.byteLength;
            this._resizeCache();
          }
        };
        this._requestScheduler = new RequestScheduler({
          maxRequests: opts.maxRequests,
          throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)
        });
        this._cache = /* @__PURE__ */ new Map();
        this._tiles = [];
        this._dirty = false;
        this._cacheByteSize = 0;
        this._viewport = null;
        this._selectedTiles = null;
        this._frameNumber = 0;
        this._modelMatrix = new Matrix4();
        this._modelMatrixInverse = new Matrix4();
        this.setOptions(opts);
      }
      get tiles() {
        return this._tiles;
      }
      get selectedTiles() {
        return this._selectedTiles;
      }
      get isLoaded() {
        return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
      }
      get needsReload() {
        return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
      }
      setOptions(opts) {
        Object.assign(this.opts, opts);
        if (Number.isFinite(opts.maxZoom)) {
          this._maxZoom = Math.floor(opts.maxZoom);
        }
        if (Number.isFinite(opts.minZoom)) {
          this._minZoom = Math.ceil(opts.minZoom);
        }
      }
      finalize() {
        for (const tile of this._cache.values()) {
          if (tile.isLoading) {
            tile.abort();
          }
        }
        this._cache.clear();
        this._tiles = [];
        this._selectedTiles = null;
      }
      reloadAll() {
        for (const id of this._cache.keys()) {
          const tile = this._cache.get(id);
          if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
            this._cache.delete(id);
          } else {
            tile.setNeedsReload();
          }
        }
      }
      update(viewport, {
        zRange,
        modelMatrix: modelMatrix2
      } = {}) {
        const modelMatrixAsMatrix4 = new Matrix4(modelMatrix2);
        const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
        if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
          if (isModelMatrixNew) {
            this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
            this._modelMatrix = modelMatrixAsMatrix4;
          }
          this._viewport = viewport;
          this._zRange = zRange;
          const tileIndices = this.getTileIndices({
            viewport,
            maxZoom: this._maxZoom,
            minZoom: this._minZoom,
            zRange,
            modelMatrix: this._modelMatrix,
            modelMatrixInverse: this._modelMatrixInverse
          });
          this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
          if (this._dirty) {
            this._rebuildTree();
          }
        } else if (this.needsReload) {
          this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
        }
        const changed = this.updateTileStates();
        this._pruneRequests();
        if (this._dirty) {
          this._resizeCache();
        }
        if (changed) {
          this._frameNumber++;
        }
        return this._frameNumber;
      }
      isTileVisible(tile, cullRect) {
        if (!tile.isVisible) {
          return false;
        }
        if (cullRect && this._viewport) {
          const boundsArr = this._getCullBounds({
            viewport: this._viewport,
            z: this._zRange,
            cullRect
          });
          const {
            bbox
          } = tile;
          for (const [minX, minY, maxX, maxY] of boundsArr) {
            let overlaps;
            if ("west" in bbox) {
              overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
            } else {
              const y0 = Math.min(bbox.top, bbox.bottom);
              const y1 = Math.max(bbox.top, bbox.bottom);
              overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
            }
            if (overlaps) {
              return true;
            }
          }
          return false;
        }
        return true;
      }
      getTileIndices({
        viewport,
        maxZoom,
        minZoom,
        zRange,
        modelMatrix: modelMatrix2,
        modelMatrixInverse
      }) {
        const {
          tileSize,
          extent,
          zoomOffset
        } = this.opts;
        return getTileIndices({
          viewport,
          maxZoom,
          minZoom,
          zRange,
          tileSize,
          extent,
          modelMatrix: modelMatrix2,
          modelMatrixInverse,
          zoomOffset
        });
      }
      getTileId(index) {
        return "".concat(index.x, "-").concat(index.y, "-").concat(index.z);
      }
      getTileZoom(index) {
        return index.z;
      }
      getTileMetadata(index) {
        const {
          tileSize
        } = this.opts;
        return {
          bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)
        };
      }
      getParentIndex(index) {
        const x2 = Math.floor(index.x / 2);
        const y2 = Math.floor(index.y / 2);
        const z = index.z - 1;
        return {
          x: x2,
          y: y2,
          z
        };
      }
      updateTileStates() {
        const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
        const visibilities = new Array(this._cache.size);
        let i3 = 0;
        for (const tile of this._cache.values()) {
          visibilities[i3++] = tile.isVisible;
          tile.isSelected = false;
          tile.isVisible = false;
        }
        for (const tile of this._selectedTiles) {
          tile.isSelected = true;
          tile.isVisible = true;
        }
        (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
        i3 = 0;
        for (const tile of this._cache.values()) {
          if (visibilities[i3++] !== tile.isVisible) {
            return true;
          }
        }
        return false;
      }
      _pruneRequests() {
        const {
          maxRequests = 0
        } = this.opts;
        const abortCandidates = [];
        let ongoingRequestCount = 0;
        for (const tile of this._cache.values()) {
          if (tile.isLoading) {
            ongoingRequestCount++;
            if (!tile.isSelected && !tile.isVisible) {
              abortCandidates.push(tile);
            }
          }
        }
        while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
          const tile = abortCandidates.shift();
          tile.abort();
          ongoingRequestCount--;
        }
      }
      _rebuildTree() {
        const {
          _cache
        } = this;
        for (const tile of _cache.values()) {
          tile.parent = null;
          if (tile.children) {
            tile.children.length = 0;
          }
        }
        for (const tile of _cache.values()) {
          const parent = this._getNearestAncestor(tile);
          tile.parent = parent;
          if (parent !== null && parent !== void 0 && parent.children) {
            parent.children.push(tile);
          }
        }
      }
      _resizeCache() {
        const {
          _cache,
          opts
        } = this;
        const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
        const maxCacheByteSize = opts.maxCacheByteSize || Infinity;
        const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
        if (overflown) {
          for (const [id, tile] of _cache) {
            if (!tile.isVisible && !tile.isSelected) {
              var _this$opts$onTileUnlo, _this$opts2;
              this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
              _cache.delete(id);
              (_this$opts$onTileUnlo = (_this$opts2 = this.opts).onTileUnload) === null || _this$opts$onTileUnlo === void 0 ? void 0 : _this$opts$onTileUnlo.call(_this$opts2, tile);
            }
            if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
              break;
            }
          }
          this._rebuildTree();
          this._dirty = true;
        }
        if (this._dirty) {
          this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
          this._dirty = false;
        }
      }
      _getTile(index, create) {
        const id = this.getTileId(index);
        let tile = this._cache.get(id);
        let needsReload = false;
        if (!tile && create) {
          tile = new Tile2DHeader(index);
          Object.assign(tile, this.getTileMetadata(tile.index));
          Object.assign(tile, {
            id,
            zoom: this.getTileZoom(tile.index)
          });
          needsReload = true;
          this._cache.set(id, tile);
          this._dirty = true;
        } else if (tile && tile.needsReload) {
          needsReload = true;
        }
        if (tile && needsReload) {
          tile.loadData({
            getData: this.opts.getTileData,
            requestScheduler: this._requestScheduler,
            onLoad: this.onTileLoad,
            onError: this.opts.onTileError
          });
        }
        return tile;
      }
      _getNearestAncestor(tile) {
        const {
          _minZoom = 0
        } = this;
        let index = tile.index;
        while (this.getTileZoom(index) > _minZoom) {
          index = this.getParentIndex(index);
          const parent = this._getTile(index);
          if (parent) {
            return parent;
          }
        }
        return null;
      }
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/index.js
var init_tileset_2d2 = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/index.js"() {
    init_tileset_2d();
    init_tile_2d_header();
    init_utils5();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-layer.js
var defaultProps21, TileLayer;
var init_tile_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm15();
    init_tileset_2d2();
    init_tileset_2d2();
    defaultProps21 = {
      TilesetClass: Tileset2D,
      data: {
        type: "data",
        value: []
      },
      dataComparator: urlType.equal,
      renderSubLayers: {
        type: "function",
        value: (props) => new GeoJsonLayer(props)
      },
      getTileData: {
        type: "function",
        optional: true,
        value: null
      },
      onViewportLoad: {
        type: "function",
        optional: true,
        value: null
      },
      onTileLoad: {
        type: "function",
        value: (tile) => {
        }
      },
      onTileUnload: {
        type: "function",
        value: (tile) => {
        }
      },
      onTileError: {
        type: "function",
        value: (err) => console.error(err)
      },
      extent: {
        type: "array",
        optional: true,
        value: null,
        compare: true
      },
      tileSize: 512,
      maxZoom: null,
      minZoom: 0,
      maxCacheSize: null,
      maxCacheByteSize: null,
      refinementStrategy: STRATEGY_DEFAULT,
      zRange: null,
      maxRequests: 6,
      zoomOffset: 0
    };
    TileLayer = class extends CompositeLayer {
      initializeState() {
        this.state = {
          tileset: null,
          isLoaded: false
        };
      }
      finalizeState() {
        var _this$state, _this$state$tileset;
        (_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$tileset = _this$state.tileset) === null || _this$state$tileset === void 0 ? void 0 : _this$state$tileset.finalize();
      }
      get isLoaded() {
        var _this$state2, _this$state2$tileset;
        return (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : (_this$state2$tileset = _this$state2.tileset) === null || _this$state2$tileset === void 0 ? void 0 : _this$state2$tileset.selectedTiles.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded));
      }
      shouldUpdateState({
        changeFlags
      }) {
        return changeFlags.somethingChanged;
      }
      updateState({
        changeFlags
      }) {
        let {
          tileset
        } = this.state;
        const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
        const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
        if (!tileset) {
          tileset = new this.props.TilesetClass(this._getTilesetOptions());
          this.setState({
            tileset
          });
        } else if (propsChanged) {
          tileset.setOptions(this._getTilesetOptions());
          if (dataChanged) {
            tileset.reloadAll();
          } else {
            this.state.tileset.tiles.forEach((tile) => {
              tile.layers = null;
            });
          }
        }
        this._updateTileset();
      }
      _getTilesetOptions() {
        const {
          tileSize,
          maxCacheSize,
          maxCacheByteSize,
          refinementStrategy,
          extent,
          maxZoom,
          minZoom,
          maxRequests,
          zoomOffset
        } = this.props;
        return {
          maxCacheSize,
          maxCacheByteSize,
          maxZoom,
          minZoom,
          tileSize,
          refinementStrategy,
          extent,
          maxRequests,
          zoomOffset,
          getTileData: this.getTileData.bind(this),
          onTileLoad: this._onTileLoad.bind(this),
          onTileError: this._onTileError.bind(this),
          onTileUnload: this._onTileUnload.bind(this)
        };
      }
      _updateTileset() {
        const {
          tileset
        } = this.state;
        const {
          zRange,
          modelMatrix: modelMatrix2
        } = this.props;
        const frameNumber = tileset.update(this.context.viewport, {
          zRange,
          modelMatrix: modelMatrix2
        });
        const {
          isLoaded
        } = tileset;
        const loadingStateChanged = this.state.isLoaded !== isLoaded;
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (isLoaded && (loadingStateChanged || tilesetChanged)) {
          this._onViewportLoad();
        }
        if (tilesetChanged) {
          this.setState({
            frameNumber
          });
        }
        this.state.isLoaded = isLoaded;
      }
      _onViewportLoad() {
        const {
          tileset
        } = this.state;
        const {
          onViewportLoad
        } = this.props;
        if (onViewportLoad) {
          onViewportLoad(tileset.selectedTiles);
        }
      }
      _onTileLoad(tile) {
        this.props.onTileLoad(tile);
        tile.layers = null;
        this.setNeedsUpdate();
      }
      _onTileError(error, tile) {
        this.props.onTileError(error);
        tile.layers = null;
        this.setNeedsUpdate();
      }
      _onTileUnload(tile) {
        this.props.onTileUnload(tile);
      }
      getTileData(tile) {
        const {
          data,
          getTileData,
          fetch: fetch2
        } = this.props;
        const {
          signal
        } = tile;
        tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
        if (getTileData) {
          return getTileData(tile);
        }
        if (fetch2 && tile.url) {
          return fetch2(tile.url, {
            propName: "data",
            layer: this,
            signal
          });
        }
        return null;
      }
      renderSubLayers(props) {
        return this.props.renderSubLayers(props);
      }
      getSubLayerPropsByTile(tile) {
        return null;
      }
      getPickingInfo({
        info,
        sourceLayer
      }) {
        const sourceTile = sourceLayer.props.tile;
        if (info.picked) {
          info.tile = sourceTile;
        }
        info.sourceTile = sourceTile;
        return info;
      }
      _updateAutoHighlight(info) {
        const sourceTile = info.sourceTile;
        if (sourceTile && sourceTile.layers) {
          for (const layer of sourceTile.layers) {
            layer.updateAutoHighlight(info);
          }
        }
      }
      renderLayers() {
        return this.state.tileset.tiles.map((tile) => {
          const subLayerProps = this.getSubLayerPropsByTile(tile);
          if (!tile.isLoaded && !tile.content) {
          } else if (!tile.layers) {
            const layers = this.renderSubLayers({
              ...this.props,
              id: "".concat(this.id, "-").concat(tile.id),
              data: tile.content,
              _offset: 0,
              tile
            });
            tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
              tile,
              ...subLayerProps
            }));
          } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
            tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
          }
          return tile.layers;
        });
      }
      filterSubLayer({
        layer,
        cullRect
      }) {
        const {
          tile
        } = layer.props;
        return this.state.tileset.isTileVisible(tile, cullRect);
      }
    };
    _defineProperty(TileLayer, "defaultProps", defaultProps21);
    _defineProperty(TileLayer, "layerName", "TileLayer");
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/trips-layer/trips-layer.js
var defaultProps22, TripsLayer;
var init_trips_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/trips-layer/trips-layer.js"() {
    init_defineProperty();
    init_esm15();
    defaultProps22 = {
      fadeTrail: true,
      trailLength: {
        type: "number",
        value: 120,
        min: 0
      },
      currentTime: {
        type: "number",
        value: 0,
        min: 0
      },
      getTimestamps: {
        type: "accessor",
        value: (d) => d.timestamps
      }
    };
    TripsLayer = class extends PathLayer {
      getShaders() {
        const shaders = super.getShaders();
        shaders.inject = {
          "vs:#decl": "uniform float trailLength;\nattribute float instanceTimestamps;\nattribute float instanceNextTimestamps;\nvarying float vTime;\n",
          "vs:#main-end": "vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;\n",
          "fs:#decl": "uniform bool fadeTrail;\nuniform float trailLength;\nuniform float currentTime;\nvarying float vTime;\n",
          "fs:#main-start": "if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {\n  discard;\n}\n",
          "fs:DECKGL_FILTER_COLOR": "if(fadeTrail) {\n  color.a *= 1.0 - (currentTime - vTime) / trailLength;\n}\n"
        };
        return shaders;
      }
      initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          timestamps: {
            size: 1,
            accessor: "getTimestamps",
            shaderAttributes: {
              instanceTimestamps: {
                vertexOffset: 0
              },
              instanceNextTimestamps: {
                vertexOffset: 1
              }
            }
          }
        });
      }
      draw(params) {
        const {
          fadeTrail,
          trailLength,
          currentTime
        } = this.props;
        params.uniforms = {
          ...params.uniforms,
          fadeTrail,
          trailLength,
          currentTime
        };
        super.draw(params);
      }
    };
    _defineProperty(TripsLayer, "layerName", "TripsLayer");
    _defineProperty(TripsLayer, "defaultProps", defaultProps22);
  }
});

// node_modules/h3-js/dist/browser/h3-js.es.js
var h3_js_es_exports = {};
__export(h3_js_es_exports, {
  UNITS: () => UNITS,
  cellArea: () => cellArea,
  compact: () => compact,
  degsToRads: () => degsToRads,
  edgeLength: () => edgeLength,
  exactEdgeLength: () => exactEdgeLength,
  experimentalH3ToLocalIj: () => experimentalH3ToLocalIj,
  experimentalLocalIjToH3: () => experimentalLocalIjToH3,
  geoToH3: () => geoToH3,
  getDestinationH3IndexFromUnidirectionalEdge: () => getDestinationH3IndexFromUnidirectionalEdge,
  getH3IndexesFromUnidirectionalEdge: () => getH3IndexesFromUnidirectionalEdge,
  getH3UnidirectionalEdge: () => getH3UnidirectionalEdge,
  getH3UnidirectionalEdgeBoundary: () => getH3UnidirectionalEdgeBoundary,
  getH3UnidirectionalEdgesFromHexagon: () => getH3UnidirectionalEdgesFromHexagon,
  getOriginH3IndexFromUnidirectionalEdge: () => getOriginH3IndexFromUnidirectionalEdge,
  getPentagonIndexes: () => getPentagonIndexes,
  getRes0Indexes: () => getRes0Indexes,
  h3Distance: () => h3Distance,
  h3GetBaseCell: () => h3GetBaseCell,
  h3GetFaces: () => h3GetFaces,
  h3GetResolution: () => h3GetResolution,
  h3IndexToSplitLong: () => h3IndexToSplitLong,
  h3IndexesAreNeighbors: () => h3IndexesAreNeighbors,
  h3IsPentagon: () => h3IsPentagon,
  h3IsResClassIII: () => h3IsResClassIII,
  h3IsValid: () => h3IsValid,
  h3Line: () => h3Line,
  h3SetToMultiPolygon: () => h3SetToMultiPolygon,
  h3ToCenterChild: () => h3ToCenterChild,
  h3ToChildren: () => h3ToChildren,
  h3ToGeo: () => h3ToGeo,
  h3ToGeoBoundary: () => h3ToGeoBoundary,
  h3ToParent: () => h3ToParent,
  h3UnidirectionalEdgeIsValid: () => h3UnidirectionalEdgeIsValid,
  hexArea: () => hexArea,
  hexRing: () => hexRing,
  kRing: () => kRing,
  kRingDistances: () => kRingDistances,
  numHexagons: () => numHexagons,
  pointDist: () => pointDist,
  polyfill: () => polyfill,
  radsToDegs: () => radsToDegs,
  splitLongToh3Index: () => splitLongToh3Index,
  uncompact: () => uncompact
});
function validateRes(res) {
  if (typeof res !== "number" || res < 0 || res > 15 || Math.floor(res) !== res) {
    throw new Error("Invalid resolution: " + res);
  }
}
function h3IndexToSplitLong(h3Index) {
  if (Array.isArray(h3Index) && h3Index.length === 2 && Number.isInteger(h3Index[0]) && Number.isInteger(h3Index[1])) {
    return h3Index;
  }
  if (typeof h3Index !== "string" || INVALID_HEXIDECIMAL_CHAR.test(h3Index)) {
    return [0, 0];
  }
  var upper = parseInt(h3Index.substring(0, h3Index.length - 8), BASE_16);
  var lower = parseInt(h3Index.substring(h3Index.length - 8), BASE_16);
  return [lower, upper];
}
function hexFrom32Bit(num) {
  if (num >= 0) {
    return num.toString(BASE_16);
  }
  num = num & 2147483647;
  var tempStr = zeroPad(8, num.toString(BASE_16));
  var topNum = (parseInt(tempStr[0], BASE_16) + 8).toString(BASE_16);
  tempStr = topNum + tempStr.substring(1);
  return tempStr;
}
function splitLongToh3Index(lower, upper) {
  return hexFrom32Bit(upper) + zeroPad(8, hexFrom32Bit(lower));
}
function zeroPad(fullLen, numStr) {
  var numZeroes = fullLen - numStr.length;
  var outStr = "";
  for (var i3 = 0; i3 < numZeroes; i3++) {
    outStr += "0";
  }
  outStr = outStr + numStr;
  return outStr;
}
function polygonArrayToGeofence(polygonArray, geofence, isGeoJson) {
  var numVerts = polygonArray.length;
  var geoCoordArray = libh3._calloc(numVerts, SZ_GEOCOORD);
  var latIndex = isGeoJson ? 1 : 0;
  var lngIndex = isGeoJson ? 0 : 1;
  for (var i3 = 0; i3 < numVerts * 2; i3 += 2) {
    libh3.HEAPF64.set([polygonArray[i3 / 2][latIndex], polygonArray[i3 / 2][lngIndex]].map(degsToRads), geoCoordArray / SZ_DBL + i3);
  }
  libh3.HEAPU32.set([numVerts, geoCoordArray], geofence / SZ_INT);
  return geofence;
}
function coordinatesToGeoPolygon(coordinates, isGeoJson) {
  var numHoles = coordinates.length - 1;
  var geoPolygon = libh3._calloc(SZ_GEOPOLYGON);
  var geofenceOffset = 0;
  var numHolesOffset = geofenceOffset + SZ_GEOFENCE;
  var holesOffset = numHolesOffset + SZ_INT;
  polygonArrayToGeofence(coordinates[0], geoPolygon + geofenceOffset, isGeoJson);
  var holes;
  if (numHoles > 0) {
    holes = libh3._calloc(numHoles, SZ_GEOFENCE);
    for (var i3 = 0; i3 < numHoles; i3++) {
      polygonArrayToGeofence(coordinates[i3 + 1], holes + SZ_GEOFENCE * i3, isGeoJson);
    }
  }
  libh3.setValue(geoPolygon + numHolesOffset, numHoles, "i32");
  libh3.setValue(geoPolygon + holesOffset, holes, "i32");
  return geoPolygon;
}
function destroyGeoPolygon(geoPolygon) {
  var geofenceOffset = 0;
  var numHolesOffset = geofenceOffset + SZ_GEOFENCE;
  var holesOffset = numHolesOffset + SZ_INT;
  var geofenceArrayOffset = SZ_INT;
  libh3._free(libh3.getValue(geoPolygon + geofenceOffset + geofenceArrayOffset, "i8*"));
  var numHoles = libh3.getValue(geoPolygon + numHolesOffset, "i32");
  if (numHoles > 0) {
    var holes = libh3.getValue(geoPolygon + holesOffset, "i32");
    for (var i3 = 0; i3 < numHoles; i3++) {
      libh3._free(libh3.getValue(holes + SZ_GEOFENCE * i3 + geofenceArrayOffset, "i8*"));
    }
    libh3._free(holes);
  }
  libh3._free(geoPolygon);
}
function readLong(invocation) {
  var upper = libh3.getTempRet0();
  return [invocation, upper];
}
function readH3Index(invocation) {
  var ref = readLong(invocation);
  var lower = ref[0];
  var upper = ref[1];
  return upper ? splitLongToh3Index(lower, upper) : null;
}
function readH3IndexFromPointer(cAddress, offset) {
  if (offset === void 0)
    offset = 0;
  var lower = libh3.getValue(cAddress + SZ_INT * offset * 2, "i32");
  var upper = libh3.getValue(cAddress + SZ_INT * (offset * 2 + 1), "i32");
  return upper ? splitLongToh3Index(lower, upper) : null;
}
function storeH3Index(h3Index, cAddress, offset) {
  libh3.HEAPU32.set(h3IndexToSplitLong(h3Index), cAddress / SZ_INT + 2 * offset);
}
function readArrayOfHexagons(cAddress, maxCount) {
  var out = [];
  for (var i3 = 0; i3 < maxCount; i3++) {
    var h3Index = readH3IndexFromPointer(cAddress, i3);
    if (h3Index !== null) {
      out.push(h3Index);
    }
  }
  return out;
}
function storeArrayOfHexagons(cAddress, hexagons) {
  var count = hexagons.length;
  for (var i3 = 0; i3 < count; i3++) {
    storeH3Index(hexagons[i3], cAddress, i3);
  }
}
function storeGeoCoord(lat, lng) {
  var geoCoord = libh3._calloc(1, SZ_GEOCOORD);
  libh3.HEAPF64.set([lat, lng].map(degsToRads), geoCoord / SZ_DBL);
  return geoCoord;
}
function readSingleCoord(cAddress) {
  return radsToDegs(libh3.getValue(cAddress, "double"));
}
function readGeoCoord(cAddress) {
  return [readSingleCoord(cAddress), readSingleCoord(cAddress + SZ_DBL)];
}
function readGeoCoordGeoJson(cAddress) {
  return [readSingleCoord(cAddress + SZ_DBL), readSingleCoord(cAddress)];
}
function readGeoBoundary(geoBoundary, geoJsonCoords, closedLoop) {
  var numVerts = libh3.getValue(geoBoundary, "i32");
  var vertsPos = geoBoundary + SZ_DBL;
  var out = [];
  var readCoord = geoJsonCoords ? readGeoCoordGeoJson : readGeoCoord;
  for (var i3 = 0; i3 < numVerts * 2; i3 += 2) {
    out.push(readCoord(vertsPos + SZ_DBL * i3));
  }
  if (closedLoop) {
    out.push(out[0]);
  }
  return out;
}
function readMultiPolygon(polygon, formatAsGeoJson) {
  var output = [];
  var readCoord = formatAsGeoJson ? readGeoCoordGeoJson : readGeoCoord;
  var loops;
  var loop;
  var coords;
  var coord;
  while (polygon) {
    output.push(loops = []);
    loop = libh3.getValue(polygon, "i8*");
    while (loop) {
      loops.push(coords = []);
      coord = libh3.getValue(loop, "i8*");
      while (coord) {
        coords.push(readCoord(coord));
        coord = libh3.getValue(coord + SZ_DBL * 2, "i8*");
      }
      if (formatAsGeoJson) {
        coords.push(coords[0]);
      }
      loop = libh3.getValue(loop + SZ_PTR * 2, "i8*");
    }
    polygon = libh3.getValue(polygon + SZ_PTR * 2, "i8*");
  }
  return output;
}
function readCoordIJ(cAddress) {
  return {
    i: libh3.getValue(cAddress, "i32"),
    j: libh3.getValue(cAddress + SZ_INT, "i32")
  };
}
function storeCoordIJ(cAddress, ref) {
  var i3 = ref.i;
  var j = ref.j;
  libh3.setValue(cAddress, i3, "i32");
  libh3.setValue(cAddress + SZ_INT, j, "i32");
}
function readArrayOfPositiveIntegers(cAddress, count) {
  var out = [];
  for (var i3 = 0; i3 < count; i3++) {
    var int = libh3.getValue(cAddress + SZ_INT * i3, "i32");
    if (int >= 0) {
      out.push(int);
    }
  }
  return out;
}
function h3IsValid(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.h3IsValid(lower, upper));
}
function h3IsPentagon(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.h3IsPentagon(lower, upper));
}
function h3IsResClassIII(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.h3IsResClassIII(lower, upper));
}
function h3GetBaseCell(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return H3.h3GetBaseCell(lower, upper);
}
function h3GetFaces(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  var count = H3.maxFaceCount(lower, upper);
  var faces2 = libh3._malloc(SZ_INT * count);
  H3.h3GetFaces(lower, upper, faces2);
  var out = readArrayOfPositiveIntegers(faces2, count);
  libh3._free(faces2);
  return out;
}
function h3GetResolution(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  if (!H3.h3IsValid(lower, upper)) {
    return -1;
  }
  return H3.h3GetResolution(lower, upper);
}
function geoToH3(lat, lng, res) {
  var latlng = libh3._malloc(SZ_GEOCOORD);
  libh3.HEAPF64.set([lat, lng].map(degsToRads), latlng / SZ_DBL);
  var h3Index = readH3Index(H3.geoToH3(latlng, res));
  libh3._free(latlng);
  return h3Index;
}
function h3ToGeo(h3Index) {
  var latlng = libh3._malloc(SZ_GEOCOORD);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  H3.h3ToGeo(lower, upper, latlng);
  var out = readGeoCoord(latlng);
  libh3._free(latlng);
  return out;
}
function h3ToGeoBoundary(h3Index, formatAsGeoJson) {
  var geoBoundary = libh3._malloc(SZ_GEOBOUNDARY);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  H3.h3ToGeoBoundary(lower, upper, geoBoundary);
  var out = readGeoBoundary(geoBoundary, formatAsGeoJson, formatAsGeoJson);
  libh3._free(geoBoundary);
  return out;
}
function h3ToParent(h3Index, res) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return readH3Index(H3.h3ToParent(lower, upper, res));
}
function h3ToChildren(h3Index, res) {
  if (!h3IsValid(h3Index)) {
    return [];
  }
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  var maxCount = H3.maxH3ToChildrenSize(lower, upper, res);
  var hexagons = libh3._calloc(maxCount, SZ_H3INDEX);
  H3.h3ToChildren(lower, upper, res, hexagons);
  var out = readArrayOfHexagons(hexagons, maxCount);
  libh3._free(hexagons);
  return out;
}
function h3ToCenterChild(h3Index, res) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return readH3Index(H3.h3ToCenterChild(lower, upper, res));
}
function kRing(h3Index, ringSize) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  var maxCount = H3.maxKringSize(ringSize);
  var hexagons = libh3._calloc(maxCount, SZ_H3INDEX);
  H3.kRing(lower, upper, ringSize, hexagons);
  var out = readArrayOfHexagons(hexagons, maxCount);
  libh3._free(hexagons);
  return out;
}
function kRingDistances(h3Index, ringSize) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  var maxCount = H3.maxKringSize(ringSize);
  var kRings = libh3._calloc(maxCount, SZ_H3INDEX);
  var distances = libh3._calloc(maxCount, SZ_INT);
  H3.kRingDistances(lower, upper, ringSize, kRings, distances);
  var out = [];
  for (var i3 = 0; i3 < ringSize + 1; i3++) {
    out.push([]);
  }
  for (var i$1 = 0; i$1 < maxCount * 2; i$1 += 2) {
    var hexLower = libh3.getValue(kRings + SZ_INT * i$1, "i32");
    var hexUpper = libh3.getValue(kRings + SZ_INT * (i$1 + 1), "i32");
    var index = libh3.getValue(distances + SZ_INT * (i$1 / 2), "i32");
    if (hexLower !== 0 || hexUpper !== 0) {
      out[index].push(splitLongToh3Index(hexLower, hexUpper));
    }
  }
  libh3._free(kRings);
  libh3._free(distances);
  return out;
}
function hexRing(h3Index, ringSize) {
  var maxCount = ringSize === 0 ? 1 : 6 * ringSize;
  var hexagons = libh3._calloc(maxCount, SZ_H3INDEX);
  var retVal = H3.hexRing.apply(H3, h3IndexToSplitLong(h3Index).concat([ringSize], [hexagons]));
  if (retVal !== 0) {
    libh3._free(hexagons);
    throw new Error("Failed to get hexRing (encountered a pentagon?)");
  }
  var out = readArrayOfHexagons(hexagons, maxCount);
  libh3._free(hexagons);
  return out;
}
function polyfill(coordinates, res, isGeoJson) {
  validateRes(res);
  isGeoJson = Boolean(isGeoJson);
  if (coordinates.length === 0 || coordinates[0].length === 0) {
    return [];
  }
  if (typeof coordinates[0][0] === "number") {
    coordinates = [coordinates];
  }
  var geoPolygon = coordinatesToGeoPolygon(coordinates, isGeoJson);
  var arrayLen = H3.maxPolyfillSize(geoPolygon, res);
  var hexagons = libh3._calloc(arrayLen, SZ_H3INDEX);
  H3.polyfill(geoPolygon, res, hexagons);
  var out = readArrayOfHexagons(hexagons, arrayLen);
  libh3._free(hexagons);
  destroyGeoPolygon(geoPolygon);
  return out;
}
function h3SetToMultiPolygon(h3Indexes, formatAsGeoJson) {
  if (!h3Indexes || !h3Indexes.length) {
    return [];
  }
  var indexCount = h3Indexes.length;
  var set = libh3._calloc(indexCount, SZ_H3INDEX);
  storeArrayOfHexagons(set, h3Indexes);
  var polygon = libh3._calloc(SZ_LINKED_GEOPOLYGON);
  var originalPolygon = polygon;
  H3.h3SetToLinkedGeo(set, indexCount, polygon);
  var multiPolygon = readMultiPolygon(polygon, formatAsGeoJson);
  H3.destroyLinkedPolygon(originalPolygon);
  libh3._free(originalPolygon);
  libh3._free(set);
  return multiPolygon;
}
function compact(h3Set) {
  if (!h3Set || !h3Set.length) {
    return [];
  }
  var count = h3Set.length;
  var set = libh3._calloc(count, SZ_H3INDEX);
  storeArrayOfHexagons(set, h3Set);
  var compactedSet = libh3._calloc(count, SZ_H3INDEX);
  var retVal = H3.compact(set, compactedSet, count);
  if (retVal !== 0) {
    libh3._free(set);
    libh3._free(compactedSet);
    throw new Error("Failed to compact, malformed input data (duplicate hexagons?)");
  }
  var out = readArrayOfHexagons(compactedSet, count);
  libh3._free(set);
  libh3._free(compactedSet);
  return out;
}
function uncompact(compactedSet, res) {
  validateRes(res);
  if (!compactedSet || !compactedSet.length) {
    return [];
  }
  var count = compactedSet.length;
  var set = libh3._calloc(count, SZ_H3INDEX);
  storeArrayOfHexagons(set, compactedSet);
  var maxUncompactedNum = H3.maxUncompactSize(set, count, res);
  var uncompactedSet = libh3._calloc(maxUncompactedNum, SZ_H3INDEX);
  var retVal = H3.uncompact(set, count, uncompactedSet, maxUncompactedNum, res);
  if (retVal !== 0) {
    libh3._free(set);
    libh3._free(uncompactedSet);
    throw new Error("Failed to uncompact (bad resolution?)");
  }
  var out = readArrayOfHexagons(uncompactedSet, maxUncompactedNum);
  libh3._free(set);
  libh3._free(uncompactedSet);
  return out;
}
function h3IndexesAreNeighbors(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  return Boolean(H3.h3IndexesAreNeighbors(oLower, oUpper, dLower, dUpper));
}
function getH3UnidirectionalEdge(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  return readH3Index(H3.getH3UnidirectionalEdge(oLower, oUpper, dLower, dUpper));
}
function getOriginH3IndexFromUnidirectionalEdge(edgeIndex) {
  var ref = h3IndexToSplitLong(edgeIndex);
  var lower = ref[0];
  var upper = ref[1];
  return readH3Index(H3.getOriginH3IndexFromUnidirectionalEdge(lower, upper));
}
function getDestinationH3IndexFromUnidirectionalEdge(edgeIndex) {
  var ref = h3IndexToSplitLong(edgeIndex);
  var lower = ref[0];
  var upper = ref[1];
  return readH3Index(H3.getDestinationH3IndexFromUnidirectionalEdge(lower, upper));
}
function h3UnidirectionalEdgeIsValid(edgeIndex) {
  var ref = h3IndexToSplitLong(edgeIndex);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.h3UnidirectionalEdgeIsValid(lower, upper));
}
function getH3IndexesFromUnidirectionalEdge(edgeIndex) {
  var ref = h3IndexToSplitLong(edgeIndex);
  var lower = ref[0];
  var upper = ref[1];
  var count = 2;
  var hexagons = libh3._calloc(count, SZ_H3INDEX);
  H3.getH3IndexesFromUnidirectionalEdge(lower, upper, hexagons);
  var out = readArrayOfHexagons(hexagons, count);
  libh3._free(hexagons);
  return out;
}
function getH3UnidirectionalEdgesFromHexagon(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  var count = 6;
  var edges = libh3._calloc(count, SZ_H3INDEX);
  H3.getH3UnidirectionalEdgesFromHexagon(lower, upper, edges);
  var out = readArrayOfHexagons(edges, count);
  libh3._free(edges);
  return out;
}
function getH3UnidirectionalEdgeBoundary(edgeIndex, formatAsGeoJson) {
  var geoBoundary = libh3._malloc(SZ_GEOBOUNDARY);
  var ref = h3IndexToSplitLong(edgeIndex);
  var lower = ref[0];
  var upper = ref[1];
  H3.getH3UnidirectionalEdgeBoundary(lower, upper, geoBoundary);
  var out = readGeoBoundary(geoBoundary, formatAsGeoJson);
  libh3._free(geoBoundary);
  return out;
}
function h3Distance(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  return H3.h3Distance(oLower, oUpper, dLower, dUpper);
}
function h3Line(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  var count = H3.h3LineSize(oLower, oUpper, dLower, dUpper);
  if (count < 0) {
    throw new Error("Line cannot be calculated");
  }
  var hexagons = libh3._calloc(count, SZ_H3INDEX);
  H3.h3Line(oLower, oUpper, dLower, dUpper, hexagons);
  var out = readArrayOfHexagons(hexagons, count);
  libh3._free(hexagons);
  return out;
}
function experimentalH3ToLocalIj(origin, destination) {
  var ij = libh3._malloc(SZ_COORDIJ);
  var retVal = H3.experimentalH3ToLocalIj.apply(H3, h3IndexToSplitLong(origin).concat(h3IndexToSplitLong(destination), [ij]));
  var coords = readCoordIJ(ij);
  libh3._free(ij);
  switch (retVal) {
    case 0:
      return coords;
    case 1:
      throw new Error("Incompatible origin and index.");
    case 2:
    default:
      throw new Error("Local IJ coordinates undefined for this origin and index pair. The index may be too far from the origin.");
    case 3:
    case 4:
    case 5:
      throw new Error("Encountered possible pentagon distortion");
  }
}
function experimentalLocalIjToH3(origin, coords) {
  if (!coords || typeof coords.i !== "number" || typeof coords.j !== "number") {
    throw new Error("Coordinates must be provided as an {i, j} object");
  }
  var ij = libh3._malloc(SZ_COORDIJ);
  var out = libh3._malloc(SZ_H3INDEX);
  storeCoordIJ(ij, coords);
  var retVal = H3.experimentalLocalIjToH3.apply(H3, h3IndexToSplitLong(origin).concat([ij], [out]));
  var h3Index = readH3IndexFromPointer(out);
  libh3._free(ij);
  libh3._free(out);
  if (retVal !== 0) {
    throw new Error("Index not defined for this origin and IJ coordinates pair. IJ coordinates may be too far from origin, or a pentagon distortion was encountered.");
  }
  return h3Index;
}
function pointDist(latlng1, latlng2, unit) {
  var coord1 = storeGeoCoord(latlng1[0], latlng1[1]);
  var coord2 = storeGeoCoord(latlng2[0], latlng2[1]);
  var result;
  switch (unit) {
    case UNITS.m:
      result = H3.pointDistM(coord1, coord2);
      break;
    case UNITS.km:
      result = H3.pointDistKm(coord1, coord2);
      break;
    case UNITS.rads:
      result = H3.pointDistRads(coord1, coord2);
      break;
    default:
      result = null;
  }
  libh3._free(coord1);
  libh3._free(coord2);
  if (result === null) {
    throw new Error("Unknown unit: " + unit);
  }
  return result;
}
function cellArea(h3Index, unit) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  switch (unit) {
    case UNITS.m2:
      return H3.cellAreaM2(lower, upper);
    case UNITS.km2:
      return H3.cellAreaKm2(lower, upper);
    case UNITS.rads2:
      return H3.cellAreaRads2(lower, upper);
    default:
      throw new Error("Unknown unit: " + unit);
  }
}
function exactEdgeLength(edge, unit) {
  var ref = h3IndexToSplitLong(edge);
  var lower = ref[0];
  var upper = ref[1];
  switch (unit) {
    case UNITS.m:
      return H3.exactEdgeLengthM(lower, upper);
    case UNITS.km:
      return H3.exactEdgeLengthKm(lower, upper);
    case UNITS.rads:
      return H3.exactEdgeLengthRads(lower, upper);
    default:
      throw new Error("Unknown unit: " + unit);
  }
}
function hexArea(res, unit) {
  validateRes(res);
  switch (unit) {
    case UNITS.m2:
      return H3.hexAreaM2(res);
    case UNITS.km2:
      return H3.hexAreaKm2(res);
    default:
      throw new Error("Unknown unit: " + unit);
  }
}
function edgeLength(res, unit) {
  validateRes(res);
  switch (unit) {
    case UNITS.m:
      return H3.edgeLengthM(res);
    case UNITS.km:
      return H3.edgeLengthKm(res);
    default:
      throw new Error("Unknown unit: " + unit);
  }
}
function numHexagons(res) {
  validateRes(res);
  var ref = readLong(H3.numHexagons(res));
  var lower = ref[0];
  var upper = ref[1];
  if (!upper) {
    return lower;
  }
  return upper * Math.pow(2, 32) + lower;
}
function getRes0Indexes() {
  var count = H3.res0IndexCount();
  var hexagons = libh3._malloc(SZ_H3INDEX * count);
  H3.getRes0Indexes(hexagons);
  var out = readArrayOfHexagons(hexagons, count);
  libh3._free(hexagons);
  return out;
}
function getPentagonIndexes(res) {
  validateRes(res);
  var count = H3.pentagonIndexCount();
  var hexagons = libh3._malloc(SZ_H3INDEX * count);
  H3.getPentagonIndexes(res, hexagons);
  var out = readArrayOfHexagons(hexagons, count);
  libh3._free(hexagons);
  return out;
}
function degsToRads(deg) {
  return deg * Math.PI / 180;
}
function radsToDegs(rad) {
  return rad * 180 / Math.PI;
}
var libh3, NUMBER, BOOLEAN, H3_LOWER, H3_UPPER, RESOLUTION, POINTER, BINDINGS, H3, BASE_16, SZ_INT, SZ_PTR, SZ_DBL, SZ_H3INDEX, SZ_GEOCOORD, SZ_GEOBOUNDARY, SZ_GEOPOLYGON, SZ_GEOFENCE, SZ_LINKED_GEOPOLYGON, SZ_COORDIJ, UNITS, INVALID_HEXIDECIMAL_CHAR;
var init_h3_js_es = __esm({
  "node_modules/h3-js/dist/browser/h3-js.es.js"() {
    libh3 = function(libh32) {
      libh32 = libh32 || {};
      var Module = typeof libh32 !== "undefined" ? libh32 : {};
      var moduleOverrides = {};
      var key;
      for (key in Module) {
        if (Module.hasOwnProperty(key)) {
          moduleOverrides[key] = Module[key];
        }
      }
      var arguments_ = [];
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var readAsync;
      {
        if (document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        readAsync = function readAsync2(url, onload, onerror) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function xhr_onload() {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }
            var data = tryParseAsDataURI(url);
            if (data) {
              onload(data.buffer);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.warn.bind(console);
      for (key in moduleOverrides) {
        if (moduleOverrides.hasOwnProperty(key)) {
          Module[key] = moduleOverrides[key];
        }
      }
      moduleOverrides = null;
      if (Module["arguments"]) {
        arguments_ = Module["arguments"];
      }
      var tempRet0 = 0;
      var setTempRet0 = function(value) {
        tempRet0 = value;
      };
      var getTempRet0 = function() {
        return tempRet0;
      };
      var GLOBAL_BASE = 8;
      function setValue(ptr, value, type, noSafe) {
        type = type || "i8";
        if (type.charAt(type.length - 1) === "*") {
          type = "i32";
        }
        switch (type) {
          case "i1":
            HEAP8[ptr >> 0] = value;
            break;
          case "i8":
            HEAP8[ptr >> 0] = value;
            break;
          case "i16":
            HEAP16[ptr >> 1] = value;
            break;
          case "i32":
            HEAP32[ptr >> 2] = value;
            break;
          case "i64":
            tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
            break;
          case "float":
            HEAPF32[ptr >> 2] = value;
            break;
          case "double":
            HEAPF64[ptr >> 3] = value;
            break;
          default:
            abort("invalid type for setValue: " + type);
        }
      }
      function getValue(ptr, type, noSafe) {
        type = type || "i8";
        if (type.charAt(type.length - 1) === "*") {
          type = "i32";
        }
        switch (type) {
          case "i1":
            return HEAP8[ptr >> 0];
          case "i8":
            return HEAP8[ptr >> 0];
          case "i16":
            return HEAP16[ptr >> 1];
          case "i32":
            return HEAP32[ptr >> 2];
          case "i64":
            return HEAP32[ptr >> 2];
          case "float":
            return HEAPF32[ptr >> 2];
          case "double":
            return HEAPF64[ptr >> 3];
          default:
            abort("invalid type for getValue: " + type);
        }
        return null;
      }
      var ABORT = false;
      function assert8(condition, text) {
        if (!condition) {
          abort("Assertion failed: " + text);
        }
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert8(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {
          "string": function(str) {
            var ret2 = 0;
            if (str !== null && str !== void 0 && str !== 0) {
              var len = (str.length << 2) + 1;
              ret2 = stackAlloc(len);
              stringToUTF8(str, ret2, len);
            }
            return ret2;
          },
          "array": function(arr) {
            var ret2 = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret2);
            return ret2;
          }
        };
        function convertReturnValue(ret2) {
          if (returnType === "string") {
            return UTF8ToString(ret2);
          }
          if (returnType === "boolean") {
            return Boolean(ret2);
          }
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack2 = 0;
        if (args) {
          for (var i3 = 0; i3 < args.length; i3++) {
            var converter = toC[argTypes[i3]];
            if (converter) {
              if (stack2 === 0) {
                stack2 = stackSave();
              }
              cArgs[i3] = converter(args[i3]);
            } else {
              cArgs[i3] = args[i3];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        ret = convertReturnValue(ret);
        if (stack2 !== 0) {
          stackRestore(stack2);
        }
        return ret;
      }
      function cwrap(ident, returnType, argTypes, opts) {
        argTypes = argTypes || [];
        var numericArgs = argTypes.every(function(type) {
          return type === "number";
        });
        var numericRet = returnType !== "string";
        if (numericRet && numericArgs && !opts) {
          return getCFunc(ident);
        }
        return function() {
          return ccall(ident, returnType, argTypes, arguments, opts);
        };
      }
      var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (u8Array[endPtr] && !(endPtr >= endIdx)) {
          ++endPtr;
        }
        if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
          return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
        } else {
          var str = "";
          while (idx < endPtr) {
            var u0 = u8Array[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = u8Array[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = u8Array[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0)) {
          return 0;
        }
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i3 = 0; i3 < str.length; ++i3) {
          var u = str.charCodeAt(i3);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i3);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx) {
              break;
            }
            outU8Array[outIdx++] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx) {
              break;
            }
            outU8Array[outIdx++] = 192 | u >> 6;
            outU8Array[outIdx++] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx) {
              break;
            }
            outU8Array[outIdx++] = 224 | u >> 12;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx) {
              break;
            }
            outU8Array[outIdx++] = 240 | u >> 18;
            outU8Array[outIdx++] = 128 | u >> 12 & 63;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63;
          }
        }
        outU8Array[outIdx] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
      function writeArrayToMemory(array, buffer2) {
        HEAP8.set(array, buffer2);
      }
      function alignUp(x2, multiple) {
        if (x2 % multiple > 0) {
          x2 += multiple - x2 % multiple;
        }
        return x2;
      }
      var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        Module["HEAP8"] = HEAP8 = new Int8Array(buf);
        Module["HEAP16"] = HEAP16 = new Int16Array(buf);
        Module["HEAP32"] = HEAP32 = new Int32Array(buf);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
      }
      var DYNAMIC_BASE = 5266928, DYNAMICTOP_PTR = 24016;
      var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 33554432;
      if (Module["buffer"]) {
        buffer = Module["buffer"];
      } else {
        buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
      }
      INITIAL_TOTAL_MEMORY = buffer.byteLength;
      updateGlobalBufferAndViews(buffer);
      HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          var callback = callbacks.shift();
          if (typeof callback == "function") {
            callback();
            continue;
          }
          var func = callback.func;
          if (typeof func === "number") {
            if (callback.arg === void 0) {
              Module["dynCall_v"](func);
            } else {
              Module["dynCall_vi"](func, callback.arg);
            }
          } else {
            func(callback.arg === void 0 ? null : callback.arg);
          }
        }
      }
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATPOSTRUN__ = [];
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function") {
            Module["preRun"] = [Module["preRun"]];
          }
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function") {
            Module["postRun"] = [Module["postRun"]];
          }
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      var Math_abs = Math.abs;
      var Math_ceil = Math.ceil;
      var Math_floor = Math.floor;
      var Math_min = Math.min;
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      var memoryInitializer = null;
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
      }
      var tempDouble;
      var tempI64;
      memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAABAAAAAMAAAAGAAAABQAAAAIAAAAAAAAAAgAAAAMAAAABAAAABAAAAAYAAAAAAAAABQAAAAMAAAAGAAAABAAAAAUAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAABAAAABQAAAAIAAAAAAAAAAQAAAAMAAAAGAAAABAAAAAYAAAAAAAAABQAAAAIAAAABAAAABAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAgAAAAMAAAAAAAAAAAAAAAIAAAAAAAAAAQAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABgAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAAAAAAAAAAAAAAAAAIAAAAAAAAABgAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAAAAAACAAAAAwAAAAQAAAAFAAAABgAAAAAAAAABAAAAAwAAAAQAAAAFAAAABgAAAAAAAAABAAAAAgAAAAQAAAAFAAAABgAAAAAAAAABAAAAAgAAAAMAAAAFAAAABgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAAAAAAABgAAAAAAAAADAAAAAgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAUAAAAEAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAEAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAUAAAACAAAABAAAAAMAAAAIAAAAAQAAAAcAAAAGAAAACQAAAAAAAAADAAAAAgAAAAIAAAAGAAAACgAAAAsAAAAAAAAAAQAAAAUAAAADAAAADQAAAAEAAAAHAAAABAAAAAwAAAAAAAAABAAAAH8AAAAPAAAACAAAAAMAAAAAAAAADAAAAAUAAAACAAAAEgAAAAoAAAAIAAAAAAAAABAAAAAGAAAADgAAAAsAAAARAAAAAQAAAAkAAAACAAAABwAAABUAAAAJAAAAEwAAAAMAAAANAAAAAQAAAAgAAAAFAAAAFgAAABAAAAAEAAAAAAAAAA8AAAAJAAAAEwAAAA4AAAAUAAAAAQAAAAcAAAAGAAAACgAAAAsAAAAYAAAAFwAAAAUAAAACAAAAEgAAAAsAAAARAAAAFwAAABkAAAACAAAABgAAAAoAAAAMAAAAHAAAAA0AAAAaAAAABAAAAA8AAAADAAAADQAAABoAAAAVAAAAHQAAAAMAAAAMAAAABwAAAA4AAAB/AAAAEQAAABsAAAAJAAAAFAAAAAYAAAAPAAAAFgAAABwAAAAfAAAABAAAAAgAAAAMAAAAEAAAABIAAAAhAAAAHgAAAAgAAAAFAAAAFgAAABEAAAALAAAADgAAAAYAAAAjAAAAGQAAABsAAAASAAAAGAAAAB4AAAAgAAAABQAAAAoAAAAQAAAAEwAAACIAAAAUAAAAJAAAAAcAAAAVAAAACQAAABQAAAAOAAAAEwAAAAkAAAAoAAAAGwAAACQAAAAVAAAAJgAAABMAAAAiAAAADQAAAB0AAAAHAAAAFgAAABAAAAApAAAAIQAAAA8AAAAIAAAAHwAAABcAAAAYAAAACwAAAAoAAAAnAAAAJQAAABkAAAAYAAAAfwAAACAAAAAlAAAACgAAABcAAAASAAAAGQAAABcAAAARAAAACwAAAC0AAAAnAAAAIwAAABoAAAAqAAAAHQAAACsAAAAMAAAAHAAAAA0AAAAbAAAAKAAAACMAAAAuAAAADgAAABQAAAARAAAAHAAAAB8AAAAqAAAALAAAAAwAAAAPAAAAGgAAAB0AAAArAAAAJgAAAC8AAAANAAAAGgAAABUAAAAeAAAAIAAAADAAAAAyAAAAEAAAABIAAAAhAAAAHwAAACkAAAAsAAAANQAAAA8AAAAWAAAAHAAAACAAAAAeAAAAGAAAABIAAAA0AAAAMgAAACUAAAAhAAAAHgAAADEAAAAwAAAAFgAAABAAAAApAAAAIgAAABMAAAAmAAAAFQAAADYAAAAkAAAAMwAAACMAAAAuAAAALQAAADgAAAARAAAAGwAAABkAAAAkAAAAFAAAACIAAAATAAAANwAAACgAAAA2AAAAJQAAACcAAAA0AAAAOQAAABgAAAAXAAAAIAAAACYAAAB/AAAAIgAAADMAAAAdAAAALwAAABUAAAAnAAAAJQAAABkAAAAXAAAAOwAAADkAAAAtAAAAKAAAABsAAAAkAAAAFAAAADwAAAAuAAAANwAAACkAAAAxAAAANQAAAD0AAAAWAAAAIQAAAB8AAAAqAAAAOgAAACsAAAA+AAAAHAAAACwAAAAaAAAAKwAAAD4AAAAvAAAAQAAAABoAAAAqAAAAHQAAACwAAAA1AAAAOgAAAEEAAAAcAAAAHwAAACoAAAAtAAAAJwAAACMAAAAZAAAAPwAAADsAAAA4AAAALgAAADwAAAA4AAAARAAAABsAAAAoAAAAIwAAAC8AAAAmAAAAKwAAAB0AAABFAAAAMwAAAEAAAAAwAAAAMQAAAB4AAAAhAAAAQwAAAEIAAAAyAAAAMQAAAH8AAAA9AAAAQgAAACEAAAAwAAAAKQAAADIAAAAwAAAAIAAAAB4AAABGAAAAQwAAADQAAAAzAAAARQAAADYAAABHAAAAJgAAAC8AAAAiAAAANAAAADkAAABGAAAASgAAACAAAAAlAAAAMgAAADUAAAA9AAAAQQAAAEsAAAAfAAAAKQAAACwAAAA2AAAARwAAADcAAABJAAAAIgAAADMAAAAkAAAANwAAACgAAAA2AAAAJAAAAEgAAAA8AAAASQAAADgAAABEAAAAPwAAAE0AAAAjAAAALgAAAC0AAAA5AAAAOwAAAEoAAABOAAAAJQAAACcAAAA0AAAAOgAAAH8AAAA+AAAATAAAACwAAABBAAAAKgAAADsAAAA/AAAATgAAAE8AAAAnAAAALQAAADkAAAA8AAAASAAAAEQAAABQAAAAKAAAADcAAAAuAAAAPQAAADUAAAAxAAAAKQAAAFEAAABLAAAAQgAAAD4AAAArAAAAOgAAACoAAABSAAAAQAAAAEwAAAA/AAAAfwAAADgAAAAtAAAATwAAADsAAABNAAAAQAAAAC8AAAA+AAAAKwAAAFQAAABFAAAAUgAAAEEAAAA6AAAANQAAACwAAABWAAAATAAAAEsAAABCAAAAQwAAAFEAAABVAAAAMQAAADAAAAA9AAAAQwAAAEIAAAAyAAAAMAAAAFcAAABVAAAARgAAAEQAAAA4AAAAPAAAAC4AAABaAAAATQAAAFAAAABFAAAAMwAAAEAAAAAvAAAAWQAAAEcAAABUAAAARgAAAEMAAAA0AAAAMgAAAFMAAABXAAAASgAAAEcAAABZAAAASQAAAFsAAAAzAAAARQAAADYAAABIAAAAfwAAAEkAAAA3AAAAUAAAADwAAABYAAAASQAAAFsAAABIAAAAWAAAADYAAABHAAAANwAAAEoAAABOAAAAUwAAAFwAAAA0AAAAOQAAAEYAAABLAAAAQQAAAD0AAAA1AAAAXgAAAFYAAABRAAAATAAAAFYAAABSAAAAYAAAADoAAABBAAAAPgAAAE0AAAA/AAAARAAAADgAAABdAAAATwAAAFoAAABOAAAASgAAADsAAAA5AAAAXwAAAFwAAABPAAAATwAAAE4AAAA/AAAAOwAAAF0AAABfAAAATQAAAFAAAABEAAAASAAAADwAAABjAAAAWgAAAFgAAABRAAAAVQAAAF4AAABlAAAAPQAAAEIAAABLAAAAUgAAAGAAAABUAAAAYgAAAD4AAABMAAAAQAAAAFMAAAB/AAAASgAAAEYAAABkAAAAVwAAAFwAAABUAAAARQAAAFIAAABAAAAAYQAAAFkAAABiAAAAVQAAAFcAAABlAAAAZgAAAEIAAABDAAAAUQAAAFYAAABMAAAASwAAAEEAAABoAAAAYAAAAF4AAABXAAAAUwAAAGYAAABkAAAAQwAAAEYAAABVAAAAWAAAAEgAAABbAAAASQAAAGMAAABQAAAAaQAAAFkAAABhAAAAWwAAAGcAAABFAAAAVAAAAEcAAABaAAAATQAAAFAAAABEAAAAagAAAF0AAABjAAAAWwAAAEkAAABZAAAARwAAAGkAAABYAAAAZwAAAFwAAABTAAAATgAAAEoAAABsAAAAZAAAAF8AAABdAAAATwAAAFoAAABNAAAAbQAAAF8AAABqAAAAXgAAAFYAAABRAAAASwAAAGsAAABoAAAAZQAAAF8AAABcAAAATwAAAE4AAABtAAAAbAAAAF0AAABgAAAAaAAAAGIAAABuAAAATAAAAFYAAABSAAAAYQAAAH8AAABiAAAAVAAAAGcAAABZAAAAbwAAAGIAAABuAAAAYQAAAG8AAABSAAAAYAAAAFQAAABjAAAAUAAAAGkAAABYAAAAagAAAFoAAABxAAAAZAAAAGYAAABTAAAAVwAAAGwAAAByAAAAXAAAAGUAAABmAAAAawAAAHAAAABRAAAAVQAAAF4AAABmAAAAZQAAAFcAAABVAAAAcgAAAHAAAABkAAAAZwAAAFsAAABhAAAAWQAAAHQAAABpAAAAbwAAAGgAAABrAAAAbgAAAHMAAABWAAAAXgAAAGAAAABpAAAAWAAAAGcAAABbAAAAcQAAAGMAAAB0AAAAagAAAF0AAABjAAAAWgAAAHUAAABtAAAAcQAAAGsAAAB/AAAAZQAAAF4AAABzAAAAaAAAAHAAAABsAAAAZAAAAF8AAABcAAAAdgAAAHIAAABtAAAAbQAAAGwAAABdAAAAXwAAAHUAAAB2AAAAagAAAG4AAABiAAAAaAAAAGAAAAB3AAAAbwAAAHMAAABvAAAAYQAAAG4AAABiAAAAdAAAAGcAAAB3AAAAcAAAAGsAAABmAAAAZQAAAHgAAABzAAAAcgAAAHEAAABjAAAAdAAAAGkAAAB1AAAAagAAAHkAAAByAAAAcAAAAGQAAABmAAAAdgAAAHgAAABsAAAAcwAAAG4AAABrAAAAaAAAAHgAAAB3AAAAcAAAAHQAAABnAAAAdwAAAG8AAABxAAAAaQAAAHkAAAB1AAAAfwAAAG0AAAB2AAAAcQAAAHkAAABqAAAAdgAAAHgAAABsAAAAcgAAAHUAAAB5AAAAbQAAAHcAAABvAAAAcwAAAG4AAAB5AAAAdAAAAHgAAAB4AAAAcwAAAHIAAABwAAAAeQAAAHcAAAB2AAAAeQAAAHQAAAB4AAAAdwAAAHUAAABxAAAAdgAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAQAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAADAAAABQAAAAEAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAgAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAABQAAAAUAAAAAAAAAAAAAAP////8BAAAAAAAAAAMAAAAEAAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAQAAAP//////////AQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAIAAAAAAAAAAAAAAAEAAAACAAAABgAAAAQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAoAAAACAAAAAAAAAAAAAAABAAAAAQAAAAUAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAAAAAAAAAAAAAEAAAADAAAABwAAAAYAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAHAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAJAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAAAAAAAAAAAAQAAAAQAAAAIAAAACgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAAAAAAAAAAABAAAACwAAAA8AAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA4AAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAgAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAAAAAAAAAAABAAAADAAAABAAAAAMAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAEAAAAKAAAAEwAAAAgAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAJAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAgAAAAAAAAAAAAAAAQAAAA0AAAARAAAADQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAIAAAAAAAAAAAAAAAEAAAAOAAAAEgAAAA8AAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAAAAAABAAAA//////////8TAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABIAAAAAAAAAGAAAAAAAAAAhAAAAAAAAAB4AAAAAAAAAIAAAAAMAAAAxAAAAAQAAADAAAAADAAAAMgAAAAMAAAAIAAAAAAAAAAUAAAAFAAAACgAAAAUAAAAWAAAAAAAAABAAAAAAAAAAEgAAAAAAAAApAAAAAQAAACEAAAAAAAAAHgAAAAAAAAAEAAAAAAAAAAAAAAAFAAAAAgAAAAUAAAAPAAAAAQAAAAgAAAAAAAAABQAAAAUAAAAfAAAAAQAAABYAAAAAAAAAEAAAAAAAAAACAAAAAAAAAAYAAAAAAAAADgAAAAAAAAAKAAAAAAAAAAsAAAAAAAAAEQAAAAMAAAAYAAAAAQAAABcAAAADAAAAGQAAAAMAAAAAAAAAAAAAAAEAAAAFAAAACQAAAAUAAAAFAAAAAAAAAAIAAAAAAAAABgAAAAAAAAASAAAAAQAAAAoAAAAAAAAACwAAAAAAAAAEAAAAAQAAAAMAAAAFAAAABwAAAAUAAAAIAAAAAQAAAAAAAAAAAAAAAQAAAAUAAAAQAAAAAQAAAAUAAAAAAAAAAgAAAAAAAAAHAAAAAAAAABUAAAAAAAAAJgAAAAAAAAAJAAAAAAAAABMAAAAAAAAAIgAAAAMAAAAOAAAAAQAAABQAAAADAAAAJAAAAAMAAAADAAAAAAAAAA0AAAAFAAAAHQAAAAUAAAABAAAAAAAAAAcAAAAAAAAAFQAAAAAAAAAGAAAAAQAAAAkAAAAAAAAAEwAAAAAAAAAEAAAAAgAAAAwAAAAFAAAAGgAAAAUAAAAAAAAAAQAAAAMAAAAAAAAADQAAAAUAAAACAAAAAQAAAAEAAAAAAAAABwAAAAAAAAAaAAAAAAAAACoAAAAAAAAAOgAAAAAAAAAdAAAAAAAAACsAAAAAAAAAPgAAAAMAAAAmAAAAAQAAAC8AAAADAAAAQAAAAAMAAAAMAAAAAAAAABwAAAAFAAAALAAAAAUAAAANAAAAAAAAABoAAAAAAAAAKgAAAAAAAAAVAAAAAQAAAB0AAAAAAAAAKwAAAAAAAAAEAAAAAwAAAA8AAAAFAAAAHwAAAAUAAAADAAAAAQAAAAwAAAAAAAAAHAAAAAUAAAAHAAAAAQAAAA0AAAAAAAAAGgAAAAAAAAAfAAAAAAAAACkAAAAAAAAAMQAAAAAAAAAsAAAAAAAAADUAAAAAAAAAPQAAAAMAAAA6AAAAAQAAAEEAAAADAAAASwAAAAMAAAAPAAAAAAAAABYAAAAFAAAAIQAAAAUAAAAcAAAAAAAAAB8AAAAAAAAAKQAAAAAAAAAqAAAAAQAAACwAAAAAAAAANQAAAAAAAAAEAAAABAAAAAgAAAAFAAAAEAAAAAUAAAAMAAAAAQAAAA8AAAAAAAAAFgAAAAUAAAAaAAAAAQAAABwAAAAAAAAAHwAAAAAAAAAyAAAAAAAAADAAAAAAAAAAMQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAIQAAAAMAAAAYAAAAAwAAABIAAAADAAAAEAAAAAMAAABGAAAAAAAAAEMAAAAAAAAAQgAAAAMAAAA0AAAAAwAAADIAAAAAAAAAMAAAAAAAAAAlAAAAAwAAACAAAAAAAAAAHgAAAAMAAABTAAAAAAAAAFcAAAADAAAAVQAAAAMAAABKAAAAAwAAAEYAAAAAAAAAQwAAAAAAAAA5AAAAAQAAADQAAAADAAAAMgAAAAAAAAAZAAAAAAAAABcAAAAAAAAAGAAAAAMAAAARAAAAAAAAAAsAAAADAAAACgAAAAMAAAAOAAAAAwAAAAYAAAADAAAAAgAAAAMAAAAtAAAAAAAAACcAAAAAAAAAJQAAAAMAAAAjAAAAAwAAABkAAAAAAAAAFwAAAAAAAAAbAAAAAwAAABEAAAAAAAAACwAAAAMAAAA/AAAAAAAAADsAAAADAAAAOQAAAAMAAAA4AAAAAwAAAC0AAAAAAAAAJwAAAAAAAAAuAAAAAwAAACMAAAADAAAAGQAAAAAAAAAkAAAAAAAAABQAAAAAAAAADgAAAAMAAAAiAAAAAAAAABMAAAADAAAACQAAAAMAAAAmAAAAAwAAABUAAAADAAAABwAAAAMAAAA3AAAAAAAAACgAAAAAAAAAGwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAFAAAAAAAAAAzAAAAAwAAACIAAAAAAAAAEwAAAAMAAABIAAAAAAAAADwAAAADAAAALgAAAAMAAABJAAAAAwAAADcAAAAAAAAAKAAAAAAAAABHAAAAAwAAADYAAAADAAAAJAAAAAAAAABAAAAAAAAAAC8AAAAAAAAAJgAAAAMAAAA+AAAAAAAAACsAAAADAAAAHQAAAAMAAAA6AAAAAwAAACoAAAADAAAAGgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAMwAAAAMAAABSAAAAAwAAAEAAAAAAAAAALwAAAAAAAABMAAAAAwAAAD4AAAAAAAAAKwAAAAMAAABhAAAAAAAAAFkAAAADAAAARwAAAAMAAABiAAAAAwAAAFQAAAAAAAAARQAAAAAAAABgAAAAAwAAAFIAAAADAAAAQAAAAAAAAABLAAAAAAAAAEEAAAAAAAAAOgAAAAMAAAA9AAAAAAAAADUAAAADAAAALAAAAAMAAAAxAAAAAwAAACkAAAADAAAAHwAAAAMAAABeAAAAAAAAAFYAAAAAAAAATAAAAAMAAABRAAAAAwAAAEsAAAAAAAAAQQAAAAAAAABCAAAAAwAAAD0AAAAAAAAANQAAAAMAAABrAAAAAAAAAGgAAAADAAAAYAAAAAMAAABlAAAAAwAAAF4AAAAAAAAAVgAAAAAAAABVAAAAAwAAAFEAAAADAAAASwAAAAAAAAA5AAAAAAAAADsAAAAAAAAAPwAAAAMAAABKAAAAAAAAAE4AAAADAAAATwAAAAMAAABTAAAAAwAAAFwAAAADAAAAXwAAAAMAAAAlAAAAAAAAACcAAAADAAAALQAAAAMAAAA0AAAAAAAAADkAAAAAAAAAOwAAAAAAAABGAAAAAwAAAEoAAAAAAAAATgAAAAMAAAAYAAAAAAAAABcAAAADAAAAGQAAAAMAAAAgAAAAAwAAACUAAAAAAAAAJwAAAAMAAAAyAAAAAwAAADQAAAAAAAAAOQAAAAAAAAAuAAAAAAAAADwAAAAAAAAASAAAAAMAAAA4AAAAAAAAAEQAAAADAAAAUAAAAAMAAAA/AAAAAwAAAE0AAAADAAAAWgAAAAMAAAAbAAAAAAAAACgAAAADAAAANwAAAAMAAAAjAAAAAAAAAC4AAAAAAAAAPAAAAAAAAAAtAAAAAwAAADgAAAAAAAAARAAAAAMAAAAOAAAAAAAAABQAAAADAAAAJAAAAAMAAAARAAAAAwAAABsAAAAAAAAAKAAAAAMAAAAZAAAAAwAAACMAAAAAAAAALgAAAAAAAABHAAAAAAAAAFkAAAAAAAAAYQAAAAMAAABJAAAAAAAAAFsAAAADAAAAZwAAAAMAAABIAAAAAwAAAFgAAAADAAAAaQAAAAMAAAAzAAAAAAAAAEUAAAADAAAAVAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAWQAAAAAAAAA3AAAAAwAAAEkAAAAAAAAAWwAAAAMAAAAmAAAAAAAAAC8AAAADAAAAQAAAAAMAAAAiAAAAAwAAADMAAAAAAAAARQAAAAMAAAAkAAAAAwAAADYAAAAAAAAARwAAAAAAAABgAAAAAAAAAGgAAAAAAAAAawAAAAMAAABiAAAAAAAAAG4AAAADAAAAcwAAAAMAAABhAAAAAwAAAG8AAAADAAAAdwAAAAMAAABMAAAAAAAAAFYAAAADAAAAXgAAAAMAAABSAAAAAAAAAGAAAAAAAAAAaAAAAAAAAABUAAAAAwAAAGIAAAAAAAAAbgAAAAMAAAA6AAAAAAAAAEEAAAADAAAASwAAAAMAAAA+AAAAAwAAAEwAAAAAAAAAVgAAAAMAAABAAAAAAwAAAFIAAAAAAAAAYAAAAAAAAABVAAAAAAAAAFcAAAAAAAAAUwAAAAMAAABlAAAAAAAAAGYAAAADAAAAZAAAAAMAAABrAAAAAwAAAHAAAAADAAAAcgAAAAMAAABCAAAAAAAAAEMAAAADAAAARgAAAAMAAABRAAAAAAAAAFUAAAAAAAAAVwAAAAAAAABeAAAAAwAAAGUAAAAAAAAAZgAAAAMAAAAxAAAAAAAAADAAAAADAAAAMgAAAAMAAAA9AAAAAwAAAEIAAAAAAAAAQwAAAAMAAABLAAAAAwAAAFEAAAAAAAAAVQAAAAAAAABfAAAAAAAAAFwAAAAAAAAAUwAAAAAAAABPAAAAAAAAAE4AAAAAAAAASgAAAAMAAAA/AAAAAQAAADsAAAADAAAAOQAAAAMAAABtAAAAAAAAAGwAAAAAAAAAZAAAAAUAAABdAAAAAQAAAF8AAAAAAAAAXAAAAAAAAABNAAAAAQAAAE8AAAAAAAAATgAAAAAAAAB1AAAABAAAAHYAAAAFAAAAcgAAAAUAAABqAAAAAQAAAG0AAAAAAAAAbAAAAAAAAABaAAAAAQAAAF0AAAABAAAAXwAAAAAAAABaAAAAAAAAAE0AAAAAAAAAPwAAAAAAAABQAAAAAAAAAEQAAAAAAAAAOAAAAAMAAABIAAAAAQAAADwAAAADAAAALgAAAAMAAABqAAAAAAAAAF0AAAAAAAAATwAAAAUAAABjAAAAAQAAAFoAAAAAAAAATQAAAAAAAABYAAAAAQAAAFAAAAAAAAAARAAAAAAAAAB1AAAAAwAAAG0AAAAFAAAAXwAAAAUAAABxAAAAAQAAAGoAAAAAAAAAXQAAAAAAAABpAAAAAQAAAGMAAAABAAAAWgAAAAAAAABpAAAAAAAAAFgAAAAAAAAASAAAAAAAAABnAAAAAAAAAFsAAAAAAAAASQAAAAMAAABhAAAAAQAAAFkAAAADAAAARwAAAAMAAABxAAAAAAAAAGMAAAAAAAAAUAAAAAUAAAB0AAAAAQAAAGkAAAAAAAAAWAAAAAAAAABvAAAAAQAAAGcAAAAAAAAAWwAAAAAAAAB1AAAAAgAAAGoAAAAFAAAAWgAAAAUAAAB5AAAAAQAAAHEAAAAAAAAAYwAAAAAAAAB3AAAAAQAAAHQAAAABAAAAaQAAAAAAAAB3AAAAAAAAAG8AAAAAAAAAYQAAAAAAAABzAAAAAAAAAG4AAAAAAAAAYgAAAAMAAABrAAAAAQAAAGgAAAADAAAAYAAAAAMAAAB5AAAAAAAAAHQAAAAAAAAAZwAAAAUAAAB4AAAAAQAAAHcAAAAAAAAAbwAAAAAAAABwAAAAAQAAAHMAAAAAAAAAbgAAAAAAAAB1AAAAAQAAAHEAAAAFAAAAaQAAAAUAAAB2AAAAAQAAAHkAAAAAAAAAdAAAAAAAAAByAAAAAQAAAHgAAAABAAAAdwAAAAAAAAByAAAAAAAAAHAAAAAAAAAAawAAAAAAAABkAAAAAAAAAGYAAAAAAAAAZQAAAAMAAABTAAAAAQAAAFcAAAADAAAAVQAAAAMAAAB2AAAAAAAAAHgAAAAAAAAAcwAAAAUAAABsAAAAAQAAAHIAAAAAAAAAcAAAAAAAAABcAAAAAQAAAGQAAAAAAAAAZgAAAAAAAAB1AAAAAAAAAHkAAAAFAAAAdwAAAAUAAABtAAAAAQAAAHYAAAAAAAAAeAAAAAAAAABfAAAAAQAAAGwAAAABAAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAB+ogX28rbpPxqumpJv+fM/165tC4ns9D+XaEnTqUsEQFrOtNlC4PA/3U+0XG6P9b9TdUUBxTTjP4PUp8ex1ty/B1rD/EN43z+lcDi6LLrZP/a45NWEHMY/oJ5ijLDZ+j/xw3rjxWPjP2B8A46ioQdAotff3wla2z+FMSpA1jj+v6b5Y1mtPbS/cIu8K0F457/2esiyJpDNv98k5Ts2NeA/pvljWa09tD88ClUJ60MDQPZ6yLImkM0/4ONKxa0UBcD2uOTVhBzGv5G7JRxGave/8cN648Vj47+HCwtkjAXIv6LX398JWtu/qyheaCAL9D9TdUUBxTTjv4gyTxslhwVAB1rD/EN4378EH/28teoFwH6iBfbytum/F6ztFYdK/r/Xrm0Liez0vwcS6wNGWeO/Ws602ULg8L9TCtRLiLT8P8pi5RexJsw/BlIKPVwR5T95Wyu0/QjnP5PjoT7YYcu/mBhKZ6zrwj8wRYS7NebuP3qW6geh+Ls/SLrixebL3r+pcyymN9XrPwmkNHp7xec/GWNMZVAA17+82s+x2BLiPwn2ytbJ9ek/LgEH1sMS1j8yp/2LhTfeP+SnWwtQBbu/d38gkp5X7z8ytsuHaADGPzUYObdf1+m/7IauECWhwz+cjSACjzniP76Z+wUhN9K/1+GEKzup67+/GYr/04baPw6idWOvsuc/ZedTWsRa5b/EJQOuRzi0v/OncYhHPes/h49PixY53j+i8wWfC03Nvw2idWOvsue/ZedTWsRa5T/EJQOuRzi0P/KncYhHPeu/iY9PixY53r+i8wWfC03NP9anWwtQBbs/d38gkp5X778ytsuHaADGvzUYObdf1+k/74auECWhw7+cjSACjzniv8CZ+wUhN9I/1uGEKzup6z+/GYr/04bavwmkNHp7xee/F2NMZVAA1z+82s+x2BLivwr2ytbJ9em/KwEH1sMS1r8yp/2LhTfev81i5RexJsy/BlIKPVwR5b95Wyu0/Qjnv5DjoT7YYcs/nBhKZ6zrwr8wRYS7Nebuv3OW6geh+Lu/SLrixebL3j+pcyymN9Xrv8rHIFfWehZAMBwUdlo0DECTUc17EOb2PxpVB1SWChdAzjbhb9pTDUDQhmdvECX5P9FlMKCC9+g/IIAzjELgE0DajDngMv8GQFhWDmDPjNs/y1guLh96EkAxPi8k7DIEQJCc4URlhRhA3eLKKLwkEECqpNAyTBD/P6xpjXcDiwVAFtl//cQm4z+Ibt3XKiYTQM7mCLUb3QdAoM1t8yVv7D8aLZv2Nk8UQEAJPV5nQwxAtSsfTCoE9z9TPjXLXIIWQBVanC5W9AtAYM3d7Adm9j++5mQz1FoWQBUThyaVBghAwH5muQsV7T89Q1qv82MUQJoWGOfNuBdAzrkClkmwDkDQjKq77t37Py+g0dtitsE/ZwAMTwVPEUBojepluNwBQGYbtuW+t9w/HNWIJs6MEkDTNuQUSlgEQKxktPP5TcQ/ixbLB8JjEUCwuWjXMQYCQAS/R09FkRdAowpiZjhhDkB7LmlczD/7P01iQmhhsAVAnrtTwDy84z/Z6jfQ2TgTQChOCXMnWwpAhrW3daoz8z/HYJvVPI4VQLT3ik5FcA5Angi7LOZd+z+NNVzDy5gXQBXdvVTFUA1AYNMgOeYe+T8+qHXGCwkXQKQTOKwa5AJA8gFVoEMW0T+FwzJyttIRQAEAAAD/////BwAAAP////8xAAAA/////1cBAAD/////YQkAAP////+nQQAA/////5HLAQD/////95AMAP/////B9lcAAAAAAAAAAAAAAAAAAgAAAP////8OAAAA/////2IAAAD/////rgIAAP/////CEgAA/////06DAAD/////IpcDAP/////uIRkA/////4LtrwAAAAAAAAAAAAAAAAAAAAAAAgAAAP//////////AQAAAAMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////wIAAAD//////////wEAAAAAAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA/////////////////////wEAAAD///////////////8CAAAA////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD///////////////////////////////8CAAAA////////////////AQAAAP////////////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAAAQAAAP//////////AgAAAP//////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAAEAAAD//////////wIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAgAAAAAAAAACAAAAAQAAAAEAAAACAAAAAgAAAAAAAAAFAAAABQAAAAAAAAACAAAAAgAAAAMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAABAAAAAgAAAAIAAAACAAAAAAAAAAUAAAAGAAAAAAAAAAIAAAACAAAAAwAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAEAAAADAAAAAgAAAAIAAAAAAAAABQAAAAcAAAAAAAAAAgAAAAIAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAACAAAAAQAAAAQAAAACAAAAAgAAAAAAAAAFAAAACAAAAAAAAAACAAAAAgAAAAMAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAACAAAAAAAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAUAAAAJAAAAAAAAAAIAAAACAAAAAwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAIAAAACAAAAAAAAAAMAAAAOAAAAAgAAAAAAAAACAAAAAwAAAAAAAAAAAAAAAgAAAAIAAAADAAAABgAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAgAAAAIAAAAAAAAAAwAAAAoAAAACAAAAAAAAAAIAAAADAAAAAQAAAAAAAAACAAAAAgAAAAMAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAgAAAAAAAAADAAAACwAAAAIAAAAAAAAAAgAAAAMAAAACAAAAAAAAAAIAAAACAAAAAwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAACAAAAAAAAAAMAAAAMAAAAAgAAAAAAAAACAAAAAwAAAAMAAAAAAAAAAgAAAAIAAAADAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAgAAAAIAAAAAAAAAAwAAAA0AAAACAAAAAAAAAAIAAAADAAAABAAAAAAAAAACAAAAAgAAAAMAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAgAAAAAAAAADAAAABgAAAAIAAAAAAAAAAgAAAAMAAAAPAAAAAAAAAAIAAAACAAAAAwAAAAsAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAIAAAACAAAAAAAAAAMAAAAHAAAAAgAAAAAAAAACAAAAAwAAABAAAAAAAAAAAgAAAAIAAAADAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAIAAAAAAAAAAwAAAAgAAAACAAAAAAAAAAIAAAADAAAAEQAAAAAAAAACAAAAAgAAAAMAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAACAAAAAgAAAAAAAAADAAAACQAAAAIAAAAAAAAAAgAAAAMAAAASAAAAAAAAAAIAAAACAAAAAwAAAA4AAAAAAAAAAAAAAAAAAAAAAAAACQAAAAIAAAACAAAAAAAAAAMAAAAFAAAAAgAAAAAAAAACAAAAAwAAABMAAAAAAAAAAgAAAAIAAAADAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAgAAAAAAAAACAAAAAQAAABMAAAACAAAAAgAAAAAAAAAFAAAACgAAAAAAAAACAAAAAgAAAAMAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABEAAAACAAAAAAAAAAIAAAABAAAADwAAAAIAAAACAAAAAAAAAAUAAAALAAAAAAAAAAIAAAACAAAAAwAAABEAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAIAAAAAAAAAAgAAAAEAAAAQAAAAAgAAAAIAAAAAAAAABQAAAAwAAAAAAAAAAgAAAAIAAAADAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAACAAAAAQAAABEAAAACAAAAAgAAAAAAAAAFAAAADQAAAAAAAAACAAAAAgAAAAMAAAATAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAACAAAAAAAAAAIAAAABAAAAEgAAAAIAAAACAAAAAAAAAAUAAAAOAAAAAAAAAAIAAAACAAAAAwAAAAIAAAABAAAAAAAAAAEAAAACAAAAAAAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAgAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAAAAAAAAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAUAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAgAAAAAAAAABAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAAAAAAAAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAUAAAAFAAAAAAAAAAEAAAAAAAAAAAAAAMuhRbbsNlBBYqHW9OmHIkF9XBuqnS31QAK37uYhNMhAOSo3UUupm0DC+6pc6JxvQHV9eseEEEJAzURsCyqlFEB8BQ4NMJjnPyy3tBoS97o/xawXQznRjj89J2K2CZxhP6vX43RIIDQ/S8isgygEBz+LvFHQkmzaPjFFFO7wMq4+AADMLkTtjkIAAOgkJqxhQgAAU7B0MjRCAADwpBcVB0IAAACYP2HaQQAAAIn/Ja5BzczM4Eg6gUHNzMxMU7BTQTMzMzNfgCZBAAAAAEi3+UAAAAAAwGPNQDMzMzMzy6BAmpmZmZkxc0AzMzMzM/NFQDMzMzMzMxlAzczMzMzM7D+ygXSx2U6RQKimJOvQKnpA23hmONTHY0A/AGcxyudNQNb3K647mzZA+S56rrwWIUAm4kUQ+9UJQKre9hGzh/M/BLvoy9WG3T+LmqMf8VHGP2m3nYNV37A/gbFHcyeCmT+cBPWBckiDP61tZACjKW0/q2RbYVUYVj8uDypVyLNAP6jGS5cA5zBBwcqhBdCNGUEGEhQ/JVEDQT6WPnRbNO1AB/AWSJgT1kDfUWNCNLDAQNk+5C33OqlAchWL34QSk0DKvtDIrNV8QNF0G3kFzGVASSeWhBl6UED+/0mNGuk4QGjA/dm/1CJALPLPMql6DEDSHoDrwpP1P2jouzWST+A/egAAAAAAAABKAwAAAAAAAPoWAAAAAAAAyqAAAAAAAAB6ZQQAAAAAAErGHgAAAAAA+mvXAAAAAADK8+MFAAAAAHqqOykAAAAASqmhIAEAAAD6oGvkBwAAAMpm8T43AAAAes+ZuIIBAABKrDQMkwoAAPq1cFUFSgAAyvkUViUGAgAAAAAAAwAAAAYAAAACAAAABQAAAAEAAAAEAAAAAAAAAAAAAAAFAAAAAwAAAAEAAAAGAAAABAAAAAIAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAA/////wAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAP////8AAAAAAAAAAAEAAAABAAAAAAAAAAAAAAD/////AAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAA/////wUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAUAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAAAAAABAAEAAAEBAAAAAAABAAAAAQAAAAEAAQAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAHAAAABwAAAAEAAAACAAAABAAAAAMAAAAAAAAAAAAAAAcAAAADAAAAAQAAAAIAAAAFAAAABAAAAAAAAAAAAAAAYWxnb3MuYwBfcG9seWZpbGxJbnRlcm5hbABhZGphY2VudEZhY2VEaXJbdG1wRmlqay5mYWNlXVtmaWprLmZhY2VdID09IEtJAGZhY2VpamsuYwBfZmFjZUlqa1BlbnRUb0dlb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9HZW9Cb3VuZGFyeQBwb2x5Z29uLT5uZXh0ID09IE5VTEwAbGlua2VkR2VvLmMAYWRkTmV3TGlua2VkUG9seWdvbgBuZXh0ICE9IE5VTEwAbG9vcCAhPSBOVUxMAGFkZE5ld0xpbmtlZExvb3AAcG9seWdvbi0+Zmlyc3QgPT0gTlVMTABhZGRMaW5rZWRMb29wAGNvb3JkICE9IE5VTEwAYWRkTGlua2VkQ29vcmQAbG9vcC0+Zmlyc3QgPT0gTlVMTABpbm5lckxvb3BzICE9IE5VTEwAbm9ybWFsaXplTXVsdGlQb2x5Z29uAGJib3hlcyAhPSBOVUxMAGNhbmRpZGF0ZXMgIT0gTlVMTABmaW5kUG9seWdvbkZvckhvbGUAY2FuZGlkYXRlQkJveGVzICE9IE5VTEwAcmV2RGlyICE9IElOVkFMSURfRElHSVQAbG9jYWxpai5jAGgzVG9Mb2NhbElqawBiYXNlQ2VsbCAhPSBvcmlnaW5CYXNlQ2VsbAAhKG9yaWdpbk9uUGVudCAmJiBpbmRleE9uUGVudCkAcGVudGFnb25Sb3RhdGlvbnMgPj0gMABkaXJlY3Rpb25Sb3RhdGlvbnMgPj0gMABiYXNlQ2VsbCA9PSBvcmlnaW5CYXNlQ2VsbABiYXNlQ2VsbCAhPSBJTlZBTElEX0JBU0VfQ0VMTABsb2NhbElqa1RvSDMAIV9pc0Jhc2VDZWxsUGVudGFnb24oYmFzZUNlbGwpAGJhc2VDZWxsUm90YXRpb25zID49IDAAd2l0aGluUGVudGFnb25Sb3RhdGlvbnMgPj0gMABncmFwaC0+YnVja2V0cyAhPSBOVUxMAHZlcnRleEdyYXBoLmMAaW5pdFZlcnRleEdyYXBoAG5vZGUgIT0gTlVMTABhZGRWZXJ0ZXhOb2Rl";
      var tempDoublePtr = 24032;
      function demangle(func) {
        return func;
      }
      function demangleAll(text) {
        var regex = /\b__Z[\w\d_]+/g;
        return text.replace(regex, function(x2) {
          var y2 = demangle(x2);
          return x2 === y2 ? x2 : y2 + " [" + x2 + "]";
        });
      }
      function jsStackTrace() {
        var err2 = new Error();
        if (!err2.stack) {
          try {
            throw new Error(0);
          } catch (e2) {
            err2 = e2;
          }
          if (!err2.stack) {
            return "(no stack trace available)";
          }
        }
        return err2.stack.toString();
      }
      function stackTrace() {
        var js = jsStackTrace();
        if (Module["extraStackTrace"]) {
          js += "\n" + Module["extraStackTrace"]();
        }
        return demangleAll(js);
      }
      function ___assert_fail(condition, filename, line, func) {
        abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      }
      function _emscripten_get_heap_size() {
        return HEAP8.length;
      }
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
      }
      function ___setErrNo(value) {
        if (Module["___errno_location"]) {
          HEAP32[Module["___errno_location"]() >> 2] = value;
        }
        return value;
      }
      function abortOnCannotGrowMemory(requestedSize) {
        abort("OOM");
      }
      function emscripten_realloc_buffer(size) {
        try {
          var newBuffer = new ArrayBuffer(size);
          if (newBuffer.byteLength != size) {
            return;
          }
          new Int8Array(newBuffer).set(HEAP8);
          _emscripten_replace_memory(newBuffer);
          updateGlobalBufferAndViews(newBuffer);
          return 1;
        } catch (e2) {
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        var oldSize = _emscripten_get_heap_size();
        var PAGE_MULTIPLE = 16777216;
        var LIMIT = 2147483648 - PAGE_MULTIPLE;
        if (requestedSize > LIMIT) {
          return false;
        }
        var MIN_TOTAL_MEMORY = 16777216;
        var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
        while (newSize < requestedSize) {
          if (newSize <= 536870912) {
            newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
          } else {
            newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
          }
        }
        var replacement = emscripten_realloc_buffer(newSize);
        if (!replacement) {
          return false;
        }
        return true;
      }
      var decodeBase64 = typeof atob === "function" ? atob : function(input) {
        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i3 = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        do {
          enc1 = keyStr.indexOf(input.charAt(i3++));
          enc2 = keyStr.indexOf(input.charAt(i3++));
          enc3 = keyStr.indexOf(input.charAt(i3++));
          enc4 = keyStr.indexOf(input.charAt(i3++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 !== 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 !== 64) {
            output = output + String.fromCharCode(chr3);
          }
        } while (i3 < input.length);
        return output;
      };
      function intArrayFromBase64(s2) {
        try {
          var decoded = decodeBase64(s2);
          var bytes = new Uint8Array(decoded.length);
          for (var i3 = 0; i3 < decoded.length; ++i3) {
            bytes[i3] = decoded.charCodeAt(i3);
          }
          return bytes;
        } catch (_2) {
          throw new Error("Converting base64 string to bytes failed.");
        }
      }
      function tryParseAsDataURI(filename) {
        if (!isDataURI(filename)) {
          return;
        }
        return intArrayFromBase64(filename.slice(dataURIPrefix.length));
      }
      var asmGlobalArg = {
        "Math": Math,
        "Int8Array": Int8Array,
        "Int32Array": Int32Array,
        "Uint8Array": Uint8Array,
        "Float32Array": Float32Array,
        "Float64Array": Float64Array
      };
      var asmLibraryArg = {
        "a": abort,
        "b": setTempRet0,
        "c": getTempRet0,
        "d": ___assert_fail,
        "e": ___setErrNo,
        "f": _emscripten_get_heap_size,
        "g": _emscripten_memcpy_big,
        "h": _emscripten_resize_heap,
        "i": abortOnCannotGrowMemory,
        "j": demangle,
        "k": demangleAll,
        "l": emscripten_realloc_buffer,
        "m": jsStackTrace,
        "n": stackTrace,
        "o": tempDoublePtr,
        "p": DYNAMICTOP_PTR
      };
      var asm = (
        /** @suppress {uselessCode} */
        function(global, env, buffer2) {
          "almost asm";
          var a2 = new global.Int8Array(buffer2), b = new global.Int32Array(buffer2), c2 = new global.Uint8Array(buffer2), d = new global.Float32Array(buffer2), e2 = new global.Float64Array(buffer2), g = env.p | 0, p2 = global.Math.floor, q = global.Math.abs, r2 = global.Math.sqrt, s2 = global.Math.pow, t2 = global.Math.cos, u = global.Math.sin, v = global.Math.tan, w = global.Math.acos, x2 = global.Math.asin, y2 = global.Math.atan, z = global.Math.atan2, A = global.Math.ceil, B = global.Math.imul, C = global.Math.min, D = global.Math.clz32, F = env.b, G = env.c, H = env.d, I = env.e, J = env.f, K = env.g, L = env.h, M = env.i, S = 24048;
          function V(newBuffer) {
            a2 = new Int8Array(newBuffer);
            c2 = new Uint8Array(newBuffer);
            b = new Int32Array(newBuffer);
            d = new Float32Array(newBuffer);
            e2 = new Float64Array(newBuffer);
            buffer2 = newBuffer;
            return true;
          }
          function W(a3) {
            a3 = a3 | 0;
            var b2 = 0;
            b2 = S;
            S = S + a3 | 0;
            S = S + 15 & -16;
            return b2 | 0;
          }
          function X() {
            return S | 0;
          }
          function Y(a3) {
            a3 = a3 | 0;
            S = a3;
          }
          function Z(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            S = a3;
          }
          function _2(a3) {
            a3 = a3 | 0;
            return (B(a3 * 3 | 0, a3 + 1 | 0) | 0) + 1 | 0;
          }
          function $(a3, b2, c3, d2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0;
            if (!(ba(a3, b2, c3, d2, 0) | 0)) {
              return;
            }
            f2 = (B(c3 * 3 | 0, c3 + 1 | 0) | 0) + 1 | 0;
            hd(d2 | 0, 0, f2 << 3 | 0) | 0;
            e3 = Yc(f2, 4) | 0;
            if (!e3) {
              return;
            }
            ca(a3, b2, c3, d2, e3, f2, 0);
            Xc(e3);
            return;
          }
          function aa(a3, b2, c3, d2, e3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0;
            if (!(ba(a3, b2, c3, d2, e3) | 0)) {
              return;
            }
            f2 = (B(c3 * 3 | 0, c3 + 1 | 0) | 0) + 1 | 0;
            hd(d2 | 0, 0, f2 << 3 | 0) | 0;
            if (e3 | 0) {
              hd(e3 | 0, 0, f2 << 2 | 0) | 0;
              ca(a3, b2, c3, d2, e3, f2, 0);
              return;
            }
            e3 = Yc(f2, 4) | 0;
            if (!e3) {
              return;
            }
            ca(a3, b2, c3, d2, e3, f2, 0);
            Xc(e3);
            return;
          }
          function ba(a3, c3, d2, e3, f2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            f2 = f2 | 0;
            var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0;
            o2 = S;
            S = S + 16 | 0;
            n2 = o2;
            g2 = e3;
            b[g2 >> 2] = a3;
            b[g2 + 4 >> 2] = c3;
            g2 = (f2 | 0) != 0;
            if (g2) {
              b[f2 >> 2] = 0;
            }
            if (Fb(a3, c3) | 0) {
              n2 = 1;
              S = o2;
              return n2 | 0;
            }
            b[n2 >> 2] = 0;
            a:
              do {
                if ((d2 | 0) >= 1) {
                  if (g2) {
                    k = 0;
                    l2 = 1;
                    m = 1;
                    h = 0;
                    g2 = a3;
                    while (1) {
                      if (!(h | k)) {
                        g2 = da(g2, c3, 4, n2) | 0;
                        c3 = G() | 0;
                        if ((g2 | 0) == 0 & (c3 | 0) == 0) {
                          g2 = 2;
                          break a;
                        }
                        if (Fb(g2, c3) | 0) {
                          g2 = 1;
                          break a;
                        }
                      }
                      g2 = da(g2, c3, b[16 + (k << 2) >> 2] | 0, n2) | 0;
                      c3 = G() | 0;
                      if ((g2 | 0) == 0 & (c3 | 0) == 0) {
                        g2 = 2;
                        break a;
                      }
                      a3 = e3 + (m << 3) | 0;
                      b[a3 >> 2] = g2;
                      b[a3 + 4 >> 2] = c3;
                      b[f2 + (m << 2) >> 2] = l2;
                      h = h + 1 | 0;
                      a3 = (h | 0) == (l2 | 0);
                      i3 = k + 1 | 0;
                      j = (i3 | 0) == 6;
                      if (Fb(g2, c3) | 0) {
                        g2 = 1;
                        break a;
                      }
                      l2 = l2 + (j & a3 & 1) | 0;
                      if ((l2 | 0) > (d2 | 0)) {
                        g2 = 0;
                        break;
                      } else {
                        k = a3 ? j ? 0 : i3 : k;
                        m = m + 1 | 0;
                        h = a3 ? 0 : h;
                      }
                    }
                  } else {
                    k = 0;
                    l2 = 1;
                    m = 1;
                    h = 0;
                    g2 = a3;
                    while (1) {
                      if (!(h | k)) {
                        g2 = da(g2, c3, 4, n2) | 0;
                        c3 = G() | 0;
                        if ((g2 | 0) == 0 & (c3 | 0) == 0) {
                          g2 = 2;
                          break a;
                        }
                        if (Fb(g2, c3) | 0) {
                          g2 = 1;
                          break a;
                        }
                      }
                      g2 = da(g2, c3, b[16 + (k << 2) >> 2] | 0, n2) | 0;
                      c3 = G() | 0;
                      if ((g2 | 0) == 0 & (c3 | 0) == 0) {
                        g2 = 2;
                        break a;
                      }
                      a3 = e3 + (m << 3) | 0;
                      b[a3 >> 2] = g2;
                      b[a3 + 4 >> 2] = c3;
                      h = h + 1 | 0;
                      a3 = (h | 0) == (l2 | 0);
                      i3 = k + 1 | 0;
                      j = (i3 | 0) == 6;
                      if (Fb(g2, c3) | 0) {
                        g2 = 1;
                        break a;
                      }
                      l2 = l2 + (j & a3 & 1) | 0;
                      if ((l2 | 0) > (d2 | 0)) {
                        g2 = 0;
                        break;
                      } else {
                        k = a3 ? j ? 0 : i3 : k;
                        m = m + 1 | 0;
                        h = a3 ? 0 : h;
                      }
                    }
                  }
                } else {
                  g2 = 0;
                }
              } while (0);
            n2 = g2;
            S = o2;
            return n2 | 0;
          }
          function ca(a3, c3, d2, e3, f2, g2, h) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            f2 = f2 | 0;
            g2 = g2 | 0;
            h = h | 0;
            var i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0;
            m = S;
            S = S + 16 | 0;
            l2 = m;
            if ((a3 | 0) == 0 & (c3 | 0) == 0) {
              S = m;
              return;
            }
            i3 = bd(a3 | 0, c3 | 0, g2 | 0, ((g2 | 0) < 0) << 31 >> 31 | 0) | 0;
            G() | 0;
            j = e3 + (i3 << 3) | 0;
            n2 = j;
            o2 = b[n2 >> 2] | 0;
            n2 = b[n2 + 4 >> 2] | 0;
            k = (o2 | 0) == (a3 | 0) & (n2 | 0) == (c3 | 0);
            if (!((o2 | 0) == 0 & (n2 | 0) == 0 | k)) {
              do {
                i3 = (i3 + 1 | 0) % (g2 | 0) | 0;
                j = e3 + (i3 << 3) | 0;
                o2 = j;
                n2 = b[o2 >> 2] | 0;
                o2 = b[o2 + 4 >> 2] | 0;
                k = (n2 | 0) == (a3 | 0) & (o2 | 0) == (c3 | 0);
              } while (!((n2 | 0) == 0 & (o2 | 0) == 0 | k));
            }
            i3 = f2 + (i3 << 2) | 0;
            if (k ? (b[i3 >> 2] | 0) <= (h | 0) : 0) {
              S = m;
              return;
            }
            o2 = j;
            b[o2 >> 2] = a3;
            b[o2 + 4 >> 2] = c3;
            b[i3 >> 2] = h;
            if ((h | 0) >= (d2 | 0)) {
              S = m;
              return;
            }
            o2 = h + 1 | 0;
            b[l2 >> 2] = 0;
            n2 = da(a3, c3, 2, l2) | 0;
            ca(n2, G() | 0, d2, e3, f2, g2, o2);
            b[l2 >> 2] = 0;
            n2 = da(a3, c3, 3, l2) | 0;
            ca(n2, G() | 0, d2, e3, f2, g2, o2);
            b[l2 >> 2] = 0;
            n2 = da(a3, c3, 1, l2) | 0;
            ca(n2, G() | 0, d2, e3, f2, g2, o2);
            b[l2 >> 2] = 0;
            n2 = da(a3, c3, 5, l2) | 0;
            ca(n2, G() | 0, d2, e3, f2, g2, o2);
            b[l2 >> 2] = 0;
            n2 = da(a3, c3, 4, l2) | 0;
            ca(n2, G() | 0, d2, e3, f2, g2, o2);
            b[l2 >> 2] = 0;
            n2 = da(a3, c3, 6, l2) | 0;
            ca(n2, G() | 0, d2, e3, f2, g2, o2);
            S = m;
            return;
          }
          function da(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0;
            if ((b[e3 >> 2] | 0) > 0) {
              f2 = 0;
              do {
                d2 = Pa(d2) | 0;
                f2 = f2 + 1 | 0;
              } while ((f2 | 0) < (b[e3 >> 2] | 0));
            }
            i3 = cd(a3 | 0, c3 | 0, 45) | 0;
            G() | 0;
            j = i3 & 127;
            g2 = Lb(a3, c3) | 0;
            f2 = cd(a3 | 0, c3 | 0, 52) | 0;
            G() | 0;
            f2 = f2 & 15;
            a:
              do {
                if (!f2) {
                  h = 6;
                } else {
                  while (1) {
                    m = (15 - f2 | 0) * 3 | 0;
                    n2 = cd(a3 | 0, c3 | 0, m | 0) | 0;
                    G() | 0;
                    n2 = n2 & 7;
                    o2 = (Rb(f2) | 0) == 0;
                    f2 = f2 + -1 | 0;
                    l2 = dd(7, 0, m | 0) | 0;
                    c3 = c3 & ~(G() | 0);
                    m = dd(b[(o2 ? 464 : 48) + (n2 * 28 | 0) + (d2 << 2) >> 2] | 0, 0, m | 0) | 0;
                    k = G() | 0;
                    d2 = b[(o2 ? 672 : 256) + (n2 * 28 | 0) + (d2 << 2) >> 2] | 0;
                    a3 = m | a3 & ~l2;
                    c3 = k | c3;
                    if (!d2) {
                      d2 = 0;
                      break a;
                    }
                    if (!f2) {
                      h = 6;
                      break;
                    }
                  }
                }
              } while (0);
            if ((h | 0) == 6) {
              o2 = b[880 + (j * 28 | 0) + (d2 << 2) >> 2] | 0;
              n2 = dd(o2 | 0, 0, 45) | 0;
              a3 = n2 | a3;
              c3 = G() | 0 | c3 & -1040385;
              d2 = b[4304 + (j * 28 | 0) + (d2 << 2) >> 2] | 0;
              if ((o2 & 127 | 0) == 127) {
                o2 = dd(b[880 + (j * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0;
                c3 = G() | 0 | c3 & -1040385;
                d2 = b[4304 + (j * 28 | 0) + 20 >> 2] | 0;
                a3 = Nb(o2 | a3, c3) | 0;
                c3 = G() | 0;
                b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
              }
            }
            h = cd(a3 | 0, c3 | 0, 45) | 0;
            G() | 0;
            h = h & 127;
            b:
              do {
                if (!(la(h) | 0)) {
                  if ((d2 | 0) > 0) {
                    f2 = 0;
                    do {
                      a3 = Nb(a3, c3) | 0;
                      c3 = G() | 0;
                      f2 = f2 + 1 | 0;
                    } while ((f2 | 0) != (d2 | 0));
                  }
                } else {
                  c:
                    do {
                      if ((Lb(a3, c3) | 0) == 1) {
                        if ((j | 0) != (h | 0)) {
                          if (ra(h, b[7728 + (j * 28 | 0) >> 2] | 0) | 0) {
                            a3 = Pb(a3, c3) | 0;
                            g2 = 1;
                            c3 = G() | 0;
                            break;
                          } else {
                            a3 = Nb(a3, c3) | 0;
                            g2 = 1;
                            c3 = G() | 0;
                            break;
                          }
                        }
                        switch (g2 | 0) {
                          case 5: {
                            a3 = Pb(a3, c3) | 0;
                            c3 = G() | 0;
                            b[e3 >> 2] = (b[e3 >> 2] | 0) + 5;
                            g2 = 0;
                            break c;
                          }
                          case 3: {
                            a3 = Nb(a3, c3) | 0;
                            c3 = G() | 0;
                            b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
                            g2 = 0;
                            break c;
                          }
                          default: {
                            n2 = 0;
                            o2 = 0;
                            F(n2 | 0);
                            return o2 | 0;
                          }
                        }
                      } else {
                        g2 = 0;
                      }
                    } while (0);
                  if ((d2 | 0) > 0) {
                    f2 = 0;
                    do {
                      a3 = Mb(a3, c3) | 0;
                      c3 = G() | 0;
                      f2 = f2 + 1 | 0;
                    } while ((f2 | 0) != (d2 | 0));
                  }
                  if ((j | 0) != (h | 0)) {
                    if (!(ma(h) | 0)) {
                      if ((g2 | 0) != 0 | (Lb(a3, c3) | 0) != 5) {
                        break;
                      }
                      b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
                      break;
                    }
                    switch (i3 & 127) {
                      case 8:
                      case 118:
                        break b;
                      default:
                    }
                    if ((Lb(a3, c3) | 0) != 3) {
                      b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
                    }
                  }
                }
              } while (0);
            b[e3 >> 2] = ((b[e3 >> 2] | 0) + d2 | 0) % 6 | 0;
            n2 = c3;
            o2 = a3;
            F(n2 | 0);
            return o2 | 0;
          }
          function ea(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
            m = S;
            S = S + 16 | 0;
            l2 = m;
            if (!d2) {
              l2 = e3;
              b[l2 >> 2] = a3;
              b[l2 + 4 >> 2] = c3;
              l2 = 0;
              S = m;
              return l2 | 0;
            }
            b[l2 >> 2] = 0;
            a:
              do {
                if (!(Fb(a3, c3) | 0)) {
                  g2 = (d2 | 0) > 0;
                  if (g2) {
                    f2 = 0;
                    k = a3;
                    do {
                      k = da(k, c3, 4, l2) | 0;
                      c3 = G() | 0;
                      if ((k | 0) == 0 & (c3 | 0) == 0) {
                        a3 = 2;
                        break a;
                      }
                      f2 = f2 + 1 | 0;
                      if (Fb(k, c3) | 0) {
                        a3 = 1;
                        break a;
                      }
                    } while ((f2 | 0) < (d2 | 0));
                    j = e3;
                    b[j >> 2] = k;
                    b[j + 4 >> 2] = c3;
                    j = d2 + -1 | 0;
                    if (g2) {
                      g2 = 0;
                      h = 1;
                      f2 = k;
                      a3 = c3;
                      do {
                        f2 = da(f2, a3, 2, l2) | 0;
                        a3 = G() | 0;
                        if ((f2 | 0) == 0 & (a3 | 0) == 0) {
                          a3 = 2;
                          break a;
                        }
                        i3 = e3 + (h << 3) | 0;
                        b[i3 >> 2] = f2;
                        b[i3 + 4 >> 2] = a3;
                        h = h + 1 | 0;
                        if (Fb(f2, a3) | 0) {
                          a3 = 1;
                          break a;
                        }
                        g2 = g2 + 1 | 0;
                      } while ((g2 | 0) < (d2 | 0));
                      i3 = 0;
                      g2 = h;
                      do {
                        f2 = da(f2, a3, 3, l2) | 0;
                        a3 = G() | 0;
                        if ((f2 | 0) == 0 & (a3 | 0) == 0) {
                          a3 = 2;
                          break a;
                        }
                        h = e3 + (g2 << 3) | 0;
                        b[h >> 2] = f2;
                        b[h + 4 >> 2] = a3;
                        g2 = g2 + 1 | 0;
                        if (Fb(f2, a3) | 0) {
                          a3 = 1;
                          break a;
                        }
                        i3 = i3 + 1 | 0;
                      } while ((i3 | 0) < (d2 | 0));
                      h = 0;
                      do {
                        f2 = da(f2, a3, 1, l2) | 0;
                        a3 = G() | 0;
                        if ((f2 | 0) == 0 & (a3 | 0) == 0) {
                          a3 = 2;
                          break a;
                        }
                        i3 = e3 + (g2 << 3) | 0;
                        b[i3 >> 2] = f2;
                        b[i3 + 4 >> 2] = a3;
                        g2 = g2 + 1 | 0;
                        if (Fb(f2, a3) | 0) {
                          a3 = 1;
                          break a;
                        }
                        h = h + 1 | 0;
                      } while ((h | 0) < (d2 | 0));
                      h = 0;
                      do {
                        f2 = da(f2, a3, 5, l2) | 0;
                        a3 = G() | 0;
                        if ((f2 | 0) == 0 & (a3 | 0) == 0) {
                          a3 = 2;
                          break a;
                        }
                        i3 = e3 + (g2 << 3) | 0;
                        b[i3 >> 2] = f2;
                        b[i3 + 4 >> 2] = a3;
                        g2 = g2 + 1 | 0;
                        if (Fb(f2, a3) | 0) {
                          a3 = 1;
                          break a;
                        }
                        h = h + 1 | 0;
                      } while ((h | 0) < (d2 | 0));
                      h = 0;
                      do {
                        f2 = da(f2, a3, 4, l2) | 0;
                        a3 = G() | 0;
                        if ((f2 | 0) == 0 & (a3 | 0) == 0) {
                          a3 = 2;
                          break a;
                        }
                        i3 = e3 + (g2 << 3) | 0;
                        b[i3 >> 2] = f2;
                        b[i3 + 4 >> 2] = a3;
                        g2 = g2 + 1 | 0;
                        if (Fb(f2, a3) | 0) {
                          a3 = 1;
                          break a;
                        }
                        h = h + 1 | 0;
                      } while ((h | 0) < (d2 | 0));
                      h = 0;
                      while (1) {
                        f2 = da(f2, a3, 6, l2) | 0;
                        a3 = G() | 0;
                        if ((f2 | 0) == 0 & (a3 | 0) == 0) {
                          a3 = 2;
                          break a;
                        }
                        if ((h | 0) != (j | 0)) {
                          i3 = e3 + (g2 << 3) | 0;
                          b[i3 >> 2] = f2;
                          b[i3 + 4 >> 2] = a3;
                          if (!(Fb(f2, a3) | 0)) {
                            g2 = g2 + 1 | 0;
                          } else {
                            a3 = 1;
                            break a;
                          }
                        }
                        h = h + 1 | 0;
                        if ((h | 0) >= (d2 | 0)) {
                          h = k;
                          g2 = c3;
                          break;
                        }
                      }
                    } else {
                      h = k;
                      f2 = k;
                      g2 = c3;
                      a3 = c3;
                    }
                  } else {
                    h = e3;
                    b[h >> 2] = a3;
                    b[h + 4 >> 2] = c3;
                    h = a3;
                    f2 = a3;
                    g2 = c3;
                    a3 = c3;
                  }
                  a3 = ((h | 0) != (f2 | 0) | (g2 | 0) != (a3 | 0)) & 1;
                } else {
                  a3 = 1;
                }
              } while (0);
            l2 = a3;
            S = m;
            return l2 | 0;
          }
          function fa(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            g2 = S;
            S = S + 48 | 0;
            f2 = g2 + 8 | 0;
            e3 = g2;
            i3 = a3;
            h = b[i3 + 4 >> 2] | 0;
            d2 = e3;
            b[d2 >> 2] = b[i3 >> 2];
            b[d2 + 4 >> 2] = h;
            vc(e3, f2);
            f2 = ya(f2, c3) | 0;
            c3 = b[e3 >> 2] | 0;
            e3 = b[a3 + 8 >> 2] | 0;
            if ((e3 | 0) <= 0) {
              i3 = c3;
              h = (f2 | 0) < (i3 | 0);
              i3 = h ? i3 : f2;
              i3 = i3 + 12 | 0;
              S = g2;
              return i3 | 0;
            }
            d2 = b[a3 + 12 >> 2] | 0;
            a3 = 0;
            do {
              c3 = (b[d2 + (a3 << 3) >> 2] | 0) + c3 | 0;
              a3 = a3 + 1 | 0;
            } while ((a3 | 0) < (e3 | 0));
            i3 = (f2 | 0) < (c3 | 0);
            i3 = i3 ? c3 : f2;
            i3 = i3 + 12 | 0;
            S = g2;
            return i3 | 0;
          }
          function ga(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
            i3 = S;
            S = S + 48 | 0;
            e3 = i3 + 8 | 0;
            f2 = i3;
            if (!(ha(a3, c3, d2) | 0)) {
              S = i3;
              return;
            }
            j = a3;
            g2 = b[j + 4 >> 2] | 0;
            h = f2;
            b[h >> 2] = b[j >> 2];
            b[h + 4 >> 2] = g2;
            vc(f2, e3);
            h = ya(e3, c3) | 0;
            c3 = b[f2 >> 2] | 0;
            g2 = b[a3 + 8 >> 2] | 0;
            if ((g2 | 0) > 0) {
              f2 = b[a3 + 12 >> 2] | 0;
              e3 = 0;
              do {
                c3 = (b[f2 + (e3 << 3) >> 2] | 0) + c3 | 0;
                e3 = e3 + 1 | 0;
              } while ((e3 | 0) != (g2 | 0));
            }
            c3 = (h | 0) < (c3 | 0) ? c3 : h;
            if ((c3 | 0) <= -12) {
              S = i3;
              return;
            }
            j = c3 + 11 | 0;
            hd(d2 | 0, 0, (((j | 0) > 0 ? j : 0) << 3) + 8 | 0) | 0;
            S = i3;
            return;
          }
          function ha(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0, F2 = 0, I2 = 0, J2 = 0;
            J2 = S;
            S = S + 112 | 0;
            D2 = J2 + 80 | 0;
            j = J2 + 72 | 0;
            E = J2;
            F2 = J2 + 56 | 0;
            k = a3 + 8 | 0;
            I2 = Wc((b[k >> 2] << 5) + 32 | 0) | 0;
            if (!I2) {
              H(22848, 22448, 800, 22456);
            }
            wc(a3, I2);
            g2 = a3;
            e3 = b[g2 + 4 >> 2] | 0;
            i3 = j;
            b[i3 >> 2] = b[g2 >> 2];
            b[i3 + 4 >> 2] = e3;
            vc(j, D2);
            i3 = ya(D2, c3) | 0;
            e3 = b[j >> 2] | 0;
            g2 = b[k >> 2] | 0;
            if ((g2 | 0) > 0) {
              h = b[a3 + 12 >> 2] | 0;
              f2 = 0;
              do {
                e3 = (b[h + (f2 << 3) >> 2] | 0) + e3 | 0;
                f2 = f2 + 1 | 0;
              } while ((f2 | 0) != (g2 | 0));
            }
            i3 = (i3 | 0) < (e3 | 0) ? e3 : i3;
            C2 = i3 + 12 | 0;
            f2 = Yc(C2, 8) | 0;
            l2 = Yc(C2, 8) | 0;
            b[D2 >> 2] = 0;
            A2 = a3;
            B2 = b[A2 + 4 >> 2] | 0;
            e3 = j;
            b[e3 >> 2] = b[A2 >> 2];
            b[e3 + 4 >> 2] = B2;
            e3 = ia(j, C2, c3, D2, f2, l2) | 0;
            if (e3 | 0) {
              Xc(f2);
              Xc(l2);
              Xc(I2);
              I2 = e3;
              S = J2;
              return I2 | 0;
            }
            a:
              do {
                if ((b[k >> 2] | 0) > 0) {
                  g2 = a3 + 12 | 0;
                  e3 = 0;
                  while (1) {
                    h = ia((b[g2 >> 2] | 0) + (e3 << 3) | 0, C2, c3, D2, f2, l2) | 0;
                    e3 = e3 + 1 | 0;
                    if (h | 0) {
                      break;
                    }
                    if ((e3 | 0) >= (b[k >> 2] | 0)) {
                      break a;
                    }
                  }
                  Xc(f2);
                  Xc(l2);
                  Xc(I2);
                  I2 = h;
                  S = J2;
                  return I2 | 0;
                }
              } while (0);
            if ((i3 | 0) > -12) {
              hd(l2 | 0, 0, ((C2 | 0) > 1 ? C2 : 1) << 3 | 0) | 0;
            }
            b:
              do {
                if ((b[D2 >> 2] | 0) > 0) {
                  B2 = ((C2 | 0) < 0) << 31 >> 31;
                  v2 = f2;
                  w2 = l2;
                  x3 = f2;
                  y3 = f2;
                  z2 = l2;
                  A2 = f2;
                  e3 = f2;
                  r3 = f2;
                  s3 = l2;
                  t3 = l2;
                  u2 = l2;
                  f2 = l2;
                  c:
                    while (1) {
                      q2 = b[D2 >> 2] | 0;
                      o2 = 0;
                      p3 = 0;
                      g2 = 0;
                      while (1) {
                        h = E;
                        i3 = h + 56 | 0;
                        do {
                          b[h >> 2] = 0;
                          h = h + 4 | 0;
                        } while ((h | 0) < (i3 | 0));
                        c3 = v2 + (o2 << 3) | 0;
                        j = b[c3 >> 2] | 0;
                        c3 = b[c3 + 4 >> 2] | 0;
                        if (ba(j, c3, 1, E, 0) | 0) {
                          h = E;
                          i3 = h + 56 | 0;
                          do {
                            b[h >> 2] = 0;
                            h = h + 4 | 0;
                          } while ((h | 0) < (i3 | 0));
                          h = Yc(7, 4) | 0;
                          if (h | 0) {
                            ca(j, c3, 1, E, h, 7, 0);
                            Xc(h);
                          }
                        }
                        n2 = 0;
                        do {
                          m = E + (n2 << 3) | 0;
                          l2 = b[m >> 2] | 0;
                          m = b[m + 4 >> 2] | 0;
                          d:
                            do {
                              if (!((l2 | 0) == 0 & (m | 0) == 0)) {
                                j = bd(l2 | 0, m | 0, C2 | 0, B2 | 0) | 0;
                                G() | 0;
                                h = d2 + (j << 3) | 0;
                                i3 = h;
                                c3 = b[i3 >> 2] | 0;
                                i3 = b[i3 + 4 >> 2] | 0;
                                if (!((c3 | 0) == 0 & (i3 | 0) == 0)) {
                                  k = 0;
                                  while (1) {
                                    if ((k | 0) > (C2 | 0)) {
                                      break c;
                                    }
                                    if ((c3 | 0) == (l2 | 0) & (i3 | 0) == (m | 0)) {
                                      break d;
                                    }
                                    j = (j + 1 | 0) % (C2 | 0) | 0;
                                    h = d2 + (j << 3) | 0;
                                    i3 = h;
                                    c3 = b[i3 >> 2] | 0;
                                    i3 = b[i3 + 4 >> 2] | 0;
                                    if ((c3 | 0) == 0 & (i3 | 0) == 0) {
                                      break;
                                    } else {
                                      k = k + 1 | 0;
                                    }
                                  }
                                }
                                if (!((l2 | 0) == 0 & (m | 0) == 0)) {
                                  Vb(l2, m, F2);
                                  if (xc(a3, I2, F2) | 0) {
                                    k = h;
                                    b[k >> 2] = l2;
                                    b[k + 4 >> 2] = m;
                                    k = w2 + (g2 << 3) | 0;
                                    b[k >> 2] = l2;
                                    b[k + 4 >> 2] = m;
                                    g2 = g2 + 1 | 0;
                                  }
                                }
                              }
                            } while (0);
                          n2 = n2 + 1 | 0;
                        } while (n2 >>> 0 < 7);
                        p3 = p3 + 1 | 0;
                        if ((p3 | 0) >= (q2 | 0)) {
                          break;
                        } else {
                          o2 = o2 + 1 | 0;
                        }
                      }
                      if ((q2 | 0) > 0) {
                        hd(x3 | 0, 0, q2 << 3 | 0) | 0;
                      }
                      b[D2 >> 2] = g2;
                      if ((g2 | 0) > 0) {
                        l2 = f2;
                        m = u2;
                        n2 = A2;
                        o2 = t3;
                        p3 = s3;
                        q2 = w2;
                        f2 = r3;
                        u2 = e3;
                        t3 = y3;
                        s3 = x3;
                        r3 = l2;
                        e3 = m;
                        A2 = z2;
                        z2 = n2;
                        y3 = o2;
                        x3 = p3;
                        w2 = v2;
                        v2 = q2;
                      } else {
                        break b;
                      }
                    }
                  Xc(y3);
                  Xc(z2);
                  Xc(I2);
                  I2 = -1;
                  S = J2;
                  return I2 | 0;
                } else {
                  e3 = l2;
                }
              } while (0);
            Xc(I2);
            Xc(f2);
            Xc(e3);
            I2 = 0;
            S = J2;
            return I2 | 0;
          }
          function ia(a3, c3, d2, f2, g2, h) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            f2 = f2 | 0;
            g2 = g2 | 0;
            h = h | 0;
            var i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0;
            C2 = S;
            S = S + 48 | 0;
            y3 = C2 + 32 | 0;
            z2 = C2 + 16 | 0;
            A2 = C2;
            i3 = b[a3 >> 2] | 0;
            if ((i3 | 0) <= 0) {
              B2 = 0;
              S = C2;
              return B2 | 0;
            }
            t3 = a3 + 4 | 0;
            u2 = y3 + 8 | 0;
            v2 = z2 + 8 | 0;
            w2 = A2 + 8 | 0;
            x3 = ((c3 | 0) < 0) << 31 >> 31;
            s3 = 0;
            a:
              while (1) {
                j = b[t3 >> 2] | 0;
                q2 = j + (s3 << 4) | 0;
                b[y3 >> 2] = b[q2 >> 2];
                b[y3 + 4 >> 2] = b[q2 + 4 >> 2];
                b[y3 + 8 >> 2] = b[q2 + 8 >> 2];
                b[y3 + 12 >> 2] = b[q2 + 12 >> 2];
                if ((s3 | 0) == (i3 + -1 | 0)) {
                  b[z2 >> 2] = b[j >> 2];
                  b[z2 + 4 >> 2] = b[j + 4 >> 2];
                  b[z2 + 8 >> 2] = b[j + 8 >> 2];
                  b[z2 + 12 >> 2] = b[j + 12 >> 2];
                } else {
                  q2 = j + (s3 + 1 << 4) | 0;
                  b[z2 >> 2] = b[q2 >> 2];
                  b[z2 + 4 >> 2] = b[q2 + 4 >> 2];
                  b[z2 + 8 >> 2] = b[q2 + 8 >> 2];
                  b[z2 + 12 >> 2] = b[q2 + 12 >> 2];
                }
                q2 = za(y3, z2, d2) | 0;
                b:
                  do {
                    if ((q2 | 0) > 0) {
                      r3 = +(q2 | 0);
                      p3 = 0;
                      c:
                        while (1) {
                          E = +(q2 - p3 | 0);
                          D2 = +(p3 | 0);
                          e2[A2 >> 3] = +e2[y3 >> 3] * E / r3 + +e2[z2 >> 3] * D2 / r3;
                          e2[w2 >> 3] = +e2[u2 >> 3] * E / r3 + +e2[v2 >> 3] * D2 / r3;
                          n2 = Sb(A2, d2) | 0;
                          o2 = G() | 0;
                          j = bd(n2 | 0, o2 | 0, c3 | 0, x3 | 0) | 0;
                          G() | 0;
                          i3 = h + (j << 3) | 0;
                          k = i3;
                          l2 = b[k >> 2] | 0;
                          k = b[k + 4 >> 2] | 0;
                          d:
                            do {
                              if ((l2 | 0) == 0 & (k | 0) == 0) {
                                B2 = 14;
                              } else {
                                m = 0;
                                while (1) {
                                  if ((m | 0) > (c3 | 0)) {
                                    i3 = 1;
                                    break d;
                                  }
                                  if ((l2 | 0) == (n2 | 0) & (k | 0) == (o2 | 0)) {
                                    i3 = 7;
                                    break d;
                                  }
                                  j = (j + 1 | 0) % (c3 | 0) | 0;
                                  i3 = h + (j << 3) | 0;
                                  k = i3;
                                  l2 = b[k >> 2] | 0;
                                  k = b[k + 4 >> 2] | 0;
                                  if ((l2 | 0) == 0 & (k | 0) == 0) {
                                    B2 = 14;
                                    break;
                                  } else {
                                    m = m + 1 | 0;
                                  }
                                }
                              }
                            } while (0);
                          if ((B2 | 0) == 14) {
                            B2 = 0;
                            if ((n2 | 0) == 0 & (o2 | 0) == 0) {
                              i3 = 7;
                            } else {
                              b[i3 >> 2] = n2;
                              b[i3 + 4 >> 2] = o2;
                              i3 = b[f2 >> 2] | 0;
                              m = g2 + (i3 << 3) | 0;
                              b[m >> 2] = n2;
                              b[m + 4 >> 2] = o2;
                              b[f2 >> 2] = i3 + 1;
                              i3 = 0;
                            }
                          }
                          switch (i3 & 7) {
                            case 7:
                            case 0:
                              break;
                            default:
                              break c;
                          }
                          p3 = p3 + 1 | 0;
                          if ((q2 | 0) <= (p3 | 0)) {
                            B2 = 8;
                            break b;
                          }
                        }
                      if (i3 | 0) {
                        i3 = -1;
                        B2 = 20;
                        break a;
                      }
                    } else {
                      B2 = 8;
                    }
                  } while (0);
                if ((B2 | 0) == 8) {
                  B2 = 0;
                }
                s3 = s3 + 1 | 0;
                i3 = b[a3 >> 2] | 0;
                if ((s3 | 0) >= (i3 | 0)) {
                  i3 = 0;
                  B2 = 20;
                  break;
                }
              }
            if ((B2 | 0) == 20) {
              S = C2;
              return i3 | 0;
            }
            return 0;
          }
          function ja(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
            k = S;
            S = S + 176 | 0;
            j = k;
            if ((c3 | 0) < 1) {
              Mc(d2, 0, 0);
              S = k;
              return;
            }
            h = a3;
            h = cd(b[h >> 2] | 0, b[h + 4 >> 2] | 0, 52) | 0;
            G() | 0;
            Mc(d2, (c3 | 0) > 6 ? c3 : 6, h & 15);
            h = 0;
            do {
              e3 = a3 + (h << 3) | 0;
              Wb(b[e3 >> 2] | 0, b[e3 + 4 >> 2] | 0, j);
              e3 = b[j >> 2] | 0;
              if ((e3 | 0) > 0) {
                i3 = 0;
                do {
                  g2 = j + 8 + (i3 << 4) | 0;
                  i3 = i3 + 1 | 0;
                  e3 = j + 8 + (((i3 | 0) % (e3 | 0) | 0) << 4) | 0;
                  f2 = Rc(d2, e3, g2) | 0;
                  if (!f2) {
                    Qc(d2, g2, e3) | 0;
                  } else {
                    Pc(d2, f2) | 0;
                  }
                  e3 = b[j >> 2] | 0;
                } while ((i3 | 0) < (e3 | 0));
              }
              h = h + 1 | 0;
            } while ((h | 0) != (c3 | 0));
            S = k;
            return;
          }
          function ka(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0;
            g2 = S;
            S = S + 32 | 0;
            e3 = g2;
            f2 = g2 + 16 | 0;
            ja(a3, c3, f2);
            b[d2 >> 2] = 0;
            b[d2 + 4 >> 2] = 0;
            b[d2 + 8 >> 2] = 0;
            a3 = Oc(f2) | 0;
            if (!a3) {
              kc(d2) | 0;
              Nc(f2);
              S = g2;
              return;
            }
            do {
              c3 = hc(d2) | 0;
              do {
                ic(c3, a3) | 0;
                h = a3 + 16 | 0;
                b[e3 >> 2] = b[h >> 2];
                b[e3 + 4 >> 2] = b[h + 4 >> 2];
                b[e3 + 8 >> 2] = b[h + 8 >> 2];
                b[e3 + 12 >> 2] = b[h + 12 >> 2];
                Pc(f2, a3) | 0;
                a3 = Sc(f2, e3) | 0;
              } while ((a3 | 0) != 0);
              a3 = Oc(f2) | 0;
            } while ((a3 | 0) != 0);
            kc(d2) | 0;
            Nc(f2);
            S = g2;
            return;
          }
          function la(a3) {
            a3 = a3 | 0;
            return b[7728 + (a3 * 28 | 0) + 16 >> 2] | 0;
          }
          function ma(a3) {
            a3 = a3 | 0;
            return (a3 | 0) == 4 | (a3 | 0) == 117 | 0;
          }
          function na(a3) {
            a3 = a3 | 0;
            return b[11152 + ((b[a3 >> 2] | 0) * 216 | 0) + ((b[a3 + 4 >> 2] | 0) * 72 | 0) + ((b[a3 + 8 >> 2] | 0) * 24 | 0) + (b[a3 + 12 >> 2] << 3) >> 2] | 0;
          }
          function oa(a3) {
            a3 = a3 | 0;
            return b[11152 + ((b[a3 >> 2] | 0) * 216 | 0) + ((b[a3 + 4 >> 2] | 0) * 72 | 0) + ((b[a3 + 8 >> 2] | 0) * 24 | 0) + (b[a3 + 12 >> 2] << 3) + 4 >> 2] | 0;
          }
          function pa(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            a3 = 7728 + (a3 * 28 | 0) | 0;
            b[c3 >> 2] = b[a3 >> 2];
            b[c3 + 4 >> 2] = b[a3 + 4 >> 2];
            b[c3 + 8 >> 2] = b[a3 + 8 >> 2];
            b[c3 + 12 >> 2] = b[a3 + 12 >> 2];
            return;
          }
          function qa(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            if (c3 >>> 0 > 20) {
              c3 = -1;
              return c3 | 0;
            }
            do {
              if ((b[11152 + (c3 * 216 | 0) >> 2] | 0) != (a3 | 0)) {
                if ((b[11152 + (c3 * 216 | 0) + 8 >> 2] | 0) != (a3 | 0)) {
                  if ((b[11152 + (c3 * 216 | 0) + 16 >> 2] | 0) != (a3 | 0)) {
                    if ((b[11152 + (c3 * 216 | 0) + 24 >> 2] | 0) != (a3 | 0)) {
                      if ((b[11152 + (c3 * 216 | 0) + 32 >> 2] | 0) != (a3 | 0)) {
                        if ((b[11152 + (c3 * 216 | 0) + 40 >> 2] | 0) != (a3 | 0)) {
                          if ((b[11152 + (c3 * 216 | 0) + 48 >> 2] | 0) != (a3 | 0)) {
                            if ((b[11152 + (c3 * 216 | 0) + 56 >> 2] | 0) != (a3 | 0)) {
                              if ((b[11152 + (c3 * 216 | 0) + 64 >> 2] | 0) != (a3 | 0)) {
                                if ((b[11152 + (c3 * 216 | 0) + 72 >> 2] | 0) != (a3 | 0)) {
                                  if ((b[11152 + (c3 * 216 | 0) + 80 >> 2] | 0) != (a3 | 0)) {
                                    if ((b[11152 + (c3 * 216 | 0) + 88 >> 2] | 0) != (a3 | 0)) {
                                      if ((b[11152 + (c3 * 216 | 0) + 96 >> 2] | 0) != (a3 | 0)) {
                                        if ((b[11152 + (c3 * 216 | 0) + 104 >> 2] | 0) != (a3 | 0)) {
                                          if ((b[11152 + (c3 * 216 | 0) + 112 >> 2] | 0) != (a3 | 0)) {
                                            if ((b[11152 + (c3 * 216 | 0) + 120 >> 2] | 0) != (a3 | 0)) {
                                              if ((b[11152 + (c3 * 216 | 0) + 128 >> 2] | 0) != (a3 | 0)) {
                                                if ((b[11152 + (c3 * 216 | 0) + 136 >> 2] | 0) == (a3 | 0)) {
                                                  a3 = 2;
                                                  d2 = 1;
                                                  e3 = 2;
                                                } else {
                                                  if ((b[11152 + (c3 * 216 | 0) + 144 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 0;
                                                    d2 = 2;
                                                    e3 = 0;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 152 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 0;
                                                    d2 = 2;
                                                    e3 = 1;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 160 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 0;
                                                    d2 = 2;
                                                    e3 = 2;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 168 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 1;
                                                    d2 = 2;
                                                    e3 = 0;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 176 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 1;
                                                    d2 = 2;
                                                    e3 = 1;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 184 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 1;
                                                    d2 = 2;
                                                    e3 = 2;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 192 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 2;
                                                    d2 = 2;
                                                    e3 = 0;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 200 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 2;
                                                    d2 = 2;
                                                    e3 = 1;
                                                    break;
                                                  }
                                                  if ((b[11152 + (c3 * 216 | 0) + 208 >> 2] | 0) == (a3 | 0)) {
                                                    a3 = 2;
                                                    d2 = 2;
                                                    e3 = 2;
                                                    break;
                                                  } else {
                                                    a3 = -1;
                                                  }
                                                  return a3 | 0;
                                                }
                                              } else {
                                                a3 = 2;
                                                d2 = 1;
                                                e3 = 1;
                                              }
                                            } else {
                                              a3 = 2;
                                              d2 = 1;
                                              e3 = 0;
                                            }
                                          } else {
                                            a3 = 1;
                                            d2 = 1;
                                            e3 = 2;
                                          }
                                        } else {
                                          a3 = 1;
                                          d2 = 1;
                                          e3 = 1;
                                        }
                                      } else {
                                        a3 = 1;
                                        d2 = 1;
                                        e3 = 0;
                                      }
                                    } else {
                                      a3 = 0;
                                      d2 = 1;
                                      e3 = 2;
                                    }
                                  } else {
                                    a3 = 0;
                                    d2 = 1;
                                    e3 = 1;
                                  }
                                } else {
                                  a3 = 0;
                                  d2 = 1;
                                  e3 = 0;
                                }
                              } else {
                                a3 = 2;
                                d2 = 0;
                                e3 = 2;
                              }
                            } else {
                              a3 = 2;
                              d2 = 0;
                              e3 = 1;
                            }
                          } else {
                            a3 = 2;
                            d2 = 0;
                            e3 = 0;
                          }
                        } else {
                          a3 = 1;
                          d2 = 0;
                          e3 = 2;
                        }
                      } else {
                        a3 = 1;
                        d2 = 0;
                        e3 = 1;
                      }
                    } else {
                      a3 = 1;
                      d2 = 0;
                      e3 = 0;
                    }
                  } else {
                    a3 = 0;
                    d2 = 0;
                    e3 = 2;
                  }
                } else {
                  a3 = 0;
                  d2 = 0;
                  e3 = 1;
                }
              } else {
                a3 = 0;
                d2 = 0;
                e3 = 0;
              }
            } while (0);
            c3 = b[11152 + (c3 * 216 | 0) + (d2 * 72 | 0) + (a3 * 24 | 0) + (e3 << 3) + 4 >> 2] | 0;
            return c3 | 0;
          }
          function ra(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            if ((b[7728 + (a3 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
              c3 = 1;
              return c3 | 0;
            }
            c3 = (b[7728 + (a3 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0);
            return c3 | 0;
          }
          function sa(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            return b[880 + (a3 * 28 | 0) + (c3 << 2) >> 2] | 0;
          }
          function ta(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            if ((b[880 + (a3 * 28 | 0) >> 2] | 0) == (c3 | 0)) {
              c3 = 0;
              return c3 | 0;
            }
            if ((b[880 + (a3 * 28 | 0) + 4 >> 2] | 0) == (c3 | 0)) {
              c3 = 1;
              return c3 | 0;
            }
            if ((b[880 + (a3 * 28 | 0) + 8 >> 2] | 0) == (c3 | 0)) {
              c3 = 2;
              return c3 | 0;
            }
            if ((b[880 + (a3 * 28 | 0) + 12 >> 2] | 0) == (c3 | 0)) {
              c3 = 3;
              return c3 | 0;
            }
            if ((b[880 + (a3 * 28 | 0) + 16 >> 2] | 0) == (c3 | 0)) {
              c3 = 4;
              return c3 | 0;
            }
            if ((b[880 + (a3 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
              c3 = 5;
              return c3 | 0;
            } else {
              return ((b[880 + (a3 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0) ? 6 : 7) | 0;
            }
            return 0;
          }
          function ua() {
            return 122;
          }
          function va(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0;
            c3 = 0;
            do {
              dd(c3 | 0, 0, 45) | 0;
              e3 = G() | 0 | 134225919;
              d2 = a3 + (c3 << 3) | 0;
              b[d2 >> 2] = -1;
              b[d2 + 4 >> 2] = e3;
              c3 = c3 + 1 | 0;
            } while ((c3 | 0) != 122);
            return;
          }
          function wa(a3) {
            a3 = a3 | 0;
            return +e2[a3 + 16 >> 3] < +e2[a3 + 24 >> 3] | 0;
          }
          function xa(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, f2 = 0;
            c3 = +e2[b2 >> 3];
            if (!(c3 >= +e2[a3 + 8 >> 3])) {
              b2 = 0;
              return b2 | 0;
            }
            if (!(c3 <= +e2[a3 >> 3])) {
              b2 = 0;
              return b2 | 0;
            }
            d2 = +e2[a3 + 16 >> 3];
            c3 = +e2[a3 + 24 >> 3];
            f2 = +e2[b2 + 8 >> 3];
            b2 = f2 >= c3;
            a3 = f2 <= d2 & 1;
            if (d2 < c3) {
              if (b2) {
                a3 = 1;
              }
            } else if (!b2) {
              a3 = 0;
            }
            b2 = (a3 | 0) != 0;
            return b2 | 0;
          }
          function ya(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            i3 = S;
            S = S + 288 | 0;
            d2 = i3 + 264 | 0;
            f2 = i3 + 96 | 0;
            g2 = i3;
            h = g2;
            j = h + 96 | 0;
            do {
              b[h >> 2] = 0;
              h = h + 4 | 0;
            } while ((h | 0) < (j | 0));
            _b(c3, g2);
            h = g2;
            j = b[h >> 2] | 0;
            h = b[h + 4 >> 2] | 0;
            Vb(j, h, d2);
            Wb(j, h, f2);
            k = +jb(d2, f2 + 8 | 0);
            e2[d2 >> 3] = +e2[a3 >> 3];
            h = d2 + 8 | 0;
            e2[h >> 3] = +e2[a3 + 16 >> 3];
            e2[f2 >> 3] = +e2[a3 + 8 >> 3];
            j = f2 + 8 | 0;
            e2[j >> 3] = +e2[a3 + 24 >> 3];
            l2 = +jb(d2, f2);
            j = ~~+A(+(l2 * l2 / +ed(+ +q(+((+e2[h >> 3] - +e2[j >> 3]) / (+e2[d2 >> 3] - +e2[f2 >> 3]))), 3) / (k * (k * 2.59807621135) * 0.8)));
            S = i3;
            return ((j | 0) == 0 ? 1 : j) | 0;
          }
          function za(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
            i3 = S;
            S = S + 288 | 0;
            e3 = i3 + 264 | 0;
            f2 = i3 + 96 | 0;
            g2 = i3;
            h = g2;
            j = h + 96 | 0;
            do {
              b[h >> 2] = 0;
              h = h + 4 | 0;
            } while ((h | 0) < (j | 0));
            _b(d2, g2);
            j = g2;
            h = b[j >> 2] | 0;
            j = b[j + 4 >> 2] | 0;
            Vb(h, j, e3);
            Wb(h, j, f2);
            k = +jb(e3, f2 + 8 | 0);
            j = ~~+A(+(+jb(a3, c3) / (k * 2)));
            S = i3;
            return ((j | 0) == 0 ? 1 : j) | 0;
          }
          function Aa(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            b[a3 >> 2] = c3;
            b[a3 + 4 >> 2] = d2;
            b[a3 + 8 >> 2] = e3;
            return;
          }
          function Ba(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0;
            n2 = c3 + 8 | 0;
            b[n2 >> 2] = 0;
            k = +e2[a3 >> 3];
            i3 = +q(+k);
            l2 = +e2[a3 + 8 >> 3];
            j = +q(+l2) / 0.8660254037844386;
            i3 = i3 + j * 0.5;
            d2 = ~~i3;
            a3 = ~~j;
            i3 = i3 - +(d2 | 0);
            j = j - +(a3 | 0);
            do {
              if (i3 < 0.5) {
                if (i3 < 0.3333333333333333) {
                  b[c3 >> 2] = d2;
                  if (j < (i3 + 1) * 0.5) {
                    b[c3 + 4 >> 2] = a3;
                    break;
                  } else {
                    a3 = a3 + 1 | 0;
                    b[c3 + 4 >> 2] = a3;
                    break;
                  }
                } else {
                  o2 = 1 - i3;
                  a3 = (!(j < o2) & 1) + a3 | 0;
                  b[c3 + 4 >> 2] = a3;
                  if (o2 <= j & j < i3 * 2) {
                    d2 = d2 + 1 | 0;
                    b[c3 >> 2] = d2;
                    break;
                  } else {
                    b[c3 >> 2] = d2;
                    break;
                  }
                }
              } else {
                if (!(i3 < 0.6666666666666666)) {
                  d2 = d2 + 1 | 0;
                  b[c3 >> 2] = d2;
                  if (j < i3 * 0.5) {
                    b[c3 + 4 >> 2] = a3;
                    break;
                  } else {
                    a3 = a3 + 1 | 0;
                    b[c3 + 4 >> 2] = a3;
                    break;
                  }
                }
                if (j < 1 - i3) {
                  b[c3 + 4 >> 2] = a3;
                  if (i3 * 2 + -1 < j) {
                    b[c3 >> 2] = d2;
                    break;
                  }
                } else {
                  a3 = a3 + 1 | 0;
                  b[c3 + 4 >> 2] = a3;
                }
                d2 = d2 + 1 | 0;
                b[c3 >> 2] = d2;
              }
            } while (0);
            do {
              if (k < 0) {
                if (!(a3 & 1)) {
                  m = (a3 | 0) / 2 | 0;
                  m = _c(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
                  d2 = ~~(+(d2 | 0) - (+(m >>> 0) + 4294967296 * +(G() | 0)) * 2);
                  b[c3 >> 2] = d2;
                  break;
                } else {
                  m = (a3 + 1 | 0) / 2 | 0;
                  m = _c(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
                  d2 = ~~(+(d2 | 0) - ((+(m >>> 0) + 4294967296 * +(G() | 0)) * 2 + 1));
                  b[c3 >> 2] = d2;
                  break;
                }
              }
            } while (0);
            m = c3 + 4 | 0;
            if (l2 < 0) {
              d2 = d2 - ((a3 << 1 | 1 | 0) / 2 | 0) | 0;
              b[c3 >> 2] = d2;
              a3 = 0 - a3 | 0;
              b[m >> 2] = a3;
            }
            f2 = a3 - d2 | 0;
            if ((d2 | 0) < 0) {
              g2 = 0 - d2 | 0;
              b[m >> 2] = f2;
              b[n2 >> 2] = g2;
              b[c3 >> 2] = 0;
              a3 = f2;
              d2 = 0;
            } else {
              g2 = 0;
            }
            if ((a3 | 0) < 0) {
              d2 = d2 - a3 | 0;
              b[c3 >> 2] = d2;
              g2 = g2 - a3 | 0;
              b[n2 >> 2] = g2;
              b[m >> 2] = 0;
              a3 = 0;
            }
            h = d2 - g2 | 0;
            f2 = a3 - g2 | 0;
            if ((g2 | 0) < 0) {
              b[c3 >> 2] = h;
              b[m >> 2] = f2;
              b[n2 >> 2] = 0;
              a3 = f2;
              d2 = h;
              g2 = 0;
            }
            f2 = (a3 | 0) < (d2 | 0) ? a3 : d2;
            f2 = (g2 | 0) < (f2 | 0) ? g2 : f2;
            if ((f2 | 0) <= 0) {
              return;
            }
            b[c3 >> 2] = d2 - f2;
            b[m >> 2] = a3 - f2;
            b[n2 >> 2] = g2 - f2;
            return;
          }
          function Ca(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
            c3 = b[a3 >> 2] | 0;
            h = a3 + 4 | 0;
            d2 = b[h >> 2] | 0;
            if ((c3 | 0) < 0) {
              d2 = d2 - c3 | 0;
              b[h >> 2] = d2;
              g2 = a3 + 8 | 0;
              b[g2 >> 2] = (b[g2 >> 2] | 0) - c3;
              b[a3 >> 2] = 0;
              c3 = 0;
            }
            if ((d2 | 0) < 0) {
              c3 = c3 - d2 | 0;
              b[a3 >> 2] = c3;
              g2 = a3 + 8 | 0;
              f2 = (b[g2 >> 2] | 0) - d2 | 0;
              b[g2 >> 2] = f2;
              b[h >> 2] = 0;
              d2 = 0;
            } else {
              f2 = a3 + 8 | 0;
              g2 = f2;
              f2 = b[f2 >> 2] | 0;
            }
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[a3 >> 2] = c3;
              d2 = d2 - f2 | 0;
              b[h >> 2] = d2;
              b[g2 >> 2] = 0;
              f2 = 0;
            }
            e3 = (d2 | 0) < (c3 | 0) ? d2 : c3;
            e3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
            if ((e3 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = c3 - e3;
            b[h >> 2] = d2 - e3;
            b[g2 >> 2] = f2 - e3;
            return;
          }
          function Da(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0;
            f2 = b[a3 + 8 >> 2] | 0;
            d2 = +((b[a3 + 4 >> 2] | 0) - f2 | 0);
            e2[c3 >> 3] = +((b[a3 >> 2] | 0) - f2 | 0) - d2 * 0.5;
            e2[c3 + 8 >> 3] = d2 * 0.8660254037844386;
            return;
          }
          function Ea(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            b[d2 >> 2] = (b[c3 >> 2] | 0) + (b[a3 >> 2] | 0);
            b[d2 + 4 >> 2] = (b[c3 + 4 >> 2] | 0) + (b[a3 + 4 >> 2] | 0);
            b[d2 + 8 >> 2] = (b[c3 + 8 >> 2] | 0) + (b[a3 + 8 >> 2] | 0);
            return;
          }
          function Fa(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            b[d2 >> 2] = (b[a3 >> 2] | 0) - (b[c3 >> 2] | 0);
            b[d2 + 4 >> 2] = (b[a3 + 4 >> 2] | 0) - (b[c3 + 4 >> 2] | 0);
            b[d2 + 8 >> 2] = (b[a3 + 8 >> 2] | 0) - (b[c3 + 8 >> 2] | 0);
            return;
          }
          function Ga(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            d2 = B(b[a3 >> 2] | 0, c3) | 0;
            b[a3 >> 2] = d2;
            d2 = a3 + 4 | 0;
            e3 = B(b[d2 >> 2] | 0, c3) | 0;
            b[d2 >> 2] = e3;
            a3 = a3 + 8 | 0;
            c3 = B(b[a3 >> 2] | 0, c3) | 0;
            b[a3 >> 2] = c3;
            return;
          }
          function Ha(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            h = b[a3 >> 2] | 0;
            i3 = (h | 0) < 0;
            e3 = (b[a3 + 4 >> 2] | 0) - (i3 ? h : 0) | 0;
            g2 = (e3 | 0) < 0;
            f2 = (g2 ? 0 - e3 | 0 : 0) + ((b[a3 + 8 >> 2] | 0) - (i3 ? h : 0)) | 0;
            d2 = (f2 | 0) < 0;
            a3 = d2 ? 0 : f2;
            c3 = (g2 ? 0 : e3) - (d2 ? f2 : 0) | 0;
            f2 = (i3 ? 0 : h) - (g2 ? e3 : 0) - (d2 ? f2 : 0) | 0;
            d2 = (c3 | 0) < (f2 | 0) ? c3 : f2;
            d2 = (a3 | 0) < (d2 | 0) ? a3 : d2;
            e3 = (d2 | 0) > 0;
            a3 = a3 - (e3 ? d2 : 0) | 0;
            c3 = c3 - (e3 ? d2 : 0) | 0;
            a:
              do {
                switch (f2 - (e3 ? d2 : 0) | 0) {
                  case 0:
                    switch (c3 | 0) {
                      case 0: {
                        i3 = (a3 | 0) == 0 ? 0 : (a3 | 0) == 1 ? 1 : 7;
                        return i3 | 0;
                      }
                      case 1: {
                        i3 = (a3 | 0) == 0 ? 2 : (a3 | 0) == 1 ? 3 : 7;
                        return i3 | 0;
                      }
                      default:
                        break a;
                    }
                  case 1:
                    switch (c3 | 0) {
                      case 0: {
                        i3 = (a3 | 0) == 0 ? 4 : (a3 | 0) == 1 ? 5 : 7;
                        return i3 | 0;
                      }
                      case 1: {
                        if (!a3) {
                          a3 = 6;
                        } else {
                          break a;
                        }
                        return a3 | 0;
                      }
                      default:
                        break a;
                    }
                  default:
                }
              } while (0);
            i3 = 7;
            return i3 | 0;
          }
          function Ia(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            h = a3 + 8 | 0;
            d2 = b[h >> 2] | 0;
            c3 = (b[a3 >> 2] | 0) - d2 | 0;
            i3 = a3 + 4 | 0;
            d2 = (b[i3 >> 2] | 0) - d2 | 0;
            e3 = Vc(+((c3 * 3 | 0) - d2 | 0) / 7) | 0;
            b[a3 >> 2] = e3;
            c3 = Vc(+((d2 << 1) + c3 | 0) / 7) | 0;
            b[i3 >> 2] = c3;
            b[h >> 2] = 0;
            d2 = c3 - e3 | 0;
            if ((e3 | 0) < 0) {
              g2 = 0 - e3 | 0;
              b[i3 >> 2] = d2;
              b[h >> 2] = g2;
              b[a3 >> 2] = 0;
              c3 = d2;
              e3 = 0;
              d2 = g2;
            } else {
              d2 = 0;
            }
            if ((c3 | 0) < 0) {
              e3 = e3 - c3 | 0;
              b[a3 >> 2] = e3;
              d2 = d2 - c3 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = 0;
              c3 = 0;
            }
            g2 = e3 - d2 | 0;
            f2 = c3 - d2 | 0;
            if ((d2 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[i3 >> 2] = f2;
              b[h >> 2] = 0;
              c3 = f2;
              f2 = g2;
              d2 = 0;
            } else {
              f2 = e3;
            }
            e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
            e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
            if ((e3 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = f2 - e3;
            b[i3 >> 2] = c3 - e3;
            b[h >> 2] = d2 - e3;
            return;
          }
          function Ja(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            h = a3 + 8 | 0;
            d2 = b[h >> 2] | 0;
            c3 = (b[a3 >> 2] | 0) - d2 | 0;
            i3 = a3 + 4 | 0;
            d2 = (b[i3 >> 2] | 0) - d2 | 0;
            e3 = Vc(+((c3 << 1) + d2 | 0) / 7) | 0;
            b[a3 >> 2] = e3;
            c3 = Vc(+((d2 * 3 | 0) - c3 | 0) / 7) | 0;
            b[i3 >> 2] = c3;
            b[h >> 2] = 0;
            d2 = c3 - e3 | 0;
            if ((e3 | 0) < 0) {
              g2 = 0 - e3 | 0;
              b[i3 >> 2] = d2;
              b[h >> 2] = g2;
              b[a3 >> 2] = 0;
              c3 = d2;
              e3 = 0;
              d2 = g2;
            } else {
              d2 = 0;
            }
            if ((c3 | 0) < 0) {
              e3 = e3 - c3 | 0;
              b[a3 >> 2] = e3;
              d2 = d2 - c3 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = 0;
              c3 = 0;
            }
            g2 = e3 - d2 | 0;
            f2 = c3 - d2 | 0;
            if ((d2 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[i3 >> 2] = f2;
              b[h >> 2] = 0;
              c3 = f2;
              f2 = g2;
              d2 = 0;
            } else {
              f2 = e3;
            }
            e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
            e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
            if ((e3 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = f2 - e3;
            b[i3 >> 2] = c3 - e3;
            b[h >> 2] = d2 - e3;
            return;
          }
          function Ka(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            c3 = b[a3 >> 2] | 0;
            h = a3 + 4 | 0;
            d2 = b[h >> 2] | 0;
            i3 = a3 + 8 | 0;
            e3 = b[i3 >> 2] | 0;
            f2 = d2 + (c3 * 3 | 0) | 0;
            b[a3 >> 2] = f2;
            d2 = e3 + (d2 * 3 | 0) | 0;
            b[h >> 2] = d2;
            c3 = (e3 * 3 | 0) + c3 | 0;
            b[i3 >> 2] = c3;
            e3 = d2 - f2 | 0;
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[h >> 2] = e3;
              b[i3 >> 2] = c3;
              b[a3 >> 2] = 0;
              d2 = e3;
              e3 = 0;
            } else {
              e3 = f2;
            }
            if ((d2 | 0) < 0) {
              e3 = e3 - d2 | 0;
              b[a3 >> 2] = e3;
              c3 = c3 - d2 | 0;
              b[i3 >> 2] = c3;
              b[h >> 2] = 0;
              d2 = 0;
            }
            g2 = e3 - c3 | 0;
            f2 = d2 - c3 | 0;
            if ((c3 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[h >> 2] = f2;
              b[i3 >> 2] = 0;
              e3 = g2;
              c3 = 0;
            } else {
              f2 = d2;
            }
            d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
            d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
            if ((d2 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = e3 - d2;
            b[h >> 2] = f2 - d2;
            b[i3 >> 2] = c3 - d2;
            return;
          }
          function La(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            f2 = b[a3 >> 2] | 0;
            h = a3 + 4 | 0;
            c3 = b[h >> 2] | 0;
            i3 = a3 + 8 | 0;
            d2 = b[i3 >> 2] | 0;
            e3 = (c3 * 3 | 0) + f2 | 0;
            f2 = d2 + (f2 * 3 | 0) | 0;
            b[a3 >> 2] = f2;
            b[h >> 2] = e3;
            c3 = (d2 * 3 | 0) + c3 | 0;
            b[i3 >> 2] = c3;
            d2 = e3 - f2 | 0;
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = c3;
              b[a3 >> 2] = 0;
              f2 = 0;
            } else {
              d2 = e3;
            }
            if ((d2 | 0) < 0) {
              f2 = f2 - d2 | 0;
              b[a3 >> 2] = f2;
              c3 = c3 - d2 | 0;
              b[i3 >> 2] = c3;
              b[h >> 2] = 0;
              d2 = 0;
            }
            g2 = f2 - c3 | 0;
            e3 = d2 - c3 | 0;
            if ((c3 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[h >> 2] = e3;
              b[i3 >> 2] = 0;
              f2 = g2;
              c3 = 0;
            } else {
              e3 = d2;
            }
            d2 = (e3 | 0) < (f2 | 0) ? e3 : f2;
            d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
            if ((d2 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = f2 - d2;
            b[h >> 2] = e3 - d2;
            b[i3 >> 2] = c3 - d2;
            return;
          }
          function Ma(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            if ((c3 + -1 | 0) >>> 0 >= 6) {
              return;
            }
            f2 = (b[15472 + (c3 * 12 | 0) >> 2] | 0) + (b[a3 >> 2] | 0) | 0;
            b[a3 >> 2] = f2;
            i3 = a3 + 4 | 0;
            e3 = (b[15472 + (c3 * 12 | 0) + 4 >> 2] | 0) + (b[i3 >> 2] | 0) | 0;
            b[i3 >> 2] = e3;
            h = a3 + 8 | 0;
            c3 = (b[15472 + (c3 * 12 | 0) + 8 >> 2] | 0) + (b[h >> 2] | 0) | 0;
            b[h >> 2] = c3;
            d2 = e3 - f2 | 0;
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[i3 >> 2] = d2;
              b[h >> 2] = c3;
              b[a3 >> 2] = 0;
              e3 = 0;
            } else {
              d2 = e3;
              e3 = f2;
            }
            if ((d2 | 0) < 0) {
              e3 = e3 - d2 | 0;
              b[a3 >> 2] = e3;
              c3 = c3 - d2 | 0;
              b[h >> 2] = c3;
              b[i3 >> 2] = 0;
              d2 = 0;
            }
            g2 = e3 - c3 | 0;
            f2 = d2 - c3 | 0;
            if ((c3 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[i3 >> 2] = f2;
              b[h >> 2] = 0;
              e3 = g2;
              c3 = 0;
            } else {
              f2 = d2;
            }
            d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
            d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
            if ((d2 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = e3 - d2;
            b[i3 >> 2] = f2 - d2;
            b[h >> 2] = c3 - d2;
            return;
          }
          function Na(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            f2 = b[a3 >> 2] | 0;
            h = a3 + 4 | 0;
            c3 = b[h >> 2] | 0;
            i3 = a3 + 8 | 0;
            d2 = b[i3 >> 2] | 0;
            e3 = c3 + f2 | 0;
            f2 = d2 + f2 | 0;
            b[a3 >> 2] = f2;
            b[h >> 2] = e3;
            c3 = d2 + c3 | 0;
            b[i3 >> 2] = c3;
            d2 = e3 - f2 | 0;
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = c3;
              b[a3 >> 2] = 0;
              e3 = 0;
            } else {
              d2 = e3;
              e3 = f2;
            }
            if ((d2 | 0) < 0) {
              e3 = e3 - d2 | 0;
              b[a3 >> 2] = e3;
              c3 = c3 - d2 | 0;
              b[i3 >> 2] = c3;
              b[h >> 2] = 0;
              d2 = 0;
            }
            g2 = e3 - c3 | 0;
            f2 = d2 - c3 | 0;
            if ((c3 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[h >> 2] = f2;
              b[i3 >> 2] = 0;
              e3 = g2;
              c3 = 0;
            } else {
              f2 = d2;
            }
            d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
            d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
            if ((d2 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = e3 - d2;
            b[h >> 2] = f2 - d2;
            b[i3 >> 2] = c3 - d2;
            return;
          }
          function Oa(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            c3 = b[a3 >> 2] | 0;
            h = a3 + 4 | 0;
            e3 = b[h >> 2] | 0;
            i3 = a3 + 8 | 0;
            d2 = b[i3 >> 2] | 0;
            f2 = e3 + c3 | 0;
            b[a3 >> 2] = f2;
            e3 = d2 + e3 | 0;
            b[h >> 2] = e3;
            c3 = d2 + c3 | 0;
            b[i3 >> 2] = c3;
            d2 = e3 - f2 | 0;
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = c3;
              b[a3 >> 2] = 0;
              e3 = 0;
            } else {
              d2 = e3;
              e3 = f2;
            }
            if ((d2 | 0) < 0) {
              e3 = e3 - d2 | 0;
              b[a3 >> 2] = e3;
              c3 = c3 - d2 | 0;
              b[i3 >> 2] = c3;
              b[h >> 2] = 0;
              d2 = 0;
            }
            g2 = e3 - c3 | 0;
            f2 = d2 - c3 | 0;
            if ((c3 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[h >> 2] = f2;
              b[i3 >> 2] = 0;
              e3 = g2;
              c3 = 0;
            } else {
              f2 = d2;
            }
            d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
            d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
            if ((d2 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = e3 - d2;
            b[h >> 2] = f2 - d2;
            b[i3 >> 2] = c3 - d2;
            return;
          }
          function Pa(a3) {
            a3 = a3 | 0;
            switch (a3 | 0) {
              case 1: {
                a3 = 5;
                break;
              }
              case 5: {
                a3 = 4;
                break;
              }
              case 4: {
                a3 = 6;
                break;
              }
              case 6: {
                a3 = 2;
                break;
              }
              case 2: {
                a3 = 3;
                break;
              }
              case 3: {
                a3 = 1;
                break;
              }
              default:
            }
            return a3 | 0;
          }
          function Qa(a3) {
            a3 = a3 | 0;
            switch (a3 | 0) {
              case 1: {
                a3 = 3;
                break;
              }
              case 3: {
                a3 = 2;
                break;
              }
              case 2: {
                a3 = 6;
                break;
              }
              case 6: {
                a3 = 4;
                break;
              }
              case 4: {
                a3 = 5;
                break;
              }
              case 5: {
                a3 = 1;
                break;
              }
              default:
            }
            return a3 | 0;
          }
          function Ra(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            c3 = b[a3 >> 2] | 0;
            h = a3 + 4 | 0;
            d2 = b[h >> 2] | 0;
            i3 = a3 + 8 | 0;
            e3 = b[i3 >> 2] | 0;
            f2 = d2 + (c3 << 1) | 0;
            b[a3 >> 2] = f2;
            d2 = e3 + (d2 << 1) | 0;
            b[h >> 2] = d2;
            c3 = (e3 << 1) + c3 | 0;
            b[i3 >> 2] = c3;
            e3 = d2 - f2 | 0;
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[h >> 2] = e3;
              b[i3 >> 2] = c3;
              b[a3 >> 2] = 0;
              d2 = e3;
              e3 = 0;
            } else {
              e3 = f2;
            }
            if ((d2 | 0) < 0) {
              e3 = e3 - d2 | 0;
              b[a3 >> 2] = e3;
              c3 = c3 - d2 | 0;
              b[i3 >> 2] = c3;
              b[h >> 2] = 0;
              d2 = 0;
            }
            g2 = e3 - c3 | 0;
            f2 = d2 - c3 | 0;
            if ((c3 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[h >> 2] = f2;
              b[i3 >> 2] = 0;
              e3 = g2;
              c3 = 0;
            } else {
              f2 = d2;
            }
            d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
            d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
            if ((d2 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = e3 - d2;
            b[h >> 2] = f2 - d2;
            b[i3 >> 2] = c3 - d2;
            return;
          }
          function Sa(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            f2 = b[a3 >> 2] | 0;
            h = a3 + 4 | 0;
            c3 = b[h >> 2] | 0;
            i3 = a3 + 8 | 0;
            d2 = b[i3 >> 2] | 0;
            e3 = (c3 << 1) + f2 | 0;
            f2 = d2 + (f2 << 1) | 0;
            b[a3 >> 2] = f2;
            b[h >> 2] = e3;
            c3 = (d2 << 1) + c3 | 0;
            b[i3 >> 2] = c3;
            d2 = e3 - f2 | 0;
            if ((f2 | 0) < 0) {
              c3 = c3 - f2 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = c3;
              b[a3 >> 2] = 0;
              f2 = 0;
            } else {
              d2 = e3;
            }
            if ((d2 | 0) < 0) {
              f2 = f2 - d2 | 0;
              b[a3 >> 2] = f2;
              c3 = c3 - d2 | 0;
              b[i3 >> 2] = c3;
              b[h >> 2] = 0;
              d2 = 0;
            }
            g2 = f2 - c3 | 0;
            e3 = d2 - c3 | 0;
            if ((c3 | 0) < 0) {
              b[a3 >> 2] = g2;
              b[h >> 2] = e3;
              b[i3 >> 2] = 0;
              f2 = g2;
              c3 = 0;
            } else {
              e3 = d2;
            }
            d2 = (e3 | 0) < (f2 | 0) ? e3 : f2;
            d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
            if ((d2 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = f2 - d2;
            b[h >> 2] = e3 - d2;
            b[i3 >> 2] = c3 - d2;
            return;
          }
          function Ta(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            h = (b[a3 >> 2] | 0) - (b[c3 >> 2] | 0) | 0;
            i3 = (h | 0) < 0;
            e3 = (b[a3 + 4 >> 2] | 0) - (b[c3 + 4 >> 2] | 0) - (i3 ? h : 0) | 0;
            g2 = (e3 | 0) < 0;
            f2 = (i3 ? 0 - h | 0 : 0) + (b[a3 + 8 >> 2] | 0) - (b[c3 + 8 >> 2] | 0) + (g2 ? 0 - e3 | 0 : 0) | 0;
            a3 = (f2 | 0) < 0;
            c3 = a3 ? 0 : f2;
            d2 = (g2 ? 0 : e3) - (a3 ? f2 : 0) | 0;
            f2 = (i3 ? 0 : h) - (g2 ? e3 : 0) - (a3 ? f2 : 0) | 0;
            a3 = (d2 | 0) < (f2 | 0) ? d2 : f2;
            a3 = (c3 | 0) < (a3 | 0) ? c3 : a3;
            e3 = (a3 | 0) > 0;
            c3 = c3 - (e3 ? a3 : 0) | 0;
            d2 = d2 - (e3 ? a3 : 0) | 0;
            a3 = f2 - (e3 ? a3 : 0) | 0;
            a3 = (a3 | 0) > -1 ? a3 : 0 - a3 | 0;
            d2 = (d2 | 0) > -1 ? d2 : 0 - d2 | 0;
            c3 = (c3 | 0) > -1 ? c3 : 0 - c3 | 0;
            c3 = (d2 | 0) > (c3 | 0) ? d2 : c3;
            return ((a3 | 0) > (c3 | 0) ? a3 : c3) | 0;
          }
          function Ua(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0;
            d2 = b[a3 + 8 >> 2] | 0;
            b[c3 >> 2] = (b[a3 >> 2] | 0) - d2;
            b[c3 + 4 >> 2] = (b[a3 + 4 >> 2] | 0) - d2;
            return;
          }
          function Va(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            e3 = b[a3 >> 2] | 0;
            b[c3 >> 2] = e3;
            a3 = b[a3 + 4 >> 2] | 0;
            h = c3 + 4 | 0;
            b[h >> 2] = a3;
            i3 = c3 + 8 | 0;
            b[i3 >> 2] = 0;
            d2 = a3 - e3 | 0;
            if ((e3 | 0) < 0) {
              a3 = 0 - e3 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = a3;
              b[c3 >> 2] = 0;
              e3 = 0;
            } else {
              d2 = a3;
              a3 = 0;
            }
            if ((d2 | 0) < 0) {
              e3 = e3 - d2 | 0;
              b[c3 >> 2] = e3;
              a3 = a3 - d2 | 0;
              b[i3 >> 2] = a3;
              b[h >> 2] = 0;
              d2 = 0;
            }
            g2 = e3 - a3 | 0;
            f2 = d2 - a3 | 0;
            if ((a3 | 0) < 0) {
              b[c3 >> 2] = g2;
              b[h >> 2] = f2;
              b[i3 >> 2] = 0;
              d2 = f2;
              f2 = g2;
              a3 = 0;
            } else {
              f2 = e3;
            }
            e3 = (d2 | 0) < (f2 | 0) ? d2 : f2;
            e3 = (a3 | 0) < (e3 | 0) ? a3 : e3;
            if ((e3 | 0) <= 0) {
              return;
            }
            b[c3 >> 2] = f2 - e3;
            b[h >> 2] = d2 - e3;
            b[i3 >> 2] = a3 - e3;
            return;
          }
          function Wa(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0;
            c3 = a3 + 8 | 0;
            f2 = b[c3 >> 2] | 0;
            d2 = f2 - (b[a3 >> 2] | 0) | 0;
            b[a3 >> 2] = d2;
            e3 = a3 + 4 | 0;
            a3 = (b[e3 >> 2] | 0) - f2 | 0;
            b[e3 >> 2] = a3;
            b[c3 >> 2] = 0 - (a3 + d2);
            return;
          }
          function Xa(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            d2 = b[a3 >> 2] | 0;
            c3 = 0 - d2 | 0;
            b[a3 >> 2] = c3;
            h = a3 + 8 | 0;
            b[h >> 2] = 0;
            i3 = a3 + 4 | 0;
            e3 = b[i3 >> 2] | 0;
            f2 = e3 + d2 | 0;
            if ((d2 | 0) > 0) {
              b[i3 >> 2] = f2;
              b[h >> 2] = d2;
              b[a3 >> 2] = 0;
              c3 = 0;
              e3 = f2;
            } else {
              d2 = 0;
            }
            if ((e3 | 0) < 0) {
              g2 = c3 - e3 | 0;
              b[a3 >> 2] = g2;
              d2 = d2 - e3 | 0;
              b[h >> 2] = d2;
              b[i3 >> 2] = 0;
              f2 = g2 - d2 | 0;
              c3 = 0 - d2 | 0;
              if ((d2 | 0) < 0) {
                b[a3 >> 2] = f2;
                b[i3 >> 2] = c3;
                b[h >> 2] = 0;
                e3 = c3;
                d2 = 0;
              } else {
                e3 = 0;
                f2 = g2;
              }
            } else {
              f2 = c3;
            }
            c3 = (e3 | 0) < (f2 | 0) ? e3 : f2;
            c3 = (d2 | 0) < (c3 | 0) ? d2 : c3;
            if ((c3 | 0) <= 0) {
              return;
            }
            b[a3 >> 2] = f2 - c3;
            b[i3 >> 2] = e3 - c3;
            b[h >> 2] = d2 - c3;
            return;
          }
          function Ya(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            d2 = S;
            S = S + 16 | 0;
            e3 = d2;
            Za(a3, b2, c3, e3);
            Ba(e3, c3 + 4 | 0);
            S = d2;
            return;
          }
          function Za(a3, c3, d2, f2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            f2 = f2 | 0;
            var g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
            k = S;
            S = S + 32 | 0;
            h = k;
            Jc(a3, h);
            b[d2 >> 2] = 0;
            g2 = +Ic(15888, h);
            i3 = +Ic(15912, h);
            if (i3 < g2) {
              b[d2 >> 2] = 1;
              g2 = i3;
            }
            i3 = +Ic(15936, h);
            if (i3 < g2) {
              b[d2 >> 2] = 2;
              g2 = i3;
            }
            i3 = +Ic(15960, h);
            if (i3 < g2) {
              b[d2 >> 2] = 3;
              g2 = i3;
            }
            i3 = +Ic(15984, h);
            if (i3 < g2) {
              b[d2 >> 2] = 4;
              g2 = i3;
            }
            i3 = +Ic(16008, h);
            if (i3 < g2) {
              b[d2 >> 2] = 5;
              g2 = i3;
            }
            i3 = +Ic(16032, h);
            if (i3 < g2) {
              b[d2 >> 2] = 6;
              g2 = i3;
            }
            i3 = +Ic(16056, h);
            if (i3 < g2) {
              b[d2 >> 2] = 7;
              g2 = i3;
            }
            i3 = +Ic(16080, h);
            if (i3 < g2) {
              b[d2 >> 2] = 8;
              g2 = i3;
            }
            i3 = +Ic(16104, h);
            if (i3 < g2) {
              b[d2 >> 2] = 9;
              g2 = i3;
            }
            i3 = +Ic(16128, h);
            if (i3 < g2) {
              b[d2 >> 2] = 10;
              g2 = i3;
            }
            i3 = +Ic(16152, h);
            if (i3 < g2) {
              b[d2 >> 2] = 11;
              g2 = i3;
            }
            i3 = +Ic(16176, h);
            if (i3 < g2) {
              b[d2 >> 2] = 12;
              g2 = i3;
            }
            i3 = +Ic(16200, h);
            if (i3 < g2) {
              b[d2 >> 2] = 13;
              g2 = i3;
            }
            i3 = +Ic(16224, h);
            if (i3 < g2) {
              b[d2 >> 2] = 14;
              g2 = i3;
            }
            i3 = +Ic(16248, h);
            if (i3 < g2) {
              b[d2 >> 2] = 15;
              g2 = i3;
            }
            i3 = +Ic(16272, h);
            if (i3 < g2) {
              b[d2 >> 2] = 16;
              g2 = i3;
            }
            i3 = +Ic(16296, h);
            if (i3 < g2) {
              b[d2 >> 2] = 17;
              g2 = i3;
            }
            i3 = +Ic(16320, h);
            if (i3 < g2) {
              b[d2 >> 2] = 18;
              g2 = i3;
            }
            i3 = +Ic(16344, h);
            if (i3 < g2) {
              b[d2 >> 2] = 19;
              g2 = i3;
            }
            i3 = +w(+(1 - g2 * 0.5));
            if (i3 < 1e-16) {
              b[f2 >> 2] = 0;
              b[f2 + 4 >> 2] = 0;
              b[f2 + 8 >> 2] = 0;
              b[f2 + 12 >> 2] = 0;
              S = k;
              return;
            }
            d2 = b[d2 >> 2] | 0;
            g2 = +e2[16368 + (d2 * 24 | 0) >> 3];
            g2 = +gb(g2 - +gb(+lb(15568 + (d2 << 4) | 0, a3)));
            if (!(Rb(c3) | 0)) {
              j = g2;
            } else {
              j = +gb(g2 + -0.3334731722518321);
            }
            g2 = +v(+i3) / 0.381966011250105;
            if ((c3 | 0) > 0) {
              h = 0;
              do {
                g2 = g2 * 2.6457513110645907;
                h = h + 1 | 0;
              } while ((h | 0) != (c3 | 0));
            }
            i3 = +t2(+j) * g2;
            e2[f2 >> 3] = i3;
            j = +u(+j) * g2;
            e2[f2 + 8 >> 3] = j;
            S = k;
            return;
          }
          function _a(a3, c3, d2, f2, g2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            f2 = f2 | 0;
            g2 = g2 | 0;
            var h = 0, i3 = 0;
            h = +Fc(a3);
            if (h < 1e-16) {
              c3 = 15568 + (c3 << 4) | 0;
              b[g2 >> 2] = b[c3 >> 2];
              b[g2 + 4 >> 2] = b[c3 + 4 >> 2];
              b[g2 + 8 >> 2] = b[c3 + 8 >> 2];
              b[g2 + 12 >> 2] = b[c3 + 12 >> 2];
              return;
            }
            i3 = +z(+ +e2[a3 + 8 >> 3], + +e2[a3 >> 3]);
            if ((d2 | 0) > 0) {
              a3 = 0;
              do {
                h = h / 2.6457513110645907;
                a3 = a3 + 1 | 0;
              } while ((a3 | 0) != (d2 | 0));
            }
            if (!f2) {
              h = +y2(+(h * 0.381966011250105));
              if (Rb(d2) | 0) {
                i3 = +gb(i3 + 0.3334731722518321);
              }
            } else {
              h = h / 3;
              d2 = (Rb(d2) | 0) == 0;
              h = +y2(+((d2 ? h : h / 2.6457513110645907) * 0.381966011250105));
            }
            mb(15568 + (c3 << 4) | 0, +gb(+e2[16368 + (c3 * 24 | 0) >> 3] - i3), h, g2);
            return;
          }
          function $a(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0;
            e3 = S;
            S = S + 16 | 0;
            f2 = e3;
            Da(a3 + 4 | 0, f2);
            _a(f2, b[a3 >> 2] | 0, c3, 0, d2);
            S = e3;
            return;
          }
          function ab(a3, c3, d2, f2, g2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            f2 = f2 | 0;
            g2 = g2 | 0;
            var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0, F2 = 0, G2 = 0, I2 = 0, J2 = 0;
            G2 = S;
            S = S + 272 | 0;
            h = G2 + 256 | 0;
            u2 = G2 + 240 | 0;
            D2 = G2;
            E = G2 + 224 | 0;
            F2 = G2 + 208 | 0;
            v2 = G2 + 176 | 0;
            w2 = G2 + 160 | 0;
            x3 = G2 + 192 | 0;
            y3 = G2 + 144 | 0;
            z2 = G2 + 128 | 0;
            A2 = G2 + 112 | 0;
            B2 = G2 + 96 | 0;
            C2 = G2 + 80 | 0;
            b[h >> 2] = c3;
            b[u2 >> 2] = b[a3 >> 2];
            b[u2 + 4 >> 2] = b[a3 + 4 >> 2];
            b[u2 + 8 >> 2] = b[a3 + 8 >> 2];
            b[u2 + 12 >> 2] = b[a3 + 12 >> 2];
            bb(u2, h, D2);
            b[g2 >> 2] = 0;
            u2 = f2 + d2 + ((f2 | 0) == 5 & 1) | 0;
            if ((u2 | 0) <= (d2 | 0)) {
              S = G2;
              return;
            }
            k = b[h >> 2] | 0;
            l2 = E + 4 | 0;
            m = v2 + 4 | 0;
            n2 = d2 + 5 | 0;
            o2 = 16848 + (k << 2) | 0;
            p3 = 16928 + (k << 2) | 0;
            q2 = z2 + 8 | 0;
            r3 = A2 + 8 | 0;
            s3 = B2 + 8 | 0;
            t3 = F2 + 4 | 0;
            j = d2;
            a:
              while (1) {
                i3 = D2 + (((j | 0) % 5 | 0) << 4) | 0;
                b[F2 >> 2] = b[i3 >> 2];
                b[F2 + 4 >> 2] = b[i3 + 4 >> 2];
                b[F2 + 8 >> 2] = b[i3 + 8 >> 2];
                b[F2 + 12 >> 2] = b[i3 + 12 >> 2];
                do {
                } while ((cb(F2, k, 0, 1) | 0) == 2);
                if ((j | 0) > (d2 | 0) & (Rb(c3) | 0) != 0) {
                  b[v2 >> 2] = b[F2 >> 2];
                  b[v2 + 4 >> 2] = b[F2 + 4 >> 2];
                  b[v2 + 8 >> 2] = b[F2 + 8 >> 2];
                  b[v2 + 12 >> 2] = b[F2 + 12 >> 2];
                  Da(l2, w2);
                  f2 = b[v2 >> 2] | 0;
                  h = b[17008 + (f2 * 80 | 0) + (b[E >> 2] << 2) >> 2] | 0;
                  b[v2 >> 2] = b[18608 + (f2 * 80 | 0) + (h * 20 | 0) >> 2];
                  i3 = b[18608 + (f2 * 80 | 0) + (h * 20 | 0) + 16 >> 2] | 0;
                  if ((i3 | 0) > 0) {
                    a3 = 0;
                    do {
                      Na(m);
                      a3 = a3 + 1 | 0;
                    } while ((a3 | 0) < (i3 | 0));
                  }
                  i3 = 18608 + (f2 * 80 | 0) + (h * 20 | 0) + 4 | 0;
                  b[x3 >> 2] = b[i3 >> 2];
                  b[x3 + 4 >> 2] = b[i3 + 4 >> 2];
                  b[x3 + 8 >> 2] = b[i3 + 8 >> 2];
                  Ga(x3, (b[o2 >> 2] | 0) * 3 | 0);
                  Ea(m, x3, m);
                  Ca(m);
                  Da(m, y3);
                  I2 = +(b[p3 >> 2] | 0);
                  e2[z2 >> 3] = I2 * 3;
                  e2[q2 >> 3] = 0;
                  J2 = I2 * -1.5;
                  e2[A2 >> 3] = J2;
                  e2[r3 >> 3] = I2 * 2.598076211353316;
                  e2[B2 >> 3] = J2;
                  e2[s3 >> 3] = I2 * -2.598076211353316;
                  switch (b[17008 + ((b[v2 >> 2] | 0) * 80 | 0) + (b[F2 >> 2] << 2) >> 2] | 0) {
                    case 1: {
                      a3 = A2;
                      f2 = z2;
                      break;
                    }
                    case 3: {
                      a3 = B2;
                      f2 = A2;
                      break;
                    }
                    case 2: {
                      a3 = z2;
                      f2 = B2;
                      break;
                    }
                    default: {
                      a3 = 12;
                      break a;
                    }
                  }
                  Gc(w2, y3, f2, a3, C2);
                  _a(C2, b[v2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
                  b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
                }
                if ((j | 0) < (n2 | 0)) {
                  Da(t3, v2);
                  _a(v2, b[F2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
                  b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
                }
                b[E >> 2] = b[F2 >> 2];
                b[E + 4 >> 2] = b[F2 + 4 >> 2];
                b[E + 8 >> 2] = b[F2 + 8 >> 2];
                b[E + 12 >> 2] = b[F2 + 12 >> 2];
                j = j + 1 | 0;
                if ((j | 0) >= (u2 | 0)) {
                  a3 = 3;
                  break;
                }
              }
            if ((a3 | 0) == 3) {
              S = G2;
              return;
            } else if ((a3 | 0) == 12) {
              H(22474, 22521, 581, 22531);
            }
          }
          function bb(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
            j = S;
            S = S + 128 | 0;
            e3 = j + 64 | 0;
            f2 = j;
            g2 = e3;
            h = 20208;
            i3 = g2 + 60 | 0;
            do {
              b[g2 >> 2] = b[h >> 2];
              g2 = g2 + 4 | 0;
              h = h + 4 | 0;
            } while ((g2 | 0) < (i3 | 0));
            g2 = f2;
            h = 20272;
            i3 = g2 + 60 | 0;
            do {
              b[g2 >> 2] = b[h >> 2];
              g2 = g2 + 4 | 0;
              h = h + 4 | 0;
            } while ((g2 | 0) < (i3 | 0));
            i3 = (Rb(b[c3 >> 2] | 0) | 0) == 0;
            e3 = i3 ? e3 : f2;
            f2 = a3 + 4 | 0;
            Ra(f2);
            Sa(f2);
            if (Rb(b[c3 >> 2] | 0) | 0) {
              La(f2);
              b[c3 >> 2] = (b[c3 >> 2] | 0) + 1;
            }
            b[d2 >> 2] = b[a3 >> 2];
            c3 = d2 + 4 | 0;
            Ea(f2, e3, c3);
            Ca(c3);
            b[d2 + 16 >> 2] = b[a3 >> 2];
            c3 = d2 + 20 | 0;
            Ea(f2, e3 + 12 | 0, c3);
            Ca(c3);
            b[d2 + 32 >> 2] = b[a3 >> 2];
            c3 = d2 + 36 | 0;
            Ea(f2, e3 + 24 | 0, c3);
            Ca(c3);
            b[d2 + 48 >> 2] = b[a3 >> 2];
            c3 = d2 + 52 | 0;
            Ea(f2, e3 + 36 | 0, c3);
            Ca(c3);
            b[d2 + 64 >> 2] = b[a3 >> 2];
            d2 = d2 + 68 | 0;
            Ea(f2, e3 + 48 | 0, d2);
            Ca(d2);
            S = j;
            return;
          }
          function cb(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0;
            p3 = S;
            S = S + 32 | 0;
            n2 = p3 + 12 | 0;
            i3 = p3;
            o2 = a3 + 4 | 0;
            m = b[16928 + (c3 << 2) >> 2] | 0;
            l2 = (e3 | 0) != 0;
            m = l2 ? m * 3 | 0 : m;
            f2 = b[o2 >> 2] | 0;
            k = a3 + 8 | 0;
            h = b[k >> 2] | 0;
            if (l2) {
              g2 = a3 + 12 | 0;
              e3 = b[g2 >> 2] | 0;
              f2 = h + f2 + e3 | 0;
              if ((f2 | 0) == (m | 0)) {
                o2 = 1;
                S = p3;
                return o2 | 0;
              } else {
                j = g2;
              }
            } else {
              j = a3 + 12 | 0;
              e3 = b[j >> 2] | 0;
              f2 = h + f2 + e3 | 0;
            }
            if ((f2 | 0) <= (m | 0)) {
              o2 = 0;
              S = p3;
              return o2 | 0;
            }
            do {
              if ((e3 | 0) > 0) {
                e3 = b[a3 >> 2] | 0;
                if ((h | 0) > 0) {
                  g2 = 18608 + (e3 * 80 | 0) + 60 | 0;
                  e3 = a3;
                  break;
                }
                e3 = 18608 + (e3 * 80 | 0) + 40 | 0;
                if (!d2) {
                  g2 = e3;
                  e3 = a3;
                } else {
                  Aa(n2, m, 0, 0);
                  Fa(o2, n2, i3);
                  Oa(i3);
                  Ea(i3, n2, o2);
                  g2 = e3;
                  e3 = a3;
                }
              } else {
                g2 = 18608 + ((b[a3 >> 2] | 0) * 80 | 0) + 20 | 0;
                e3 = a3;
              }
            } while (0);
            b[e3 >> 2] = b[g2 >> 2];
            f2 = g2 + 16 | 0;
            if ((b[f2 >> 2] | 0) > 0) {
              e3 = 0;
              do {
                Na(o2);
                e3 = e3 + 1 | 0;
              } while ((e3 | 0) < (b[f2 >> 2] | 0));
            }
            a3 = g2 + 4 | 0;
            b[n2 >> 2] = b[a3 >> 2];
            b[n2 + 4 >> 2] = b[a3 + 4 >> 2];
            b[n2 + 8 >> 2] = b[a3 + 8 >> 2];
            c3 = b[16848 + (c3 << 2) >> 2] | 0;
            Ga(n2, l2 ? c3 * 3 | 0 : c3);
            Ea(o2, n2, o2);
            Ca(o2);
            if (l2) {
              e3 = ((b[k >> 2] | 0) + (b[o2 >> 2] | 0) + (b[j >> 2] | 0) | 0) == (m | 0) ? 1 : 2;
            } else {
              e3 = 2;
            }
            o2 = e3;
            S = p3;
            return o2 | 0;
          }
          function db(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0;
            do {
              c3 = cb(a3, b2, 0, 1) | 0;
            } while ((c3 | 0) == 2);
            return c3 | 0;
          }
          function eb(a3, c3, d2, f2, g2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            f2 = f2 | 0;
            g2 = g2 | 0;
            var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0;
            B2 = S;
            S = S + 240 | 0;
            h = B2 + 224 | 0;
            x3 = B2 + 208 | 0;
            y3 = B2;
            z2 = B2 + 192 | 0;
            A2 = B2 + 176 | 0;
            s3 = B2 + 160 | 0;
            t3 = B2 + 144 | 0;
            u2 = B2 + 128 | 0;
            v2 = B2 + 112 | 0;
            w2 = B2 + 96 | 0;
            b[h >> 2] = c3;
            b[x3 >> 2] = b[a3 >> 2];
            b[x3 + 4 >> 2] = b[a3 + 4 >> 2];
            b[x3 + 8 >> 2] = b[a3 + 8 >> 2];
            b[x3 + 12 >> 2] = b[a3 + 12 >> 2];
            fb(x3, h, y3);
            b[g2 >> 2] = 0;
            r3 = f2 + d2 + ((f2 | 0) == 6 & 1) | 0;
            if ((r3 | 0) <= (d2 | 0)) {
              S = B2;
              return;
            }
            k = b[h >> 2] | 0;
            l2 = d2 + 6 | 0;
            m = 16928 + (k << 2) | 0;
            n2 = t3 + 8 | 0;
            o2 = u2 + 8 | 0;
            p3 = v2 + 8 | 0;
            q2 = z2 + 4 | 0;
            i3 = 0;
            j = d2;
            f2 = -1;
            a:
              while (1) {
                h = (j | 0) % 6 | 0;
                a3 = y3 + (h << 4) | 0;
                b[z2 >> 2] = b[a3 >> 2];
                b[z2 + 4 >> 2] = b[a3 + 4 >> 2];
                b[z2 + 8 >> 2] = b[a3 + 8 >> 2];
                b[z2 + 12 >> 2] = b[a3 + 12 >> 2];
                a3 = i3;
                i3 = cb(z2, k, 0, 1) | 0;
                if ((j | 0) > (d2 | 0) & (Rb(c3) | 0) != 0 ? (a3 | 0) != 1 ? (b[z2 >> 2] | 0) != (f2 | 0) : 0 : 0) {
                  Da(y3 + (((h + 5 | 0) % 6 | 0) << 4) + 4 | 0, A2);
                  Da(y3 + (h << 4) + 4 | 0, s3);
                  C2 = +(b[m >> 2] | 0);
                  e2[t3 >> 3] = C2 * 3;
                  e2[n2 >> 3] = 0;
                  D2 = C2 * -1.5;
                  e2[u2 >> 3] = D2;
                  e2[o2 >> 3] = C2 * 2.598076211353316;
                  e2[v2 >> 3] = D2;
                  e2[p3 >> 3] = C2 * -2.598076211353316;
                  h = b[x3 >> 2] | 0;
                  switch (b[17008 + (h * 80 | 0) + (((f2 | 0) == (h | 0) ? b[z2 >> 2] | 0 : f2) << 2) >> 2] | 0) {
                    case 1: {
                      a3 = u2;
                      f2 = t3;
                      break;
                    }
                    case 3: {
                      a3 = v2;
                      f2 = u2;
                      break;
                    }
                    case 2: {
                      a3 = t3;
                      f2 = v2;
                      break;
                    }
                    default: {
                      a3 = 8;
                      break a;
                    }
                  }
                  Gc(A2, s3, f2, a3, w2);
                  if (!(Hc(A2, w2) | 0) ? !(Hc(s3, w2) | 0) : 0) {
                    _a(w2, b[x3 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
                    b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
                  }
                }
                if ((j | 0) < (l2 | 0)) {
                  Da(q2, A2);
                  _a(A2, b[z2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
                  b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
                }
                j = j + 1 | 0;
                if ((j | 0) >= (r3 | 0)) {
                  a3 = 3;
                  break;
                } else {
                  f2 = b[z2 >> 2] | 0;
                }
              }
            if ((a3 | 0) == 3) {
              S = B2;
              return;
            } else if ((a3 | 0) == 8) {
              H(22557, 22521, 746, 22602);
            }
          }
          function fb(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
            j = S;
            S = S + 160 | 0;
            e3 = j + 80 | 0;
            f2 = j;
            g2 = e3;
            h = 20336;
            i3 = g2 + 72 | 0;
            do {
              b[g2 >> 2] = b[h >> 2];
              g2 = g2 + 4 | 0;
              h = h + 4 | 0;
            } while ((g2 | 0) < (i3 | 0));
            g2 = f2;
            h = 20416;
            i3 = g2 + 72 | 0;
            do {
              b[g2 >> 2] = b[h >> 2];
              g2 = g2 + 4 | 0;
              h = h + 4 | 0;
            } while ((g2 | 0) < (i3 | 0));
            i3 = (Rb(b[c3 >> 2] | 0) | 0) == 0;
            e3 = i3 ? e3 : f2;
            f2 = a3 + 4 | 0;
            Ra(f2);
            Sa(f2);
            if (Rb(b[c3 >> 2] | 0) | 0) {
              La(f2);
              b[c3 >> 2] = (b[c3 >> 2] | 0) + 1;
            }
            b[d2 >> 2] = b[a3 >> 2];
            c3 = d2 + 4 | 0;
            Ea(f2, e3, c3);
            Ca(c3);
            b[d2 + 16 >> 2] = b[a3 >> 2];
            c3 = d2 + 20 | 0;
            Ea(f2, e3 + 12 | 0, c3);
            Ca(c3);
            b[d2 + 32 >> 2] = b[a3 >> 2];
            c3 = d2 + 36 | 0;
            Ea(f2, e3 + 24 | 0, c3);
            Ca(c3);
            b[d2 + 48 >> 2] = b[a3 >> 2];
            c3 = d2 + 52 | 0;
            Ea(f2, e3 + 36 | 0, c3);
            Ca(c3);
            b[d2 + 64 >> 2] = b[a3 >> 2];
            c3 = d2 + 68 | 0;
            Ea(f2, e3 + 48 | 0, c3);
            Ca(c3);
            b[d2 + 80 >> 2] = b[a3 >> 2];
            d2 = d2 + 84 | 0;
            Ea(f2, e3 + 60 | 0, d2);
            Ca(d2);
            S = j;
            return;
          }
          function gb(a3) {
            a3 = +a3;
            var b2 = 0;
            b2 = a3 < 0 ? a3 + 6.283185307179586 : a3;
            return +(!(a3 >= 6.283185307179586) ? b2 : b2 + -6.283185307179586);
          }
          function hb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            if (!(+q(+(+e2[a3 >> 3] - +e2[b2 >> 3])) < 17453292519943298e-27)) {
              b2 = 0;
              return b2 | 0;
            }
            b2 = +q(+(+e2[a3 + 8 >> 3] - +e2[b2 + 8 >> 3])) < 17453292519943298e-27;
            return b2 | 0;
          }
          function ib(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, f2 = 0, g2 = 0;
            f2 = +e2[b2 >> 3];
            d2 = +e2[a3 >> 3];
            g2 = +u(+((f2 - d2) * 0.5));
            c3 = +u(+((+e2[b2 + 8 >> 3] - +e2[a3 + 8 >> 3]) * 0.5));
            c3 = g2 * g2 + c3 * (+t2(+f2) * +t2(+d2) * c3);
            return +(+z(+ +r2(+c3), + +r2(+(1 - c3))) * 2);
          }
          function jb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, f2 = 0, g2 = 0;
            f2 = +e2[b2 >> 3];
            d2 = +e2[a3 >> 3];
            g2 = +u(+((f2 - d2) * 0.5));
            c3 = +u(+((+e2[b2 + 8 >> 3] - +e2[a3 + 8 >> 3]) * 0.5));
            c3 = g2 * g2 + c3 * (+t2(+f2) * +t2(+d2) * c3);
            return +(+z(+ +r2(+c3), + +r2(+(1 - c3))) * 2 * 6371.007180918475);
          }
          function kb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, f2 = 0, g2 = 0;
            f2 = +e2[b2 >> 3];
            d2 = +e2[a3 >> 3];
            g2 = +u(+((f2 - d2) * 0.5));
            c3 = +u(+((+e2[b2 + 8 >> 3] - +e2[a3 + 8 >> 3]) * 0.5));
            c3 = g2 * g2 + c3 * (+t2(+f2) * +t2(+d2) * c3);
            return +(+z(+ +r2(+c3), + +r2(+(1 - c3))) * 2 * 6371.007180918475 * 1e3);
          }
          function lb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0;
            g2 = +e2[b2 >> 3];
            d2 = +t2(+g2);
            f2 = +e2[b2 + 8 >> 3] - +e2[a3 + 8 >> 3];
            h = d2 * +u(+f2);
            c3 = +e2[a3 >> 3];
            return + +z(+h, +(+u(+g2) * +t2(+c3) - +t2(+f2) * (d2 * +u(+c3))));
          }
          function mb(a3, c3, d2, f2) {
            a3 = a3 | 0;
            c3 = +c3;
            d2 = +d2;
            f2 = f2 | 0;
            var g2 = 0, h = 0, i3 = 0, j = 0;
            if (d2 < 1e-16) {
              b[f2 >> 2] = b[a3 >> 2];
              b[f2 + 4 >> 2] = b[a3 + 4 >> 2];
              b[f2 + 8 >> 2] = b[a3 + 8 >> 2];
              b[f2 + 12 >> 2] = b[a3 + 12 >> 2];
              return;
            }
            h = c3 < 0 ? c3 + 6.283185307179586 : c3;
            h = !(c3 >= 6.283185307179586) ? h : h + -6.283185307179586;
            do {
              if (h < 1e-16) {
                c3 = +e2[a3 >> 3] + d2;
                e2[f2 >> 3] = c3;
                g2 = f2;
              } else {
                g2 = +q(+(h + -3.141592653589793)) < 1e-16;
                c3 = +e2[a3 >> 3];
                if (g2) {
                  c3 = c3 - d2;
                  e2[f2 >> 3] = c3;
                  g2 = f2;
                  break;
                }
                i3 = +t2(+d2);
                d2 = +u(+d2);
                c3 = i3 * +u(+c3) + +t2(+h) * (d2 * +t2(+c3));
                c3 = c3 > 1 ? 1 : c3;
                c3 = +x2(+(c3 < -1 ? -1 : c3));
                e2[f2 >> 3] = c3;
                if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
                  e2[f2 >> 3] = 1.5707963267948966;
                  e2[f2 + 8 >> 3] = 0;
                  return;
                }
                if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
                  e2[f2 >> 3] = -1.5707963267948966;
                  e2[f2 + 8 >> 3] = 0;
                  return;
                }
                j = +t2(+c3);
                h = d2 * +u(+h) / j;
                d2 = +e2[a3 >> 3];
                c3 = (i3 - +u(+c3) * +u(+d2)) / +t2(+d2) / j;
                i3 = h > 1 ? 1 : h;
                c3 = c3 > 1 ? 1 : c3;
                c3 = +e2[a3 + 8 >> 3] + +z(+(i3 < -1 ? -1 : i3), +(c3 < -1 ? -1 : c3));
                if (c3 > 3.141592653589793) {
                  do {
                    c3 = c3 + -6.283185307179586;
                  } while (c3 > 3.141592653589793);
                }
                if (c3 < -3.141592653589793) {
                  do {
                    c3 = c3 + 6.283185307179586;
                  } while (c3 < -3.141592653589793);
                }
                e2[f2 + 8 >> 3] = c3;
                return;
              }
            } while (0);
            if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
              e2[g2 >> 3] = 1.5707963267948966;
              e2[f2 + 8 >> 3] = 0;
              return;
            }
            if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
              e2[g2 >> 3] = -1.5707963267948966;
              e2[f2 + 8 >> 3] = 0;
              return;
            }
            c3 = +e2[a3 + 8 >> 3];
            if (c3 > 3.141592653589793) {
              do {
                c3 = c3 + -6.283185307179586;
              } while (c3 > 3.141592653589793);
            }
            if (c3 < -3.141592653589793) {
              do {
                c3 = c3 + 6.283185307179586;
              } while (c3 < -3.141592653589793);
            }
            e2[f2 + 8 >> 3] = c3;
            return;
          }
          function nb(a3) {
            a3 = a3 | 0;
            return + +e2[20496 + (a3 << 3) >> 3];
          }
          function ob(a3) {
            a3 = a3 | 0;
            return + +e2[20624 + (a3 << 3) >> 3];
          }
          function pb(a3) {
            a3 = a3 | 0;
            return + +e2[20752 + (a3 << 3) >> 3];
          }
          function qb(a3) {
            a3 = a3 | 0;
            return + +e2[20880 + (a3 << 3) >> 3];
          }
          function rb(a3) {
            a3 = a3 | 0;
            var c3 = 0;
            c3 = 21008 + (a3 << 3) | 0;
            a3 = b[c3 >> 2] | 0;
            F(b[c3 + 4 >> 2] | 0);
            return a3 | 0;
          }
          function sb(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0;
            n2 = +e2[b2 >> 3];
            l2 = +e2[a3 >> 3];
            j = +u(+((n2 - l2) * 0.5));
            g2 = +e2[b2 + 8 >> 3];
            k = +e2[a3 + 8 >> 3];
            h = +u(+((g2 - k) * 0.5));
            i3 = +t2(+l2);
            m = +t2(+n2);
            h = j * j + h * (m * i3 * h);
            h = +z(+ +r2(+h), + +r2(+(1 - h))) * 2;
            j = +e2[c3 >> 3];
            n2 = +u(+((j - n2) * 0.5));
            d2 = +e2[c3 + 8 >> 3];
            g2 = +u(+((d2 - g2) * 0.5));
            f2 = +t2(+j);
            g2 = n2 * n2 + g2 * (m * f2 * g2);
            g2 = +z(+ +r2(+g2), + +r2(+(1 - g2))) * 2;
            j = +u(+((l2 - j) * 0.5));
            d2 = +u(+((k - d2) * 0.5));
            d2 = j * j + d2 * (i3 * f2 * d2);
            d2 = +z(+ +r2(+d2), + +r2(+(1 - d2))) * 2;
            f2 = (h + g2 + d2) * 0.5;
            return +(+y2(+ +r2(+(+v(+(f2 * 0.5)) * +v(+((f2 - h) * 0.5)) * +v(+((f2 - g2) * 0.5)) * +v(+((f2 - d2) * 0.5))))) * 4);
          }
          function tb(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
            g2 = S;
            S = S + 192 | 0;
            e3 = g2 + 168 | 0;
            f2 = g2;
            Vb(a3, c3, e3);
            Wb(a3, c3, f2);
            c3 = b[f2 >> 2] | 0;
            if ((c3 | 0) <= 0) {
              d2 = 0;
              S = g2;
              return +d2;
            }
            d2 = +sb(f2 + 8 | 0, f2 + 8 + (((c3 | 0) != 1 & 1) << 4) | 0, e3) + 0;
            if ((c3 | 0) == 1) {
              S = g2;
              return +d2;
            }
            a3 = 1;
            do {
              h = a3;
              a3 = a3 + 1 | 0;
              d2 = d2 + +sb(f2 + 8 + (h << 4) | 0, f2 + 8 + (((a3 | 0) % (c3 | 0) | 0) << 4) | 0, e3);
            } while ((a3 | 0) < (c3 | 0));
            S = g2;
            return +d2;
          }
          function ub(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
            g2 = S;
            S = S + 192 | 0;
            e3 = g2 + 168 | 0;
            f2 = g2;
            Vb(a3, c3, e3);
            Wb(a3, c3, f2);
            c3 = b[f2 >> 2] | 0;
            if ((c3 | 0) > 0) {
              d2 = +sb(f2 + 8 | 0, f2 + 8 + (((c3 | 0) != 1 & 1) << 4) | 0, e3) + 0;
              if ((c3 | 0) != 1) {
                a3 = 1;
                do {
                  h = a3;
                  a3 = a3 + 1 | 0;
                  d2 = d2 + +sb(f2 + 8 + (h << 4) | 0, f2 + 8 + (((a3 | 0) % (c3 | 0) | 0) << 4) | 0, e3);
                } while ((a3 | 0) < (c3 | 0));
              }
            } else {
              d2 = 0;
            }
            S = g2;
            return +(d2 * 6371.007180918475 * 6371.007180918475);
          }
          function vb(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
            g2 = S;
            S = S + 192 | 0;
            e3 = g2 + 168 | 0;
            f2 = g2;
            Vb(a3, c3, e3);
            Wb(a3, c3, f2);
            c3 = b[f2 >> 2] | 0;
            if ((c3 | 0) > 0) {
              d2 = +sb(f2 + 8 | 0, f2 + 8 + (((c3 | 0) != 1 & 1) << 4) | 0, e3) + 0;
              if ((c3 | 0) != 1) {
                a3 = 1;
                do {
                  h = a3;
                  a3 = a3 + 1 | 0;
                  d2 = d2 + +sb(f2 + 8 + (h << 4) | 0, f2 + 8 + (((a3 | 0) % (c3 | 0) | 0) << 4) | 0, e3);
                } while ((a3 | 0) < (c3 | 0));
              }
            } else {
              d2 = 0;
            }
            S = g2;
            return +(d2 * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3);
          }
          function wb(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            i3 = S;
            S = S + 176 | 0;
            h = i3;
            gc(a3, c3, h);
            a3 = b[h >> 2] | 0;
            if ((a3 | 0) <= 1) {
              g2 = 0;
              S = i3;
              return +g2;
            }
            c3 = a3 + -1 | 0;
            a3 = 0;
            d2 = 0;
            f2 = +e2[h + 8 >> 3];
            g2 = +e2[h + 16 >> 3];
            do {
              a3 = a3 + 1 | 0;
              k = f2;
              f2 = +e2[h + 8 + (a3 << 4) >> 3];
              l2 = +u(+((f2 - k) * 0.5));
              j = g2;
              g2 = +e2[h + 8 + (a3 << 4) + 8 >> 3];
              j = +u(+((g2 - j) * 0.5));
              j = l2 * l2 + j * (+t2(+f2) * +t2(+k) * j);
              d2 = d2 + +z(+ +r2(+j), + +r2(+(1 - j))) * 2;
            } while ((a3 | 0) < (c3 | 0));
            S = i3;
            return +d2;
          }
          function xb(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            i3 = S;
            S = S + 176 | 0;
            h = i3;
            gc(a3, c3, h);
            a3 = b[h >> 2] | 0;
            if ((a3 | 0) <= 1) {
              g2 = 0;
              S = i3;
              return +g2;
            }
            c3 = a3 + -1 | 0;
            a3 = 0;
            d2 = 0;
            f2 = +e2[h + 8 >> 3];
            g2 = +e2[h + 16 >> 3];
            do {
              a3 = a3 + 1 | 0;
              k = f2;
              f2 = +e2[h + 8 + (a3 << 4) >> 3];
              l2 = +u(+((f2 - k) * 0.5));
              j = g2;
              g2 = +e2[h + 8 + (a3 << 4) + 8 >> 3];
              j = +u(+((g2 - j) * 0.5));
              j = l2 * l2 + j * (+t2(+k) * +t2(+f2) * j);
              d2 = d2 + +z(+ +r2(+j), + +r2(+(1 - j))) * 2;
            } while ((a3 | 0) != (c3 | 0));
            l2 = d2 * 6371.007180918475;
            S = i3;
            return +l2;
          }
          function yb(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            i3 = S;
            S = S + 176 | 0;
            h = i3;
            gc(a3, c3, h);
            a3 = b[h >> 2] | 0;
            if ((a3 | 0) <= 1) {
              g2 = 0;
              S = i3;
              return +g2;
            }
            c3 = a3 + -1 | 0;
            a3 = 0;
            d2 = 0;
            f2 = +e2[h + 8 >> 3];
            g2 = +e2[h + 16 >> 3];
            do {
              a3 = a3 + 1 | 0;
              k = f2;
              f2 = +e2[h + 8 + (a3 << 4) >> 3];
              l2 = +u(+((f2 - k) * 0.5));
              j = g2;
              g2 = +e2[h + 8 + (a3 << 4) + 8 >> 3];
              j = +u(+((g2 - j) * 0.5));
              j = l2 * l2 + j * (+t2(+k) * +t2(+f2) * j);
              d2 = d2 + +z(+ +r2(+j), + +r2(+(1 - j))) * 2;
            } while ((a3 | 0) != (c3 | 0));
            l2 = d2 * 6371.007180918475 * 1e3;
            S = i3;
            return +l2;
          }
          function zb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            b2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            return b2 & 15 | 0;
          }
          function Ab(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            b2 = cd(a3 | 0, b2 | 0, 45) | 0;
            G() | 0;
            return b2 & 127 | 0;
          }
          function Bb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
            if (!(true & (b2 & -16777216 | 0) == 134217728)) {
              b2 = 0;
              return b2 | 0;
            }
            g2 = cd(a3 | 0, b2 | 0, 45) | 0;
            G() | 0;
            g2 = g2 & 127;
            if (g2 >>> 0 > 121) {
              b2 = 0;
              return b2 | 0;
            }
            c3 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            c3 = c3 & 15;
            do {
              if (c3 | 0) {
                e3 = 1;
                d2 = 0;
                while (1) {
                  f2 = cd(a3 | 0, b2 | 0, (15 - e3 | 0) * 3 | 0) | 0;
                  G() | 0;
                  f2 = f2 & 7;
                  if ((f2 | 0) != 0 & (d2 ^ 1)) {
                    if ((f2 | 0) == 1 & (la(g2) | 0) != 0) {
                      h = 0;
                      d2 = 13;
                      break;
                    } else {
                      d2 = 1;
                    }
                  }
                  if ((f2 | 0) == 7) {
                    h = 0;
                    d2 = 13;
                    break;
                  }
                  if (e3 >>> 0 < c3 >>> 0) {
                    e3 = e3 + 1 | 0;
                  } else {
                    d2 = 9;
                    break;
                  }
                }
                if ((d2 | 0) == 9) {
                  if ((c3 | 0) == 15) {
                    h = 1;
                  } else {
                    break;
                  }
                  return h | 0;
                } else if ((d2 | 0) == 13) {
                  return h | 0;
                }
              }
            } while (0);
            while (1) {
              h = cd(a3 | 0, b2 | 0, (14 - c3 | 0) * 3 | 0) | 0;
              G() | 0;
              if (!((h & 7 | 0) == 7 & true)) {
                h = 0;
                d2 = 13;
                break;
              }
              if (c3 >>> 0 < 14) {
                c3 = c3 + 1 | 0;
              } else {
                h = 1;
                d2 = 13;
                break;
              }
            }
            if ((d2 | 0) == 13) {
              return h | 0;
            }
            return 0;
          }
          function Cb(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            d2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            d2 = d2 & 15;
            if ((d2 | 0) >= (c3 | 0)) {
              if ((d2 | 0) != (c3 | 0)) {
                if (c3 >>> 0 <= 15) {
                  e3 = dd(c3 | 0, 0, 52) | 0;
                  a3 = e3 | a3;
                  b2 = G() | 0 | b2 & -15728641;
                  if ((d2 | 0) > (c3 | 0)) {
                    do {
                      e3 = dd(7, 0, (14 - c3 | 0) * 3 | 0) | 0;
                      c3 = c3 + 1 | 0;
                      a3 = e3 | a3;
                      b2 = G() | 0 | b2;
                    } while ((c3 | 0) < (d2 | 0));
                  }
                } else {
                  b2 = 0;
                  a3 = 0;
                }
              }
            } else {
              b2 = 0;
              a3 = 0;
            }
            F(b2 | 0);
            return a3 | 0;
          }
          function Db(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            a3 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            a3 = a3 & 15;
            if (!((c3 | 0) < 16 & (a3 | 0) <= (c3 | 0))) {
              c3 = 0;
              return c3 | 0;
            }
            c3 = tc(7, c3 - a3 | 0) | 0;
            return c3 | 0;
          }
          function Eb(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            h = cd(a3 | 0, c3 | 0, 52) | 0;
            G() | 0;
            h = h & 15;
            if (!((d2 | 0) < 16 & (h | 0) <= (d2 | 0))) {
              return;
            }
            if ((h | 0) == (d2 | 0)) {
              d2 = e3;
              b[d2 >> 2] = a3;
              b[d2 + 4 >> 2] = c3;
              return;
            }
            j = tc(7, d2 - h | 0) | 0;
            k = (j | 0) / 7 | 0;
            i3 = cd(a3 | 0, c3 | 0, 45) | 0;
            G() | 0;
            if (!(la(i3 & 127) | 0)) {
              g2 = 0;
            } else {
              a:
                do {
                  if (!h) {
                    f2 = 0;
                  } else {
                    g2 = 1;
                    while (1) {
                      f2 = cd(a3 | 0, c3 | 0, (15 - g2 | 0) * 3 | 0) | 0;
                      G() | 0;
                      f2 = f2 & 7;
                      if (f2 | 0) {
                        break a;
                      }
                      if (g2 >>> 0 < h >>> 0) {
                        g2 = g2 + 1 | 0;
                      } else {
                        f2 = 0;
                        break;
                      }
                    }
                  }
                } while (0);
              g2 = (f2 | 0) == 0;
            }
            l2 = dd(h + 1 | 0, 0, 52) | 0;
            f2 = G() | 0 | c3 & -15728641;
            i3 = (14 - h | 0) * 3 | 0;
            c3 = dd(7, 0, i3 | 0) | 0;
            c3 = (l2 | a3) & ~c3;
            h = f2 & ~(G() | 0);
            Eb(c3, h, d2, e3);
            f2 = e3 + (k << 3) | 0;
            if (!g2) {
              l2 = dd(1, 0, i3 | 0) | 0;
              Eb(l2 | c3, G() | 0 | h, d2, f2);
              l2 = f2 + (k << 3) | 0;
              j = dd(2, 0, i3 | 0) | 0;
              Eb(j | c3, G() | 0 | h, d2, l2);
              l2 = l2 + (k << 3) | 0;
              j = dd(3, 0, i3 | 0) | 0;
              Eb(j | c3, G() | 0 | h, d2, l2);
              l2 = l2 + (k << 3) | 0;
              j = dd(4, 0, i3 | 0) | 0;
              Eb(j | c3, G() | 0 | h, d2, l2);
              l2 = l2 + (k << 3) | 0;
              j = dd(5, 0, i3 | 0) | 0;
              Eb(j | c3, G() | 0 | h, d2, l2);
              j = dd(6, 0, i3 | 0) | 0;
              Eb(j | c3, G() | 0 | h, d2, l2 + (k << 3) | 0);
              return;
            }
            g2 = f2 + (k << 3) | 0;
            if ((j | 0) > 6) {
              j = f2 + 8 | 0;
              l2 = (g2 >>> 0 > j >>> 0 ? g2 : j) + -1 + (0 - f2) | 0;
              hd(f2 | 0, 0, l2 + 8 & -8 | 0) | 0;
              f2 = j + (l2 >>> 3 << 3) | 0;
            }
            l2 = dd(2, 0, i3 | 0) | 0;
            Eb(l2 | c3, G() | 0 | h, d2, f2);
            l2 = f2 + (k << 3) | 0;
            j = dd(3, 0, i3 | 0) | 0;
            Eb(j | c3, G() | 0 | h, d2, l2);
            l2 = l2 + (k << 3) | 0;
            j = dd(4, 0, i3 | 0) | 0;
            Eb(j | c3, G() | 0 | h, d2, l2);
            l2 = l2 + (k << 3) | 0;
            j = dd(5, 0, i3 | 0) | 0;
            Eb(j | c3, G() | 0 | h, d2, l2);
            j = dd(6, 0, i3 | 0) | 0;
            Eb(j | c3, G() | 0 | h, d2, l2 + (k << 3) | 0);
            return;
          }
          function Fb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0;
            e3 = cd(a3 | 0, b2 | 0, 45) | 0;
            G() | 0;
            if (!(la(e3 & 127) | 0)) {
              e3 = 0;
              return e3 | 0;
            }
            e3 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            e3 = e3 & 15;
            a:
              do {
                if (!e3) {
                  c3 = 0;
                } else {
                  d2 = 1;
                  while (1) {
                    c3 = cd(a3 | 0, b2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
                    G() | 0;
                    c3 = c3 & 7;
                    if (c3 | 0) {
                      break a;
                    }
                    if (d2 >>> 0 < e3 >>> 0) {
                      d2 = d2 + 1 | 0;
                    } else {
                      c3 = 0;
                      break;
                    }
                  }
                }
              } while (0);
            e3 = (c3 | 0) == 0 & 1;
            return e3 | 0;
          }
          function Gb(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            d2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            d2 = d2 & 15;
            if ((c3 | 0) < 16 & (d2 | 0) <= (c3 | 0)) {
              if ((d2 | 0) != (c3 | 0)) {
                e3 = dd(c3 | 0, 0, 52) | 0;
                a3 = e3 | a3;
                b2 = G() | 0 | b2 & -15728641;
                if ((d2 | 0) < (c3 | 0)) {
                  do {
                    e3 = dd(7, 0, (14 - d2 | 0) * 3 | 0) | 0;
                    d2 = d2 + 1 | 0;
                    a3 = a3 & ~e3;
                    b2 = b2 & ~(G() | 0);
                  } while ((d2 | 0) < (c3 | 0));
                }
              }
            } else {
              b2 = 0;
              a3 = 0;
            }
            F(b2 | 0);
            return a3 | 0;
          }
          function Hb(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0;
            if (!d2) {
              y3 = 0;
              return y3 | 0;
            }
            f2 = a3;
            e3 = b[f2 >> 2] | 0;
            f2 = b[f2 + 4 >> 2] | 0;
            if (true & (f2 & 15728640 | 0) == 0) {
              if ((d2 | 0) <= 0) {
                y3 = 0;
                return y3 | 0;
              }
              y3 = c3;
              b[y3 >> 2] = e3;
              b[y3 + 4 >> 2] = f2;
              if ((d2 | 0) == 1) {
                y3 = 0;
                return y3 | 0;
              }
              e3 = 1;
              do {
                w2 = a3 + (e3 << 3) | 0;
                x3 = b[w2 + 4 >> 2] | 0;
                y3 = c3 + (e3 << 3) | 0;
                b[y3 >> 2] = b[w2 >> 2];
                b[y3 + 4 >> 2] = x3;
                e3 = e3 + 1 | 0;
              } while ((e3 | 0) != (d2 | 0));
              e3 = 0;
              return e3 | 0;
            }
            w2 = d2 << 3;
            x3 = Wc(w2) | 0;
            if (!x3) {
              y3 = -3;
              return y3 | 0;
            }
            gd(x3 | 0, a3 | 0, w2 | 0) | 0;
            v2 = Yc(d2, 8) | 0;
            if (!v2) {
              Xc(x3);
              y3 = -3;
              return y3 | 0;
            }
            e3 = d2;
            a:
              while (1) {
                h = x3;
                l2 = b[h >> 2] | 0;
                h = b[h + 4 >> 2] | 0;
                t3 = cd(l2 | 0, h | 0, 52) | 0;
                G() | 0;
                t3 = t3 & 15;
                u2 = t3 + -1 | 0;
                s3 = (e3 | 0) > 0;
                b:
                  do {
                    if (s3) {
                      r3 = ((e3 | 0) < 0) << 31 >> 31;
                      p3 = dd(u2 | 0, 0, 52) | 0;
                      q2 = G() | 0;
                      if (u2 >>> 0 > 15) {
                        f2 = 0;
                        a3 = l2;
                        d2 = h;
                        while (1) {
                          if (!((a3 | 0) == 0 & (d2 | 0) == 0)) {
                            g2 = cd(a3 | 0, d2 | 0, 52) | 0;
                            G() | 0;
                            g2 = g2 & 15;
                            i3 = (g2 | 0) < (u2 | 0);
                            g2 = (g2 | 0) == (u2 | 0);
                            k = i3 ? 0 : g2 ? a3 : 0;
                            a3 = i3 ? 0 : g2 ? d2 : 0;
                            d2 = bd(k | 0, a3 | 0, e3 | 0, r3 | 0) | 0;
                            G() | 0;
                            g2 = v2 + (d2 << 3) | 0;
                            i3 = g2;
                            j = b[i3 >> 2] | 0;
                            i3 = b[i3 + 4 >> 2] | 0;
                            if ((j | 0) == 0 & (i3 | 0) == 0) {
                              d2 = k;
                            } else {
                              p3 = 0;
                              o2 = d2;
                              n2 = i3;
                              d2 = k;
                              while (1) {
                                if ((p3 | 0) > (e3 | 0)) {
                                  y3 = 41;
                                  break a;
                                }
                                if ((j | 0) == (d2 | 0) & (n2 & -117440513 | 0) == (a3 | 0)) {
                                  k = cd(j | 0, n2 | 0, 56) | 0;
                                  G() | 0;
                                  k = k & 7;
                                  m = k + 1 | 0;
                                  q2 = cd(j | 0, n2 | 0, 45) | 0;
                                  G() | 0;
                                  c:
                                    do {
                                      if (!(la(q2 & 127) | 0)) {
                                        i3 = 7;
                                      } else {
                                        j = cd(j | 0, n2 | 0, 52) | 0;
                                        G() | 0;
                                        j = j & 15;
                                        if (!j) {
                                          i3 = 6;
                                          break;
                                        }
                                        i3 = 1;
                                        while (1) {
                                          q2 = dd(7, 0, (15 - i3 | 0) * 3 | 0) | 0;
                                          if (!((q2 & d2 | 0) == 0 & ((G() | 0) & a3 | 0) == 0)) {
                                            i3 = 7;
                                            break c;
                                          }
                                          if (i3 >>> 0 < j >>> 0) {
                                            i3 = i3 + 1 | 0;
                                          } else {
                                            i3 = 6;
                                            break;
                                          }
                                        }
                                      }
                                    } while (0);
                                  if ((k + 2 | 0) >>> 0 > i3 >>> 0) {
                                    y3 = 51;
                                    break a;
                                  }
                                  q2 = dd(m | 0, 0, 56) | 0;
                                  a3 = G() | 0 | a3 & -117440513;
                                  i3 = g2;
                                  b[i3 >> 2] = 0;
                                  b[i3 + 4 >> 2] = 0;
                                  i3 = o2;
                                  d2 = q2 | d2;
                                } else {
                                  i3 = (o2 + 1 | 0) % (e3 | 0) | 0;
                                }
                                g2 = v2 + (i3 << 3) | 0;
                                n2 = g2;
                                j = b[n2 >> 2] | 0;
                                n2 = b[n2 + 4 >> 2] | 0;
                                if ((j | 0) == 0 & (n2 | 0) == 0) {
                                  break;
                                } else {
                                  p3 = p3 + 1 | 0;
                                  o2 = i3;
                                }
                              }
                            }
                            q2 = g2;
                            b[q2 >> 2] = d2;
                            b[q2 + 4 >> 2] = a3;
                          }
                          f2 = f2 + 1 | 0;
                          if ((f2 | 0) >= (e3 | 0)) {
                            break b;
                          }
                          d2 = x3 + (f2 << 3) | 0;
                          a3 = b[d2 >> 2] | 0;
                          d2 = b[d2 + 4 >> 2] | 0;
                        }
                      }
                      f2 = 0;
                      a3 = l2;
                      d2 = h;
                      while (1) {
                        if (!((a3 | 0) == 0 & (d2 | 0) == 0)) {
                          i3 = cd(a3 | 0, d2 | 0, 52) | 0;
                          G() | 0;
                          i3 = i3 & 15;
                          if ((i3 | 0) >= (u2 | 0)) {
                            if ((i3 | 0) != (u2 | 0)) {
                              a3 = a3 | p3;
                              d2 = d2 & -15728641 | q2;
                              if (i3 >>> 0 >= t3 >>> 0) {
                                g2 = u2;
                                do {
                                  o2 = dd(7, 0, (14 - g2 | 0) * 3 | 0) | 0;
                                  g2 = g2 + 1 | 0;
                                  a3 = o2 | a3;
                                  d2 = G() | 0 | d2;
                                } while (g2 >>> 0 < i3 >>> 0);
                              }
                            }
                          } else {
                            a3 = 0;
                            d2 = 0;
                          }
                          i3 = bd(a3 | 0, d2 | 0, e3 | 0, r3 | 0) | 0;
                          G() | 0;
                          g2 = v2 + (i3 << 3) | 0;
                          j = g2;
                          k = b[j >> 2] | 0;
                          j = b[j + 4 >> 2] | 0;
                          if (!((k | 0) == 0 & (j | 0) == 0)) {
                            o2 = 0;
                            while (1) {
                              if ((o2 | 0) > (e3 | 0)) {
                                y3 = 41;
                                break a;
                              }
                              if ((k | 0) == (a3 | 0) & (j & -117440513 | 0) == (d2 | 0)) {
                                m = cd(k | 0, j | 0, 56) | 0;
                                G() | 0;
                                m = m & 7;
                                n2 = m + 1 | 0;
                                z2 = cd(k | 0, j | 0, 45) | 0;
                                G() | 0;
                                d:
                                  do {
                                    if (!(la(z2 & 127) | 0)) {
                                      j = 7;
                                    } else {
                                      k = cd(k | 0, j | 0, 52) | 0;
                                      G() | 0;
                                      k = k & 15;
                                      if (!k) {
                                        j = 6;
                                        break;
                                      }
                                      j = 1;
                                      while (1) {
                                        z2 = dd(7, 0, (15 - j | 0) * 3 | 0) | 0;
                                        if (!((z2 & a3 | 0) == 0 & ((G() | 0) & d2 | 0) == 0)) {
                                          j = 7;
                                          break d;
                                        }
                                        if (j >>> 0 < k >>> 0) {
                                          j = j + 1 | 0;
                                        } else {
                                          j = 6;
                                          break;
                                        }
                                      }
                                    }
                                  } while (0);
                                if ((m + 2 | 0) >>> 0 > j >>> 0) {
                                  y3 = 51;
                                  break a;
                                }
                                z2 = dd(n2 | 0, 0, 56) | 0;
                                d2 = G() | 0 | d2 & -117440513;
                                n2 = g2;
                                b[n2 >> 2] = 0;
                                b[n2 + 4 >> 2] = 0;
                                a3 = z2 | a3;
                              } else {
                                i3 = (i3 + 1 | 0) % (e3 | 0) | 0;
                              }
                              g2 = v2 + (i3 << 3) | 0;
                              j = g2;
                              k = b[j >> 2] | 0;
                              j = b[j + 4 >> 2] | 0;
                              if ((k | 0) == 0 & (j | 0) == 0) {
                                break;
                              } else {
                                o2 = o2 + 1 | 0;
                              }
                            }
                          }
                          z2 = g2;
                          b[z2 >> 2] = a3;
                          b[z2 + 4 >> 2] = d2;
                        }
                        f2 = f2 + 1 | 0;
                        if ((f2 | 0) >= (e3 | 0)) {
                          break b;
                        }
                        d2 = x3 + (f2 << 3) | 0;
                        a3 = b[d2 >> 2] | 0;
                        d2 = b[d2 + 4 >> 2] | 0;
                      }
                    }
                  } while (0);
                if ((e3 + 5 | 0) >>> 0 < 11) {
                  y3 = 99;
                  break;
                }
                q2 = Yc((e3 | 0) / 6 | 0, 8) | 0;
                if (!q2) {
                  y3 = 58;
                  break;
                }
                e:
                  do {
                    if (s3) {
                      o2 = 0;
                      n2 = 0;
                      do {
                        i3 = v2 + (o2 << 3) | 0;
                        a3 = i3;
                        f2 = b[a3 >> 2] | 0;
                        a3 = b[a3 + 4 >> 2] | 0;
                        if (!((f2 | 0) == 0 & (a3 | 0) == 0)) {
                          j = cd(f2 | 0, a3 | 0, 56) | 0;
                          G() | 0;
                          j = j & 7;
                          d2 = j + 1 | 0;
                          k = a3 & -117440513;
                          z2 = cd(f2 | 0, a3 | 0, 45) | 0;
                          G() | 0;
                          f:
                            do {
                              if (la(z2 & 127) | 0) {
                                m = cd(f2 | 0, a3 | 0, 52) | 0;
                                G() | 0;
                                m = m & 15;
                                if (m | 0) {
                                  g2 = 1;
                                  while (1) {
                                    z2 = dd(7, 0, (15 - g2 | 0) * 3 | 0) | 0;
                                    if (!((f2 & z2 | 0) == 0 & (k & (G() | 0) | 0) == 0)) {
                                      break f;
                                    }
                                    if (g2 >>> 0 < m >>> 0) {
                                      g2 = g2 + 1 | 0;
                                    } else {
                                      break;
                                    }
                                  }
                                }
                                a3 = dd(d2 | 0, 0, 56) | 0;
                                f2 = a3 | f2;
                                a3 = G() | 0 | k;
                                d2 = i3;
                                b[d2 >> 2] = f2;
                                b[d2 + 4 >> 2] = a3;
                                d2 = j + 2 | 0;
                              }
                            } while (0);
                          if ((d2 | 0) == 7) {
                            z2 = q2 + (n2 << 3) | 0;
                            b[z2 >> 2] = f2;
                            b[z2 + 4 >> 2] = a3 & -117440513;
                            n2 = n2 + 1 | 0;
                          }
                        }
                        o2 = o2 + 1 | 0;
                      } while ((o2 | 0) != (e3 | 0));
                      if (s3) {
                        p3 = ((e3 | 0) < 0) << 31 >> 31;
                        m = dd(u2 | 0, 0, 52) | 0;
                        o2 = G() | 0;
                        if (u2 >>> 0 > 15) {
                          a3 = 0;
                          f2 = 0;
                          while (1) {
                            do {
                              if (!((l2 | 0) == 0 & (h | 0) == 0)) {
                                j = cd(l2 | 0, h | 0, 52) | 0;
                                G() | 0;
                                j = j & 15;
                                g2 = (j | 0) < (u2 | 0);
                                j = (j | 0) == (u2 | 0);
                                i3 = g2 ? 0 : j ? l2 : 0;
                                j = g2 ? 0 : j ? h : 0;
                                g2 = bd(i3 | 0, j | 0, e3 | 0, p3 | 0) | 0;
                                G() | 0;
                                d2 = 0;
                                while (1) {
                                  if ((d2 | 0) > (e3 | 0)) {
                                    y3 = 98;
                                    break a;
                                  }
                                  z2 = v2 + (g2 << 3) | 0;
                                  k = b[z2 + 4 >> 2] | 0;
                                  if ((k & -117440513 | 0) == (j | 0) ? (b[z2 >> 2] | 0) == (i3 | 0) : 0) {
                                    y3 = 70;
                                    break;
                                  }
                                  g2 = (g2 + 1 | 0) % (e3 | 0) | 0;
                                  z2 = v2 + (g2 << 3) | 0;
                                  if ((b[z2 >> 2] | 0) == (i3 | 0) ? (b[z2 + 4 >> 2] | 0) == (j | 0) : 0) {
                                    break;
                                  } else {
                                    d2 = d2 + 1 | 0;
                                  }
                                }
                                if ((y3 | 0) == 70 ? (y3 = 0, true & (k & 117440512 | 0) == 100663296) : 0) {
                                  break;
                                }
                                z2 = c3 + (f2 << 3) | 0;
                                b[z2 >> 2] = l2;
                                b[z2 + 4 >> 2] = h;
                                f2 = f2 + 1 | 0;
                              }
                            } while (0);
                            a3 = a3 + 1 | 0;
                            if ((a3 | 0) >= (e3 | 0)) {
                              e3 = n2;
                              break e;
                            }
                            h = x3 + (a3 << 3) | 0;
                            l2 = b[h >> 2] | 0;
                            h = b[h + 4 >> 2] | 0;
                          }
                        }
                        a3 = 0;
                        f2 = 0;
                        while (1) {
                          do {
                            if (!((l2 | 0) == 0 & (h | 0) == 0)) {
                              j = cd(l2 | 0, h | 0, 52) | 0;
                              G() | 0;
                              j = j & 15;
                              if ((j | 0) >= (u2 | 0)) {
                                if ((j | 0) != (u2 | 0)) {
                                  d2 = l2 | m;
                                  g2 = h & -15728641 | o2;
                                  if (j >>> 0 < t3 >>> 0) {
                                    j = g2;
                                  } else {
                                    i3 = u2;
                                    do {
                                      z2 = dd(7, 0, (14 - i3 | 0) * 3 | 0) | 0;
                                      i3 = i3 + 1 | 0;
                                      d2 = z2 | d2;
                                      g2 = G() | 0 | g2;
                                    } while (i3 >>> 0 < j >>> 0);
                                    j = g2;
                                  }
                                } else {
                                  d2 = l2;
                                  j = h;
                                }
                              } else {
                                d2 = 0;
                                j = 0;
                              }
                              i3 = bd(d2 | 0, j | 0, e3 | 0, p3 | 0) | 0;
                              G() | 0;
                              g2 = 0;
                              while (1) {
                                if ((g2 | 0) > (e3 | 0)) {
                                  y3 = 98;
                                  break a;
                                }
                                z2 = v2 + (i3 << 3) | 0;
                                k = b[z2 + 4 >> 2] | 0;
                                if ((k & -117440513 | 0) == (j | 0) ? (b[z2 >> 2] | 0) == (d2 | 0) : 0) {
                                  y3 = 93;
                                  break;
                                }
                                i3 = (i3 + 1 | 0) % (e3 | 0) | 0;
                                z2 = v2 + (i3 << 3) | 0;
                                if ((b[z2 >> 2] | 0) == (d2 | 0) ? (b[z2 + 4 >> 2] | 0) == (j | 0) : 0) {
                                  break;
                                } else {
                                  g2 = g2 + 1 | 0;
                                }
                              }
                              if ((y3 | 0) == 93 ? (y3 = 0, true & (k & 117440512 | 0) == 100663296) : 0) {
                                break;
                              }
                              z2 = c3 + (f2 << 3) | 0;
                              b[z2 >> 2] = l2;
                              b[z2 + 4 >> 2] = h;
                              f2 = f2 + 1 | 0;
                            }
                          } while (0);
                          a3 = a3 + 1 | 0;
                          if ((a3 | 0) >= (e3 | 0)) {
                            e3 = n2;
                            break e;
                          }
                          h = x3 + (a3 << 3) | 0;
                          l2 = b[h >> 2] | 0;
                          h = b[h + 4 >> 2] | 0;
                        }
                      } else {
                        f2 = 0;
                        e3 = n2;
                      }
                    } else {
                      f2 = 0;
                      e3 = 0;
                    }
                  } while (0);
                hd(v2 | 0, 0, w2 | 0) | 0;
                gd(x3 | 0, q2 | 0, e3 << 3 | 0) | 0;
                Xc(q2);
                if (!e3) {
                  break;
                } else {
                  c3 = c3 + (f2 << 3) | 0;
                }
              }
            if ((y3 | 0) == 41) {
              Xc(x3);
              Xc(v2);
              z2 = -1;
              return z2 | 0;
            } else if ((y3 | 0) == 51) {
              Xc(x3);
              Xc(v2);
              z2 = -2;
              return z2 | 0;
            } else if ((y3 | 0) == 58) {
              Xc(x3);
              Xc(v2);
              z2 = -3;
              return z2 | 0;
            } else if ((y3 | 0) == 98) {
              Xc(q2);
              Xc(x3);
              Xc(v2);
              z2 = -1;
              return z2 | 0;
            } else if ((y3 | 0) == 99) {
              gd(c3 | 0, x3 | 0, e3 << 3 | 0) | 0;
            }
            Xc(x3);
            Xc(v2);
            z2 = 0;
            return z2 | 0;
          }
          function Ib(a3, c3, d2, e3, f2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            f2 = f2 | 0;
            var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            if ((c3 | 0) <= 0) {
              f2 = 0;
              return f2 | 0;
            }
            if ((f2 | 0) >= 16) {
              g2 = 0;
              while (1) {
                l2 = a3 + (g2 << 3) | 0;
                if (!((b[l2 >> 2] | 0) == 0 & (b[l2 + 4 >> 2] | 0) == 0)) {
                  g2 = 14;
                  break;
                }
                g2 = g2 + 1 | 0;
                if ((g2 | 0) >= (c3 | 0)) {
                  h = 0;
                  g2 = 16;
                  break;
                }
              }
              if ((g2 | 0) == 14) {
                return ((e3 | 0) > 0 ? -2 : -1) | 0;
              } else if ((g2 | 0) == 16) {
                return h | 0;
              }
            }
            g2 = 0;
            l2 = 0;
            a:
              while (1) {
                k = a3 + (l2 << 3) | 0;
                i3 = k;
                h = b[i3 >> 2] | 0;
                i3 = b[i3 + 4 >> 2] | 0;
                do {
                  if (!((h | 0) == 0 & (i3 | 0) == 0)) {
                    if ((g2 | 0) >= (e3 | 0)) {
                      h = -1;
                      g2 = 16;
                      break a;
                    }
                    j = cd(h | 0, i3 | 0, 52) | 0;
                    G() | 0;
                    j = j & 15;
                    if ((j | 0) > (f2 | 0)) {
                      h = -2;
                      g2 = 16;
                      break a;
                    }
                    if ((j | 0) == (f2 | 0)) {
                      k = d2 + (g2 << 3) | 0;
                      b[k >> 2] = h;
                      b[k + 4 >> 2] = i3;
                      g2 = g2 + 1 | 0;
                      break;
                    }
                    h = (tc(7, f2 - j | 0) | 0) + g2 | 0;
                    if ((h | 0) > (e3 | 0)) {
                      h = -1;
                      g2 = 16;
                      break a;
                    }
                    Eb(b[k >> 2] | 0, b[k + 4 >> 2] | 0, f2, d2 + (g2 << 3) | 0);
                    g2 = h;
                  }
                } while (0);
                l2 = l2 + 1 | 0;
                if ((l2 | 0) >= (c3 | 0)) {
                  h = 0;
                  g2 = 16;
                  break;
                }
              }
            if ((g2 | 0) == 16) {
              return h | 0;
            }
            return 0;
          }
          function Jb(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0;
            if ((c3 | 0) <= 0) {
              d2 = 0;
              return d2 | 0;
            }
            if ((d2 | 0) >= 16) {
              e3 = 0;
              while (1) {
                h = a3 + (e3 << 3) | 0;
                if (!((b[h >> 2] | 0) == 0 & (b[h + 4 >> 2] | 0) == 0)) {
                  e3 = -1;
                  f2 = 13;
                  break;
                }
                e3 = e3 + 1 | 0;
                if ((e3 | 0) >= (c3 | 0)) {
                  e3 = 0;
                  f2 = 13;
                  break;
                }
              }
              if ((f2 | 0) == 13) {
                return e3 | 0;
              }
            }
            e3 = 0;
            h = 0;
            a:
              while (1) {
                f2 = a3 + (h << 3) | 0;
                g2 = b[f2 >> 2] | 0;
                f2 = b[f2 + 4 >> 2] | 0;
                do {
                  if (!((g2 | 0) == 0 & (f2 | 0) == 0)) {
                    f2 = cd(g2 | 0, f2 | 0, 52) | 0;
                    G() | 0;
                    f2 = f2 & 15;
                    if ((f2 | 0) > (d2 | 0)) {
                      e3 = -1;
                      f2 = 13;
                      break a;
                    }
                    if ((f2 | 0) == (d2 | 0)) {
                      e3 = e3 + 1 | 0;
                      break;
                    } else {
                      e3 = (tc(7, d2 - f2 | 0) | 0) + e3 | 0;
                      break;
                    }
                  }
                } while (0);
                h = h + 1 | 0;
                if ((h | 0) >= (c3 | 0)) {
                  f2 = 13;
                  break;
                }
              }
            if ((f2 | 0) == 13) {
              return e3 | 0;
            }
            return 0;
          }
          function Kb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            b2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            return b2 & 1 | 0;
          }
          function Lb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0;
            e3 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            e3 = e3 & 15;
            if (!e3) {
              e3 = 0;
              return e3 | 0;
            }
            d2 = 1;
            while (1) {
              c3 = cd(a3 | 0, b2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
              G() | 0;
              c3 = c3 & 7;
              if (c3 | 0) {
                d2 = 5;
                break;
              }
              if (d2 >>> 0 < e3 >>> 0) {
                d2 = d2 + 1 | 0;
              } else {
                c3 = 0;
                d2 = 5;
                break;
              }
            }
            if ((d2 | 0) == 5) {
              return c3 | 0;
            }
            return 0;
          }
          function Mb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            i3 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            i3 = i3 & 15;
            if (!i3) {
              h = b2;
              i3 = a3;
              F(h | 0);
              return i3 | 0;
            }
            h = 1;
            c3 = 0;
            while (1) {
              f2 = (15 - h | 0) * 3 | 0;
              d2 = dd(7, 0, f2 | 0) | 0;
              e3 = G() | 0;
              g2 = cd(a3 | 0, b2 | 0, f2 | 0) | 0;
              G() | 0;
              f2 = dd(Pa(g2 & 7) | 0, 0, f2 | 0) | 0;
              g2 = G() | 0;
              a3 = f2 | a3 & ~d2;
              b2 = g2 | b2 & ~e3;
              a:
                do {
                  if (!c3) {
                    if (!((f2 & d2 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                      d2 = cd(a3 | 0, b2 | 0, 52) | 0;
                      G() | 0;
                      d2 = d2 & 15;
                      if (!d2) {
                        c3 = 1;
                      } else {
                        c3 = 1;
                        b:
                          while (1) {
                            g2 = cd(a3 | 0, b2 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                            G() | 0;
                            switch (g2 & 7) {
                              case 1:
                                break b;
                              case 0:
                                break;
                              default: {
                                c3 = 1;
                                break a;
                              }
                            }
                            if (c3 >>> 0 < d2 >>> 0) {
                              c3 = c3 + 1 | 0;
                            } else {
                              c3 = 1;
                              break a;
                            }
                          }
                        c3 = 1;
                        while (1) {
                          g2 = (15 - c3 | 0) * 3 | 0;
                          e3 = cd(a3 | 0, b2 | 0, g2 | 0) | 0;
                          G() | 0;
                          f2 = dd(7, 0, g2 | 0) | 0;
                          b2 = b2 & ~(G() | 0);
                          g2 = dd(Pa(e3 & 7) | 0, 0, g2 | 0) | 0;
                          a3 = a3 & ~f2 | g2;
                          b2 = b2 | (G() | 0);
                          if (c3 >>> 0 < d2 >>> 0) {
                            c3 = c3 + 1 | 0;
                          } else {
                            c3 = 1;
                            break;
                          }
                        }
                      }
                    } else {
                      c3 = 0;
                    }
                  }
                } while (0);
              if (h >>> 0 < i3 >>> 0) {
                h = h + 1 | 0;
              } else {
                break;
              }
            }
            F(b2 | 0);
            return a3 | 0;
          }
          function Nb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0;
            d2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            d2 = d2 & 15;
            if (!d2) {
              c3 = b2;
              d2 = a3;
              F(c3 | 0);
              return d2 | 0;
            }
            c3 = 1;
            while (1) {
              f2 = (15 - c3 | 0) * 3 | 0;
              g2 = cd(a3 | 0, b2 | 0, f2 | 0) | 0;
              G() | 0;
              e3 = dd(7, 0, f2 | 0) | 0;
              b2 = b2 & ~(G() | 0);
              f2 = dd(Pa(g2 & 7) | 0, 0, f2 | 0) | 0;
              a3 = f2 | a3 & ~e3;
              b2 = G() | 0 | b2;
              if (c3 >>> 0 < d2 >>> 0) {
                c3 = c3 + 1 | 0;
              } else {
                break;
              }
            }
            F(b2 | 0);
            return a3 | 0;
          }
          function Ob(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            i3 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            i3 = i3 & 15;
            if (!i3) {
              h = b2;
              i3 = a3;
              F(h | 0);
              return i3 | 0;
            }
            h = 1;
            c3 = 0;
            while (1) {
              f2 = (15 - h | 0) * 3 | 0;
              d2 = dd(7, 0, f2 | 0) | 0;
              e3 = G() | 0;
              g2 = cd(a3 | 0, b2 | 0, f2 | 0) | 0;
              G() | 0;
              f2 = dd(Qa(g2 & 7) | 0, 0, f2 | 0) | 0;
              g2 = G() | 0;
              a3 = f2 | a3 & ~d2;
              b2 = g2 | b2 & ~e3;
              a:
                do {
                  if (!c3) {
                    if (!((f2 & d2 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                      d2 = cd(a3 | 0, b2 | 0, 52) | 0;
                      G() | 0;
                      d2 = d2 & 15;
                      if (!d2) {
                        c3 = 1;
                      } else {
                        c3 = 1;
                        b:
                          while (1) {
                            g2 = cd(a3 | 0, b2 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                            G() | 0;
                            switch (g2 & 7) {
                              case 1:
                                break b;
                              case 0:
                                break;
                              default: {
                                c3 = 1;
                                break a;
                              }
                            }
                            if (c3 >>> 0 < d2 >>> 0) {
                              c3 = c3 + 1 | 0;
                            } else {
                              c3 = 1;
                              break a;
                            }
                          }
                        c3 = 1;
                        while (1) {
                          e3 = (15 - c3 | 0) * 3 | 0;
                          f2 = dd(7, 0, e3 | 0) | 0;
                          g2 = b2 & ~(G() | 0);
                          b2 = cd(a3 | 0, b2 | 0, e3 | 0) | 0;
                          G() | 0;
                          b2 = dd(Qa(b2 & 7) | 0, 0, e3 | 0) | 0;
                          a3 = a3 & ~f2 | b2;
                          b2 = g2 | (G() | 0);
                          if (c3 >>> 0 < d2 >>> 0) {
                            c3 = c3 + 1 | 0;
                          } else {
                            c3 = 1;
                            break;
                          }
                        }
                      }
                    } else {
                      c3 = 0;
                    }
                  }
                } while (0);
              if (h >>> 0 < i3 >>> 0) {
                h = h + 1 | 0;
              } else {
                break;
              }
            }
            F(b2 | 0);
            return a3 | 0;
          }
          function Pb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0;
            d2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            d2 = d2 & 15;
            if (!d2) {
              c3 = b2;
              d2 = a3;
              F(c3 | 0);
              return d2 | 0;
            }
            c3 = 1;
            while (1) {
              g2 = (15 - c3 | 0) * 3 | 0;
              f2 = dd(7, 0, g2 | 0) | 0;
              e3 = b2 & ~(G() | 0);
              b2 = cd(a3 | 0, b2 | 0, g2 | 0) | 0;
              G() | 0;
              b2 = dd(Qa(b2 & 7) | 0, 0, g2 | 0) | 0;
              a3 = b2 | a3 & ~f2;
              b2 = G() | 0 | e3;
              if (c3 >>> 0 < d2 >>> 0) {
                c3 = c3 + 1 | 0;
              } else {
                break;
              }
            }
            F(b2 | 0);
            return a3 | 0;
          }
          function Qb(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            j = S;
            S = S + 64 | 0;
            i3 = j + 40 | 0;
            e3 = j + 24 | 0;
            f2 = j + 12 | 0;
            g2 = j;
            dd(c3 | 0, 0, 52) | 0;
            d2 = G() | 0 | 134225919;
            if (!c3) {
              if ((b[a3 + 4 >> 2] | 0) > 2) {
                h = 0;
                i3 = 0;
                F(h | 0);
                S = j;
                return i3 | 0;
              }
              if ((b[a3 + 8 >> 2] | 0) > 2) {
                h = 0;
                i3 = 0;
                F(h | 0);
                S = j;
                return i3 | 0;
              }
              if ((b[a3 + 12 >> 2] | 0) > 2) {
                h = 0;
                i3 = 0;
                F(h | 0);
                S = j;
                return i3 | 0;
              }
              dd(na(a3) | 0, 0, 45) | 0;
              h = G() | 0 | d2;
              i3 = -1;
              F(h | 0);
              S = j;
              return i3 | 0;
            }
            b[i3 >> 2] = b[a3 >> 2];
            b[i3 + 4 >> 2] = b[a3 + 4 >> 2];
            b[i3 + 8 >> 2] = b[a3 + 8 >> 2];
            b[i3 + 12 >> 2] = b[a3 + 12 >> 2];
            h = i3 + 4 | 0;
            if ((c3 | 0) > 0) {
              a3 = -1;
              while (1) {
                b[e3 >> 2] = b[h >> 2];
                b[e3 + 4 >> 2] = b[h + 4 >> 2];
                b[e3 + 8 >> 2] = b[h + 8 >> 2];
                if (!(c3 & 1)) {
                  Ja(h);
                  b[f2 >> 2] = b[h >> 2];
                  b[f2 + 4 >> 2] = b[h + 4 >> 2];
                  b[f2 + 8 >> 2] = b[h + 8 >> 2];
                  La(f2);
                } else {
                  Ia(h);
                  b[f2 >> 2] = b[h >> 2];
                  b[f2 + 4 >> 2] = b[h + 4 >> 2];
                  b[f2 + 8 >> 2] = b[h + 8 >> 2];
                  Ka(f2);
                }
                Fa(e3, f2, g2);
                Ca(g2);
                l2 = (15 - c3 | 0) * 3 | 0;
                k = dd(7, 0, l2 | 0) | 0;
                d2 = d2 & ~(G() | 0);
                l2 = dd(Ha(g2) | 0, 0, l2 | 0) | 0;
                a3 = l2 | a3 & ~k;
                d2 = G() | 0 | d2;
                if ((c3 | 0) > 1) {
                  c3 = c3 + -1 | 0;
                } else {
                  break;
                }
              }
            } else {
              a3 = -1;
            }
            a:
              do {
                if (((b[h >> 2] | 0) <= 2 ? (b[i3 + 8 >> 2] | 0) <= 2 : 0) ? (b[i3 + 12 >> 2] | 0) <= 2 : 0) {
                  e3 = na(i3) | 0;
                  c3 = dd(e3 | 0, 0, 45) | 0;
                  c3 = c3 | a3;
                  a3 = G() | 0 | d2 & -1040385;
                  g2 = oa(i3) | 0;
                  if (!(la(e3) | 0)) {
                    if ((g2 | 0) <= 0) {
                      break;
                    }
                    f2 = 0;
                    while (1) {
                      e3 = cd(c3 | 0, a3 | 0, 52) | 0;
                      G() | 0;
                      e3 = e3 & 15;
                      if (e3) {
                        d2 = 1;
                        while (1) {
                          l2 = (15 - d2 | 0) * 3 | 0;
                          i3 = cd(c3 | 0, a3 | 0, l2 | 0) | 0;
                          G() | 0;
                          k = dd(7, 0, l2 | 0) | 0;
                          a3 = a3 & ~(G() | 0);
                          l2 = dd(Pa(i3 & 7) | 0, 0, l2 | 0) | 0;
                          c3 = c3 & ~k | l2;
                          a3 = a3 | (G() | 0);
                          if (d2 >>> 0 < e3 >>> 0) {
                            d2 = d2 + 1 | 0;
                          } else {
                            break;
                          }
                        }
                      }
                      f2 = f2 + 1 | 0;
                      if ((f2 | 0) == (g2 | 0)) {
                        break a;
                      }
                    }
                  }
                  f2 = cd(c3 | 0, a3 | 0, 52) | 0;
                  G() | 0;
                  f2 = f2 & 15;
                  b:
                    do {
                      if (f2) {
                        d2 = 1;
                        c:
                          while (1) {
                            l2 = cd(c3 | 0, a3 | 0, (15 - d2 | 0) * 3 | 0) | 0;
                            G() | 0;
                            switch (l2 & 7) {
                              case 1:
                                break c;
                              case 0:
                                break;
                              default:
                                break b;
                            }
                            if (d2 >>> 0 < f2 >>> 0) {
                              d2 = d2 + 1 | 0;
                            } else {
                              break b;
                            }
                          }
                        if (ra(e3, b[i3 >> 2] | 0) | 0) {
                          d2 = 1;
                          while (1) {
                            i3 = (15 - d2 | 0) * 3 | 0;
                            k = dd(7, 0, i3 | 0) | 0;
                            l2 = a3 & ~(G() | 0);
                            a3 = cd(c3 | 0, a3 | 0, i3 | 0) | 0;
                            G() | 0;
                            a3 = dd(Qa(a3 & 7) | 0, 0, i3 | 0) | 0;
                            c3 = c3 & ~k | a3;
                            a3 = l2 | (G() | 0);
                            if (d2 >>> 0 < f2 >>> 0) {
                              d2 = d2 + 1 | 0;
                            } else {
                              break;
                            }
                          }
                        } else {
                          d2 = 1;
                          while (1) {
                            l2 = (15 - d2 | 0) * 3 | 0;
                            i3 = cd(c3 | 0, a3 | 0, l2 | 0) | 0;
                            G() | 0;
                            k = dd(7, 0, l2 | 0) | 0;
                            a3 = a3 & ~(G() | 0);
                            l2 = dd(Pa(i3 & 7) | 0, 0, l2 | 0) | 0;
                            c3 = c3 & ~k | l2;
                            a3 = a3 | (G() | 0);
                            if (d2 >>> 0 < f2 >>> 0) {
                              d2 = d2 + 1 | 0;
                            } else {
                              break;
                            }
                          }
                        }
                      }
                    } while (0);
                  if ((g2 | 0) > 0) {
                    d2 = 0;
                    do {
                      c3 = Mb(c3, a3) | 0;
                      a3 = G() | 0;
                      d2 = d2 + 1 | 0;
                    } while ((d2 | 0) != (g2 | 0));
                  }
                } else {
                  c3 = 0;
                  a3 = 0;
                }
              } while (0);
            k = a3;
            l2 = c3;
            F(k | 0);
            S = j;
            return l2 | 0;
          }
          function Rb(a3) {
            a3 = a3 | 0;
            return (a3 | 0) % 2 | 0 | 0;
          }
          function Sb(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            e3 = S;
            S = S + 16 | 0;
            d2 = e3;
            if ((c3 >>> 0 <= 15 ? !((b[a3 + 4 >> 2] & 2146435072 | 0) == 2146435072) : 0) ? !((b[a3 + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072) : 0) {
              Ya(a3, c3, d2);
              c3 = Qb(d2, c3) | 0;
              a3 = G() | 0;
            } else {
              a3 = 0;
              c3 = 0;
            }
            F(a3 | 0);
            S = e3;
            return c3 | 0;
          }
          function Tb(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0;
            f2 = d2 + 4 | 0;
            g2 = cd(a3 | 0, c3 | 0, 52) | 0;
            G() | 0;
            g2 = g2 & 15;
            h = cd(a3 | 0, c3 | 0, 45) | 0;
            G() | 0;
            e3 = (g2 | 0) == 0;
            if (!(la(h & 127) | 0)) {
              if (e3) {
                h = 0;
                return h | 0;
              }
              if ((b[f2 >> 2] | 0) == 0 ? (b[d2 + 8 >> 2] | 0) == 0 : 0) {
                e3 = (b[d2 + 12 >> 2] | 0) != 0 & 1;
              } else {
                e3 = 1;
              }
            } else if (e3) {
              h = 1;
              return h | 0;
            } else {
              e3 = 1;
            }
            d2 = 1;
            while (1) {
              if (!(d2 & 1)) {
                La(f2);
              } else {
                Ka(f2);
              }
              h = cd(a3 | 0, c3 | 0, (15 - d2 | 0) * 3 | 0) | 0;
              G() | 0;
              Ma(f2, h & 7);
              if (d2 >>> 0 < g2 >>> 0) {
                d2 = d2 + 1 | 0;
              } else {
                break;
              }
            }
            return e3 | 0;
          }
          function Ub(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            l2 = S;
            S = S + 16 | 0;
            j = l2;
            k = cd(a3 | 0, c3 | 0, 45) | 0;
            G() | 0;
            k = k & 127;
            a:
              do {
                if ((la(k) | 0) != 0 ? (g2 = cd(a3 | 0, c3 | 0, 52) | 0, G() | 0, g2 = g2 & 15, (g2 | 0) != 0) : 0) {
                  e3 = 1;
                  b:
                    while (1) {
                      i3 = cd(a3 | 0, c3 | 0, (15 - e3 | 0) * 3 | 0) | 0;
                      G() | 0;
                      switch (i3 & 7) {
                        case 5:
                          break b;
                        case 0:
                          break;
                        default: {
                          e3 = c3;
                          break a;
                        }
                      }
                      if (e3 >>> 0 < g2 >>> 0) {
                        e3 = e3 + 1 | 0;
                      } else {
                        e3 = c3;
                        break a;
                      }
                    }
                  f2 = 1;
                  e3 = c3;
                  while (1) {
                    c3 = (15 - f2 | 0) * 3 | 0;
                    h = dd(7, 0, c3 | 0) | 0;
                    i3 = e3 & ~(G() | 0);
                    e3 = cd(a3 | 0, e3 | 0, c3 | 0) | 0;
                    G() | 0;
                    e3 = dd(Qa(e3 & 7) | 0, 0, c3 | 0) | 0;
                    a3 = a3 & ~h | e3;
                    e3 = i3 | (G() | 0);
                    if (f2 >>> 0 < g2 >>> 0) {
                      f2 = f2 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                } else {
                  e3 = c3;
                }
              } while (0);
            i3 = 7728 + (k * 28 | 0) | 0;
            b[d2 >> 2] = b[i3 >> 2];
            b[d2 + 4 >> 2] = b[i3 + 4 >> 2];
            b[d2 + 8 >> 2] = b[i3 + 8 >> 2];
            b[d2 + 12 >> 2] = b[i3 + 12 >> 2];
            if (!(Tb(a3, e3, d2) | 0)) {
              S = l2;
              return;
            }
            h = d2 + 4 | 0;
            b[j >> 2] = b[h >> 2];
            b[j + 4 >> 2] = b[h + 4 >> 2];
            b[j + 8 >> 2] = b[h + 8 >> 2];
            g2 = cd(a3 | 0, e3 | 0, 52) | 0;
            G() | 0;
            i3 = g2 & 15;
            if (!(g2 & 1)) {
              g2 = i3;
            } else {
              La(h);
              g2 = i3 + 1 | 0;
            }
            if (!(la(k) | 0)) {
              e3 = 0;
            } else {
              c:
                do {
                  if (!i3) {
                    e3 = 0;
                  } else {
                    c3 = 1;
                    while (1) {
                      f2 = cd(a3 | 0, e3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                      G() | 0;
                      f2 = f2 & 7;
                      if (f2 | 0) {
                        e3 = f2;
                        break c;
                      }
                      if (c3 >>> 0 < i3 >>> 0) {
                        c3 = c3 + 1 | 0;
                      } else {
                        e3 = 0;
                        break;
                      }
                    }
                  }
                } while (0);
              e3 = (e3 | 0) == 4 & 1;
            }
            if (!(cb(d2, g2, e3, 0) | 0)) {
              if ((g2 | 0) != (i3 | 0)) {
                b[h >> 2] = b[j >> 2];
                b[h + 4 >> 2] = b[j + 4 >> 2];
                b[h + 8 >> 2] = b[j + 8 >> 2];
              }
            } else {
              if (la(k) | 0) {
                do {
                } while ((cb(d2, g2, 0, 0) | 0) != 0);
              }
              if ((g2 | 0) != (i3 | 0)) {
                Ja(h);
              }
            }
            S = l2;
            return;
          }
          function Vb(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            d2 = S;
            S = S + 16 | 0;
            e3 = d2;
            Ub(a3, b2, e3);
            b2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            $a(e3, b2 & 15, c3);
            S = d2;
            return;
          }
          function Wb(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
            g2 = S;
            S = S + 16 | 0;
            f2 = g2;
            Ub(a3, b2, f2);
            d2 = cd(a3 | 0, b2 | 0, 45) | 0;
            G() | 0;
            d2 = (la(d2 & 127) | 0) == 0;
            e3 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            e3 = e3 & 15;
            a:
              do {
                if (!d2) {
                  if (e3 | 0) {
                    d2 = 1;
                    while (1) {
                      h = dd(7, 0, (15 - d2 | 0) * 3 | 0) | 0;
                      if (!((h & a3 | 0) == 0 & ((G() | 0) & b2 | 0) == 0)) {
                        break a;
                      }
                      if (d2 >>> 0 < e3 >>> 0) {
                        d2 = d2 + 1 | 0;
                      } else {
                        break;
                      }
                    }
                  }
                  ab(f2, e3, 0, 5, c3);
                  S = g2;
                  return;
                }
              } while (0);
            eb(f2, e3, 0, 6, c3);
            S = g2;
            return;
          }
          function Xb(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, e3 = 0;
            d2 = cd(a3 | 0, b2 | 0, 45) | 0;
            G() | 0;
            if (!(la(d2 & 127) | 0)) {
              d2 = 2;
              return d2 | 0;
            }
            d2 = cd(a3 | 0, b2 | 0, 52) | 0;
            G() | 0;
            d2 = d2 & 15;
            if (!d2) {
              d2 = 5;
              return d2 | 0;
            }
            c3 = 1;
            while (1) {
              e3 = dd(7, 0, (15 - c3 | 0) * 3 | 0) | 0;
              if (!((e3 & a3 | 0) == 0 & ((G() | 0) & b2 | 0) == 0)) {
                c3 = 2;
                a3 = 6;
                break;
              }
              if (c3 >>> 0 < d2 >>> 0) {
                c3 = c3 + 1 | 0;
              } else {
                c3 = 5;
                a3 = 6;
                break;
              }
            }
            if ((a3 | 0) == 6) {
              return c3 | 0;
            }
            return 0;
          }
          function Yb(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
            m = S;
            S = S + 128 | 0;
            k = m + 112 | 0;
            g2 = m + 96 | 0;
            l2 = m;
            f2 = cd(a3 | 0, c3 | 0, 52) | 0;
            G() | 0;
            i3 = f2 & 15;
            b[k >> 2] = i3;
            h = cd(a3 | 0, c3 | 0, 45) | 0;
            G() | 0;
            h = h & 127;
            a:
              do {
                if (la(h) | 0) {
                  if (i3 | 0) {
                    e3 = 1;
                    while (1) {
                      j = dd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                      if (!((j & a3 | 0) == 0 & ((G() | 0) & c3 | 0) == 0)) {
                        f2 = 0;
                        break a;
                      }
                      if (e3 >>> 0 < i3 >>> 0) {
                        e3 = e3 + 1 | 0;
                      } else {
                        break;
                      }
                    }
                  }
                  if (!(f2 & 1)) {
                    j = dd(i3 + 1 | 0, 0, 52) | 0;
                    l2 = G() | 0 | c3 & -15728641;
                    k = dd(7, 0, (14 - i3 | 0) * 3 | 0) | 0;
                    Yb((j | a3) & ~k, l2 & ~(G() | 0), d2);
                    S = m;
                    return;
                  } else {
                    f2 = 1;
                  }
                } else {
                  f2 = 0;
                }
              } while (0);
            Ub(a3, c3, g2);
            if (f2) {
              bb(g2, k, l2);
              j = 5;
            } else {
              fb(g2, k, l2);
              j = 6;
            }
            b:
              do {
                if (la(h) | 0) {
                  if (!i3) {
                    e3 = 20;
                  } else {
                    e3 = 1;
                    while (1) {
                      h = dd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                      if (!((h & a3 | 0) == 0 & ((G() | 0) & c3 | 0) == 0)) {
                        e3 = 8;
                        break b;
                      }
                      if (e3 >>> 0 < i3 >>> 0) {
                        e3 = e3 + 1 | 0;
                      } else {
                        e3 = 20;
                        break;
                      }
                    }
                  }
                } else {
                  e3 = 8;
                }
              } while (0);
            hd(d2 | 0, -1, e3 | 0) | 0;
            if (f2) {
              f2 = 0;
              do {
                g2 = l2 + (f2 << 4) | 0;
                db(g2, b[k >> 2] | 0) | 0;
                g2 = b[g2 >> 2] | 0;
                e3 = 0;
                while (1) {
                  h = d2 + (e3 << 2) | 0;
                  i3 = b[h >> 2] | 0;
                  if ((i3 | 0) == -1 | (i3 | 0) == (g2 | 0)) {
                    break;
                  } else {
                    e3 = e3 + 1 | 0;
                  }
                }
                b[h >> 2] = g2;
                f2 = f2 + 1 | 0;
              } while ((f2 | 0) != (j | 0));
            } else {
              f2 = 0;
              do {
                g2 = l2 + (f2 << 4) | 0;
                cb(g2, b[k >> 2] | 0, 0, 1) | 0;
                g2 = b[g2 >> 2] | 0;
                e3 = 0;
                while (1) {
                  h = d2 + (e3 << 2) | 0;
                  i3 = b[h >> 2] | 0;
                  if ((i3 | 0) == -1 | (i3 | 0) == (g2 | 0)) {
                    break;
                  } else {
                    e3 = e3 + 1 | 0;
                  }
                }
                b[h >> 2] = g2;
                f2 = f2 + 1 | 0;
              } while ((f2 | 0) != (j | 0));
            }
            S = m;
            return;
          }
          function Zb() {
            return 12;
          }
          function _b(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
            dd(a3 | 0, 0, 52) | 0;
            i3 = G() | 0 | 134225919;
            if ((a3 | 0) < 1) {
              e3 = 0;
              d2 = 0;
              do {
                if (la(e3) | 0) {
                  dd(e3 | 0, 0, 45) | 0;
                  h = i3 | (G() | 0);
                  a3 = c3 + (d2 << 3) | 0;
                  b[a3 >> 2] = -1;
                  b[a3 + 4 >> 2] = h;
                  d2 = d2 + 1 | 0;
                }
                e3 = e3 + 1 | 0;
              } while ((e3 | 0) != 122);
              return;
            }
            h = 0;
            d2 = 0;
            do {
              if (la(h) | 0) {
                dd(h | 0, 0, 45) | 0;
                e3 = 1;
                f2 = -1;
                g2 = i3 | (G() | 0);
                while (1) {
                  j = dd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                  f2 = f2 & ~j;
                  g2 = g2 & ~(G() | 0);
                  if ((e3 | 0) == (a3 | 0)) {
                    break;
                  } else {
                    e3 = e3 + 1 | 0;
                  }
                }
                j = c3 + (d2 << 3) | 0;
                b[j >> 2] = f2;
                b[j + 4 >> 2] = g2;
                d2 = d2 + 1 | 0;
              }
              h = h + 1 | 0;
            } while ((h | 0) != 122);
            return;
          }
          function $b(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
            i3 = S;
            S = S + 64 | 0;
            h = i3;
            if ((a3 | 0) == (d2 | 0) & (c3 | 0) == (e3 | 0) | (false | (c3 & 2013265920 | 0) != 134217728 | (false | (e3 & 2013265920 | 0) != 134217728))) {
              h = 0;
              S = i3;
              return h | 0;
            }
            f2 = cd(a3 | 0, c3 | 0, 52) | 0;
            G() | 0;
            f2 = f2 & 15;
            g2 = cd(d2 | 0, e3 | 0, 52) | 0;
            G() | 0;
            if ((f2 | 0) != (g2 & 15 | 0)) {
              h = 0;
              S = i3;
              return h | 0;
            }
            g2 = f2 + -1 | 0;
            if (f2 >>> 0 > 1 ? (k = Cb(a3, c3, g2) | 0, j = G() | 0, g2 = Cb(d2, e3, g2) | 0, (k | 0) == (g2 | 0) & (j | 0) == (G() | 0)) : 0) {
              g2 = (f2 ^ 15) * 3 | 0;
              f2 = cd(a3 | 0, c3 | 0, g2 | 0) | 0;
              G() | 0;
              f2 = f2 & 7;
              g2 = cd(d2 | 0, e3 | 0, g2 | 0) | 0;
              G() | 0;
              g2 = g2 & 7;
              if ((f2 | 0) == 0 | (g2 | 0) == 0) {
                k = 1;
                S = i3;
                return k | 0;
              }
              if ((b[21136 + (f2 << 2) >> 2] | 0) == (g2 | 0)) {
                k = 1;
                S = i3;
                return k | 0;
              }
              if ((b[21168 + (f2 << 2) >> 2] | 0) == (g2 | 0)) {
                k = 1;
                S = i3;
                return k | 0;
              }
            }
            f2 = h;
            g2 = f2 + 56 | 0;
            do {
              b[f2 >> 2] = 0;
              f2 = f2 + 4 | 0;
            } while ((f2 | 0) < (g2 | 0));
            $(a3, c3, 1, h);
            k = h;
            if (((((!((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e3 | 0) : 0) ? (k = h + 8 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (k = h + 16 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (k = h + 24 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (k = h + 32 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (k = h + 40 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) {
              f2 = h + 48 | 0;
              f2 = ((b[f2 >> 2] | 0) == (d2 | 0) ? (b[f2 + 4 >> 2] | 0) == (e3 | 0) : 0) & 1;
            } else {
              f2 = 1;
            }
            k = f2;
            S = i3;
            return k | 0;
          }
          function ac(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
            k = S;
            S = S + 16 | 0;
            h = k;
            if (!($b(a3, c3, d2, e3) | 0)) {
              i3 = 0;
              j = 0;
              F(i3 | 0);
              S = k;
              return j | 0;
            }
            i3 = c3 & -2130706433;
            f2 = (Fb(a3, c3) | 0) == 0;
            f2 = f2 ? 1 : 2;
            while (1) {
              b[h >> 2] = 0;
              l2 = da(a3, c3, f2, h) | 0;
              g2 = f2 + 1 | 0;
              if ((l2 | 0) == (d2 | 0) & (G() | 0) == (e3 | 0)) {
                break;
              }
              if (g2 >>> 0 < 7) {
                f2 = g2;
              } else {
                f2 = 0;
                a3 = 0;
                j = 6;
                break;
              }
            }
            if ((j | 0) == 6) {
              F(f2 | 0);
              S = k;
              return a3 | 0;
            }
            l2 = dd(f2 | 0, 0, 56) | 0;
            j = i3 | (G() | 0) | 268435456;
            l2 = a3 | l2;
            F(j | 0);
            S = k;
            return l2 | 0;
          }
          function bc(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0;
            c3 = true & (b2 & 2013265920 | 0) == 268435456;
            F((c3 ? b2 & -2130706433 | 134217728 : 0) | 0);
            return (c3 ? a3 : 0) | 0;
          }
          function cc(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0;
            e3 = S;
            S = S + 16 | 0;
            d2 = e3;
            if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
              c3 = 0;
              d2 = 0;
              F(c3 | 0);
              S = e3;
              return d2 | 0;
            }
            f2 = cd(a3 | 0, c3 | 0, 56) | 0;
            G() | 0;
            b[d2 >> 2] = 0;
            d2 = da(a3, c3 & -2130706433 | 134217728, f2 & 7, d2) | 0;
            c3 = G() | 0;
            F(c3 | 0);
            S = e3;
            return d2 | 0;
          }
          function dc(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0;
            if (!(true & (b2 & 2013265920 | 0) == 268435456)) {
              c3 = 0;
              return c3 | 0;
            }
            c3 = cd(a3 | 0, b2 | 0, 56) | 0;
            G() | 0;
            switch (c3 & 7) {
              case 0:
              case 7: {
                c3 = 0;
                return c3 | 0;
              }
              default:
            }
            c3 = b2 & -2130706433 | 134217728;
            if (true & (b2 & 117440512 | 0) == 16777216 & (Fb(a3, c3) | 0) != 0) {
              c3 = 0;
              return c3 | 0;
            }
            c3 = Bb(a3, c3) | 0;
            return c3 | 0;
          }
          function ec(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            g2 = S;
            S = S + 16 | 0;
            e3 = g2;
            h = true & (c3 & 2013265920 | 0) == 268435456;
            f2 = c3 & -2130706433 | 134217728;
            i3 = d2;
            b[i3 >> 2] = h ? a3 : 0;
            b[i3 + 4 >> 2] = h ? f2 : 0;
            if (h) {
              c3 = cd(a3 | 0, c3 | 0, 56) | 0;
              G() | 0;
              b[e3 >> 2] = 0;
              a3 = da(a3, f2, c3 & 7, e3) | 0;
              c3 = G() | 0;
            } else {
              a3 = 0;
              c3 = 0;
            }
            i3 = d2 + 8 | 0;
            b[i3 >> 2] = a3;
            b[i3 + 4 >> 2] = c3;
            S = g2;
            return;
          }
          function fc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0;
            f2 = (Fb(a3, c3) | 0) == 0;
            c3 = c3 & -2130706433;
            e3 = d2;
            b[e3 >> 2] = f2 ? a3 : 0;
            b[e3 + 4 >> 2] = f2 ? c3 | 285212672 : 0;
            e3 = d2 + 8 | 0;
            b[e3 >> 2] = a3;
            b[e3 + 4 >> 2] = c3 | 301989888;
            e3 = d2 + 16 | 0;
            b[e3 >> 2] = a3;
            b[e3 + 4 >> 2] = c3 | 318767104;
            e3 = d2 + 24 | 0;
            b[e3 >> 2] = a3;
            b[e3 + 4 >> 2] = c3 | 335544320;
            e3 = d2 + 32 | 0;
            b[e3 >> 2] = a3;
            b[e3 + 4 >> 2] = c3 | 352321536;
            d2 = d2 + 40 | 0;
            b[d2 >> 2] = a3;
            b[d2 + 4 >> 2] = c3 | 369098752;
            return;
          }
          function gc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0;
            h = S;
            S = S + 16 | 0;
            g2 = h;
            e3 = cd(a3 | 0, c3 | 0, 56) | 0;
            G() | 0;
            i3 = true & (c3 & 2013265920 | 0) == 268435456;
            f2 = i3 ? a3 : 0;
            a3 = i3 ? c3 & -2130706433 | 134217728 : 0;
            c3 = Lc(f2, a3, e3 & 7) | 0;
            if ((c3 | 0) == -1) {
              b[d2 >> 2] = 0;
              S = h;
              return;
            }
            Ub(f2, a3, g2);
            e3 = cd(f2 | 0, a3 | 0, 52) | 0;
            G() | 0;
            e3 = e3 & 15;
            if (!(Fb(f2, a3) | 0)) {
              eb(g2, e3, c3, 2, d2);
            } else {
              ab(g2, e3, c3, 2, d2);
            }
            S = h;
            return;
          }
          function hc(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0;
            c3 = Yc(1, 12) | 0;
            if (!c3) {
              H(22691, 22646, 49, 22704);
            }
            d2 = a3 + 4 | 0;
            e3 = b[d2 >> 2] | 0;
            if (e3 | 0) {
              e3 = e3 + 8 | 0;
              b[e3 >> 2] = c3;
              b[d2 >> 2] = c3;
              return c3 | 0;
            }
            if (b[a3 >> 2] | 0) {
              H(22721, 22646, 61, 22744);
            }
            e3 = a3;
            b[e3 >> 2] = c3;
            b[d2 >> 2] = c3;
            return c3 | 0;
          }
          function ic(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0;
            e3 = Wc(24) | 0;
            if (!e3) {
              H(22758, 22646, 78, 22772);
            }
            b[e3 >> 2] = b[c3 >> 2];
            b[e3 + 4 >> 2] = b[c3 + 4 >> 2];
            b[e3 + 8 >> 2] = b[c3 + 8 >> 2];
            b[e3 + 12 >> 2] = b[c3 + 12 >> 2];
            b[e3 + 16 >> 2] = 0;
            c3 = a3 + 4 | 0;
            d2 = b[c3 >> 2] | 0;
            if (d2 | 0) {
              b[d2 + 16 >> 2] = e3;
              b[c3 >> 2] = e3;
              return e3 | 0;
            }
            if (b[a3 >> 2] | 0) {
              H(22787, 22646, 82, 22772);
            }
            b[a3 >> 2] = e3;
            b[c3 >> 2] = e3;
            return e3 | 0;
          }
          function jc(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0;
            if (!a3) {
              return;
            }
            e3 = 1;
            while (1) {
              c3 = b[a3 >> 2] | 0;
              if (c3 | 0) {
                do {
                  d2 = b[c3 >> 2] | 0;
                  if (d2 | 0) {
                    do {
                      f2 = d2;
                      d2 = b[d2 + 16 >> 2] | 0;
                      Xc(f2);
                    } while ((d2 | 0) != 0);
                  }
                  f2 = c3;
                  c3 = b[c3 + 8 >> 2] | 0;
                  Xc(f2);
                } while ((c3 | 0) != 0);
              }
              c3 = a3;
              a3 = b[a3 + 8 >> 2] | 0;
              if (!e3) {
                Xc(c3);
              }
              if (!a3) {
                break;
              } else {
                e3 = 0;
              }
            }
            return;
          }
          function kc(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0, F2 = 0, G2 = 0, I2 = 0, J2 = 0, K2 = 0;
            g2 = a3 + 8 | 0;
            if (b[g2 >> 2] | 0) {
              K2 = 1;
              return K2 | 0;
            }
            f2 = b[a3 >> 2] | 0;
            if (!f2) {
              K2 = 0;
              return K2 | 0;
            }
            c3 = f2;
            d2 = 0;
            do {
              d2 = d2 + 1 | 0;
              c3 = b[c3 + 8 >> 2] | 0;
            } while ((c3 | 0) != 0);
            if (d2 >>> 0 < 2) {
              K2 = 0;
              return K2 | 0;
            }
            I2 = Wc(d2 << 2) | 0;
            if (!I2) {
              H(22807, 22646, 317, 22826);
            }
            G2 = Wc(d2 << 5) | 0;
            if (!G2) {
              H(22848, 22646, 321, 22826);
            }
            b[a3 >> 2] = 0;
            z2 = a3 + 4 | 0;
            b[z2 >> 2] = 0;
            b[g2 >> 2] = 0;
            d2 = 0;
            F2 = 0;
            y3 = 0;
            n2 = 0;
            a:
              while (1) {
                m = b[f2 >> 2] | 0;
                if (m) {
                  h = 0;
                  i3 = m;
                  do {
                    k = +e2[i3 + 8 >> 3];
                    c3 = i3;
                    i3 = b[i3 + 16 >> 2] | 0;
                    l2 = (i3 | 0) == 0;
                    g2 = l2 ? m : i3;
                    j = +e2[g2 + 8 >> 3];
                    if (+q(+(k - j)) > 3.141592653589793) {
                      K2 = 14;
                      break;
                    }
                    h = h + (j - k) * (+e2[c3 >> 3] + +e2[g2 >> 3]);
                  } while (!l2);
                  if ((K2 | 0) == 14) {
                    K2 = 0;
                    h = 0;
                    c3 = m;
                    do {
                      x3 = +e2[c3 + 8 >> 3];
                      E = c3 + 16 | 0;
                      D2 = b[E >> 2] | 0;
                      D2 = (D2 | 0) == 0 ? m : D2;
                      w2 = +e2[D2 + 8 >> 3];
                      h = h + (+e2[c3 >> 3] + +e2[D2 >> 3]) * ((w2 < 0 ? w2 + 6.283185307179586 : w2) - (x3 < 0 ? x3 + 6.283185307179586 : x3));
                      c3 = b[((c3 | 0) == 0 ? f2 : E) >> 2] | 0;
                    } while ((c3 | 0) != 0);
                  }
                  if (h > 0) {
                    b[I2 + (F2 << 2) >> 2] = f2;
                    F2 = F2 + 1 | 0;
                    g2 = y3;
                    c3 = n2;
                  } else {
                    K2 = 19;
                  }
                } else {
                  K2 = 19;
                }
                if ((K2 | 0) == 19) {
                  K2 = 0;
                  do {
                    if (!d2) {
                      if (!n2) {
                        if (!(b[a3 >> 2] | 0)) {
                          g2 = z2;
                          i3 = a3;
                          c3 = f2;
                          d2 = a3;
                          break;
                        } else {
                          K2 = 27;
                          break a;
                        }
                      } else {
                        g2 = z2;
                        i3 = n2 + 8 | 0;
                        c3 = f2;
                        d2 = a3;
                        break;
                      }
                    } else {
                      c3 = d2 + 8 | 0;
                      if (b[c3 >> 2] | 0) {
                        K2 = 21;
                        break a;
                      }
                      d2 = Yc(1, 12) | 0;
                      if (!d2) {
                        K2 = 23;
                        break a;
                      }
                      b[c3 >> 2] = d2;
                      g2 = d2 + 4 | 0;
                      i3 = d2;
                      c3 = n2;
                    }
                  } while (0);
                  b[i3 >> 2] = f2;
                  b[g2 >> 2] = f2;
                  i3 = G2 + (y3 << 5) | 0;
                  l2 = b[f2 >> 2] | 0;
                  if (l2) {
                    m = G2 + (y3 << 5) + 8 | 0;
                    e2[m >> 3] = 17976931348623157e292;
                    n2 = G2 + (y3 << 5) + 24 | 0;
                    e2[n2 >> 3] = 17976931348623157e292;
                    e2[i3 >> 3] = -17976931348623157e292;
                    o2 = G2 + (y3 << 5) + 16 | 0;
                    e2[o2 >> 3] = -17976931348623157e292;
                    u2 = 17976931348623157e292;
                    v2 = -17976931348623157e292;
                    g2 = 0;
                    p3 = l2;
                    k = 17976931348623157e292;
                    s3 = 17976931348623157e292;
                    t3 = -17976931348623157e292;
                    j = -17976931348623157e292;
                    while (1) {
                      h = +e2[p3 >> 3];
                      x3 = +e2[p3 + 8 >> 3];
                      p3 = b[p3 + 16 >> 2] | 0;
                      r3 = (p3 | 0) == 0;
                      w2 = +e2[(r3 ? l2 : p3) + 8 >> 3];
                      if (h < k) {
                        e2[m >> 3] = h;
                        k = h;
                      }
                      if (x3 < s3) {
                        e2[n2 >> 3] = x3;
                        s3 = x3;
                      }
                      if (h > t3) {
                        e2[i3 >> 3] = h;
                      } else {
                        h = t3;
                      }
                      if (x3 > j) {
                        e2[o2 >> 3] = x3;
                        j = x3;
                      }
                      u2 = x3 > 0 & x3 < u2 ? x3 : u2;
                      v2 = x3 < 0 & x3 > v2 ? x3 : v2;
                      g2 = g2 | +q(+(x3 - w2)) > 3.141592653589793;
                      if (r3) {
                        break;
                      } else {
                        t3 = h;
                      }
                    }
                    if (g2) {
                      e2[o2 >> 3] = v2;
                      e2[n2 >> 3] = u2;
                    }
                  } else {
                    b[i3 >> 2] = 0;
                    b[i3 + 4 >> 2] = 0;
                    b[i3 + 8 >> 2] = 0;
                    b[i3 + 12 >> 2] = 0;
                    b[i3 + 16 >> 2] = 0;
                    b[i3 + 20 >> 2] = 0;
                    b[i3 + 24 >> 2] = 0;
                    b[i3 + 28 >> 2] = 0;
                  }
                  g2 = y3 + 1 | 0;
                }
                E = f2 + 8 | 0;
                f2 = b[E >> 2] | 0;
                b[E >> 2] = 0;
                if (!f2) {
                  K2 = 45;
                  break;
                } else {
                  y3 = g2;
                  n2 = c3;
                }
              }
            if ((K2 | 0) == 21) {
              H(22624, 22646, 35, 22658);
            } else if ((K2 | 0) == 23) {
              H(22678, 22646, 37, 22658);
            } else if ((K2 | 0) == 27) {
              H(22721, 22646, 61, 22744);
            } else if ((K2 | 0) == 45) {
              b:
                do {
                  if ((F2 | 0) > 0) {
                    E = (g2 | 0) == 0;
                    C2 = g2 << 2;
                    D2 = (a3 | 0) == 0;
                    B2 = 0;
                    c3 = 0;
                    while (1) {
                      A2 = b[I2 + (B2 << 2) >> 2] | 0;
                      if (!E) {
                        y3 = Wc(C2) | 0;
                        if (!y3) {
                          K2 = 50;
                          break;
                        }
                        z2 = Wc(C2) | 0;
                        if (!z2) {
                          K2 = 52;
                          break;
                        }
                        c:
                          do {
                            if (!D2) {
                              g2 = 0;
                              d2 = 0;
                              i3 = a3;
                              while (1) {
                                f2 = G2 + (g2 << 5) | 0;
                                if (lc(b[i3 >> 2] | 0, f2, b[A2 >> 2] | 0) | 0) {
                                  b[y3 + (d2 << 2) >> 2] = i3;
                                  b[z2 + (d2 << 2) >> 2] = f2;
                                  r3 = d2 + 1 | 0;
                                } else {
                                  r3 = d2;
                                }
                                i3 = b[i3 + 8 >> 2] | 0;
                                if (!i3) {
                                  break;
                                } else {
                                  g2 = g2 + 1 | 0;
                                  d2 = r3;
                                }
                              }
                              if ((r3 | 0) > 0) {
                                f2 = b[y3 >> 2] | 0;
                                if ((r3 | 0) == 1) {
                                  d2 = f2;
                                } else {
                                  o2 = 0;
                                  p3 = -1;
                                  d2 = f2;
                                  n2 = f2;
                                  while (1) {
                                    l2 = b[n2 >> 2] | 0;
                                    f2 = 0;
                                    i3 = 0;
                                    while (1) {
                                      g2 = b[b[y3 + (i3 << 2) >> 2] >> 2] | 0;
                                      if ((g2 | 0) == (l2 | 0)) {
                                        m = f2;
                                      } else {
                                        m = f2 + ((lc(g2, b[z2 + (i3 << 2) >> 2] | 0, b[l2 >> 2] | 0) | 0) & 1) | 0;
                                      }
                                      i3 = i3 + 1 | 0;
                                      if ((i3 | 0) == (r3 | 0)) {
                                        break;
                                      } else {
                                        f2 = m;
                                      }
                                    }
                                    g2 = (m | 0) > (p3 | 0);
                                    d2 = g2 ? n2 : d2;
                                    f2 = o2 + 1 | 0;
                                    if ((f2 | 0) == (r3 | 0)) {
                                      break c;
                                    }
                                    o2 = f2;
                                    p3 = g2 ? m : p3;
                                    n2 = b[y3 + (f2 << 2) >> 2] | 0;
                                  }
                                }
                              } else {
                                d2 = 0;
                              }
                            } else {
                              d2 = 0;
                            }
                          } while (0);
                        Xc(y3);
                        Xc(z2);
                        if (d2) {
                          g2 = d2 + 4 | 0;
                          f2 = b[g2 >> 2] | 0;
                          if (!f2) {
                            if (b[d2 >> 2] | 0) {
                              K2 = 70;
                              break;
                            }
                          } else {
                            d2 = f2 + 8 | 0;
                          }
                          b[d2 >> 2] = A2;
                          b[g2 >> 2] = A2;
                        } else {
                          K2 = 73;
                        }
                      } else {
                        K2 = 73;
                      }
                      if ((K2 | 0) == 73) {
                        K2 = 0;
                        c3 = b[A2 >> 2] | 0;
                        if (c3 | 0) {
                          do {
                            z2 = c3;
                            c3 = b[c3 + 16 >> 2] | 0;
                            Xc(z2);
                          } while ((c3 | 0) != 0);
                        }
                        Xc(A2);
                        c3 = 2;
                      }
                      B2 = B2 + 1 | 0;
                      if ((B2 | 0) >= (F2 | 0)) {
                        J2 = c3;
                        break b;
                      }
                    }
                    if ((K2 | 0) == 50) {
                      H(22863, 22646, 249, 22882);
                    } else if ((K2 | 0) == 52) {
                      H(22901, 22646, 252, 22882);
                    } else if ((K2 | 0) == 70) {
                      H(22721, 22646, 61, 22744);
                    }
                  } else {
                    J2 = 0;
                  }
                } while (0);
              Xc(I2);
              Xc(G2);
              K2 = J2;
              return K2 | 0;
            }
            return 0;
          }
          function lc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
            if (!(xa(c3, d2) | 0)) {
              a3 = 0;
              return a3 | 0;
            }
            c3 = wa(c3) | 0;
            l2 = +e2[d2 >> 3];
            f2 = +e2[d2 + 8 >> 3];
            f2 = c3 & f2 < 0 ? f2 + 6.283185307179586 : f2;
            a3 = b[a3 >> 2] | 0;
            if (!a3) {
              a3 = 0;
              return a3 | 0;
            }
            if (c3) {
              c3 = 0;
              d2 = a3;
              a:
                while (1) {
                  while (1) {
                    i3 = +e2[d2 >> 3];
                    k = +e2[d2 + 8 >> 3];
                    d2 = d2 + 16 | 0;
                    m = b[d2 >> 2] | 0;
                    m = (m | 0) == 0 ? a3 : m;
                    h = +e2[m >> 3];
                    g2 = +e2[m + 8 >> 3];
                    if (i3 > h) {
                      j = i3;
                      i3 = k;
                    } else {
                      j = h;
                      h = i3;
                      i3 = g2;
                      g2 = k;
                    }
                    if (!(l2 < h | l2 > j)) {
                      break;
                    }
                    d2 = b[d2 >> 2] | 0;
                    if (!d2) {
                      d2 = 22;
                      break a;
                    }
                  }
                  k = g2 < 0 ? g2 + 6.283185307179586 : g2;
                  i3 = i3 < 0 ? i3 + 6.283185307179586 : i3;
                  f2 = i3 == f2 | k == f2 ? f2 + -2220446049250313e-31 : f2;
                  k = k + (l2 - h) / (j - h) * (i3 - k);
                  if ((k < 0 ? k + 6.283185307179586 : k) > f2) {
                    c3 = c3 ^ 1;
                  }
                  d2 = b[d2 >> 2] | 0;
                  if (!d2) {
                    d2 = 22;
                    break;
                  }
                }
              if ((d2 | 0) == 22) {
                return c3 | 0;
              }
            } else {
              c3 = 0;
              d2 = a3;
              b:
                while (1) {
                  while (1) {
                    i3 = +e2[d2 >> 3];
                    k = +e2[d2 + 8 >> 3];
                    d2 = d2 + 16 | 0;
                    m = b[d2 >> 2] | 0;
                    m = (m | 0) == 0 ? a3 : m;
                    h = +e2[m >> 3];
                    g2 = +e2[m + 8 >> 3];
                    if (i3 > h) {
                      j = i3;
                      i3 = k;
                    } else {
                      j = h;
                      h = i3;
                      i3 = g2;
                      g2 = k;
                    }
                    if (!(l2 < h | l2 > j)) {
                      break;
                    }
                    d2 = b[d2 >> 2] | 0;
                    if (!d2) {
                      d2 = 22;
                      break b;
                    }
                  }
                  f2 = i3 == f2 | g2 == f2 ? f2 + -2220446049250313e-31 : f2;
                  if (g2 + (l2 - h) / (j - h) * (i3 - g2) > f2) {
                    c3 = c3 ^ 1;
                  }
                  d2 = b[d2 >> 2] | 0;
                  if (!d2) {
                    d2 = 22;
                    break;
                  }
                }
              if ((d2 | 0) == 22) {
                return c3 | 0;
              }
            }
            return 0;
          }
          function mc(c3, d2, e3, f2, g2) {
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            f2 = f2 | 0;
            g2 = g2 | 0;
            var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0;
            u2 = S;
            S = S + 32 | 0;
            t3 = u2 + 16 | 0;
            s3 = u2;
            h = cd(c3 | 0, d2 | 0, 52) | 0;
            G() | 0;
            h = h & 15;
            p3 = cd(e3 | 0, f2 | 0, 52) | 0;
            G() | 0;
            if ((h | 0) != (p3 & 15 | 0)) {
              t3 = 1;
              S = u2;
              return t3 | 0;
            }
            l2 = cd(c3 | 0, d2 | 0, 45) | 0;
            G() | 0;
            l2 = l2 & 127;
            m = cd(e3 | 0, f2 | 0, 45) | 0;
            G() | 0;
            m = m & 127;
            p3 = (l2 | 0) != (m | 0);
            if (p3) {
              j = ta(l2, m) | 0;
              if ((j | 0) == 7) {
                t3 = 2;
                S = u2;
                return t3 | 0;
              }
              k = ta(m, l2) | 0;
              if ((k | 0) == 7) {
                H(22925, 22949, 151, 22959);
              } else {
                q2 = j;
                i3 = k;
              }
            } else {
              q2 = 0;
              i3 = 0;
            }
            n2 = la(l2) | 0;
            o2 = la(m) | 0;
            b[t3 >> 2] = 0;
            b[t3 + 4 >> 2] = 0;
            b[t3 + 8 >> 2] = 0;
            b[t3 + 12 >> 2] = 0;
            do {
              if (!q2) {
                Tb(e3, f2, t3) | 0;
                if ((n2 | 0) != 0 & (o2 | 0) != 0) {
                  if ((m | 0) != (l2 | 0)) {
                    H(23077, 22949, 243, 22959);
                  }
                  i3 = Lb(c3, d2) | 0;
                  h = Lb(e3, f2) | 0;
                  if (!(a2[22032 + (i3 * 7 | 0) + h >> 0] | 0)) {
                    i3 = b[21200 + (i3 * 28 | 0) + (h << 2) >> 2] | 0;
                    if ((i3 | 0) > 0) {
                      j = t3 + 4 | 0;
                      h = 0;
                      do {
                        Oa(j);
                        h = h + 1 | 0;
                      } while ((h | 0) != (i3 | 0));
                      r3 = 50;
                    } else {
                      r3 = 50;
                    }
                  } else {
                    h = 5;
                  }
                } else {
                  r3 = 50;
                }
              } else {
                m = b[4304 + (l2 * 28 | 0) + (q2 << 2) >> 2] | 0;
                j = (m | 0) > 0;
                if (!o2) {
                  if (j) {
                    l2 = 0;
                    k = e3;
                    j = f2;
                    do {
                      k = Pb(k, j) | 0;
                      j = G() | 0;
                      i3 = Qa(i3) | 0;
                      l2 = l2 + 1 | 0;
                    } while ((l2 | 0) != (m | 0));
                    m = i3;
                    l2 = k;
                    k = j;
                  } else {
                    m = i3;
                    l2 = e3;
                    k = f2;
                  }
                } else if (j) {
                  l2 = 0;
                  k = e3;
                  j = f2;
                  do {
                    k = Ob(k, j) | 0;
                    j = G() | 0;
                    i3 = Qa(i3) | 0;
                    if ((i3 | 0) == 1) {
                      i3 = Qa(1) | 0;
                    }
                    l2 = l2 + 1 | 0;
                  } while ((l2 | 0) != (m | 0));
                  m = i3;
                  l2 = k;
                  k = j;
                } else {
                  m = i3;
                  l2 = e3;
                  k = f2;
                }
                Tb(l2, k, t3) | 0;
                if (!p3) {
                  H(22972, 22949, 181, 22959);
                }
                j = (n2 | 0) != 0;
                i3 = (o2 | 0) != 0;
                if (j & i3) {
                  H(22999, 22949, 182, 22959);
                }
                if (!j) {
                  if (i3) {
                    i3 = Lb(l2, k) | 0;
                    if (a2[22032 + (i3 * 7 | 0) + m >> 0] | 0) {
                      h = 4;
                      break;
                    }
                    l2 = 0;
                    k = b[21200 + (m * 28 | 0) + (i3 << 2) >> 2] | 0;
                    r3 = 26;
                  } else {
                    i3 = 0;
                  }
                } else {
                  i3 = Lb(c3, d2) | 0;
                  if (a2[22032 + (i3 * 7 | 0) + q2 >> 0] | 0) {
                    h = 3;
                    break;
                  }
                  k = b[21200 + (i3 * 28 | 0) + (q2 << 2) >> 2] | 0;
                  l2 = k;
                  r3 = 26;
                }
                if ((r3 | 0) == 26) {
                  if ((k | 0) <= -1) {
                    H(23030, 22949, 212, 22959);
                  }
                  if ((l2 | 0) <= -1) {
                    H(23053, 22949, 213, 22959);
                  }
                  if ((k | 0) > 0) {
                    j = t3 + 4 | 0;
                    i3 = 0;
                    do {
                      Oa(j);
                      i3 = i3 + 1 | 0;
                    } while ((i3 | 0) != (k | 0));
                    i3 = l2;
                  } else {
                    i3 = l2;
                  }
                }
                b[s3 >> 2] = 0;
                b[s3 + 4 >> 2] = 0;
                b[s3 + 8 >> 2] = 0;
                Ma(s3, q2);
                if (h | 0) {
                  while (1) {
                    if (!(Rb(h) | 0)) {
                      La(s3);
                    } else {
                      Ka(s3);
                    }
                    if ((h | 0) > 1) {
                      h = h + -1 | 0;
                    } else {
                      break;
                    }
                  }
                }
                if ((i3 | 0) > 0) {
                  h = 0;
                  do {
                    Oa(s3);
                    h = h + 1 | 0;
                  } while ((h | 0) != (i3 | 0));
                }
                r3 = t3 + 4 | 0;
                Ea(r3, s3, r3);
                Ca(r3);
                r3 = 50;
              }
            } while (0);
            if ((r3 | 0) == 50) {
              h = t3 + 4 | 0;
              b[g2 >> 2] = b[h >> 2];
              b[g2 + 4 >> 2] = b[h + 4 >> 2];
              b[g2 + 8 >> 2] = b[h + 8 >> 2];
              h = 0;
            }
            t3 = h;
            S = u2;
            return t3 | 0;
          }
          function nc(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0;
            p3 = S;
            S = S + 48 | 0;
            h = p3 + 36 | 0;
            i3 = p3 + 24 | 0;
            j = p3 + 12 | 0;
            k = p3;
            g2 = cd(a3 | 0, c3 | 0, 52) | 0;
            G() | 0;
            g2 = g2 & 15;
            n2 = cd(a3 | 0, c3 | 0, 45) | 0;
            G() | 0;
            n2 = n2 & 127;
            l2 = la(n2) | 0;
            dd(g2 | 0, 0, 52) | 0;
            r3 = G() | 0 | 134225919;
            q2 = e3;
            b[q2 >> 2] = -1;
            b[q2 + 4 >> 2] = r3;
            if (!g2) {
              if ((b[d2 >> 2] | 0) > 1) {
                r3 = 1;
                S = p3;
                return r3 | 0;
              }
              if ((b[d2 + 4 >> 2] | 0) > 1) {
                r3 = 1;
                S = p3;
                return r3 | 0;
              }
              if ((b[d2 + 8 >> 2] | 0) > 1) {
                r3 = 1;
                S = p3;
                return r3 | 0;
              }
              f2 = sa(n2, Ha(d2) | 0) | 0;
              if ((f2 | 0) == 127) {
                r3 = 1;
                S = p3;
                return r3 | 0;
              }
              o2 = dd(f2 | 0, 0, 45) | 0;
              q2 = G() | 0;
              n2 = e3;
              q2 = b[n2 + 4 >> 2] & -1040385 | q2;
              r3 = e3;
              b[r3 >> 2] = b[n2 >> 2] | o2;
              b[r3 + 4 >> 2] = q2;
              r3 = 0;
              S = p3;
              return r3 | 0;
            }
            b[h >> 2] = b[d2 >> 2];
            b[h + 4 >> 2] = b[d2 + 4 >> 2];
            b[h + 8 >> 2] = b[d2 + 8 >> 2];
            while (1) {
              b[i3 >> 2] = b[h >> 2];
              b[i3 + 4 >> 2] = b[h + 4 >> 2];
              b[i3 + 8 >> 2] = b[h + 8 >> 2];
              if (!(Rb(g2) | 0)) {
                Ja(h);
                b[j >> 2] = b[h >> 2];
                b[j + 4 >> 2] = b[h + 4 >> 2];
                b[j + 8 >> 2] = b[h + 8 >> 2];
                La(j);
              } else {
                Ia(h);
                b[j >> 2] = b[h >> 2];
                b[j + 4 >> 2] = b[h + 4 >> 2];
                b[j + 8 >> 2] = b[h + 8 >> 2];
                Ka(j);
              }
              Fa(i3, j, k);
              Ca(k);
              q2 = e3;
              s3 = b[q2 >> 2] | 0;
              q2 = b[q2 + 4 >> 2] | 0;
              t3 = (15 - g2 | 0) * 3 | 0;
              d2 = dd(7, 0, t3 | 0) | 0;
              q2 = q2 & ~(G() | 0);
              t3 = dd(Ha(k) | 0, 0, t3 | 0) | 0;
              q2 = G() | 0 | q2;
              r3 = e3;
              b[r3 >> 2] = t3 | s3 & ~d2;
              b[r3 + 4 >> 2] = q2;
              if ((g2 | 0) > 1) {
                g2 = g2 + -1 | 0;
              } else {
                break;
              }
            }
            a:
              do {
                if (((b[h >> 2] | 0) <= 1 ? (b[h + 4 >> 2] | 0) <= 1 : 0) ? (b[h + 8 >> 2] | 0) <= 1 : 0) {
                  g2 = Ha(h) | 0;
                  i3 = sa(n2, g2) | 0;
                  if ((i3 | 0) == 127) {
                    k = 0;
                  } else {
                    k = la(i3) | 0;
                  }
                  b:
                    do {
                      if (!g2) {
                        if ((l2 | 0) != 0 & (k | 0) != 0) {
                          t3 = Lb(a3, c3) | 0;
                          g2 = e3;
                          g2 = 21408 + (t3 * 28 | 0) + ((Lb(b[g2 >> 2] | 0, b[g2 + 4 >> 2] | 0) | 0) << 2) | 0;
                          g2 = b[g2 >> 2] | 0;
                          if ((g2 | 0) <= -1) {
                            H(23201, 22949, 433, 23134);
                          }
                          if (!g2) {
                            f2 = i3;
                            g2 = 55;
                          } else {
                            h = e3;
                            f2 = 0;
                            d2 = b[h >> 2] | 0;
                            h = b[h + 4 >> 2] | 0;
                            do {
                              d2 = Nb(d2, h) | 0;
                              h = G() | 0;
                              t3 = e3;
                              b[t3 >> 2] = d2;
                              b[t3 + 4 >> 2] = h;
                              f2 = f2 + 1 | 0;
                            } while ((f2 | 0) < (g2 | 0));
                            f2 = i3;
                            g2 = 54;
                          }
                        } else {
                          f2 = i3;
                          g2 = 54;
                        }
                      } else {
                        if (l2) {
                          h = 21408 + ((Lb(a3, c3) | 0) * 28 | 0) + (g2 << 2) | 0;
                          h = b[h >> 2] | 0;
                          if ((h | 0) > 0) {
                            d2 = 0;
                            do {
                              g2 = Pa(g2) | 0;
                              d2 = d2 + 1 | 0;
                            } while ((d2 | 0) != (h | 0));
                          }
                          if ((g2 | 0) == 1) {
                            f2 = 3;
                            break a;
                          }
                          d2 = sa(n2, g2) | 0;
                          if ((d2 | 0) == 127) {
                            H(23104, 22949, 376, 23134);
                          }
                          if (!(la(d2) | 0)) {
                            o2 = h;
                            m = g2;
                            f2 = d2;
                          } else {
                            H(23147, 22949, 377, 23134);
                          }
                        } else {
                          o2 = 0;
                          m = g2;
                          f2 = i3;
                        }
                        j = b[4304 + (n2 * 28 | 0) + (m << 2) >> 2] | 0;
                        if ((j | 0) <= -1) {
                          H(23178, 22949, 384, 23134);
                        }
                        if (!k) {
                          if ((o2 | 0) <= -1) {
                            H(23030, 22949, 417, 23134);
                          }
                          if (o2 | 0) {
                            h = e3;
                            g2 = 0;
                            d2 = b[h >> 2] | 0;
                            h = b[h + 4 >> 2] | 0;
                            do {
                              d2 = Nb(d2, h) | 0;
                              h = G() | 0;
                              t3 = e3;
                              b[t3 >> 2] = d2;
                              b[t3 + 4 >> 2] = h;
                              g2 = g2 + 1 | 0;
                            } while ((g2 | 0) < (o2 | 0));
                          }
                          if ((j | 0) <= 0) {
                            g2 = 54;
                            break;
                          }
                          h = e3;
                          g2 = 0;
                          d2 = b[h >> 2] | 0;
                          h = b[h + 4 >> 2] | 0;
                          while (1) {
                            d2 = Nb(d2, h) | 0;
                            h = G() | 0;
                            t3 = e3;
                            b[t3 >> 2] = d2;
                            b[t3 + 4 >> 2] = h;
                            g2 = g2 + 1 | 0;
                            if ((g2 | 0) == (j | 0)) {
                              g2 = 54;
                              break b;
                            }
                          }
                        }
                        i3 = ta(f2, n2) | 0;
                        if ((i3 | 0) == 7) {
                          H(22925, 22949, 393, 23134);
                        }
                        g2 = e3;
                        d2 = b[g2 >> 2] | 0;
                        g2 = b[g2 + 4 >> 2] | 0;
                        if ((j | 0) > 0) {
                          h = 0;
                          do {
                            d2 = Nb(d2, g2) | 0;
                            g2 = G() | 0;
                            t3 = e3;
                            b[t3 >> 2] = d2;
                            b[t3 + 4 >> 2] = g2;
                            h = h + 1 | 0;
                          } while ((h | 0) != (j | 0));
                        }
                        d2 = Lb(d2, g2) | 0;
                        t3 = ma(f2) | 0;
                        d2 = b[(t3 ? 21824 : 21616) + (i3 * 28 | 0) + (d2 << 2) >> 2] | 0;
                        if ((d2 | 0) <= -1) {
                          H(23030, 22949, 412, 23134);
                        }
                        if (!d2) {
                          g2 = 54;
                        } else {
                          i3 = e3;
                          g2 = 0;
                          h = b[i3 >> 2] | 0;
                          i3 = b[i3 + 4 >> 2] | 0;
                          do {
                            h = Mb(h, i3) | 0;
                            i3 = G() | 0;
                            t3 = e3;
                            b[t3 >> 2] = h;
                            b[t3 + 4 >> 2] = i3;
                            g2 = g2 + 1 | 0;
                          } while ((g2 | 0) < (d2 | 0));
                          g2 = 54;
                        }
                      }
                    } while (0);
                  if ((g2 | 0) == 54) {
                    if (k) {
                      g2 = 55;
                    }
                  }
                  if ((g2 | 0) == 55) {
                    t3 = e3;
                    if ((Lb(b[t3 >> 2] | 0, b[t3 + 4 >> 2] | 0) | 0) == 1) {
                      f2 = 4;
                      break;
                    }
                  }
                  t3 = e3;
                  r3 = b[t3 >> 2] | 0;
                  t3 = b[t3 + 4 >> 2] & -1040385;
                  s3 = dd(f2 | 0, 0, 45) | 0;
                  t3 = t3 | (G() | 0);
                  f2 = e3;
                  b[f2 >> 2] = r3 | s3;
                  b[f2 + 4 >> 2] = t3;
                  f2 = 0;
                } else {
                  f2 = 2;
                }
              } while (0);
            t3 = f2;
            S = p3;
            return t3 | 0;
          }
          function oc(a3, b2, c3, d2, e3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0;
            g2 = S;
            S = S + 16 | 0;
            f2 = g2;
            a3 = mc(a3, b2, c3, d2, f2) | 0;
            if (!a3) {
              Ua(f2, e3);
              a3 = 0;
            }
            S = g2;
            return a3 | 0;
          }
          function pc(a3, b2, c3, d2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0;
            e3 = S;
            S = S + 16 | 0;
            f2 = e3;
            Va(c3, f2);
            d2 = nc(a3, b2, f2, d2) | 0;
            S = e3;
            return d2 | 0;
          }
          function qc(a3, b2, c3, d2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0;
            g2 = S;
            S = S + 32 | 0;
            e3 = g2 + 12 | 0;
            f2 = g2;
            if ((mc(a3, b2, a3, b2, e3) | 0) == 0 ? (mc(a3, b2, c3, d2, f2) | 0) == 0 : 0) {
              a3 = Ta(e3, f2) | 0;
            } else {
              a3 = -1;
            }
            S = g2;
            return a3 | 0;
          }
          function rc(a3, b2, c3, d2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0;
            g2 = S;
            S = S + 32 | 0;
            e3 = g2 + 12 | 0;
            f2 = g2;
            if ((mc(a3, b2, a3, b2, e3) | 0) == 0 ? (mc(a3, b2, c3, d2, f2) | 0) == 0 : 0) {
              a3 = Ta(e3, f2) | 0;
            } else {
              a3 = -1;
            }
            S = g2;
            return (a3 >>> 31 ^ 1) + a3 | 0;
          }
          function sc(a3, c3, d2, e3, f2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            f2 = f2 | 0;
            var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0;
            x3 = S;
            S = S + 48 | 0;
            g2 = x3 + 24 | 0;
            h = x3 + 12 | 0;
            w2 = x3;
            if ((mc(a3, c3, a3, c3, g2) | 0) == 0 ? (mc(a3, c3, d2, e3, h) | 0) == 0 : 0) {
              v2 = Ta(g2, h) | 0;
              if ((v2 | 0) < 0) {
                w2 = v2;
                S = x3;
                return w2 | 0;
              }
              b[g2 >> 2] = 0;
              b[g2 + 4 >> 2] = 0;
              b[g2 + 8 >> 2] = 0;
              b[h >> 2] = 0;
              b[h + 4 >> 2] = 0;
              b[h + 8 >> 2] = 0;
              mc(a3, c3, a3, c3, g2) | 0;
              mc(a3, c3, d2, e3, h) | 0;
              Wa(g2);
              Wa(h);
              if (!v2) {
                e3 = g2 + 4 | 0;
                n2 = g2 + 8 | 0;
                s3 = e3;
                t3 = n2;
                u2 = g2;
                d2 = b[g2 >> 2] | 0;
                e3 = b[e3 >> 2] | 0;
                g2 = b[n2 >> 2] | 0;
                p3 = 0;
                r3 = 0;
                o2 = 0;
              } else {
                l2 = b[g2 >> 2] | 0;
                o2 = +(v2 | 0);
                s3 = g2 + 4 | 0;
                m = b[s3 >> 2] | 0;
                t3 = g2 + 8 | 0;
                n2 = b[t3 >> 2] | 0;
                u2 = g2;
                d2 = l2;
                e3 = m;
                g2 = n2;
                p3 = +((b[h >> 2] | 0) - l2 | 0) / o2;
                r3 = +((b[h + 4 >> 2] | 0) - m | 0) / o2;
                o2 = +((b[h + 8 >> 2] | 0) - n2 | 0) / o2;
              }
              b[w2 >> 2] = d2;
              n2 = w2 + 4 | 0;
              b[n2 >> 2] = e3;
              m = w2 + 8 | 0;
              b[m >> 2] = g2;
              l2 = 0;
              while (1) {
                j = +(l2 | 0);
                y3 = p3 * j + +(d2 | 0);
                i3 = r3 * j + +(b[s3 >> 2] | 0);
                j = o2 * j + +(b[t3 >> 2] | 0);
                e3 = ~~+fd(+y3);
                h = ~~+fd(+i3);
                d2 = ~~+fd(+j);
                y3 = +q(+(+(e3 | 0) - y3));
                i3 = +q(+(+(h | 0) - i3));
                j = +q(+(+(d2 | 0) - j));
                do {
                  if (!(y3 > i3 & y3 > j)) {
                    k = 0 - e3 | 0;
                    if (i3 > j) {
                      g2 = k - d2 | 0;
                      break;
                    } else {
                      g2 = h;
                      d2 = k - h | 0;
                      break;
                    }
                  } else {
                    e3 = 0 - (h + d2) | 0;
                    g2 = h;
                  }
                } while (0);
                b[w2 >> 2] = e3;
                b[n2 >> 2] = g2;
                b[m >> 2] = d2;
                Xa(w2);
                nc(a3, c3, w2, f2 + (l2 << 3) | 0) | 0;
                if ((l2 | 0) == (v2 | 0)) {
                  break;
                }
                l2 = l2 + 1 | 0;
                d2 = b[u2 >> 2] | 0;
              }
              w2 = 0;
              S = x3;
              return w2 | 0;
            }
            w2 = -1;
            S = x3;
            return w2 | 0;
          }
          function tc(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0;
            if (!b2) {
              c3 = 1;
              return c3 | 0;
            }
            c3 = a3;
            a3 = 1;
            do {
              a3 = B((b2 & 1 | 0) == 0 ? 1 : c3, a3) | 0;
              b2 = b2 >> 1;
              c3 = B(c3, c3) | 0;
            } while ((b2 | 0) != 0);
            return a3 | 0;
          }
          function uc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0;
            if (!(xa(c3, d2) | 0)) {
              n2 = 0;
              return n2 | 0;
            }
            c3 = wa(c3) | 0;
            o2 = +e2[d2 >> 3];
            f2 = +e2[d2 + 8 >> 3];
            f2 = c3 & f2 < 0 ? f2 + 6.283185307179586 : f2;
            n2 = b[a3 >> 2] | 0;
            if ((n2 | 0) <= 0) {
              n2 = 0;
              return n2 | 0;
            }
            m = b[a3 + 4 >> 2] | 0;
            if (c3) {
              c3 = 0;
              d2 = -1;
              a3 = 0;
              a:
                while (1) {
                  l2 = a3;
                  while (1) {
                    i3 = +e2[m + (l2 << 4) >> 3];
                    k = +e2[m + (l2 << 4) + 8 >> 3];
                    a3 = (d2 + 2 | 0) % (n2 | 0) | 0;
                    h = +e2[m + (a3 << 4) >> 3];
                    g2 = +e2[m + (a3 << 4) + 8 >> 3];
                    if (i3 > h) {
                      j = i3;
                      i3 = k;
                    } else {
                      j = h;
                      h = i3;
                      i3 = g2;
                      g2 = k;
                    }
                    if (!(o2 < h | o2 > j)) {
                      break;
                    }
                    d2 = l2 + 1 | 0;
                    if ((d2 | 0) < (n2 | 0)) {
                      a3 = l2;
                      l2 = d2;
                      d2 = a3;
                    } else {
                      d2 = 22;
                      break a;
                    }
                  }
                  k = g2 < 0 ? g2 + 6.283185307179586 : g2;
                  i3 = i3 < 0 ? i3 + 6.283185307179586 : i3;
                  f2 = i3 == f2 | k == f2 ? f2 + -2220446049250313e-31 : f2;
                  k = k + (o2 - h) / (j - h) * (i3 - k);
                  if ((k < 0 ? k + 6.283185307179586 : k) > f2) {
                    c3 = c3 ^ 1;
                  }
                  a3 = l2 + 1 | 0;
                  if ((a3 | 0) >= (n2 | 0)) {
                    d2 = 22;
                    break;
                  } else {
                    d2 = l2;
                  }
                }
              if ((d2 | 0) == 22) {
                return c3 | 0;
              }
            } else {
              c3 = 0;
              d2 = -1;
              a3 = 0;
              b:
                while (1) {
                  l2 = a3;
                  while (1) {
                    i3 = +e2[m + (l2 << 4) >> 3];
                    k = +e2[m + (l2 << 4) + 8 >> 3];
                    a3 = (d2 + 2 | 0) % (n2 | 0) | 0;
                    h = +e2[m + (a3 << 4) >> 3];
                    g2 = +e2[m + (a3 << 4) + 8 >> 3];
                    if (i3 > h) {
                      j = i3;
                      i3 = k;
                    } else {
                      j = h;
                      h = i3;
                      i3 = g2;
                      g2 = k;
                    }
                    if (!(o2 < h | o2 > j)) {
                      break;
                    }
                    d2 = l2 + 1 | 0;
                    if ((d2 | 0) < (n2 | 0)) {
                      a3 = l2;
                      l2 = d2;
                      d2 = a3;
                    } else {
                      d2 = 22;
                      break b;
                    }
                  }
                  f2 = i3 == f2 | g2 == f2 ? f2 + -2220446049250313e-31 : f2;
                  if (g2 + (o2 - h) / (j - h) * (i3 - g2) > f2) {
                    c3 = c3 ^ 1;
                  }
                  a3 = l2 + 1 | 0;
                  if ((a3 | 0) >= (n2 | 0)) {
                    d2 = 22;
                    break;
                  } else {
                    d2 = l2;
                  }
                }
              if ((d2 | 0) == 22) {
                return c3 | 0;
              }
            }
            return 0;
          }
          function vc(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0;
            r3 = b[a3 >> 2] | 0;
            if (!r3) {
              b[c3 >> 2] = 0;
              b[c3 + 4 >> 2] = 0;
              b[c3 + 8 >> 2] = 0;
              b[c3 + 12 >> 2] = 0;
              b[c3 + 16 >> 2] = 0;
              b[c3 + 20 >> 2] = 0;
              b[c3 + 24 >> 2] = 0;
              b[c3 + 28 >> 2] = 0;
              return;
            }
            s3 = c3 + 8 | 0;
            e2[s3 >> 3] = 17976931348623157e292;
            t3 = c3 + 24 | 0;
            e2[t3 >> 3] = 17976931348623157e292;
            e2[c3 >> 3] = -17976931348623157e292;
            u2 = c3 + 16 | 0;
            e2[u2 >> 3] = -17976931348623157e292;
            if ((r3 | 0) <= 0) {
              return;
            }
            o2 = b[a3 + 4 >> 2] | 0;
            l2 = 17976931348623157e292;
            m = -17976931348623157e292;
            n2 = 0;
            a3 = -1;
            h = 17976931348623157e292;
            i3 = 17976931348623157e292;
            k = -17976931348623157e292;
            f2 = -17976931348623157e292;
            p3 = 0;
            while (1) {
              d2 = +e2[o2 + (p3 << 4) >> 3];
              j = +e2[o2 + (p3 << 4) + 8 >> 3];
              a3 = a3 + 2 | 0;
              g2 = +e2[o2 + (((a3 | 0) == (r3 | 0) ? 0 : a3) << 4) + 8 >> 3];
              if (d2 < h) {
                e2[s3 >> 3] = d2;
                h = d2;
              }
              if (j < i3) {
                e2[t3 >> 3] = j;
                i3 = j;
              }
              if (d2 > k) {
                e2[c3 >> 3] = d2;
              } else {
                d2 = k;
              }
              if (j > f2) {
                e2[u2 >> 3] = j;
                f2 = j;
              }
              l2 = j > 0 & j < l2 ? j : l2;
              m = j < 0 & j > m ? j : m;
              n2 = n2 | +q(+(j - g2)) > 3.141592653589793;
              a3 = p3 + 1 | 0;
              if ((a3 | 0) == (r3 | 0)) {
                break;
              } else {
                v2 = p3;
                k = d2;
                p3 = a3;
                a3 = v2;
              }
            }
            if (!n2) {
              return;
            }
            e2[u2 >> 3] = m;
            e2[t3 >> 3] = l2;
            return;
          }
          function wc(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0;
            r3 = b[a3 >> 2] | 0;
            if (r3) {
              s3 = c3 + 8 | 0;
              e2[s3 >> 3] = 17976931348623157e292;
              t3 = c3 + 24 | 0;
              e2[t3 >> 3] = 17976931348623157e292;
              e2[c3 >> 3] = -17976931348623157e292;
              u2 = c3 + 16 | 0;
              e2[u2 >> 3] = -17976931348623157e292;
              if ((r3 | 0) > 0) {
                g2 = b[a3 + 4 >> 2] | 0;
                o2 = 17976931348623157e292;
                p3 = -17976931348623157e292;
                f2 = 0;
                d2 = -1;
                k = 17976931348623157e292;
                l2 = 17976931348623157e292;
                n2 = -17976931348623157e292;
                i3 = -17976931348623157e292;
                v2 = 0;
                while (1) {
                  h = +e2[g2 + (v2 << 4) >> 3];
                  m = +e2[g2 + (v2 << 4) + 8 >> 3];
                  z2 = d2 + 2 | 0;
                  j = +e2[g2 + (((z2 | 0) == (r3 | 0) ? 0 : z2) << 4) + 8 >> 3];
                  if (h < k) {
                    e2[s3 >> 3] = h;
                    k = h;
                  }
                  if (m < l2) {
                    e2[t3 >> 3] = m;
                    l2 = m;
                  }
                  if (h > n2) {
                    e2[c3 >> 3] = h;
                  } else {
                    h = n2;
                  }
                  if (m > i3) {
                    e2[u2 >> 3] = m;
                    i3 = m;
                  }
                  o2 = m > 0 & m < o2 ? m : o2;
                  p3 = m < 0 & m > p3 ? m : p3;
                  f2 = f2 | +q(+(m - j)) > 3.141592653589793;
                  d2 = v2 + 1 | 0;
                  if ((d2 | 0) == (r3 | 0)) {
                    break;
                  } else {
                    z2 = v2;
                    n2 = h;
                    v2 = d2;
                    d2 = z2;
                  }
                }
                if (f2) {
                  e2[u2 >> 3] = p3;
                  e2[t3 >> 3] = o2;
                }
              }
            } else {
              b[c3 >> 2] = 0;
              b[c3 + 4 >> 2] = 0;
              b[c3 + 8 >> 2] = 0;
              b[c3 + 12 >> 2] = 0;
              b[c3 + 16 >> 2] = 0;
              b[c3 + 20 >> 2] = 0;
              b[c3 + 24 >> 2] = 0;
              b[c3 + 28 >> 2] = 0;
            }
            z2 = a3 + 8 | 0;
            d2 = b[z2 >> 2] | 0;
            if ((d2 | 0) <= 0) {
              return;
            }
            y3 = a3 + 12 | 0;
            x3 = 0;
            do {
              g2 = b[y3 >> 2] | 0;
              f2 = x3;
              x3 = x3 + 1 | 0;
              t3 = c3 + (x3 << 5) | 0;
              u2 = b[g2 + (f2 << 3) >> 2] | 0;
              if (u2) {
                v2 = c3 + (x3 << 5) + 8 | 0;
                e2[v2 >> 3] = 17976931348623157e292;
                a3 = c3 + (x3 << 5) + 24 | 0;
                e2[a3 >> 3] = 17976931348623157e292;
                e2[t3 >> 3] = -17976931348623157e292;
                w2 = c3 + (x3 << 5) + 16 | 0;
                e2[w2 >> 3] = -17976931348623157e292;
                if ((u2 | 0) > 0) {
                  r3 = b[g2 + (f2 << 3) + 4 >> 2] | 0;
                  o2 = 17976931348623157e292;
                  p3 = -17976931348623157e292;
                  g2 = 0;
                  f2 = -1;
                  s3 = 0;
                  k = 17976931348623157e292;
                  l2 = 17976931348623157e292;
                  m = -17976931348623157e292;
                  i3 = -17976931348623157e292;
                  while (1) {
                    h = +e2[r3 + (s3 << 4) >> 3];
                    n2 = +e2[r3 + (s3 << 4) + 8 >> 3];
                    f2 = f2 + 2 | 0;
                    j = +e2[r3 + (((f2 | 0) == (u2 | 0) ? 0 : f2) << 4) + 8 >> 3];
                    if (h < k) {
                      e2[v2 >> 3] = h;
                      k = h;
                    }
                    if (n2 < l2) {
                      e2[a3 >> 3] = n2;
                      l2 = n2;
                    }
                    if (h > m) {
                      e2[t3 >> 3] = h;
                    } else {
                      h = m;
                    }
                    if (n2 > i3) {
                      e2[w2 >> 3] = n2;
                      i3 = n2;
                    }
                    o2 = n2 > 0 & n2 < o2 ? n2 : o2;
                    p3 = n2 < 0 & n2 > p3 ? n2 : p3;
                    g2 = g2 | +q(+(n2 - j)) > 3.141592653589793;
                    f2 = s3 + 1 | 0;
                    if ((f2 | 0) == (u2 | 0)) {
                      break;
                    } else {
                      A2 = s3;
                      s3 = f2;
                      m = h;
                      f2 = A2;
                    }
                  }
                  if (g2) {
                    e2[w2 >> 3] = p3;
                    e2[a3 >> 3] = o2;
                  }
                }
              } else {
                b[t3 >> 2] = 0;
                b[t3 + 4 >> 2] = 0;
                b[t3 + 8 >> 2] = 0;
                b[t3 + 12 >> 2] = 0;
                b[t3 + 16 >> 2] = 0;
                b[t3 + 20 >> 2] = 0;
                b[t3 + 24 >> 2] = 0;
                b[t3 + 28 >> 2] = 0;
                d2 = b[z2 >> 2] | 0;
              }
            } while ((x3 | 0) < (d2 | 0));
            return;
          }
          function xc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0, g2 = 0;
            if (!(uc(a3, c3, d2) | 0)) {
              f2 = 0;
              return f2 | 0;
            }
            f2 = a3 + 8 | 0;
            if ((b[f2 >> 2] | 0) <= 0) {
              f2 = 1;
              return f2 | 0;
            }
            e3 = a3 + 12 | 0;
            a3 = 0;
            while (1) {
              g2 = a3;
              a3 = a3 + 1 | 0;
              if (uc((b[e3 >> 2] | 0) + (g2 << 3) | 0, c3 + (a3 << 5) | 0, d2) | 0) {
                a3 = 0;
                e3 = 6;
                break;
              }
              if ((a3 | 0) >= (b[f2 >> 2] | 0)) {
                a3 = 1;
                e3 = 6;
                break;
              }
            }
            if ((e3 | 0) == 6) {
              return a3 | 0;
            }
            return 0;
          }
          function yc() {
            return 8;
          }
          function zc() {
            return 16;
          }
          function Ac() {
            return 168;
          }
          function Bc() {
            return 8;
          }
          function Cc() {
            return 16;
          }
          function Dc() {
            return 12;
          }
          function Ec() {
            return 8;
          }
          function Fc(a3) {
            a3 = a3 | 0;
            var b2 = 0, c3 = 0;
            c3 = +e2[a3 >> 3];
            b2 = +e2[a3 + 8 >> 3];
            return + +r2(+(c3 * c3 + b2 * b2));
          }
          function Gc(a3, b2, c3, d2, f2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            f2 = f2 | 0;
            var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0;
            k = +e2[a3 >> 3];
            j = +e2[b2 >> 3] - k;
            i3 = +e2[a3 + 8 >> 3];
            h = +e2[b2 + 8 >> 3] - i3;
            m = +e2[c3 >> 3];
            g2 = +e2[d2 >> 3] - m;
            n2 = +e2[c3 + 8 >> 3];
            l2 = +e2[d2 + 8 >> 3] - n2;
            g2 = (g2 * (i3 - n2) - (k - m) * l2) / (j * l2 - h * g2);
            e2[f2 >> 3] = k + j * g2;
            e2[f2 + 8 >> 3] = i3 + h * g2;
            return;
          }
          function Hc(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            if (!(+e2[a3 >> 3] == +e2[b2 >> 3])) {
              b2 = 0;
              return b2 | 0;
            }
            b2 = +e2[a3 + 8 >> 3] == +e2[b2 + 8 >> 3];
            return b2 | 0;
          }
          function Ic(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, f2 = 0;
            f2 = +e2[a3 >> 3] - +e2[b2 >> 3];
            d2 = +e2[a3 + 8 >> 3] - +e2[b2 + 8 >> 3];
            c3 = +e2[a3 + 16 >> 3] - +e2[b2 + 16 >> 3];
            return +(f2 * f2 + d2 * d2 + c3 * c3);
          }
          function Jc(a3, b2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            var c3 = 0, d2 = 0, f2 = 0;
            c3 = +e2[a3 >> 3];
            d2 = +t2(+c3);
            c3 = +u(+c3);
            e2[b2 + 16 >> 3] = c3;
            c3 = +e2[a3 + 8 >> 3];
            f2 = d2 * +t2(+c3);
            e2[b2 >> 3] = f2;
            c3 = d2 * +u(+c3);
            e2[b2 + 8 >> 3] = c3;
            return;
          }
          function Kc(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
            k = S;
            S = S + 32 | 0;
            f2 = k + 16 | 0;
            g2 = k;
            Ub(a3, c3, f2);
            h = Ab(a3, c3) | 0;
            j = Lb(a3, c3) | 0;
            pa(h, g2);
            c3 = qa(h, b[f2 >> 2] | 0) | 0;
            if (!(la(h) | 0)) {
              j = c3;
              S = k;
              return j | 0;
            }
            do {
              switch (h | 0) {
                case 4: {
                  a3 = 0;
                  d2 = 14;
                  break;
                }
                case 14: {
                  a3 = 1;
                  d2 = 14;
                  break;
                }
                case 24: {
                  a3 = 2;
                  d2 = 14;
                  break;
                }
                case 38: {
                  a3 = 3;
                  d2 = 14;
                  break;
                }
                case 49: {
                  a3 = 4;
                  d2 = 14;
                  break;
                }
                case 58: {
                  a3 = 5;
                  d2 = 14;
                  break;
                }
                case 63: {
                  a3 = 6;
                  d2 = 14;
                  break;
                }
                case 72: {
                  a3 = 7;
                  d2 = 14;
                  break;
                }
                case 83: {
                  a3 = 8;
                  d2 = 14;
                  break;
                }
                case 97: {
                  a3 = 9;
                  d2 = 14;
                  break;
                }
                case 107: {
                  a3 = 10;
                  d2 = 14;
                  break;
                }
                case 117: {
                  a3 = 11;
                  d2 = 14;
                  break;
                }
                default: {
                  i3 = 0;
                  e3 = 0;
                }
              }
            } while (0);
            if ((d2 | 0) == 14) {
              i3 = b[22096 + (a3 * 24 | 0) + 8 >> 2] | 0;
              e3 = b[22096 + (a3 * 24 | 0) + 16 >> 2] | 0;
            }
            a3 = b[f2 >> 2] | 0;
            if ((a3 | 0) != (b[g2 >> 2] | 0)) {
              h = ma(h) | 0;
              a3 = b[f2 >> 2] | 0;
              if (h | (a3 | 0) == (e3 | 0)) {
                c3 = (c3 + 1 | 0) % 6 | 0;
              }
            }
            if ((j | 0) == 3 & (a3 | 0) == (e3 | 0)) {
              j = (c3 + 5 | 0) % 6 | 0;
              S = k;
              return j | 0;
            }
            if (!((j | 0) == 5 & (a3 | 0) == (i3 | 0))) {
              j = c3;
              S = k;
              return j | 0;
            }
            j = (c3 + 1 | 0) % 6 | 0;
            S = k;
            return j | 0;
          }
          function Lc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0, f2 = 0;
            e3 = Fb(a3, c3) | 0;
            if ((d2 + -1 | 0) >>> 0 > 5) {
              d2 = -1;
              return d2 | 0;
            }
            f2 = (e3 | 0) != 0;
            if ((d2 | 0) == 1 & f2) {
              d2 = -1;
              return d2 | 0;
            }
            e3 = Kc(a3, c3) | 0;
            if (f2) {
              d2 = (5 - e3 + (b[22384 + (d2 << 2) >> 2] | 0) | 0) % 5 | 0;
              return d2 | 0;
            } else {
              d2 = (6 - e3 + (b[22416 + (d2 << 2) >> 2] | 0) | 0) % 6 | 0;
              return d2 | 0;
            }
            return 0;
          }
          function Mc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var e3 = 0;
            if ((c3 | 0) > 0) {
              e3 = Yc(c3, 4) | 0;
              b[a3 >> 2] = e3;
              if (!e3) {
                H(23230, 23253, 40, 23267);
              }
            } else {
              b[a3 >> 2] = 0;
            }
            b[a3 + 4 >> 2] = c3;
            b[a3 + 8 >> 2] = 0;
            b[a3 + 12 >> 2] = d2;
            return;
          }
          function Nc(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
            g2 = a3 + 4 | 0;
            h = a3 + 12 | 0;
            i3 = a3 + 8 | 0;
            a:
              while (1) {
                d2 = b[g2 >> 2] | 0;
                c3 = 0;
                while (1) {
                  if ((c3 | 0) >= (d2 | 0)) {
                    break a;
                  }
                  f2 = b[a3 >> 2] | 0;
                  j = b[f2 + (c3 << 2) >> 2] | 0;
                  if (!j) {
                    c3 = c3 + 1 | 0;
                  } else {
                    break;
                  }
                }
                c3 = f2 + (~~(+q(+(+s2(10, + +(15 - (b[h >> 2] | 0) | 0)) * (+e2[j >> 3] + +e2[j + 8 >> 3]))) % +(d2 | 0)) >>> 0 << 2) | 0;
                d2 = b[c3 >> 2] | 0;
                b:
                  do {
                    if (d2 | 0) {
                      f2 = j + 32 | 0;
                      if ((d2 | 0) == (j | 0)) {
                        b[c3 >> 2] = b[f2 >> 2];
                      } else {
                        d2 = d2 + 32 | 0;
                        c3 = b[d2 >> 2] | 0;
                        if (!c3) {
                          break;
                        }
                        while (1) {
                          if ((c3 | 0) == (j | 0)) {
                            break;
                          }
                          d2 = c3 + 32 | 0;
                          c3 = b[d2 >> 2] | 0;
                          if (!c3) {
                            break b;
                          }
                        }
                        b[d2 >> 2] = b[f2 >> 2];
                      }
                      Xc(j);
                      b[i3 >> 2] = (b[i3 >> 2] | 0) + -1;
                    }
                  } while (0);
              }
            Xc(b[a3 >> 2] | 0);
            return;
          }
          function Oc(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0;
            e3 = b[a3 + 4 >> 2] | 0;
            d2 = 0;
            while (1) {
              if ((d2 | 0) >= (e3 | 0)) {
                c3 = 0;
                d2 = 4;
                break;
              }
              c3 = b[(b[a3 >> 2] | 0) + (d2 << 2) >> 2] | 0;
              if (!c3) {
                d2 = d2 + 1 | 0;
              } else {
                d2 = 4;
                break;
              }
            }
            if ((d2 | 0) == 4) {
              return c3 | 0;
            }
            return 0;
          }
          function Pc(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0, f2 = 0, g2 = 0, h = 0;
            d2 = ~~(+q(+(+s2(10, + +(15 - (b[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b[a3 + 4 >> 2] | 0)) >>> 0;
            d2 = (b[a3 >> 2] | 0) + (d2 << 2) | 0;
            f2 = b[d2 >> 2] | 0;
            if (!f2) {
              h = 1;
              return h | 0;
            }
            h = c3 + 32 | 0;
            do {
              if ((f2 | 0) != (c3 | 0)) {
                d2 = b[f2 + 32 >> 2] | 0;
                if (!d2) {
                  h = 1;
                  return h | 0;
                }
                g2 = d2;
                while (1) {
                  if ((g2 | 0) == (c3 | 0)) {
                    g2 = 8;
                    break;
                  }
                  d2 = b[g2 + 32 >> 2] | 0;
                  if (!d2) {
                    d2 = 1;
                    g2 = 10;
                    break;
                  } else {
                    f2 = g2;
                    g2 = d2;
                  }
                }
                if ((g2 | 0) == 8) {
                  b[f2 + 32 >> 2] = b[h >> 2];
                  break;
                } else if ((g2 | 0) == 10) {
                  return d2 | 0;
                }
              } else {
                b[d2 >> 2] = b[h >> 2];
              }
            } while (0);
            Xc(c3);
            h = a3 + 8 | 0;
            b[h >> 2] = (b[h >> 2] | 0) + -1;
            h = 0;
            return h | 0;
          }
          function Qc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0;
            h = Wc(40) | 0;
            if (!h) {
              H(23283, 23253, 98, 23296);
            }
            b[h >> 2] = b[c3 >> 2];
            b[h + 4 >> 2] = b[c3 + 4 >> 2];
            b[h + 8 >> 2] = b[c3 + 8 >> 2];
            b[h + 12 >> 2] = b[c3 + 12 >> 2];
            g2 = h + 16 | 0;
            b[g2 >> 2] = b[d2 >> 2];
            b[g2 + 4 >> 2] = b[d2 + 4 >> 2];
            b[g2 + 8 >> 2] = b[d2 + 8 >> 2];
            b[g2 + 12 >> 2] = b[d2 + 12 >> 2];
            b[h + 32 >> 2] = 0;
            g2 = ~~(+q(+(+s2(10, + +(15 - (b[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b[a3 + 4 >> 2] | 0)) >>> 0;
            g2 = (b[a3 >> 2] | 0) + (g2 << 2) | 0;
            f2 = b[g2 >> 2] | 0;
            do {
              if (!f2) {
                b[g2 >> 2] = h;
              } else {
                while (1) {
                  if (hb(f2, c3) | 0 ? hb(f2 + 16 | 0, d2) | 0 : 0) {
                    break;
                  }
                  g2 = b[f2 + 32 >> 2] | 0;
                  f2 = (g2 | 0) == 0 ? f2 : g2;
                  if (!(b[f2 + 32 >> 2] | 0)) {
                    i3 = 10;
                    break;
                  }
                }
                if ((i3 | 0) == 10) {
                  b[f2 + 32 >> 2] = h;
                  break;
                }
                Xc(h);
                i3 = f2;
                return i3 | 0;
              }
            } while (0);
            i3 = a3 + 8 | 0;
            b[i3 >> 2] = (b[i3 >> 2] | 0) + 1;
            i3 = h;
            return i3 | 0;
          }
          function Rc(a3, c3, d2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            var f2 = 0, g2 = 0;
            g2 = ~~(+q(+(+s2(10, + +(15 - (b[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b[a3 + 4 >> 2] | 0)) >>> 0;
            g2 = b[(b[a3 >> 2] | 0) + (g2 << 2) >> 2] | 0;
            if (!g2) {
              d2 = 0;
              return d2 | 0;
            }
            if (!d2) {
              a3 = g2;
              while (1) {
                if (hb(a3, c3) | 0) {
                  f2 = 10;
                  break;
                }
                a3 = b[a3 + 32 >> 2] | 0;
                if (!a3) {
                  a3 = 0;
                  f2 = 10;
                  break;
                }
              }
              if ((f2 | 0) == 10) {
                return a3 | 0;
              }
            }
            a3 = g2;
            while (1) {
              if (hb(a3, c3) | 0 ? hb(a3 + 16 | 0, d2) | 0 : 0) {
                f2 = 10;
                break;
              }
              a3 = b[a3 + 32 >> 2] | 0;
              if (!a3) {
                a3 = 0;
                f2 = 10;
                break;
              }
            }
            if ((f2 | 0) == 10) {
              return a3 | 0;
            }
            return 0;
          }
          function Sc(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0;
            d2 = ~~(+q(+(+s2(10, + +(15 - (b[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b[a3 + 4 >> 2] | 0)) >>> 0;
            a3 = b[(b[a3 >> 2] | 0) + (d2 << 2) >> 2] | 0;
            if (!a3) {
              d2 = 0;
              return d2 | 0;
            }
            while (1) {
              if (hb(a3, c3) | 0) {
                c3 = 5;
                break;
              }
              a3 = b[a3 + 32 >> 2] | 0;
              if (!a3) {
                a3 = 0;
                c3 = 5;
                break;
              }
            }
            if ((c3 | 0) == 5) {
              return a3 | 0;
            }
            return 0;
          }
          function Tc() {
            return 23312;
          }
          function Uc(a3) {
            a3 = +a3;
            return + +id(+a3);
          }
          function Vc(a3) {
            a3 = +a3;
            return ~~+Uc(a3) | 0;
          }
          function Wc(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0;
            w2 = S;
            S = S + 16 | 0;
            n2 = w2;
            do {
              if (a3 >>> 0 < 245) {
                k = a3 >>> 0 < 11 ? 16 : a3 + 11 & -8;
                a3 = k >>> 3;
                m = b[5829] | 0;
                d2 = m >>> a3;
                if (d2 & 3 | 0) {
                  c3 = (d2 & 1 ^ 1) + a3 | 0;
                  a3 = 23356 + (c3 << 1 << 2) | 0;
                  d2 = a3 + 8 | 0;
                  e3 = b[d2 >> 2] | 0;
                  f2 = e3 + 8 | 0;
                  g2 = b[f2 >> 2] | 0;
                  if ((g2 | 0) == (a3 | 0)) {
                    b[5829] = m & ~(1 << c3);
                  } else {
                    b[g2 + 12 >> 2] = a3;
                    b[d2 >> 2] = g2;
                  }
                  v2 = c3 << 3;
                  b[e3 + 4 >> 2] = v2 | 3;
                  v2 = e3 + v2 + 4 | 0;
                  b[v2 >> 2] = b[v2 >> 2] | 1;
                  v2 = f2;
                  S = w2;
                  return v2 | 0;
                }
                l2 = b[5831] | 0;
                if (k >>> 0 > l2 >>> 0) {
                  if (d2 | 0) {
                    c3 = 2 << a3;
                    c3 = d2 << a3 & (c3 | 0 - c3);
                    c3 = (c3 & 0 - c3) + -1 | 0;
                    i3 = c3 >>> 12 & 16;
                    c3 = c3 >>> i3;
                    d2 = c3 >>> 5 & 8;
                    c3 = c3 >>> d2;
                    g2 = c3 >>> 2 & 4;
                    c3 = c3 >>> g2;
                    a3 = c3 >>> 1 & 2;
                    c3 = c3 >>> a3;
                    e3 = c3 >>> 1 & 1;
                    e3 = (d2 | i3 | g2 | a3 | e3) + (c3 >>> e3) | 0;
                    c3 = 23356 + (e3 << 1 << 2) | 0;
                    a3 = c3 + 8 | 0;
                    g2 = b[a3 >> 2] | 0;
                    i3 = g2 + 8 | 0;
                    d2 = b[i3 >> 2] | 0;
                    if ((d2 | 0) == (c3 | 0)) {
                      a3 = m & ~(1 << e3);
                      b[5829] = a3;
                    } else {
                      b[d2 + 12 >> 2] = c3;
                      b[a3 >> 2] = d2;
                      a3 = m;
                    }
                    v2 = e3 << 3;
                    h = v2 - k | 0;
                    b[g2 + 4 >> 2] = k | 3;
                    f2 = g2 + k | 0;
                    b[f2 + 4 >> 2] = h | 1;
                    b[g2 + v2 >> 2] = h;
                    if (l2 | 0) {
                      e3 = b[5834] | 0;
                      c3 = l2 >>> 3;
                      d2 = 23356 + (c3 << 1 << 2) | 0;
                      c3 = 1 << c3;
                      if (!(a3 & c3)) {
                        b[5829] = a3 | c3;
                        c3 = d2;
                        a3 = d2 + 8 | 0;
                      } else {
                        a3 = d2 + 8 | 0;
                        c3 = b[a3 >> 2] | 0;
                      }
                      b[a3 >> 2] = e3;
                      b[c3 + 12 >> 2] = e3;
                      b[e3 + 8 >> 2] = c3;
                      b[e3 + 12 >> 2] = d2;
                    }
                    b[5831] = h;
                    b[5834] = f2;
                    v2 = i3;
                    S = w2;
                    return v2 | 0;
                  }
                  g2 = b[5830] | 0;
                  if (g2) {
                    d2 = (g2 & 0 - g2) + -1 | 0;
                    f2 = d2 >>> 12 & 16;
                    d2 = d2 >>> f2;
                    e3 = d2 >>> 5 & 8;
                    d2 = d2 >>> e3;
                    h = d2 >>> 2 & 4;
                    d2 = d2 >>> h;
                    i3 = d2 >>> 1 & 2;
                    d2 = d2 >>> i3;
                    j = d2 >>> 1 & 1;
                    j = b[23620 + ((e3 | f2 | h | i3 | j) + (d2 >>> j) << 2) >> 2] | 0;
                    d2 = j;
                    i3 = j;
                    j = (b[j + 4 >> 2] & -8) - k | 0;
                    while (1) {
                      a3 = b[d2 + 16 >> 2] | 0;
                      if (!a3) {
                        a3 = b[d2 + 20 >> 2] | 0;
                        if (!a3) {
                          break;
                        }
                      }
                      h = (b[a3 + 4 >> 2] & -8) - k | 0;
                      f2 = h >>> 0 < j >>> 0;
                      d2 = a3;
                      i3 = f2 ? a3 : i3;
                      j = f2 ? h : j;
                    }
                    h = i3 + k | 0;
                    if (h >>> 0 > i3 >>> 0) {
                      f2 = b[i3 + 24 >> 2] | 0;
                      c3 = b[i3 + 12 >> 2] | 0;
                      do {
                        if ((c3 | 0) == (i3 | 0)) {
                          a3 = i3 + 20 | 0;
                          c3 = b[a3 >> 2] | 0;
                          if (!c3) {
                            a3 = i3 + 16 | 0;
                            c3 = b[a3 >> 2] | 0;
                            if (!c3) {
                              d2 = 0;
                              break;
                            }
                          }
                          while (1) {
                            e3 = c3 + 20 | 0;
                            d2 = b[e3 >> 2] | 0;
                            if (!d2) {
                              e3 = c3 + 16 | 0;
                              d2 = b[e3 >> 2] | 0;
                              if (!d2) {
                                break;
                              } else {
                                c3 = d2;
                                a3 = e3;
                              }
                            } else {
                              c3 = d2;
                              a3 = e3;
                            }
                          }
                          b[a3 >> 2] = 0;
                          d2 = c3;
                        } else {
                          d2 = b[i3 + 8 >> 2] | 0;
                          b[d2 + 12 >> 2] = c3;
                          b[c3 + 8 >> 2] = d2;
                          d2 = c3;
                        }
                      } while (0);
                      do {
                        if (f2 | 0) {
                          c3 = b[i3 + 28 >> 2] | 0;
                          a3 = 23620 + (c3 << 2) | 0;
                          if ((i3 | 0) == (b[a3 >> 2] | 0)) {
                            b[a3 >> 2] = d2;
                            if (!d2) {
                              b[5830] = g2 & ~(1 << c3);
                              break;
                            }
                          } else {
                            v2 = f2 + 16 | 0;
                            b[((b[v2 >> 2] | 0) == (i3 | 0) ? v2 : f2 + 20 | 0) >> 2] = d2;
                            if (!d2) {
                              break;
                            }
                          }
                          b[d2 + 24 >> 2] = f2;
                          c3 = b[i3 + 16 >> 2] | 0;
                          if (c3 | 0) {
                            b[d2 + 16 >> 2] = c3;
                            b[c3 + 24 >> 2] = d2;
                          }
                          c3 = b[i3 + 20 >> 2] | 0;
                          if (c3 | 0) {
                            b[d2 + 20 >> 2] = c3;
                            b[c3 + 24 >> 2] = d2;
                          }
                        }
                      } while (0);
                      if (j >>> 0 < 16) {
                        v2 = j + k | 0;
                        b[i3 + 4 >> 2] = v2 | 3;
                        v2 = i3 + v2 + 4 | 0;
                        b[v2 >> 2] = b[v2 >> 2] | 1;
                      } else {
                        b[i3 + 4 >> 2] = k | 3;
                        b[h + 4 >> 2] = j | 1;
                        b[h + j >> 2] = j;
                        if (l2 | 0) {
                          e3 = b[5834] | 0;
                          c3 = l2 >>> 3;
                          d2 = 23356 + (c3 << 1 << 2) | 0;
                          c3 = 1 << c3;
                          if (!(c3 & m)) {
                            b[5829] = c3 | m;
                            c3 = d2;
                            a3 = d2 + 8 | 0;
                          } else {
                            a3 = d2 + 8 | 0;
                            c3 = b[a3 >> 2] | 0;
                          }
                          b[a3 >> 2] = e3;
                          b[c3 + 12 >> 2] = e3;
                          b[e3 + 8 >> 2] = c3;
                          b[e3 + 12 >> 2] = d2;
                        }
                        b[5831] = j;
                        b[5834] = h;
                      }
                      v2 = i3 + 8 | 0;
                      S = w2;
                      return v2 | 0;
                    } else {
                      m = k;
                    }
                  } else {
                    m = k;
                  }
                } else {
                  m = k;
                }
              } else if (a3 >>> 0 <= 4294967231) {
                a3 = a3 + 11 | 0;
                k = a3 & -8;
                e3 = b[5830] | 0;
                if (e3) {
                  f2 = 0 - k | 0;
                  a3 = a3 >>> 8;
                  if (a3) {
                    if (k >>> 0 > 16777215) {
                      j = 31;
                    } else {
                      m = (a3 + 1048320 | 0) >>> 16 & 8;
                      q2 = a3 << m;
                      i3 = (q2 + 520192 | 0) >>> 16 & 4;
                      q2 = q2 << i3;
                      j = (q2 + 245760 | 0) >>> 16 & 2;
                      j = 14 - (i3 | m | j) + (q2 << j >>> 15) | 0;
                      j = k >>> (j + 7 | 0) & 1 | j << 1;
                    }
                  } else {
                    j = 0;
                  }
                  d2 = b[23620 + (j << 2) >> 2] | 0;
                  a:
                    do {
                      if (!d2) {
                        d2 = 0;
                        a3 = 0;
                        q2 = 61;
                      } else {
                        a3 = 0;
                        i3 = k << ((j | 0) == 31 ? 0 : 25 - (j >>> 1) | 0);
                        g2 = 0;
                        while (1) {
                          h = (b[d2 + 4 >> 2] & -8) - k | 0;
                          if (h >>> 0 < f2 >>> 0) {
                            if (!h) {
                              a3 = d2;
                              f2 = 0;
                              q2 = 65;
                              break a;
                            } else {
                              a3 = d2;
                              f2 = h;
                            }
                          }
                          q2 = b[d2 + 20 >> 2] | 0;
                          d2 = b[d2 + 16 + (i3 >>> 31 << 2) >> 2] | 0;
                          g2 = (q2 | 0) == 0 | (q2 | 0) == (d2 | 0) ? g2 : q2;
                          if (!d2) {
                            d2 = g2;
                            q2 = 61;
                            break;
                          } else {
                            i3 = i3 << 1;
                          }
                        }
                      }
                    } while (0);
                  if ((q2 | 0) == 61) {
                    if ((d2 | 0) == 0 & (a3 | 0) == 0) {
                      a3 = 2 << j;
                      a3 = (a3 | 0 - a3) & e3;
                      if (!a3) {
                        m = k;
                        break;
                      }
                      m = (a3 & 0 - a3) + -1 | 0;
                      h = m >>> 12 & 16;
                      m = m >>> h;
                      g2 = m >>> 5 & 8;
                      m = m >>> g2;
                      i3 = m >>> 2 & 4;
                      m = m >>> i3;
                      j = m >>> 1 & 2;
                      m = m >>> j;
                      d2 = m >>> 1 & 1;
                      a3 = 0;
                      d2 = b[23620 + ((g2 | h | i3 | j | d2) + (m >>> d2) << 2) >> 2] | 0;
                    }
                    if (!d2) {
                      i3 = a3;
                      h = f2;
                    } else {
                      q2 = 65;
                    }
                  }
                  if ((q2 | 0) == 65) {
                    g2 = d2;
                    while (1) {
                      m = (b[g2 + 4 >> 2] & -8) - k | 0;
                      d2 = m >>> 0 < f2 >>> 0;
                      f2 = d2 ? m : f2;
                      a3 = d2 ? g2 : a3;
                      d2 = b[g2 + 16 >> 2] | 0;
                      if (!d2) {
                        d2 = b[g2 + 20 >> 2] | 0;
                      }
                      if (!d2) {
                        i3 = a3;
                        h = f2;
                        break;
                      } else {
                        g2 = d2;
                      }
                    }
                  }
                  if (((i3 | 0) != 0 ? h >>> 0 < ((b[5831] | 0) - k | 0) >>> 0 : 0) ? (l2 = i3 + k | 0, l2 >>> 0 > i3 >>> 0) : 0) {
                    g2 = b[i3 + 24 >> 2] | 0;
                    c3 = b[i3 + 12 >> 2] | 0;
                    do {
                      if ((c3 | 0) == (i3 | 0)) {
                        a3 = i3 + 20 | 0;
                        c3 = b[a3 >> 2] | 0;
                        if (!c3) {
                          a3 = i3 + 16 | 0;
                          c3 = b[a3 >> 2] | 0;
                          if (!c3) {
                            c3 = 0;
                            break;
                          }
                        }
                        while (1) {
                          f2 = c3 + 20 | 0;
                          d2 = b[f2 >> 2] | 0;
                          if (!d2) {
                            f2 = c3 + 16 | 0;
                            d2 = b[f2 >> 2] | 0;
                            if (!d2) {
                              break;
                            } else {
                              c3 = d2;
                              a3 = f2;
                            }
                          } else {
                            c3 = d2;
                            a3 = f2;
                          }
                        }
                        b[a3 >> 2] = 0;
                      } else {
                        v2 = b[i3 + 8 >> 2] | 0;
                        b[v2 + 12 >> 2] = c3;
                        b[c3 + 8 >> 2] = v2;
                      }
                    } while (0);
                    do {
                      if (g2) {
                        a3 = b[i3 + 28 >> 2] | 0;
                        d2 = 23620 + (a3 << 2) | 0;
                        if ((i3 | 0) == (b[d2 >> 2] | 0)) {
                          b[d2 >> 2] = c3;
                          if (!c3) {
                            e3 = e3 & ~(1 << a3);
                            b[5830] = e3;
                            break;
                          }
                        } else {
                          v2 = g2 + 16 | 0;
                          b[((b[v2 >> 2] | 0) == (i3 | 0) ? v2 : g2 + 20 | 0) >> 2] = c3;
                          if (!c3) {
                            break;
                          }
                        }
                        b[c3 + 24 >> 2] = g2;
                        a3 = b[i3 + 16 >> 2] | 0;
                        if (a3 | 0) {
                          b[c3 + 16 >> 2] = a3;
                          b[a3 + 24 >> 2] = c3;
                        }
                        a3 = b[i3 + 20 >> 2] | 0;
                        if (a3) {
                          b[c3 + 20 >> 2] = a3;
                          b[a3 + 24 >> 2] = c3;
                        }
                      }
                    } while (0);
                    b:
                      do {
                        if (h >>> 0 < 16) {
                          v2 = h + k | 0;
                          b[i3 + 4 >> 2] = v2 | 3;
                          v2 = i3 + v2 + 4 | 0;
                          b[v2 >> 2] = b[v2 >> 2] | 1;
                        } else {
                          b[i3 + 4 >> 2] = k | 3;
                          b[l2 + 4 >> 2] = h | 1;
                          b[l2 + h >> 2] = h;
                          c3 = h >>> 3;
                          if (h >>> 0 < 256) {
                            d2 = 23356 + (c3 << 1 << 2) | 0;
                            a3 = b[5829] | 0;
                            c3 = 1 << c3;
                            if (!(a3 & c3)) {
                              b[5829] = a3 | c3;
                              c3 = d2;
                              a3 = d2 + 8 | 0;
                            } else {
                              a3 = d2 + 8 | 0;
                              c3 = b[a3 >> 2] | 0;
                            }
                            b[a3 >> 2] = l2;
                            b[c3 + 12 >> 2] = l2;
                            b[l2 + 8 >> 2] = c3;
                            b[l2 + 12 >> 2] = d2;
                            break;
                          }
                          c3 = h >>> 8;
                          if (c3) {
                            if (h >>> 0 > 16777215) {
                              d2 = 31;
                            } else {
                              u2 = (c3 + 1048320 | 0) >>> 16 & 8;
                              v2 = c3 << u2;
                              t3 = (v2 + 520192 | 0) >>> 16 & 4;
                              v2 = v2 << t3;
                              d2 = (v2 + 245760 | 0) >>> 16 & 2;
                              d2 = 14 - (t3 | u2 | d2) + (v2 << d2 >>> 15) | 0;
                              d2 = h >>> (d2 + 7 | 0) & 1 | d2 << 1;
                            }
                          } else {
                            d2 = 0;
                          }
                          c3 = 23620 + (d2 << 2) | 0;
                          b[l2 + 28 >> 2] = d2;
                          a3 = l2 + 16 | 0;
                          b[a3 + 4 >> 2] = 0;
                          b[a3 >> 2] = 0;
                          a3 = 1 << d2;
                          if (!(e3 & a3)) {
                            b[5830] = e3 | a3;
                            b[c3 >> 2] = l2;
                            b[l2 + 24 >> 2] = c3;
                            b[l2 + 12 >> 2] = l2;
                            b[l2 + 8 >> 2] = l2;
                            break;
                          }
                          c3 = b[c3 >> 2] | 0;
                          c:
                            do {
                              if ((b[c3 + 4 >> 2] & -8 | 0) != (h | 0)) {
                                e3 = h << ((d2 | 0) == 31 ? 0 : 25 - (d2 >>> 1) | 0);
                                while (1) {
                                  d2 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                                  a3 = b[d2 >> 2] | 0;
                                  if (!a3) {
                                    break;
                                  }
                                  if ((b[a3 + 4 >> 2] & -8 | 0) == (h | 0)) {
                                    c3 = a3;
                                    break c;
                                  } else {
                                    e3 = e3 << 1;
                                    c3 = a3;
                                  }
                                }
                                b[d2 >> 2] = l2;
                                b[l2 + 24 >> 2] = c3;
                                b[l2 + 12 >> 2] = l2;
                                b[l2 + 8 >> 2] = l2;
                                break b;
                              }
                            } while (0);
                          u2 = c3 + 8 | 0;
                          v2 = b[u2 >> 2] | 0;
                          b[v2 + 12 >> 2] = l2;
                          b[u2 >> 2] = l2;
                          b[l2 + 8 >> 2] = v2;
                          b[l2 + 12 >> 2] = c3;
                          b[l2 + 24 >> 2] = 0;
                        }
                      } while (0);
                    v2 = i3 + 8 | 0;
                    S = w2;
                    return v2 | 0;
                  } else {
                    m = k;
                  }
                } else {
                  m = k;
                }
              } else {
                m = -1;
              }
            } while (0);
            d2 = b[5831] | 0;
            if (d2 >>> 0 >= m >>> 0) {
              c3 = d2 - m | 0;
              a3 = b[5834] | 0;
              if (c3 >>> 0 > 15) {
                v2 = a3 + m | 0;
                b[5834] = v2;
                b[5831] = c3;
                b[v2 + 4 >> 2] = c3 | 1;
                b[a3 + d2 >> 2] = c3;
                b[a3 + 4 >> 2] = m | 3;
              } else {
                b[5831] = 0;
                b[5834] = 0;
                b[a3 + 4 >> 2] = d2 | 3;
                v2 = a3 + d2 + 4 | 0;
                b[v2 >> 2] = b[v2 >> 2] | 1;
              }
              v2 = a3 + 8 | 0;
              S = w2;
              return v2 | 0;
            }
            h = b[5832] | 0;
            if (h >>> 0 > m >>> 0) {
              t3 = h - m | 0;
              b[5832] = t3;
              v2 = b[5835] | 0;
              u2 = v2 + m | 0;
              b[5835] = u2;
              b[u2 + 4 >> 2] = t3 | 1;
              b[v2 + 4 >> 2] = m | 3;
              v2 = v2 + 8 | 0;
              S = w2;
              return v2 | 0;
            }
            if (!(b[5947] | 0)) {
              b[5949] = 4096;
              b[5948] = 4096;
              b[5950] = -1;
              b[5951] = -1;
              b[5952] = 0;
              b[5940] = 0;
              b[5947] = n2 & -16 ^ 1431655768;
              a3 = 4096;
            } else {
              a3 = b[5949] | 0;
            }
            i3 = m + 48 | 0;
            j = m + 47 | 0;
            g2 = a3 + j | 0;
            f2 = 0 - a3 | 0;
            k = g2 & f2;
            if (k >>> 0 <= m >>> 0) {
              v2 = 0;
              S = w2;
              return v2 | 0;
            }
            a3 = b[5939] | 0;
            if (a3 | 0 ? (l2 = b[5937] | 0, n2 = l2 + k | 0, n2 >>> 0 <= l2 >>> 0 | n2 >>> 0 > a3 >>> 0) : 0) {
              v2 = 0;
              S = w2;
              return v2 | 0;
            }
            d:
              do {
                if (!(b[5940] & 4)) {
                  d2 = b[5835] | 0;
                  e:
                    do {
                      if (d2) {
                        e3 = 23764;
                        while (1) {
                          n2 = b[e3 >> 2] | 0;
                          if (n2 >>> 0 <= d2 >>> 0 ? (n2 + (b[e3 + 4 >> 2] | 0) | 0) >>> 0 > d2 >>> 0 : 0) {
                            break;
                          }
                          a3 = b[e3 + 8 >> 2] | 0;
                          if (!a3) {
                            q2 = 128;
                            break e;
                          } else {
                            e3 = a3;
                          }
                        }
                        c3 = g2 - h & f2;
                        if (c3 >>> 0 < 2147483647) {
                          a3 = jd(c3 | 0) | 0;
                          if ((a3 | 0) == ((b[e3 >> 2] | 0) + (b[e3 + 4 >> 2] | 0) | 0)) {
                            if ((a3 | 0) != (-1 | 0)) {
                              h = c3;
                              g2 = a3;
                              q2 = 145;
                              break d;
                            }
                          } else {
                            e3 = a3;
                            q2 = 136;
                          }
                        } else {
                          c3 = 0;
                        }
                      } else {
                        q2 = 128;
                      }
                    } while (0);
                  do {
                    if ((q2 | 0) == 128) {
                      d2 = jd(0) | 0;
                      if ((d2 | 0) != (-1 | 0) ? (c3 = d2, o2 = b[5948] | 0, p3 = o2 + -1 | 0, c3 = ((p3 & c3 | 0) == 0 ? 0 : (p3 + c3 & 0 - o2) - c3 | 0) + k | 0, o2 = b[5937] | 0, p3 = c3 + o2 | 0, c3 >>> 0 > m >>> 0 & c3 >>> 0 < 2147483647) : 0) {
                        n2 = b[5939] | 0;
                        if (n2 | 0 ? p3 >>> 0 <= o2 >>> 0 | p3 >>> 0 > n2 >>> 0 : 0) {
                          c3 = 0;
                          break;
                        }
                        a3 = jd(c3 | 0) | 0;
                        if ((a3 | 0) == (d2 | 0)) {
                          h = c3;
                          g2 = d2;
                          q2 = 145;
                          break d;
                        } else {
                          e3 = a3;
                          q2 = 136;
                        }
                      } else {
                        c3 = 0;
                      }
                    }
                  } while (0);
                  do {
                    if ((q2 | 0) == 136) {
                      d2 = 0 - c3 | 0;
                      if (!(i3 >>> 0 > c3 >>> 0 & (c3 >>> 0 < 2147483647 & (e3 | 0) != (-1 | 0)))) {
                        if ((e3 | 0) == (-1 | 0)) {
                          c3 = 0;
                          break;
                        } else {
                          h = c3;
                          g2 = e3;
                          q2 = 145;
                          break d;
                        }
                      }
                      a3 = b[5949] | 0;
                      a3 = j - c3 + a3 & 0 - a3;
                      if (a3 >>> 0 >= 2147483647) {
                        h = c3;
                        g2 = e3;
                        q2 = 145;
                        break d;
                      }
                      if ((jd(a3 | 0) | 0) == (-1 | 0)) {
                        jd(d2 | 0) | 0;
                        c3 = 0;
                        break;
                      } else {
                        h = a3 + c3 | 0;
                        g2 = e3;
                        q2 = 145;
                        break d;
                      }
                    }
                  } while (0);
                  b[5940] = b[5940] | 4;
                  q2 = 143;
                } else {
                  c3 = 0;
                  q2 = 143;
                }
              } while (0);
            if (((q2 | 0) == 143 ? k >>> 0 < 2147483647 : 0) ? (t3 = jd(k | 0) | 0, p3 = jd(0) | 0, r3 = p3 - t3 | 0, s3 = r3 >>> 0 > (m + 40 | 0) >>> 0, !((t3 | 0) == (-1 | 0) | s3 ^ 1 | t3 >>> 0 < p3 >>> 0 & ((t3 | 0) != (-1 | 0) & (p3 | 0) != (-1 | 0)) ^ 1)) : 0) {
              h = s3 ? r3 : c3;
              g2 = t3;
              q2 = 145;
            }
            if ((q2 | 0) == 145) {
              c3 = (b[5937] | 0) + h | 0;
              b[5937] = c3;
              if (c3 >>> 0 > (b[5938] | 0) >>> 0) {
                b[5938] = c3;
              }
              j = b[5835] | 0;
              f:
                do {
                  if (j) {
                    c3 = 23764;
                    while (1) {
                      a3 = b[c3 >> 2] | 0;
                      d2 = b[c3 + 4 >> 2] | 0;
                      if ((g2 | 0) == (a3 + d2 | 0)) {
                        q2 = 154;
                        break;
                      }
                      e3 = b[c3 + 8 >> 2] | 0;
                      if (!e3) {
                        break;
                      } else {
                        c3 = e3;
                      }
                    }
                    if (((q2 | 0) == 154 ? (u2 = c3 + 4 | 0, (b[c3 + 12 >> 2] & 8 | 0) == 0) : 0) ? g2 >>> 0 > j >>> 0 & a3 >>> 0 <= j >>> 0 : 0) {
                      b[u2 >> 2] = d2 + h;
                      v2 = (b[5832] | 0) + h | 0;
                      t3 = j + 8 | 0;
                      t3 = (t3 & 7 | 0) == 0 ? 0 : 0 - t3 & 7;
                      u2 = j + t3 | 0;
                      t3 = v2 - t3 | 0;
                      b[5835] = u2;
                      b[5832] = t3;
                      b[u2 + 4 >> 2] = t3 | 1;
                      b[j + v2 + 4 >> 2] = 40;
                      b[5836] = b[5951];
                      break;
                    }
                    if (g2 >>> 0 < (b[5833] | 0) >>> 0) {
                      b[5833] = g2;
                    }
                    d2 = g2 + h | 0;
                    c3 = 23764;
                    while (1) {
                      if ((b[c3 >> 2] | 0) == (d2 | 0)) {
                        q2 = 162;
                        break;
                      }
                      a3 = b[c3 + 8 >> 2] | 0;
                      if (!a3) {
                        break;
                      } else {
                        c3 = a3;
                      }
                    }
                    if ((q2 | 0) == 162 ? (b[c3 + 12 >> 2] & 8 | 0) == 0 : 0) {
                      b[c3 >> 2] = g2;
                      l2 = c3 + 4 | 0;
                      b[l2 >> 2] = (b[l2 >> 2] | 0) + h;
                      l2 = g2 + 8 | 0;
                      l2 = g2 + ((l2 & 7 | 0) == 0 ? 0 : 0 - l2 & 7) | 0;
                      c3 = d2 + 8 | 0;
                      c3 = d2 + ((c3 & 7 | 0) == 0 ? 0 : 0 - c3 & 7) | 0;
                      k = l2 + m | 0;
                      i3 = c3 - l2 - m | 0;
                      b[l2 + 4 >> 2] = m | 3;
                      g:
                        do {
                          if ((j | 0) == (c3 | 0)) {
                            v2 = (b[5832] | 0) + i3 | 0;
                            b[5832] = v2;
                            b[5835] = k;
                            b[k + 4 >> 2] = v2 | 1;
                          } else {
                            if ((b[5834] | 0) == (c3 | 0)) {
                              v2 = (b[5831] | 0) + i3 | 0;
                              b[5831] = v2;
                              b[5834] = k;
                              b[k + 4 >> 2] = v2 | 1;
                              b[k + v2 >> 2] = v2;
                              break;
                            }
                            a3 = b[c3 + 4 >> 2] | 0;
                            if ((a3 & 3 | 0) == 1) {
                              h = a3 & -8;
                              e3 = a3 >>> 3;
                              h:
                                do {
                                  if (a3 >>> 0 < 256) {
                                    a3 = b[c3 + 8 >> 2] | 0;
                                    d2 = b[c3 + 12 >> 2] | 0;
                                    if ((d2 | 0) == (a3 | 0)) {
                                      b[5829] = b[5829] & ~(1 << e3);
                                      break;
                                    } else {
                                      b[a3 + 12 >> 2] = d2;
                                      b[d2 + 8 >> 2] = a3;
                                      break;
                                    }
                                  } else {
                                    g2 = b[c3 + 24 >> 2] | 0;
                                    a3 = b[c3 + 12 >> 2] | 0;
                                    do {
                                      if ((a3 | 0) == (c3 | 0)) {
                                        d2 = c3 + 16 | 0;
                                        e3 = d2 + 4 | 0;
                                        a3 = b[e3 >> 2] | 0;
                                        if (!a3) {
                                          a3 = b[d2 >> 2] | 0;
                                          if (!a3) {
                                            a3 = 0;
                                            break;
                                          }
                                        } else {
                                          d2 = e3;
                                        }
                                        while (1) {
                                          f2 = a3 + 20 | 0;
                                          e3 = b[f2 >> 2] | 0;
                                          if (!e3) {
                                            f2 = a3 + 16 | 0;
                                            e3 = b[f2 >> 2] | 0;
                                            if (!e3) {
                                              break;
                                            } else {
                                              a3 = e3;
                                              d2 = f2;
                                            }
                                          } else {
                                            a3 = e3;
                                            d2 = f2;
                                          }
                                        }
                                        b[d2 >> 2] = 0;
                                      } else {
                                        v2 = b[c3 + 8 >> 2] | 0;
                                        b[v2 + 12 >> 2] = a3;
                                        b[a3 + 8 >> 2] = v2;
                                      }
                                    } while (0);
                                    if (!g2) {
                                      break;
                                    }
                                    d2 = b[c3 + 28 >> 2] | 0;
                                    e3 = 23620 + (d2 << 2) | 0;
                                    do {
                                      if ((b[e3 >> 2] | 0) != (c3 | 0)) {
                                        v2 = g2 + 16 | 0;
                                        b[((b[v2 >> 2] | 0) == (c3 | 0) ? v2 : g2 + 20 | 0) >> 2] = a3;
                                        if (!a3) {
                                          break h;
                                        }
                                      } else {
                                        b[e3 >> 2] = a3;
                                        if (a3 | 0) {
                                          break;
                                        }
                                        b[5830] = b[5830] & ~(1 << d2);
                                        break h;
                                      }
                                    } while (0);
                                    b[a3 + 24 >> 2] = g2;
                                    d2 = c3 + 16 | 0;
                                    e3 = b[d2 >> 2] | 0;
                                    if (e3 | 0) {
                                      b[a3 + 16 >> 2] = e3;
                                      b[e3 + 24 >> 2] = a3;
                                    }
                                    d2 = b[d2 + 4 >> 2] | 0;
                                    if (!d2) {
                                      break;
                                    }
                                    b[a3 + 20 >> 2] = d2;
                                    b[d2 + 24 >> 2] = a3;
                                  }
                                } while (0);
                              c3 = c3 + h | 0;
                              f2 = h + i3 | 0;
                            } else {
                              f2 = i3;
                            }
                            c3 = c3 + 4 | 0;
                            b[c3 >> 2] = b[c3 >> 2] & -2;
                            b[k + 4 >> 2] = f2 | 1;
                            b[k + f2 >> 2] = f2;
                            c3 = f2 >>> 3;
                            if (f2 >>> 0 < 256) {
                              d2 = 23356 + (c3 << 1 << 2) | 0;
                              a3 = b[5829] | 0;
                              c3 = 1 << c3;
                              if (!(a3 & c3)) {
                                b[5829] = a3 | c3;
                                c3 = d2;
                                a3 = d2 + 8 | 0;
                              } else {
                                a3 = d2 + 8 | 0;
                                c3 = b[a3 >> 2] | 0;
                              }
                              b[a3 >> 2] = k;
                              b[c3 + 12 >> 2] = k;
                              b[k + 8 >> 2] = c3;
                              b[k + 12 >> 2] = d2;
                              break;
                            }
                            c3 = f2 >>> 8;
                            do {
                              if (!c3) {
                                e3 = 0;
                              } else {
                                if (f2 >>> 0 > 16777215) {
                                  e3 = 31;
                                  break;
                                }
                                u2 = (c3 + 1048320 | 0) >>> 16 & 8;
                                v2 = c3 << u2;
                                t3 = (v2 + 520192 | 0) >>> 16 & 4;
                                v2 = v2 << t3;
                                e3 = (v2 + 245760 | 0) >>> 16 & 2;
                                e3 = 14 - (t3 | u2 | e3) + (v2 << e3 >>> 15) | 0;
                                e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                              }
                            } while (0);
                            c3 = 23620 + (e3 << 2) | 0;
                            b[k + 28 >> 2] = e3;
                            a3 = k + 16 | 0;
                            b[a3 + 4 >> 2] = 0;
                            b[a3 >> 2] = 0;
                            a3 = b[5830] | 0;
                            d2 = 1 << e3;
                            if (!(a3 & d2)) {
                              b[5830] = a3 | d2;
                              b[c3 >> 2] = k;
                              b[k + 24 >> 2] = c3;
                              b[k + 12 >> 2] = k;
                              b[k + 8 >> 2] = k;
                              break;
                            }
                            c3 = b[c3 >> 2] | 0;
                            i:
                              do {
                                if ((b[c3 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                                  e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                                  while (1) {
                                    d2 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                                    a3 = b[d2 >> 2] | 0;
                                    if (!a3) {
                                      break;
                                    }
                                    if ((b[a3 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                                      c3 = a3;
                                      break i;
                                    } else {
                                      e3 = e3 << 1;
                                      c3 = a3;
                                    }
                                  }
                                  b[d2 >> 2] = k;
                                  b[k + 24 >> 2] = c3;
                                  b[k + 12 >> 2] = k;
                                  b[k + 8 >> 2] = k;
                                  break g;
                                }
                              } while (0);
                            u2 = c3 + 8 | 0;
                            v2 = b[u2 >> 2] | 0;
                            b[v2 + 12 >> 2] = k;
                            b[u2 >> 2] = k;
                            b[k + 8 >> 2] = v2;
                            b[k + 12 >> 2] = c3;
                            b[k + 24 >> 2] = 0;
                          }
                        } while (0);
                      v2 = l2 + 8 | 0;
                      S = w2;
                      return v2 | 0;
                    }
                    c3 = 23764;
                    while (1) {
                      a3 = b[c3 >> 2] | 0;
                      if (a3 >>> 0 <= j >>> 0 ? (v2 = a3 + (b[c3 + 4 >> 2] | 0) | 0, v2 >>> 0 > j >>> 0) : 0) {
                        break;
                      }
                      c3 = b[c3 + 8 >> 2] | 0;
                    }
                    f2 = v2 + -47 | 0;
                    a3 = f2 + 8 | 0;
                    a3 = f2 + ((a3 & 7 | 0) == 0 ? 0 : 0 - a3 & 7) | 0;
                    f2 = j + 16 | 0;
                    a3 = a3 >>> 0 < f2 >>> 0 ? j : a3;
                    c3 = a3 + 8 | 0;
                    d2 = h + -40 | 0;
                    t3 = g2 + 8 | 0;
                    t3 = (t3 & 7 | 0) == 0 ? 0 : 0 - t3 & 7;
                    u2 = g2 + t3 | 0;
                    t3 = d2 - t3 | 0;
                    b[5835] = u2;
                    b[5832] = t3;
                    b[u2 + 4 >> 2] = t3 | 1;
                    b[g2 + d2 + 4 >> 2] = 40;
                    b[5836] = b[5951];
                    d2 = a3 + 4 | 0;
                    b[d2 >> 2] = 27;
                    b[c3 >> 2] = b[5941];
                    b[c3 + 4 >> 2] = b[5942];
                    b[c3 + 8 >> 2] = b[5943];
                    b[c3 + 12 >> 2] = b[5944];
                    b[5941] = g2;
                    b[5942] = h;
                    b[5944] = 0;
                    b[5943] = c3;
                    c3 = a3 + 24 | 0;
                    do {
                      u2 = c3;
                      c3 = c3 + 4 | 0;
                      b[c3 >> 2] = 7;
                    } while ((u2 + 8 | 0) >>> 0 < v2 >>> 0);
                    if ((a3 | 0) != (j | 0)) {
                      g2 = a3 - j | 0;
                      b[d2 >> 2] = b[d2 >> 2] & -2;
                      b[j + 4 >> 2] = g2 | 1;
                      b[a3 >> 2] = g2;
                      c3 = g2 >>> 3;
                      if (g2 >>> 0 < 256) {
                        d2 = 23356 + (c3 << 1 << 2) | 0;
                        a3 = b[5829] | 0;
                        c3 = 1 << c3;
                        if (!(a3 & c3)) {
                          b[5829] = a3 | c3;
                          c3 = d2;
                          a3 = d2 + 8 | 0;
                        } else {
                          a3 = d2 + 8 | 0;
                          c3 = b[a3 >> 2] | 0;
                        }
                        b[a3 >> 2] = j;
                        b[c3 + 12 >> 2] = j;
                        b[j + 8 >> 2] = c3;
                        b[j + 12 >> 2] = d2;
                        break;
                      }
                      c3 = g2 >>> 8;
                      if (c3) {
                        if (g2 >>> 0 > 16777215) {
                          e3 = 31;
                        } else {
                          u2 = (c3 + 1048320 | 0) >>> 16 & 8;
                          v2 = c3 << u2;
                          t3 = (v2 + 520192 | 0) >>> 16 & 4;
                          v2 = v2 << t3;
                          e3 = (v2 + 245760 | 0) >>> 16 & 2;
                          e3 = 14 - (t3 | u2 | e3) + (v2 << e3 >>> 15) | 0;
                          e3 = g2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                        }
                      } else {
                        e3 = 0;
                      }
                      d2 = 23620 + (e3 << 2) | 0;
                      b[j + 28 >> 2] = e3;
                      b[j + 20 >> 2] = 0;
                      b[f2 >> 2] = 0;
                      c3 = b[5830] | 0;
                      a3 = 1 << e3;
                      if (!(c3 & a3)) {
                        b[5830] = c3 | a3;
                        b[d2 >> 2] = j;
                        b[j + 24 >> 2] = d2;
                        b[j + 12 >> 2] = j;
                        b[j + 8 >> 2] = j;
                        break;
                      }
                      c3 = b[d2 >> 2] | 0;
                      j:
                        do {
                          if ((b[c3 + 4 >> 2] & -8 | 0) != (g2 | 0)) {
                            e3 = g2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                            while (1) {
                              d2 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                              a3 = b[d2 >> 2] | 0;
                              if (!a3) {
                                break;
                              }
                              if ((b[a3 + 4 >> 2] & -8 | 0) == (g2 | 0)) {
                                c3 = a3;
                                break j;
                              } else {
                                e3 = e3 << 1;
                                c3 = a3;
                              }
                            }
                            b[d2 >> 2] = j;
                            b[j + 24 >> 2] = c3;
                            b[j + 12 >> 2] = j;
                            b[j + 8 >> 2] = j;
                            break f;
                          }
                        } while (0);
                      u2 = c3 + 8 | 0;
                      v2 = b[u2 >> 2] | 0;
                      b[v2 + 12 >> 2] = j;
                      b[u2 >> 2] = j;
                      b[j + 8 >> 2] = v2;
                      b[j + 12 >> 2] = c3;
                      b[j + 24 >> 2] = 0;
                    }
                  } else {
                    v2 = b[5833] | 0;
                    if ((v2 | 0) == 0 | g2 >>> 0 < v2 >>> 0) {
                      b[5833] = g2;
                    }
                    b[5941] = g2;
                    b[5942] = h;
                    b[5944] = 0;
                    b[5838] = b[5947];
                    b[5837] = -1;
                    b[5842] = 23356;
                    b[5841] = 23356;
                    b[5844] = 23364;
                    b[5843] = 23364;
                    b[5846] = 23372;
                    b[5845] = 23372;
                    b[5848] = 23380;
                    b[5847] = 23380;
                    b[5850] = 23388;
                    b[5849] = 23388;
                    b[5852] = 23396;
                    b[5851] = 23396;
                    b[5854] = 23404;
                    b[5853] = 23404;
                    b[5856] = 23412;
                    b[5855] = 23412;
                    b[5858] = 23420;
                    b[5857] = 23420;
                    b[5860] = 23428;
                    b[5859] = 23428;
                    b[5862] = 23436;
                    b[5861] = 23436;
                    b[5864] = 23444;
                    b[5863] = 23444;
                    b[5866] = 23452;
                    b[5865] = 23452;
                    b[5868] = 23460;
                    b[5867] = 23460;
                    b[5870] = 23468;
                    b[5869] = 23468;
                    b[5872] = 23476;
                    b[5871] = 23476;
                    b[5874] = 23484;
                    b[5873] = 23484;
                    b[5876] = 23492;
                    b[5875] = 23492;
                    b[5878] = 23500;
                    b[5877] = 23500;
                    b[5880] = 23508;
                    b[5879] = 23508;
                    b[5882] = 23516;
                    b[5881] = 23516;
                    b[5884] = 23524;
                    b[5883] = 23524;
                    b[5886] = 23532;
                    b[5885] = 23532;
                    b[5888] = 23540;
                    b[5887] = 23540;
                    b[5890] = 23548;
                    b[5889] = 23548;
                    b[5892] = 23556;
                    b[5891] = 23556;
                    b[5894] = 23564;
                    b[5893] = 23564;
                    b[5896] = 23572;
                    b[5895] = 23572;
                    b[5898] = 23580;
                    b[5897] = 23580;
                    b[5900] = 23588;
                    b[5899] = 23588;
                    b[5902] = 23596;
                    b[5901] = 23596;
                    b[5904] = 23604;
                    b[5903] = 23604;
                    v2 = h + -40 | 0;
                    t3 = g2 + 8 | 0;
                    t3 = (t3 & 7 | 0) == 0 ? 0 : 0 - t3 & 7;
                    u2 = g2 + t3 | 0;
                    t3 = v2 - t3 | 0;
                    b[5835] = u2;
                    b[5832] = t3;
                    b[u2 + 4 >> 2] = t3 | 1;
                    b[g2 + v2 + 4 >> 2] = 40;
                    b[5836] = b[5951];
                  }
                } while (0);
              c3 = b[5832] | 0;
              if (c3 >>> 0 > m >>> 0) {
                t3 = c3 - m | 0;
                b[5832] = t3;
                v2 = b[5835] | 0;
                u2 = v2 + m | 0;
                b[5835] = u2;
                b[u2 + 4 >> 2] = t3 | 1;
                b[v2 + 4 >> 2] = m | 3;
                v2 = v2 + 8 | 0;
                S = w2;
                return v2 | 0;
              }
            }
            v2 = Tc() | 0;
            b[v2 >> 2] = 12;
            v2 = 0;
            S = w2;
            return v2 | 0;
          }
          function Xc(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
            if (!a3) {
              return;
            }
            d2 = a3 + -8 | 0;
            f2 = b[5833] | 0;
            a3 = b[a3 + -4 >> 2] | 0;
            c3 = a3 & -8;
            j = d2 + c3 | 0;
            do {
              if (!(a3 & 1)) {
                e3 = b[d2 >> 2] | 0;
                if (!(a3 & 3)) {
                  return;
                }
                h = d2 + (0 - e3) | 0;
                g2 = e3 + c3 | 0;
                if (h >>> 0 < f2 >>> 0) {
                  return;
                }
                if ((b[5834] | 0) == (h | 0)) {
                  a3 = j + 4 | 0;
                  c3 = b[a3 >> 2] | 0;
                  if ((c3 & 3 | 0) != 3) {
                    i3 = h;
                    c3 = g2;
                    break;
                  }
                  b[5831] = g2;
                  b[a3 >> 2] = c3 & -2;
                  b[h + 4 >> 2] = g2 | 1;
                  b[h + g2 >> 2] = g2;
                  return;
                }
                d2 = e3 >>> 3;
                if (e3 >>> 0 < 256) {
                  a3 = b[h + 8 >> 2] | 0;
                  c3 = b[h + 12 >> 2] | 0;
                  if ((c3 | 0) == (a3 | 0)) {
                    b[5829] = b[5829] & ~(1 << d2);
                    i3 = h;
                    c3 = g2;
                    break;
                  } else {
                    b[a3 + 12 >> 2] = c3;
                    b[c3 + 8 >> 2] = a3;
                    i3 = h;
                    c3 = g2;
                    break;
                  }
                }
                f2 = b[h + 24 >> 2] | 0;
                a3 = b[h + 12 >> 2] | 0;
                do {
                  if ((a3 | 0) == (h | 0)) {
                    c3 = h + 16 | 0;
                    d2 = c3 + 4 | 0;
                    a3 = b[d2 >> 2] | 0;
                    if (!a3) {
                      a3 = b[c3 >> 2] | 0;
                      if (!a3) {
                        a3 = 0;
                        break;
                      }
                    } else {
                      c3 = d2;
                    }
                    while (1) {
                      e3 = a3 + 20 | 0;
                      d2 = b[e3 >> 2] | 0;
                      if (!d2) {
                        e3 = a3 + 16 | 0;
                        d2 = b[e3 >> 2] | 0;
                        if (!d2) {
                          break;
                        } else {
                          a3 = d2;
                          c3 = e3;
                        }
                      } else {
                        a3 = d2;
                        c3 = e3;
                      }
                    }
                    b[c3 >> 2] = 0;
                  } else {
                    i3 = b[h + 8 >> 2] | 0;
                    b[i3 + 12 >> 2] = a3;
                    b[a3 + 8 >> 2] = i3;
                  }
                } while (0);
                if (f2) {
                  c3 = b[h + 28 >> 2] | 0;
                  d2 = 23620 + (c3 << 2) | 0;
                  if ((b[d2 >> 2] | 0) == (h | 0)) {
                    b[d2 >> 2] = a3;
                    if (!a3) {
                      b[5830] = b[5830] & ~(1 << c3);
                      i3 = h;
                      c3 = g2;
                      break;
                    }
                  } else {
                    i3 = f2 + 16 | 0;
                    b[((b[i3 >> 2] | 0) == (h | 0) ? i3 : f2 + 20 | 0) >> 2] = a3;
                    if (!a3) {
                      i3 = h;
                      c3 = g2;
                      break;
                    }
                  }
                  b[a3 + 24 >> 2] = f2;
                  c3 = h + 16 | 0;
                  d2 = b[c3 >> 2] | 0;
                  if (d2 | 0) {
                    b[a3 + 16 >> 2] = d2;
                    b[d2 + 24 >> 2] = a3;
                  }
                  c3 = b[c3 + 4 >> 2] | 0;
                  if (c3) {
                    b[a3 + 20 >> 2] = c3;
                    b[c3 + 24 >> 2] = a3;
                    i3 = h;
                    c3 = g2;
                  } else {
                    i3 = h;
                    c3 = g2;
                  }
                } else {
                  i3 = h;
                  c3 = g2;
                }
              } else {
                i3 = d2;
                h = d2;
              }
            } while (0);
            if (h >>> 0 >= j >>> 0) {
              return;
            }
            a3 = j + 4 | 0;
            e3 = b[a3 >> 2] | 0;
            if (!(e3 & 1)) {
              return;
            }
            if (!(e3 & 2)) {
              if ((b[5835] | 0) == (j | 0)) {
                j = (b[5832] | 0) + c3 | 0;
                b[5832] = j;
                b[5835] = i3;
                b[i3 + 4 >> 2] = j | 1;
                if ((i3 | 0) != (b[5834] | 0)) {
                  return;
                }
                b[5834] = 0;
                b[5831] = 0;
                return;
              }
              if ((b[5834] | 0) == (j | 0)) {
                j = (b[5831] | 0) + c3 | 0;
                b[5831] = j;
                b[5834] = h;
                b[i3 + 4 >> 2] = j | 1;
                b[h + j >> 2] = j;
                return;
              }
              f2 = (e3 & -8) + c3 | 0;
              d2 = e3 >>> 3;
              do {
                if (e3 >>> 0 < 256) {
                  c3 = b[j + 8 >> 2] | 0;
                  a3 = b[j + 12 >> 2] | 0;
                  if ((a3 | 0) == (c3 | 0)) {
                    b[5829] = b[5829] & ~(1 << d2);
                    break;
                  } else {
                    b[c3 + 12 >> 2] = a3;
                    b[a3 + 8 >> 2] = c3;
                    break;
                  }
                } else {
                  g2 = b[j + 24 >> 2] | 0;
                  a3 = b[j + 12 >> 2] | 0;
                  do {
                    if ((a3 | 0) == (j | 0)) {
                      c3 = j + 16 | 0;
                      d2 = c3 + 4 | 0;
                      a3 = b[d2 >> 2] | 0;
                      if (!a3) {
                        a3 = b[c3 >> 2] | 0;
                        if (!a3) {
                          d2 = 0;
                          break;
                        }
                      } else {
                        c3 = d2;
                      }
                      while (1) {
                        e3 = a3 + 20 | 0;
                        d2 = b[e3 >> 2] | 0;
                        if (!d2) {
                          e3 = a3 + 16 | 0;
                          d2 = b[e3 >> 2] | 0;
                          if (!d2) {
                            break;
                          } else {
                            a3 = d2;
                            c3 = e3;
                          }
                        } else {
                          a3 = d2;
                          c3 = e3;
                        }
                      }
                      b[c3 >> 2] = 0;
                      d2 = a3;
                    } else {
                      d2 = b[j + 8 >> 2] | 0;
                      b[d2 + 12 >> 2] = a3;
                      b[a3 + 8 >> 2] = d2;
                      d2 = a3;
                    }
                  } while (0);
                  if (g2 | 0) {
                    a3 = b[j + 28 >> 2] | 0;
                    c3 = 23620 + (a3 << 2) | 0;
                    if ((b[c3 >> 2] | 0) == (j | 0)) {
                      b[c3 >> 2] = d2;
                      if (!d2) {
                        b[5830] = b[5830] & ~(1 << a3);
                        break;
                      }
                    } else {
                      e3 = g2 + 16 | 0;
                      b[((b[e3 >> 2] | 0) == (j | 0) ? e3 : g2 + 20 | 0) >> 2] = d2;
                      if (!d2) {
                        break;
                      }
                    }
                    b[d2 + 24 >> 2] = g2;
                    a3 = j + 16 | 0;
                    c3 = b[a3 >> 2] | 0;
                    if (c3 | 0) {
                      b[d2 + 16 >> 2] = c3;
                      b[c3 + 24 >> 2] = d2;
                    }
                    a3 = b[a3 + 4 >> 2] | 0;
                    if (a3 | 0) {
                      b[d2 + 20 >> 2] = a3;
                      b[a3 + 24 >> 2] = d2;
                    }
                  }
                }
              } while (0);
              b[i3 + 4 >> 2] = f2 | 1;
              b[h + f2 >> 2] = f2;
              if ((i3 | 0) == (b[5834] | 0)) {
                b[5831] = f2;
                return;
              }
            } else {
              b[a3 >> 2] = e3 & -2;
              b[i3 + 4 >> 2] = c3 | 1;
              b[h + c3 >> 2] = c3;
              f2 = c3;
            }
            a3 = f2 >>> 3;
            if (f2 >>> 0 < 256) {
              d2 = 23356 + (a3 << 1 << 2) | 0;
              c3 = b[5829] | 0;
              a3 = 1 << a3;
              if (!(c3 & a3)) {
                b[5829] = c3 | a3;
                a3 = d2;
                c3 = d2 + 8 | 0;
              } else {
                c3 = d2 + 8 | 0;
                a3 = b[c3 >> 2] | 0;
              }
              b[c3 >> 2] = i3;
              b[a3 + 12 >> 2] = i3;
              b[i3 + 8 >> 2] = a3;
              b[i3 + 12 >> 2] = d2;
              return;
            }
            a3 = f2 >>> 8;
            if (a3) {
              if (f2 >>> 0 > 16777215) {
                e3 = 31;
              } else {
                h = (a3 + 1048320 | 0) >>> 16 & 8;
                j = a3 << h;
                g2 = (j + 520192 | 0) >>> 16 & 4;
                j = j << g2;
                e3 = (j + 245760 | 0) >>> 16 & 2;
                e3 = 14 - (g2 | h | e3) + (j << e3 >>> 15) | 0;
                e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
              }
            } else {
              e3 = 0;
            }
            a3 = 23620 + (e3 << 2) | 0;
            b[i3 + 28 >> 2] = e3;
            b[i3 + 20 >> 2] = 0;
            b[i3 + 16 >> 2] = 0;
            c3 = b[5830] | 0;
            d2 = 1 << e3;
            a:
              do {
                if (!(c3 & d2)) {
                  b[5830] = c3 | d2;
                  b[a3 >> 2] = i3;
                  b[i3 + 24 >> 2] = a3;
                  b[i3 + 12 >> 2] = i3;
                  b[i3 + 8 >> 2] = i3;
                } else {
                  a3 = b[a3 >> 2] | 0;
                  b:
                    do {
                      if ((b[a3 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                        e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                        while (1) {
                          d2 = a3 + 16 + (e3 >>> 31 << 2) | 0;
                          c3 = b[d2 >> 2] | 0;
                          if (!c3) {
                            break;
                          }
                          if ((b[c3 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                            a3 = c3;
                            break b;
                          } else {
                            e3 = e3 << 1;
                            a3 = c3;
                          }
                        }
                        b[d2 >> 2] = i3;
                        b[i3 + 24 >> 2] = a3;
                        b[i3 + 12 >> 2] = i3;
                        b[i3 + 8 >> 2] = i3;
                        break a;
                      }
                    } while (0);
                  h = a3 + 8 | 0;
                  j = b[h >> 2] | 0;
                  b[j + 12 >> 2] = i3;
                  b[h >> 2] = i3;
                  b[i3 + 8 >> 2] = j;
                  b[i3 + 12 >> 2] = a3;
                  b[i3 + 24 >> 2] = 0;
                }
              } while (0);
            j = (b[5837] | 0) + -1 | 0;
            b[5837] = j;
            if (j | 0) {
              return;
            }
            a3 = 23772;
            while (1) {
              a3 = b[a3 >> 2] | 0;
              if (!a3) {
                break;
              } else {
                a3 = a3 + 8 | 0;
              }
            }
            b[5837] = -1;
            return;
          }
          function Yc(a3, c3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            var d2 = 0;
            if (a3) {
              d2 = B(c3, a3) | 0;
              if ((c3 | a3) >>> 0 > 65535) {
                d2 = ((d2 >>> 0) / (a3 >>> 0) | 0 | 0) == (c3 | 0) ? d2 : -1;
              }
            } else {
              d2 = 0;
            }
            a3 = Wc(d2) | 0;
            if (!a3) {
              return a3 | 0;
            }
            if (!(b[a3 + -4 >> 2] & 3)) {
              return a3 | 0;
            }
            hd(a3 | 0, 0, d2 | 0) | 0;
            return a3 | 0;
          }
          function Zc(a3, b2, c3, d2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            c3 = a3 + c3 >>> 0;
            return (F(b2 + d2 + (c3 >>> 0 < a3 >>> 0 | 0) >>> 0 | 0), c3 | 0) | 0;
          }
          function _c(a3, b2, c3, d2) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            d2 = b2 - d2 - (c3 >>> 0 > a3 >>> 0 | 0) >>> 0;
            return (F(d2 | 0), a3 - c3 >>> 0 | 0) | 0;
          }
          function $c(a3) {
            a3 = a3 | 0;
            return (a3 ? 31 - (D(a3 ^ a3 - 1) | 0) | 0 : 32) | 0;
          }
          function ad(a3, c3, d2, e3, f2) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            f2 = f2 | 0;
            var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0;
            l2 = a3;
            j = c3;
            k = j;
            h = d2;
            n2 = e3;
            i3 = n2;
            if (!k) {
              g2 = (f2 | 0) != 0;
              if (!i3) {
                if (g2) {
                  b[f2 >> 2] = (l2 >>> 0) % (h >>> 0);
                  b[f2 + 4 >> 2] = 0;
                }
                n2 = 0;
                f2 = (l2 >>> 0) / (h >>> 0) >>> 0;
                return (F(n2 | 0), f2) | 0;
              } else {
                if (!g2) {
                  n2 = 0;
                  f2 = 0;
                  return (F(n2 | 0), f2) | 0;
                }
                b[f2 >> 2] = a3 | 0;
                b[f2 + 4 >> 2] = c3 & 0;
                n2 = 0;
                f2 = 0;
                return (F(n2 | 0), f2) | 0;
              }
            }
            g2 = (i3 | 0) == 0;
            do {
              if (h) {
                if (!g2) {
                  g2 = (D(i3 | 0) | 0) - (D(k | 0) | 0) | 0;
                  if (g2 >>> 0 <= 31) {
                    m = g2 + 1 | 0;
                    i3 = 31 - g2 | 0;
                    c3 = g2 - 31 >> 31;
                    h = m;
                    a3 = l2 >>> (m >>> 0) & c3 | k << i3;
                    c3 = k >>> (m >>> 0) & c3;
                    g2 = 0;
                    i3 = l2 << i3;
                    break;
                  }
                  if (!f2) {
                    n2 = 0;
                    f2 = 0;
                    return (F(n2 | 0), f2) | 0;
                  }
                  b[f2 >> 2] = a3 | 0;
                  b[f2 + 4 >> 2] = j | c3 & 0;
                  n2 = 0;
                  f2 = 0;
                  return (F(n2 | 0), f2) | 0;
                }
                g2 = h - 1 | 0;
                if (g2 & h | 0) {
                  i3 = (D(h | 0) | 0) + 33 - (D(k | 0) | 0) | 0;
                  p3 = 64 - i3 | 0;
                  m = 32 - i3 | 0;
                  j = m >> 31;
                  o2 = i3 - 32 | 0;
                  c3 = o2 >> 31;
                  h = i3;
                  a3 = m - 1 >> 31 & k >>> (o2 >>> 0) | (k << m | l2 >>> (i3 >>> 0)) & c3;
                  c3 = c3 & k >>> (i3 >>> 0);
                  g2 = l2 << p3 & j;
                  i3 = (k << p3 | l2 >>> (o2 >>> 0)) & j | l2 << m & i3 - 33 >> 31;
                  break;
                }
                if (f2 | 0) {
                  b[f2 >> 2] = g2 & l2;
                  b[f2 + 4 >> 2] = 0;
                }
                if ((h | 0) == 1) {
                  o2 = j | c3 & 0;
                  p3 = a3 | 0 | 0;
                  return (F(o2 | 0), p3) | 0;
                } else {
                  p3 = $c(h | 0) | 0;
                  o2 = k >>> (p3 >>> 0) | 0;
                  p3 = k << 32 - p3 | l2 >>> (p3 >>> 0) | 0;
                  return (F(o2 | 0), p3) | 0;
                }
              } else {
                if (g2) {
                  if (f2 | 0) {
                    b[f2 >> 2] = (k >>> 0) % (h >>> 0);
                    b[f2 + 4 >> 2] = 0;
                  }
                  o2 = 0;
                  p3 = (k >>> 0) / (h >>> 0) >>> 0;
                  return (F(o2 | 0), p3) | 0;
                }
                if (!l2) {
                  if (f2 | 0) {
                    b[f2 >> 2] = 0;
                    b[f2 + 4 >> 2] = (k >>> 0) % (i3 >>> 0);
                  }
                  o2 = 0;
                  p3 = (k >>> 0) / (i3 >>> 0) >>> 0;
                  return (F(o2 | 0), p3) | 0;
                }
                g2 = i3 - 1 | 0;
                if (!(g2 & i3)) {
                  if (f2 | 0) {
                    b[f2 >> 2] = a3 | 0;
                    b[f2 + 4 >> 2] = g2 & k | c3 & 0;
                  }
                  o2 = 0;
                  p3 = k >>> (($c(i3 | 0) | 0) >>> 0);
                  return (F(o2 | 0), p3) | 0;
                }
                g2 = (D(i3 | 0) | 0) - (D(k | 0) | 0) | 0;
                if (g2 >>> 0 <= 30) {
                  c3 = g2 + 1 | 0;
                  i3 = 31 - g2 | 0;
                  h = c3;
                  a3 = k << i3 | l2 >>> (c3 >>> 0);
                  c3 = k >>> (c3 >>> 0);
                  g2 = 0;
                  i3 = l2 << i3;
                  break;
                }
                if (!f2) {
                  o2 = 0;
                  p3 = 0;
                  return (F(o2 | 0), p3) | 0;
                }
                b[f2 >> 2] = a3 | 0;
                b[f2 + 4 >> 2] = j | c3 & 0;
                o2 = 0;
                p3 = 0;
                return (F(o2 | 0), p3) | 0;
              }
            } while (0);
            if (!h) {
              k = i3;
              j = 0;
              i3 = 0;
            } else {
              m = d2 | 0 | 0;
              l2 = n2 | e3 & 0;
              k = Zc(m | 0, l2 | 0, -1, -1) | 0;
              d2 = G() | 0;
              j = i3;
              i3 = 0;
              do {
                e3 = j;
                j = g2 >>> 31 | j << 1;
                g2 = i3 | g2 << 1;
                e3 = a3 << 1 | e3 >>> 31 | 0;
                n2 = a3 >>> 31 | c3 << 1 | 0;
                _c(k | 0, d2 | 0, e3 | 0, n2 | 0) | 0;
                p3 = G() | 0;
                o2 = p3 >> 31 | ((p3 | 0) < 0 ? -1 : 0) << 1;
                i3 = o2 & 1;
                a3 = _c(e3 | 0, n2 | 0, o2 & m | 0, (((p3 | 0) < 0 ? -1 : 0) >> 31 | ((p3 | 0) < 0 ? -1 : 0) << 1) & l2 | 0) | 0;
                c3 = G() | 0;
                h = h - 1 | 0;
              } while ((h | 0) != 0);
              k = j;
              j = 0;
            }
            h = 0;
            if (f2 | 0) {
              b[f2 >> 2] = a3;
              b[f2 + 4 >> 2] = c3;
            }
            o2 = (g2 | 0) >>> 31 | (k | h) << 1 | (h << 1 | g2 >>> 31) & 0 | j;
            p3 = (g2 << 1 | 0 >>> 31) & -2 | i3;
            return (F(o2 | 0), p3) | 0;
          }
          function bd(a3, c3, d2, e3) {
            a3 = a3 | 0;
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0;
            g2 = S;
            S = S + 16 | 0;
            f2 = g2 | 0;
            ad(a3, c3, d2, e3, f2) | 0;
            S = g2;
            return (F(b[f2 + 4 >> 2] | 0), b[f2 >> 2] | 0) | 0;
          }
          function cd(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            if ((c3 | 0) < 32) {
              F(b2 >>> c3 | 0);
              return a3 >>> c3 | (b2 & (1 << c3) - 1) << 32 - c3;
            }
            F(0);
            return b2 >>> c3 - 32 | 0;
          }
          function dd(a3, b2, c3) {
            a3 = a3 | 0;
            b2 = b2 | 0;
            c3 = c3 | 0;
            if ((c3 | 0) < 32) {
              F(b2 << c3 | (a3 & (1 << c3) - 1 << 32 - c3) >>> 32 - c3 | 0);
              return a3 << c3;
            }
            F(a3 << c3 - 32 | 0);
            return 0;
          }
          function ed(a3, b2) {
            a3 = +a3;
            b2 = +b2;
            if (a3 != a3) {
              return +b2;
            }
            if (b2 != b2) {
              return +a3;
            }
            return +C(+a3, +b2);
          }
          function fd(a3) {
            a3 = +a3;
            return a3 >= 0 ? +p2(a3 + 0.5) : +A(a3 - 0.5);
          }
          function gd(c3, d2, e3) {
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0;
            if ((e3 | 0) >= 8192) {
              K(c3 | 0, d2 | 0, e3 | 0) | 0;
              return c3 | 0;
            }
            h = c3 | 0;
            g2 = c3 + e3 | 0;
            if ((c3 & 3) == (d2 & 3)) {
              while (c3 & 3) {
                if (!e3) {
                  return h | 0;
                }
                a2[c3 >> 0] = a2[d2 >> 0] | 0;
                c3 = c3 + 1 | 0;
                d2 = d2 + 1 | 0;
                e3 = e3 - 1 | 0;
              }
              e3 = g2 & -4 | 0;
              f2 = e3 - 64 | 0;
              while ((c3 | 0) <= (f2 | 0)) {
                b[c3 >> 2] = b[d2 >> 2];
                b[c3 + 4 >> 2] = b[d2 + 4 >> 2];
                b[c3 + 8 >> 2] = b[d2 + 8 >> 2];
                b[c3 + 12 >> 2] = b[d2 + 12 >> 2];
                b[c3 + 16 >> 2] = b[d2 + 16 >> 2];
                b[c3 + 20 >> 2] = b[d2 + 20 >> 2];
                b[c3 + 24 >> 2] = b[d2 + 24 >> 2];
                b[c3 + 28 >> 2] = b[d2 + 28 >> 2];
                b[c3 + 32 >> 2] = b[d2 + 32 >> 2];
                b[c3 + 36 >> 2] = b[d2 + 36 >> 2];
                b[c3 + 40 >> 2] = b[d2 + 40 >> 2];
                b[c3 + 44 >> 2] = b[d2 + 44 >> 2];
                b[c3 + 48 >> 2] = b[d2 + 48 >> 2];
                b[c3 + 52 >> 2] = b[d2 + 52 >> 2];
                b[c3 + 56 >> 2] = b[d2 + 56 >> 2];
                b[c3 + 60 >> 2] = b[d2 + 60 >> 2];
                c3 = c3 + 64 | 0;
                d2 = d2 + 64 | 0;
              }
              while ((c3 | 0) < (e3 | 0)) {
                b[c3 >> 2] = b[d2 >> 2];
                c3 = c3 + 4 | 0;
                d2 = d2 + 4 | 0;
              }
            } else {
              e3 = g2 - 4 | 0;
              while ((c3 | 0) < (e3 | 0)) {
                a2[c3 >> 0] = a2[d2 >> 0] | 0;
                a2[c3 + 1 >> 0] = a2[d2 + 1 >> 0] | 0;
                a2[c3 + 2 >> 0] = a2[d2 + 2 >> 0] | 0;
                a2[c3 + 3 >> 0] = a2[d2 + 3 >> 0] | 0;
                c3 = c3 + 4 | 0;
                d2 = d2 + 4 | 0;
              }
            }
            while ((c3 | 0) < (g2 | 0)) {
              a2[c3 >> 0] = a2[d2 >> 0] | 0;
              c3 = c3 + 1 | 0;
              d2 = d2 + 1 | 0;
            }
            return h | 0;
          }
          function hd(c3, d2, e3) {
            c3 = c3 | 0;
            d2 = d2 | 0;
            e3 = e3 | 0;
            var f2 = 0, g2 = 0, h = 0, i3 = 0;
            h = c3 + e3 | 0;
            d2 = d2 & 255;
            if ((e3 | 0) >= 67) {
              while (c3 & 3) {
                a2[c3 >> 0] = d2;
                c3 = c3 + 1 | 0;
              }
              f2 = h & -4 | 0;
              i3 = d2 | d2 << 8 | d2 << 16 | d2 << 24;
              g2 = f2 - 64 | 0;
              while ((c3 | 0) <= (g2 | 0)) {
                b[c3 >> 2] = i3;
                b[c3 + 4 >> 2] = i3;
                b[c3 + 8 >> 2] = i3;
                b[c3 + 12 >> 2] = i3;
                b[c3 + 16 >> 2] = i3;
                b[c3 + 20 >> 2] = i3;
                b[c3 + 24 >> 2] = i3;
                b[c3 + 28 >> 2] = i3;
                b[c3 + 32 >> 2] = i3;
                b[c3 + 36 >> 2] = i3;
                b[c3 + 40 >> 2] = i3;
                b[c3 + 44 >> 2] = i3;
                b[c3 + 48 >> 2] = i3;
                b[c3 + 52 >> 2] = i3;
                b[c3 + 56 >> 2] = i3;
                b[c3 + 60 >> 2] = i3;
                c3 = c3 + 64 | 0;
              }
              while ((c3 | 0) < (f2 | 0)) {
                b[c3 >> 2] = i3;
                c3 = c3 + 4 | 0;
              }
            }
            while ((c3 | 0) < (h | 0)) {
              a2[c3 >> 0] = d2;
              c3 = c3 + 1 | 0;
            }
            return h - e3 | 0;
          }
          function id(a3) {
            a3 = +a3;
            return a3 >= 0 ? +p2(a3 + 0.5) : +A(a3 - 0.5);
          }
          function jd(a3) {
            a3 = a3 | 0;
            var c3 = 0, d2 = 0, e3 = 0;
            e3 = J() | 0;
            d2 = b[g >> 2] | 0;
            c3 = d2 + a3 | 0;
            if ((a3 | 0) > 0 & (c3 | 0) < (d2 | 0) | (c3 | 0) < 0) {
              M(c3 | 0) | 0;
              I(12);
              return -1;
            }
            if ((c3 | 0) > (e3 | 0)) {
              if (!(L(c3 | 0) | 0)) {
                I(12);
                return -1;
              }
            }
            b[g >> 2] = c3;
            return d2 | 0;
          }
          return {
            ___uremdi3: bd,
            _bitshift64Lshr: cd,
            _bitshift64Shl: dd,
            _calloc: Yc,
            _cellAreaKm2: ub,
            _cellAreaM2: vb,
            _cellAreaRads2: tb,
            _compact: Hb,
            _destroyLinkedPolygon: jc,
            _edgeLengthKm: pb,
            _edgeLengthM: qb,
            _emscripten_replace_memory: V,
            _exactEdgeLengthKm: xb,
            _exactEdgeLengthM: yb,
            _exactEdgeLengthRads: wb,
            _experimentalH3ToLocalIj: oc,
            _experimentalLocalIjToH3: pc,
            _free: Xc,
            _geoToH3: Sb,
            _getDestinationH3IndexFromUnidirectionalEdge: cc,
            _getH3IndexesFromUnidirectionalEdge: ec,
            _getH3UnidirectionalEdge: ac,
            _getH3UnidirectionalEdgeBoundary: gc,
            _getH3UnidirectionalEdgesFromHexagon: fc,
            _getOriginH3IndexFromUnidirectionalEdge: bc,
            _getPentagonIndexes: _b,
            _getRes0Indexes: va,
            _h3Distance: qc,
            _h3GetBaseCell: Ab,
            _h3GetFaces: Yb,
            _h3GetResolution: zb,
            _h3IndexesAreNeighbors: $b,
            _h3IsPentagon: Fb,
            _h3IsResClassIII: Kb,
            _h3IsValid: Bb,
            _h3Line: sc,
            _h3LineSize: rc,
            _h3SetToLinkedGeo: ka,
            _h3ToCenterChild: Gb,
            _h3ToChildren: Eb,
            _h3ToGeo: Vb,
            _h3ToGeoBoundary: Wb,
            _h3ToParent: Cb,
            _h3UnidirectionalEdgeIsValid: dc,
            _hexAreaKm2: nb,
            _hexAreaM2: ob,
            _hexRing: ea,
            _i64Subtract: _c,
            _kRing: $,
            _kRingDistances: aa,
            _llvm_minnum_f64: ed,
            _llvm_round_f64: fd,
            _malloc: Wc,
            _maxFaceCount: Xb,
            _maxH3ToChildrenSize: Db,
            _maxKringSize: _2,
            _maxPolyfillSize: fa,
            _maxUncompactSize: Jb,
            _memcpy: gd,
            _memset: hd,
            _numHexagons: rb,
            _pentagonIndexCount: Zb,
            _pointDistKm: jb,
            _pointDistM: kb,
            _pointDistRads: ib,
            _polyfill: ga,
            _res0IndexCount: ua,
            _round: id,
            _sbrk: jd,
            _sizeOfCoordIJ: Ec,
            _sizeOfGeoBoundary: Ac,
            _sizeOfGeoCoord: zc,
            _sizeOfGeoPolygon: Cc,
            _sizeOfGeofence: Bc,
            _sizeOfH3Index: yc,
            _sizeOfLinkedGeoPolygon: Dc,
            _uncompact: Ib,
            establishStackSpace: Z,
            stackAlloc: W,
            stackRestore: Y,
            stackSave: X
          };
        }(
          // EMSCRIPTEN_END_ASM
          asmGlobalArg,
          asmLibraryArg,
          buffer
        )
      );
      var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
      var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
      var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
      var _calloc = Module["_calloc"] = asm["_calloc"];
      var _cellAreaKm2 = Module["_cellAreaKm2"] = asm["_cellAreaKm2"];
      var _cellAreaM2 = Module["_cellAreaM2"] = asm["_cellAreaM2"];
      var _cellAreaRads2 = Module["_cellAreaRads2"] = asm["_cellAreaRads2"];
      var _compact = Module["_compact"] = asm["_compact"];
      var _destroyLinkedPolygon = Module["_destroyLinkedPolygon"] = asm["_destroyLinkedPolygon"];
      var _edgeLengthKm = Module["_edgeLengthKm"] = asm["_edgeLengthKm"];
      var _edgeLengthM = Module["_edgeLengthM"] = asm["_edgeLengthM"];
      var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];
      var _exactEdgeLengthKm = Module["_exactEdgeLengthKm"] = asm["_exactEdgeLengthKm"];
      var _exactEdgeLengthM = Module["_exactEdgeLengthM"] = asm["_exactEdgeLengthM"];
      var _exactEdgeLengthRads = Module["_exactEdgeLengthRads"] = asm["_exactEdgeLengthRads"];
      var _experimentalH3ToLocalIj = Module["_experimentalH3ToLocalIj"] = asm["_experimentalH3ToLocalIj"];
      var _experimentalLocalIjToH3 = Module["_experimentalLocalIjToH3"] = asm["_experimentalLocalIjToH3"];
      var _free = Module["_free"] = asm["_free"];
      var _geoToH3 = Module["_geoToH3"] = asm["_geoToH3"];
      var _getDestinationH3IndexFromUnidirectionalEdge = Module["_getDestinationH3IndexFromUnidirectionalEdge"] = asm["_getDestinationH3IndexFromUnidirectionalEdge"];
      var _getH3IndexesFromUnidirectionalEdge = Module["_getH3IndexesFromUnidirectionalEdge"] = asm["_getH3IndexesFromUnidirectionalEdge"];
      var _getH3UnidirectionalEdge = Module["_getH3UnidirectionalEdge"] = asm["_getH3UnidirectionalEdge"];
      var _getH3UnidirectionalEdgeBoundary = Module["_getH3UnidirectionalEdgeBoundary"] = asm["_getH3UnidirectionalEdgeBoundary"];
      var _getH3UnidirectionalEdgesFromHexagon = Module["_getH3UnidirectionalEdgesFromHexagon"] = asm["_getH3UnidirectionalEdgesFromHexagon"];
      var _getOriginH3IndexFromUnidirectionalEdge = Module["_getOriginH3IndexFromUnidirectionalEdge"] = asm["_getOriginH3IndexFromUnidirectionalEdge"];
      var _getPentagonIndexes = Module["_getPentagonIndexes"] = asm["_getPentagonIndexes"];
      var _getRes0Indexes = Module["_getRes0Indexes"] = asm["_getRes0Indexes"];
      var _h3Distance = Module["_h3Distance"] = asm["_h3Distance"];
      var _h3GetBaseCell = Module["_h3GetBaseCell"] = asm["_h3GetBaseCell"];
      var _h3GetFaces = Module["_h3GetFaces"] = asm["_h3GetFaces"];
      var _h3GetResolution = Module["_h3GetResolution"] = asm["_h3GetResolution"];
      var _h3IndexesAreNeighbors = Module["_h3IndexesAreNeighbors"] = asm["_h3IndexesAreNeighbors"];
      var _h3IsPentagon = Module["_h3IsPentagon"] = asm["_h3IsPentagon"];
      var _h3IsResClassIII = Module["_h3IsResClassIII"] = asm["_h3IsResClassIII"];
      var _h3IsValid = Module["_h3IsValid"] = asm["_h3IsValid"];
      var _h3Line = Module["_h3Line"] = asm["_h3Line"];
      var _h3LineSize = Module["_h3LineSize"] = asm["_h3LineSize"];
      var _h3SetToLinkedGeo = Module["_h3SetToLinkedGeo"] = asm["_h3SetToLinkedGeo"];
      var _h3ToCenterChild = Module["_h3ToCenterChild"] = asm["_h3ToCenterChild"];
      var _h3ToChildren = Module["_h3ToChildren"] = asm["_h3ToChildren"];
      var _h3ToGeo = Module["_h3ToGeo"] = asm["_h3ToGeo"];
      var _h3ToGeoBoundary = Module["_h3ToGeoBoundary"] = asm["_h3ToGeoBoundary"];
      var _h3ToParent = Module["_h3ToParent"] = asm["_h3ToParent"];
      var _h3UnidirectionalEdgeIsValid = Module["_h3UnidirectionalEdgeIsValid"] = asm["_h3UnidirectionalEdgeIsValid"];
      var _hexAreaKm2 = Module["_hexAreaKm2"] = asm["_hexAreaKm2"];
      var _hexAreaM2 = Module["_hexAreaM2"] = asm["_hexAreaM2"];
      var _hexRing = Module["_hexRing"] = asm["_hexRing"];
      var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
      var _kRing = Module["_kRing"] = asm["_kRing"];
      var _kRingDistances = Module["_kRingDistances"] = asm["_kRingDistances"];
      var _llvm_minnum_f64 = Module["_llvm_minnum_f64"] = asm["_llvm_minnum_f64"];
      var _llvm_round_f64 = Module["_llvm_round_f64"] = asm["_llvm_round_f64"];
      var _malloc = Module["_malloc"] = asm["_malloc"];
      var _maxFaceCount = Module["_maxFaceCount"] = asm["_maxFaceCount"];
      var _maxH3ToChildrenSize = Module["_maxH3ToChildrenSize"] = asm["_maxH3ToChildrenSize"];
      var _maxKringSize = Module["_maxKringSize"] = asm["_maxKringSize"];
      var _maxPolyfillSize = Module["_maxPolyfillSize"] = asm["_maxPolyfillSize"];
      var _maxUncompactSize = Module["_maxUncompactSize"] = asm["_maxUncompactSize"];
      var _memcpy = Module["_memcpy"] = asm["_memcpy"];
      var _memset = Module["_memset"] = asm["_memset"];
      var _numHexagons = Module["_numHexagons"] = asm["_numHexagons"];
      var _pentagonIndexCount = Module["_pentagonIndexCount"] = asm["_pentagonIndexCount"];
      var _pointDistKm = Module["_pointDistKm"] = asm["_pointDistKm"];
      var _pointDistM = Module["_pointDistM"] = asm["_pointDistM"];
      var _pointDistRads = Module["_pointDistRads"] = asm["_pointDistRads"];
      var _polyfill = Module["_polyfill"] = asm["_polyfill"];
      var _res0IndexCount = Module["_res0IndexCount"] = asm["_res0IndexCount"];
      var _round = Module["_round"] = asm["_round"];
      var _sbrk = Module["_sbrk"] = asm["_sbrk"];
      var _sizeOfCoordIJ = Module["_sizeOfCoordIJ"] = asm["_sizeOfCoordIJ"];
      var _sizeOfGeoBoundary = Module["_sizeOfGeoBoundary"] = asm["_sizeOfGeoBoundary"];
      var _sizeOfGeoCoord = Module["_sizeOfGeoCoord"] = asm["_sizeOfGeoCoord"];
      var _sizeOfGeoPolygon = Module["_sizeOfGeoPolygon"] = asm["_sizeOfGeoPolygon"];
      var _sizeOfGeofence = Module["_sizeOfGeofence"] = asm["_sizeOfGeofence"];
      var _sizeOfH3Index = Module["_sizeOfH3Index"] = asm["_sizeOfH3Index"];
      var _sizeOfLinkedGeoPolygon = Module["_sizeOfLinkedGeoPolygon"] = asm["_sizeOfLinkedGeoPolygon"];
      var _uncompact = Module["_uncompact"] = asm["_uncompact"];
      var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
      var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
      var stackRestore = Module["stackRestore"] = asm["stackRestore"];
      var stackSave = Module["stackSave"] = asm["stackSave"];
      Module["asm"] = asm;
      Module["cwrap"] = cwrap;
      Module["setValue"] = setValue;
      Module["getValue"] = getValue;
      Module["getTempRet0"] = getTempRet0;
      if (memoryInitializer) {
        if (!isDataURI(memoryInitializer)) {
          memoryInitializer = locateFile(memoryInitializer);
        }
        {
          addRunDependency("memory initializer");
          var applyMemoryInitializer = function(data) {
            if (data.byteLength) {
              data = new Uint8Array(data);
            }
            HEAPU8.set(data, GLOBAL_BASE);
            if (Module["memoryInitializerRequest"]) {
              delete Module["memoryInitializerRequest"].response;
            }
            removeRunDependency("memory initializer");
          };
          var doBrowserLoad = function() {
            readAsync(memoryInitializer, applyMemoryInitializer, function() {
              throw "could not load memory initializer " + memoryInitializer;
            });
          };
          var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
          if (memoryInitializerBytes) {
            applyMemoryInitializer(memoryInitializerBytes.buffer);
          } else if (Module["memoryInitializerRequest"]) {
            var useRequest = function() {
              var request = Module["memoryInitializerRequest"];
              var response = request.response;
              if (request.status !== 200 && request.status !== 0) {
                var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]);
                if (data) {
                  response = data.buffer;
                } else {
                  console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
                  doBrowserLoad();
                  return;
                }
              }
              applyMemoryInitializer(response);
            };
            if (Module["memoryInitializerRequest"].response) {
              setTimeout(useRequest, 0);
            } else {
              Module["memoryInitializerRequest"].addEventListener("load", useRequest);
            }
          } else {
            doBrowserLoad();
          }
        }
      }
      var calledRun;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun) {
          run();
        }
        if (!calledRun) {
          dependenciesFulfilled = runCaller;
        }
      };
      function run(args) {
        args = args || arguments_;
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0) {
          return;
        }
        function doRun() {
          if (calledRun) {
            return;
          }
          calledRun = true;
          if (ABORT) {
            return;
          }
          initRuntime();
          preMain();
          if (Module["onRuntimeInitialized"]) {
            Module["onRuntimeInitialized"]();
          }
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      Module["run"] = run;
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what += "";
        out(what);
        err(what);
        ABORT = true;
        throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
      }
      Module["abort"] = abort;
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function") {
          Module["preInit"] = [Module["preInit"]];
        }
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      run();
      return libh32;
    }(typeof libh3 === "object" ? libh3 : {});
    NUMBER = "number";
    BOOLEAN = NUMBER;
    H3_LOWER = NUMBER;
    H3_UPPER = NUMBER;
    RESOLUTION = NUMBER;
    POINTER = NUMBER;
    BINDINGS = [
      // The size functions are inserted via build/sizes.h
      ["sizeOfH3Index", NUMBER],
      ["sizeOfGeoCoord", NUMBER],
      ["sizeOfGeoBoundary", NUMBER],
      ["sizeOfGeoPolygon", NUMBER],
      ["sizeOfGeofence", NUMBER],
      ["sizeOfLinkedGeoPolygon", NUMBER],
      ["sizeOfCoordIJ", NUMBER],
      // The remaining functions are defined in the core lib in h3Api.h
      ["h3IsValid", BOOLEAN, [H3_LOWER, H3_UPPER]],
      ["geoToH3", H3_LOWER, [NUMBER, NUMBER, RESOLUTION]],
      ["h3ToGeo", null, [H3_LOWER, H3_UPPER, POINTER]],
      ["h3ToGeoBoundary", null, [H3_LOWER, H3_UPPER, POINTER]],
      ["maxKringSize", NUMBER, [NUMBER]],
      ["kRing", null, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
      ["kRingDistances", null, [H3_LOWER, H3_UPPER, NUMBER, POINTER, POINTER]],
      ["hexRing", null, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
      ["maxPolyfillSize", NUMBER, [POINTER, RESOLUTION]],
      ["polyfill", null, [POINTER, RESOLUTION, POINTER]],
      ["h3SetToLinkedGeo", null, [POINTER, NUMBER, POINTER]],
      ["destroyLinkedPolygon", null, [POINTER]],
      ["compact", NUMBER, [POINTER, POINTER, NUMBER]],
      ["uncompact", NUMBER, [POINTER, NUMBER, POINTER, NUMBER, RESOLUTION]],
      ["maxUncompactSize", NUMBER, [POINTER, NUMBER, RESOLUTION]],
      ["h3IsPentagon", BOOLEAN, [H3_LOWER, H3_UPPER]],
      ["h3IsResClassIII", BOOLEAN, [H3_LOWER, H3_UPPER]],
      ["h3GetBaseCell", NUMBER, [H3_LOWER, H3_UPPER]],
      ["h3GetResolution", NUMBER, [H3_LOWER, H3_UPPER]],
      ["maxFaceCount", NUMBER, [H3_LOWER, H3_UPPER]],
      ["h3GetFaces", null, [H3_LOWER, H3_UPPER, POINTER]],
      ["h3ToParent", H3_LOWER, [H3_LOWER, H3_UPPER, RESOLUTION]],
      ["h3ToChildren", null, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
      ["h3ToCenterChild", H3_LOWER, [H3_LOWER, H3_UPPER, RESOLUTION]],
      ["maxH3ToChildrenSize", NUMBER, [H3_LOWER, H3_UPPER, RESOLUTION]],
      ["h3IndexesAreNeighbors", BOOLEAN, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
      ["getH3UnidirectionalEdge", H3_LOWER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
      ["getOriginH3IndexFromUnidirectionalEdge", H3_LOWER, [H3_LOWER, H3_UPPER]],
      ["getDestinationH3IndexFromUnidirectionalEdge", H3_LOWER, [H3_LOWER, H3_UPPER]],
      ["h3UnidirectionalEdgeIsValid", BOOLEAN, [H3_LOWER, H3_UPPER]],
      ["getH3IndexesFromUnidirectionalEdge", null, [H3_LOWER, H3_UPPER, POINTER]],
      ["getH3UnidirectionalEdgesFromHexagon", null, [H3_LOWER, H3_UPPER, POINTER]],
      ["getH3UnidirectionalEdgeBoundary", null, [H3_LOWER, H3_UPPER, POINTER]],
      ["h3Distance", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
      ["h3Line", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
      ["h3LineSize", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
      ["experimentalH3ToLocalIj", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
      ["experimentalLocalIjToH3", NUMBER, [H3_LOWER, H3_UPPER, POINTER, POINTER]],
      ["hexAreaM2", NUMBER, [RESOLUTION]],
      ["hexAreaKm2", NUMBER, [RESOLUTION]],
      ["edgeLengthM", NUMBER, [RESOLUTION]],
      ["edgeLengthKm", NUMBER, [RESOLUTION]],
      ["pointDistM", NUMBER, [POINTER, POINTER]],
      ["pointDistKm", NUMBER, [POINTER, POINTER]],
      ["pointDistRads", NUMBER, [POINTER, POINTER]],
      ["cellAreaM2", NUMBER, [H3_LOWER, H3_UPPER]],
      ["cellAreaKm2", NUMBER, [H3_LOWER, H3_UPPER]],
      ["cellAreaRads2", NUMBER, [H3_LOWER, H3_UPPER]],
      ["exactEdgeLengthM", NUMBER, [H3_LOWER, H3_UPPER]],
      ["exactEdgeLengthKm", NUMBER, [H3_LOWER, H3_UPPER]],
      ["exactEdgeLengthRads", NUMBER, [H3_LOWER, H3_UPPER]],
      ["numHexagons", NUMBER, [RESOLUTION]],
      ["getRes0Indexes", null, [POINTER]],
      ["res0IndexCount", NUMBER],
      ["getPentagonIndexes", null, [NUMBER, POINTER]],
      ["pentagonIndexCount", NUMBER]
    ];
    H3 = {};
    BINDINGS.forEach(function bind(def) {
      H3[def[0]] = libh3.cwrap.apply(libh3, def);
    });
    BASE_16 = 16;
    SZ_INT = 4;
    SZ_PTR = 4;
    SZ_DBL = 8;
    SZ_H3INDEX = H3.sizeOfH3Index();
    SZ_GEOCOORD = H3.sizeOfGeoCoord();
    SZ_GEOBOUNDARY = H3.sizeOfGeoBoundary();
    SZ_GEOPOLYGON = H3.sizeOfGeoPolygon();
    SZ_GEOFENCE = H3.sizeOfGeofence();
    SZ_LINKED_GEOPOLYGON = H3.sizeOfLinkedGeoPolygon();
    SZ_COORDIJ = H3.sizeOfCoordIJ();
    UNITS = {
      m: "m",
      m2: "m2",
      km: "km",
      km2: "km2",
      rads: "rads",
      rads2: "rads2"
    };
    INVALID_HEXIDECIMAL_CHAR = /[^0-9a-fA-F]/;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-hexagon-layer.js
function normalizeLongitudes(vertices, refLng) {
  refLng = refLng === void 0 ? vertices[0][0] : refLng;
  for (const pt of vertices) {
    const deltaLng = pt[0] - refLng;
    if (deltaLng > 180) {
      pt[0] -= 360;
    } else if (deltaLng < -180) {
      pt[0] += 360;
    }
  }
}
function scalePolygon(hexId, vertices, factor) {
  const [lat, lng] = h3ToGeo(hexId);
  const actualCount = vertices.length;
  normalizeLongitudes(vertices, lng);
  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
  for (let i3 = 0; i3 < vertexCount; i3++) {
    vertices[i3][0] = lerp(lng, vertices[i3][0], factor);
    vertices[i3][1] = lerp(lat, vertices[i3][1], factor);
  }
}
function getHexagonCentroid(getHexagon, object, objectInfo) {
  const hexagonId = getHexagon(object, objectInfo);
  const [lat, lng] = h3ToGeo(hexagonId);
  return [lng, lat];
}
function h3ToPolygon(hexId, coverage = 1) {
  const vertices = h3ToGeoBoundary(hexId, true);
  if (coverage !== 1) {
    scalePolygon(hexId, vertices, coverage);
  } else {
    normalizeLongitudes(vertices);
  }
  return vertices;
}
function flattenPolygon(vertices) {
  const positions = new Float64Array(vertices.length * 2);
  let i3 = 0;
  for (const pt of vertices) {
    positions[i3++] = pt[0];
    positions[i3++] = pt[1];
  }
  return positions;
}
function mergeTriggers(getHexagon, coverage) {
  let trigger;
  if (getHexagon === void 0 || getHexagon === null) {
    trigger = coverage;
  } else if (typeof getHexagon === "object") {
    trigger = {
      ...getHexagon,
      coverage
    };
  } else {
    trigger = {
      getHexagon,
      coverage
    };
  }
  return trigger;
}
var UPDATE_THRESHOLD_KM, defaultProps23, H3HexagonLayer;
var init_h3_hexagon_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-hexagon-layer.js"() {
    init_defineProperty();
    init_h3_js_es();
    init_esm8();
    init_esm13();
    init_esm15();
    UPDATE_THRESHOLD_KM = 10;
    defaultProps23 = {
      ...PolygonLayer.defaultProps,
      highPrecision: "auto",
      coverage: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
      },
      centerHexagon: null,
      getHexagon: {
        type: "accessor",
        value: (x2) => x2.hexagon
      },
      extruded: true
    };
    H3HexagonLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      initializeState() {
        H3HexagonLayer._checkH3Lib();
        this.state = {
          edgeLengthKM: 0,
          resolution: -1
        };
      }
      shouldUpdateState({
        changeFlags
      }) {
        return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
      }
      updateState({
        props,
        changeFlags
      }) {
        if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
          const dataProps = this._calculateH3DataProps();
          this.setState(dataProps);
        }
        this._updateVertices(this.context.viewport);
      }
      _calculateH3DataProps() {
        let resolution = -1;
        let hasPentagon = false;
        let hasMultipleRes = false;
        const {
          iterable,
          objectInfo
        } = createIterable(this.props.data);
        for (const object of iterable) {
          objectInfo.index++;
          const hexId = this.props.getHexagon(object, objectInfo);
          const hexResolution = h3GetResolution(hexId);
          if (resolution < 0) {
            resolution = hexResolution;
            if (!this.props.highPrecision)
              break;
          } else if (resolution !== hexResolution) {
            hasMultipleRes = true;
            break;
          }
          if (h3IsPentagon(hexId)) {
            hasPentagon = true;
            break;
          }
        }
        return {
          resolution,
          edgeLengthKM: resolution >= 0 ? edgeLength(resolution, "km") : 0,
          hasMultipleRes,
          hasPentagon
        };
      }
      _shouldUseHighPrecision() {
        if (this.props.highPrecision === "auto") {
          const {
            resolution,
            hasPentagon,
            hasMultipleRes
          } = this.state;
          const {
            viewport
          } = this.context;
          return Boolean(viewport === null || viewport === void 0 ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
        }
        return this.props.highPrecision;
      }
      _updateVertices(viewport) {
        if (this._shouldUseHighPrecision()) {
          return;
        }
        const {
          resolution,
          edgeLengthKM,
          centerHex
        } = this.state;
        if (resolution < 0) {
          return;
        }
        const hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);
        if (centerHex === hex) {
          return;
        }
        if (centerHex) {
          const distance = h3Distance(centerHex, hex);
          if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {
            return;
          }
        }
        const {
          unitsPerMeter
        } = viewport.distanceScales;
        let vertices = h3ToPolygon(hex);
        const [centerLat, centerLng] = h3ToGeo(hex);
        const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
        vertices = vertices.map((p2) => {
          const worldPosition = viewport.projectFlat(p2);
          return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];
        });
        this.setState({
          centerHex: hex,
          vertices
        });
      }
      renderLayers() {
        return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
      }
      _getForwardProps() {
        const {
          elevationScale,
          material,
          coverage,
          extruded,
          wireframe,
          stroked,
          filled,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          getFillColor,
          getElevation,
          getLineColor,
          getLineWidth,
          transitions,
          updateTriggers
        } = this.props;
        return {
          elevationScale,
          extruded,
          coverage,
          wireframe,
          stroked,
          filled,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          material,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth,
          transitions,
          updateTriggers: {
            getFillColor: updateTriggers.getFillColor,
            getElevation: updateTriggers.getElevation,
            getLineColor: updateTriggers.getLineColor,
            getLineWidth: updateTriggers.getLineWidth
          }
        };
      }
      _renderPolygonLayer() {
        const {
          data,
          getHexagon,
          updateTriggers,
          coverage
        } = this.props;
        const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", PolygonLayer);
        const forwardProps2 = this._getForwardProps();
        forwardProps2.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
        return new SubLayerClass(forwardProps2, this.getSubLayerProps({
          id: "hexagon-cell-hifi",
          updateTriggers: forwardProps2.updateTriggers
        }), {
          data,
          _normalize: false,
          _windingOrder: "CCW",
          positionFormat: "XY",
          getPolygon: (object, objectInfo) => {
            const hexagonId = getHexagon(object, objectInfo);
            return flattenPolygon(h3ToPolygon(hexagonId, coverage));
          }
        });
      }
      _renderColumnLayer() {
        const {
          data,
          getHexagon,
          updateTriggers
        } = this.props;
        const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
        const forwardProps2 = this._getForwardProps();
        forwardProps2.updateTriggers.getPosition = updateTriggers.getHexagon;
        return new SubLayerClass(forwardProps2, this.getSubLayerProps({
          id: "hexagon-cell",
          flatShading: true,
          updateTriggers: forwardProps2.updateTriggers
        }), {
          data,
          diskResolution: 6,
          radius: 1,
          vertices: this.state.vertices,
          getPosition: getHexagonCentroid.bind(null, getHexagon)
        });
      }
    };
    _defineProperty(H3HexagonLayer, "defaultProps", defaultProps23);
    _defineProperty(H3HexagonLayer, "layerName", "H3HexagonLayer");
    _defineProperty(H3HexagonLayer, "_checkH3Lib", () => {
    });
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-cluster-layer.js
var defaultProps24, H3ClusterLayer;
var init_h3_cluster_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-cluster-layer.js"() {
    init_defineProperty();
    init_h3_js_es();
    init_esm13();
    init_h3_hexagon_layer();
    init_GeoCellLayer();
    defaultProps24 = {
      getHexagons: {
        type: "accessor",
        value: (d) => d.hexagons
      }
    };
    H3ClusterLayer = class extends GeoCellLayer {
      initializeState() {
        H3HexagonLayer._checkH3Lib();
      }
      updateState({
        props,
        changeFlags
      }) {
        if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
          const {
            data,
            getHexagons
          } = props;
          const polygons = [];
          const {
            iterable,
            objectInfo
          } = createIterable(data);
          for (const object of iterable) {
            objectInfo.index++;
            const hexagons = getHexagons(object, objectInfo);
            const multiPolygon = h3SetToMultiPolygon(hexagons, true);
            for (const polygon of multiPolygon) {
              polygons.push(this.getSubLayerRow({
                polygon
              }, object, objectInfo.index));
            }
          }
          this.setState({
            polygons
          });
        }
      }
      indexToBounds() {
        const {
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        } = this.props;
        return {
          data: this.state.polygons,
          getPolygon: (d) => d.polygon,
          getElevation: this.getSubLayerAccessor(getElevation),
          getFillColor: this.getSubLayerAccessor(getFillColor),
          getLineColor: this.getSubLayerAccessor(getLineColor),
          getLineWidth: this.getSubLayerAccessor(getLineWidth)
        };
      }
    };
    _defineProperty(H3ClusterLayer, "layerName", "H3ClusterLayer");
    _defineProperty(H3ClusterLayer, "defaultProps", defaultProps24);
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/utils/matrix.js
function calculateTransformMatrix(targetMatrix, orientation, scale) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;
  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);
  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);
  const scx = scale[0];
  const scy = scale[1];
  const scz = scale[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}
function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
}
var RADIAN_PER_DEGREE, modelMatrix, valueArray, MATRIX_ATTRIBUTES;
var init_matrix = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/utils/matrix.js"() {
    init_esm13();
    RADIAN_PER_DEGREE = Math.PI / 180;
    modelMatrix = new Float32Array(16);
    valueArray = new Float32Array(12);
    MATRIX_ATTRIBUTES = {
      size: 12,
      accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
      shaderAttributes: {
        instanceModelMatrix__LOCATION_0: {
          size: 3,
          elementOffset: 0
        },
        instanceModelMatrix__LOCATION_1: {
          size: 3,
          elementOffset: 3
        },
        instanceModelMatrix__LOCATION_2: {
          size: 3,
          elementOffset: 6
        },
        instanceTranslation: {
          size: 3,
          elementOffset: 9
        }
      },
      update(attribute, {
        startRow,
        endRow
      }) {
        const {
          data,
          getOrientation,
          getScale: getScale2,
          getTranslation,
          getTransformMatrix
        } = this.props;
        const arrayMatrix = Array.isArray(getTransformMatrix);
        const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
        const constantScale = Array.isArray(getScale2);
        const constantOrientation = Array.isArray(getOrientation);
        const constantTranslation = Array.isArray(getTranslation);
        const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
        if (hasMatrix) {
          attribute.constant = constantMatrix;
        } else {
          attribute.constant = constantOrientation && constantScale && constantTranslation;
        }
        const instanceModelMatrixData = attribute.value;
        if (attribute.constant) {
          let matrix;
          if (hasMatrix) {
            modelMatrix.set(getTransformMatrix);
            matrix = getExtendedMat3FromMat4(modelMatrix);
          } else {
            matrix = valueArray;
            const orientation = getOrientation;
            const scale = getScale2;
            calculateTransformMatrix(matrix, orientation, scale);
            matrix.set(getTranslation, 9);
          }
          attribute.value = new Float32Array(matrix);
        } else {
          let i3 = startRow * attribute.size;
          const {
            iterable,
            objectInfo
          } = createIterable(data, startRow, endRow);
          for (const object of iterable) {
            objectInfo.index++;
            let matrix;
            if (hasMatrix) {
              modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
              matrix = getExtendedMat3FromMat4(modelMatrix);
            } else {
              matrix = valueArray;
              const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
              const scale = constantScale ? getScale2 : getScale2(object, objectInfo);
              calculateTransformMatrix(matrix, orientation, scale);
              matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
            }
            instanceModelMatrixData[i3++] = matrix[0];
            instanceModelMatrixData[i3++] = matrix[1];
            instanceModelMatrixData[i3++] = matrix[2];
            instanceModelMatrixData[i3++] = matrix[3];
            instanceModelMatrixData[i3++] = matrix[4];
            instanceModelMatrixData[i3++] = matrix[5];
            instanceModelMatrixData[i3++] = matrix[6];
            instanceModelMatrixData[i3++] = matrix[7];
            instanceModelMatrixData[i3++] = matrix[8];
            instanceModelMatrixData[i3++] = matrix[9];
            instanceModelMatrixData[i3++] = matrix[10];
            instanceModelMatrixData[i3++] = matrix[11];
          }
        }
      }
    };
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js
var simple_mesh_layer_vertex_glsl_default;
var init_simple_mesh_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js"() {
    simple_mesh_layer_vertex_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n\n  if (composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js
var simple_mesh_layer_fragment_glsl_default;
var init_simple_mesh_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js"() {
    simple_mesh_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n}\n";
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/base-table-batch-aggregator.js
var DEFAULT_ROW_COUNT, RowTableBatchAggregator;
var init_base_table_batch_aggregator = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/batches/base-table-batch-aggregator.js"() {
    init_defineProperty();
    DEFAULT_ROW_COUNT = 100;
    RowTableBatchAggregator = class {
      constructor(schema, options) {
        _defineProperty(this, "schema", void 0);
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "length", 0);
        _defineProperty(this, "rows", null);
        _defineProperty(this, "cursor", 0);
        _defineProperty(this, "_headers", []);
        this.options = options;
        this.schema = schema;
        if (!Array.isArray(schema)) {
          this._headers = [];
          for (const key in schema) {
            this._headers[schema[key].index] = schema[key].name;
          }
        }
      }
      rowCount() {
        return this.length;
      }
      addArrayRow(row, cursor) {
        if (Number.isFinite(cursor)) {
          this.cursor = cursor;
        }
        this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
        this.rows[this.length] = row;
        this.length++;
      }
      addObjectRow(row, cursor) {
        if (Number.isFinite(cursor)) {
          this.cursor = cursor;
        }
        this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
        this.rows[this.length] = row;
        this.length++;
      }
      getBatch() {
        let rows = this.rows;
        if (!rows) {
          return null;
        }
        rows = rows.slice(0, this.length);
        this.rows = null;
        const batch = {
          shape: this.options.shape,
          batchType: "data",
          data: rows,
          length: this.length,
          schema: this.schema,
          cursor: this.cursor
        };
        return batch;
      }
    };
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/utils/row-utils.js
function convertToObjectRow(arrayRow, headers) {
  if (!arrayRow) {
    throw new Error("null row");
  }
  if (!headers) {
    throw new Error("no headers");
  }
  const objectRow = {};
  for (let i3 = 0; i3 < headers.length; i3++) {
    objectRow[headers[i3]] = arrayRow[i3];
  }
  return objectRow;
}
function convertToArrayRow(objectRow, headers) {
  if (!objectRow) {
    throw new Error("null row");
  }
  if (!headers) {
    throw new Error("no headers");
  }
  const arrayRow = new Array(headers.length);
  for (let i3 = 0; i3 < headers.length; i3++) {
    arrayRow[i3] = objectRow[headers[i3]];
  }
  return arrayRow;
}
var init_row_utils = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/utils/row-utils.js"() {
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/row-table-batch-aggregator.js
var DEFAULT_ROW_COUNT2, RowTableBatchAggregator2;
var init_row_table_batch_aggregator = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/batches/row-table-batch-aggregator.js"() {
    init_defineProperty();
    init_row_utils();
    DEFAULT_ROW_COUNT2 = 100;
    RowTableBatchAggregator2 = class {
      constructor(schema, options) {
        _defineProperty(this, "schema", void 0);
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "length", 0);
        _defineProperty(this, "objectRows", null);
        _defineProperty(this, "arrayRows", null);
        _defineProperty(this, "cursor", 0);
        _defineProperty(this, "_headers", []);
        this.options = options;
        this.schema = schema;
        if (!Array.isArray(schema)) {
          this._headers = [];
          for (const key in schema) {
            this._headers[schema[key].index] = schema[key].name;
          }
        }
      }
      rowCount() {
        return this.length;
      }
      addArrayRow(row, cursor) {
        if (Number.isFinite(cursor)) {
          this.cursor = cursor;
        }
        switch (this.options.shape) {
          case "object-row-table":
            const rowObject = convertToObjectRow(row, this._headers);
            this.addObjectRow(rowObject, cursor);
            break;
          case "array-row-table":
            this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT2);
            this.arrayRows[this.length] = row;
            this.length++;
            break;
        }
      }
      addObjectRow(row, cursor) {
        if (Number.isFinite(cursor)) {
          this.cursor = cursor;
        }
        switch (this.options.shape) {
          case "array-row-table":
            const rowArray = convertToArrayRow(row, this._headers);
            this.addArrayRow(rowArray, cursor);
            break;
          case "object-row-table":
            this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT2);
            this.objectRows[this.length] = row;
            this.length++;
            break;
        }
      }
      getBatch() {
        let rows = this.arrayRows || this.objectRows;
        if (!rows) {
          return null;
        }
        rows = rows.slice(0, this.length);
        this.arrayRows = null;
        this.objectRows = null;
        return {
          shape: this.options.shape,
          batchType: "data",
          data: rows,
          length: this.length,
          schema: this.schema,
          cursor: this.cursor
        };
      }
    };
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/columnar-table-batch-aggregator.js
var DEFAULT_ROW_COUNT3, ColumnarTableBatchAggregator;
var init_columnar_table_batch_aggregator = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/batches/columnar-table-batch-aggregator.js"() {
    init_defineProperty();
    DEFAULT_ROW_COUNT3 = 100;
    ColumnarTableBatchAggregator = class {
      constructor(schema, options) {
        _defineProperty(this, "schema", void 0);
        _defineProperty(this, "length", 0);
        _defineProperty(this, "allocated", 0);
        _defineProperty(this, "columns", {});
        this.schema = schema;
        this._reallocateColumns();
      }
      rowCount() {
        return this.length;
      }
      addArrayRow(row) {
        this._reallocateColumns();
        let i3 = 0;
        for (const fieldName in this.columns) {
          this.columns[fieldName][this.length] = row[i3++];
        }
        this.length++;
      }
      addObjectRow(row) {
        this._reallocateColumns();
        for (const fieldName in row) {
          this.columns[fieldName][this.length] = row[fieldName];
        }
        this.length++;
      }
      getBatch() {
        this._pruneColumns();
        const columns = Array.isArray(this.schema) ? this.columns : {};
        if (!Array.isArray(this.schema)) {
          for (const fieldName in this.schema) {
            const field = this.schema[fieldName];
            columns[field.name] = this.columns[field.index];
          }
        }
        this.columns = {};
        const batch = {
          shape: "columnar-table",
          batchType: "data",
          data: columns,
          schema: this.schema,
          length: this.length
        };
        return batch;
      }
      _reallocateColumns() {
        if (this.length < this.allocated) {
          return;
        }
        this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT3;
        this.columns = {};
        for (const fieldName in this.schema) {
          const field = this.schema[fieldName];
          const ArrayType = field.type || Float32Array;
          const oldColumn = this.columns[field.index];
          if (oldColumn && ArrayBuffer.isView(oldColumn)) {
            const typedArray = new ArrayType(this.allocated);
            typedArray.set(oldColumn);
            this.columns[field.index] = typedArray;
          } else if (oldColumn) {
            oldColumn.length = this.allocated;
            this.columns[field.index] = oldColumn;
          } else {
            this.columns[field.index] = new ArrayType(this.allocated);
          }
        }
      }
      _pruneColumns() {
        for (const [columnName, column] of Object.entries(this.columns)) {
          this.columns[columnName] = column.slice(0, this.length);
        }
      }
    };
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/table-batch-builder.js
var DEFAULT_OPTIONS, ERR_MESSAGE, TableBatchBuilder;
var init_table_batch_builder = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/batches/table-batch-builder.js"() {
    init_defineProperty();
    init_base_table_batch_aggregator();
    init_row_table_batch_aggregator();
    init_columnar_table_batch_aggregator();
    DEFAULT_OPTIONS = {
      shape: "array-row-table",
      batchSize: "auto",
      batchDebounceMs: 0,
      limit: 0,
      _limitMB: 0
    };
    ERR_MESSAGE = "TableBatchBuilder";
    TableBatchBuilder = class {
      constructor(schema, options) {
        _defineProperty(this, "schema", void 0);
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "aggregator", null);
        _defineProperty(this, "batchCount", 0);
        _defineProperty(this, "bytesUsed", 0);
        _defineProperty(this, "isChunkComplete", false);
        _defineProperty(this, "lastBatchEmittedMs", Date.now());
        _defineProperty(this, "totalLength", 0);
        _defineProperty(this, "totalBytes", 0);
        _defineProperty(this, "rowBytes", 0);
        this.schema = schema;
        this.options = {
          ...DEFAULT_OPTIONS,
          ...options
        };
      }
      limitReached() {
        var _this$options, _this$options2;
        if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {
          return true;
        }
        if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
          return true;
        }
        return false;
      }
      addRow(row) {
        if (this.limitReached()) {
          return;
        }
        this.totalLength++;
        this.rowBytes = this.rowBytes || this._estimateRowMB(row);
        this.totalBytes += this.rowBytes;
        if (Array.isArray(row)) {
          this.addArrayRow(row);
        } else {
          this.addObjectRow(row);
        }
      }
      addArrayRow(row) {
        if (!this.aggregator) {
          const TableBatchType = this._getTableBatchType();
          this.aggregator = new TableBatchType(this.schema, this.options);
        }
        this.aggregator.addArrayRow(row);
      }
      addObjectRow(row) {
        if (!this.aggregator) {
          const TableBatchType = this._getTableBatchType();
          this.aggregator = new TableBatchType(this.schema, this.options);
        }
        this.aggregator.addObjectRow(row);
      }
      chunkComplete(chunk) {
        if (chunk instanceof ArrayBuffer) {
          this.bytesUsed += chunk.byteLength;
        }
        if (typeof chunk === "string") {
          this.bytesUsed += chunk.length;
        }
        this.isChunkComplete = true;
      }
      getFullBatch(options) {
        return this._isFull() ? this._getBatch(options) : null;
      }
      getFinalBatch(options) {
        return this._getBatch(options);
      }
      _estimateRowMB(row) {
        return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
      }
      _isFull() {
        if (!this.aggregator || this.aggregator.rowCount() === 0) {
          return false;
        }
        if (this.options.batchSize === "auto") {
          if (!this.isChunkComplete) {
            return false;
          }
        } else if (this.options.batchSize > this.aggregator.rowCount()) {
          return false;
        }
        if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
          return false;
        }
        this.isChunkComplete = false;
        this.lastBatchEmittedMs = Date.now();
        return true;
      }
      _getBatch(options) {
        if (!this.aggregator) {
          return null;
        }
        if (options !== null && options !== void 0 && options.bytesUsed) {
          this.bytesUsed = options.bytesUsed;
        }
        const normalizedBatch = this.aggregator.getBatch();
        normalizedBatch.count = this.batchCount;
        normalizedBatch.bytesUsed = this.bytesUsed;
        Object.assign(normalizedBatch, options);
        this.batchCount++;
        this.aggregator = null;
        return normalizedBatch;
      }
      _getTableBatchType() {
        switch (this.options.shape) {
          case "row-table":
            return RowTableBatchAggregator;
          case "array-row-table":
          case "object-row-table":
            return RowTableBatchAggregator2;
          case "columnar-table":
            return ColumnarTableBatchAggregator;
          case "arrow-table":
            if (!TableBatchBuilder.ArrowBatch) {
              throw new Error(ERR_MESSAGE);
            }
            return TableBatchBuilder.ArrowBatch;
          default:
            throw new Error(ERR_MESSAGE);
        }
      }
    };
    _defineProperty(TableBatchBuilder, "ArrowBatch", void 0);
  }
});

// node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js
function getMeshBoundingBox(attributes) {
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  const positions = attributes.POSITION ? attributes.POSITION.value : [];
  const len = positions && positions.length;
  for (let i3 = 0; i3 < len; i3 += 3) {
    const x2 = positions[i3];
    const y2 = positions[i3 + 1];
    const z = positions[i3 + 2];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }
  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}
var init_mesh_utils = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js"() {
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}
var init_assert = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js"() {
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js
function checkNames(fields) {
  const usedNames = {};
  for (const field of fields) {
    if (usedNames[field.name]) {
      console.warn("Schema: duplicated field name", field.name, field);
    }
    usedNames[field.name] = true;
  }
}
function mergeMaps(m1, m2) {
  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
}
var Schema;
var init_schema = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js"() {
    init_defineProperty();
    init_assert();
    Schema = class {
      constructor(fields, metadata) {
        _defineProperty(this, "fields", void 0);
        _defineProperty(this, "metadata", void 0);
        assert5(Array.isArray(fields));
        checkNames(fields);
        this.fields = fields;
        this.metadata = metadata || /* @__PURE__ */ new Map();
      }
      compareTo(other) {
        if (this.metadata !== other.metadata) {
          return false;
        }
        if (this.fields.length !== other.fields.length) {
          return false;
        }
        for (let i3 = 0; i3 < this.fields.length; ++i3) {
          if (!this.fields[i3].compareTo(other.fields[i3])) {
            return false;
          }
        }
        return true;
      }
      select() {
        const nameMap = /* @__PURE__ */ Object.create(null);
        for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
          columnNames[_key] = arguments[_key];
        }
        for (const name10 of columnNames) {
          nameMap[name10] = true;
        }
        const selectedFields = this.fields.filter((field) => nameMap[field.name]);
        return new Schema(selectedFields, this.metadata);
      }
      selectAt() {
        for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          columnIndices[_key2] = arguments[_key2];
        }
        const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);
        return new Schema(selectedFields, this.metadata);
      }
      assign(schemaOrFields) {
        let fields;
        let metadata = this.metadata;
        if (schemaOrFields instanceof Schema) {
          const otherSchema = schemaOrFields;
          fields = otherSchema.fields;
          metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), otherSchema.metadata);
        } else {
          fields = schemaOrFields;
        }
        const fieldMap = /* @__PURE__ */ Object.create(null);
        for (const field of this.fields) {
          fieldMap[field.name] = field;
        }
        for (const field of fields) {
          fieldMap[field.name] = field;
        }
        const mergedFields = Object.values(fieldMap);
        return new Schema(mergedFields, metadata);
      }
    };
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js
var Field;
var init_field = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js"() {
    init_defineProperty();
    Field = class {
      constructor(name10, type) {
        let nullable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        let metadata = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "nullable", void 0);
        _defineProperty(this, "metadata", void 0);
        this.name = name10;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata;
      }
      get typeId() {
        return this.type && this.type.typeId;
      }
      clone() {
        return new Field(this.name, this.type, this.nullable, this.metadata);
      }
      compareTo(other) {
        return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
      }
      toString() {
        return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
      }
    };
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js
var Type;
var init_enum = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js"() {
    (function(Type2) {
      Type2[Type2["NONE"] = 0] = "NONE";
      Type2[Type2["Null"] = 1] = "Null";
      Type2[Type2["Int"] = 2] = "Int";
      Type2[Type2["Float"] = 3] = "Float";
      Type2[Type2["Binary"] = 4] = "Binary";
      Type2[Type2["Utf8"] = 5] = "Utf8";
      Type2[Type2["Bool"] = 6] = "Bool";
      Type2[Type2["Decimal"] = 7] = "Decimal";
      Type2[Type2["Date"] = 8] = "Date";
      Type2[Type2["Time"] = 9] = "Time";
      Type2[Type2["Timestamp"] = 10] = "Timestamp";
      Type2[Type2["Interval"] = 11] = "Interval";
      Type2[Type2["List"] = 12] = "List";
      Type2[Type2["Struct"] = 13] = "Struct";
      Type2[Type2["Union"] = 14] = "Union";
      Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
      Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
      Type2[Type2["Map"] = 17] = "Map";
      Type2[Type2["Dictionary"] = -1] = "Dictionary";
      Type2[Type2["Int8"] = -2] = "Int8";
      Type2[Type2["Int16"] = -3] = "Int16";
      Type2[Type2["Int32"] = -4] = "Int32";
      Type2[Type2["Int64"] = -5] = "Int64";
      Type2[Type2["Uint8"] = -6] = "Uint8";
      Type2[Type2["Uint16"] = -7] = "Uint16";
      Type2[Type2["Uint32"] = -8] = "Uint32";
      Type2[Type2["Uint64"] = -9] = "Uint64";
      Type2[Type2["Float16"] = -10] = "Float16";
      Type2[Type2["Float32"] = -11] = "Float32";
      Type2[Type2["Float64"] = -12] = "Float64";
      Type2[Type2["DateDay"] = -13] = "DateDay";
      Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
      Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
      Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
      Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
      Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
      Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
      Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
      Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
      Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
      Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
      Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
      Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
      Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    })(Type || (Type = {}));
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js
var _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag3, _Symbol$toStringTag4, _Symbol$toStringTag5, _Symbol$toStringTag6, _Symbol$toStringTag7, _Symbol$toStringTag8, DataType, Null, Bool, Int, Int8, Int16, Int32, Uint8, Uint16, Uint32, Precision, Float, Float32, Float64, Binary, Utf8, DateUnit, Date2, TimeUnit, Time, Timestamp, IntervalUnit, Interval, FixedSizeList, Struct;
var init_type = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js"() {
    init_defineProperty();
    init_enum();
    init_enum();
    DataType = class {
      static isNull(x2) {
        return x2 && x2.typeId === Type.Null;
      }
      static isInt(x2) {
        return x2 && x2.typeId === Type.Int;
      }
      static isFloat(x2) {
        return x2 && x2.typeId === Type.Float;
      }
      static isBinary(x2) {
        return x2 && x2.typeId === Type.Binary;
      }
      static isUtf8(x2) {
        return x2 && x2.typeId === Type.Utf8;
      }
      static isBool(x2) {
        return x2 && x2.typeId === Type.Bool;
      }
      static isDecimal(x2) {
        return x2 && x2.typeId === Type.Decimal;
      }
      static isDate(x2) {
        return x2 && x2.typeId === Type.Date;
      }
      static isTime(x2) {
        return x2 && x2.typeId === Type.Time;
      }
      static isTimestamp(x2) {
        return x2 && x2.typeId === Type.Timestamp;
      }
      static isInterval(x2) {
        return x2 && x2.typeId === Type.Interval;
      }
      static isList(x2) {
        return x2 && x2.typeId === Type.List;
      }
      static isStruct(x2) {
        return x2 && x2.typeId === Type.Struct;
      }
      static isUnion(x2) {
        return x2 && x2.typeId === Type.Union;
      }
      static isFixedSizeBinary(x2) {
        return x2 && x2.typeId === Type.FixedSizeBinary;
      }
      static isFixedSizeList(x2) {
        return x2 && x2.typeId === Type.FixedSizeList;
      }
      static isMap(x2) {
        return x2 && x2.typeId === Type.Map;
      }
      static isDictionary(x2) {
        return x2 && x2.typeId === Type.Dictionary;
      }
      get typeId() {
        return Type.NONE;
      }
      compareTo(other) {
        return this === other;
      }
    };
    Null = class extends DataType {
      get typeId() {
        return Type.Null;
      }
      get [Symbol.toStringTag]() {
        return "Null";
      }
      toString() {
        return "Null";
      }
    };
    Bool = class extends DataType {
      get typeId() {
        return Type.Bool;
      }
      get [Symbol.toStringTag]() {
        return "Bool";
      }
      toString() {
        return "Bool";
      }
    };
    _Symbol$toStringTag = Symbol.toStringTag;
    Int = class extends DataType {
      constructor(isSigned, bitWidth) {
        super();
        _defineProperty(this, "isSigned", void 0);
        _defineProperty(this, "bitWidth", void 0);
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
      }
      get typeId() {
        return Type.Int;
      }
      get [_Symbol$toStringTag]() {
        return "Int";
      }
      toString() {
        return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
      }
    };
    Int8 = class extends Int {
      constructor() {
        super(true, 8);
      }
    };
    Int16 = class extends Int {
      constructor() {
        super(true, 16);
      }
    };
    Int32 = class extends Int {
      constructor() {
        super(true, 32);
      }
    };
    Uint8 = class extends Int {
      constructor() {
        super(false, 8);
      }
    };
    Uint16 = class extends Int {
      constructor() {
        super(false, 16);
      }
    };
    Uint32 = class extends Int {
      constructor() {
        super(false, 32);
      }
    };
    Precision = {
      HALF: 16,
      SINGLE: 32,
      DOUBLE: 64
    };
    _Symbol$toStringTag2 = Symbol.toStringTag;
    Float = class extends DataType {
      constructor(precision) {
        super();
        _defineProperty(this, "precision", void 0);
        this.precision = precision;
      }
      get typeId() {
        return Type.Float;
      }
      get [_Symbol$toStringTag2]() {
        return "Float";
      }
      toString() {
        return "Float".concat(this.precision);
      }
    };
    Float32 = class extends Float {
      constructor() {
        super(Precision.SINGLE);
      }
    };
    Float64 = class extends Float {
      constructor() {
        super(Precision.DOUBLE);
      }
    };
    Binary = class extends DataType {
      constructor() {
        super();
      }
      get typeId() {
        return Type.Binary;
      }
      toString() {
        return "Binary";
      }
      get [Symbol.toStringTag]() {
        return "Binary";
      }
    };
    Utf8 = class extends DataType {
      get typeId() {
        return Type.Utf8;
      }
      get [Symbol.toStringTag]() {
        return "Utf8";
      }
      toString() {
        return "Utf8";
      }
    };
    DateUnit = {
      DAY: 0,
      MILLISECOND: 1
    };
    _Symbol$toStringTag3 = Symbol.toStringTag;
    Date2 = class extends DataType {
      constructor(unit) {
        super();
        _defineProperty(this, "unit", void 0);
        this.unit = unit;
      }
      get typeId() {
        return Type.Date;
      }
      get [_Symbol$toStringTag3]() {
        return "Date";
      }
      toString() {
        return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
      }
    };
    TimeUnit = {
      SECOND: 1,
      MILLISECOND: 1e3,
      MICROSECOND: 1e6,
      NANOSECOND: 1e9
    };
    _Symbol$toStringTag4 = Symbol.toStringTag;
    Time = class extends DataType {
      constructor(unit, bitWidth) {
        super();
        _defineProperty(this, "unit", void 0);
        _defineProperty(this, "bitWidth", void 0);
        this.unit = unit;
        this.bitWidth = bitWidth;
      }
      get typeId() {
        return Type.Time;
      }
      toString() {
        return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
      }
      get [_Symbol$toStringTag4]() {
        return "Time";
      }
    };
    _Symbol$toStringTag5 = Symbol.toStringTag;
    Timestamp = class extends DataType {
      constructor(unit) {
        let timezone = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        super();
        _defineProperty(this, "unit", void 0);
        _defineProperty(this, "timezone", void 0);
        this.unit = unit;
        this.timezone = timezone;
      }
      get typeId() {
        return Type.Timestamp;
      }
      get [_Symbol$toStringTag5]() {
        return "Timestamp";
      }
      toString() {
        return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : "", ">");
      }
    };
    IntervalUnit = {
      DAY_TIME: 0,
      YEAR_MONTH: 1
    };
    _Symbol$toStringTag6 = Symbol.toStringTag;
    Interval = class extends DataType {
      constructor(unit) {
        super();
        _defineProperty(this, "unit", void 0);
        this.unit = unit;
      }
      get typeId() {
        return Type.Interval;
      }
      get [_Symbol$toStringTag6]() {
        return "Interval";
      }
      toString() {
        return "Interval<".concat(IntervalUnit[this.unit], ">");
      }
    };
    _Symbol$toStringTag7 = Symbol.toStringTag;
    FixedSizeList = class extends DataType {
      constructor(listSize, child) {
        super();
        _defineProperty(this, "listSize", void 0);
        _defineProperty(this, "children", void 0);
        this.listSize = listSize;
        this.children = [child];
      }
      get typeId() {
        return Type.FixedSizeList;
      }
      get valueType() {
        return this.children[0].type;
      }
      get valueField() {
        return this.children[0];
      }
      get [_Symbol$toStringTag7]() {
        return "FixedSizeList";
      }
      toString() {
        return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
      }
    };
    _Symbol$toStringTag8 = Symbol.toStringTag;
    Struct = class extends DataType {
      constructor(children) {
        super();
        _defineProperty(this, "children", void 0);
        this.children = children;
      }
      get typeId() {
        return Type.Struct;
      }
      toString() {
        return "Struct<{".concat(this.children.map((f2) => "".concat(f2.name, ":").concat(f2.type)).join(", "), "}>");
      }
      get [_Symbol$toStringTag8]() {
        return "Struct";
      }
    };
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/schema.js
var init_schema2 = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/schema/schema.js"() {
    init_schema();
    init_field();
    init_type();
    init_type();
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/arrow/arrow-like-type-utils.js
function getArrowTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return new Int8();
    case Uint8Array:
      return new Uint8();
    case Int16Array:
      return new Int16();
    case Uint16Array:
      return new Uint16();
    case Int32Array:
      return new Int32();
    case Uint32Array:
      return new Uint32();
    case Float32Array:
      return new Float32();
    case Float64Array:
      return new Float64();
    default:
      throw new Error("array type not supported");
  }
}
var init_arrow_like_type_utils = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/arrow/arrow-like-type-utils.js"() {
    init_schema2();
  }
});

// node_modules/@loaders.gl/schema/dist/esm/category/mesh/deduce-mesh-schema.js
function deduceMeshField(attributeName, attribute, optionalMetadata) {
  const type = getArrowTypeFromTypedArray(attribute.value);
  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
  const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field("value", type)), false, metadata);
  return field;
}
function makeMeshAttributeMetadata(attribute) {
  const result = /* @__PURE__ */ new Map();
  if ("byteOffset" in attribute) {
    result.set("byteOffset", attribute.byteOffset.toString(10));
  }
  if ("byteStride" in attribute) {
    result.set("byteStride", attribute.byteStride.toString(10));
  }
  if ("normalized" in attribute) {
    result.set("normalized", attribute.normalized.toString());
  }
  return result;
}
var init_deduce_mesh_schema = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/category/mesh/deduce-mesh-schema.js"() {
    init_schema2();
    init_arrow_like_type_utils();
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/deduce-column-type.js
var init_deduce_column_type = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/schema-utils/deduce-column-type.js"() {
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/arrow/get-type-info.js
var init_get_type_info = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/arrow/get-type-info.js"() {
    init_schema2();
  }
});

// node_modules/@loaders.gl/schema/dist/esm/lib/utils/async-queue.js
var _Symbol$asyncIterator, ArrayQueue, AsyncQueue;
var init_async_queue = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/lib/utils/async-queue.js"() {
    init_defineProperty();
    ArrayQueue = class extends Array {
      enqueue(value) {
        return this.push(value);
      }
      dequeue() {
        return this.shift();
      }
    };
    _Symbol$asyncIterator = Symbol.asyncIterator;
    AsyncQueue = class {
      constructor() {
        _defineProperty(this, "_values", void 0);
        _defineProperty(this, "_settlers", void 0);
        _defineProperty(this, "_closed", void 0);
        this._values = new ArrayQueue();
        this._settlers = new ArrayQueue();
        this._closed = false;
      }
      close() {
        while (this._settlers.length > 0) {
          this._settlers.dequeue().resolve({
            done: true
          });
        }
        this._closed = true;
      }
      [_Symbol$asyncIterator]() {
        return this;
      }
      enqueue(value) {
        if (this._closed) {
          throw new Error("Closed");
        }
        if (this._settlers.length > 0) {
          if (this._values.length > 0) {
            throw new Error("Illegal internal state");
          }
          const settler = this._settlers.dequeue();
          if (value instanceof Error) {
            settler.reject(value);
          } else {
            settler.resolve({
              value
            });
          }
        } else {
          this._values.enqueue(value);
        }
      }
      next() {
        if (this._values.length > 0) {
          const value = this._values.dequeue();
          if (value instanceof Error) {
            return Promise.reject(value);
          }
          return Promise.resolve({
            value
          });
        }
        if (this._closed) {
          if (this._settlers.length > 0) {
            throw new Error("Illegal internal state");
          }
          return Promise.resolve({
            done: true
          });
        }
        return new Promise((resolve, reject) => {
          this._settlers.enqueue({
            resolve,
            reject
          });
        });
      }
    };
  }
});

// node_modules/@loaders.gl/schema/dist/esm/index.js
var init_esm19 = __esm({
  "node_modules/@loaders.gl/schema/dist/esm/index.js"() {
    init_table_batch_builder();
    init_row_table_batch_aggregator();
    init_columnar_table_batch_aggregator();
    init_row_utils();
    init_mesh_utils();
    init_deduce_mesh_schema();
    init_schema2();
    init_deduce_column_type();
    init_get_type_info();
    init_arrow_like_type_utils();
    init_async_queue();
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer.js
function validateGeometryAttributes(attributes, useMeshColors) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  const useColorAttribute = hasColorAttribute && useMeshColors;
  if (!useColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }
  log_default.assert(attributes.positions || attributes.POSITION, 'no "postions" or "POSITION" attribute in mesh');
}
function getGeometry(data, useMeshColors) {
  if (data.attributes) {
    validateGeometryAttributes(data.attributes, useMeshColors);
    if (data instanceof Geometry) {
      return data;
    } else {
      return new Geometry(data);
    }
  } else if (data.positions || data.POSITION) {
    validateGeometryAttributes(data, useMeshColors);
    return new Geometry({
      attributes: data
    });
  }
  throw Error("Invalid mesh");
}
var DEFAULT_COLOR10, defaultProps25, SimpleMeshLayer;
var init_simple_mesh_layer = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_esm7();
    init_matrix();
    init_simple_mesh_layer_vertex_glsl();
    init_simple_mesh_layer_fragment_glsl();
    init_esm19();
    DEFAULT_COLOR10 = [0, 0, 0, 255];
    defaultProps25 = {
      mesh: {
        type: "object",
        value: null,
        async: true
      },
      texture: {
        type: "image",
        value: null,
        async: true
      },
      sizeScale: {
        type: "number",
        value: 1,
        min: 0
      },
      _useMeshColors: {
        type: "boolean",
        value: false
      },
      _instanced: true,
      wireframe: false,
      material: true,
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR10
      },
      getOrientation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getScale: {
        type: "accessor",
        value: [1, 1, 1]
      },
      getTranslation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getTransformMatrix: {
        type: "accessor",
        value: []
      },
      textureParameters: {
        type: "object",
        ignore: true
      }
    };
    SimpleMeshLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        const transpileToGLSL100 = !isWebGL2(this.context.gl);
        const defines = {};
        if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {
          defines.DERIVATIVES_AVAILABLE = 1;
        }
        return super.getShaders({
          vs: simple_mesh_layer_vertex_glsl_default,
          fs: simple_mesh_layer_fragment_glsl_default,
          modules: [project32_default, phongLighting, picking_default],
          transpileToGLSL100,
          defines
        });
      }
      getBounds() {
        var _mesh$header;
        if (this.props._instanced) {
          return super.getBounds();
        }
        let result = this.state.positionBounds;
        if (result) {
          return result;
        }
        const {
          mesh
        } = this.props;
        if (!mesh) {
          return null;
        }
        result = (_mesh$header = mesh.header) === null || _mesh$header === void 0 ? void 0 : _mesh$header.boundingBox;
        if (!result) {
          const {
            attributes
          } = getGeometry(mesh, this.props._useMeshColors);
          attributes.POSITION = attributes.POSITION || attributes.positions;
          result = getMeshBoundingBox(attributes);
        }
        this.state.positionBounds = result;
        return result;
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instancePositions: {
            transition: true,
            type: 5130,
            fp64: this.use64bitPositions(),
            size: 3,
            accessor: "getPosition"
          },
          instanceColors: {
            type: 5121,
            transition: true,
            size: this.props.colorFormat.length,
            normalized: true,
            accessor: "getColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceModelMatrix: MATRIX_ATTRIBUTES
        });
        this.setState({
          emptyTexture: new Texture2D(this.context.gl, {
            data: new Uint8Array(4),
            width: 1,
            height: 1
          })
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps,
          changeFlags
        } = params;
        if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
          var _this$state$model;
          this.state.positionBounds = null;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          if (props.mesh) {
            this.state.model = this.getModel(props.mesh);
            const attributes = props.mesh.attributes || props.mesh;
            this.setState({
              hasNormals: Boolean(attributes.NORMAL || attributes.normals)
            });
          }
          this.getAttributeManager().invalidateAll();
        }
        if (props.texture !== oldProps.texture) {
          this.setTexture(props.texture);
        }
        if (this.state.model) {
          this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
        }
      }
      finalizeState(context) {
        super.finalizeState(context);
        this.state.emptyTexture.delete();
      }
      draw({
        uniforms
      }) {
        if (!this.state.model) {
          return;
        }
        const {
          viewport
        } = this.context;
        const {
          sizeScale,
          coordinateSystem,
          _instanced
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          sizeScale,
          composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
          flatShading: !this.state.hasNormals
        }).draw();
      }
      getModel(mesh) {
        const model = new Model(this.context.gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: getGeometry(mesh, this.props._useMeshColors),
          isInstanced: true
        });
        const {
          texture
        } = this.props;
        const {
          emptyTexture
        } = this.state;
        model.setUniforms({
          sampler: texture || emptyTexture,
          hasTexture: Boolean(texture)
        });
        return model;
      }
      setTexture(texture) {
        const {
          emptyTexture,
          model
        } = this.state;
        if (model) {
          model.setUniforms({
            sampler: texture || emptyTexture,
            hasTexture: Boolean(texture)
          });
        }
      }
    };
    _defineProperty(SimpleMeshLayer, "defaultProps", defaultProps25);
    _defineProperty(SimpleMeshLayer, "layerName", "SimpleMeshLayer");
  }
});

// node_modules/@luma.gl/experimental/dist/esm/webvr/display.js
var init_display = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/webvr/display.js"() {
    init_esm6();
  }
});

// node_modules/@luma.gl/experimental/dist/esm/webvr/vr-button.js
var init_vr_button = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/webvr/vr-button.js"() {
  }
});

// node_modules/@luma.gl/experimental/dist/esm/webvr/vr-display.js
var init_vr_display = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/webvr/vr-display.js"() {
    init_esm7();
    init_display();
    init_vr_button();
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-environment.js
var init_gltf_environment = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-environment.js"() {
    init_esm7();
    init_esm5();
  }
});

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js
var ScenegraphNode;
var init_scenegraph_node = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js"() {
    init_esm8();
    init_esm7();
    ScenegraphNode = class {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id
        } = props;
        this.id = id || uid(this.constructor.name);
        this.display = true;
        this.position = new Vector3();
        this.rotation = new Vector3();
        this.scale = new Vector3(1, 1, 1);
        this.matrix = new Matrix4();
        this.userData = {};
        this.props = {};
        this._setScenegraphNodeProps(props);
      }
      delete() {
      }
      setProps(props) {
        this._setScenegraphNodeProps(props);
        return this;
      }
      toString() {
        return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
      }
      getBounds() {
        return null;
      }
      setPosition(position) {
        assert3(position.length === 3, "setPosition requires vector argument");
        this.position = position;
        return this;
      }
      setRotation(rotation) {
        assert3(rotation.length === 3, "setRotation requires vector argument");
        this.rotation = rotation;
        return this;
      }
      setScale(scale) {
        assert3(scale.length === 3, "setScale requires vector argument");
        this.scale = scale;
        return this;
      }
      setMatrix(matrix) {
        let copyMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (copyMatrix) {
          this.matrix.copy(matrix);
        } else {
          this.matrix = matrix;
        }
      }
      setMatrixComponents(_ref) {
        let {
          position,
          rotation,
          scale,
          update = true
        } = _ref;
        if (position) {
          this.setPosition(position);
        }
        if (rotation) {
          this.setRotation(rotation);
        }
        if (scale) {
          this.setScale(scale);
        }
        if (update) {
          this.updateMatrix();
        }
        return this;
      }
      updateMatrix() {
        const pos = this.position;
        const rot = this.rotation;
        const scale = this.scale;
        this.matrix.identity();
        this.matrix.translate(pos);
        this.matrix.rotateXYZ(rot);
        this.matrix.scale(scale);
        return this;
      }
      update() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          position,
          rotation,
          scale
        } = options;
        if (position) {
          this.setPosition(position);
        }
        if (rotation) {
          this.setRotation(rotation);
        }
        if (scale) {
          this.setScale(scale);
        }
        this.updateMatrix();
        return this;
      }
      getCoordinateUniforms(viewMatrix, modelMatrix2) {
        assert3(viewMatrix);
        modelMatrix2 = modelMatrix2 || this.matrix;
        const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix2);
        const worldInverse = worldMatrix.invert();
        const worldInverseTranspose = worldInverse.transpose();
        return {
          viewMatrix,
          modelMatrix: modelMatrix2,
          objectMatrix: modelMatrix2,
          worldMatrix,
          worldInverseMatrix: worldInverse,
          worldInverseTransposeMatrix: worldInverseTranspose
        };
      }
      _setScenegraphNodeProps(props) {
        if ("display" in props) {
          this.display = props.display;
        }
        if ("position" in props) {
          this.setPosition(props.position);
        }
        if ("rotation" in props) {
          this.setRotation(props.rotation);
        }
        if ("scale" in props) {
          this.setScale(props.scale);
        }
        if ("matrix" in props) {
          this.setMatrix(props.matrix);
        }
        Object.assign(this.props, props);
      }
    };
  }
});

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js
var GroupNode;
var init_group_node = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js"() {
    init_esm8();
    init_esm7();
    init_scenegraph_node();
    GroupNode = class extends ScenegraphNode {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        props = Array.isArray(props) ? {
          children: props
        } : props;
        const {
          children = []
        } = props;
        log.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
        super(props);
        this.children = children;
      }
      add() {
        for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
          children[_key] = arguments[_key];
        }
        for (const child of children) {
          if (Array.isArray(child)) {
            this.add(...child);
          } else {
            this.children.push(child);
          }
        }
        return this;
      }
      remove(child) {
        const children = this.children;
        const indexOf = children.indexOf(child);
        if (indexOf > -1) {
          children.splice(indexOf, 1);
        }
        return this;
      }
      removeAll() {
        this.children = [];
        return this;
      }
      delete() {
        this.children.forEach((child) => child.delete());
        this.removeAll();
        super.delete();
      }
      getBounds() {
        const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
        this.traverse((node, _ref) => {
          let {
            worldMatrix
          } = _ref;
          const bounds = node.getBounds();
          if (!bounds) {
            return;
          }
          const [min, max] = bounds;
          const center = new Vector3(min).add(max).divide([2, 2, 2]);
          worldMatrix.transformAsPoint(center, center);
          const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);
          worldMatrix.transformAsVector(halfSize, halfSize);
          for (let v = 0; v < 8; v++) {
            const position = new Vector3(v & 1 ? -1 : 1, v & 2 ? -1 : 1, v & 4 ? -1 : 1).multiply(halfSize).add(center);
            for (let i3 = 0; i3 < 3; i3++) {
              result[0][i3] = Math.min(result[0][i3], position[i3]);
              result[1][i3] = Math.max(result[1][i3], position[i3]);
            }
          }
        });
        if (!Number.isFinite(result[0][0])) {
          return null;
        }
        return result;
      }
      traverse(visitor) {
        let {
          worldMatrix = new Matrix4()
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const modelMatrix2 = new Matrix4(worldMatrix).multiplyRight(this.matrix);
        for (const child of this.children) {
          if (child instanceof GroupNode) {
            child.traverse(visitor, {
              worldMatrix: modelMatrix2
            });
          } else {
            visitor(child, {
              worldMatrix: modelMatrix2
            });
          }
        }
      }
    };
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js
function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
    const length3 = components * accessor.count;
    const {
      buffer,
      byteOffset
    } = accessor.bufferView.data;
    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length3);
    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      const slicedArray = [];
      for (let i3 = 0; i3 < array.length; i3 += components) {
        slicedArray.push(Array.from(array.slice(i3, i3 + components)));
      }
      accessor._animation = slicedArray;
    }
  }
  return accessor._animation;
}
function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();
  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }
  if (gltfNode.rotation) {
    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }
  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}
function linearInterpolate(target, path, start, stop, ratio) {
  if (path === "rotation") {
    quaternion.slerp({
      start,
      target: stop,
      ratio
    });
    for (let i3 = 0; i3 < quaternion.length; i3++) {
      target[path][i3] = quaternion[i3];
    }
  } else {
    for (let i3 = 0; i3 < start.length; i3++) {
      target[path][i3] = ratio * stop[i3] + (1 - ratio) * start[i3];
    }
  }
}
function cubicsplineInterpolate(target, path, _ref) {
  let {
    p0,
    outTangent0,
    inTangent1,
    p1,
    tDiff,
    ratio: t2
  } = _ref;
  for (let i3 = 0; i3 < target[path].length; i3++) {
    const m0 = outTangent0[i3] * tDiff;
    const m1 = inTangent1[i3] * tDiff;
    target[path][i3] = (2 * Math.pow(t2, 3) - 3 * Math.pow(t2, 2) + 1) * p0[i3] + (Math.pow(t2, 3) - 2 * Math.pow(t2, 2) + t2) * m0 + (-2 * Math.pow(t2, 3) + 3 * Math.pow(t2, 2)) * p1[i3] + (Math.pow(t2, 3) - Math.pow(t2, 2)) * m1;
  }
}
function stepInterpolate(target, path, value) {
  for (let i3 = 0; i3 < value.length; i3++) {
    target[path][i3] = value[i3];
  }
}
function interpolate(time, _ref2, target, path) {
  let {
    input,
    interpolation,
    output
  } = _ref2;
  const maxTime = input[input.length - 1];
  const animationTime = time % maxTime;
  const nextIndex = input.findIndex((t2) => t2 >= animationTime);
  const previousIndex = Math.max(0, nextIndex - 1);
  if (!Array.isArray(target[path])) {
    switch (path) {
      case "translation":
        target[path] = [0, 0, 0];
        break;
      case "rotation":
        target[path] = [0, 0, 0, 1];
        break;
      case "scale":
        target[path] = [1, 1, 1];
        break;
      default:
        log.warn("Bad animation path ".concat(path))();
    }
  }
  assert3(target[path].length === output[previousIndex].length);
  const previousTime = input[previousIndex];
  const nextTime = input[nextIndex];
  switch (interpolation) {
    case "STEP":
      stepInterpolate(target, path, output[previousIndex]);
      break;
    case "LINEAR":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }
      break;
    case "CUBICSPLINE":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        const tDiff = nextTime - previousTime;
        const p0 = output[3 * previousIndex + 1];
        const outTangent0 = output[3 * previousIndex + 2];
        const inTangent1 = output[3 * nextIndex + 0];
        const p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, {
          p0,
          outTangent0,
          inTangent1,
          p1,
          tDiff,
          ratio
        });
      }
      break;
    default:
      log.warn("Interpolation ".concat(interpolation, " not supported"))();
      break;
  }
}
var ATTRIBUTE_TYPE_TO_COMPONENTS, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY, helperMatrix, quaternion, GLTFAnimation, GLTFAnimator;
var init_gltf_animator = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js"() {
    init_esm7();
    init_esm8();
    ATTRIBUTE_TYPE_TO_COMPONENTS = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    };
    ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    };
    helperMatrix = new Matrix4();
    quaternion = new Quaternion();
    GLTFAnimation = class {
      constructor(props) {
        this.startTime = 0;
        this.playing = true;
        this.speed = 1;
        this.channels = [];
        Object.assign(this, props);
      }
      animate(timeMs) {
        if (!this.playing) {
          return;
        }
        const absTime = timeMs / 1e3;
        const time = (absTime - this.startTime) * this.speed;
        this.channels.forEach((_ref3) => {
          let {
            sampler,
            target,
            path
          } = _ref3;
          interpolate(time, sampler, target, path);
          applyTranslationRotationScale(target, target._node);
        });
      }
    };
    GLTFAnimator = class {
      constructor(gltf) {
        this.animations = gltf.animations.map((animation, index) => {
          const name10 = animation.name || "Animation-".concat(index);
          const samplers = animation.samplers.map((_ref4) => {
            let {
              input,
              interpolation = "LINEAR",
              output
            } = _ref4;
            return {
              input: accessorToJsArray(gltf.accessors[input]),
              interpolation,
              output: accessorToJsArray(gltf.accessors[output])
            };
          });
          const channels = animation.channels.map((_ref5) => {
            let {
              sampler,
              target
            } = _ref5;
            return {
              sampler: samplers[sampler],
              target: gltf.nodes[target.node],
              path: target.path
            };
          });
          return new GLTFAnimation({
            name: name10,
            channels
          });
        });
      }
      animate(time) {
        this.setTime(time);
      }
      setTime(time) {
        this.animations.forEach((animation) => animation.animate(time));
      }
      getAnimations() {
        return this.animations;
      }
    };
  }
});

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js
var ModelNode;
var init_model_node = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js"() {
    init_esm10();
    init_scenegraph_node();
    ModelNode = class extends ScenegraphNode {
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(props);
        this.onBeforeRender = null;
        this.AfterRender = null;
        if (gl instanceof Model) {
          this.model = gl;
          this._setModelNodeProps(props);
        } else {
          this.model = new Model(gl, props);
        }
        this.bounds = null;
        this.managedResources = props.managedResources || [];
      }
      setProps(props) {
        super.setProps(props);
        this._setModelNodeProps(props);
        return this;
      }
      getBounds() {
        return this.bounds;
      }
      delete() {
        if (this.model) {
          this.model.delete();
          this.model = null;
        }
        this.managedResources.forEach((resource) => resource.delete());
        this.managedResources = [];
      }
      draw() {
        return this.model.draw(...arguments);
      }
      setUniforms() {
        this.model.setUniforms(...arguments);
        return this;
      }
      setAttributes() {
        this.model.setAttributes(...arguments);
        return this;
      }
      updateModuleSettings() {
        this.model.updateModuleSettings(...arguments);
        return this;
      }
      _setModelNodeProps(props) {
        this.model.setProps(props);
      }
    };
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js
var GLTFMaterialParser;
var init_gltf_material_parser = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js"() {
    init_esm7();
    GLTFMaterialParser = class {
      constructor(gl, _ref) {
        let {
          attributes,
          material,
          pbrDebug,
          imageBasedLightingEnvironment,
          lights,
          useTangents
        } = _ref;
        this.gl = gl;
        this.defines = {
          MANUAL_SRGB: 1,
          SRGB_FAST_APPROXIMATION: 1
        };
        if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {
          this.defines.USE_TEX_LOD = 1;
        }
        this.uniforms = {
          u_Camera: [0, 0, 0],
          u_MetallicRoughnessValues: [1, 1]
        };
        this.parameters = {};
        this.generatedTextures = [];
        if (imageBasedLightingEnvironment) {
          this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
          this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
          this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
          this.uniforms.u_ScaleIBLAmbient = [1, 1];
        }
        if (pbrDebug) {
          this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
          this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
        }
        this.defineIfPresent(attributes.NORMAL, "HAS_NORMALS");
        this.defineIfPresent(attributes.TANGENT && useTangents, "HAS_TANGENTS");
        this.defineIfPresent(attributes.TEXCOORD_0, "HAS_UV");
        this.defineIfPresent(imageBasedLightingEnvironment, "USE_IBL");
        this.defineIfPresent(lights, "USE_LIGHTS");
        this.defineIfPresent(pbrDebug, "PBR_DEBUG");
        if (material) {
          this.parseMaterial(material);
        }
      }
      defineIfPresent(value, name10) {
        if (value) {
          this.defines[name10] = 1;
        }
      }
      parseTexture(gltfTexture, name10) {
        let define2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        const parameters2 = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
        const image = gltfTexture.texture.source.image;
        let textureOptions;
        let specialTextureParameters = {};
        if (image.compressed) {
          textureOptions = image;
          specialTextureParameters = {
            [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
          };
        } else {
          textureOptions = {
            data: image
          };
        }
        const texture = new Texture2D(this.gl, {
          id: gltfTexture.name || gltfTexture.id,
          parameters: {
            ...parameters2,
            ...specialTextureParameters
          },
          pixelStore: {
            [this.gl.UNPACK_FLIP_Y_WEBGL]: false
          },
          ...textureOptions
        });
        this.uniforms[name10] = texture;
        this.defineIfPresent(define2, define2);
        this.generatedTextures.push(texture);
      }
      parsePbrMetallicRoughness(pbrMetallicRoughness) {
        if (pbrMetallicRoughness.baseColorTexture) {
          this.parseTexture(pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP");
        }
        this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
        if (pbrMetallicRoughness.metallicRoughnessTexture) {
          this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
        }
        const {
          metallicFactor = 1,
          roughnessFactor = 1
        } = pbrMetallicRoughness;
        this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
      }
      parseMaterial(material) {
        this.uniforms.pbr_uUnlit = Boolean(material.unlit);
        if (material.pbrMetallicRoughness) {
          this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
        }
        if (material.normalTexture) {
          this.parseTexture(material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
          const {
            scale = 1
          } = material.normalTexture;
          this.uniforms.u_NormalScale = scale;
        }
        if (material.occlusionTexture) {
          this.parseTexture(material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
          const {
            strength = 1
          } = material.occlusionTexture;
          this.uniforms.u_OcclusionStrength = strength;
        }
        if (material.emissiveTexture) {
          this.parseTexture(material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP");
          this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
        }
        if (material.alphaMode === "MASK") {
          const {
            alphaCutoff = 0.5
          } = material;
          this.defines.ALPHA_CUTOFF = 1;
          this.uniforms.u_AlphaCutoff = alphaCutoff;
        } else if (material.alphaMode === "BLEND") {
          log.warn("BLEND alphaMode might not work well because it requires mesh sorting")();
          Object.assign(this.parameters, {
            blend: true,
            blendEquation: this.gl.FUNC_ADD,
            blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
          });
        }
      }
      delete() {
        this.generatedTextures.forEach((texture) => texture.delete());
      }
    };
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js
function addVersionToShader(gl, source) {
  if (isWebGL2(gl)) {
    return "#version 300 es\n".concat(source);
  }
  return source;
}
function createGLTFModel(gl, options) {
  const {
    id,
    drawMode,
    vertexCount,
    attributes,
    modelOptions
  } = options;
  const materialParser = new GLTFMaterialParser(gl, options);
  log.info(4, "createGLTFModel defines: ", materialParser.defines)();
  const managedResources = [];
  managedResources.push(...materialParser.generatedTextures);
  managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));
  const model = new ModelNode(gl, Object.assign({
    id,
    drawMode,
    vertexCount,
    modules: [pbr],
    defines: materialParser.defines,
    parameters: materialParser.parameters,
    vs: addVersionToShader(gl, vs),
    fs: addVersionToShader(gl, fs),
    managedResources
  }, modelOptions));
  model.setProps({
    attributes
  });
  model.setUniforms(materialParser.uniforms);
  return model;
}
var vs, fs;
var init_create_gltf_model = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js"() {
    init_esm6();
    init_esm7();
    init_esm9();
    init_model_node();
    init_gltf_material_parser();
    vs = "\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n";
    fs = "\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js
var ATTRIBUTE_TYPE_TO_COMPONENTS2, DEFAULT_OPTIONS2, GLTFInstantiator;
var init_gltf_instantiator = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js"() {
    init_esm8();
    init_esm7();
    init_group_node();
    init_gltf_animator();
    init_create_gltf_model();
    ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    };
    DEFAULT_OPTIONS2 = {
      modelOptions: {},
      pbrDebug: false,
      imageBasedLightingEnvironment: null,
      lights: true,
      useTangents: false
    };
    GLTFInstantiator = class {
      constructor(gl) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.options = Object.assign({}, DEFAULT_OPTIONS2, options);
      }
      instantiate(gltf) {
        this.gltf = gltf;
        const scenes = (gltf.scenes || []).map((scene) => this.createScene(scene));
        return scenes;
      }
      createAnimator() {
        if (Array.isArray(this.gltf.animations)) {
          return new GLTFAnimator(this.gltf);
        }
        return null;
      }
      createScene(gltfScene) {
        const gltfNodes = gltfScene.nodes || [];
        const nodes = gltfNodes.map((node) => this.createNode(node));
        const scene = new GroupNode({
          id: gltfScene.name || gltfScene.id,
          children: nodes
        });
        return scene;
      }
      createNode(gltfNode) {
        if (!gltfNode._node) {
          const gltfChildren = gltfNode.children || [];
          const children = gltfChildren.map((child) => this.createNode(child));
          if (gltfNode.mesh) {
            children.push(this.createMesh(gltfNode.mesh));
          }
          const node = new GroupNode({
            id: gltfNode.name || gltfNode.id,
            children
          });
          if (gltfNode.matrix) {
            node.setMatrix(gltfNode.matrix);
          } else {
            node.matrix.identity();
            if (gltfNode.translation) {
              node.matrix.translate(gltfNode.translation);
            }
            if (gltfNode.rotation) {
              const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
              node.matrix.multiplyRight(rotationMatrix);
            }
            if (gltfNode.scale) {
              node.matrix.scale(gltfNode.scale);
            }
          }
          gltfNode._node = node;
        }
        return gltfNode._node;
      }
      createMesh(gltfMesh) {
        if (!gltfMesh._mesh) {
          const gltfPrimitives = gltfMesh.primitives || [];
          const primitives = gltfPrimitives.map((gltfPrimitive, i3) => this.createPrimitive(gltfPrimitive, i3, gltfMesh));
          const mesh = new GroupNode({
            id: gltfMesh.name || gltfMesh.id,
            children: primitives
          });
          gltfMesh._mesh = mesh;
        }
        return gltfMesh._mesh;
      }
      getVertexCount(attributes) {
        log.warn("getVertexCount() not found")();
      }
      createPrimitive(gltfPrimitive, i3, gltfMesh) {
        const model = createGLTFModel(this.gl, Object.assign({
          id: gltfPrimitive.name || "".concat(gltfMesh.name || gltfMesh.id, "-primitive-").concat(i3),
          drawMode: gltfPrimitive.mode || 4,
          vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),
          attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),
          material: gltfPrimitive.material
        }, this.options));
        model.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];
        return model;
      }
      createAttributes(attributes, indices) {
        const loadedAttributes = {};
        Object.keys(attributes).forEach((attrName) => {
          loadedAttributes[attrName] = this.createAccessor(attributes[attrName], this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER));
        });
        if (indices) {
          loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));
        }
        log.info(4, "glTF Attributes", {
          attributes,
          indices,
          generated: loadedAttributes
        })();
        return loadedAttributes;
      }
      createBuffer(attribute, target) {
        if (!attribute.bufferView) {
          attribute.bufferView = {};
        }
        const {
          bufferView
        } = attribute;
        if (!bufferView.lumaBuffers) {
          bufferView.lumaBuffers = {};
        }
        if (!bufferView.lumaBuffers[target]) {
          bufferView.lumaBuffers[target] = new Buffer2(this.gl, {
            id: "from-".concat(bufferView.id),
            data: bufferView.data || attribute.value,
            target
          });
        }
        return bufferView.lumaBuffers[target];
      }
      createAccessor(accessor, buffer) {
        return new Accessor({
          buffer,
          offset: accessor.byteOffset || 0,
          stride: accessor.bufferView.byteStride || 0,
          type: accessor.componentType,
          size: ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type]
        });
      }
      createSampler(gltfSampler) {
        return gltfSampler;
      }
      needsPOT() {
        return false;
      }
    };
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js
function createGLTFObjects(gl, gltf, options) {
  const instantiator = new GLTFInstantiator(gl, options);
  const scenes = instantiator.instantiate(gltf);
  const animator = instantiator.createAnimator();
  return {
    scenes,
    animator
  };
}
var init_create_gltf_objects = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js"() {
    init_gltf_instantiator();
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid-shaders.js
var init_histopyramid_shaders = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid-shaders.js"() {
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid.js
var init_histopyramid = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gpgpu/histopyramid/histopyramid.js"() {
    init_esm7();
    init_esm10();
    init_histopyramid_shaders();
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/texture-filter.js
var init_texture_filter = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/texture-filter.js"() {
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/shaders.js
var init_shaders = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/shaders.js"() {
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/polygon.js
var import_earcut3, PI_4, DEGREES_TO_RADIANS_HALF;
var init_polygon3 = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/polygon.js"() {
    import_earcut3 = __toESM(require_earcut());
    PI_4 = Math.PI / 4;
    DEGREES_TO_RADIANS_HALF = Math.PI / 360;
  }
});

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/gpu-point-in-polygon.js
var init_gpu_point_in_polygon = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/gpu-point-in-polygon.js"() {
    init_esm7();
    init_esm6();
    init_esm10();
    init_texture_filter();
    init_shaders();
    init_polygon3();
  }
});

// node_modules/@luma.gl/experimental/dist/esm/index.js
var init_esm20 = __esm({
  "node_modules/@luma.gl/experimental/dist/esm/index.js"() {
    init_display();
    init_vr_display();
    init_gltf_environment();
    init_create_gltf_objects();
    init_gltf_material_parser();
    init_gltf_animator();
    init_scenegraph_node();
    init_group_node();
    init_model_node();
    init_histopyramid();
    init_gpu_point_in_polygon();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js
var VERSION4;
var init_version = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js"() {
    VERSION4 = true ? "3.3.3" : "latest";
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/utils/version.js
var VERSION5;
var init_version2 = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/utils/version.js"() {
    VERSION5 = true ? "3.3.3" : "beta";
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/parsers/basis-module-loader.js
async function loadBasisTrascoderModule(options) {
  const modules = options.modules || {};
  if (modules.basis) {
    return modules.basis;
  }
  loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);
  return await loadBasisTranscoderPromise;
}
async function loadBasisTrascoder(options) {
  let BASIS = null;
  let wasmBinary = null;
  [BASIS, wasmBinary] = await Promise.all([await loadLibrary("basis_transcoder.js", "textures", options), await loadLibrary("basis_transcoder.wasm", "textures", options)]);
  BASIS = BASIS || globalThis.BASIS;
  return await initializeBasisTrascoderModule(BASIS, wasmBinary);
}
function initializeBasisTrascoderModule(BasisModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisModule(options).then((module) => {
      const {
        BasisFile,
        initializeBasis
      } = module;
      initializeBasis();
      resolve({
        BasisFile
      });
    });
  });
}
async function loadBasisEncoderModule(options) {
  const modules = options.modules || {};
  if (modules.basisEncoder) {
    return modules.basisEncoder;
  }
  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
  return await loadBasisEncoderPromise;
}
async function loadBasisEncoder(options) {
  let BASIS_ENCODER = null;
  let wasmBinary = null;
  [BASIS_ENCODER, wasmBinary] = await Promise.all([await loadLibrary(BASIS_CDN_ENCODER_JS, "textures", options), await loadLibrary(BASIS_CDN_ENCODER_WASM, "textures", options)]);
  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
}
function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisEncoderModule(options).then((module) => {
      const {
        BasisFile,
        KTX2File,
        initializeBasis,
        BasisEncoder
      } = module;
      initializeBasis();
      resolve({
        BasisFile,
        KTX2File,
        BasisEncoder
      });
    });
  });
}
var VERSION6, BASIS_CDN_ENCODER_WASM, BASIS_CDN_ENCODER_JS, loadBasisTranscoderPromise, loadBasisEncoderPromise;
var init_basis_module_loader = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/parsers/basis-module-loader.js"() {
    init_esm();
    VERSION6 = true ? "3.3.3" : "beta";
    BASIS_CDN_ENCODER_WASM = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION6, "/dist/libs/basis_encoder.wasm");
    BASIS_CDN_ENCODER_JS = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION6, "/dist/libs/basis_encoder.js");
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/gl-extensions.js
var GL_EXTENSIONS_CONSTANTS;
var init_gl_extensions = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/gl-extensions.js"() {
    GL_EXTENSIONS_CONSTANTS = {
      COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
      COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
      COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
      COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
      COMPRESSED_R11_EAC: 37488,
      COMPRESSED_SIGNED_R11_EAC: 37489,
      COMPRESSED_RG11_EAC: 37490,
      COMPRESSED_SIGNED_RG11_EAC: 37491,
      COMPRESSED_RGB8_ETC2: 37492,
      COMPRESSED_RGBA8_ETC2_EAC: 37493,
      COMPRESSED_SRGB8_ETC2: 37494,
      COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
      COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
      COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
      COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
      COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
      COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
      COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
      COMPRESSED_RGB_ETC1_WEBGL: 36196,
      COMPRESSED_RGB_ATC_WEBGL: 35986,
      COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
      COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
      COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
      COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
      COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
      COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
      COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
      COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
      COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
      COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
      COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
      COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
      COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
      COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
      COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
      COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
      COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
      COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
      COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
      COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
      COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
      COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
      COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
      COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
      COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
      COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
      COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
      COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
      COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
      COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
      COMPRESSED_RED_RGTC1_EXT: 36283,
      COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
      COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
      COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
      COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
      COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
      COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
      COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/utils/texture-formats.js
function getSupportedGPUTextureFormats(gl) {
  if (!formats) {
    gl = gl || getWebGLContext() || void 0;
    formats = /* @__PURE__ */ new Set();
    for (const prefix of BROWSER_PREFIXES) {
      for (const extension in WEBGL_EXTENSIONS) {
        if (gl && gl.getExtension("".concat(prefix).concat(extension))) {
          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
          formats.add(gpuTextureFormat);
        }
      }
    }
  }
  return formats;
}
function getWebGLContext() {
  try {
    const canvas = document.createElement("canvas");
    return canvas.getContext("webgl");
  } catch (error) {
    return null;
  }
}
var BROWSER_PREFIXES, WEBGL_EXTENSIONS, formats;
var init_texture_formats = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/utils/texture-formats.js"() {
    BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
    WEBGL_EXTENSIONS = {
      WEBGL_compressed_texture_s3tc: "dxt",
      WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
      WEBGL_compressed_texture_etc1: "etc1",
      WEBGL_compressed_texture_etc: "etc2",
      WEBGL_compressed_texture_pvrtc: "pvrtc",
      WEBGL_compressed_texture_atc: "atc",
      WEBGL_compressed_texture_astc: "astc",
      EXT_texture_compression_rgtc: "rgtc"
    };
    formats = null;
  }
});

// node_modules/ktx-parse/dist/ktx-parse.modern.js
function _(t2) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t2) : Buffer.from(t2).toString("utf8");
}
function p(t2) {
  const n2 = new Uint8Array(t2.buffer, t2.byteOffset, e.length);
  if (n2[0] !== e[0] || n2[1] !== e[1] || n2[2] !== e[2] || n2[3] !== e[3] || n2[4] !== e[4] || n2[5] !== e[5] || n2[6] !== e[6] || n2[7] !== e[7] || n2[8] !== e[8] || n2[9] !== e[9] || n2[10] !== e[10] || n2[11] !== e[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const i3 = new U(), s2 = 17 * Uint32Array.BYTES_PER_ELEMENT, a2 = new c(t2, e.length, s2, true);
  i3.vkFormat = a2._nextUint32(), i3.typeSize = a2._nextUint32(), i3.pixelWidth = a2._nextUint32(), i3.pixelHeight = a2._nextUint32(), i3.pixelDepth = a2._nextUint32(), i3.layerCount = a2._nextUint32(), i3.faceCount = a2._nextUint32();
  const r2 = a2._nextUint32();
  i3.supercompressionScheme = a2._nextUint32();
  const o2 = a2._nextUint32(), l2 = a2._nextUint32(), f2 = a2._nextUint32(), h = a2._nextUint32(), g = a2._nextUint64(), p2 = a2._nextUint64(), x2 = new c(t2, e.length + s2, 3 * r2 * 8, true);
  for (let e2 = 0; e2 < r2; e2++)
    i3.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + x2._nextUint64(), x2._nextUint64()), uncompressedByteLength: x2._nextUint64() });
  const u = new c(t2, o2, l2, true), y2 = { vendorId: u._skip(4)._nextUint16(), descriptorType: u._nextUint16(), versionNumber: u._nextUint16(), descriptorBlockSize: u._nextUint16(), colorModel: u._nextUint8(), colorPrimaries: u._nextUint8(), transferFunction: u._nextUint8(), flags: u._nextUint8(), texelBlockDimension: { x: u._nextUint8() + 1, y: u._nextUint8() + 1, z: u._nextUint8() + 1, w: u._nextUint8() + 1 }, bytesPlane: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()], samples: [] }, D = (y2.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < D; t3++)
    y2.samples[t3] = { bitOffset: u._nextUint16(), bitLength: u._nextUint8(), channelID: u._nextUint8(), samplePosition: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()], sampleLower: u._nextUint32(), sampleUpper: u._nextUint32() };
  i3.dataFormatDescriptor.length = 0, i3.dataFormatDescriptor.push(y2);
  const b = new c(t2, f2, h, true);
  for (; b._offset < h; ) {
    const t3 = b._nextUint32(), e2 = b._scan(t3), n3 = _(e2), s3 = b._scan(t3 - e2.byteLength);
    i3.keyValue[n3] = n3.match(/^ktx/i) ? _(s3) : s3, t3 % 4 && b._skip(4 - t3 % 4);
  }
  if (p2 <= 0)
    return i3;
  const d = new c(t2, g, p2, true), B = d._nextUint16(), w = d._nextUint16(), A = d._nextUint32(), S = d._nextUint32(), m = d._nextUint32(), L = d._nextUint32(), I = [];
  for (let t3 = 0; t3 < r2; t3++)
    I.push({ imageFlags: d._nextUint32(), rgbSliceByteOffset: d._nextUint32(), rgbSliceByteLength: d._nextUint32(), alphaSliceByteOffset: d._nextUint32(), alphaSliceByteLength: d._nextUint32() });
  const R = g + d._offset, E = R + A, T = E + S, O = T + m, P = new Uint8Array(t2.buffer, t2.byteOffset + R, A), C = new Uint8Array(t2.buffer, t2.byteOffset + E, S), F = new Uint8Array(t2.buffer, t2.byteOffset + T, m), G = new Uint8Array(t2.buffer, t2.byteOffset + O, L);
  return i3.globalData = { endpointCount: B, selectorCount: w, imageDescs: I, endpointsData: P, selectorsData: C, tablesData: F, extendedData: G }, i3;
}
var t, e, n, i, s, a, r, o, l, f, U, c;
var init_ktx_parse_modern = __esm({
  "node_modules/ktx-parse/dist/ktx-parse.modern.js"() {
    t = new Uint8Array([0]);
    e = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
    !function(t2) {
      t2[t2.NONE = 0] = "NONE", t2[t2.BASISLZ = 1] = "BASISLZ", t2[t2.ZSTD = 2] = "ZSTD", t2[t2.ZLIB = 3] = "ZLIB";
    }(n || (n = {})), function(t2) {
      t2[t2.BASICFORMAT = 0] = "BASICFORMAT";
    }(i || (i = {})), function(t2) {
      t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.ETC1S = 163] = "ETC1S", t2[t2.UASTC = 166] = "UASTC";
    }(s || (s = {})), function(t2) {
      t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.SRGB = 1] = "SRGB";
    }(a || (a = {})), function(t2) {
      t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.LINEAR = 1] = "LINEAR", t2[t2.SRGB = 2] = "SRGB", t2[t2.ITU = 3] = "ITU", t2[t2.NTSC = 4] = "NTSC", t2[t2.SLOG = 5] = "SLOG", t2[t2.SLOG2 = 6] = "SLOG2";
    }(r || (r = {})), function(t2) {
      t2[t2.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t2[t2.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
    }(o || (o = {})), function(t2) {
      t2[t2.RGB = 0] = "RGB", t2[t2.RRR = 3] = "RRR", t2[t2.GGG = 4] = "GGG", t2[t2.AAA = 15] = "AAA";
    }(l || (l = {})), function(t2) {
      t2[t2.RGB = 0] = "RGB", t2[t2.RGBA = 3] = "RGBA", t2[t2.RRR = 4] = "RRR", t2[t2.RRRG = 5] = "RRRG";
    }(f || (f = {}));
    U = class {
      constructor() {
        this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = n.NONE, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: i.BASICFORMAT, versionNumber: 2, descriptorBlockSize: 40, colorModel: s.UNSPECIFIED, colorPrimaries: a.SRGB, transferFunction: a.SRGB, flags: o.ALPHA_STRAIGHT, texelBlockDimension: { x: 4, y: 4, z: 1, w: 1 }, bytesPlane: [], samples: [] }], this.keyValue = {}, this.globalData = null;
      }
    };
    c = class {
      constructor(t2, e2, n2, i3) {
        this._dataView = new DataView(t2.buffer, t2.byteOffset + e2, n2), this._littleEndian = i3, this._offset = 0;
      }
      _nextUint8() {
        const t2 = this._dataView.getUint8(this._offset);
        return this._offset += 1, t2;
      }
      _nextUint16() {
        const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2, t2;
      }
      _nextUint32() {
        const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4, t2;
      }
      _nextUint64() {
        const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8, t2;
      }
      _skip(t2) {
        return this._offset += t2, this;
      }
      _scan(t2, e2 = 0) {
        const n2 = this._offset;
        let i3 = 0;
        for (; this._dataView.getUint8(this._offset) !== e2 && i3 < t2; )
          i3++, this._offset++;
        return i3 < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i3);
      }
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/utils/extract-mipmap-images.js
function extractMipmapImages(data, options) {
  const images = new Array(options.mipMapLevels);
  let levelWidth = options.width;
  let levelHeight = options.height;
  let offset = 0;
  for (let i3 = 0; i3 < options.mipMapLevels; ++i3) {
    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i3);
    const levelData = getLevelData(data, i3, offset, levelSize);
    images[i3] = {
      compressed: true,
      format: options.internalFormat,
      data: levelData,
      width: levelWidth,
      height: levelHeight,
      levelSize
    };
    levelWidth = Math.max(1, levelWidth >> 1);
    levelHeight = Math.max(1, levelHeight >> 1);
    offset += levelSize;
  }
  return images;
}
function getLevelData(data, index, offset, levelSize) {
  if (!Array.isArray(data)) {
    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);
  }
  return data[index].levelData;
}
function getLevelSize(options, levelWidth, levelHeight, data, index) {
  if (!Array.isArray(data)) {
    return options.sizeFunction(levelWidth, levelHeight);
  }
  return options.sizeFunction(data[index]);
}
var init_extract_mipmap_images = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/utils/extract-mipmap-images.js"() {
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/utils/ktx-format-helper.js
function mapVkFormatToWebGL(vkFormat) {
  return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];
}
var VULKAN_TO_WEBGL_FORMAT_MAP;
var init_ktx_format_helper = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/utils/ktx-format-helper.js"() {
    init_gl_extensions();
    VULKAN_TO_WEBGL_FORMAT_MAP = {
      131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
      132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,
      133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
      138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
      139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,
      140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,
      142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
      147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,
      148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,
      149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,
      152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,
      154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,
      155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,
      156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,
      157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
      158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
      160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,
      161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
      162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
      164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
      166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
      168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
      170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
      172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
      174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
      176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
      178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
      180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
      182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,
      184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
      1000054e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
      1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      1000066e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
      1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
      1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
      1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
      1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
      1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
      1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
      1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
      1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
      1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
      1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
      1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
      1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
      1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-ktx.js
function isKTX(data) {
  const id = new Uint8Array(data);
  const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11];
  return !notKTX;
}
function parseKTX(arrayBuffer) {
  const uint8Array = new Uint8Array(arrayBuffer);
  const ktx = p(uint8Array);
  const mipMapLevels = Math.max(1, ktx.levels.length);
  const width = ktx.pixelWidth;
  const height = ktx.pixelHeight;
  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);
  return extractMipmapImages(ktx.levels, {
    mipMapLevels,
    width,
    height,
    sizeFunction: (level) => level.uncompressedByteLength,
    internalFormat
  });
}
var KTX2_ID;
var init_parse_ktx = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-ktx.js"() {
    init_ktx_parse_modern();
    init_extract_mipmap_images();
    init_ktx_format_helper();
    KTX2_ID = [
      171,
      75,
      84,
      88,
      32,
      50,
      48,
      187,
      13,
      10,
      26,
      10
    ];
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-basis.js
async function parseBasis(data, options) {
  if (options.basis.containerFormat === "auto") {
    if (isKTX(data)) {
      const fileConstructors = await loadBasisEncoderModule(options);
      return parseKTX2File(fileConstructors.KTX2File, data, options);
    }
    const {
      BasisFile
    } = await loadBasisTrascoderModule(options);
    return parseBasisFile(BasisFile, data, options);
  }
  switch (options.basis.module) {
    case "encoder":
      const fileConstructors = await loadBasisEncoderModule(options);
      switch (options.basis.containerFormat) {
        case "ktx2":
          return parseKTX2File(fileConstructors.KTX2File, data, options);
        case "basis":
        default:
          return parseBasisFile(fileConstructors.BasisFile, data, options);
      }
    case "transcoder":
    default:
      const {
        BasisFile
      } = await loadBasisTrascoderModule(options);
      return parseBasisFile(BasisFile, data, options);
  }
}
function parseBasisFile(BasisFile, data, options) {
  const basisFile = new BasisFile(new Uint8Array(data));
  try {
    if (!basisFile.startTranscoding()) {
      throw new Error("Failed to start basis transcoding");
    }
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
      const levelsCount = basisFile.getNumLevels(imageIndex);
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
      }
      images.push(levels);
    }
    return images;
  } finally {
    basisFile.close();
    basisFile.delete();
  }
}
function transcodeImage(basisFile, imageIndex, levelIndex, options) {
  const width = basisFile.getImageWidth(imageIndex, levelIndex);
  const height = basisFile.getImageHeight(imageIndex, levelIndex);
  const hasAlpha = basisFile.getHasAlpha();
  const {
    compressed,
    format,
    basisFormat
  } = getBasisOptions(options, hasAlpha);
  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
    throw new Error("failed to start Basis transcoding");
  }
  return {
    width,
    height,
    data: decodedData,
    compressed,
    format,
    hasAlpha
  };
}
function parseKTX2File(KTX2File, data, options) {
  const ktx2File = new KTX2File(new Uint8Array(data));
  try {
    if (!ktx2File.startTranscoding()) {
      throw new Error("failed to start KTX2 transcoding");
    }
    const levelsCount = ktx2File.getLevels();
    const levels = [];
    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
      break;
    }
    return [levels];
  } finally {
    ktx2File.close();
    ktx2File.delete();
  }
}
function transcodeKTX2Image(ktx2File, levelIndex, options) {
  const {
    alphaFlag,
    height,
    width
  } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
  const {
    compressed,
    format,
    basisFormat
  } = getBasisOptions(options, alphaFlag);
  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {
    throw new Error("Failed to transcode KTX2 image");
  }
  return {
    width,
    height,
    data: decodedData,
    compressed,
    levelSize: decodedSize,
    hasAlpha: alphaFlag,
    format
  };
}
function getBasisOptions(options, hasAlpha) {
  let format = options && options.basis && options.basis.format;
  if (format === "auto") {
    format = selectSupportedBasisFormat();
  }
  if (typeof format === "object") {
    format = hasAlpha ? format.alpha : format.noAlpha;
  }
  format = format.toLowerCase();
  return OutputFormat[format];
}
function selectSupportedBasisFormat() {
  const supportedFormats = getSupportedGPUTextureFormats();
  if (supportedFormats.has("astc")) {
    return "astc-4x4";
  } else if (supportedFormats.has("dxt")) {
    return {
      alpha: "bc3",
      noAlpha: "bc1"
    };
  } else if (supportedFormats.has("pvrtc")) {
    return {
      alpha: "pvrtc1-4-rgba",
      noAlpha: "pvrtc1-4-rgb"
    };
  } else if (supportedFormats.has("etc1")) {
    return "etc1";
  } else if (supportedFormats.has("etc2")) {
    return "etc2";
  }
  return "rgb565";
}
var OutputFormat;
var init_parse_basis = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-basis.js"() {
    init_basis_module_loader();
    init_gl_extensions();
    init_texture_formats();
    init_parse_ktx();
    OutputFormat = {
      etc1: {
        basisFormat: 0,
        compressed: true,
        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
      },
      etc2: {
        basisFormat: 1,
        compressed: true
      },
      bc1: {
        basisFormat: 2,
        compressed: true,
        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
      },
      bc3: {
        basisFormat: 3,
        compressed: true,
        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
      },
      bc4: {
        basisFormat: 4,
        compressed: true
      },
      bc5: {
        basisFormat: 5,
        compressed: true
      },
      "bc7-m6-opaque-only": {
        basisFormat: 6,
        compressed: true
      },
      "bc7-m5": {
        basisFormat: 7,
        compressed: true
      },
      "pvrtc1-4-rgb": {
        basisFormat: 8,
        compressed: true,
        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
      },
      "pvrtc1-4-rgba": {
        basisFormat: 9,
        compressed: true,
        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
      },
      "astc-4x4": {
        basisFormat: 10,
        compressed: true,
        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
      },
      "atc-rgb": {
        basisFormat: 11,
        compressed: true
      },
      "atc-rgba-interpolated-alpha": {
        basisFormat: 12,
        compressed: true
      },
      rgba32: {
        basisFormat: 13,
        compressed: false
      },
      rgb565: {
        basisFormat: 14,
        compressed: false
      },
      bgr565: {
        basisFormat: 15,
        compressed: false
      },
      rgba4444: {
        basisFormat: 16,
        compressed: false
      }
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/basis-loader.js
var BasisWorkerLoader, BasisLoader;
var init_basis_loader = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/basis-loader.js"() {
    init_esm();
    init_version2();
    init_parse_basis();
    BasisWorkerLoader = {
      name: "Basis",
      id: isBrowser ? "basis" : "basis-nodejs",
      module: "textures",
      version: VERSION5,
      worker: true,
      extensions: ["basis", "ktx2"],
      mimeTypes: ["application/octet-stream", "image/ktx2"],
      tests: ["sB"],
      binary: true,
      options: {
        basis: {
          format: "auto",
          libraryPath: "libs/",
          containerFormat: "auto",
          module: "transcoder"
        }
      }
    };
    BasisLoader = {
      ...BasisWorkerLoader,
      parse: parseBasis
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-dds.js
function isDDS(data) {
  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];
  return magic === DDS_CONSTANTS.MAGIC_NUMBER;
}
function parseDDS(data) {
  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];
  assert2(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), "DDS: Unsupported format, must contain a FourCC code");
  const fourCC = int32ToFourCC(pixelFormatNumber);
  const internalFormat = DDS_PIXEL_FORMATS[fourCC];
  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];
  assert2(internalFormat && sizeFunction, "DDS: Unknown pixel format ".concat(pixelFormatNumber));
  let mipMapLevels = 1;
  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {
    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);
  }
  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];
  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];
  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function getDxt1LevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 8;
}
function getDxtXLevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 16;
}
function int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}
var DDS_CONSTANTS, DDS_PIXEL_FORMATS, getATCLevelSize, getATCALevelSize, getATCILevelSize, DDS_SIZE_FUNCTIONS;
var init_parse_dds = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-dds.js"() {
    init_esm3();
    init_gl_extensions();
    init_extract_mipmap_images();
    DDS_CONSTANTS = {
      MAGIC_NUMBER: 542327876,
      HEADER_LENGTH: 31,
      MAGIC_NUMBER_INDEX: 0,
      HEADER_SIZE_INDEX: 1,
      HEADER_FLAGS_INDEX: 2,
      HEADER_HEIGHT_INDEX: 3,
      HEADER_WIDTH_INDEX: 4,
      MIPMAPCOUNT_INDEX: 7,
      HEADER_PF_FLAGS_INDEX: 20,
      HEADER_PF_FOURCC_INDEX: 21,
      DDSD_MIPMAPCOUNT: 131072,
      DDPF_FOURCC: 4
    };
    DDS_PIXEL_FORMATS = {
      DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
      DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
      "ATC ": GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,
      ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    };
    getATCLevelSize = getDxt1LevelSize;
    getATCALevelSize = getDxtXLevelSize;
    getATCILevelSize = getDxtXLevelSize;
    DDS_SIZE_FUNCTIONS = {
      DXT1: getDxt1LevelSize,
      DXT3: getDxtXLevelSize,
      DXT5: getDxtXLevelSize,
      "ATC ": getATCLevelSize,
      ATCA: getATCALevelSize,
      ATCI: getATCILevelSize
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-pvr.js
function isPVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];
  return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;
}
function parsePVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];
  const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];
  const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];
  const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];
  const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];
  const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];
  const width = header[PVR_CONSTANTS.WIDTH_INDEX];
  const height = header[PVR_CONSTANTS.HEIGHT_INDEX];
  const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function pvrtc2bppSize(width, height) {
  width = Math.max(width, 16);
  height = Math.max(height, 8);
  return width * height / 4;
}
function pvrtc4bppSize(width, height) {
  width = Math.max(width, 8);
  height = Math.max(height, 8);
  return width * height / 2;
}
function dxtEtcSmallSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
}
function dxtEtcAstcBigSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
}
function atc5x4Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
}
function atc5x5Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
}
function atc6x5Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
}
function atc6x6Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
}
function atc8x5Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
}
function atc8x6Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
}
function atc8x8Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
}
function atc10x5Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
}
function atc10x6Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
}
function atc10x8Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
}
function atc10x10Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
}
function atc12x10Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
}
function atc12x12Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
}
var PVR_CONSTANTS, PVR_PIXEL_FORMATS, PVR_SIZE_FUNCTIONS;
var init_parse_pvr = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-pvr.js"() {
    init_gl_extensions();
    init_extract_mipmap_images();
    PVR_CONSTANTS = {
      MAGIC_NUMBER: 55727696,
      MAGIC_NUMBER_EXTRA: 1347834371,
      HEADER_LENGTH: 13,
      HEADER_SIZE: 52,
      MAGIC_NUMBER_INDEX: 0,
      PIXEL_FORMAT_INDEX: 2,
      COLOUR_SPACE_INDEX: 4,
      HEIGHT_INDEX: 6,
      WIDTH_INDEX: 7,
      MIPMAPCOUNT_INDEX: 11,
      METADATA_SIZE_INDEX: 12
    };
    PVR_PIXEL_FORMATS = {
      0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],
      1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],
      2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],
      3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],
      6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],
      7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],
      9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],
      11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],
      22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],
      23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],
      24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],
      25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],
      26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],
      27: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR],
      28: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR],
      29: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR],
      30: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR],
      31: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR],
      32: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR],
      33: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR],
      34: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR],
      35: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR],
      36: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR],
      37: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR],
      38: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR],
      39: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR],
      40: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR, GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR]
    };
    PVR_SIZE_FUNCTIONS = {
      0: pvrtc2bppSize,
      1: pvrtc2bppSize,
      2: pvrtc4bppSize,
      3: pvrtc4bppSize,
      6: dxtEtcSmallSize,
      7: dxtEtcSmallSize,
      9: dxtEtcAstcBigSize,
      11: dxtEtcAstcBigSize,
      22: dxtEtcSmallSize,
      23: dxtEtcAstcBigSize,
      24: dxtEtcSmallSize,
      25: dxtEtcSmallSize,
      26: dxtEtcAstcBigSize,
      27: dxtEtcAstcBigSize,
      28: atc5x4Size,
      29: atc5x5Size,
      30: atc6x5Size,
      31: atc6x6Size,
      32: atc8x5Size,
      33: atc8x6Size,
      34: atc8x8Size,
      35: atc10x5Size,
      36: atc10x6Size,
      37: atc10x8Size,
      38: atc10x10Size,
      39: atc12x10Size,
      40: atc12x12Size
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-compressed-texture.js
function parseCompressedTexture(data) {
  if (isKTX(data)) {
    return parseKTX(data);
  }
  if (isDDS(data)) {
    return parseDDS(data);
  }
  if (isPVR(data)) {
    return parsePVR(data);
  }
  throw new Error("Texture container format not recognized");
}
var init_parse_compressed_texture = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-compressed-texture.js"() {
    init_parse_ktx();
    init_parse_dds();
    init_parse_pvr();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/compressed-texture-loader.js
var DEFAULT_TEXTURE_LOADER_OPTIONS, CompressedTextureWorkerLoader, CompressedTextureLoader;
var init_compressed_texture_loader = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/compressed-texture-loader.js"() {
    init_version2();
    init_parse_compressed_texture();
    init_parse_basis();
    DEFAULT_TEXTURE_LOADER_OPTIONS = {
      "compressed-texture": {
        libraryPath: "libs/",
        useBasis: false
      }
    };
    CompressedTextureWorkerLoader = {
      name: "Texture Containers",
      id: "compressed-texture",
      module: "textures",
      version: VERSION5,
      worker: true,
      extensions: [
        "ktx",
        "ktx2",
        "dds",
        "pvr"
      ],
      mimeTypes: ["image/ktx2", "image/ktx", "image/vnd-ms.dds", "image/x-dds", "application/octet-stream"],
      binary: true,
      options: DEFAULT_TEXTURE_LOADER_OPTIONS
    };
    CompressedTextureLoader = {
      ...CompressedTextureWorkerLoader,
      parse: async (arrayBuffer, options) => {
        if (options["compressed-texture"].useBasis) {
          options.basis = {
            format: {
              alpha: "BC3",
              noAlpha: "BC1"
            },
            ...options.basis,
            containerFormat: "ktx2",
            module: "encoder"
          };
          return (await parseBasis(arrayBuffer, options))[0];
        }
        return parseCompressedTexture(arrayBuffer);
      }
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/crunch-loader.js
var init_crunch_loader = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/crunch-loader.js"() {
    init_version2();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-npy.js
function systemIsLittleEndian() {
  const a2 = new Uint32Array([305419896]);
  const b = new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength);
  return !(b[0] === 18);
}
function parseNPY(arrayBuffer, options) {
  var _header$shape;
  if (!arrayBuffer) {
    return null;
  }
  const view = new DataView(arrayBuffer);
  const {
    header,
    headerEndOffset
  } = parseHeader(view);
  const numpyType = header.descr;
  const ArrayType = DTYPES[numpyType.slice(1, 3)];
  if (!ArrayType) {
    throw new Error("Unimplemented type ".concat(numpyType));
  }
  const nArrayElements = (_header$shape = header.shape) === null || _header$shape === void 0 ? void 0 : _header$shape.reduce((a2, b) => a2 * b);
  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;
  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {
    throw new Error("Buffer overflow");
  }
  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));
  if (numpyType[0] === ">" && LITTLE_ENDIAN_OS || numpyType[0] === "<" && !LITTLE_ENDIAN_OS) {
    throw new Error("Incorrect endianness");
  }
  return {
    data,
    header
  };
}
function parseHeader(view) {
  const majorVersion = view.getUint8(6);
  let offset = 8;
  let headerLength;
  if (majorVersion >= 2) {
    headerLength = view.getUint32(offset, true);
    offset += 4;
  } else {
    headerLength = view.getUint16(offset, true);
    offset += 2;
  }
  const encoding = majorVersion <= 2 ? "latin1" : "utf-8";
  const decoder = new TextDecoder(encoding);
  const headerArray = new Uint8Array(view.buffer, offset, headerLength);
  const headerText = decoder.decode(headerArray);
  offset += headerLength;
  const header = JSON.parse(headerText.replace(/'/g, '"').replace("False", "false").replace("(", "[").replace(/,*\),*/g, "]"));
  return {
    header,
    headerEndOffset: offset
  };
}
var LITTLE_ENDIAN_OS, DTYPES;
var init_parse_npy = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-npy.js"() {
    LITTLE_ENDIAN_OS = systemIsLittleEndian();
    DTYPES = {
      u1: Uint8Array,
      i1: Int8Array,
      u2: Uint16Array,
      i2: Int16Array,
      u4: Uint32Array,
      i4: Int32Array,
      f4: Float32Array,
      f8: Float64Array
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/npy-loader.js
var NPY_MAGIC_NUMBER, NPYWorkerLoader, NPYLoader;
var init_npy_loader = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/npy-loader.js"() {
    init_version2();
    init_parse_npy();
    NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);
    NPYWorkerLoader = {
      name: "NPY",
      id: "npy",
      module: "textures",
      version: VERSION5,
      worker: true,
      extensions: ["npy"],
      mimeTypes: [],
      tests: [NPY_MAGIC_NUMBER.buffer],
      options: {
        npy: {}
      }
    };
    NPYLoader = {
      ...NPYWorkerLoader,
      parseSync: parseNPY,
      parse: async (arrayBuffer, options) => parseNPY(arrayBuffer, options)
    };
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/encoders/encode-texture.js
var init_encode_texture = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/encoders/encode-texture.js"() {
    init_esm();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/compressed-texture-writer.js
var init_compressed_texture_writer = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/compressed-texture-writer.js"() {
    init_version2();
    init_encode_texture();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/encoders/encode-ktx2-basis-texture.js
var init_encode_ktx2_basis_texture = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/encoders/encode-ktx2-basis-texture.js"() {
    init_basis_module_loader();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/ktx2-basis-writer.js
var init_ktx2_basis_writer = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/ktx2-basis-writer.js"() {
    init_version2();
    init_encode_ktx2_basis_texture();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/generate-url.js
var init_generate_url = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/generate-url.js"() {
    init_esm3();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/async-deep-map.js
var init_async_deep_map = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/async-deep-map.js"() {
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/deep-load.js
var init_deep_load = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/deep-load.js"() {
    init_async_deep_map();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/load-image.js
var init_load_image = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/load-image.js"() {
    init_esm3();
    init_esm5();
    init_generate_url();
    init_deep_load();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/load-image-array.js
var init_load_image_array = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/load-image-array.js"() {
    init_esm5();
    init_load_image();
    init_deep_load();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/load-image-cube.js
var init_load_image_cube = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/lib/texture-api/load-image-cube.js"() {
    init_esm5();
    init_load_image();
    init_deep_load();
  }
});

// node_modules/@loaders.gl/textures/dist/esm/index.js
var init_esm21 = __esm({
  "node_modules/@loaders.gl/textures/dist/esm/index.js"() {
    init_esm3();
    init_version2();
    init_basis_loader();
    init_compressed_texture_loader();
    init_crunch_loader();
    init_npy_loader();
    init_compressed_texture_writer();
    init_ktx2_basis_writer();
    init_load_image();
    init_load_image_array();
    init_load_image_cube();
    init_gl_extensions();
    init_parse_basis();
    init_texture_formats();
    init_crunch_loader();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js
function assert6(condition, message) {
  if (!condition) {
    throw new Error(message || "assert failed: gltf");
  }
}
var init_assert2 = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js"() {
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js
function resolveUrl(url, options) {
  const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
  if (absolute) {
    return url;
  }
  const baseUrl = options.baseUri || options.uri;
  if (!baseUrl) {
    throw new Error("'baseUri' must be provided to resolve relative url ".concat(url));
  }
  return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
}
var init_resolve_url = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js"() {
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js
function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
  const bufferView = json.bufferViews[bufferViewIndex];
  assert6(bufferView);
  const bufferIndex = bufferView.buffer;
  const binChunk = buffers[bufferIndex];
  assert6(binChunk);
  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
}
var init_get_typed_array = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js"() {
    init_assert2();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js
function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}
function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
  if (!componentType) {
    throw new Error("Illegal typed array");
  }
  return componentType;
}
function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS3[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length3 = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  assert6(byteLength >= 0 && byteLength <= bufferView.byteLength);
  return {
    ArrayType,
    length: length3,
    byteLength
  };
}
var TYPES, ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT, ARRAY_TO_COMPONENT_TYPE, ATTRIBUTE_TYPE_TO_COMPONENTS3, ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2;
var init_gltf_utils = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js"() {
    init_assert2();
    TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
    ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];
    ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
    ATTRIBUTE_TYPE_TO_COMPONENTS3 = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    };
    ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
      5120: 1,
      5121: 1,
      5122: 2,
      5123: 2,
      5125: 4,
      5126: 4
    };
    ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js
var DEFAULT_GLTF_JSON, GLTFScenegraph;
var init_gltf_scenegraph = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js"() {
    init_defineProperty();
    init_esm5();
    init_esm3();
    init_assert2();
    init_gltf_utils();
    DEFAULT_GLTF_JSON = {
      asset: {
        version: "2.0",
        generator: "loaders.gl"
      },
      buffers: []
    };
    GLTFScenegraph = class {
      constructor(gltf) {
        _defineProperty(this, "gltf", void 0);
        _defineProperty(this, "sourceBuffers", void 0);
        _defineProperty(this, "byteLength", void 0);
        this.gltf = gltf || {
          json: {
            ...DEFAULT_GLTF_JSON
          },
          buffers: []
        };
        this.sourceBuffers = [];
        this.byteLength = 0;
        if (this.gltf.buffers && this.gltf.buffers[0]) {
          this.byteLength = this.gltf.buffers[0].byteLength;
          this.sourceBuffers = [this.gltf.buffers[0]];
        }
      }
      get json() {
        return this.gltf.json;
      }
      getApplicationData(key) {
        const data = this.json[key];
        return data;
      }
      getExtraData(key) {
        const extras = this.json.extras || {};
        return extras[key];
      }
      getExtension(extensionName) {
        const isExtension = this.getUsedExtensions().find((name10) => name10 === extensionName);
        const extensions = this.json.extensions || {};
        return isExtension ? extensions[extensionName] || true : null;
      }
      getRequiredExtension(extensionName) {
        const isRequired = this.getRequiredExtensions().find((name10) => name10 === extensionName);
        return isRequired ? this.getExtension(extensionName) : null;
      }
      getRequiredExtensions() {
        return this.json.extensionsRequired || [];
      }
      getUsedExtensions() {
        return this.json.extensionsUsed || [];
      }
      getRemovedExtensions() {
        return this.json.extensionsRemoved || [];
      }
      getObjectExtension(object, extensionName) {
        const extensions = object.extensions || {};
        return extensions[extensionName];
      }
      getScene(index) {
        return this.getObject("scenes", index);
      }
      getNode(index) {
        return this.getObject("nodes", index);
      }
      getSkin(index) {
        return this.getObject("skins", index);
      }
      getMesh(index) {
        return this.getObject("meshes", index);
      }
      getMaterial(index) {
        return this.getObject("materials", index);
      }
      getAccessor(index) {
        return this.getObject("accessors", index);
      }
      getTexture(index) {
        return this.getObject("textures", index);
      }
      getSampler(index) {
        return this.getObject("samplers", index);
      }
      getImage(index) {
        return this.getObject("images", index);
      }
      getBufferView(index) {
        return this.getObject("bufferViews", index);
      }
      getBuffer(index) {
        return this.getObject("buffers", index);
      }
      getObject(array, index) {
        if (typeof index === "object") {
          return index;
        }
        const object = this.json[array] && this.json[array][index];
        if (!object) {
          throw new Error("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
        }
        return object;
      }
      getTypedArrayForBufferView(bufferView) {
        bufferView = this.getBufferView(bufferView);
        const bufferIndex = bufferView.buffer;
        const binChunk = this.gltf.buffers[bufferIndex];
        assert6(binChunk);
        const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
        return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
      }
      getTypedArrayForAccessor(accessor) {
        accessor = this.getAccessor(accessor);
        const bufferView = this.getBufferView(accessor.bufferView);
        const buffer = this.getBuffer(bufferView.buffer);
        const arrayBuffer = buffer.data;
        const {
          ArrayType,
          length: length3
        } = getAccessorArrayTypeAndLength(accessor, bufferView);
        const byteOffset = bufferView.byteOffset + accessor.byteOffset;
        return new ArrayType(arrayBuffer, byteOffset, length3);
      }
      getTypedArrayForImageData(image) {
        image = this.getAccessor(image);
        const bufferView = this.getBufferView(image.bufferView);
        const buffer = this.getBuffer(bufferView.buffer);
        const arrayBuffer = buffer.data;
        const byteOffset = bufferView.byteOffset || 0;
        return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
      }
      addApplicationData(key, data) {
        this.json[key] = data;
        return this;
      }
      addExtraData(key, data) {
        this.json.extras = this.json.extras || {};
        this.json.extras[key] = data;
        return this;
      }
      addObjectExtension(object, extensionName, data) {
        object.extensions = object.extensions || {};
        object.extensions[extensionName] = data;
        this.registerUsedExtension(extensionName);
        return this;
      }
      setObjectExtension(object, extensionName, data) {
        const extensions = object.extensions || {};
        extensions[extensionName] = data;
      }
      removeObjectExtension(object, extensionName) {
        const extensions = object.extensions || {};
        const extension = extensions[extensionName];
        delete extensions[extensionName];
        return extension;
      }
      addExtension(extensionName) {
        let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assert6(extensionData);
        this.json.extensions = this.json.extensions || {};
        this.json.extensions[extensionName] = extensionData;
        this.registerUsedExtension(extensionName);
        return extensionData;
      }
      addRequiredExtension(extensionName) {
        let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assert6(extensionData);
        this.addExtension(extensionName, extensionData);
        this.registerRequiredExtension(extensionName);
        return extensionData;
      }
      registerUsedExtension(extensionName) {
        this.json.extensionsUsed = this.json.extensionsUsed || [];
        if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
          this.json.extensionsUsed.push(extensionName);
        }
      }
      registerRequiredExtension(extensionName) {
        this.registerUsedExtension(extensionName);
        this.json.extensionsRequired = this.json.extensionsRequired || [];
        if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
          this.json.extensionsRequired.push(extensionName);
        }
      }
      removeExtension(extensionName) {
        if (!this.getExtension(extensionName)) {
          return;
        }
        if (this.json.extensionsRequired) {
          this._removeStringFromArray(this.json.extensionsRequired, extensionName);
        }
        if (this.json.extensionsUsed) {
          this._removeStringFromArray(this.json.extensionsUsed, extensionName);
        }
        if (this.json.extensions) {
          delete this.json.extensions[extensionName];
        }
        if (!Array.isArray(this.json.extensionsRemoved)) {
          this.json.extensionsRemoved = [];
        }
        const extensionsRemoved = this.json.extensionsRemoved;
        if (!extensionsRemoved.includes(extensionName)) {
          extensionsRemoved.push(extensionName);
        }
      }
      setDefaultScene(sceneIndex) {
        this.json.scene = sceneIndex;
      }
      addScene(scene) {
        const {
          nodeIndices
        } = scene;
        this.json.scenes = this.json.scenes || [];
        this.json.scenes.push({
          nodes: nodeIndices
        });
        return this.json.scenes.length - 1;
      }
      addNode(node) {
        const {
          meshIndex,
          matrix
        } = node;
        this.json.nodes = this.json.nodes || [];
        const nodeData = {
          mesh: meshIndex
        };
        if (matrix) {
          nodeData.matrix = matrix;
        }
        this.json.nodes.push(nodeData);
        return this.json.nodes.length - 1;
      }
      addMesh(mesh) {
        const {
          attributes,
          indices,
          material,
          mode = 4
        } = mesh;
        const accessors = this._addAttributes(attributes);
        const glTFMesh = {
          primitives: [{
            attributes: accessors,
            mode
          }]
        };
        if (indices) {
          const indicesAccessor = this._addIndices(indices);
          glTFMesh.primitives[0].indices = indicesAccessor;
        }
        if (Number.isFinite(material)) {
          glTFMesh.primitives[0].material = material;
        }
        this.json.meshes = this.json.meshes || [];
        this.json.meshes.push(glTFMesh);
        return this.json.meshes.length - 1;
      }
      addPointCloud(attributes) {
        const accessorIndices = this._addAttributes(attributes);
        const glTFMesh = {
          primitives: [{
            attributes: accessorIndices,
            mode: 0
          }]
        };
        this.json.meshes = this.json.meshes || [];
        this.json.meshes.push(glTFMesh);
        return this.json.meshes.length - 1;
      }
      addImage(imageData, mimeTypeOpt) {
        const metadata = getBinaryImageMetadata(imageData);
        const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);
        const bufferViewIndex = this.addBufferView(imageData);
        const glTFImage = {
          bufferView: bufferViewIndex,
          mimeType
        };
        this.json.images = this.json.images || [];
        this.json.images.push(glTFImage);
        return this.json.images.length - 1;
      }
      addBufferView(buffer) {
        const byteLength = buffer.byteLength;
        assert6(Number.isFinite(byteLength));
        this.sourceBuffers = this.sourceBuffers || [];
        this.sourceBuffers.push(buffer);
        const glTFBufferView = {
          buffer: 0,
          byteOffset: this.byteLength,
          byteLength
        };
        this.byteLength += padToNBytes(byteLength, 4);
        this.json.bufferViews = this.json.bufferViews || [];
        this.json.bufferViews.push(glTFBufferView);
        return this.json.bufferViews.length - 1;
      }
      addAccessor(bufferViewIndex, accessor) {
        const glTFAccessor = {
          bufferView: bufferViewIndex,
          type: getAccessorTypeFromSize(accessor.size),
          componentType: accessor.componentType,
          count: accessor.count,
          max: accessor.max,
          min: accessor.min
        };
        this.json.accessors = this.json.accessors || [];
        this.json.accessors.push(glTFAccessor);
        return this.json.accessors.length - 1;
      }
      addBinaryBuffer(sourceBuffer) {
        let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          size: 3
        };
        const bufferViewIndex = this.addBufferView(sourceBuffer);
        let minMax = {
          min: accessor.min,
          max: accessor.max
        };
        if (!minMax.min || !minMax.max) {
          minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
        }
        const accessorDefaults = {
          size: accessor.size,
          componentType: getComponentTypeFromArray(sourceBuffer),
          count: Math.round(sourceBuffer.length / accessor.size),
          min: minMax.min,
          max: minMax.max
        };
        return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
      }
      addTexture(texture) {
        const {
          imageIndex
        } = texture;
        const glTFTexture = {
          source: imageIndex
        };
        this.json.textures = this.json.textures || [];
        this.json.textures.push(glTFTexture);
        return this.json.textures.length - 1;
      }
      addMaterial(pbrMaterialInfo) {
        this.json.materials = this.json.materials || [];
        this.json.materials.push(pbrMaterialInfo);
        return this.json.materials.length - 1;
      }
      createBinaryChunk() {
        var _this$json, _this$json$buffers;
        this.gltf.buffers = [];
        const totalByteLength = this.byteLength;
        const arrayBuffer = new ArrayBuffer(totalByteLength);
        const targetArray = new Uint8Array(arrayBuffer);
        let dstByteOffset = 0;
        for (const sourceBuffer of this.sourceBuffers || []) {
          dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
        }
        if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {
          this.json.buffers[0].byteLength = totalByteLength;
        } else {
          this.json.buffers = [{
            byteLength: totalByteLength
          }];
        }
        this.gltf.binary = arrayBuffer;
        this.sourceBuffers = [arrayBuffer];
      }
      _removeStringFromArray(array, string) {
        let found = true;
        while (found) {
          const index = array.indexOf(string);
          if (index > -1) {
            array.splice(index, 1);
          } else {
            found = false;
          }
        }
      }
      _addAttributes() {
        let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const result = {};
        for (const attributeKey in attributes) {
          const attributeData = attributes[attributeKey];
          const attrName = this._getGltfAttributeName(attributeKey);
          const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
          result[attrName] = accessor;
        }
        return result;
      }
      _addIndices(indices) {
        return this.addBinaryBuffer(indices, {
          size: 1
        });
      }
      _getGltfAttributeName(attributeName) {
        switch (attributeName.toLowerCase()) {
          case "position":
          case "positions":
          case "vertices":
            return "POSITION";
          case "normal":
          case "normals":
            return "NORMAL";
          case "color":
          case "colors":
            return "COLOR_0";
          case "texcoord":
          case "texcoords":
            return "TEXCOORD_0";
          default:
            return attributeName;
        }
      }
      _getAccessorMinMax(buffer, size) {
        const result = {
          min: null,
          max: null
        };
        if (buffer.length < size) {
          return result;
        }
        result.min = [];
        result.max = [];
        const initValues = buffer.subarray(0, size);
        for (const value of initValues) {
          result.min.push(value);
          result.max.push(value);
        }
        for (let index = size; index < buffer.length; index += size) {
          for (let componentIndex = 0; componentIndex < size; componentIndex++) {
            result.min[0 + componentIndex] = Math.min(
              result.min[0 + componentIndex],
              buffer[index + componentIndex]
            );
            result.max[0 + componentIndex] = Math.max(
              result.max[0 + componentIndex],
              buffer[index + componentIndex]
            );
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/meshopt/meshopt-decoder.js
async function meshoptDecodeGltfBuffer(target, count, size, source, mode) {
  let filter = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
  const instance = await loadWasmInstance();
  decode(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || "NONE"]]);
}
async function loadWasmInstance() {
  if (!wasmPromise) {
    wasmPromise = loadWasmModule();
  }
  return wasmPromise;
}
async function loadWasmModule() {
  let wasm = wasm_base;
  if (WebAssembly.validate(detector)) {
    wasm = wasm_simd;
    console.log("Warning: meshopt_decoder is using experimental SIMD support");
  }
  const result = await WebAssembly.instantiate(unpack(wasm), {});
  await result.instance.exports.__wasm_call_ctors();
  return result.instance;
}
function unpack(data) {
  const result = new Uint8Array(data.length);
  for (let i3 = 0; i3 < data.length; ++i3) {
    const ch = data.charCodeAt(i3);
    result[i3] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
  }
  let write = 0;
  for (let i3 = 0; i3 < data.length; ++i3) {
    result[write++] = result[i3] < 60 ? wasmpack[result[i3]] : (result[i3] - 60) * 64 + result[++i3];
  }
  return result.buffer.slice(0, write);
}
function decode(instance, fun, target, count, size, source, filter) {
  const sbrk = instance.exports.sbrk;
  const count4 = count + 3 & ~3;
  const tp = sbrk(count4 * size);
  const sp = sbrk(source.length);
  const heap = new Uint8Array(instance.exports.memory.buffer);
  heap.set(source, sp);
  const res = fun(tp, count, size, sp, source.length);
  if (res === 0 && filter) {
    filter(tp, count4, size);
  }
  target.set(heap.subarray(tp, tp + count * size));
  sbrk(tp - sbrk(0));
  if (res !== 0) {
    throw new Error("Malformed buffer data: ".concat(res));
  }
}
var wasm_base, wasm_simd, detector, wasmpack, FILTERS, DECODERS, wasmPromise;
var init_meshopt_decoder = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/meshopt/meshopt-decoder.js"() {
    wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
    wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
    detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
    wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
    FILTERS = {
      0: "",
      1: "meshopt_decodeFilterOct",
      2: "meshopt_decodeFilterQuat",
      3: "meshopt_decodeFilterExp",
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp"
    };
    DECODERS = {
      0: "meshopt_decodeVertexBuffer",
      1: "meshopt_decodeIndexBuffer",
      2: "meshopt_decodeIndexSequence",
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence"
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js
var EXT_meshopt_compression_exports = {};
__export(EXT_meshopt_compression_exports, {
  decode: () => decode2,
  name: () => name
});
async function decode2(gltfData, options) {
  var _options$gltf;
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
    return;
  }
  const promises = [];
  for (const bufferViewIndex of gltfData.json.bufferViews || []) {
    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
  }
  await Promise.all(promises);
  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
}
async function decodeMeshoptBufferView(scenegraph, bufferView) {
  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  if (meshoptExtension) {
    const {
      byteOffset = 0,
      byteLength = 0,
      byteStride,
      count,
      mode,
      filter = "NONE",
      buffer: bufferIndex
    } = meshoptExtension;
    const buffer = scenegraph.gltf.buffers[bufferIndex];
    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
    const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);
    return result;
  }
  return null;
}
var EXT_MESHOPT_COMPRESSION, name;
var init_EXT_meshopt_compression = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js"() {
    init_gltf_scenegraph();
    init_meshopt_decoder();
    EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
    name = EXT_MESHOPT_COMPRESSION;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_texture_webp.js
var EXT_texture_webp_exports = {};
__export(EXT_texture_webp_exports, {
  name: () => name2,
  preprocess: () => preprocess
});
function preprocess(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!_isImageFormatSupported("image/webp")) {
    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
      throw new Error("gltf: Required extension ".concat(EXT_TEXTURE_WEBP, " not supported by browser"));
    }
    return;
  }
  const {
    json
  } = scenegraph;
  for (const texture of json.textures || []) {
    const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
    if (extension) {
      texture.source = extension.source;
    }
    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
  }
  scenegraph.removeExtension(EXT_TEXTURE_WEBP);
}
var EXT_TEXTURE_WEBP, name2;
var init_EXT_texture_webp = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_texture_webp.js"() {
    init_esm5();
    init_gltf_scenegraph();
    EXT_TEXTURE_WEBP = "EXT_texture_webp";
    name2 = EXT_TEXTURE_WEBP;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_basisu.js
var KHR_texture_basisu_exports = {};
__export(KHR_texture_basisu_exports, {
  name: () => name3,
  preprocess: () => preprocess2
});
function preprocess2(gltfData, options) {
  const scene = new GLTFScenegraph(gltfData);
  const {
    json
  } = scene;
  for (const texture of json.textures || []) {
    const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
    if (extension) {
      texture.source = extension.source;
    }
    scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
  }
  scene.removeExtension(KHR_TEXTURE_BASISU);
}
var KHR_TEXTURE_BASISU, name3;
var init_KHR_texture_basisu = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_basisu.js"() {
    init_gltf_scenegraph();
    KHR_TEXTURE_BASISU = "KHR_texture_basisu";
    name3 = KHR_TEXTURE_BASISU;
  }
});

// node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js
var VERSION7;
var init_version3 = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js"() {
    VERSION7 = true ? "3.3.3" : "latest";
  }
});

// node_modules/@loaders.gl/draco/dist/esm/draco-loader.js
var DEFAULT_DRACO_OPTIONS, DracoLoader;
var init_draco_loader = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/draco-loader.js"() {
    init_esm();
    init_version3();
    DEFAULT_DRACO_OPTIONS = {
      draco: {
        decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
        libraryPath: "libs/",
        extraAttributes: {},
        attributeNameEntry: void 0
      }
    };
    DracoLoader = {
      name: "Draco",
      id: isBrowser ? "draco" : "draco-nodejs",
      module: "draco",
      shapes: ["mesh"],
      version: VERSION7,
      worker: true,
      extensions: ["drc"],
      mimeTypes: ["application/octet-stream"],
      binary: true,
      tests: ["DRACO"],
      options: DEFAULT_DRACO_OPTIONS
    };
  }
});

// node_modules/@loaders.gl/draco/dist/esm/lib/utils/get-draco-schema.js
function getDracoSchema(attributes, loaderData, indices) {
  const metadataMap = makeMetadata(loaderData.metadata);
  const fields = [];
  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
    fields.push(field);
  }
  if (indices) {
    const indicesField = getArrowFieldFromAttribute("indices", indices);
    fields.push(indicesField);
  }
  return new Schema(fields, metadataMap);
}
function transformAttributesLoaderData(loaderData) {
  const result = {};
  for (const key in loaderData) {
    const dracoAttribute = loaderData[key];
    result[dracoAttribute.name || "undefined"] = dracoAttribute;
  }
  return result;
}
function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
  const field = deduceMeshField(attributeName, attribute, metadataMap);
  return field;
}
function makeMetadata(metadata) {
  const metadataMap = /* @__PURE__ */ new Map();
  for (const key in metadata) {
    metadataMap.set("".concat(key, ".string"), JSON.stringify(metadata[key]));
  }
  return metadataMap;
}
var init_get_draco_schema = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/lib/utils/get-draco-schema.js"() {
    init_esm19();
    init_esm19();
  }
});

// node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js
function getDracoDataType(draco, attributeType) {
  switch (attributeType) {
    case Float32Array:
      return draco.DT_FLOAT32;
    case Int8Array:
      return draco.DT_INT8;
    case Int16Array:
      return draco.DT_INT16;
    case Int32Array:
      return draco.DT_INT32;
    case Uint8Array:
      return draco.DT_UINT8;
    case Uint16Array:
      return draco.DT_UINT16;
    case Uint32Array:
      return draco.DT_UINT32;
    default:
      return draco.DT_INVALID;
  }
}
function getInt32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i3 = 0; i3 < numValues; i3++) {
    intArray[i3] = dracoArray.GetValue(i3);
  }
  return intArray;
}
function getUint32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i3 = 0; i3 < numValues; i3++) {
    intArray[i3] = dracoArray.GetValue(i3);
  }
  return intArray;
}
var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP, DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP, INDEX_ITEM_SIZE, DracoParser;
var init_draco_parser = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js"() {
    init_defineProperty();
    init_esm19();
    init_get_draco_schema();
    DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
      POSITION: "POSITION",
      NORMAL: "NORMAL",
      COLOR: "COLOR_0",
      TEX_COORD: "TEXCOORD_0"
    };
    DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
      1: Int8Array,
      2: Uint8Array,
      3: Int16Array,
      4: Uint16Array,
      5: Int32Array,
      6: Uint32Array,
      9: Float32Array
    };
    INDEX_ITEM_SIZE = 4;
    DracoParser = class {
      constructor(draco) {
        _defineProperty(this, "draco", void 0);
        _defineProperty(this, "decoder", void 0);
        _defineProperty(this, "metadataQuerier", void 0);
        this.draco = draco;
        this.decoder = new this.draco.Decoder();
        this.metadataQuerier = new this.draco.MetadataQuerier();
      }
      destroy() {
        this.draco.destroy(this.decoder);
        this.draco.destroy(this.metadataQuerier);
      }
      parseSync(arrayBuffer) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const buffer = new this.draco.DecoderBuffer();
        buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
        this._disableAttributeTransforms(options);
        const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
        const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
        try {
          let dracoStatus;
          switch (geometry_type) {
            case this.draco.TRIANGULAR_MESH:
              dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
              break;
            case this.draco.POINT_CLOUD:
              dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
              break;
            default:
              throw new Error("DRACO: Unknown geometry type.");
          }
          if (!dracoStatus.ok() || !dracoGeometry.ptr) {
            const message = "DRACO decompression failed: ".concat(dracoStatus.error_msg());
            throw new Error(message);
          }
          const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
          const geometry = this._getMeshData(dracoGeometry, loaderData, options);
          const boundingBox = getMeshBoundingBox(geometry.attributes);
          const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
          const data = {
            loader: "draco",
            loaderData,
            header: {
              vertexCount: dracoGeometry.num_points(),
              boundingBox
            },
            ...geometry,
            schema
          };
          return data;
        } finally {
          this.draco.destroy(buffer);
          if (dracoGeometry) {
            this.draco.destroy(dracoGeometry);
          }
        }
      }
      _getDracoLoaderData(dracoGeometry, geometry_type, options) {
        const metadata = this._getTopLevelMetadata(dracoGeometry);
        const attributes = this._getDracoAttributes(dracoGeometry, options);
        return {
          geometry_type,
          num_attributes: dracoGeometry.num_attributes(),
          num_points: dracoGeometry.num_points(),
          num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
          metadata,
          attributes
        };
      }
      _getDracoAttributes(dracoGeometry, options) {
        const dracoAttributes = {};
        for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
          const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
          const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
          dracoAttributes[dracoAttribute.unique_id()] = {
            unique_id: dracoAttribute.unique_id(),
            attribute_type: dracoAttribute.attribute_type(),
            data_type: dracoAttribute.data_type(),
            num_components: dracoAttribute.num_components(),
            byte_offset: dracoAttribute.byte_offset(),
            byte_stride: dracoAttribute.byte_stride(),
            normalized: dracoAttribute.normalized(),
            attribute_index: attributeId,
            metadata
          };
          const quantization = this._getQuantizationTransform(dracoAttribute, options);
          if (quantization) {
            dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
          }
          const octahedron = this._getOctahedronTransform(dracoAttribute, options);
          if (octahedron) {
            dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
          }
        }
        return dracoAttributes;
      }
      _getMeshData(dracoGeometry, loaderData, options) {
        const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
        const positionAttribute = attributes.POSITION;
        if (!positionAttribute) {
          throw new Error("DRACO: No position attribute found.");
        }
        if (dracoGeometry instanceof this.draco.Mesh) {
          switch (options.topology) {
            case "triangle-strip":
              return {
                topology: "triangle-strip",
                mode: 4,
                attributes,
                indices: {
                  value: this._getTriangleStripIndices(dracoGeometry),
                  size: 1
                }
              };
            case "triangle-list":
            default:
              return {
                topology: "triangle-list",
                mode: 5,
                attributes,
                indices: {
                  value: this._getTriangleListIndices(dracoGeometry),
                  size: 1
                }
              };
          }
        }
        return {
          topology: "point-list",
          mode: 0,
          attributes
        };
      }
      _getMeshAttributes(loaderData, dracoGeometry, options) {
        const attributes = {};
        for (const loaderAttribute of Object.values(loaderData.attributes)) {
          const attributeName = this._deduceAttributeName(loaderAttribute, options);
          loaderAttribute.name = attributeName;
          const {
            value,
            size
          } = this._getAttributeValues(dracoGeometry, loaderAttribute);
          attributes[attributeName] = {
            value,
            size,
            byteOffset: loaderAttribute.byte_offset,
            byteStride: loaderAttribute.byte_stride,
            normalized: loaderAttribute.normalized
          };
        }
        return attributes;
      }
      _getTriangleListIndices(dracoGeometry) {
        const numFaces = dracoGeometry.num_faces();
        const numIndices = numFaces * 3;
        const byteLength = numIndices * INDEX_ITEM_SIZE;
        const ptr = this.draco._malloc(byteLength);
        try {
          this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
          return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
        } finally {
          this.draco._free(ptr);
        }
      }
      _getTriangleStripIndices(dracoGeometry) {
        const dracoArray = new this.draco.DracoInt32Array();
        try {
          this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
          return getUint32Array(dracoArray);
        } finally {
          this.draco.destroy(dracoArray);
        }
      }
      _getAttributeValues(dracoGeometry, attribute) {
        const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
        const numComponents = attribute.num_components;
        const numPoints = dracoGeometry.num_points();
        const numValues = numPoints * numComponents;
        const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
        const dataType = getDracoDataType(this.draco, TypedArrayCtor);
        let value;
        const ptr = this.draco._malloc(byteLength);
        try {
          const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
          this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
          value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
        } finally {
          this.draco._free(ptr);
        }
        return {
          value,
          size: numComponents
        };
      }
      _deduceAttributeName(attribute, options) {
        const uniqueId = attribute.unique_id;
        for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
          if (attributeUniqueId === uniqueId) {
            return attributeName;
          }
        }
        const thisAttributeType = attribute.attribute_type;
        for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
          const attributeType = this.draco[dracoAttributeConstant];
          if (attributeType === thisAttributeType) {
            return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
          }
        }
        const entryName = options.attributeNameEntry || "name";
        if (attribute.metadata[entryName]) {
          return attribute.metadata[entryName].string;
        }
        return "CUSTOM_ATTRIBUTE_".concat(uniqueId);
      }
      _getTopLevelMetadata(dracoGeometry) {
        const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
        return this._getDracoMetadata(dracoMetadata);
      }
      _getAttributeMetadata(dracoGeometry, attributeId) {
        const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
        return this._getDracoMetadata(dracoMetadata);
      }
      _getDracoMetadata(dracoMetadata) {
        if (!dracoMetadata || !dracoMetadata.ptr) {
          return {};
        }
        const result = {};
        const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
        for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
          const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
          result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
        }
        return result;
      }
      _getDracoMetadataField(dracoMetadata, entryName) {
        const dracoArray = new this.draco.DracoInt32Array();
        try {
          this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
          const intArray = getInt32Array(dracoArray);
          return {
            int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
            string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
            double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
            intArray
          };
        } finally {
          this.draco.destroy(dracoArray);
        }
      }
      _disableAttributeTransforms(options) {
        const {
          quantizedAttributes = [],
          octahedronAttributes = []
        } = options;
        const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
        for (const dracoAttributeName of skipAttributes) {
          this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
        }
      }
      _getQuantizationTransform(dracoAttribute, options) {
        const {
          quantizedAttributes = []
        } = options;
        const attribute_type = dracoAttribute.attribute_type();
        const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
        if (skip) {
          const transform2 = new this.draco.AttributeQuantizationTransform();
          try {
            if (transform2.InitFromAttribute(dracoAttribute)) {
              return {
                quantization_bits: transform2.quantization_bits(),
                range: transform2.range(),
                min_values: new Float32Array([1, 2, 3]).map((i3) => transform2.min_value(i3))
              };
            }
          } finally {
            this.draco.destroy(transform2);
          }
        }
        return null;
      }
      _getOctahedronTransform(dracoAttribute, options) {
        const {
          octahedronAttributes = []
        } = options;
        const attribute_type = dracoAttribute.attribute_type();
        const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
        if (octahedron) {
          const transform2 = new this.draco.AttributeQuantizationTransform();
          try {
            if (transform2.InitFromAttribute(dracoAttribute)) {
              return {
                quantization_bits: transform2.quantization_bits()
              };
            }
          } finally {
            this.draco.destroy(transform2);
          }
        }
        return null;
      }
    };
  }
});

// node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js
async function loadDracoDecoderModule(options) {
  const modules = options.modules || {};
  if (modules.draco3d) {
    loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then((draco) => {
      return {
        draco
      };
    });
  } else {
    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);
  }
  return await loadDecoderPromise;
}
async function loadDracoDecoder(options) {
  let DracoDecoderModule;
  let wasmBinary;
  switch (options.draco && options.draco.decoderType) {
    case "js":
      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, "draco", options);
      break;
    case "wasm":
    default:
      [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_WASM_WRAPPER_URL, "draco", options), await loadLibrary(DRACO_WASM_DECODER_URL, "draco", options)]);
  }
  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
}
function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    DracoDecoderModule({
      ...options,
      onModuleLoaded: (draco) => resolve({
        draco
      })
    });
  });
}
var DRACO_DECODER_VERSION, DRACO_ENCODER_VERSION, STATIC_DECODER_URL, DRACO_JS_DECODER_URL, DRACO_WASM_WRAPPER_URL, DRACO_WASM_DECODER_URL, DRACO_ENCODER_URL, loadDecoderPromise;
var init_draco_module_loader = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js"() {
    init_esm();
    DRACO_DECODER_VERSION = "1.5.5";
    DRACO_ENCODER_VERSION = "1.4.1";
    STATIC_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_DECODER_VERSION);
    DRACO_JS_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.js");
    DRACO_WASM_WRAPPER_URL = "".concat(STATIC_DECODER_URL, "/draco_wasm_wrapper.js");
    DRACO_WASM_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.wasm");
    DRACO_ENCODER_URL = "https://raw.githubusercontent.com/google/draco/".concat(DRACO_ENCODER_VERSION, "/javascript/draco_encoder.js");
  }
});

// node_modules/@loaders.gl/draco/dist/esm/lib/draco-builder.js
var init_draco_builder = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/lib/draco-builder.js"() {
    init_defineProperty();
  }
});

// node_modules/@loaders.gl/draco/dist/esm/draco-writer.js
var init_draco_writer = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/draco-writer.js"() {
    init_draco_builder();
    init_draco_module_loader();
    init_version3();
  }
});

// node_modules/@loaders.gl/draco/dist/esm/index.js
async function parse(arrayBuffer, options) {
  const {
    draco
  } = await loadDracoDecoderModule(options);
  const dracoParser = new DracoParser(draco);
  try {
    return dracoParser.parseSync(arrayBuffer, options === null || options === void 0 ? void 0 : options.draco);
  } finally {
    dracoParser.destroy();
  }
}
var DracoLoader2;
var init_esm22 = __esm({
  "node_modules/@loaders.gl/draco/dist/esm/index.js"() {
    init_draco_loader();
    init_draco_parser();
    init_draco_module_loader();
    init_version3();
    init_esm();
    init_draco_writer();
    DracoLoader2 = {
      ...DracoLoader,
      parse
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js
function getGLTFAccessors(attributes) {
  const accessors = {};
  for (const name10 in attributes) {
    const attribute = attributes[name10];
    if (name10 !== "indices") {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name10] = glTFAccessor;
    }
  }
  return accessors;
}
function getGLTFAccessor(attribute) {
  const {
    buffer,
    size,
    count
  } = getAccessorData(attribute);
  const glTFAccessor = {
    value: buffer,
    size,
    byteOffset: 0,
    count,
    type: getAccessorTypeFromSize(size),
    componentType: getComponentTypeFromArray(buffer)
  };
  return glTFAccessor;
}
function getAccessorData(attribute) {
  let buffer = attribute;
  let size = 1;
  let count = 0;
  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }
  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }
    count = buffer.length / size;
  }
  return {
    buffer,
    size,
    count
  };
}
function toTypedArray(array, ArrayType) {
  let convertTypedArrays = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (!array) {
    return null;
  }
  if (Array.isArray(array)) {
    return new ArrayType(array);
  }
  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }
  return array;
}
var init_gltf_attribute_utils = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js"() {
    init_gltf_utils();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js
var KHR_draco_mesh_compression_exports = {};
__export(KHR_draco_mesh_compression_exports, {
  decode: () => decode3,
  encode: () => encode,
  name: () => name4,
  preprocess: () => preprocess3
});
function preprocess3(gltfData, options, context) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
    }
  }
}
async function decode3(gltfData, options, context) {
  var _options$gltf;
  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
    return;
  }
  const scenegraph = new GLTFScenegraph(gltfData);
  const promises = [];
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      promises.push(decompressPrimitive(scenegraph, primitive, options, context));
    }
  }
  await Promise.all(promises);
  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
}
function encode(gltfData) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const mesh of scenegraph.json.meshes || []) {
    compressMesh(mesh, options);
    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
  }
}
async function decompressPrimitive(scenegraph, primitive, options, context) {
  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  if (!dracoExtension) {
    return;
  }
  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
  const {
    parse: parse4
  } = context;
  const dracoOptions = {
    ...options
  };
  delete dracoOptions["3d-tiles"];
  const decodedData = await parse4(bufferCopy, DracoLoader2, dracoOptions, context);
  const decodedAttributes = getGLTFAccessors(decodedData.attributes);
  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
    if (attributeName in primitive.attributes) {
      const accessorIndex = primitive.attributes[attributeName];
      const accessor = scenegraph.getAccessor(accessorIndex);
      if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {
        decodedAttribute.min = accessor.min;
        decodedAttribute.max = accessor.max;
      }
    }
  }
  primitive.attributes = decodedAttributes;
  if (decodedData.indices) {
    primitive.indices = getGLTFAccessor(decodedData.indices);
  }
  checkPrimitive(primitive);
}
function compressMesh(attributes, indices) {
  var _context$parseSync;
  let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4;
  let options = arguments.length > 3 ? arguments[3] : void 0;
  let context = arguments.length > 4 ? arguments[4] : void 0;
  if (!options.DracoWriter) {
    throw new Error("options.gltf.DracoWriter not provided");
  }
  const compressedData = options.DracoWriter.encodeSync({
    attributes
  });
  const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {
    attributes
  });
  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
  const bufferViewIndex = options.addBufferView(compressedData);
  const glTFMesh = {
    primitives: [{
      attributes: fauxAccessors,
      mode,
      extensions: {
        [KHR_DRACO_MESH_COMPRESSION]: {
          bufferView: bufferViewIndex,
          attributes: fauxAccessors
        }
      }
    }]
  };
  return glTFMesh;
}
function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
  }
}
function* makeMeshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}
var KHR_DRACO_MESH_COMPRESSION, name4;
var init_KHR_draco_mesh_compression = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js"() {
    init_esm22();
    init_esm3();
    init_gltf_scenegraph();
    init_gltf_attribute_utils();
    KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
    name4 = KHR_DRACO_MESH_COMPRESSION;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js
var COMPONENTS, BYTES;
var init_gltf_constants = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js"() {
    COMPONENTS = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    };
    BYTES = {
      5120: 1,
      5121: 1,
      5122: 2,
      5123: 2,
      5125: 4,
      5126: 4
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js
var KHR_texture_transform_exports = {};
__export(KHR_texture_transform_exports, {
  decode: () => decode4,
  name: () => name5
});
async function decode4(gltfData, options) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);
  if (!extension) {
    return;
  }
  const materials = gltfData.json.materials || [];
  for (let i3 = 0; i3 < materials.length; i3++) {
    transformTexCoords(i3, gltfData);
  }
}
function transformTexCoords(materialIndex, gltfData) {
  var _gltfData$json$materi, _material$pbrMetallic, _material$pbrMetallic2;
  const processedTexCoords = [];
  const material = (_gltfData$json$materi = gltfData.json.materials) === null || _gltfData$json$materi === void 0 ? void 0 : _gltfData$json$materi[materialIndex];
  const baseColorTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic = material.pbrMetallicRoughness) === null || _material$pbrMetallic === void 0 ? void 0 : _material$pbrMetallic.baseColorTexture;
  if (baseColorTexture) {
    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);
  }
  const emisiveTexture = material === null || material === void 0 ? void 0 : material.emissiveTexture;
  if (emisiveTexture) {
    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);
  }
  const normalTexture = material === null || material === void 0 ? void 0 : material.normalTexture;
  if (normalTexture) {
    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);
  }
  const occlusionTexture = material === null || material === void 0 ? void 0 : material.occlusionTexture;
  if (occlusionTexture) {
    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);
  }
  const metallicRoughnessTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic2 = material.pbrMetallicRoughness) === null || _material$pbrMetallic2 === void 0 ? void 0 : _material$pbrMetallic2.metallicRoughnessTexture;
  if (metallicRoughnessTexture) {
    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);
  }
}
function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
  const transformParameters = getTransformParameters(texture, processedTexCoords);
  if (!transformParameters) {
    return;
  }
  const meshes = gltfData.json.meshes || [];
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      const material = primitive.material;
      if (Number.isFinite(material) && materialIndex === material) {
        transformPrimitive(gltfData, primitive, transformParameters);
      }
    }
  }
}
function getTransformParameters(texture, processedTexCoords) {
  var _texture$extensions;
  const textureInfo = (_texture$extensions = texture.extensions) === null || _texture$extensions === void 0 ? void 0 : _texture$extensions[EXT_MESHOPT_TRANSFORM];
  const {
    texCoord: originalTexCoord = 0
  } = texture;
  const {
    texCoord = originalTexCoord
  } = textureInfo;
  const isProcessed = processedTexCoords.findIndex((_ref) => {
    let [original, newTexCoord] = _ref;
    return original === originalTexCoord && newTexCoord === texCoord;
  }) !== -1;
  if (!isProcessed) {
    const matrix = makeTransformationMatrix(textureInfo);
    if (originalTexCoord !== texCoord) {
      texture.texCoord = texCoord;
    }
    processedTexCoords.push([originalTexCoord, texCoord]);
    return {
      originalTexCoord,
      texCoord,
      matrix
    };
  }
  return null;
}
function transformPrimitive(gltfData, primitive, transformParameters) {
  const {
    originalTexCoord,
    texCoord,
    matrix
  } = transformParameters;
  const texCoordAccessor = primitive.attributes["TEXCOORD_".concat(originalTexCoord)];
  if (Number.isFinite(texCoordAccessor)) {
    var _gltfData$json$access;
    const accessor = (_gltfData$json$access = gltfData.json.accessors) === null || _gltfData$json$access === void 0 ? void 0 : _gltfData$json$access[texCoordAccessor];
    if (accessor && accessor.bufferView) {
      var _gltfData$json$buffer;
      const bufferView = (_gltfData$json$buffer = gltfData.json.bufferViews) === null || _gltfData$json$buffer === void 0 ? void 0 : _gltfData$json$buffer[accessor.bufferView];
      if (bufferView) {
        const {
          arrayBuffer,
          byteOffset: bufferByteOffset
        } = gltfData.buffers[bufferView.buffer];
        const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
        const {
          ArrayType,
          length: length3
        } = getAccessorArrayTypeAndLength(accessor, bufferView);
        const bytes = BYTES[accessor.componentType];
        const components = COMPONENTS[accessor.type];
        const elementAddressScale = bufferView.byteStride || bytes * components;
        const result = new Float32Array(length3);
        for (let i3 = 0; i3 < accessor.count; i3++) {
          const uv = new ArrayType(arrayBuffer, byteOffset + i3 * elementAddressScale, 2);
          scratchVector7.set(uv[0], uv[1], 1);
          scratchVector7.transformByMatrix3(matrix);
          result.set([scratchVector7[0], scratchVector7[1]], i3 * components);
        }
        if (originalTexCoord === texCoord) {
          updateGltf(accessor, bufferView, gltfData.buffers, result);
        } else {
          createAttribute(texCoord, accessor, primitive, gltfData, result);
        }
      }
    }
  }
}
function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
  accessor.componentType = 5126;
  buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  bufferView.buffer = buffers.length - 1;
  bufferView.byteLength = newTexCoordArray.buffer.byteLength;
  bufferView.byteOffset = 0;
  delete bufferView.byteStride;
}
function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
  gltfData.buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  const bufferViews = gltfData.json.bufferViews;
  if (!bufferViews) {
    return;
  }
  bufferViews.push({
    buffer: gltfData.buffers.length - 1,
    byteLength: newTexCoordArray.buffer.byteLength,
    byteOffset: 0
  });
  const accessors = gltfData.json.accessors;
  if (!accessors) {
    return;
  }
  accessors.push({
    bufferView: (bufferViews === null || bufferViews === void 0 ? void 0 : bufferViews.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: originalAccessor.count,
    type: "VEC2"
  });
  primitive.attributes["TEXCOORD_".concat(newTexCoord)] = accessors.length - 1;
}
function makeTransformationMatrix(extensionData) {
  const {
    offset = [0, 0],
    rotation = 0,
    scale = [1, 1]
  } = extensionData;
  const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
  const rotationMatirx = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);
  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);
}
var EXT_MESHOPT_TRANSFORM, name5, scratchVector7, scratchRotationMatrix, scratchScaleMatrix;
var init_KHR_texture_transform = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js"() {
    init_esm8();
    init_gltf_utils();
    init_gltf_constants();
    init_gltf_scenegraph();
    EXT_MESHOPT_TRANSFORM = "KHR_texture_transform";
    name5 = EXT_MESHOPT_TRANSFORM;
    scratchVector7 = new Vector3();
    scratchRotationMatrix = new Matrix3();
    scratchScaleMatrix = new Matrix3();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_lights_punctual.js
var KHR_lights_punctual_exports = {};
__export(KHR_lights_punctual_exports, {
  decode: () => decode5,
  encode: () => encode2,
  name: () => name6
});
async function decode5(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const {
    json
  } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
  if (extension) {
    gltfScenegraph.json.lights = extension.lights;
    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
  }
  for (const node of json.nodes || []) {
    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
    if (nodeExtension) {
      node.light = nodeExtension.light;
    }
    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
  }
}
async function encode2(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const {
    json
  } = gltfScenegraph;
  if (json.lights) {
    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
    assert6(!extension.lights);
    extension.lights = json.lights;
    delete json.lights;
  }
  if (gltfScenegraph.json.lights) {
    for (const light of gltfScenegraph.json.lights) {
      const node = light.node;
      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);
    }
    delete gltfScenegraph.json.lights;
  }
}
var KHR_LIGHTS_PUNCTUAL, name6;
var init_KHR_lights_punctual = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_lights_punctual.js"() {
    init_assert2();
    init_gltf_scenegraph();
    KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
    name6 = KHR_LIGHTS_PUNCTUAL;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_materials_unlit.js
var KHR_materials_unlit_exports = {};
__export(KHR_materials_unlit_exports, {
  decode: () => decode6,
  encode: () => encode3,
  name: () => name7
});
async function decode6(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const {
    json
  } = gltfScenegraph;
  for (const material of json.materials || []) {
    const extension = material.extensions && material.extensions.KHR_materials_unlit;
    if (extension) {
      material.unlit = true;
    }
    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
  }
  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
}
function encode3(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const {
    json
  } = gltfScenegraph;
  if (gltfScenegraph.materials) {
    for (const material of json.materials || []) {
      if (material.unlit) {
        delete material.unlit;
        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
      }
    }
  }
}
var KHR_MATERIALS_UNLIT, name7;
var init_KHR_materials_unlit = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_materials_unlit.js"() {
    init_gltf_scenegraph();
    KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
    name7 = KHR_MATERIALS_UNLIT;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_techniques_webgl.js
var KHR_techniques_webgl_exports = {};
__export(KHR_techniques_webgl_exports, {
  decode: () => decode7,
  encode: () => encode4,
  name: () => name8
});
async function decode7(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const {
    json
  } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
  if (extension) {
    const techniques = resolveTechniques(extension, gltfScenegraph);
    for (const material of json.materials || []) {
      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      if (materialExtension) {
        material.technique = Object.assign(
          {},
          materialExtension,
          techniques[materialExtension.technique]
        );
        material.technique.values = resolveValues(material.technique, gltfScenegraph);
      }
      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
    }
    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
  }
}
async function encode4(gltfData, options) {
}
function resolveTechniques(techniquesExtension, gltfScenegraph) {
  const {
    programs = [],
    shaders = [],
    techniques = []
  } = techniquesExtension;
  const textDecoder = new TextDecoder();
  shaders.forEach((shader) => {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
    } else {
      throw new Error("KHR_techniques_webgl: no shader code");
    }
  });
  programs.forEach((program) => {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });
  techniques.forEach((technique) => {
    technique.program = programs[technique.program];
  });
  return techniques;
}
function resolveValues(technique, gltfScenegraph) {
  const values = Object.assign({}, technique.values);
  Object.keys(technique.uniforms || {}).forEach((uniform) => {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });
  Object.keys(values).forEach((uniform) => {
    if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });
  return values;
}
var KHR_TECHNIQUES_WEBGL, name8;
var init_KHR_techniques_webgl = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_techniques_webgl.js"() {
    init_gltf_scenegraph();
    KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
    name8 = KHR_TECHNIQUES_WEBGL;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/EXT_feature_metadata.js
var EXT_feature_metadata_exports = {};
__export(EXT_feature_metadata_exports, {
  decode: () => decode8,
  name: () => name9
});
async function decode8(gltfData) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtFeatureMetadata(scenegraph);
}
function decodeExtFeatureMetadata(scenegraph) {
  var _extension$schema;
  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA);
  const schemaClasses = extension === null || extension === void 0 ? void 0 : (_extension$schema = extension.schema) === null || _extension$schema === void 0 ? void 0 : _extension$schema.classes;
  const featureTables = extension === null || extension === void 0 ? void 0 : extension.featureTables;
  const featureTextures = extension === null || extension === void 0 ? void 0 : extension.featureTextures;
  if (featureTextures) {
    console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.');
  }
  if (schemaClasses && featureTables) {
    for (const schemaName in schemaClasses) {
      const schemaClass = schemaClasses[schemaName];
      const featureTable = findFeatureTableByName(featureTables, schemaName);
      if (featureTable) {
        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);
      }
    }
  }
}
function handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {
  for (const propertyName in schemaClass.properties) {
    var _featureTable$propert;
    const schemaProperty = schemaClass.properties[propertyName];
    const featureTableProperty = featureTable === null || featureTable === void 0 ? void 0 : (_featureTable$propert = featureTable.properties) === null || _featureTable$propert === void 0 ? void 0 : _featureTable$propert[propertyName];
    const numberOfFeatures = featureTable.count;
    if (featureTableProperty) {
      const data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);
      featureTableProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {
  const bufferView = featureTableProperty.bufferView;
  let data = scenegraph.getTypedArrayForBufferView(bufferView);
  switch (schemaProperty.type) {
    case "STRING": {
      const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;
      const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);
      data = getStringAttributes(data, offsetsData, numberOfFeatures);
      break;
    }
    default:
  }
  return data;
}
function findFeatureTableByName(featureTables, schemaClassName) {
  for (const featureTableName in featureTables) {
    const featureTable = featureTables[featureTableName];
    if (featureTable.class === schemaClassName) {
      return featureTable;
    }
  }
  return null;
}
function getStringAttributes(data, offsetsData, stringsCount) {
  const stringsArray = [];
  const textDecoder = new TextDecoder("utf8");
  let stringOffset = 0;
  const bytesPerStringSize = 4;
  for (let index = 0; index < stringsCount; index++) {
    const stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];
    const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);
    const stringAttribute = textDecoder.decode(stringData);
    stringsArray.push(stringAttribute);
    stringOffset += stringByteSize;
  }
  return stringsArray;
}
var EXT_FEATURE_METADATA, name9;
var init_EXT_feature_metadata = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/EXT_feature_metadata.js"() {
    init_gltf_scenegraph();
    EXT_FEATURE_METADATA = "EXT_feature_metadata";
    name9 = EXT_FEATURE_METADATA;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-extensions.js
function preprocessExtensions(gltf) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let context = arguments.length > 2 ? arguments[2] : void 0;
  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    var _extension$preprocess;
    (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);
  }
}
async function decodeExtensions(gltf) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let context = arguments.length > 2 ? arguments[2] : void 0;
  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    var _extension$decode;
    await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));
  }
}
function useExtension(extensionName, options) {
  var _options$gltf;
  const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};
  const exclude = extensionName in excludes && !excludes[extensionName];
  return !exclude;
}
var EXTENSIONS;
var init_gltf_extensions = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-extensions.js"() {
    init_EXT_meshopt_compression();
    init_EXT_texture_webp();
    init_KHR_texture_basisu();
    init_KHR_draco_mesh_compression();
    init_KHR_texture_transform();
    init_KHR_lights_punctual();
    init_KHR_materials_unlit();
    init_KHR_techniques_webgl();
    init_EXT_feature_metadata();
    EXTENSIONS = [
      EXT_meshopt_compression_exports,
      EXT_texture_webp_exports,
      KHR_texture_basisu_exports,
      KHR_draco_mesh_compression_exports,
      KHR_lights_punctual_exports,
      KHR_materials_unlit_exports,
      KHR_techniques_webgl_exports,
      KHR_texture_transform_exports,
      EXT_feature_metadata_exports
    ];
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js
function preprocess4(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const {
    json
  } = gltfScenegraph;
  for (const image of json.images || []) {
    const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
    if (extension) {
      Object.assign(image, extension);
    }
    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
  }
  if (json.buffers && json.buffers[0]) {
    delete json.buffers[0].uri;
  }
  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
}
var KHR_BINARY_GLTF;
var init_KHR_binary_gltf = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js"() {
    init_gltf_scenegraph();
    KHR_BINARY_GLTF = "KHR_binary_glTF";
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js
function normalizeGLTFV1(gltf) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new GLTFV1Normalizer().normalize(gltf, options);
}
var GLTF_ARRAYS, GLTF_KEYS, GLTFV1Normalizer;
var init_normalize_gltf_v1 = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js"() {
    init_defineProperty();
    init_KHR_binary_gltf();
    GLTF_ARRAYS = {
      accessors: "accessor",
      animations: "animation",
      buffers: "buffer",
      bufferViews: "bufferView",
      images: "image",
      materials: "material",
      meshes: "mesh",
      nodes: "node",
      samplers: "sampler",
      scenes: "scene",
      skins: "skin",
      textures: "texture"
    };
    GLTF_KEYS = {
      accessor: "accessors",
      animations: "animation",
      buffer: "buffers",
      bufferView: "bufferViews",
      image: "images",
      material: "materials",
      mesh: "meshes",
      node: "nodes",
      sampler: "samplers",
      scene: "scenes",
      skin: "skins",
      texture: "textures"
    };
    GLTFV1Normalizer = class {
      constructor() {
        _defineProperty(this, "idToIndexMap", {
          animations: {},
          accessors: {},
          buffers: {},
          bufferViews: {},
          images: {},
          materials: {},
          meshes: {},
          nodes: {},
          samplers: {},
          scenes: {},
          skins: {},
          textures: {}
        });
        _defineProperty(this, "json", void 0);
      }
      normalize(gltf, options) {
        this.json = gltf.json;
        const json = gltf.json;
        switch (json.asset && json.asset.version) {
          case "2.0":
            return;
          case void 0:
          case "1.0":
            break;
          default:
            console.warn("glTF: Unknown version ".concat(json.asset.version));
            return;
        }
        if (!options.normalize) {
          throw new Error("glTF v1 is not supported.");
        }
        console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
        this._addAsset(json);
        this._convertTopLevelObjectsToArrays(json);
        preprocess4(gltf);
        this._convertObjectIdsToArrayIndices(json);
        this._updateObjects(json);
        this._updateMaterial(json);
      }
      _addAsset(json) {
        json.asset = json.asset || {};
        json.asset.version = "2.0";
        json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
      }
      _convertTopLevelObjectsToArrays(json) {
        for (const arrayName in GLTF_ARRAYS) {
          this._convertTopLevelObjectToArray(json, arrayName);
        }
      }
      _convertTopLevelObjectToArray(json, mapName) {
        const objectMap = json[mapName];
        if (!objectMap || Array.isArray(objectMap)) {
          return;
        }
        json[mapName] = [];
        for (const id in objectMap) {
          const object = objectMap[id];
          object.id = object.id || id;
          const index = json[mapName].length;
          json[mapName].push(object);
          this.idToIndexMap[mapName][id] = index;
        }
      }
      _convertObjectIdsToArrayIndices(json) {
        for (const arrayName in GLTF_ARRAYS) {
          this._convertIdsToIndices(json, arrayName);
        }
        if ("scene" in json) {
          json.scene = this._convertIdToIndex(json.scene, "scene");
        }
        for (const texture of json.textures) {
          this._convertTextureIds(texture);
        }
        for (const mesh of json.meshes) {
          this._convertMeshIds(mesh);
        }
        for (const node of json.nodes) {
          this._convertNodeIds(node);
        }
        for (const node of json.scenes) {
          this._convertSceneIds(node);
        }
      }
      _convertTextureIds(texture) {
        if (texture.source) {
          texture.source = this._convertIdToIndex(texture.source, "image");
        }
      }
      _convertMeshIds(mesh) {
        for (const primitive of mesh.primitives) {
          const {
            attributes,
            indices,
            material
          } = primitive;
          for (const attributeName in attributes) {
            attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
          }
          if (indices) {
            primitive.indices = this._convertIdToIndex(indices, "accessor");
          }
          if (material) {
            primitive.material = this._convertIdToIndex(material, "material");
          }
        }
      }
      _convertNodeIds(node) {
        if (node.children) {
          node.children = node.children.map((child) => this._convertIdToIndex(child, "node"));
        }
        if (node.meshes) {
          node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
        }
      }
      _convertSceneIds(scene) {
        if (scene.nodes) {
          scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, "node"));
        }
      }
      _convertIdsToIndices(json, topLevelArrayName) {
        if (!json[topLevelArrayName]) {
          console.warn("gltf v1: json doesn't contain attribute ".concat(topLevelArrayName));
          json[topLevelArrayName] = [];
        }
        for (const object of json[topLevelArrayName]) {
          for (const key in object) {
            const id = object[key];
            const index = this._convertIdToIndex(id, key);
            object[key] = index;
          }
        }
      }
      _convertIdToIndex(id, key) {
        const arrayName = GLTF_KEYS[key];
        if (arrayName in this.idToIndexMap) {
          const index = this.idToIndexMap[arrayName][id];
          if (!Number.isFinite(index)) {
            throw new Error("gltf v1: failed to resolve ".concat(key, " with id ").concat(id));
          }
          return index;
        }
        return id;
      }
      _updateObjects(json) {
        for (const buffer of this.json.buffers) {
          delete buffer.type;
        }
      }
      _updateMaterial(json) {
        for (const material of json.materials) {
          var _material$values, _material$values2, _material$values3;
          material.pbrMetallicRoughness = {
            baseColorFactor: [1, 1, 1, 1],
            metallicFactor: 1,
            roughnessFactor: 1
          };
          const textureId = ((_material$values = material.values) === null || _material$values === void 0 ? void 0 : _material$values.tex) || ((_material$values2 = material.values) === null || _material$values2 === void 0 ? void 0 : _material$values2.texture2d_0) || ((_material$values3 = material.values) === null || _material$values3 === void 0 ? void 0 : _material$values3.diffuseTex);
          const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
          if (textureIndex !== -1) {
            material.pbrMetallicRoughness.baseColorTexture = {
              index: textureIndex
            };
          }
        }
      }
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js
function getBytesFromComponentType(componentType) {
  return BYTES2[componentType];
}
function getSizeFromAccessorType(type) {
  return COMPONENTS2[type];
}
function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}
var COMPONENTS2, BYTES2, GL_SAMPLER, SAMPLER_PARAMETER_GLTF_TO_GL, DEFAULT_SAMPLER, GLTFPostProcessor;
var init_post_process_gltf = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js"() {
    init_defineProperty();
    init_assert2();
    init_gltf_utils();
    COMPONENTS2 = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    };
    BYTES2 = {
      5120: 1,
      5121: 1,
      5122: 2,
      5123: 2,
      5125: 4,
      5126: 4
    };
    GL_SAMPLER = {
      TEXTURE_MAG_FILTER: 10240,
      TEXTURE_MIN_FILTER: 10241,
      TEXTURE_WRAP_S: 10242,
      TEXTURE_WRAP_T: 10243,
      REPEAT: 10497,
      LINEAR: 9729,
      NEAREST_MIPMAP_LINEAR: 9986
    };
    SAMPLER_PARAMETER_GLTF_TO_GL = {
      magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
      minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
      wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
      wrapT: GL_SAMPLER.TEXTURE_WRAP_T
    };
    DEFAULT_SAMPLER = {
      [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
      [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
      [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
      [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
    };
    GLTFPostProcessor = class {
      constructor() {
        _defineProperty(this, "baseUri", "");
        _defineProperty(this, "json", {});
        _defineProperty(this, "buffers", []);
        _defineProperty(this, "images", []);
      }
      postProcess(gltf) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          json,
          buffers = [],
          images = [],
          baseUri = ""
        } = gltf;
        assert6(json);
        this.baseUri = baseUri;
        this.json = json;
        this.buffers = buffers;
        this.images = images;
        this._resolveTree(this.json, options);
        return this.json;
      }
      _resolveTree(json) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (json.bufferViews) {
          json.bufferViews = json.bufferViews.map((bufView, i3) => this._resolveBufferView(bufView, i3));
        }
        if (json.images) {
          json.images = json.images.map((image, i3) => this._resolveImage(image, i3));
        }
        if (json.samplers) {
          json.samplers = json.samplers.map((sampler, i3) => this._resolveSampler(sampler, i3));
        }
        if (json.textures) {
          json.textures = json.textures.map((texture, i3) => this._resolveTexture(texture, i3));
        }
        if (json.accessors) {
          json.accessors = json.accessors.map((accessor, i3) => this._resolveAccessor(accessor, i3));
        }
        if (json.materials) {
          json.materials = json.materials.map((material, i3) => this._resolveMaterial(material, i3));
        }
        if (json.meshes) {
          json.meshes = json.meshes.map((mesh, i3) => this._resolveMesh(mesh, i3));
        }
        if (json.nodes) {
          json.nodes = json.nodes.map((node, i3) => this._resolveNode(node, i3));
        }
        if (json.skins) {
          json.skins = json.skins.map((skin, i3) => this._resolveSkin(skin, i3));
        }
        if (json.scenes) {
          json.scenes = json.scenes.map((scene, i3) => this._resolveScene(scene, i3));
        }
        if (json.scene !== void 0) {
          json.scene = json.scenes[this.json.scene];
        }
      }
      getScene(index) {
        return this._get("scenes", index);
      }
      getNode(index) {
        return this._get("nodes", index);
      }
      getSkin(index) {
        return this._get("skins", index);
      }
      getMesh(index) {
        return this._get("meshes", index);
      }
      getMaterial(index) {
        return this._get("materials", index);
      }
      getAccessor(index) {
        return this._get("accessors", index);
      }
      getCamera(index) {
        return null;
      }
      getTexture(index) {
        return this._get("textures", index);
      }
      getSampler(index) {
        return this._get("samplers", index);
      }
      getImage(index) {
        return this._get("images", index);
      }
      getBufferView(index) {
        return this._get("bufferViews", index);
      }
      getBuffer(index) {
        return this._get("buffers", index);
      }
      _get(array, index) {
        if (typeof index === "object") {
          return index;
        }
        const object = this.json[array] && this.json[array][index];
        if (!object) {
          console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
        }
        return object;
      }
      _resolveScene(scene, index) {
        scene.id = scene.id || "scene-".concat(index);
        scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));
        return scene;
      }
      _resolveNode(node, index) {
        node.id = node.id || "node-".concat(index);
        if (node.children) {
          node.children = node.children.map((child) => this.getNode(child));
        }
        if (node.mesh !== void 0) {
          node.mesh = this.getMesh(node.mesh);
        } else if (node.meshes !== void 0 && node.meshes.length) {
          node.mesh = node.meshes.reduce((accum, meshIndex) => {
            const mesh = this.getMesh(meshIndex);
            accum.id = mesh.id;
            accum.primitives = accum.primitives.concat(mesh.primitives);
            return accum;
          }, {
            primitives: []
          });
        }
        if (node.camera !== void 0) {
          node.camera = this.getCamera(node.camera);
        }
        if (node.skin !== void 0) {
          node.skin = this.getSkin(node.skin);
        }
        return node;
      }
      _resolveSkin(skin, index) {
        skin.id = skin.id || "skin-".concat(index);
        skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
        return skin;
      }
      _resolveMesh(mesh, index) {
        mesh.id = mesh.id || "mesh-".concat(index);
        if (mesh.primitives) {
          mesh.primitives = mesh.primitives.map((primitive) => {
            primitive = {
              ...primitive
            };
            const attributes = primitive.attributes;
            primitive.attributes = {};
            for (const attribute in attributes) {
              primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
            }
            if (primitive.indices !== void 0) {
              primitive.indices = this.getAccessor(primitive.indices);
            }
            if (primitive.material !== void 0) {
              primitive.material = this.getMaterial(primitive.material);
            }
            return primitive;
          });
        }
        return mesh;
      }
      _resolveMaterial(material, index) {
        material.id = material.id || "material-".concat(index);
        if (material.normalTexture) {
          material.normalTexture = {
            ...material.normalTexture
          };
          material.normalTexture.texture = this.getTexture(material.normalTexture.index);
        }
        if (material.occlusionTexture) {
          material.occlustionTexture = {
            ...material.occlustionTexture
          };
          material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
        }
        if (material.emissiveTexture) {
          material.emmisiveTexture = {
            ...material.emmisiveTexture
          };
          material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
        }
        if (!material.emissiveFactor) {
          material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];
        }
        if (material.pbrMetallicRoughness) {
          material.pbrMetallicRoughness = {
            ...material.pbrMetallicRoughness
          };
          const mr = material.pbrMetallicRoughness;
          if (mr.baseColorTexture) {
            mr.baseColorTexture = {
              ...mr.baseColorTexture
            };
            mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
          }
          if (mr.metallicRoughnessTexture) {
            mr.metallicRoughnessTexture = {
              ...mr.metallicRoughnessTexture
            };
            mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
          }
        }
        return material;
      }
      _resolveAccessor(accessor, index) {
        accessor.id = accessor.id || "accessor-".concat(index);
        if (accessor.bufferView !== void 0) {
          accessor.bufferView = this.getBufferView(accessor.bufferView);
        }
        accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
        accessor.components = getSizeFromAccessorType(accessor.type);
        accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
        if (accessor.bufferView) {
          const buffer = accessor.bufferView.buffer;
          const {
            ArrayType,
            byteLength
          } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
          const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
          let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
          if (accessor.bufferView.byteStride) {
            cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
          }
          accessor.value = new ArrayType(cutBuffer);
        }
        return accessor;
      }
      _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
        const result = new Uint8Array(count * bytesPerElement);
        for (let i3 = 0; i3 < count; i3++) {
          const elementOffset = byteOffset + i3 * byteStride;
          result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i3 * bytesPerElement);
        }
        return result.buffer;
      }
      _resolveTexture(texture, index) {
        texture.id = texture.id || "texture-".concat(index);
        texture.sampler = "sampler" in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
        texture.source = this.getImage(texture.source);
        return texture;
      }
      _resolveSampler(sampler, index) {
        sampler.id = sampler.id || "sampler-".concat(index);
        sampler.parameters = {};
        for (const key in sampler) {
          const glEnum = this._enumSamplerParameter(key);
          if (glEnum !== void 0) {
            sampler.parameters[glEnum] = sampler[key];
          }
        }
        return sampler;
      }
      _enumSamplerParameter(key) {
        return SAMPLER_PARAMETER_GLTF_TO_GL[key];
      }
      _resolveImage(image, index) {
        image.id = image.id || "image-".concat(index);
        if (image.bufferView !== void 0) {
          image.bufferView = this.getBufferView(image.bufferView);
        }
        const preloadedImage = this.images[index];
        if (preloadedImage) {
          image.image = preloadedImage;
        }
        return image;
      }
      _resolveBufferView(bufferView, index) {
        const bufferIndex = bufferView.buffer;
        const result = {
          id: "bufferView-".concat(index),
          ...bufferView,
          buffer: this.buffers[bufferIndex]
        };
        const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
        let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
        if ("byteOffset" in bufferView) {
          byteOffset += bufferView.byteOffset;
        }
        result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
        return result;
      }
      _resolveCamera(camera, index) {
        camera.id = camera.id || "camera-".concat(index);
        if (camera.perspective) {
        }
        if (camera.orthographic) {
        }
        return camera;
      }
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js
function getMagicString(dataView) {
  let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
}
function isGLB(arrayBuffer) {
  let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const dataView = new DataView(arrayBuffer);
  const {
    magic = MAGIC_glTF
  } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer) {
  let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString(dataView, byteOffset + 0);
  const version = dataView.getUint32(byteOffset + 4, LE);
  const byteLength = dataView.getUint32(byteOffset + 8, LE);
  Object.assign(glb, {
    header: {
      byteOffset,
      byteLength,
      hasBinChunk: false
    },
    type,
    version,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;
  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});
    default:
      throw new Error("Invalid GLB version ".concat(glb.version, ". Only supports v1 and v2."));
  }
}
function parseGLBV1(glb, dataView, byteOffset) {
  assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LE);
  const contentFormat = dataView.getUint32(byteOffset + 4, LE);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  assert2(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}
function parseGLBV2(glb, dataView, byteOffset, options) {
  assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}
function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LE);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LE);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      default:
        break;
    }
    byteOffset += padToNBytes(chunkLength, 4);
  }
  return byteOffset;
}
function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder("utf8");
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return padToNBytes(chunkLength, 4);
}
function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
  });
  return padToNBytes(chunkLength, 4);
}
var MAGIC_glTF, GLB_FILE_HEADER_SIZE, GLB_CHUNK_HEADER_SIZE, GLB_CHUNK_TYPE_JSON, GLB_CHUNK_TYPE_BIN, GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED, GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED, GLB_V1_CONTENT_FORMAT_JSON, LE;
var init_parse_glb = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js"() {
    init_esm3();
    MAGIC_glTF = 1735152710;
    GLB_FILE_HEADER_SIZE = 12;
    GLB_CHUNK_HEADER_SIZE = 8;
    GLB_CHUNK_TYPE_JSON = 1313821514;
    GLB_CHUNK_TYPE_BIN = 5130562;
    GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
    GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
    GLB_V1_CONTENT_FORMAT_JSON = 0;
    LE = true;
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js
async function parseGLTF(gltf, arrayBufferOrString) {
  var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;
  let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let options = arguments.length > 3 ? arguments[3] : void 0;
  let context = arguments.length > 4 ? arguments[4] : void 0;
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  normalizeGLTFV1(gltf, {
    normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize
  });
  preprocessExtensions(gltf, options, context);
  const promises = [];
  if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {
    await loadBuffers(gltf, options, context);
  }
  if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {
    const promise2 = loadImages(gltf, options, context);
    promises.push(promise2);
  }
  const promise = decodeExtensions(gltf, options, context);
  promises.push(promise);
  await Promise.all(promises);
  return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf;
}
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }
  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }
  if (typeof data === "string") {
    gltf.json = parseJSON(data);
  } else if (data instanceof ArrayBuffer) {
    const glb = {};
    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
    assert6(glb.type === "glTF", "Invalid GLB magic string ".concat(glb.type));
    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    assert6(false, "GLTF: must be ArrayBuffer or string");
  }
  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);
  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const {
      binChunks
    } = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };
  }
  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}
async function loadBuffers(gltf, options, context) {
  const buffers = gltf.json.buffers || [];
  for (let i3 = 0; i3 < buffers.length; ++i3) {
    const buffer = buffers[i3];
    if (buffer.uri) {
      var _context$fetch, _response$arrayBuffer;
      const {
        fetch: fetch2
      } = context;
      assert6(fetch2);
      const uri = resolveUrl(buffer.uri, options);
      const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));
      const arrayBuffer = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));
      gltf.buffers[i3] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    } else if (gltf.buffers[i3] === null) {
      gltf.buffers[i3] = {
        arrayBuffer: new ArrayBuffer(buffer.byteLength),
        byteOffset: 0,
        byteLength: buffer.byteLength
      };
    }
  }
}
async function loadImages(gltf, options, context) {
  const imageIndices = getReferencesImageIndices(gltf);
  const images = gltf.json.images || [];
  const promises = [];
  for (const imageIndex of imageIndices) {
    promises.push(loadImage2(gltf, images[imageIndex], imageIndex, options, context));
  }
  return await Promise.all(promises);
}
function getReferencesImageIndices(gltf) {
  const imageIndices = /* @__PURE__ */ new Set();
  const textures = gltf.json.textures || [];
  for (const texture of textures) {
    if (texture.source !== void 0) {
      imageIndices.add(texture.source);
    }
  }
  return Array.from(imageIndices).sort();
}
async function loadImage2(gltf, image, index, options, context) {
  const {
    fetch: fetch2,
    parse: parse4
  } = context;
  let arrayBuffer;
  if (image.uri && !image.hasOwnProperty("bufferView")) {
    const uri = resolveUrl(image.uri, options);
    const response = await fetch2(uri);
    arrayBuffer = await response.arrayBuffer();
    image.bufferView = {
      data: arrayBuffer
    };
  }
  if (Number.isFinite(image.bufferView)) {
    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
  }
  assert6(arrayBuffer, "glTF image has no data");
  let parsedImage = await parse4(arrayBuffer, [ImageLoader, BasisLoader], {
    mimeType: image.mimeType,
    basis: options.basis || {
      format: selectSupportedBasisFormat()
    }
  }, context);
  if (parsedImage && parsedImage[0]) {
    parsedImage = {
      compressed: true,
      mipmaps: false,
      width: parsedImage[0].width,
      height: parsedImage[0].height,
      data: parsedImage[0]
    };
  }
  gltf.images = gltf.images || [];
  gltf.images[index] = parsedImage;
}
var init_parse_gltf = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js"() {
    init_esm21();
    init_esm5();
    init_esm3();
    init_assert2();
    init_resolve_url();
    init_get_typed_array();
    init_gltf_extensions();
    init_normalize_gltf_v1();
    init_post_process_gltf();
    init_parse_glb();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js
async function parse2(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let context = arguments.length > 2 ? arguments[2] : void 0;
  options = {
    ...GLTFLoader.options,
    ...options
  };
  options.gltf = {
    ...GLTFLoader.options.gltf,
    ...options.gltf
  };
  const {
    byteOffset = 0
  } = options;
  const gltf = {};
  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);
}
var GLTFLoader;
var init_gltf_loader = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js"() {
    init_version();
    init_parse_gltf();
    GLTFLoader = {
      name: "glTF",
      id: "gltf",
      module: "gltf",
      version: VERSION4,
      extensions: ["gltf", "glb"],
      mimeTypes: ["model/gltf+json", "model/gltf-binary"],
      text: true,
      binary: true,
      tests: ["glTF"],
      parse: parse2,
      options: {
        gltf: {
          normalize: true,
          loadBuffers: true,
          loadImages: true,
          decompressMeshes: true,
          postProcess: true
        },
        log: console
      },
      deprecatedOptions: {
        fetchImages: "gltf.loadImages",
        createImages: "gltf.loadImages",
        decompress: "gltf.decompressMeshes",
        postProcess: "gltf.postProcess",
        gltf: {
          decompress: "gltf.decompressMeshes"
        }
      }
    };
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-glb.js
var init_encode_glb = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-glb.js"() {
    init_esm3();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-gltf.js
var init_encode_gltf = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/lib/encoders/encode-gltf.js"() {
    init_encode_glb();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/gltf-writer.js
var init_gltf_writer = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/gltf-writer.js"() {
    init_version();
    init_encode_gltf();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/glb-loader.js
var init_glb_loader = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/glb-loader.js"() {
    init_version();
    init_parse_glb();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/glb-writer.js
var init_glb_writer = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/glb-writer.js"() {
    init_version();
    init_encode_glb();
  }
});

// node_modules/@loaders.gl/gltf/dist/esm/index.js
var init_esm23 = __esm({
  "node_modules/@loaders.gl/gltf/dist/esm/index.js"() {
    init_gltf_loader();
    init_gltf_writer();
    init_glb_loader();
    init_glb_writer();
    init_gltf_scenegraph();
    init_post_process_gltf();
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/gltf-utils.js
async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];
  gltfObjects.scenes.forEach((scene) => {
    scene.traverse((model) => {
      Object.values(model.model.getUniforms()).forEach((uniform) => {
        if (uniform.loaded === false) {
          remaining.push(uniform);
        }
      });
    });
  });
  return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
}
async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise((resolve) => requestAnimationFrame(resolve));
  }
}
var init_gltf_utils2 = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/gltf-utils.js"() {
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-vertex.glsl.js
var scenegraph_layer_vertex_glsl_default;
var init_scenegraph_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-vertex.glsl.js"() {
    scenegraph_layer_vertex_glsl_default = "#version 300 es\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec4 POSITION;\n\n#ifdef HAS_UV\n  in vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    in vec4 NORMAL;\n  #endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(sizeScale);\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-fragment.glsl.js
var scenegraph_layer_fragment_glsl_default;
var init_scenegraph_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-fragment.glsl.js"() {
    scenegraph_layer_fragment_glsl_default = "#version 300 es\nuniform float opacity;\nin vec4 vColor;\n\nout vec4 fragmentColor;\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  fragmentColor.a *= opacity;\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer.js
var DEFAULT_COLOR11, defaultProps26, ScenegraphLayer;
var init_scenegraph_layer = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_esm9();
    init_esm20();
    init_esm23();
    init_gltf_utils2();
    init_matrix();
    init_scenegraph_layer_vertex_glsl();
    init_scenegraph_layer_fragment_glsl();
    DEFAULT_COLOR11 = [255, 255, 255, 255];
    defaultProps26 = {
      scenegraph: {
        type: "object",
        value: null,
        async: true
      },
      getScene: (gltf) => {
        if (gltf && gltf.scenes) {
          return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
        }
        return gltf;
      },
      getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
      _animations: null,
      sizeScale: {
        type: "number",
        value: 1,
        min: 0
      },
      sizeMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      sizeMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      getPosition: {
        type: "accessor",
        value: (x2) => x2.position
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR11
      },
      _lighting: "flat",
      _imageBasedLightingEnvironment: null,
      getOrientation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getScale: {
        type: "accessor",
        value: [1, 1, 1]
      },
      getTranslation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getTransformMatrix: {
        type: "accessor",
        value: []
      },
      loaders: [GLTFLoader]
    };
    ScenegraphLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        const modules = [project32_default, picking_default];
        if (this.props._lighting === "pbr") {
          modules.push(pbr);
        }
        return {
          vs: scenegraph_layer_vertex_glsl_default,
          fs: scenegraph_layer_fragment_glsl_default,
          modules
        };
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            accessor: "getPosition",
            transition: true
          },
          instanceColors: {
            type: 5121,
            size: this.props.colorFormat.length,
            accessor: "getColor",
            normalized: true,
            defaultValue: DEFAULT_COLOR11,
            transition: true
          },
          instanceModelMatrix: MATRIX_ATTRIBUTES
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps
        } = params;
        if (props.scenegraph !== oldProps.scenegraph) {
          this._updateScenegraph();
        } else if (props._animations !== oldProps._animations) {
          this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
        }
      }
      finalizeState(context) {
        super.finalizeState(context);
        this._deleteScenegraph();
      }
      _updateScenegraph() {
        const props = this.props;
        const {
          gl
        } = this.context;
        let scenegraphData = null;
        if (props.scenegraph instanceof ScenegraphNode) {
          scenegraphData = {
            scenes: [props.scenegraph]
          };
        } else if (props.scenegraph && !props.scenegraph.gltf) {
          const gltf = props.scenegraph;
          const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());
          scenegraphData = {
            gltf,
            ...gltfObjects
          };
          waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw());
        } else if (props.scenegraph) {
          log_default.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")();
          scenegraphData = props.scenegraph;
        }
        const options = {
          layer: this,
          gl
        };
        const scenegraph = props.getScene(scenegraphData, options);
        const animator = props.getAnimator(scenegraphData, options);
        if (scenegraph instanceof ScenegraphNode) {
          this._deleteScenegraph();
          this._applyAllAttributes(scenegraph);
          this._applyAnimationsProp(scenegraph, animator, props._animations);
          this.setState({
            scenegraph,
            animator
          });
        } else if (scenegraph !== null) {
          log_default.warn("invalid scenegraph:", scenegraph)();
        }
      }
      _applyAllAttributes(scenegraph) {
        if (this.state.attributesAvailable) {
          const allAttributes = this.getAttributeManager().getAttributes();
          scenegraph.traverse((model) => {
            this._setModelAttributes(model.model, allAttributes);
          });
        }
      }
      _applyAnimationsProp(scenegraph, animator, animationsProp) {
        if (!scenegraph || !animator || !animationsProp) {
          return;
        }
        const animations = animator.getAnimations();
        Object.keys(animationsProp).sort().forEach((key) => {
          const value = animationsProp[key];
          if (key === "*") {
            animations.forEach((animation) => {
              Object.assign(animation, value);
            });
          } else if (Number.isFinite(Number(key))) {
            const number = Number(key);
            if (number >= 0 && number < animations.length) {
              Object.assign(animations[number], value);
            } else {
              log_default.warn("animation ".concat(key, " not found"))();
            }
          } else {
            const findResult = animations.find(({
              name: name10
            }) => name10 === key);
            if (findResult) {
              Object.assign(findResult, value);
            } else {
              log_default.warn("animation ".concat(key, " not found"))();
            }
          }
        });
      }
      _deleteScenegraph() {
        const {
          scenegraph
        } = this.state;
        if (scenegraph instanceof ScenegraphNode) {
          scenegraph.delete();
        }
      }
      _getModelOptions() {
        const {
          _imageBasedLightingEnvironment
        } = this.props;
        let env = null;
        if (_imageBasedLightingEnvironment) {
          if (typeof _imageBasedLightingEnvironment === "function") {
            env = _imageBasedLightingEnvironment({
              gl: this.context.gl,
              layer: this
            });
          } else {
            env = _imageBasedLightingEnvironment;
          }
        }
        return {
          gl: this.context.gl,
          waitForFullLoad: true,
          imageBasedLightingEnvironment: env,
          modelOptions: {
            isInstanced: true,
            transpileToGLSL100: !isWebGL2(this.context.gl),
            ...this.getShaders()
          },
          useTangents: false
        };
      }
      updateAttributes(changedAttributes) {
        this.setState({
          attributesAvailable: true
        });
        if (!this.state.scenegraph)
          return;
        this.state.scenegraph.traverse((model) => {
          this._setModelAttributes(model.model, changedAttributes);
        });
      }
      draw({
        moduleParameters = null,
        parameters: parameters2 = {},
        context
      }) {
        if (!this.state.scenegraph)
          return;
        if (this.props._animations && this.state.animator) {
          this.state.animator.animate(context.timeline.getTime());
          this.setNeedsRedraw();
        }
        const {
          viewport
        } = this.context;
        const {
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          opacity,
          coordinateSystem
        } = this.props;
        const numInstances = this.getNumInstances();
        this.state.scenegraph.traverse((model, {
          worldMatrix
        }) => {
          model.model.setInstanceCount(numInstances);
          model.updateModuleSettings(moduleParameters);
          model.draw({
            parameters: parameters2,
            uniforms: {
              sizeScale,
              opacity,
              sizeMinPixels,
              sizeMaxPixels,
              composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
              sceneModelMatrix: worldMatrix,
              u_Camera: model.model.getUniforms().project_uCameraPosition
            }
          });
        });
      }
    };
    _defineProperty(ScenegraphLayer, "defaultProps", defaultProps26);
    _defineProperty(ScenegraphLayer, "layerName", "ScenegraphLayer");
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  ScenegraphLayer: () => ScenegraphLayer,
  SimpleMeshLayer: () => SimpleMeshLayer
});
var init_esm24 = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/index.js"() {
    init_simple_mesh_layer();
    init_scenegraph_layer();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-vertex.glsl.js
var mesh_layer_vertex_glsl_default;
var init_mesh_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-vertex.glsl.js"() {
    mesh_layer_vertex_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nuniform bool pickFeatureIds;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec4 uvRegions;\nin vec3 featureIdsPickingColors;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvec2 applyUVRegion(vec2 uv) {\n  #ifdef HAS_UV_REGIONS\n    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;\n  #else\n    return uv;\n  #endif\n}\n\nvoid main(void) {\n  vec2 uv = applyUVRegion(texCoords);\n  geometry.uv = uv;\n\n  if (pickFeatureIds) {\n    geometry.pickingColor = featureIdsPickingColors;\n  } else {\n    geometry.pickingColor = instancePickingColors;\n  }\n\n  vTexCoord = uv;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale;\n  vec3 projectedPosition = project_position(positions);\n  position_commonspace = vec4(projectedPosition, 1.0);\n  gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n  geometry.position = position_commonspace;\n  normals_commonspace = project_normal(instanceModelMatrix * normals);\n  geometry.normal = normals_commonspace;\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = uv;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-fragment.glsl.js
var mesh_layer_fragment_glsl_default;
var init_mesh_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-fragment.glsl.js"() {
    mesh_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  \n#ifdef MODULE_PBR\n\n  fragColor = vColor * pbr_filterColor(vec4(0));\n  geometry.uv = pbr_vUV;\n  fragColor.a *= opacity;\n\n#else\n\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n\n#endif\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer.js
function validateGeometryAttributes2(attributes) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!hasColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }
}
var defaultProps27, MeshLayer;
var init_mesh_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer.js"() {
    init_defineProperty();
    init_esm20();
    init_esm11();
    init_esm24();
    init_mesh_layer_vertex_glsl();
    init_mesh_layer_fragment_glsl();
    defaultProps27 = {
      pbrMaterial: {
        type: "object",
        value: null
      },
      featureIds: {
        type: "array",
        value: null,
        optional: true
      }
    };
    MeshLayer = class extends SimpleMeshLayer {
      getShaders() {
        const shaders = super.getShaders();
        const modules = shaders.modules;
        modules.push(pbr);
        return {
          ...shaders,
          vs: mesh_layer_vertex_glsl_default,
          fs: mesh_layer_fragment_glsl_default
        };
      }
      initializeState() {
        const {
          featureIds
        } = this.props;
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        if (featureIds) {
          attributeManager.add({
            featureIdsPickingColors: {
              type: 5121,
              size: 3,
              noAlloc: true,
              update: this.calculateFeatureIdsPickingColors
            }
          });
        }
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps
        } = params;
        if (props.pbrMaterial !== oldProps.pbrMaterial) {
          this.updatePbrMaterialUniforms(props.pbrMaterial);
        }
      }
      draw(opts) {
        const {
          featureIds
        } = this.props;
        if (!this.state.model) {
          return;
        }
        this.state.model.setUniforms({
          u_Camera: this.state.model.getUniforms().project_uCameraPosition,
          pickFeatureIds: Boolean(featureIds)
        });
        super.draw(opts);
      }
      getModel(mesh) {
        const {
          id,
          pbrMaterial
        } = this.props;
        const materialParser = this.parseMaterial(pbrMaterial, mesh);
        this.setState({
          materialParser
        });
        const shaders = this.getShaders();
        validateGeometryAttributes2(mesh.attributes);
        const model = new Model(this.context.gl, {
          ...this.getShaders(),
          id,
          geometry: mesh,
          defines: {
            ...shaders.defines,
            ...materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines,
            HAS_UV_REGIONS: mesh.attributes.uvRegions
          },
          parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,
          isInstanced: true
        });
        return model;
      }
      updatePbrMaterialUniforms(pbrMaterial) {
        const {
          model
        } = this.state;
        if (model) {
          const {
            mesh
          } = this.props;
          const materialParser = this.parseMaterial(pbrMaterial, mesh);
          this.setState({
            materialParser
          });
          model.setUniforms(materialParser.uniforms);
        }
      }
      parseMaterial(pbrMaterial, mesh) {
        var _this$state$materialP;
        const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);
        (_this$state$materialP = this.state.materialParser) === null || _this$state$materialP === void 0 ? void 0 : _this$state$materialP.delete();
        return new GLTFMaterialParser(this.context.gl, {
          attributes: {
            NORMAL: mesh.attributes.normals,
            TEXCOORD_0: mesh.attributes.texCoords
          },
          material: {
            unlit,
            ...pbrMaterial
          },
          pbrDebug: false,
          imageBasedLightingEnvironment: null,
          lights: true,
          useTangents: false
        });
      }
      calculateFeatureIdsPickingColors(attribute) {
        const featureIds = this.props.featureIds;
        const value = new Uint8ClampedArray(featureIds.length * attribute.size);
        const pickingColor = [];
        for (let index = 0; index < featureIds.length; index++) {
          this.encodePickingColor(featureIds[index], pickingColor);
          value[index * 3] = pickingColor[0];
          value[index * 3 + 1] = pickingColor[1];
          value[index * 3 + 2] = pickingColor[2];
        }
        attribute.value = value;
      }
      finalizeState(context) {
        var _this$state$materialP2;
        super.finalizeState(context);
        (_this$state$materialP2 = this.state.materialParser) === null || _this$state$materialP2 === void 0 ? void 0 : _this$state$materialP2.delete();
        this.setState({
          materialParser: null
        });
      }
    };
    _defineProperty(MeshLayer, "layerName", "MeshLayer");
    _defineProperty(MeshLayer, "defaultProps", defaultProps27);
  }
});

// node_modules/@math.gl/geospatial/dist/esm/constants.js
var WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z, WGS84_CONSTANTS;
var init_constants2 = __esm({
  "node_modules/@math.gl/geospatial/dist/esm/constants.js"() {
    WGS84_RADIUS_X = 6378137;
    WGS84_RADIUS_Y = 6378137;
    WGS84_RADIUS_Z = 6356752314245179e-9;
    WGS84_CONSTANTS = {
      radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
      radiiSquared: [WGS84_RADIUS_X * WGS84_RADIUS_X, WGS84_RADIUS_Y * WGS84_RADIUS_Y, WGS84_RADIUS_Z * WGS84_RADIUS_Z],
      oneOverRadii: [1 / WGS84_RADIUS_X, 1 / WGS84_RADIUS_Y, 1 / WGS84_RADIUS_Z],
      oneOverRadiiSquared: [1 / (WGS84_RADIUS_X * WGS84_RADIUS_X), 1 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y), 1 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)],
      maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
      centerToleranceSquared: 0.1
    };
  }
});

// node_modules/@math.gl/geospatial/dist/esm/type-utils.js
function identity(x2) {
  return x2;
}
function fromCartographic(cartographic, result = [], map = identity) {
  if ("longitude" in cartographic) {
    result[0] = map(cartographic.longitude);
    result[1] = map(cartographic.latitude);
    result[2] = cartographic.height;
  } else if ("x" in cartographic) {
    result[0] = map(cartographic.x);
    result[1] = map(cartographic.y);
    result[2] = cartographic.z;
  } else {
    result[0] = map(cartographic[0]);
    result[1] = map(cartographic[1]);
    result[2] = cartographic[2];
  }
  return result;
}
function fromCartographicToRadians(cartographic, vector = []) {
  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);
}
function toCartographic(vector, cartographic, map = identity) {
  if ("longitude" in cartographic) {
    cartographic.longitude = map(vector[0]);
    cartographic.latitude = map(vector[1]);
    cartographic.height = vector[2];
  } else if ("x" in cartographic) {
    cartographic.x = map(vector[0]);
    cartographic.y = map(vector[1]);
    cartographic.z = vector[2];
  } else {
    cartographic[0] = map(vector[0]);
    cartographic[1] = map(vector[1]);
    cartographic[2] = vector[2];
  }
  return cartographic;
}
function toCartographicFromRadians(vector, cartographic) {
  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);
}
var scratchVector8;
var init_type_utils = __esm({
  "node_modules/@math.gl/geospatial/dist/esm/type-utils.js"() {
    init_esm8();
    init_constants2();
    scratchVector8 = new Vector3();
  }
});

// node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/scale-to-geodetic-surface.js
function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {
  const {
    oneOverRadii,
    oneOverRadiiSquared,
    centerToleranceSquared
  } = ellipsoid;
  scratchVector9.from(cartesian);
  const positionX = scratchVector9.x;
  const positionY = scratchVector9.y;
  const positionZ = scratchVector9.z;
  const oneOverRadiiX = oneOverRadii.x;
  const oneOverRadiiY = oneOverRadii.y;
  const oneOverRadiiZ = oneOverRadii.z;
  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
  const squaredNorm = x2 + y2 + z2;
  const ratio = Math.sqrt(1 / squaredNorm);
  if (!Number.isFinite(ratio)) {
    return void 0;
  }
  const intersection = scaleToGeodeticSurfaceIntersection;
  intersection.copy(cartesian).scale(ratio);
  if (squaredNorm < centerToleranceSquared) {
    return intersection.to(result);
  }
  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
  const gradient = scaleToGeodeticSurfaceGradient;
  gradient.set(intersection.x * oneOverRadiiSquaredX * 2, intersection.y * oneOverRadiiSquaredY * 2, intersection.z * oneOverRadiiSquaredZ * 2);
  let lambda = (1 - ratio) * scratchVector9.len() / (0.5 * gradient.len());
  let correction = 0;
  let xMultiplier;
  let yMultiplier;
  let zMultiplier;
  let func;
  do {
    lambda -= correction;
    xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
    yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
    zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
    const xMultiplier2 = xMultiplier * xMultiplier;
    const yMultiplier2 = yMultiplier * yMultiplier;
    const zMultiplier2 = zMultiplier * zMultiplier;
    const xMultiplier3 = xMultiplier2 * xMultiplier;
    const yMultiplier3 = yMultiplier2 * yMultiplier;
    const zMultiplier3 = zMultiplier2 * zMultiplier;
    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1;
    const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
    const derivative = -2 * denominator;
    correction = func / derivative;
  } while (Math.abs(func) > math_utils_default.EPSILON12);
  return scratchVector9.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
}
var scratchVector9, scaleToGeodeticSurfaceIntersection, scaleToGeodeticSurfaceGradient;
var init_scale_to_geodetic_surface = __esm({
  "node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/scale-to-geodetic-surface.js"() {
    init_esm8();
    scratchVector9 = new Vector3();
    scaleToGeodeticSurfaceIntersection = new Vector3();
    scaleToGeodeticSurfaceGradient = new Vector3();
  }
});

// node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/ellipsoid-transform.js
function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
  const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
  assert4(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
  let firstAxisVector;
  let secondAxisVector;
  let thirdAxisVector;
  const origin = scratchOrigin.copy(cartesianOrigin);
  const atPole = equals(origin.x, 0, EPSILON14) && equals(origin.y, 0, EPSILON14);
  if (atPole) {
    const sign2 = Math.sign(origin.z);
    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);
    if (firstAxis !== "east" && firstAxis !== "west") {
      firstAxisVector.scale(sign2);
    }
    secondAxisVector = scratchVector24.fromArray(degeneratePositionLocalFrame[secondAxis]);
    if (secondAxis !== "east" && secondAxis !== "west") {
      secondAxisVector.scale(sign2);
    }
    thirdAxisVector = scratchVector33.fromArray(degeneratePositionLocalFrame[thirdAxis]);
    if (thirdAxis !== "east" && thirdAxis !== "west") {
      thirdAxisVector.scale(sign2);
    }
  } else {
    const {
      up,
      east,
      north
    } = scratchAxisVectors;
    east.set(-origin.y, origin.x, 0).normalize();
    ellipsoid.geodeticSurfaceNormal(origin, up);
    north.copy(up).cross(east);
    const {
      down,
      west,
      south
    } = scratchAxisVectors;
    down.copy(up).scale(-1);
    west.copy(east).scale(-1);
    south.copy(north).scale(-1);
    firstAxisVector = scratchAxisVectors[firstAxis];
    secondAxisVector = scratchAxisVectors[secondAxis];
    thirdAxisVector = scratchAxisVectors[thirdAxis];
  }
  result[0] = firstAxisVector.x;
  result[1] = firstAxisVector.y;
  result[2] = firstAxisVector.z;
  result[3] = 0;
  result[4] = secondAxisVector.x;
  result[5] = secondAxisVector.y;
  result[6] = secondAxisVector.z;
  result[7] = 0;
  result[8] = thirdAxisVector.x;
  result[9] = thirdAxisVector.y;
  result[10] = thirdAxisVector.z;
  result[11] = 0;
  result[12] = origin.x;
  result[13] = origin.y;
  result[14] = origin.z;
  result[15] = 1;
  return result;
}
var EPSILON14, scratchOrigin, VECTOR_PRODUCT_LOCAL_FRAME, degeneratePositionLocalFrame, scratchAxisVectors, scratchVector1, scratchVector24, scratchVector33;
var init_ellipsoid_transform = __esm({
  "node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/ellipsoid-transform.js"() {
    init_esm8();
    EPSILON14 = 1e-14;
    scratchOrigin = new Vector3();
    VECTOR_PRODUCT_LOCAL_FRAME = {
      up: {
        south: "east",
        north: "west",
        west: "south",
        east: "north"
      },
      down: {
        south: "west",
        north: "east",
        west: "north",
        east: "south"
      },
      south: {
        up: "west",
        down: "east",
        west: "down",
        east: "up"
      },
      north: {
        up: "east",
        down: "west",
        west: "up",
        east: "down"
      },
      west: {
        up: "north",
        down: "south",
        north: "down",
        south: "up"
      },
      east: {
        up: "south",
        down: "north",
        north: "up",
        south: "down"
      }
    };
    degeneratePositionLocalFrame = {
      north: [-1, 0, 0],
      east: [0, 1, 0],
      up: [0, 0, 1],
      south: [1, 0, 0],
      west: [0, -1, 0],
      down: [0, 0, -1]
    };
    scratchAxisVectors = {
      east: new Vector3(),
      north: new Vector3(),
      up: new Vector3(),
      west: new Vector3(),
      south: new Vector3(),
      down: new Vector3()
    };
    scratchVector1 = new Vector3();
    scratchVector24 = new Vector3();
    scratchVector33 = new Vector3();
  }
});

// node_modules/@math.gl/geospatial/dist/esm/ellipsoid/ellipsoid.js
var scratchVector10, scratchNormal3, scratchK, scratchPosition2, scratchHeight, scratchCartesian, Ellipsoid;
var init_ellipsoid = __esm({
  "node_modules/@math.gl/geospatial/dist/esm/ellipsoid/ellipsoid.js"() {
    init_defineProperty();
    init_esm8();
    init_vec3();
    init_constants2();
    init_type_utils();
    init_scale_to_geodetic_surface();
    init_ellipsoid_transform();
    scratchVector10 = new Vector3();
    scratchNormal3 = new Vector3();
    scratchK = new Vector3();
    scratchPosition2 = new Vector3();
    scratchHeight = new Vector3();
    scratchCartesian = new Vector3();
    Ellipsoid = class {
      constructor(x2 = 0, y2 = 0, z = 0) {
        _defineProperty(this, "radii", void 0);
        _defineProperty(this, "radiiSquared", void 0);
        _defineProperty(this, "radiiToTheFourth", void 0);
        _defineProperty(this, "oneOverRadii", void 0);
        _defineProperty(this, "oneOverRadiiSquared", void 0);
        _defineProperty(this, "minimumRadius", void 0);
        _defineProperty(this, "maximumRadius", void 0);
        _defineProperty(this, "centerToleranceSquared", math_utils_default.EPSILON1);
        _defineProperty(this, "squaredXOverSquaredZ", void 0);
        assert4(x2 >= 0);
        assert4(y2 >= 0);
        assert4(z >= 0);
        this.radii = new Vector3(x2, y2, z);
        this.radiiSquared = new Vector3(x2 * x2, y2 * y2, z * z);
        this.radiiToTheFourth = new Vector3(x2 * x2 * x2 * x2, y2 * y2 * y2 * y2, z * z * z * z);
        this.oneOverRadii = new Vector3(x2 === 0 ? 0 : 1 / x2, y2 === 0 ? 0 : 1 / y2, z === 0 ? 0 : 1 / z);
        this.oneOverRadiiSquared = new Vector3(x2 === 0 ? 0 : 1 / (x2 * x2), y2 === 0 ? 0 : 1 / (y2 * y2), z === 0 ? 0 : 1 / (z * z));
        this.minimumRadius = Math.min(x2, y2, z);
        this.maximumRadius = Math.max(x2, y2, z);
        if (this.radiiSquared.z !== 0) {
          this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
        }
        Object.freeze(this);
      }
      equals(right) {
        return this === right || Boolean(right && this.radii.equals(right.radii));
      }
      toString() {
        return this.radii.toString();
      }
      cartographicToCartesian(cartographic, result = [0, 0, 0]) {
        const normal = scratchNormal3;
        const k = scratchK;
        const [, , height] = cartographic;
        this.geodeticSurfaceNormalCartographic(cartographic, normal);
        k.copy(this.radiiSquared).scale(normal);
        const gamma = Math.sqrt(normal.dot(k));
        k.scale(1 / gamma);
        normal.scale(height);
        k.add(normal);
        return k.to(result);
      }
      cartesianToCartographic(cartesian, result = [0, 0, 0]) {
        scratchCartesian.from(cartesian);
        const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition2);
        if (!point) {
          return void 0;
        }
        const normal = this.geodeticSurfaceNormal(point, scratchNormal3);
        const h = scratchHeight;
        h.copy(scratchCartesian).subtract(point);
        const longitude = Math.atan2(normal.y, normal.x);
        const latitude = Math.asin(normal.z);
        const height = Math.sign(dot(h, scratchCartesian)) * length(h);
        return toCartographicFromRadians([longitude, latitude, height], result);
      }
      eastNorthUpToFixedFrame(origin, result = new Matrix4()) {
        return localFrameToFixedFrame(this, "east", "north", "up", origin, result);
      }
      localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {
        return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
      }
      geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {
        return scratchVector10.from(cartesian).normalize().to(result);
      }
      geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {
        const cartographicVectorRadians = fromCartographicToRadians(cartographic);
        const longitude = cartographicVectorRadians[0];
        const latitude = cartographicVectorRadians[1];
        const cosLatitude = Math.cos(latitude);
        scratchVector10.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
        return scratchVector10.to(result);
      }
      geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {
        return scratchVector10.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
      }
      scaleToGeodeticSurface(cartesian, result) {
        return scaleToGeodeticSurface(cartesian, this, result);
      }
      scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {
        scratchPosition2.from(cartesian);
        const positionX = scratchPosition2.x;
        const positionY = scratchPosition2.y;
        const positionZ = scratchPosition2.z;
        const oneOverRadiiSquared = this.oneOverRadiiSquared;
        const beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
        return scratchPosition2.multiplyScalar(beta).to(result);
      }
      transformPositionToScaledSpace(position, result = [0, 0, 0]) {
        return scratchPosition2.from(position).scale(this.oneOverRadii).to(result);
      }
      transformPositionFromScaledSpace(position, result = [0, 0, 0]) {
        return scratchPosition2.from(position).scale(this.radii).to(result);
      }
      getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {
        assert4(equals(this.radii.x, this.radii.y, math_utils_default.EPSILON15));
        assert4(this.radii.z > 0);
        scratchPosition2.from(position);
        const z = scratchPosition2.z * (1 - this.squaredXOverSquaredZ);
        if (Math.abs(z) >= this.radii.z - buffer) {
          return void 0;
        }
        return scratchPosition2.set(0, 0, z).to(result);
      }
    };
    _defineProperty(Ellipsoid, "WGS84", new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z));
  }
});

// node_modules/@math.gl/geospatial/dist/esm/index.js
var init_esm25 = __esm({
  "node_modules/@math.gl/geospatial/dist/esm/index.js"() {
    init_ellipsoid();
    init_type_utils();
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list-node.js
var DoublyLinkedListNode;
var init_doubly_linked_list_node = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list-node.js"() {
    init_defineProperty();
    DoublyLinkedListNode = class {
      constructor(item, previous, next) {
        _defineProperty(this, "item", void 0);
        _defineProperty(this, "previous", void 0);
        _defineProperty(this, "next", void 0);
        this.item = item;
        this.previous = previous;
        this.next = next;
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list.js
var DoublyLinkedList;
var init_doubly_linked_list = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list.js"() {
    init_defineProperty();
    init_doubly_linked_list_node();
    DoublyLinkedList = class {
      constructor() {
        _defineProperty(this, "head", null);
        _defineProperty(this, "tail", null);
        _defineProperty(this, "_length", 0);
      }
      get length() {
        return this._length;
      }
      add(item) {
        const node = new DoublyLinkedListNode(item, this.tail, null);
        if (this.tail) {
          this.tail.next = node;
          this.tail = node;
        } else {
          this.head = node;
          this.tail = node;
        }
        ++this._length;
        return node;
      }
      remove(node) {
        if (!node) {
          return;
        }
        if (node.previous && node.next) {
          node.previous.next = node.next;
          node.next.previous = node.previous;
        } else if (node.previous) {
          node.previous.next = null;
          this.tail = node.previous;
        } else if (node.next) {
          node.next.previous = null;
          this.head = node.next;
        } else {
          this.head = null;
          this.tail = null;
        }
        node.next = null;
        node.previous = null;
        --this._length;
      }
      splice(node, nextNode) {
        if (node === nextNode) {
          return;
        }
        this.remove(nextNode);
        this._insert(node, nextNode);
      }
      _insert(node, nextNode) {
        const oldNodeNext = node.next;
        node.next = nextNode;
        if (this.tail === node) {
          this.tail = nextNode;
        } else {
          oldNodeNext.previous = nextNode;
        }
        nextNode.next = oldNodeNext;
        nextNode.previous = node;
        ++this._length;
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-cache.js
function defined(x2) {
  return x2 !== void 0 && x2 !== null;
}
var TilesetCache;
var init_tileset_cache = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-cache.js"() {
    init_defineProperty();
    init_doubly_linked_list();
    TilesetCache = class {
      constructor() {
        _defineProperty(this, "_list", void 0);
        _defineProperty(this, "_sentinel", void 0);
        _defineProperty(this, "_trimTiles", void 0);
        this._list = new DoublyLinkedList();
        this._sentinel = this._list.add("sentinel");
        this._trimTiles = false;
      }
      reset() {
        this._list.splice(this._list.tail, this._sentinel);
      }
      touch(tile) {
        const node = tile._cacheNode;
        if (defined(node)) {
          this._list.splice(this._sentinel, node);
        }
      }
      add(tileset, tile, addCallback) {
        if (!defined(tile._cacheNode)) {
          tile._cacheNode = this._list.add(tile);
          if (addCallback) {
            addCallback(tileset, tile);
          }
        }
      }
      unloadTile(tileset, tile, unloadCallback) {
        const node = tile._cacheNode;
        if (!defined(node)) {
          return;
        }
        this._list.remove(node);
        tile._cacheNode = void 0;
        if (unloadCallback) {
          unloadCallback(tileset, tile);
        }
      }
      unloadTiles(tileset, unloadCallback) {
        const trimTiles = this._trimTiles;
        this._trimTiles = false;
        const list = this._list;
        const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
        const sentinel = this._sentinel;
        let node = list.head;
        while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
          const tile = node.item;
          node = node.next;
          this.unloadTile(tileset, tile, unloadCallback);
        }
      }
      trim() {
        this._trimTiles = true;
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/transform-utils.js
function calculateTransformProps(tileHeader, tile) {
  assert2(tileHeader);
  assert2(tile);
  const {
    rtcCenter,
    gltfUpAxis
  } = tile;
  const {
    computedTransform,
    boundingVolume: {
      center
    }
  } = tileHeader;
  let modelMatrix2 = new Matrix4(computedTransform);
  if (rtcCenter) {
    modelMatrix2.translate(rtcCenter);
  }
  switch (gltfUpAxis) {
    case "Z":
      break;
    case "Y":
      const rotationY = new Matrix4().rotateX(Math.PI / 2);
      modelMatrix2 = modelMatrix2.multiplyRight(rotationY);
      break;
    case "X":
      const rotationX = new Matrix4().rotateY(-Math.PI / 2);
      modelMatrix2 = modelMatrix2.multiplyRight(rotationX);
      break;
    default:
      break;
  }
  if (tile.isQuantized) {
    modelMatrix2.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
  }
  const cartesianOrigin = new Vector3(center);
  tile.cartesianModelMatrix = modelMatrix2;
  tile.cartesianOrigin = cartesianOrigin;
  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());
  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();
  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix2);
  tile.cartographicOrigin = cartographicOrigin;
  if (!tile.coordinateSystem) {
    tile.modelMatrix = tile.cartographicModelMatrix;
  }
}
var init_transform_utils = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/transform-utils.js"() {
    init_esm25();
    init_esm8();
    init_esm3();
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/frame-state.js
function getFrameState(viewport, frameNumber) {
  const {
    cameraDirection,
    cameraUp,
    height
  } = viewport;
  const {
    metersPerUnit
  } = viewport.distanceScales;
  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);
  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
  const cameraPositionCartesian2 = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());
  const cameraDirectionCartesian = new Vector3(
    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))
  ).normalize();
  const cameraUpCartesian = new Vector3(
    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))
  ).normalize();
  commonSpacePlanesToWGS84(viewport);
  const ViewportClass = viewport.constructor;
  const {
    longitude,
    latitude,
    width,
    bearing,
    zoom
  } = viewport;
  const topDownViewport = new ViewportClass({
    longitude,
    latitude,
    height,
    width,
    bearing,
    zoom,
    pitch: 0
  });
  return {
    camera: {
      position: cameraPositionCartesian2,
      direction: cameraDirectionCartesian,
      up: cameraUpCartesian
    },
    viewport,
    topDownViewport,
    height,
    cullingVolume,
    frameNumber,
    sseDenominator: 1.15
  };
}
function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {
  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {
    return [tiles, []];
  }
  const tuples = [];
  const {
    longitude: viewportLongitude,
    latitude: viewportLatitude
  } = frameState.viewport;
  for (const [index, tile] of tiles.entries()) {
    const [longitude, latitude] = tile.header.mbs;
    const deltaLon = Math.abs(viewportLongitude - longitude);
    const deltaLat = Math.abs(viewportLatitude - latitude);
    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
    tuples.push([index, distance]);
  }
  const tuplesSorted = tuples.sort((a2, b) => a2[1] - b[1]);
  const selectedTiles = [];
  for (let i3 = 0; i3 < maximumTilesSelected; i3++) {
    selectedTiles.push(tiles[tuplesSorted[i3][0]]);
  }
  const unselectedTiles = [];
  for (let i3 = maximumTilesSelected; i3 < tuplesSorted.length; i3++) {
    unselectedTiles.push(tiles[tuplesSorted[i3][0]]);
  }
  return [selectedTiles, unselectedTiles];
}
function commonSpacePlanesToWGS84(viewport) {
  const frustumPlanes = viewport.getFrustumPlanes();
  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);
  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);
  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition3);
  let i3 = 0;
  cullingVolume.planes[i3++].fromPointNormal(nearCenterCartesian, scratchVector11.copy(nearCenterCartesian).subtract(cameraCartesian));
  for (const dir in frustumPlanes) {
    if (dir === "near") {
      continue;
    }
    const plane = frustumPlanes[dir];
    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition3);
    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition3);
    cullingVolume.planes[i3++].fromPointNormal(
      cartesianPos,
      scratchVector11.copy(nearCenterCartesian).subtract(cartesianPos)
    );
  }
}
function closestPointOnPlane(plane, refPoint) {
  let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
  const distanceToRef = plane.normal.dot(refPoint);
  out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);
  return out;
}
function worldToCartesian(viewport, point) {
  let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
  const cartographicPos = viewport.unprojectPosition(point);
  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);
}
var scratchVector11, scratchPosition3, cullingVolume;
var init_frame_state = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/frame-state.js"() {
    init_esm8();
    init_esm18();
    init_esm25();
    scratchVector11 = new Vector3();
    scratchPosition3 = new Vector3();
    cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/zoom.js
function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
  if (boundingVolume instanceof OrientedBoundingBox) {
    const {
      halfAxes
    } = boundingVolume;
    const obbSize = getObbSize(halfAxes);
    return Math.log2(WGS84_RADIUS_Z2 / (obbSize + cartorgraphicCenter[2]));
  } else if (boundingVolume instanceof BoundingSphere) {
    const {
      radius
    } = boundingVolume;
    return Math.log2(WGS84_RADIUS_Z2 / (radius + cartorgraphicCenter[2]));
  } else if (boundingVolume.width && boundingVolume.height) {
    const {
      width,
      height
    } = boundingVolume;
    const zoomX = Math.log2(WGS84_RADIUS_X2 / width);
    const zoomY = Math.log2(WGS84_RADIUS_Y2 / height);
    return (zoomX + zoomY) / 2;
  }
  return 1;
}
function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {
  const extentVertex = Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], new Vector3());
  const extentSize = Math.sqrt(Math.pow(extentVertex[0] - cartesianCenter[0], 2) + Math.pow(extentVertex[1] - cartesianCenter[1], 2) + Math.pow(extentVertex[2] - cartesianCenter[2], 2));
  return Math.log2(WGS84_RADIUS_Z2 / (extentSize + cartorgraphicCenter[2]));
}
function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {
  const [xmin, ymin, xmax, ymax] = extent;
  return getZoomFromFullExtent({
    xmin,
    xmax,
    ymin,
    ymax,
    zmin: 0,
    zmax: 0
  }, cartorgraphicCenter, cartesianCenter);
}
function getObbSize(halfAxes) {
  halfAxes.getColumn(0, scratchVector12);
  const axeY = halfAxes.getColumn(1);
  const axeZ = halfAxes.getColumn(2);
  const farthestVertex = scratchVector12.add(axeY).add(axeZ);
  const size = farthestVertex.len();
  return size;
}
var WGS84_RADIUS_X2, WGS84_RADIUS_Y2, WGS84_RADIUS_Z2, scratchVector12;
var init_zoom = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/zoom.js"() {
    init_esm8();
    init_esm18();
    init_esm25();
    WGS84_RADIUS_X2 = 6378137;
    WGS84_RADIUS_Y2 = 6378137;
    WGS84_RADIUS_Z2 = 6356752314245179e-9;
    scratchVector12 = new Vector3();
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/constants.js
var TILE_CONTENT_STATE, TILE_REFINEMENT, TILE_TYPE, TILESET_TYPE, LOD_METRIC_TYPE, TILE3D_OPTIMIZATION_HINT;
var init_constants3 = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/constants.js"() {
    TILE_CONTENT_STATE = {
      UNLOADED: 0,
      LOADING: 1,
      PROCESSING: 2,
      READY: 3,
      EXPIRED: 4,
      FAILED: 5
    };
    TILE_REFINEMENT = {
      ADD: 1,
      REPLACE: 2
    };
    TILE_TYPE = {
      EMPTY: "empty",
      SCENEGRAPH: "scenegraph",
      POINTCLOUD: "pointcloud",
      MESH: "mesh"
    };
    TILESET_TYPE = {
      I3S: "I3S",
      TILES3D: "TILES3D"
    };
    LOD_METRIC_TYPE = {
      GEOMETRIC_ERROR: "geometricError",
      MAX_SCREEN_THRESHOLD: "maxScreenThreshold"
    };
    TILE3D_OPTIMIZATION_HINT = {
      NOT_COMPUTED: -1,
      USE_OPTIMIZATION: 1,
      SKIP_OPTIMIZATION: 0
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/bounding-volume.js
function defined2(x2) {
  return x2 !== void 0 && x2 !== null;
}
function createBoundingVolume(boundingVolumeHeader, transform2, result) {
  assert2(boundingVolumeHeader, "3D Tile: boundingVolume must be defined");
  if (boundingVolumeHeader.box) {
    return createBox(boundingVolumeHeader.box, transform2, result);
  }
  if (boundingVolumeHeader.region) {
    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
    const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);
    const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);
    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);
    const radius = new Vector3().subVectors(northWest, southEast).len() / 2;
    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());
  }
  if (boundingVolumeHeader.sphere) {
    return createSphere(boundingVolumeHeader.sphere, transform2, result);
  }
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function getCartographicBounds(boundingVolumeHeader, boundingVolume) {
  if (boundingVolumeHeader.box) {
    return orientedBoundingBoxToCartographicBounds(boundingVolume);
  }
  if (boundingVolumeHeader.region) {
    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
    return [[degrees(west), degrees(south), minHeight], [degrees(east), degrees(north), maxHeight]];
  }
  if (boundingVolumeHeader.sphere) {
    return boundingSphereToCartographicBounds(boundingVolume);
  }
  throw new Error("Unkown boundingVolume type");
}
function createBox(box, transform2, result) {
  const center = new Vector3(box[0], box[1], box[2]);
  transform2.transform(center, center);
  let origin = [];
  if (box.length === 10) {
    const halfSize = box.slice(3, 6);
    const quaternion2 = new Quaternion();
    quaternion2.fromArray(box, 6);
    const x2 = new Vector3([1, 0, 0]);
    const y2 = new Vector3([0, 1, 0]);
    const z = new Vector3([0, 0, 1]);
    x2.transformByQuaternion(quaternion2);
    x2.scale(halfSize[0]);
    y2.transformByQuaternion(quaternion2);
    y2.scale(halfSize[1]);
    z.transformByQuaternion(quaternion2);
    z.scale(halfSize[2]);
    origin = [...x2.toArray(), ...y2.toArray(), ...z.toArray()];
  } else {
    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];
  }
  const xAxis = transform2.transformAsVector(origin.slice(0, 3));
  const yAxis = transform2.transformAsVector(origin.slice(3, 6));
  const zAxis = transform2.transformAsVector(origin.slice(6, 9));
  const halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);
  if (defined2(result)) {
    result.center = center;
    result.halfAxes = halfAxes;
    return result;
  }
  return new OrientedBoundingBox(center, halfAxes);
}
function createSphere(sphere, transform2, result) {
  const center = new Vector3(sphere[0], sphere[1], sphere[2]);
  transform2.transform(center, center);
  const scale = transform2.getScale(scratchScale);
  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);
  const radius = sphere[3] * uniformScale;
  if (defined2(result)) {
    result.center = center;
    result.radius = radius;
    return result;
  }
  return new BoundingSphere(center, radius);
}
function orientedBoundingBoxToCartographicBounds(boundingVolume) {
  const result = emptyCartographicBounds();
  const {
    halfAxes
  } = boundingVolume;
  const xAxis = new Vector3(halfAxes.getColumn(0));
  const yAxis = new Vector3(halfAxes.getColumn(1));
  const zAxis = new Vector3(halfAxes.getColumn(2));
  for (let x2 = 0; x2 < 2; x2++) {
    for (let y2 = 0; y2 < 2; y2++) {
      for (let z = 0; z < 2; z++) {
        scratchPoint.copy(boundingVolume.center);
        scratchPoint.add(xAxis);
        scratchPoint.add(yAxis);
        scratchPoint.add(zAxis);
        addToCartographicBounds(result, scratchPoint);
        zAxis.negate();
      }
      yAxis.negate();
    }
    xAxis.negate();
  }
  return result;
}
function boundingSphereToCartographicBounds(boundingVolume) {
  const result = emptyCartographicBounds();
  const {
    center,
    radius
  } = boundingVolume;
  const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);
  let zAxis;
  if (point) {
    zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point);
  } else {
    zAxis = new Vector3(0, 0, 1);
  }
  let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);
  if (xAxis.len() > 0) {
    xAxis.normalize();
  } else {
    xAxis = new Vector3(0, 1, 0);
  }
  const yAxis = xAxis.clone().cross(zAxis);
  for (const axis of [xAxis, yAxis, zAxis]) {
    scratchScale.copy(axis).scale(radius);
    for (let dir = 0; dir < 2; dir++) {
      scratchPoint.copy(center);
      scratchPoint.add(scratchScale);
      addToCartographicBounds(result, scratchPoint);
      scratchScale.negate();
    }
  }
  return result;
}
function emptyCartographicBounds() {
  return [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
}
function addToCartographicBounds(target, cartesian) {
  Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);
  target[0][0] = Math.min(target[0][0], scratchPoint[0]);
  target[0][1] = Math.min(target[0][1], scratchPoint[1]);
  target[0][2] = Math.min(target[0][2], scratchPoint[2]);
  target[1][0] = Math.max(target[1][0], scratchPoint[0]);
  target[1][1] = Math.max(target[1][1], scratchPoint[1]);
  target[1][2] = Math.max(target[1][2], scratchPoint[2]);
}
var scratchPoint, scratchScale, scratchNorthWest, scratchSouthEast;
var init_bounding_volume = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/bounding-volume.js"() {
    init_esm8();
    init_esm18();
    init_esm25();
    init_esm3();
    scratchPoint = new Vector3();
    scratchScale = new Vector3();
    scratchNorthWest = new Vector3();
    scratchSouthEast = new Vector3();
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/tiles-3d-lod.js
function fog(distanceToCamera, density) {
  const scalar = distanceToCamera * density;
  return 1 - Math.exp(-(scalar * scalar));
}
function getDynamicScreenSpaceError(tileset, distanceToCamera) {
  if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {
    const density = tileset.dynamicScreenSpaceErrorComputedDensity;
    const factor = tileset.dynamicScreenSpaceErrorFactor;
    const dynamicError = fog(distanceToCamera, density) * factor;
    return dynamicError;
  }
  return 0;
}
function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {
  const tileset = tile.tileset;
  const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;
  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;
  if (lodMetricValue === 0) {
    return 0;
  }
  const distance = Math.max(tile._distanceToCamera, 1e-7);
  const {
    height,
    sseDenominator
  } = frameState;
  const {
    viewDistanceScale
  } = tileset.options;
  let error = lodMetricValue * height * (viewDistanceScale || 1) / (distance * sseDenominator);
  error -= getDynamicScreenSpaceError(tileset, distance);
  return error;
}
var scratchPositionNormal, scratchCartographic, scratchMatrix2, scratchCenter, scratchPosition4, scratchDirection;
var init_tiles_3d_lod = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/tiles-3d-lod.js"() {
    init_esm8();
    scratchPositionNormal = new Vector3();
    scratchCartographic = new Vector3();
    scratchMatrix2 = new Matrix4();
    scratchCenter = new Vector3();
    scratchPosition4 = new Vector3();
    scratchDirection = new Vector3();
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/i3s-lod.js
function getLodStatus(tile, frameState) {
  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
    return "DIG";
  }
  const screenSize = 2 * getProjectedRadius(tile, frameState);
  if (screenSize < 2) {
    return "OUT";
  }
  if (!tile.header.children || screenSize <= tile.lodMetricValue) {
    return "DRAW";
  } else if (tile.header.children) {
    return "DIG";
  }
  return "OUT";
}
function getProjectedRadius(tile, frameState) {
  const {
    topDownViewport: viewport
  } = frameState;
  const mbsLat = tile.header.mbs[1];
  const mbsLon = tile.header.mbs[0];
  const mbsZ = tile.header.mbs[2];
  const mbsR = tile.header.mbs[3];
  const mbsCenterCartesian = [...tile.boundingVolume.center];
  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);
  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);
  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();
  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);
  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
  const extraZ = projection * projection / cameraPositionEnu[2];
  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();
  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);
  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);
  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
  const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
  return projectedRadius;
}
var cameraPositionCartesian, toEye, cameraPositionEnu, extraVertexEnu, projectedOriginVector, enuToCartesianMatrix, cartesianToEnuMatrix;
var init_i3s_lod = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/i3s-lod.js"() {
    init_esm8();
    init_esm25();
    cameraPositionCartesian = new Vector3();
    toEye = new Vector3();
    cameraPositionEnu = new Vector3();
    extraVertexEnu = new Vector3();
    projectedOriginVector = new Vector3();
    enuToCartesianMatrix = new Matrix4();
    cartesianToEnuMatrix = new Matrix4();
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/3d-tiles-options.js
function get3dTilesOptions(tileset) {
  return {
    assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || "Y"
  };
}
var init_d_tiles_options = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/3d-tiles-options.js"() {
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/utils/managed-array.js
var ManagedArray;
var init_managed_array = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/utils/managed-array.js"() {
    init_defineProperty();
    init_esm3();
    ManagedArray = class {
      constructor() {
        let length3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        _defineProperty(this, "_map", /* @__PURE__ */ new Map());
        _defineProperty(this, "_array", void 0);
        _defineProperty(this, "_length", void 0);
        this._array = new Array(length3);
        this._length = length3;
      }
      get length() {
        return this._length;
      }
      set length(length3) {
        this._length = length3;
        if (length3 > this._array.length) {
          this._array.length = length3;
        }
      }
      get values() {
        return this._array;
      }
      get(index) {
        assert2(index < this._array.length);
        return this._array[index];
      }
      set(index, element) {
        assert2(index >= 0);
        if (index >= this.length) {
          this.length = index + 1;
        }
        if (this._map.has(this._array[index])) {
          this._map.delete(this._array[index]);
        }
        this._array[index] = element;
        this._map.set(element, index);
      }
      delete(element) {
        const index = this._map.get(element);
        if (index >= 0) {
          this._array.splice(index, 1);
          this._map.delete(element);
          this.length--;
        }
      }
      peek() {
        return this._array[this._length - 1];
      }
      push(element) {
        if (!this._map.has(element)) {
          const index = this.length++;
          this._array[index] = element;
          this._map.set(element, index);
        }
      }
      pop() {
        const element = this._array[--this.length];
        this._map.delete(element);
        return element;
      }
      reserve(length3) {
        assert2(length3 >= 0);
        if (length3 > this._array.length) {
          this._array.length = length3;
        }
      }
      resize(length3) {
        assert2(length3 >= 0);
        this.length = length3;
      }
      trim(length3) {
        if (length3 === null || length3 === void 0) {
          length3 = this.length;
        }
        this._array.length = length3;
      }
      reset() {
        this._array = [];
        this._map = /* @__PURE__ */ new Map();
        this._length = 0;
      }
      find(target) {
        return this._map.has(target);
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-traverser.js
var DEFAULT_PROPS, TilesetTraverser;
var init_tileset_traverser = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-traverser.js"() {
    init_defineProperty();
    init_managed_array();
    init_constants3();
    DEFAULT_PROPS = {
      loadSiblings: false,
      skipLevelOfDetail: false,
      maximumScreenSpaceError: 2,
      updateTransforms: true,
      onTraversalEnd: () => {
      },
      viewportTraversersMap: {},
      basePath: ""
    };
    TilesetTraverser = class {
      traversalFinished(frameState) {
        return true;
      }
      constructor(options) {
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "root", void 0);
        _defineProperty(this, "requestedTiles", void 0);
        _defineProperty(this, "selectedTiles", void 0);
        _defineProperty(this, "emptyTiles", void 0);
        _defineProperty(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime());
        _defineProperty(this, "updateDebounceTime", 1e3);
        _defineProperty(this, "_traversalStack", void 0);
        _defineProperty(this, "_emptyTraversalStack", void 0);
        _defineProperty(this, "_frameNumber", void 0);
        this.options = {
          ...DEFAULT_PROPS,
          ...options
        };
        this._traversalStack = new ManagedArray();
        this._emptyTraversalStack = new ManagedArray();
        this._frameNumber = null;
        this.root = null;
        this.selectedTiles = {};
        this.requestedTiles = {};
        this.emptyTiles = {};
      }
      traverse(root, frameState, options) {
        this.root = root;
        this.options = {
          ...this.options,
          ...options
        };
        this.reset();
        this.updateTile(root, frameState);
        this._frameNumber = frameState.frameNumber;
        this.executeTraversal(root, frameState);
      }
      reset() {
        this.requestedTiles = {};
        this.selectedTiles = {};
        this.emptyTiles = {};
        this._traversalStack.reset();
        this._emptyTraversalStack.reset();
      }
      executeTraversal(root, frameState) {
        const stack2 = this._traversalStack;
        root._selectionDepth = 1;
        stack2.push(root);
        while (stack2.length > 0) {
          const tile = stack2.pop();
          let shouldRefine = false;
          if (this.canTraverse(tile, frameState)) {
            this.updateChildTiles(tile, frameState);
            shouldRefine = this.updateAndPushChildren(tile, frameState, stack2, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);
          }
          const parent = tile.parent;
          const parentRefines = Boolean(!parent || parent._shouldRefine);
          const stoppedRefining = !shouldRefine;
          if (!tile.hasRenderContent) {
            this.emptyTiles[tile.id] = tile;
            this.loadTile(tile, frameState);
            if (stoppedRefining) {
              this.selectTile(tile, frameState);
            }
          } else if (tile.refine === TILE_REFINEMENT.ADD) {
            this.loadTile(tile, frameState);
            this.selectTile(tile, frameState);
          } else if (tile.refine === TILE_REFINEMENT.REPLACE) {
            this.loadTile(tile, frameState);
            if (stoppedRefining) {
              this.selectTile(tile, frameState);
            }
          }
          this.touchTile(tile, frameState);
          tile._shouldRefine = shouldRefine && parentRefines;
        }
        const newTime = (/* @__PURE__ */ new Date()).getTime();
        if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {
          this.lastUpdate = newTime;
          this.options.onTraversalEnd(frameState);
        }
      }
      updateChildTiles(tile, frameState) {
        const children = tile.children;
        for (const child of children) {
          this.updateTile(child, frameState);
        }
        return true;
      }
      updateAndPushChildren(tile, frameState, stack2, depth) {
        const {
          loadSiblings,
          skipLevelOfDetail
        } = this.options;
        const children = tile.children;
        children.sort(this.compareDistanceToCamera.bind(this));
        const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;
        let hasVisibleChild = false;
        let refines = true;
        for (const child of children) {
          child._selectionDepth = depth;
          if (child.isVisibleAndInRequestVolume) {
            if (stack2.find(child)) {
              stack2.delete(child);
            }
            stack2.push(child);
            hasVisibleChild = true;
          } else if (checkRefines || loadSiblings) {
            this.loadTile(child, frameState);
            this.touchTile(child, frameState);
          }
          if (checkRefines) {
            let childRefines;
            if (!child._inRequestVolume) {
              childRefines = false;
            } else if (!child.hasRenderContent) {
              childRefines = this.executeEmptyTraversal(child, frameState);
            } else {
              childRefines = child.contentAvailable;
            }
            refines = refines && childRefines;
            if (!refines) {
              return false;
            }
          }
        }
        if (!hasVisibleChild) {
          refines = false;
        }
        return refines;
      }
      updateTile(tile, frameState) {
        this.updateTileVisibility(tile, frameState);
      }
      selectTile(tile, frameState) {
        if (this.shouldSelectTile(tile)) {
          tile._selectedFrame = frameState.frameNumber;
          this.selectedTiles[tile.id] = tile;
        }
      }
      loadTile(tile, frameState) {
        if (this.shouldLoadTile(tile)) {
          tile._requestedFrame = frameState.frameNumber;
          tile._priority = tile._getPriority();
          this.requestedTiles[tile.id] = tile;
        }
      }
      touchTile(tile, frameState) {
        tile.tileset._cache.touch(tile);
        tile._touchedFrame = frameState.frameNumber;
      }
      canTraverse(tile, frameState) {
        let useParentMetric = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        let ignoreVisibility = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        if (!tile.hasChildren) {
          return false;
        }
        if (tile.hasTilesetContent) {
          return !tile.contentExpired;
        }
        if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {
          return false;
        }
        return this.shouldRefine(tile, frameState, useParentMetric);
      }
      shouldLoadTile(tile) {
        return tile.hasUnloadedContent || tile.contentExpired;
      }
      shouldSelectTile(tile) {
        return tile.contentAvailable && !this.options.skipLevelOfDetail;
      }
      shouldRefine(tile, frameState, useParentMetric) {
        let screenSpaceError = tile._screenSpaceError;
        if (useParentMetric) {
          screenSpaceError = tile.getScreenSpaceError(frameState, true);
        }
        return screenSpaceError > this.options.maximumScreenSpaceError;
      }
      updateTileVisibility(tile, frameState) {
        const viewportIds = [];
        if (this.options.viewportTraversersMap) {
          for (const key in this.options.viewportTraversersMap) {
            const value = this.options.viewportTraversersMap[key];
            if (value === frameState.viewport.id) {
              viewportIds.push(key);
            }
          }
        } else {
          viewportIds.push(frameState.viewport.id);
        }
        tile.updateVisibility(frameState, viewportIds);
      }
      compareDistanceToCamera(b, a2) {
        return b._distanceToCamera - a2._distanceToCamera;
      }
      anyChildrenVisible(tile, frameState) {
        let anyVisible = false;
        for (const child of tile.children) {
          child.updateVisibility(frameState);
          anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
        }
        return anyVisible;
      }
      executeEmptyTraversal(root, frameState) {
        let allDescendantsLoaded = true;
        const stack2 = this._emptyTraversalStack;
        stack2.push(root);
        while (stack2.length > 0 && allDescendantsLoaded) {
          const tile = stack2.pop();
          this.updateTile(tile, frameState);
          if (!tile.isVisibleAndInRequestVolume) {
            this.loadTile(tile, frameState);
          }
          this.touchTile(tile, frameState);
          const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);
          if (traverse) {
            const children = tile.children;
            for (const child of children) {
              if (stack2.find(child)) {
                stack2.delete(child);
              }
              stack2.push(child);
            }
          } else if (!tile.contentAvailable) {
            allDescendantsLoaded = false;
          }
        }
        return allDescendantsLoaded;
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/tile-3d.js
function defined3(x2) {
  return x2 !== void 0 && x2 !== null;
}
var scratchVector13, Tile3D;
var init_tile_3d = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/tile-3d.js"() {
    init_defineProperty();
    init_esm8();
    init_esm18();
    init_esm4();
    init_constants3();
    init_bounding_volume();
    init_tiles_3d_lod();
    init_i3s_lod();
    init_d_tiles_options();
    init_tileset_traverser();
    scratchVector13 = new Vector3();
    Tile3D = class {
      constructor(tileset, header, parentHeader) {
        let extendedId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
        _defineProperty(this, "tileset", void 0);
        _defineProperty(this, "header", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "url", void 0);
        _defineProperty(this, "parent", void 0);
        _defineProperty(this, "refine", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "contentUrl", void 0);
        _defineProperty(this, "lodMetricType", void 0);
        _defineProperty(this, "lodMetricValue", void 0);
        _defineProperty(this, "boundingVolume", void 0);
        _defineProperty(this, "content", void 0);
        _defineProperty(this, "contentState", void 0);
        _defineProperty(this, "gpuMemoryUsageInBytes", void 0);
        _defineProperty(this, "children", void 0);
        _defineProperty(this, "depth", void 0);
        _defineProperty(this, "viewportIds", void 0);
        _defineProperty(this, "transform", void 0);
        _defineProperty(this, "extensions", void 0);
        _defineProperty(this, "implicitTiling", void 0);
        _defineProperty(this, "userData", void 0);
        _defineProperty(this, "computedTransform", void 0);
        _defineProperty(this, "hasEmptyContent", void 0);
        _defineProperty(this, "hasTilesetContent", void 0);
        _defineProperty(this, "traverser", void 0);
        _defineProperty(this, "_cacheNode", void 0);
        _defineProperty(this, "_frameNumber", void 0);
        _defineProperty(this, "_lodJudge", void 0);
        _defineProperty(this, "_expireDate", void 0);
        _defineProperty(this, "_expiredContent", void 0);
        _defineProperty(this, "_shouldRefine", void 0);
        _defineProperty(this, "_boundingBox", void 0);
        _defineProperty(this, "_distanceToCamera", void 0);
        _defineProperty(this, "_centerZDepth", void 0);
        _defineProperty(this, "_screenSpaceError", void 0);
        _defineProperty(this, "_visibilityPlaneMask", void 0);
        _defineProperty(this, "_visible", void 0);
        _defineProperty(this, "_inRequestVolume", void 0);
        _defineProperty(this, "_stackLength", void 0);
        _defineProperty(this, "_selectionDepth", void 0);
        _defineProperty(this, "_touchedFrame", void 0);
        _defineProperty(this, "_visitedFrame", void 0);
        _defineProperty(this, "_selectedFrame", void 0);
        _defineProperty(this, "_requestedFrame", void 0);
        _defineProperty(this, "_priority", void 0);
        _defineProperty(this, "_contentBoundingVolume", void 0);
        _defineProperty(this, "_viewerRequestVolume", void 0);
        _defineProperty(this, "_initialTransform", void 0);
        this.header = header;
        this.tileset = tileset;
        this.id = extendedId || header.id;
        this.url = header.url;
        this.parent = parentHeader;
        this.refine = this._getRefine(header.refine);
        this.type = header.type;
        this.contentUrl = header.contentUrl;
        this.lodMetricType = "geometricError";
        this.lodMetricValue = 0;
        this.boundingVolume = null;
        this.content = null;
        this.contentState = TILE_CONTENT_STATE.UNLOADED;
        this.gpuMemoryUsageInBytes = 0;
        this.children = [];
        this.hasEmptyContent = false;
        this.hasTilesetContent = false;
        this.depth = 0;
        this.viewportIds = [];
        this.userData = {};
        this.extensions = null;
        this._priority = 0;
        this._touchedFrame = 0;
        this._visitedFrame = 0;
        this._selectedFrame = 0;
        this._requestedFrame = 0;
        this._screenSpaceError = 0;
        this._cacheNode = null;
        this._frameNumber = null;
        this._cacheNode = null;
        this.traverser = new TilesetTraverser({});
        this._shouldRefine = false;
        this._distanceToCamera = 0;
        this._centerZDepth = 0;
        this._visible = void 0;
        this._inRequestVolume = false;
        this._stackLength = 0;
        this._selectionDepth = 0;
        this._initialTransform = new Matrix4();
        this.transform = new Matrix4();
        this._initializeLodMetric(header);
        this._initializeTransforms(header);
        this._initializeBoundingVolumes(header);
        this._initializeContent(header);
        this._initializeRenderingState(header);
        this._lodJudge = null;
        this._expireDate = null;
        this._expiredContent = null;
        this.implicitTiling = null;
        Object.seal(this);
      }
      destroy() {
        this.header = null;
      }
      isDestroyed() {
        return this.header === null;
      }
      get selected() {
        return this._selectedFrame === this.tileset._frameNumber;
      }
      get isVisible() {
        return this._visible;
      }
      get isVisibleAndInRequestVolume() {
        return this._visible && this._inRequestVolume;
      }
      get hasRenderContent() {
        return !this.hasEmptyContent && !this.hasTilesetContent;
      }
      get hasChildren() {
        return this.children.length > 0 || this.header.children && this.header.children.length > 0;
      }
      get contentReady() {
        return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;
      }
      get contentAvailable() {
        return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
      }
      get hasUnloadedContent() {
        return this.hasRenderContent && this.contentUnloaded;
      }
      get contentUnloaded() {
        return this.contentState === TILE_CONTENT_STATE.UNLOADED;
      }
      get contentExpired() {
        return this.contentState === TILE_CONTENT_STATE.EXPIRED;
      }
      get contentFailed() {
        return this.contentState === TILE_CONTENT_STATE.FAILED;
      }
      get distanceToCamera() {
        return this._distanceToCamera;
      }
      get screenSpaceError() {
        return this._screenSpaceError;
      }
      get boundingBox() {
        if (!this._boundingBox) {
          this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);
        }
        return this._boundingBox;
      }
      getScreenSpaceError(frameState, useParentLodMetric) {
        switch (this.tileset.type) {
          case TILESET_TYPE.I3S:
            return getProjectedRadius(this, frameState);
          case TILESET_TYPE.TILES3D:
            return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);
          default:
            throw new Error("Unsupported tileset type");
        }
      }
      unselect() {
        this._selectedFrame = 0;
      }
      _getPriority() {
        const traverser = this.tileset._traverser;
        const {
          skipLevelOfDetail
        } = traverser.options;
        const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;
        if (maySkipTile && !this.isVisible && this._visible !== void 0) {
          return -1;
        }
        if (this.tileset._frameNumber - this._touchedFrame >= 1) {
          return -1;
        }
        if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {
          return -1;
        }
        const parent = this.parent;
        const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0 || parent.hasTilesetContent);
        const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;
        const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0;
        return Math.max(rootScreenSpaceError - screenSpaceError, 0);
      }
      async loadContent() {
        if (this.hasEmptyContent) {
          return false;
        }
        if (this.content) {
          return true;
        }
        const expired = this.contentExpired;
        if (expired) {
          this._expireDate = null;
        }
        this.contentState = TILE_CONTENT_STATE.LOADING;
        const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
        if (!requestToken) {
          this.contentState = TILE_CONTENT_STATE.UNLOADED;
          return false;
        }
        try {
          const contentUrl = this.tileset.getTileUrl(this.contentUrl);
          const loader = this.tileset.loader;
          const options = {
            ...this.tileset.loadOptions,
            [loader.id]: {
              ...this.tileset.loadOptions[loader.id],
              isTileset: this.type === "json",
              ...this._getLoaderSpecificOptions(loader.id)
            }
          };
          this.content = await load(contentUrl, loader, options);
          if (this.tileset.options.contentLoader) {
            await this.tileset.options.contentLoader(this);
          }
          if (this._isTileset()) {
            this.tileset._initializeTileHeaders(this.content, this);
          }
          this.contentState = TILE_CONTENT_STATE.READY;
          this._onContentLoaded();
          return true;
        } catch (error) {
          this.contentState = TILE_CONTENT_STATE.FAILED;
          throw error;
        } finally {
          requestToken.done();
        }
      }
      unloadContent() {
        if (this.content && this.content.destroy) {
          this.content.destroy();
        }
        this.content = null;
        if (this.header.content && this.header.content.destroy) {
          this.header.content.destroy();
        }
        this.header.content = null;
        this.contentState = TILE_CONTENT_STATE.UNLOADED;
        return true;
      }
      updateVisibility(frameState, viewportIds) {
        if (this._frameNumber === frameState.frameNumber) {
          return;
        }
        const parent = this.parent;
        const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;
        if (this.tileset._traverser.options.updateTransforms) {
          const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;
          this._updateTransform(parentTransform);
        }
        this._distanceToCamera = this.distanceToTile(frameState);
        this._screenSpaceError = this.getScreenSpaceError(frameState, false);
        this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);
        this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;
        this._inRequestVolume = this.insideViewerRequestVolume(frameState);
        this._frameNumber = frameState.frameNumber;
        this.viewportIds = viewportIds;
      }
      visibility(frameState, parentVisibilityPlaneMask) {
        const {
          cullingVolume: cullingVolume2
        } = frameState;
        const {
          boundingVolume
        } = this;
        return cullingVolume2.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
      }
      contentVisibility() {
        return true;
      }
      distanceToTile(frameState) {
        const boundingVolume = this.boundingVolume;
        return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));
      }
      cameraSpaceZDepth(_ref) {
        let {
          camera
        } = _ref;
        const boundingVolume = this.boundingVolume;
        scratchVector13.subVectors(boundingVolume.center, camera.position);
        return camera.direction.dot(scratchVector13);
      }
      insideViewerRequestVolume(frameState) {
        const viewerRequestVolume = this._viewerRequestVolume;
        return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;
      }
      updateExpiration() {
        if (defined3(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
          const now = Date.now();
          if (Date.lessThan(this._expireDate, now)) {
            this.contentState = TILE_CONTENT_STATE.EXPIRED;
            this._expiredContent = this.content;
          }
        }
      }
      get extras() {
        return this.header.extras;
      }
      _initializeLodMetric(header) {
        if ("lodMetricType" in header) {
          this.lodMetricType = header.lodMetricType;
        } else {
          this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;
          console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType");
        }
        if ("lodMetricValue" in header) {
          this.lodMetricValue = header.lodMetricValue;
        } else {
          this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;
          console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue");
        }
      }
      _initializeTransforms(tileHeader) {
        this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();
        const parent = this.parent;
        const tileset = this.tileset;
        const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();
        this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);
        const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();
        this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);
      }
      _initializeBoundingVolumes(tileHeader) {
        this._contentBoundingVolume = null;
        this._viewerRequestVolume = null;
        this._updateBoundingVolume(tileHeader);
      }
      _initializeContent(tileHeader) {
        this.content = {
          _tileset: this.tileset,
          _tile: this
        };
        this.hasEmptyContent = true;
        this.contentState = TILE_CONTENT_STATE.UNLOADED;
        this.hasTilesetContent = false;
        if (tileHeader.contentUrl) {
          this.content = null;
          this.hasEmptyContent = false;
        }
      }
      _initializeRenderingState(header) {
        this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);
        this._shouldRefine = false;
        this._distanceToCamera = 0;
        this._centerZDepth = 0;
        this._screenSpaceError = 0;
        this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;
        this._visible = void 0;
        this._inRequestVolume = false;
        this._stackLength = 0;
        this._selectionDepth = 0;
        this._frameNumber = 0;
        this._touchedFrame = 0;
        this._visitedFrame = 0;
        this._selectedFrame = 0;
        this._requestedFrame = 0;
        this._priority = 0;
      }
      _getRefine(refine) {
        return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;
      }
      _isTileset() {
        return this.contentUrl.indexOf(".json") !== -1;
      }
      _onContentLoaded() {
        switch (this.content && this.content.type) {
          case "vctr":
          case "geom":
            this.tileset._traverser.disableSkipLevelOfDetail = true;
            break;
          default:
        }
        if (this._isTileset()) {
          this.hasTilesetContent = true;
        }
      }
      _updateBoundingVolume(header) {
        this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);
        const content = header.content;
        if (!content) {
          return;
        }
        if (content.boundingVolume) {
          this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);
        }
        if (header.viewerRequestVolume) {
          this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);
        }
      }
      _updateTransform() {
        let parentTransform = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Matrix4();
        const computedTransform = parentTransform.clone().multiplyRight(this.transform);
        const didTransformChange = !computedTransform.equals(this.computedTransform);
        if (!didTransformChange) {
          return;
        }
        this.computedTransform = computedTransform;
        this._updateBoundingVolume(this.header);
      }
      _getLoaderSpecificOptions(loaderId) {
        switch (loaderId) {
          case "i3s":
            return {
              ...this.tileset.options.i3s,
              _tileOptions: {
                attributeUrls: this.header.attributeUrls,
                textureUrl: this.header.textureUrl,
                textureFormat: this.header.textureFormat,
                textureLoaderOptions: this.header.textureLoaderOptions,
                materialDefinition: this.header.materialDefinition,
                isDracoGeometry: this.header.isDracoGeometry,
                mbs: this.header.mbs
              },
              _tilesetOptions: {
                store: this.tileset.tileset.store,
                attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
                fields: this.tileset.tileset.fields
              },
              isTileHeader: false
            };
          case "3d-tiles":
          case "cesium-ion":
          default:
            return get3dTilesOptions(this.tileset.tileset);
        }
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/format-3d-tiles/tileset-3d-traverser.js
var Tileset3DTraverser;
var init_tileset_3d_traverser = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/format-3d-tiles/tileset-3d-traverser.js"() {
    init_constants3();
    init_tileset_traverser();
    Tileset3DTraverser = class extends TilesetTraverser {
      compareDistanceToCamera(a2, b) {
        return b._distanceToCamera === 0 && a2._distanceToCamera === 0 ? b._centerZDepth - a2._centerZDepth : b._distanceToCamera - a2._distanceToCamera;
      }
      updateTileVisibility(tile, frameState) {
        super.updateTileVisibility(tile, frameState);
        if (!tile.isVisibleAndInRequestVolume) {
          return;
        }
        const hasChildren = tile.children.length > 0;
        if (tile.hasTilesetContent && hasChildren) {
          const firstChild = tile.children[0];
          this.updateTileVisibility(firstChild, frameState);
          tile._visible = firstChild._visible;
          return;
        }
        if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {
          tile._visible = false;
          return;
        }
        const replace = tile.refine === TILE_REFINEMENT.REPLACE;
        const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
        if (replace && useOptimization && hasChildren) {
          if (!this.anyChildrenVisible(tile, frameState)) {
            tile._visible = false;
            return;
          }
        }
      }
      meetsScreenSpaceErrorEarly(tile, frameState) {
        const {
          parent
        } = tile;
        if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {
          return false;
        }
        return !this.shouldRefine(tile, frameState, true);
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-pending-tiles-register.js
var I3SPendingTilesRegister;
var init_i3s_pending_tiles_register = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-pending-tiles-register.js"() {
    init_defineProperty();
    I3SPendingTilesRegister = class {
      constructor() {
        _defineProperty(this, "frameNumberMap", /* @__PURE__ */ new Map());
      }
      register(viewportId, frameNumber) {
        const viewportMap = this.frameNumberMap.get(viewportId) || /* @__PURE__ */ new Map();
        const oldCount = viewportMap.get(frameNumber) || 0;
        viewportMap.set(frameNumber, oldCount + 1);
        this.frameNumberMap.set(viewportId, viewportMap);
      }
      deregister(viewportId, frameNumber) {
        const viewportMap = this.frameNumberMap.get(viewportId);
        if (!viewportMap) {
          return;
        }
        const oldCount = viewportMap.get(frameNumber) || 1;
        viewportMap.set(frameNumber, oldCount - 1);
      }
      isZero(viewportId, frameNumber) {
        var _this$frameNumberMap$;
        const count = ((_this$frameNumberMap$ = this.frameNumberMap.get(viewportId)) === null || _this$frameNumberMap$ === void 0 ? void 0 : _this$frameNumberMap$.get(frameNumber)) || 0;
        return count === 0;
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tile-manager.js
var STATUS, I3STileManager;
var init_i3s_tile_manager = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tile-manager.js"() {
    init_defineProperty();
    init_i3s_pending_tiles_register();
    STATUS = {
      REQUESTED: "REQUESTED",
      COMPLETED: "COMPLETED",
      ERROR: "ERROR"
    };
    I3STileManager = class {
      constructor() {
        _defineProperty(this, "_statusMap", void 0);
        _defineProperty(this, "pendingTilesRegister", new I3SPendingTilesRegister());
        this._statusMap = {};
      }
      add(request, key, callback, frameState) {
        if (!this._statusMap[key]) {
          const {
            frameNumber,
            viewport: {
              id
            }
          } = frameState;
          this._statusMap[key] = {
            request,
            callback,
            key,
            frameState,
            status: STATUS.REQUESTED
          };
          this.pendingTilesRegister.register(id, frameNumber);
          request().then((data) => {
            this._statusMap[key].status = STATUS.COMPLETED;
            const {
              frameNumber: actualFrameNumber,
              viewport: {
                id: id2
              }
            } = this._statusMap[key].frameState;
            this.pendingTilesRegister.deregister(id2, actualFrameNumber);
            this._statusMap[key].callback(data, frameState);
          }).catch((error) => {
            this._statusMap[key].status = STATUS.ERROR;
            const {
              frameNumber: actualFrameNumber,
              viewport: {
                id: id2
              }
            } = this._statusMap[key].frameState;
            this.pendingTilesRegister.deregister(id2, actualFrameNumber);
            callback(error);
          });
        }
      }
      update(key, frameState) {
        if (this._statusMap[key]) {
          const {
            frameNumber,
            viewport: {
              id
            }
          } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id, frameNumber);
          const {
            frameNumber: newFrameNumber,
            viewport: {
              id: newViewportId
            }
          } = frameState;
          this.pendingTilesRegister.register(newViewportId, newFrameNumber);
          this._statusMap[key].frameState = frameState;
        }
      }
      find(key) {
        return this._statusMap[key];
      }
      hasPendingTiles(viewportId, frameNumber) {
        return !this.pendingTilesRegister.isZero(viewportId, frameNumber);
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tileset-traverser.js
var I3STilesetTraverser;
var init_i3s_tileset_traverser = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tileset-traverser.js"() {
    init_defineProperty();
    init_esm4();
    init_tileset_traverser();
    init_i3s_lod();
    init_tile_3d();
    init_i3s_tile_manager();
    I3STilesetTraverser = class extends TilesetTraverser {
      constructor(options) {
        super(options);
        _defineProperty(this, "_tileManager", void 0);
        this._tileManager = new I3STileManager();
      }
      traversalFinished(frameState) {
        return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);
      }
      shouldRefine(tile, frameState) {
        tile._lodJudge = getLodStatus(tile, frameState);
        return tile._lodJudge === "DIG";
      }
      updateChildTiles(tile, frameState) {
        const children = tile.header.children || [];
        const childTiles = tile.children;
        const tileset = tile.tileset;
        for (const child of children) {
          const extendedId = "".concat(child.id, "-").concat(frameState.viewport.id);
          const childTile = childTiles && childTiles.find((t2) => t2.id === extendedId);
          if (!childTile) {
            let request = () => this._loadTile(child.id, tileset);
            const cachedRequest = this._tileManager.find(extendedId);
            if (!cachedRequest) {
              if (tileset.tileset.nodePages) {
                request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);
              }
              this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);
            } else {
              this._tileManager.update(extendedId, frameState);
            }
          } else if (childTile) {
            this.updateTile(childTile, frameState);
          }
        }
        return false;
      }
      async _loadTile(nodeId, tileset) {
        const {
          loader
        } = tileset;
        const nodeUrl = tileset.getTileUrl("".concat(tileset.url, "/nodes/").concat(nodeId));
        const options = {
          ...tileset.loadOptions,
          i3s: {
            ...tileset.loadOptions.i3s,
            isTileHeader: true
          }
        };
        return await load(nodeUrl, loader, options);
      }
      _onTileLoad(header, tile, extendedId) {
        const childTile = new Tile3D(tile.tileset, header, tile, extendedId);
        tile.children.push(childTile);
        const frameState = this._tileManager.find(childTile.id).frameState;
        this.updateTile(childTile, frameState);
        if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime)) {
          this.executeTraversal(childTile, frameState);
        }
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-3d.js
function getQueryParamString(queryParams) {
  const queryParamStrings = [];
  for (const key of Object.keys(queryParams)) {
    queryParamStrings.push("".concat(key, "=").concat(queryParams[key]));
  }
  switch (queryParamStrings.length) {
    case 0:
      return "";
    case 1:
      return "?".concat(queryParamStrings[0]);
    default:
      return "?".concat(queryParamStrings.join("&"));
  }
}
var DEFAULT_PROPS2, TILES_TOTAL, TILES_IN_MEMORY, TILES_IN_VIEW, TILES_RENDERABLE, TILES_LOADED, TILES_LOADING, TILES_UNLOADED, TILES_LOAD_FAILED, POINTS_COUNT, TILES_GPU_MEMORY, Tileset3D;
var init_tileset_3d = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-3d.js"() {
    init_defineProperty();
    init_esm8();
    init_esm25();
    init_esm2();
    init_esm3();
    init_tileset_cache();
    init_transform_utils();
    init_frame_state();
    init_zoom();
    init_tile_3d();
    init_constants3();
    init_tileset_traverser();
    init_tileset_3d_traverser();
    init_i3s_tileset_traverser();
    DEFAULT_PROPS2 = {
      description: "",
      ellipsoid: Ellipsoid.WGS84,
      modelMatrix: new Matrix4(),
      throttleRequests: true,
      maxRequests: 64,
      maximumMemoryUsage: 32,
      maximumTilesSelected: 0,
      debounceTime: 0,
      onTileLoad: () => {
      },
      onTileUnload: () => {
      },
      onTileError: () => {
      },
      onTraversalComplete: (selectedTiles) => selectedTiles,
      contentLoader: void 0,
      viewDistanceScale: 1,
      maximumScreenSpaceError: 8,
      loadTiles: true,
      updateTransforms: true,
      viewportTraversersMap: null,
      loadOptions: {
        fetch: {}
      },
      attributions: [],
      basePath: "",
      i3s: {}
    };
    TILES_TOTAL = "Tiles In Tileset(s)";
    TILES_IN_MEMORY = "Tiles In Memory";
    TILES_IN_VIEW = "Tiles In View";
    TILES_RENDERABLE = "Tiles To Render";
    TILES_LOADED = "Tiles Loaded";
    TILES_LOADING = "Tiles Loading";
    TILES_UNLOADED = "Tiles Unloaded";
    TILES_LOAD_FAILED = "Failed Tile Loads";
    POINTS_COUNT = "Points/Vertices";
    TILES_GPU_MEMORY = "Tile Memory Use";
    Tileset3D = class {
      constructor(json, options) {
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "loadOptions", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "tileset", void 0);
        _defineProperty(this, "loader", void 0);
        _defineProperty(this, "url", void 0);
        _defineProperty(this, "basePath", void 0);
        _defineProperty(this, "modelMatrix", void 0);
        _defineProperty(this, "ellipsoid", void 0);
        _defineProperty(this, "lodMetricType", void 0);
        _defineProperty(this, "lodMetricValue", void 0);
        _defineProperty(this, "refine", void 0);
        _defineProperty(this, "root", void 0);
        _defineProperty(this, "roots", void 0);
        _defineProperty(this, "asset", void 0);
        _defineProperty(this, "description", void 0);
        _defineProperty(this, "properties", void 0);
        _defineProperty(this, "extras", void 0);
        _defineProperty(this, "attributions", void 0);
        _defineProperty(this, "credits", void 0);
        _defineProperty(this, "stats", void 0);
        _defineProperty(this, "contentFormats", {
          draco: false,
          meshopt: false,
          dds: false,
          ktx2: false
        });
        _defineProperty(this, "traverseCounter", void 0);
        _defineProperty(this, "geometricError", void 0);
        _defineProperty(this, "selectedTiles", void 0);
        _defineProperty(this, "updatePromise", null);
        _defineProperty(this, "tilesetInitializationPromise", void 0);
        _defineProperty(this, "cartographicCenter", void 0);
        _defineProperty(this, "cartesianCenter", void 0);
        _defineProperty(this, "zoom", void 0);
        _defineProperty(this, "boundingVolume", void 0);
        _defineProperty(this, "gpuMemoryUsageInBytes", void 0);
        _defineProperty(this, "dynamicScreenSpaceErrorComputedDensity", void 0);
        _defineProperty(this, "_traverser", void 0);
        _defineProperty(this, "_cache", void 0);
        _defineProperty(this, "_requestScheduler", void 0);
        _defineProperty(this, "_frameNumber", void 0);
        _defineProperty(this, "_queryParamsString", void 0);
        _defineProperty(this, "_queryParams", void 0);
        _defineProperty(this, "_extensionsUsed", void 0);
        _defineProperty(this, "_tiles", void 0);
        _defineProperty(this, "_pendingCount", void 0);
        _defineProperty(this, "lastUpdatedVieports", void 0);
        _defineProperty(this, "_requestedTiles", void 0);
        _defineProperty(this, "_emptyTiles", void 0);
        _defineProperty(this, "frameStateData", void 0);
        _defineProperty(this, "maximumMemoryUsage", void 0);
        assert2(json);
        this.options = {
          ...DEFAULT_PROPS2,
          ...options
        };
        this.tileset = json;
        this.loader = json.loader;
        this.type = json.type;
        this.url = json.url;
        this.basePath = json.basePath || path_exports.dirname(this.url);
        this.modelMatrix = this.options.modelMatrix;
        this.ellipsoid = this.options.ellipsoid;
        this.lodMetricType = json.lodMetricType;
        this.lodMetricValue = json.lodMetricValue;
        this.refine = json.root.refine;
        this.loadOptions = this.options.loadOptions || {};
        this.root = null;
        this.roots = {};
        this.cartographicCenter = null;
        this.cartesianCenter = null;
        this.zoom = 1;
        this.boundingVolume = null;
        this.traverseCounter = 0;
        this.geometricError = 0;
        this._traverser = this._initializeTraverser();
        this._cache = new TilesetCache();
        this._requestScheduler = new RequestScheduler({
          throttleRequests: this.options.throttleRequests,
          maxRequests: this.options.maxRequests
        });
        this._frameNumber = 0;
        this._pendingCount = 0;
        this._tiles = {};
        this.selectedTiles = [];
        this._emptyTiles = [];
        this._requestedTiles = [];
        this.frameStateData = {};
        this.lastUpdatedVieports = null;
        this._queryParams = {};
        this._queryParamsString = "";
        this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;
        this.gpuMemoryUsageInBytes = 0;
        this.stats = new Stats({
          id: this.url
        });
        this._initializeStats();
        this._extensionsUsed = void 0;
        this.dynamicScreenSpaceErrorComputedDensity = 0;
        this.extras = null;
        this.asset = {};
        this.credits = {};
        this.description = this.options.description || "";
        this.tilesetInitializationPromise = this._initializeTileSet(json);
      }
      destroy() {
        this._destroy();
      }
      isLoaded() {
        return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
      }
      get tiles() {
        return Object.values(this._tiles);
      }
      get frameNumber() {
        return this._frameNumber;
      }
      get queryParams() {
        if (!this._queryParamsString) {
          this._queryParamsString = getQueryParamString(this._queryParams);
        }
        return this._queryParamsString;
      }
      setProps(props) {
        this.options = {
          ...this.options,
          ...props
        };
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options
        };
      }
      getTileUrl(tilePath) {
        const isDataUrl = tilePath.startsWith("data:");
        if (isDataUrl) {
          return tilePath;
        }
        return "".concat(tilePath).concat(this.queryParams);
      }
      hasExtension(extensionName) {
        return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);
      }
      update() {
        let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        this.tilesetInitializationPromise.then(() => {
          if (!viewports && this.lastUpdatedVieports) {
            viewports = this.lastUpdatedVieports;
          } else {
            this.lastUpdatedVieports = viewports;
          }
          if (viewports) {
            this.doUpdate(viewports);
          }
        });
      }
      async selectTiles() {
        let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        await this.tilesetInitializationPromise;
        if (viewports) {
          this.lastUpdatedVieports = viewports;
        }
        if (!this.updatePromise) {
          this.updatePromise = new Promise((resolve) => {
            setTimeout(() => {
              if (this.lastUpdatedVieports) {
                this.doUpdate(this.lastUpdatedVieports);
              }
              resolve(this._frameNumber);
              this.updatePromise = null;
            }, this.options.debounceTime);
          });
        }
        return this.updatePromise;
      }
      doUpdate(viewports) {
        if ("loadTiles" in this.options && !this.options.loadTiles) {
          return;
        }
        if (this.traverseCounter > 0) {
          return;
        }
        const preparedViewports = viewports instanceof Array ? viewports : [viewports];
        this._cache.reset();
        this._frameNumber++;
        this.traverseCounter = preparedViewports.length;
        const viewportsToTraverse = [];
        for (const viewport of preparedViewports) {
          const id = viewport.id;
          if (this._needTraverse(id)) {
            viewportsToTraverse.push(id);
          } else {
            this.traverseCounter--;
          }
        }
        for (const viewport of preparedViewports) {
          const id = viewport.id;
          if (!this.roots[id]) {
            this.roots[id] = this._initializeTileHeaders(this.tileset, null);
          }
          if (!viewportsToTraverse.includes(id)) {
            continue;
          }
          const frameState = getFrameState(viewport, this._frameNumber);
          this._traverser.traverse(this.roots[id], frameState, this.options);
        }
      }
      _needTraverse(viewportId) {
        let traverserId = viewportId;
        if (this.options.viewportTraversersMap) {
          traverserId = this.options.viewportTraversersMap[viewportId];
        }
        if (traverserId !== viewportId) {
          return false;
        }
        return true;
      }
      _onTraversalEnd(frameState) {
        const id = frameState.viewport.id;
        if (!this.frameStateData[id]) {
          this.frameStateData[id] = {
            selectedTiles: [],
            _requestedTiles: [],
            _emptyTiles: []
          };
        }
        const currentFrameStateData = this.frameStateData[id];
        const selectedTiles = Object.values(this._traverser.selectedTiles);
        const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);
        currentFrameStateData.selectedTiles = filteredSelectedTiles;
        for (const tile of unselectedTiles) {
          tile.unselect();
        }
        currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);
        currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);
        this.traverseCounter--;
        if (this.traverseCounter > 0) {
          return;
        }
        this._updateTiles();
      }
      _updateTiles() {
        this.selectedTiles = [];
        this._requestedTiles = [];
        this._emptyTiles = [];
        for (const frameStateKey in this.frameStateData) {
          const frameStateDataValue = this.frameStateData[frameStateKey];
          this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);
          this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);
          this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);
        }
        this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
        for (const tile of this.selectedTiles) {
          this._tiles[tile.id] = tile;
        }
        this._loadTiles();
        this._unloadTiles();
        this._updateStats();
      }
      _tilesChanged(oldSelectedTiles, selectedTiles) {
        if (oldSelectedTiles.length !== selectedTiles.length) {
          return true;
        }
        const set1 = new Set(oldSelectedTiles.map((t2) => t2.id));
        const set2 = new Set(selectedTiles.map((t2) => t2.id));
        let changed = oldSelectedTiles.filter((x2) => !set2.has(x2.id)).length > 0;
        changed = changed || selectedTiles.filter((x2) => !set1.has(x2.id)).length > 0;
        return changed;
      }
      _loadTiles() {
        for (const tile of this._requestedTiles) {
          if (tile.contentUnloaded) {
            this._loadTile(tile);
          }
        }
      }
      _unloadTiles() {
        this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
      }
      _updateStats() {
        let tilesRenderable = 0;
        let pointsRenderable = 0;
        for (const tile of this.selectedTiles) {
          if (tile.contentAvailable && tile.content) {
            tilesRenderable++;
            if (tile.content.pointCount) {
              pointsRenderable += tile.content.pointCount;
            } else {
              pointsRenderable += tile.content.vertexCount;
            }
          }
        }
        this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
        this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
        this.stats.get(POINTS_COUNT).count = pointsRenderable;
      }
      async _initializeTileSet(tilesetJson) {
        if (this.type === TILESET_TYPE.I3S) {
          this.calculateViewPropsI3S();
          tilesetJson.root = await tilesetJson.root;
        }
        this.root = this._initializeTileHeaders(tilesetJson, null);
        if (this.type === TILESET_TYPE.TILES3D) {
          this._initializeTiles3DTileset(tilesetJson);
          this.calculateViewPropsTiles3D();
        }
        if (this.type === TILESET_TYPE.I3S) {
          this._initializeI3STileset();
        }
      }
      calculateViewPropsI3S() {
        var _this$tileset$store;
        const fullExtent = this.tileset.fullExtent;
        if (fullExtent) {
          const {
            xmin,
            xmax,
            ymin,
            ymax,
            zmin,
            zmax
          } = fullExtent;
          this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);
          this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());
          this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);
          return;
        }
        const extent = (_this$tileset$store = this.tileset.store) === null || _this$tileset$store === void 0 ? void 0 : _this$tileset$store.extent;
        if (extent) {
          const [xmin, ymin, xmax, ymax] = extent;
          this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);
          this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());
          this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);
          return;
        }
        console.warn("Extent is not defined in the tileset header");
        this.cartographicCenter = new Vector3();
        this.zoom = 1;
        return;
      }
      calculateViewPropsTiles3D() {
        const root = this.root;
        assert2(root);
        const {
          center
        } = root.boundingVolume;
        if (!center) {
          console.warn("center was not pre-calculated for the root tile");
          this.cartographicCenter = new Vector3();
          this.zoom = 1;
          return;
        }
        if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {
          this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());
        } else {
          this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);
        }
        this.cartesianCenter = center;
        this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);
      }
      _initializeStats() {
        this.stats.get(TILES_TOTAL);
        this.stats.get(TILES_LOADING);
        this.stats.get(TILES_IN_MEMORY);
        this.stats.get(TILES_IN_VIEW);
        this.stats.get(TILES_RENDERABLE);
        this.stats.get(TILES_LOADED);
        this.stats.get(TILES_UNLOADED);
        this.stats.get(TILES_LOAD_FAILED);
        this.stats.get(POINTS_COUNT);
        this.stats.get(TILES_GPU_MEMORY, "memory");
      }
      _initializeTileHeaders(tilesetJson, parentTileHeader) {
        const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);
        if (parentTileHeader) {
          parentTileHeader.children.push(rootTile);
          rootTile.depth = parentTileHeader.depth + 1;
        }
        if (this.type === TILESET_TYPE.TILES3D) {
          const stack2 = [];
          stack2.push(rootTile);
          while (stack2.length > 0) {
            const tile = stack2.pop();
            this.stats.get(TILES_TOTAL).incrementCount();
            const children = tile.header.children || [];
            for (const childHeader of children) {
              const childTile = new Tile3D(this, childHeader, tile);
              tile.children.push(childTile);
              childTile.depth = tile.depth + 1;
              stack2.push(childTile);
            }
          }
        }
        return rootTile;
      }
      _initializeTraverser() {
        let TraverserClass;
        const type = this.type;
        switch (type) {
          case TILESET_TYPE.TILES3D:
            TraverserClass = Tileset3DTraverser;
            break;
          case TILESET_TYPE.I3S:
            TraverserClass = I3STilesetTraverser;
            break;
          default:
            TraverserClass = TilesetTraverser;
        }
        return new TraverserClass({
          basePath: this.basePath,
          onTraversalEnd: this._onTraversalEnd.bind(this)
        });
      }
      _destroyTileHeaders(parentTile) {
        this._destroySubtree(parentTile);
      }
      async _loadTile(tile) {
        let loaded;
        try {
          this._onStartTileLoading();
          loaded = await tile.loadContent();
        } catch (error) {
          this._onTileLoadError(tile, error);
        } finally {
          this._onEndTileLoading();
          this._onTileLoad(tile, loaded);
        }
      }
      _onTileLoadError(tile, error) {
        this.stats.get(TILES_LOAD_FAILED).incrementCount();
        const message = error.message || error.toString();
        const url = tile.url;
        console.error("A 3D tile failed to load: ".concat(tile.url, " ").concat(message));
        this.options.onTileError(tile, message, url);
      }
      _onTileLoad(tile, loaded) {
        if (!loaded) {
          return;
        }
        if (this.type === TILESET_TYPE.I3S) {
          var _this$tileset, _this$tileset$nodePag;
          const nodesInNodePages = ((_this$tileset = this.tileset) === null || _this$tileset === void 0 ? void 0 : (_this$tileset$nodePag = _this$tileset.nodePagesTile) === null || _this$tileset$nodePag === void 0 ? void 0 : _this$tileset$nodePag.nodesInNodePages) || 0;
          this.stats.get(TILES_TOTAL).reset();
          this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);
        }
        if (tile && tile.content) {
          calculateTransformProps(tile, tile.content);
        }
        this.updateContentTypes(tile);
        this._addTileToCache(tile);
        this.options.onTileLoad(tile);
      }
      updateContentTypes(tile) {
        if (this.type === TILESET_TYPE.I3S) {
          if (tile.header.isDracoGeometry) {
            this.contentFormats.draco = true;
          }
          switch (tile.header.textureFormat) {
            case "dds":
              this.contentFormats.dds = true;
              break;
            case "ktx2":
              this.contentFormats.ktx2 = true;
              break;
            default:
          }
        } else if (this.type === TILESET_TYPE.TILES3D) {
          var _tile$content;
          const {
            extensionsRemoved = []
          } = ((_tile$content = tile.content) === null || _tile$content === void 0 ? void 0 : _tile$content.gltf) || {};
          if (extensionsRemoved.includes("KHR_draco_mesh_compression")) {
            this.contentFormats.draco = true;
          }
          if (extensionsRemoved.includes("EXT_meshopt_compression")) {
            this.contentFormats.meshopt = true;
          }
          if (extensionsRemoved.includes("KHR_texture_basisu")) {
            this.contentFormats.ktx2 = true;
          }
        }
      }
      _onStartTileLoading() {
        this._pendingCount++;
        this.stats.get(TILES_LOADING).incrementCount();
      }
      _onEndTileLoading() {
        this._pendingCount--;
        this.stats.get(TILES_LOADING).decrementCount();
      }
      _addTileToCache(tile) {
        this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));
      }
      _updateCacheStats(tile) {
        this.stats.get(TILES_LOADED).incrementCount();
        this.stats.get(TILES_IN_MEMORY).incrementCount();
        this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;
        this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
      }
      _unloadTile(tile) {
        this.gpuMemoryUsageInBytes -= tile.content && tile.content.byteLength || 0;
        this.stats.get(TILES_IN_MEMORY).decrementCount();
        this.stats.get(TILES_UNLOADED).incrementCount();
        this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
        this.options.onTileUnload(tile);
        tile.unloadContent();
      }
      _destroy() {
        const stack2 = [];
        if (this.root) {
          stack2.push(this.root);
        }
        while (stack2.length > 0) {
          const tile = stack2.pop();
          for (const child of tile.children) {
            stack2.push(child);
          }
          this._destroyTile(tile);
        }
        this.root = null;
      }
      _destroySubtree(tile) {
        const root = tile;
        const stack2 = [];
        stack2.push(root);
        while (stack2.length > 0) {
          tile = stack2.pop();
          for (const child of tile.children) {
            stack2.push(child);
          }
          if (tile !== root) {
            this._destroyTile(tile);
          }
        }
        root.children = [];
      }
      _destroyTile(tile) {
        this._cache.unloadTile(this, tile);
        this._unloadTile(tile);
        tile.destroy();
      }
      _initializeTiles3DTileset(tilesetJson) {
        this.asset = tilesetJson.asset;
        if (!this.asset) {
          throw new Error("Tileset must have an asset property.");
        }
        if (this.asset.version !== "0.0" && this.asset.version !== "1.0") {
          throw new Error("The tileset must be 3D Tiles version 0.0 or 1.0.");
        }
        if ("tilesetVersion" in this.asset) {
          this._queryParams.v = this.asset.tilesetVersion;
        }
        this.credits = {
          attributions: this.options.attributions || []
        };
        this.description = this.options.description || "";
        this.properties = tilesetJson.properties;
        this.geometricError = tilesetJson.geometricError;
        this._extensionsUsed = tilesetJson.extensionsUsed;
        this.extras = tilesetJson.extras;
      }
      _initializeI3STileset() {
        if (this.loadOptions.i3s && "token" in this.loadOptions.i3s) {
          this._queryParams.token = this.loadOptions.i3s.token;
        }
      }
    };
  }
});

// node_modules/@loaders.gl/tiles/dist/esm/index.js
var init_esm26 = __esm({
  "node_modules/@loaders.gl/tiles/dist/esm/index.js"() {
    init_tileset_3d();
    init_tile_3d();
    init_tileset_traverser();
    init_tileset_cache();
    init_bounding_volume();
    init_transform_utils();
    init_frame_state();
    init_i3s_lod();
    init_constants3();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/version.js
var VERSION8;
var init_version4 = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/version.js"() {
    VERSION8 = true ? "3.3.3" : "latest";
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/constants.js
var TILE3D_TYPE, TILE3D_TYPES;
var init_constants4 = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/constants.js"() {
    TILE3D_TYPE = {
      COMPOSITE: "cmpt",
      POINT_CLOUD: "pnts",
      BATCHED_3D_MODEL: "b3dm",
      INSTANCED_3D_MODEL: "i3dm",
      GEOMETRY: "geom",
      VECTOR: "vect",
      GLTF: "glTF"
    };
    TILE3D_TYPES = Object.keys(TILE3D_TYPE);
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-utils.js
function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  assert2(arrayBuffer instanceof ArrayBuffer);
  const textDecoder = new TextDecoder("utf8");
  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);
  const string = textDecoder.decode(typedArray);
  return string;
}
function getMagicString2(arrayBuffer) {
  let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const dataView = new DataView(arrayBuffer);
  return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
}
var init_parse_utils = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-utils.js"() {
    init_esm3();
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/constants.js
var GL_PRIMITIVE_MODE, GL_TYPE, GL2;
var init_constants5 = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/constants.js"() {
    GL_PRIMITIVE_MODE = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };
    GL_TYPE = {
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      INT: 5124,
      UNSIGNED_INT: 5125,
      FLOAT: 5126,
      DOUBLE: 5130
    };
    GL2 = {
      ...GL_PRIMITIVE_MODE,
      ...GL_TYPE
    };
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/gl/gl-type.js
var GL_TYPE_TO_ARRAY_TYPE, NAME_TO_GL_TYPE, ERR_TYPE_CONVERSION, GLType;
var init_gl_type = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/gl/gl-type.js"() {
    init_constants5();
    GL_TYPE_TO_ARRAY_TYPE = {
      [GL_TYPE.DOUBLE]: Float64Array,
      [GL_TYPE.FLOAT]: Float32Array,
      [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,
      [GL_TYPE.UNSIGNED_INT]: Uint32Array,
      [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,
      [GL_TYPE.BYTE]: Int8Array,
      [GL_TYPE.SHORT]: Int16Array,
      [GL_TYPE.INT]: Int32Array
    };
    NAME_TO_GL_TYPE = {
      DOUBLE: GL_TYPE.DOUBLE,
      FLOAT: GL_TYPE.FLOAT,
      UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
      UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
      UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
      BYTE: GL_TYPE.BYTE,
      SHORT: GL_TYPE.SHORT,
      INT: GL_TYPE.INT
    };
    ERR_TYPE_CONVERSION = "Failed to convert GL type";
    GLType = class {
      static fromTypedArray(arrayOrType) {
        arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
        for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
          const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
          if (ArrayType === arrayOrType) {
            return glType;
          }
        }
        throw new Error(ERR_TYPE_CONVERSION);
      }
      static fromName(name10) {
        const glType = NAME_TO_GL_TYPE[name10];
        if (!glType) {
          throw new Error(ERR_TYPE_CONVERSION);
        }
        return glType;
      }
      static getArrayType(glType) {
        switch (glType) {
          case GL_TYPE.UNSIGNED_SHORT_5_6_5:
          case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:
          case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:
            return Uint16Array;
          default:
            const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
            if (!ArrayType) {
              throw new Error(ERR_TYPE_CONVERSION);
            }
            return ArrayType;
        }
      }
      static getByteSize(glType) {
        const ArrayType = GLType.getArrayType(glType);
        return ArrayType.BYTES_PER_ELEMENT;
      }
      static validate(glType) {
        return Boolean(GLType.getArrayType(glType));
      }
      static createTypedArray(glType, buffer) {
        let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        let length3 = arguments.length > 3 ? arguments[3] : void 0;
        if (length3 === void 0) {
          length3 = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);
        }
        const ArrayType = GLType.getArrayType(glType);
        return new ArrayType(buffer, byteOffset, length3);
      }
    };
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/is-geometry.js
var init_is_geometry = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/is-geometry.js"() {
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/iterators/attribute-iterator.js
var init_attribute_iterator = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/iterators/attribute-iterator.js"() {
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/primitives/modes.js
var init_modes = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/primitives/modes.js"() {
    init_constants5();
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/iterators/primitive-iterator.js
var init_primitive_iterator = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/iterators/primitive-iterator.js"() {
    init_constants5();
    init_modes();
    init_esm3();
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/utils/assert.js
function assert7(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion failed. ".concat(message));
  }
}
var init_assert3 = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/utils/assert.js"() {
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/attributes/get-attribute-from-geometry.js
var init_get_attribute_from_geometry = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/attributes/get-attribute-from-geometry.js"() {
    init_is_geometry();
    init_assert3();
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/attributes/compute-vertex-normals.js
var init_compute_vertex_normals = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/attributes/compute-vertex-normals.js"() {
    init_esm8();
    init_constants5();
    init_assert3();
    init_primitive_iterator();
    init_modes();
    init_get_attribute_from_geometry();
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/colors/rgb565.js
function decodeRGB565(rgb565) {
  let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  const r5 = rgb565 >> 11 & 31;
  const g6 = rgb565 >> 5 & 63;
  const b5 = rgb565 & 31;
  target[0] = r5 << 3;
  target[1] = g6 << 2;
  target[2] = b5 << 3;
  return target;
}
var init_rgb565 = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/colors/rgb565.js"() {
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/typed-arrays/typed-array-utils.js
var init_typed_array_utils = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/typed-arrays/typed-array-utils.js"() {
  }
});

// node_modules/@loaders.gl/math/dist/esm/geometry/compression/attribute-compression.js
function fromSNorm(value) {
  let rangeMaximum = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
  return clamp(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
}
function signNotZero(value) {
  return value < 0 ? -1 : 1;
}
function octDecodeInRange(x2, y2, rangeMax, result) {
  assert7(result);
  if (x2 < 0 || x2 > rangeMax || y2 < 0 || y2 > rangeMax) {
    throw new Error("x and y must be unsigned normalized integers between 0 and ".concat(rangeMax));
  }
  result.x = fromSNorm(x2, rangeMax);
  result.y = fromSNorm(y2, rangeMax);
  result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
  if (result.z < 0) {
    const oldVX = result.x;
    result.x = (1 - Math.abs(result.y)) * signNotZero(oldVX);
    result.y = (1 - Math.abs(oldVX)) * signNotZero(result.y);
  }
  return result.normalize();
}
function octDecode(x2, y2, result) {
  return octDecodeInRange(x2, y2, 255, result);
}
var RIGHT_SHIFT, scratchVector25, scratchVector34, scratchEncodeVector2, octEncodeScratch, uint8ForceArray;
var init_attribute_compression = __esm({
  "node_modules/@loaders.gl/math/dist/esm/geometry/compression/attribute-compression.js"() {
    init_esm8();
    init_assert3();
    RIGHT_SHIFT = 1 / 256;
    scratchVector25 = new Vector2();
    scratchVector34 = new Vector3();
    scratchEncodeVector2 = new Vector2();
    octEncodeScratch = new Vector2();
    uint8ForceArray = new Uint8Array(1);
  }
});

// node_modules/@loaders.gl/math/dist/esm/index.js
var init_esm27 = __esm({
  "node_modules/@loaders.gl/math/dist/esm/index.js"() {
    init_constants5();
    init_constants5();
    init_gl_type();
    init_is_geometry();
    init_attribute_iterator();
    init_primitive_iterator();
    init_compute_vertex_normals();
    init_rgb565();
    init_typed_array_utils();
    init_attribute_compression();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-feature-table.js
var Tile3DFeatureTable;
var init_tile_3d_feature_table = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-feature-table.js"() {
    init_defineProperty();
    init_esm27();
    Tile3DFeatureTable = class {
      constructor(featureTableJson, featureTableBinary) {
        _defineProperty(this, "json", void 0);
        _defineProperty(this, "buffer", void 0);
        _defineProperty(this, "featuresLength", 0);
        _defineProperty(this, "_cachedTypedArrays", {});
        this.json = featureTableJson;
        this.buffer = featureTableBinary;
      }
      getExtension(extensionName) {
        return this.json.extensions && this.json.extensions[extensionName];
      }
      hasProperty(propertyName) {
        return Boolean(this.json[propertyName]);
      }
      getGlobalProperty(propertyName) {
        let componentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GL2.UNSIGNED_INT;
        let componentLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        const jsonValue = this.json[propertyName];
        if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
          return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
        }
        return jsonValue;
      }
      getPropertyArray(propertyName, componentType, componentLength) {
        const jsonValue = this.json[propertyName];
        if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
          if ("componentType" in jsonValue) {
            componentType = GLType.fromName(jsonValue.componentType);
          }
          return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
        }
        return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
      }
      getProperty(propertyName, componentType, componentLength, featureId, result) {
        const jsonValue = this.json[propertyName];
        if (!jsonValue) {
          return jsonValue;
        }
        const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
        if (componentLength === 1) {
          return typedArray[featureId];
        }
        for (let i3 = 0; i3 < componentLength; ++i3) {
          result[i3] = typedArray[componentLength * featureId + i3];
        }
        return result;
      }
      _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {
        const cachedTypedArrays = this._cachedTypedArrays;
        let typedArray = cachedTypedArrays[propertyName];
        if (!typedArray) {
          typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);
          cachedTypedArrays[propertyName] = typedArray;
        }
        return typedArray;
      }
      _getTypedArrayFromArray(propertyName, componentType, array) {
        const cachedTypedArrays = this._cachedTypedArrays;
        let typedArray = cachedTypedArrays[propertyName];
        if (!typedArray) {
          typedArray = GLType.createTypedArray(componentType, array);
          cachedTypedArrays[propertyName] = typedArray;
        }
        return typedArray;
      }
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/helpers/tile-3d-accessor-utils.js
function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length3) {
  const {
    componentType
  } = tile3DAccessor;
  assert2(tile3DAccessor.componentType);
  const type = typeof componentType === "string" ? GLType.fromName(componentType) : componentType;
  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
  const unpacker = UNPACKER[tile3DAccessor.type];
  const packer = PACKER[tile3DAccessor.type];
  byteOffset += tile3DAccessor.byteOffset;
  const values = GLType.createTypedArray(type, buffer, byteOffset, size * length3);
  return {
    values,
    type,
    size,
    unpacker,
    packer
  };
}
var COMPONENTS_PER_ATTRIBUTE, UNPACKER, PACKER;
var init_tile_3d_accessor_utils = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/helpers/tile-3d-accessor-utils.js"() {
    init_esm27();
    init_esm3();
    COMPONENTS_PER_ATTRIBUTE = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    };
    UNPACKER = {
      SCALAR: (values, i3) => values[i3],
      VEC2: (values, i3) => [values[2 * i3 + 0], values[2 * i3 + 1]],
      VEC3: (values, i3) => [values[3 * i3 + 0], values[3 * i3 + 1], values[3 * i3 + 2]],
      VEC4: (values, i3) => [values[4 * i3 + 0], values[4 * i3 + 1], values[4 * i3 + 2], values[4 * i3 + 3]],
      MAT2: (values, i3) => [values[4 * i3 + 0], values[4 * i3 + 1], values[4 * i3 + 2], values[4 * i3 + 3]],
      MAT3: (values, i3) => [values[9 * i3 + 0], values[9 * i3 + 1], values[9 * i3 + 2], values[9 * i3 + 3], values[9 * i3 + 4], values[9 * i3 + 5], values[9 * i3 + 6], values[9 * i3 + 7], values[9 * i3 + 8]],
      MAT4: (values, i3) => [values[16 * i3 + 0], values[16 * i3 + 1], values[16 * i3 + 2], values[16 * i3 + 3], values[16 * i3 + 4], values[16 * i3 + 5], values[16 * i3 + 6], values[16 * i3 + 7], values[16 * i3 + 8], values[16 * i3 + 9], values[16 * i3 + 10], values[16 * i3 + 11], values[16 * i3 + 12], values[16 * i3 + 13], values[16 * i3 + 14], values[16 * i3 + 15]]
    };
    PACKER = {
      SCALAR: (x2, values, i3) => {
        values[i3] = x2;
      },
      VEC2: (x2, values, i3) => {
        values[2 * i3 + 0] = x2[0];
        values[2 * i3 + 1] = x2[1];
      },
      VEC3: (x2, values, i3) => {
        values[3 * i3 + 0] = x2[0];
        values[3 * i3 + 1] = x2[1];
        values[3 * i3 + 2] = x2[2];
      },
      VEC4: (x2, values, i3) => {
        values[4 * i3 + 0] = x2[0];
        values[4 * i3 + 1] = x2[1];
        values[4 * i3 + 2] = x2[2];
        values[4 * i3 + 3] = x2[3];
      },
      MAT2: (x2, values, i3) => {
        values[4 * i3 + 0] = x2[0];
        values[4 * i3 + 1] = x2[1];
        values[4 * i3 + 2] = x2[2];
        values[4 * i3 + 3] = x2[3];
      },
      MAT3: (x2, values, i3) => {
        values[9 * i3 + 0] = x2[0];
        values[9 * i3 + 1] = x2[1];
        values[9 * i3 + 2] = x2[2];
        values[9 * i3 + 3] = x2[3];
        values[9 * i3 + 4] = x2[4];
        values[9 * i3 + 5] = x2[5];
        values[9 * i3 + 6] = x2[6];
        values[9 * i3 + 7] = x2[7];
        values[9 * i3 + 8] = x2[8];
        values[9 * i3 + 9] = x2[9];
      },
      MAT4: (x2, values, i3) => {
        values[16 * i3 + 0] = x2[0];
        values[16 * i3 + 1] = x2[1];
        values[16 * i3 + 2] = x2[2];
        values[16 * i3 + 3] = x2[3];
        values[16 * i3 + 4] = x2[4];
        values[16 * i3 + 5] = x2[5];
        values[16 * i3 + 6] = x2[6];
        values[16 * i3 + 7] = x2[7];
        values[16 * i3 + 8] = x2[8];
        values[16 * i3 + 9] = x2[9];
        values[16 * i3 + 10] = x2[10];
        values[16 * i3 + 11] = x2[11];
        values[16 * i3 + 12] = x2[12];
        values[16 * i3 + 13] = x2[13];
        values[16 * i3 + 14] = x2[14];
        values[16 * i3 + 15] = x2[15];
      }
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table-hierarchy.js
function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
  if (!jsonHeader) {
    return null;
  }
  let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
  const legacyHierarchy = jsonHeader.HIERARCHY;
  if (legacyHierarchy) {
    console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
    jsonHeader.extensions = jsonHeader.extensions || {};
    jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
    hierarchy = legacyHierarchy;
  }
  if (!hierarchy) {
    return null;
  }
  return initializeHierarchyValues(hierarchy, binaryBody);
}
function initializeHierarchyValues(hierarchyJson, binaryBody) {
  let i3;
  let classId;
  let binaryAccessor;
  const instancesLength = hierarchyJson.instancesLength;
  const classes = hierarchyJson.classes;
  let classIds = hierarchyJson.classIds;
  let parentCounts = hierarchyJson.parentCounts;
  let parentIds = hierarchyJson.parentIds;
  let parentIdsLength = instancesLength;
  if (defined4(classIds.byteOffset)) {
    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
    classIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(classIds);
    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
  }
  let parentIndexes;
  if (defined4(parentCounts)) {
    if (defined4(parentCounts.byteOffset)) {
      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
      parentCounts.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentCounts);
      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
    }
    parentIndexes = new Uint16Array(instancesLength);
    parentIdsLength = 0;
    for (i3 = 0; i3 < instancesLength; ++i3) {
      parentIndexes[i3] = parentIdsLength;
      parentIdsLength += parentCounts[i3];
    }
  }
  if (defined4(parentIds) && defined4(parentIds.byteOffset)) {
    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
    parentIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(parentIds);
    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
  }
  const classesLength = classes.length;
  for (i3 = 0; i3 < classesLength; ++i3) {
    const classInstancesLength = classes[i3].length;
    const properties = classes[i3].instances;
    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
    classes[i3].instances = combine(binaryProperties, properties);
  }
  const classCounts = new Array(classesLength).fill(0);
  const classIndexes = new Uint16Array(instancesLength);
  for (i3 = 0; i3 < instancesLength; ++i3) {
    classId = classIds[i3];
    classIndexes[i3] = classCounts[classId];
    ++classCounts[classId];
  }
  const hierarchy = {
    classes,
    classIds,
    classIndexes,
    parentCounts,
    parentIndexes,
    parentIds
  };
  validateHierarchy(hierarchy);
  return hierarchy;
}
function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
  if (!hierarchy) {
    return;
  }
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  if (parentIds) {
    return endConditionCallback(hierarchy, instanceIndex);
  }
  if (parentCounts > 0) {
    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
  }
  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
}
function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
  const classIds = hierarchy.classIds;
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const instancesLength = classIds.length;
  const visited = scratchVisited;
  visited.length = Math.max(visited.length, instancesLength);
  const visitedMarker = ++marker;
  const stack2 = scratchStack;
  stack2.length = 0;
  stack2.push(instanceIndex);
  while (stack2.length > 0) {
    instanceIndex = stack2.pop();
    if (visited[instanceIndex] === visitedMarker) {
      continue;
    }
    visited[instanceIndex] = visitedMarker;
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined4(result)) {
      return result;
    }
    const parentCount = parentCounts[instanceIndex];
    const parentIndex = parentIndexes[instanceIndex];
    for (let i3 = 0; i3 < parentCount; ++i3) {
      const parentId = parentIds[parentIndex + i3];
      if (parentId !== instanceIndex) {
        stack2.push(parentId);
      }
    }
  }
  return null;
}
function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
  let hasParent = true;
  while (hasParent) {
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined4(result)) {
      return result;
    }
    const parentId = hierarchy.parentIds[instanceIndex];
    hasParent = parentId !== instanceIndex;
    instanceIndex = parentId;
  }
  throw new Error("traverseHierarchySingleParent");
}
function validateHierarchy(hierarchy) {
  const scratchValidateStack = [];
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  for (let i3 = 0; i3 < instancesLength; ++i3) {
    validateInstance(hierarchy, i3, stack);
  }
}
function validateInstance(hierarchy, instanceIndex, stack2) {
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  if (!defined4(parentIds)) {
    return;
  }
  assert(instanceIndex < instancesLength, "Parent index ".concat(instanceIndex, " exceeds the total number of instances: ").concat(instancesLength));
  assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
  stack2.push(instanceIndex);
  const parentCount = defined4(parentCounts) ? parentCounts[instanceIndex] : 1;
  const parentIndex = defined4(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
  for (let i3 = 0; i3 < parentCount; ++i3) {
    const parentId = parentIds[parentIndex + i3];
    if (parentId !== instanceIndex) {
      validateInstance(hierarchy, parentId, stack2);
    }
  }
  stack2.pop(instanceIndex);
}
var defined4;
var init_tile_3d_batch_table_hierarchy = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table-hierarchy.js"() {
    defined4 = (x2) => x2 !== void 0;
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table.js
function defined5(x2) {
  return x2 !== void 0 && x2 !== null;
}
var clone2, IGNORED_PROPERTY_FIELDS, Tile3DBatchTableParser;
var init_tile_3d_batch_table = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table.js"() {
    init_defineProperty();
    init_esm3();
    init_tile_3d_accessor_utils();
    init_tile_3d_batch_table_hierarchy();
    clone2 = (x2, y2) => x2;
    IGNORED_PROPERTY_FIELDS = {
      HIERARCHY: true,
      extensions: true,
      extras: true
    };
    Tile3DBatchTableParser = class {
      constructor(json, binary, featureCount) {
        var _this$json;
        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        _defineProperty(this, "json", void 0);
        _defineProperty(this, "binary", void 0);
        _defineProperty(this, "featureCount", void 0);
        _defineProperty(this, "_extensions", void 0);
        _defineProperty(this, "_properties", void 0);
        _defineProperty(this, "_binaryProperties", void 0);
        _defineProperty(this, "_hierarchy", void 0);
        assert2(featureCount >= 0);
        this.json = json || {};
        this.binary = binary;
        this.featureCount = featureCount;
        this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};
        this._properties = {};
        for (const propertyName in this.json) {
          if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
            this._properties[propertyName] = this.json[propertyName];
          }
        }
        this._binaryProperties = this._initializeBinaryProperties();
        if (options["3DTILES_batch_table_hierarchy"]) {
          this._hierarchy = initializeHierarchy(this, this.json, this.binary);
        }
      }
      getExtension(extensionName) {
        return this.json && this.json.extensions && this.json.extensions[extensionName];
      }
      memorySizeInBytes() {
        return 0;
      }
      isClass(batchId, className) {
        this._checkBatchId(batchId);
        assert2(typeof className === "string", className);
        if (this._hierarchy) {
          const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
            const classId = hierarchy.classIds[instanceIndex];
            const instanceClass = hierarchy.classes[classId];
            return instanceClass.name === className;
          });
          return defined5(result);
        }
        return false;
      }
      isExactClass(batchId, className) {
        assert2(typeof className === "string", className);
        return this.getExactClassName(batchId) === className;
      }
      getExactClassName(batchId) {
        this._checkBatchId(batchId);
        if (this._hierarchy) {
          const classId = this._hierarchy.classIds[batchId];
          const instanceClass = this._hierarchy.classes[classId];
          return instanceClass.name;
        }
        return void 0;
      }
      hasProperty(batchId, name10) {
        this._checkBatchId(batchId);
        assert2(typeof name10 === "string", name10);
        return defined5(this._properties[name10]) || this._hasPropertyInHierarchy(batchId, name10);
      }
      getPropertyNames(batchId, results) {
        this._checkBatchId(batchId);
        results = defined5(results) ? results : [];
        results.length = 0;
        const propertyNames = Object.keys(this._properties);
        results.push(...propertyNames);
        if (this._hierarchy) {
          this._getPropertyNamesInHierarchy(batchId, results);
        }
        return results;
      }
      getProperty(batchId, name10) {
        this._checkBatchId(batchId);
        assert2(typeof name10 === "string", name10);
        if (this._binaryProperties) {
          const binaryProperty = this._binaryProperties[name10];
          if (defined5(binaryProperty)) {
            return this._getBinaryProperty(binaryProperty, batchId);
          }
        }
        const propertyValues = this._properties[name10];
        if (defined5(propertyValues)) {
          return clone2(propertyValues[batchId], true);
        }
        if (this._hierarchy) {
          const hierarchyProperty = this._getHierarchyProperty(batchId, name10);
          if (defined5(hierarchyProperty)) {
            return hierarchyProperty;
          }
        }
        return void 0;
      }
      setProperty(batchId, name10, value) {
        const featureCount = this.featureCount;
        this._checkBatchId(batchId);
        assert2(typeof name10 === "string", name10);
        if (this._binaryProperties) {
          const binaryProperty = this._binaryProperties[name10];
          if (binaryProperty) {
            this._setBinaryProperty(binaryProperty, batchId, value);
            return;
          }
        }
        if (this._hierarchy) {
          if (this._setHierarchyProperty(this, batchId, name10, value)) {
            return;
          }
        }
        let propertyValues = this._properties[name10];
        if (!defined5(propertyValues)) {
          this._properties[name10] = new Array(featureCount);
          propertyValues = this._properties[name10];
        }
        propertyValues[batchId] = clone2(value, true);
      }
      _checkBatchId(batchId) {
        const valid = batchId >= 0 && batchId < this.featureCount;
        if (!valid) {
          throw new Error("batchId not in range [0, featureCount - 1].");
        }
      }
      _getBinaryProperty(binaryProperty, index) {
        return binaryProperty.unpack(binaryProperty.typedArray, index);
      }
      _setBinaryProperty(binaryProperty, index, value) {
        binaryProperty.pack(value, binaryProperty.typedArray, index);
      }
      _initializeBinaryProperties() {
        let binaryProperties = null;
        for (const name10 in this._properties) {
          const property = this._properties[name10];
          const binaryProperty = this._initializeBinaryProperty(name10, property);
          if (binaryProperty) {
            binaryProperties = binaryProperties || {};
            binaryProperties[name10] = binaryProperty;
          }
        }
        return binaryProperties;
      }
      _initializeBinaryProperty(name10, property) {
        if ("byteOffset" in property) {
          const tile3DAccessor = property;
          assert2(this.binary, "Property ".concat(name10, " requires a batch table binary."));
          assert2(tile3DAccessor.type, "Property ".concat(name10, " requires a type."));
          const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
          return {
            typedArray: accessor.values,
            componentCount: accessor.size,
            unpack: accessor.unpacker,
            pack: accessor.packer
          };
        }
        return null;
      }
      _hasPropertyInHierarchy(batchId, name10) {
        if (!this._hierarchy) {
          return false;
        }
        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instances = hierarchy.classes[classId].instances;
          return defined5(instances[name10]);
        });
        return defined5(result);
      }
      _getPropertyNamesInHierarchy(batchId, results) {
        traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instances = hierarchy.classes[classId].instances;
          for (const name10 in instances) {
            if (instances.hasOwnProperty(name10)) {
              if (results.indexOf(name10) === -1) {
                results.push(name10);
              }
            }
          }
        });
      }
      _getHierarchyProperty(batchId, name10) {
        return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instanceClass = hierarchy.classes[classId];
          const indexInClass = hierarchy.classIndexes[instanceIndex];
          const propertyValues = instanceClass.instances[name10];
          if (defined5(propertyValues)) {
            if (defined5(propertyValues.typedArray)) {
              return this._getBinaryProperty(propertyValues, indexInClass);
            }
            return clone2(propertyValues[indexInClass], true);
          }
          return null;
        });
      }
      _setHierarchyProperty(batchTable, batchId, name10, value) {
        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instanceClass = hierarchy.classes[classId];
          const indexInClass = hierarchy.classIndexes[instanceIndex];
          const propertyValues = instanceClass.instances[name10];
          if (defined5(propertyValues)) {
            assert2(instanceIndex === batchId, 'Inherited property "'.concat(name10, '" is read-only.'));
            if (defined5(propertyValues.typedArray)) {
              this._setBinaryProperty(propertyValues, indexInClass, value);
            } else {
              propertyValues[indexInClass] = clone2(value, true);
            }
            return true;
          }
          return false;
        });
        return defined5(result);
      }
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-header.js
function parse3DTileHeaderSync(tile, arrayBuffer) {
  let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const view = new DataView(arrayBuffer);
  tile.magic = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.version = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.byteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  if (tile.version !== 1) {
    throw new Error("3D Tile Version ".concat(tile.version, " not supported"));
  }
  return byteOffset;
}
var SIZEOF_UINT32;
var init_parse_3d_tile_header = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-header.js"() {
    SIZEOF_UINT32 = 4;
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-tables.js
function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {
  const view = new DataView(arrayBuffer);
  let batchLength;
  tile.header = tile.header || {};
  let featureTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  if (batchTableJsonByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322 * 2;
    batchLength = featureTableJsonByteLength;
    batchTableJsonByteLength = featureTableBinaryByteLength;
    batchTableBinaryByteLength = 0;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  } else if (batchTableBinaryByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322;
    batchLength = batchTableJsonByteLength;
    batchTableJsonByteLength = featureTableJsonByteLength;
    batchTableBinaryByteLength = featureTableBinaryByteLength;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  }
  tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
  tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
  tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
  tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
  tile.header.batchLength = batchLength;
  return byteOffset;
}
function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {
  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);
  return byteOffset;
}
function parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {
  const {
    featureTableJsonByteLength,
    featureTableBinaryByteLength,
    batchLength
  } = tile.header;
  tile.featureTableJson = {
    BATCH_LENGTH: batchLength || 0
  };
  if (featureTableJsonByteLength > 0) {
    const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);
    tile.featureTableJson = JSON.parse(featureTableString);
  }
  byteOffset += featureTableJsonByteLength;
  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
  byteOffset += featureTableBinaryByteLength;
  return byteOffset;
}
function parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {
  const {
    batchTableJsonByteLength,
    batchTableBinaryByteLength
  } = tile.header;
  if (batchTableJsonByteLength > 0) {
    const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);
    tile.batchTableJson = JSON.parse(batchTableString);
    byteOffset += batchTableJsonByteLength;
    if (batchTableBinaryByteLength > 0) {
      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);
      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
      byteOffset += batchTableBinaryByteLength;
    }
  }
  return byteOffset;
}
var SIZEOF_UINT322, DEPRECATION_WARNING;
var init_parse_3d_tile_tables = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-tables.js"() {
    init_parse_utils();
    SIZEOF_UINT322 = 4;
    DEPRECATION_WARNING = "b3dm tile in legacy format.";
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-colors.js
function normalize3DTileColorAttribute(tile, colors, batchTable) {
  if (!colors && (!tile || !tile.batchIds || !batchTable)) {
    return null;
  }
  const {
    batchIds,
    isRGB565,
    pointCount
  } = tile;
  if (batchIds && batchTable) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i3 = 0; i3 < pointCount; i3++) {
      const batchId = batchIds[i3];
      const dimensions = batchTable.getProperty(batchId, "dimensions");
      const color = dimensions.map((d) => d * 255);
      colorArray[i3 * 3] = color[0];
      colorArray[i3 * 3 + 1] = color[1];
      colorArray[i3 * 3 + 2] = color[2];
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (isRGB565) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i3 = 0; i3 < pointCount; i3++) {
      const color = decodeRGB565(colors[i3]);
      colorArray[i3 * 3] = color[0];
      colorArray[i3 * 3 + 1] = color[1];
      colorArray[i3 * 3 + 2] = color[2];
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (colors && colors.length === pointCount * 3) {
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colors,
      size: 3,
      normalized: true
    };
  }
  return {
    type: GL2.UNSIGNED_BYTE,
    value: colors,
    size: 4,
    normalized: true
  };
}
var init_normalize_3d_tile_colors = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-colors.js"() {
    init_esm27();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-normals.js
function normalize3DTileNormalAttribute(tile, normals) {
  if (!normals) {
    return null;
  }
  if (tile.isOctEncoded16P) {
    const decodedArray = new Float32Array(tile.pointsLength * 3);
    for (let i3 = 0; i3 < tile.pointsLength; i3++) {
      octDecode(normals[i3 * 2], normals[i3 * 2 + 1], scratchNormal4);
      scratchNormal4.toArray(decodedArray, i3 * 3);
    }
    return {
      type: GL2.FLOAT,
      size: 2,
      value: decodedArray
    };
  }
  return {
    type: GL2.FLOAT,
    size: 2,
    value: normals
  };
}
var scratchNormal4;
var init_normalize_3d_tile_normals = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-normals.js"() {
    init_esm8();
    init_esm27();
    scratchNormal4 = new Vector3();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-positions.js
function normalize3DTilePositionAttribute(tile, positions, options) {
  if (!tile.isQuantized) {
    return positions;
  }
  if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
    tile.isQuantized = false;
    return decodeQuantizedPositions(tile, positions);
  }
  return {
    type: GL2.UNSIGNED_SHORT,
    value: positions,
    size: 3,
    normalized: true
  };
}
function decodeQuantizedPositions(tile, positions) {
  const scratchPosition5 = new Vector3();
  const decodedArray = new Float32Array(tile.pointCount * 3);
  for (let i3 = 0; i3 < tile.pointCount; i3++) {
    scratchPosition5.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i3 * 3);
  }
  return decodedArray;
}
var init_normalize_3d_tile_positions = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-positions.js"() {
    init_esm8();
    init_esm27();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-point-cloud.js
async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  initializeTile(tile);
  const {
    featureTable,
    batchTable
  } = parsePointCloudTables(tile);
  await parseDraco(tile, featureTable, batchTable, options, context);
  parsePositions(tile, featureTable, options);
  parseColors(tile, featureTable, batchTable);
  parseNormals(tile, featureTable);
  return byteOffset;
}
function initializeTile(tile) {
  tile.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  tile.isQuantized = false;
  tile.isTranslucent = false;
  tile.isRGB565 = false;
  tile.isOctEncoded16P = false;
}
function parsePointCloudTables(tile) {
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(pointsLength)) {
    throw new Error("POINTS_LENGTH must be defined");
  }
  featureTable.featuresLength = pointsLength;
  tile.featuresLength = pointsLength;
  tile.pointsLength = pointsLength;
  tile.pointCount = pointsLength;
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  const batchTable = parseBatchIds(tile, featureTable);
  return {
    featureTable,
    batchTable
  };
}
function parsePositions(tile, featureTable, options) {
  if (!tile.attributes.positions) {
    if (featureTable.hasProperty("POSITION")) {
      tile.attributes.positions = featureTable.getPropertyArray("POSITION", GL2.FLOAT, 3);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3);
      tile.isQuantized = true;
      tile.quantizedRange = (1 << 16) - 1;
      tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
      if (!tile.quantizedVolumeScale) {
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
      if (!tile.quantizedVolumeOffset) {
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
    }
  }
  if (!tile.attributes.positions) {
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
  }
}
function parseColors(tile, featureTable, batchTable) {
  if (!tile.attributes.colors) {
    let colors = null;
    if (featureTable.hasProperty("RGBA")) {
      colors = featureTable.getPropertyArray("RGBA", GL2.UNSIGNED_BYTE, 4);
      tile.isTranslucent = true;
    } else if (featureTable.hasProperty("RGB")) {
      colors = featureTable.getPropertyArray("RGB", GL2.UNSIGNED_BYTE, 3);
    } else if (featureTable.hasProperty("RGB565")) {
      colors = featureTable.getPropertyArray("RGB565", GL2.UNSIGNED_SHORT, 1);
      tile.isRGB565 = true;
    }
    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
  }
  if (featureTable.hasProperty("CONSTANT_RGBA")) {
    tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", GL2.UNSIGNED_BYTE, 4);
  }
}
function parseNormals(tile, featureTable) {
  if (!tile.attributes.normals) {
    let normals = null;
    if (featureTable.hasProperty("NORMAL")) {
      normals = featureTable.getPropertyArray("NORMAL", GL2.FLOAT, 3);
    } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
      normals = featureTable.getPropertyArray("NORMAL_OCT16P", GL2.UNSIGNED_BYTE, 2);
      tile.isOctEncoded16P = true;
    }
    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
  }
}
function parseBatchIds(tile, featureTable) {
  let batchTable = null;
  if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
    tile.batchIds = featureTable.getPropertyArray("BATCH_ID", GL2.UNSIGNED_SHORT, 1);
    if (tile.batchIds) {
      const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
      if (!batchFeatureLength) {
        throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
      }
      const {
        batchTableJson,
        batchTableBinary
      } = tile;
      batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
    }
  }
  return batchTable;
}
async function parseDraco(tile, featureTable, batchTable, options, context) {
  let dracoBuffer;
  let dracoFeatureTableProperties;
  let dracoBatchTableProperties;
  const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
  if (batchTableDraco) {
    dracoBatchTableProperties = batchTableDraco.properties;
  }
  const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
  if (featureTableDraco) {
    dracoFeatureTableProperties = featureTableDraco.properties;
    const dracoByteOffset = featureTableDraco.byteOffset;
    const dracoByteLength = featureTableDraco.byteLength;
    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    }
    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
    tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
  }
  if (!dracoBuffer) {
    return true;
  }
  const dracoData = {
    buffer: dracoBuffer,
    properties: {
      ...dracoFeatureTableProperties,
      ...dracoBatchTableProperties
    },
    featureTableProperties: dracoFeatureTableProperties,
    batchTableProperties: dracoBatchTableProperties,
    dequantizeInShader: false
  };
  return await loadDraco(tile, dracoData, options, context);
}
async function loadDraco(tile, dracoData, options, context) {
  const {
    parse: parse4
  } = context;
  const dracoOptions = {
    ...options,
    draco: {
      ...options.draco,
      extraAttributes: dracoData.batchTableProperties || {}
    }
  };
  delete dracoOptions["3d-tiles"];
  const data = await parse4(dracoData.buffer, DracoLoader2, dracoOptions);
  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
  if (isQuantizedDraco) {
    const quantization = data.POSITION.data.quantization;
    const range = quantization.range;
    tile.quantizedVolumeScale = new Vector3(range, range, range);
    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);
    tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
    tile.isQuantizedDraco = true;
  }
  if (isOctEncodedDraco) {
    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
    tile.isOctEncodedDraco = true;
  }
  const batchTableAttributes = {};
  if (dracoData.batchTableProperties) {
    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
      if (data.attributes[attributeName] && data.attributes[attributeName].value) {
        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
      }
    }
  }
  tile.attributes = {
    positions: decodedPositions,
    colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
    normals: decodedNormals,
    batchIds: decodedBatchIds,
    ...batchTableAttributes
  };
}
var init_parse_3d_tile_point_cloud = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-point-cloud.js"() {
    init_esm22();
    init_esm27();
    init_esm8();
    init_tile_3d_feature_table();
    init_tile_3d_batch_table();
    init_parse_3d_tile_header();
    init_parse_3d_tile_tables();
    init_normalize_3d_tile_colors();
    init_normalize_3d_tile_normals();
    init_normalize_3d_tile_positions();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-gltf-view.js
function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {
  tile.rotateYtoZ = true;
  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;
  if (gltfByteLength === 0) {
    throw new Error("glTF byte length must be greater than 0.");
  }
  tile.gltfUpAxis = options["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
  tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);
  tile.gltfByteOffset = 0;
  tile.gltfByteLength = gltfByteLength;
  if (byteOffset % 4 === 0) {
  } else {
    console.warn("".concat(tile.type, ": embedded glb is not aligned to a 4-byte boundary."));
  }
  return tile.byteOffset + tile.byteLength;
}
async function extractGLTF(tile, gltfFormat, options, context) {
  const tile3DOptions = options["3d-tiles"] || {};
  extractGLTFBufferOrURL(tile, gltfFormat, options);
  if (tile3DOptions.loadGLTF) {
    const {
      parse: parse4,
      fetch: fetch2
    } = context;
    if (tile.gltfUrl) {
      tile.gltfArrayBuffer = await fetch2(tile.gltfUrl, options);
      tile.gltfByteOffset = 0;
    }
    if (tile.gltfArrayBuffer) {
      tile.gltf = await parse4(tile.gltfArrayBuffer, GLTFLoader, options, context);
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
    }
  }
}
function extractGLTFBufferOrURL(tile, gltfFormat, options) {
  switch (gltfFormat) {
    case GLTF_FORMAT.URI:
      const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
      const textDecoder = new TextDecoder();
      const gltfUrl = textDecoder.decode(gltfUrlBytes);
      tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
      break;
    case GLTF_FORMAT.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
var GLTF_FORMAT;
var init_parse_3d_tile_gltf_view = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-gltf-view.js"() {
    init_esm23();
    init_esm3();
    GLTF_FORMAT = {
      URI: 0,
      EMBEDDED: 1
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-batched-model.js
async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  var _tile$gltf;
  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
  const extensions = tile === null || tile === void 0 ? void 0 : (_tile$gltf = tile.gltf) === null || _tile$gltf === void 0 ? void 0 : _tile$gltf.extensions;
  if (extensions && extensions.CESIUM_RTC) {
    tile.rtcCenter = extensions.CESIUM_RTC.center;
  }
  return byteOffset;
}
function parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  return byteOffset;
}
var init_parse_3d_tile_batched_model = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-batched-model.js"() {
    init_esm27();
    init_tile_3d_feature_table();
    init_parse_3d_tile_header();
    init_parse_3d_tile_tables();
    init_parse_3d_tile_gltf_view();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-instanced-model.js
async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, tile.gltfFormat, options, context);
  return byteOffset;
}
function parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  if (tile.version !== 1) {
    throw new Error("Instanced 3D Model version ".concat(tile.version, " is not supported"));
  }
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.gltfFormat = view.getUint32(byteOffset, true);
  byteOffset += 4;
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  if (tile.featureTableJsonByteLength === 0) {
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  }
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
  featureTable.featuresLength = instancesLength;
  if (!Number.isFinite(instancesLength)) {
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  }
  tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
  return byteOffset;
}
function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
  const collectionOptions = {
    instances: new Array(instancesLength),
    batchTable: tile._batchTable,
    cull: false,
    url: void 0,
    gltf: void 0,
    basePath: void 0,
    incrementallyLoadTextures: false,
    forwardAxis: [1, 0, 0]
  };
  const instances = collectionOptions.instances;
  const instancePosition = new Vector3();
  const instanceNormalRight = new Vector3();
  const instanceNormalUp = new Vector3();
  const instanceNormalForward = new Vector3();
  const instanceRotation = new Matrix3();
  const instanceQuaternion = new Quaternion();
  const instanceScale = new Vector3();
  const instanceTranslationRotationScale = {};
  const instanceTransform = new Matrix4();
  const scratch1 = [];
  const scratch2 = [];
  const scratchVector14 = new Vector3();
  const scratchVector26 = new Vector3();
  for (let i3 = 0; i3 < instancesLength; i3++) {
    let position;
    if (featureTable.hasProperty("POSITION")) {
      position = featureTable.getProperty("POSITION", GL2.FLOAT, 3, i3, instancePosition);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      position = featureTable.getProperty("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3, i3, instancePosition);
      const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3, scratchVector14);
      if (!quantizedVolumeOffset) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3, scratchVector26);
      if (!quantizedVolumeScale) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      const MAX_UNSIGNED_SHORT = 65535;
      for (let j = 0; j < 3; j++) {
        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
      }
    }
    if (!position) {
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    }
    instancePosition.copy(position);
    instanceTranslationRotationScale.translation = instancePosition;
    tile.normalUp = featureTable.getProperty("NORMAL_UP", GL2.FLOAT, 3, i3, scratch1);
    tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", GL2.FLOAT, 3, i3, scratch2);
    const hasCustomOrientation = false;
    if (tile.normalUp) {
      if (!tile.normalRight) {
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      }
      tile.hasCustomOrientation = true;
    } else {
      tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", GL2.UNSIGNED_SHORT, 2, scratch1);
      tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", GL2.UNSIGNED_SHORT, 2, scratch2);
      if (tile.octNormalUp) {
        if (!tile.octNormalRight) {
          throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
        }
        throw new Error("i3dm: oct-encoded orientation not implemented");
      } else if (tile.eastNorthUp) {
        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
        instanceTransform.getRotationMatrix3(instanceRotation);
      } else {
        instanceRotation.identity();
      }
    }
    if (hasCustomOrientation) {
      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
      instanceRotation.setColumn(0, instanceNormalRight);
      instanceRotation.setColumn(1, instanceNormalUp);
      instanceRotation.setColumn(2, instanceNormalForward);
    }
    instanceQuaternion.fromMatrix3(instanceRotation);
    instanceTranslationRotationScale.rotation = instanceQuaternion;
    instanceScale.set(1, 1, 1);
    const scale = featureTable.getProperty("SCALE", GL2.FLOAT, 1, i3);
    if (Number.isFinite(scale)) {
      instanceScale.multiplyByScalar(scale);
    }
    const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", GL2.FLOAT, 3, i3, scratch1);
    if (nonUniformScale) {
      instanceScale.scale(nonUniformScale);
    }
    instanceTranslationRotationScale.scale = instanceScale;
    let batchId = featureTable.getProperty("BATCH_ID", GL2.UNSIGNED_SHORT, 1, i3);
    if (batchId === void 0) {
      batchId = i3;
    }
    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);
    instanceTransform.identity();
    instanceTransform.translate(instanceTranslationRotationScale.translation);
    instanceTransform.multiplyRight(rotationMatrix);
    instanceTransform.scale(instanceTranslationRotationScale.scale);
    const modelMatrix2 = instanceTransform.clone();
    instances[i3] = {
      modelMatrix: modelMatrix2,
      batchId
    };
  }
  tile.instances = instances;
}
var init_parse_3d_tile_instanced_model = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-instanced-model.js"() {
    init_esm8();
    init_esm25();
    init_esm27();
    init_tile_3d_feature_table();
    init_tile_3d_batch_table();
    init_parse_3d_tile_header();
    init_parse_3d_tile_tables();
    init_parse_3d_tile_gltf_view();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-composite.js
async function parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile2) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.tilesLength = view.getUint32(byteOffset, true);
  byteOffset += 4;
  tile.tiles = [];
  while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {
    const subtile = {};
    tile.tiles.push(subtile);
    byteOffset = await parse3DTile2(arrayBuffer, byteOffset, options, context, subtile);
  }
  return byteOffset;
}
var init_parse_3d_tile_composite = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-composite.js"() {
    init_parse_3d_tile_header();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-gltf.js
async function parseGltf3DTile(tile, arrayBuffer, options, context) {
  tile.rotateYtoZ = true;
  tile.gltfUpAxis = options["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
  const {
    parse: parse4
  } = context;
  tile.gltf = await parse4(arrayBuffer, GLTFLoader, options, context);
}
var init_parse_3d_tile_gltf = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-gltf.js"() {
    init_esm23();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile.js
async function parse3DTile(arrayBuffer) {
  let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  let tile = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  tile.byteOffset = byteOffset;
  tile.type = getMagicString2(arrayBuffer, byteOffset);
  switch (tile.type) {
    case TILE3D_TYPE.COMPOSITE:
      return await parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile);
    case TILE3D_TYPE.BATCHED_3D_MODEL:
      return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.GLTF:
      return await parseGltf3DTile(tile, arrayBuffer, options, context);
    case TILE3D_TYPE.INSTANCED_3D_MODEL:
      return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.POINT_CLOUD:
      return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);
    default:
      throw new Error("3DTileLoader: unknown type ".concat(tile.type));
  }
}
var init_parse_3d_tile = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile.js"() {
    init_constants4();
    init_parse_utils();
    init_parse_3d_tile_point_cloud();
    init_parse_3d_tile_batched_model();
    init_parse_3d_tile_instanced_model();
    init_parse_3d_tile_composite();
    init_parse_3d_tile_gltf();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-subtree.js
async function parse3DTilesSubtree(data, options, context) {
  const magic = new Uint32Array(data.slice(0, 4));
  if (magic[0] !== SUBTREE_FILE_MAGIC) {
    throw new Error("Wrong subtree file magic number");
  }
  const version = new Uint32Array(data.slice(4, 8));
  if (version[0] !== SUBTREE_FILE_VERSION) {
    throw new Error("Wrong subtree file verson, must be 1");
  }
  const jsonByteLength = parseUint64Value(data.slice(8, 16));
  const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
  const textDecoder = new TextDecoder("utf8");
  const string = textDecoder.decode(stringAttribute);
  const subtree = JSON.parse(string);
  const binaryByteLength = parseUint64Value(data.slice(16, 24));
  let internalBinaryBuffer = new ArrayBuffer(0);
  if (binaryByteLength) {
    internalBinaryBuffer = data.slice(24 + jsonByteLength);
  }
  if ("bufferView" in subtree.tileAvailability) {
    subtree.tileAvailability.explicitBitstream = await getExplicitBitstream(subtree, "tileAvailability", internalBinaryBuffer, context);
  }
  if ("bufferView" in subtree.contentAvailability) {
    subtree.contentAvailability.explicitBitstream = await getExplicitBitstream(subtree, "contentAvailability", internalBinaryBuffer, context);
  }
  if ("bufferView" in subtree.childSubtreeAvailability) {
    subtree.childSubtreeAvailability.explicitBitstream = await getExplicitBitstream(subtree, "childSubtreeAvailability", internalBinaryBuffer, context);
  }
  return subtree;
}
function resolveBufferUri(bitstreamRelativeUri, basePath) {
  const hasProtocol = basePath.startsWith("http");
  if (hasProtocol) {
    const resolvedUri2 = new URL(bitstreamRelativeUri, basePath);
    return decodeURI(resolvedUri2.toString());
  }
  const basePathWithProtocol = "http://".concat(basePath);
  const resolvedUri = new URL(bitstreamRelativeUri, basePathWithProtocol);
  return "/".concat(resolvedUri.host).concat(resolvedUri.pathname);
}
async function getExplicitBitstream(subtree, name10, internalBinaryBuffer, context) {
  const bufferViewIndex = subtree[name10].bufferView;
  const bufferView = subtree.bufferViews[bufferViewIndex];
  const buffer = subtree.buffers[bufferView.buffer];
  if (!(context !== null && context !== void 0 && context.url) || !context.fetch) {
    throw new Error("Url is not provided");
  }
  if (!context.fetch) {
    throw new Error("fetch is not provided");
  }
  if (buffer.uri) {
    const bufferUri = resolveBufferUri(buffer.uri, context === null || context === void 0 ? void 0 : context.url);
    const response = await context.fetch(bufferUri);
    const data = await response.arrayBuffer();
    return new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
  }
  return new Uint8Array(internalBinaryBuffer, bufferView.byteOffset, bufferView.byteLength);
}
function parseUint64Value(buffer) {
  const dataView = new DataView(buffer);
  const left = dataView.getUint32(0, true);
  const right = dataView.getUint32(4, true);
  return left + 2 ** 32 * right;
}
var SUBTREE_FILE_MAGIC, SUBTREE_FILE_VERSION;
var init_parse_3d_tile_subtree = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-subtree.js"() {
    SUBTREE_FILE_MAGIC = 1952609651;
    SUBTREE_FILE_VERSION = 1;
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/tile-3d-subtree-loader.js
var Tile3DSubtreeLoader;
var init_tile_3d_subtree_loader = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/tile-3d-subtree-loader.js"() {
    init_parse_3d_tile_subtree();
    init_version4();
    Tile3DSubtreeLoader = {
      id: "3d-tiles-subtree",
      name: "3D Tiles Subtree",
      module: "3d-tiles",
      version: VERSION8,
      extensions: ["subtree"],
      mimeTypes: ["application/octet-stream"],
      tests: ["subtree"],
      parse: parse3DTilesSubtree,
      options: {}
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-implicit-tiles.js
async function parseImplicitTiles(params) {
  const {
    options,
    parentData = {
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    },
    childIndex = 0,
    globalData = {
      level: 0,
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    }
  } = params;
  let {
    subtree,
    level = 0
  } = params;
  const {
    subdivisionScheme,
    subtreeLevels,
    maximumLevel,
    contentUrlTemplate,
    subtreesUriTemplate,
    basePath
  } = options;
  const tile = {
    children: [],
    lodMetricValue: 0,
    contentUrl: ""
  };
  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
  const childX = childIndex & 1;
  const childY = childIndex >> 1 & 1;
  const childZ = childIndex >> 2 & 1;
  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);
  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);
  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;
  let childTileX = concatBits(parentData.x, childX);
  let childTileY = concatBits(parentData.y, childY);
  let childTileZ = concatBits(parentData.z, childZ);
  let isChildSubtreeAvailable = false;
  if (level + 1 > subtreeLevels) {
    isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
  }
  const x2 = concatBits(globalData.x, childTileX);
  const y2 = concatBits(globalData.y, childTileY);
  const z = concatBits(globalData.z, childTileZ);
  const lev = level + globalData.level;
  if (isChildSubtreeAvailable) {
    const subtreePath = "".concat(basePath, "/").concat(subtreesUriTemplate);
    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x2, y2, z);
    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);
    subtree = childSubtree;
    globalData.mortonIndex = childTileMortonIndex;
    globalData.x = childTileX;
    globalData.y = childTileY;
    globalData.z = childTileZ;
    globalData.level = level;
    childTileMortonIndex = 0;
    tileAvailabilityIndex = 0;
    childTileX = 0;
    childTileY = 0;
    childTileZ = 0;
    level = 0;
  }
  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);
  if (!isTileAvailable || level > maximumLevel) {
    return tile;
  }
  const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);
  if (isContentAvailable) {
    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x2, y2, z);
  }
  const childTileLevel = level + 1;
  const pData = {
    mortonIndex: childTileMortonIndex,
    x: childTileX,
    y: childTileY,
    z: childTileZ
  };
  for (let index = 0; index < childrenPerTile; index++) {
    const currentTile = await parseImplicitTiles({
      subtree,
      options,
      parentData: pData,
      childIndex: index,
      level: childTileLevel,
      globalData
    });
    if (currentTile.contentUrl || currentTile.children.length) {
      const globalLevel = lev + 1;
      const childCoordinates = {
        childTileX,
        childTileY,
        childTileZ
      };
      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);
      tile.children.push(formattedTile);
    }
  }
  return tile;
}
function getAvailabilityResult(availabilityData, index) {
  if ("constant" in availabilityData) {
    return Boolean(availabilityData.constant);
  }
  if (availabilityData.explicitBitstream) {
    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);
  }
  return false;
}
function formatTileData(tile, level, childCoordinates, options) {
  const {
    basePath,
    refine,
    getRefine: getRefine2,
    lodMetricType,
    getTileType: getTileType2,
    rootLodMetricValue,
    rootBoundingVolume
  } = options;
  const uri = tile.contentUrl && tile.contentUrl.replace("".concat(basePath, "/"), "");
  const lodMetricValue = rootLodMetricValue / 2 ** level;
  const boundingVolume = calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates);
  return {
    children: tile.children,
    contentUrl: tile.contentUrl,
    content: {
      uri
    },
    id: tile.contentUrl,
    refine: getRefine2(refine),
    type: getTileType2(tile),
    lodMetricType,
    lodMetricValue,
    geometricError: lodMetricValue,
    transform: tile.transform,
    boundingVolume
  };
}
function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
  if (rootBoundingVolume.region) {
    const {
      childTileX,
      childTileY,
      childTileZ
    } = childCoordinates;
    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
    const boundingVolumesCount = 2 ** level;
    const sizeX = (east - west) / boundingVolumesCount;
    const sizeY = (north - south) / boundingVolumesCount;
    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];
    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];
    const [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * childTileZ, minimumHeight + sizeZ * (childTileZ + 1)];
    return {
      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
    };
  }
  console.warn("Unsupported bounding volume type: ", rootBoundingVolume);
  return null;
}
function concatBits(first, second) {
  return parseInt(first.toString(2) + second.toString(2), 2);
}
function replaceContentUrlTemplate(templateUrl, level, x2, y2, z) {
  const mapUrl = generateMapUrl({
    level,
    x: x2,
    y: y2,
    z
  });
  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
}
function generateMapUrl(items) {
  const mapUrl = {};
  for (const key in items) {
    mapUrl["{".concat(key, "}")] = items[key];
  }
  return mapUrl;
}
function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
  const byteIndex = Math.floor(availabilityIndex / 8);
  const bitIndex = availabilityIndex % 8;
  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
  return bitValue === 1;
}
var QUADTREE_DEVISION_COUNT, OCTREE_DEVISION_COUNT, SUBDIVISION_COUNT_MAP;
var init_parse_3d_implicit_tiles = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-implicit-tiles.js"() {
    init_tile_3d_subtree_loader();
    init_esm4();
    QUADTREE_DEVISION_COUNT = 4;
    OCTREE_DEVISION_COUNT = 8;
    SUBDIVISION_COUNT_MAP = {
      QUADTREE: QUADTREE_DEVISION_COUNT,
      OCTREE: OCTREE_DEVISION_COUNT
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-header.js
function getTileType(tile) {
  if (!tile.contentUrl) {
    return TILE_TYPE.EMPTY;
  }
  const contentUrl = tile.contentUrl;
  const fileExtension = contentUrl.split(".").pop();
  switch (fileExtension) {
    case "pnts":
      return TILE_TYPE.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return TILE_TYPE.SCENEGRAPH;
    default:
      return fileExtension;
  }
}
function getRefine(refine) {
  switch (refine) {
    case "REPLACE":
    case "replace":
      return TILE_REFINEMENT.REPLACE;
    case "ADD":
    case "add":
      return TILE_REFINEMENT.ADD;
    default:
      return refine;
  }
}
function resolveUri(uri, basePath) {
  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
  if (urlSchemeRegex.test(basePath)) {
    const url = new URL(uri, "".concat(basePath, "/"));
    return decodeURI(url.toString());
  } else if (uri.startsWith("/")) {
    return uri;
  }
  return "".concat(basePath, "/").concat(uri);
}
function normalizeTileData(tile, options) {
  if (!tile) {
    return null;
  }
  if (tile.content) {
    const contentUri = tile.content.uri || tile.content.url;
    tile.contentUrl = resolveUri(contentUri, options.basePath);
  }
  tile.id = tile.contentUrl;
  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
  tile.lodMetricValue = tile.geometricError;
  tile.transformMatrix = tile.transform;
  tile.type = getTileType(tile);
  tile.refine = getRefine(tile.refine);
  return tile;
}
async function normalizeTileHeaders(tileset, options) {
  const basePath = tileset.basePath;
  let root;
  const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset === null || tileset === void 0 ? void 0 : tileset.root);
  if (rootImplicitTilingExtension && tileset.root) {
    root = await normalizeImplicitTileHeaders(tileset.root, tileset, rootImplicitTilingExtension, options);
  } else {
    root = normalizeTileData(tileset.root, tileset);
  }
  const stack2 = [];
  stack2.push(root);
  while (stack2.length > 0) {
    const tile = stack2.pop() || {};
    const children = tile.children || [];
    for (let childHeader of children) {
      const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
      if (childImplicitTilingExtension) {
        childHeader = await normalizeImplicitTileHeaders(childHeader, tileset, childImplicitTilingExtension, options);
      } else {
        normalizeTileData(childHeader, {
          basePath
        });
      }
      stack2.push(childHeader);
    }
  }
  return root;
}
async function normalizeImplicitTileHeaders(tile, tileset, implicitTilingExtension, options) {
  var _tileset$root;
  const basePath = tileset.basePath;
  const {
    subdivisionScheme,
    maximumLevel,
    subtreeLevels,
    subtrees: {
      uri: subtreesUriTemplate
    }
  } = implicitTilingExtension;
  const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
  const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
  const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);
  const contentUrlTemplate = resolveUri(tile.content.uri, basePath);
  const refine = tileset === null || tileset === void 0 ? void 0 : (_tileset$root = tileset.root) === null || _tileset$root === void 0 ? void 0 : _tileset$root.refine;
  const rootLodMetricValue = tile.geometricError;
  const rootBoundingVolume = tile.boundingVolume;
  const implicitOptions = {
    contentUrlTemplate,
    subtreesUriTemplate,
    subdivisionScheme,
    subtreeLevels,
    maximumLevel,
    refine,
    basePath,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    rootLodMetricValue,
    rootBoundingVolume,
    getTileType,
    getRefine
  };
  return await normalizeImplicitTileData(tile, subtree, implicitOptions);
}
async function normalizeImplicitTileData(tile, rootSubtree, options) {
  if (!tile) {
    return null;
  }
  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
  tile.lodMetricValue = tile.geometricError;
  tile.transformMatrix = tile.transform;
  const {
    children,
    contentUrl
  } = await parseImplicitTiles({
    subtree: rootSubtree,
    options
  });
  if (contentUrl) {
    tile.contentUrl = contentUrl;
    tile.content = {
      uri: contentUrl.replace("".concat(options.basePath, "/"), "")
    };
  }
  tile.refine = getRefine(tile.refine);
  tile.type = getTileType(tile);
  tile.children = children;
  tile.id = tile.contentUrl;
  return tile;
}
function getImplicitTilingExtensionData(tile) {
  var _tile$extensions;
  return (tile === null || tile === void 0 ? void 0 : (_tile$extensions = tile.extensions) === null || _tile$extensions === void 0 ? void 0 : _tile$extensions["3DTILES_implicit_tiling"]) || (tile === null || tile === void 0 ? void 0 : tile.implicitTiling);
}
var init_parse_3d_tile_header2 = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-header.js"() {
    init_tile_3d_subtree_loader();
    init_esm4();
    init_esm26();
    init_parse_3d_implicit_tiles();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/tiles-3d-loader.js
function getBaseUri(tileset) {
  return path_exports.dirname(tileset.url);
}
async function parseTile(arrayBuffer, options, context) {
  const tile = {
    content: {
      featureIds: null
    }
  };
  const byteOffset = 0;
  await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);
  return tile.content;
}
async function parseTileset(data, options, context) {
  var _tilesetJson$root;
  const tilesetJson = JSON.parse(new TextDecoder().decode(data));
  tilesetJson.loader = options.loader || Tiles3DLoader;
  tilesetJson.url = context.url;
  tilesetJson.basePath = getBaseUri(tilesetJson);
  tilesetJson.root = await normalizeTileHeaders(tilesetJson, options);
  tilesetJson.type = TILESET_TYPE.TILES3D;
  tilesetJson.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
  tilesetJson.lodMetricValue = ((_tilesetJson$root = tilesetJson.root) === null || _tilesetJson$root === void 0 ? void 0 : _tilesetJson$root.lodMetricValue) || 0;
  return tilesetJson;
}
async function parse3(data, options, context) {
  const loaderOptions = options["3d-tiles"] || {};
  let isTileset;
  if (loaderOptions.isTileset === "auto") {
    isTileset = context.url && context.url.indexOf(".json") !== -1;
  } else {
    isTileset = loaderOptions.isTileset;
  }
  if (isTileset) {
    data = await parseTileset(data, options, context);
  } else {
    data = await parseTile(data, options, context);
  }
  return data;
}
var Tiles3DLoader;
var init_tiles_3d_loader = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/tiles-3d-loader.js"() {
    init_esm3();
    init_esm26();
    init_version4();
    init_parse_3d_tile();
    init_parse_3d_tile_header2();
    Tiles3DLoader = {
      id: "3d-tiles",
      name: "3D Tiles",
      module: "3d-tiles",
      version: VERSION8,
      extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
      mimeTypes: ["application/octet-stream"],
      tests: ["cmpt", "pnts", "b3dm", "i3dm"],
      parse: parse3,
      options: {
        "3d-tiles": {
          loadGLTF: true,
          decodeQuantizedPositions: false,
          isTileset: "auto",
          assetGltfUpAxis: null
        }
      }
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/ion/ion.js
async function getIonTilesetMetadata(accessToken, assetId) {
  if (!assetId) {
    const assets = await getIonAssets(accessToken);
    for (const item of assets.items) {
      if (item.type === "3DTILES") {
        assetId = item.id;
      }
    }
  }
  const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);
  const {
    type,
    url
  } = ionAssetMetadata;
  assert2(type === "3DTILES" && url);
  ionAssetMetadata.headers = {
    Authorization: "Bearer ".concat(ionAssetMetadata.accessToken)
  };
  return ionAssetMetadata;
}
async function getIonAssets(accessToken) {
  assert2(accessToken);
  const url = CESIUM_ION_URL;
  const headers = {
    Authorization: "Bearer ".concat(accessToken)
  };
  const response = await fetchFile(url, {
    fetch: {
      headers
    }
  });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  return await response.json();
}
async function getIonAssetMetadata(accessToken, assetId) {
  assert2(accessToken, assetId);
  const headers = {
    Authorization: "Bearer ".concat(accessToken)
  };
  const url = "".concat(CESIUM_ION_URL, "/").concat(assetId);
  let response = await fetchFile("".concat(url), {
    fetch: {
      headers
    }
  });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  let metadata = await response.json();
  response = await fetchFile("".concat(url, "/endpoint"), {
    fetch: {
      headers
    }
  });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  const tilesetInfo = await response.json();
  metadata = {
    ...metadata,
    ...tilesetInfo
  };
  return metadata;
}
var CESIUM_ION_URL;
var init_ion = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/ion/ion.js"() {
    init_esm4();
    init_esm3();
    CESIUM_ION_URL = "https://api.cesium.com/v1/assets";
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/cesium-ion-loader.js
async function preload(url) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  options = options["cesium-ion"] || {};
  const {
    accessToken
  } = options;
  let assetId = options.assetId;
  if (!Number.isFinite(assetId)) {
    const matched = url.match(/\/([0-9]+)\/tileset.json/);
    assetId = matched && matched[1];
  }
  return getIonTilesetMetadata(accessToken, assetId);
}
var CesiumIonLoader;
var init_cesium_ion_loader = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/cesium-ion-loader.js"() {
    init_tiles_3d_loader();
    init_ion();
    CesiumIonLoader = {
      ...Tiles3DLoader,
      id: "cesium-ion",
      name: "Cesium Ion",
      preload,
      parse: async (data, options, context) => {
        options = {
          ...options
        };
        options["3d-tiles"] = options["cesium-ion"];
        options.loader = CesiumIonLoader;
        return Tiles3DLoader.parse(data, options, context);
      },
      options: {
        "cesium-ion": {
          ...Tiles3DLoader.options["3d-tiles"],
          accessToken: null
        }
      }
    };
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/helpers/encode-3d-tile-header.js
var init_encode_3d_tile_header = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/helpers/encode-3d-tile-header.js"() {
    init_esm3();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-composite.js
var init_encode_3d_tile_composite = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-composite.js"() {
    init_constants4();
    init_encode_3d_tile_header();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-batched-model.js
var init_encode_3d_tile_batched_model = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-batched-model.js"() {
    init_esm3();
    init_constants4();
    init_encode_3d_tile_header();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-instanced-model.js
var init_encode_3d_tile_instanced_model = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-instanced-model.js"() {
    init_esm3();
    init_constants4();
    init_encode_3d_tile_header();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-point-cloud.js
var init_encode_3d_tile_point_cloud = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile-point-cloud.js"() {
    init_constants4();
    init_encode_3d_tile_header();
    init_esm3();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile.js
var init_encode_3d_tile = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/lib/encoders/encode-3d-tile.js"() {
    init_constants4();
    init_esm3();
    init_encode_3d_tile_composite();
    init_encode_3d_tile_batched_model();
    init_encode_3d_tile_instanced_model();
    init_encode_3d_tile_point_cloud();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/tile-3d-writer.js
var init_tile_3d_writer = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/tile-3d-writer.js"() {
    init_version4();
    init_encode_3d_tile();
  }
});

// node_modules/@loaders.gl/3d-tiles/dist/esm/index.js
var init_esm28 = __esm({
  "node_modules/@loaders.gl/3d-tiles/dist/esm/index.js"() {
    init_tiles_3d_loader();
    init_cesium_ion_loader();
    init_tile_3d_subtree_loader();
    init_tile_3d_writer();
    init_tile_3d_feature_table();
    init_tile_3d_batch_table();
    init_constants4();
    init_ion();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js
function getMeshGeometry(contentAttributes) {
  const attributes = {};
  attributes.positions = {
    ...contentAttributes.positions,
    value: new Float32Array(contentAttributes.positions.value)
  };
  if (contentAttributes.normals) {
    attributes.normals = contentAttributes.normals;
  }
  if (contentAttributes.texCoords) {
    attributes.texCoords = contentAttributes.texCoords;
  }
  if (contentAttributes.colors) {
    attributes.colors = contentAttributes.colors;
  }
  if (contentAttributes.uvRegions) {
    attributes.uvRegions = contentAttributes.uvRegions;
  }
  return attributes;
}
var SINGLE_DATA, defaultProps28, Tile3DLayer;
var init_tile_3d_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js"() {
    init_defineProperty();
    init_esm11();
    init_esm13();
    init_esm15();
    init_esm24();
    init_mesh_layer();
    init_esm4();
    init_esm26();
    init_esm28();
    SINGLE_DATA = [0];
    defaultProps28 = {
      getPointColor: {
        type: "accessor",
        value: [0, 0, 0, 255]
      },
      pointSize: 1,
      data: "",
      loader: Tiles3DLoader,
      onTilesetLoad: {
        type: "function",
        value: (tileset3d) => {
        }
      },
      onTileLoad: {
        type: "function",
        value: (tileHeader) => {
        }
      },
      onTileUnload: {
        type: "function",
        value: (tileHeader) => {
        }
      },
      onTileError: {
        type: "function",
        value: (tile, message, url) => {
        }
      },
      _getMeshColor: {
        type: "function",
        value: (tileHeader) => [255, 255, 255]
      }
    };
    Tile3DLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      initializeState() {
        if ("onTileLoadFail" in this.props) {
          log_default.removed("onTileLoadFail", "onTileError")();
        }
        this.state = {
          layerMap: {},
          tileset3d: null,
          activeViewports: {},
          lastUpdatedViewports: null
        };
      }
      get isLoaded() {
        const {
          tileset3d
        } = this.state;
        return tileset3d !== null && tileset3d.isLoaded();
      }
      shouldUpdateState({
        changeFlags
      }) {
        return changeFlags.somethingChanged;
      }
      updateState({
        props,
        oldProps,
        changeFlags
      }) {
        if (props.data && props.data !== oldProps.data) {
          this._loadTileset(props.data);
        }
        if (changeFlags.viewportChanged) {
          const {
            activeViewports
          } = this.state;
          const viewportsNumber = Object.keys(activeViewports).length;
          if (viewportsNumber) {
            this._updateTileset(activeViewports);
            this.state.lastUpdatedViewports = activeViewports;
            this.state.activeViewports = {};
          }
        }
        if (changeFlags.propsChanged) {
          const {
            layerMap
          } = this.state;
          for (const key in layerMap) {
            layerMap[key].needsUpdate = true;
          }
        }
      }
      activateViewport(viewport) {
        const {
          activeViewports,
          lastUpdatedViewports
        } = this.state;
        this.internalState.viewport = viewport;
        activeViewports[viewport.id] = viewport;
        const lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];
        if (!lastViewport || !viewport.equals(lastViewport)) {
          this.setChangeFlags({
            viewportChanged: true
          });
          this.setNeedsUpdate();
        }
      }
      getPickingInfo({
        info,
        sourceLayer
      }) {
        const sourceTile = sourceLayer && sourceLayer.props.tile;
        if (info.picked) {
          info.object = sourceTile;
        }
        info.sourceTile = sourceTile;
        return info;
      }
      filterSubLayer({
        layer,
        viewport
      }) {
        const {
          tile
        } = layer.props;
        const {
          id: viewportId
        } = viewport;
        return tile.selected && tile.viewportIds.includes(viewportId);
      }
      _updateAutoHighlight(info) {
        const sourceTile = info.sourceTile;
        const layerCache = this.state.layerMap[sourceTile === null || sourceTile === void 0 ? void 0 : sourceTile.id];
        if (layerCache && layerCache.layer) {
          layerCache.layer.updateAutoHighlight(info);
        }
      }
      async _loadTileset(tilesetUrl) {
        const {
          loadOptions = {}
        } = this.props;
        let loader = this.props.loader || this.props.loaders;
        if (Array.isArray(loader)) {
          loader = loader[0];
        }
        const options = {
          loadOptions: {
            ...loadOptions
          }
        };
        if (loader.preload) {
          const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
          if (preloadOptions.headers) {
            options.loadOptions.fetch = {
              ...options.loadOptions.fetch,
              headers: preloadOptions.headers
            };
          }
          Object.assign(options, preloadOptions);
        }
        const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);
        const tileset3d = new Tileset3D(tilesetJson, {
          onTileLoad: this._onTileLoad.bind(this),
          onTileUnload: this._onTileUnload.bind(this),
          onTileError: this.props.onTileError,
          ...options
        });
        this.setState({
          tileset3d,
          layerMap: {}
        });
        this._updateTileset(this.state.activeViewports);
        this.props.onTilesetLoad(tileset3d);
      }
      _onTileLoad(tileHeader) {
        const {
          lastUpdatedViewports
        } = this.state;
        this.props.onTileLoad(tileHeader);
        this._updateTileset(lastUpdatedViewports);
        this.setNeedsUpdate();
      }
      _onTileUnload(tileHeader) {
        delete this.state.layerMap[tileHeader.id];
        this.props.onTileUnload(tileHeader);
      }
      _updateTileset(viewports) {
        if (!viewports) {
          return;
        }
        const {
          tileset3d
        } = this.state;
        const {
          timeline
        } = this.context;
        const viewportsNumber = Object.keys(viewports).length;
        if (!timeline || !viewportsNumber || !tileset3d) {
          return;
        }
        tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
          const tilesetChanged = this.state.frameNumber !== frameNumber;
          if (tilesetChanged) {
            this.setState({
              frameNumber
            });
          }
        });
      }
      _getSubLayer(tileHeader, oldLayer) {
        if (!tileHeader.content) {
          return null;
        }
        switch (tileHeader.type) {
          case TILE_TYPE.POINTCLOUD:
            return this._makePointCloudLayer(tileHeader, oldLayer);
          case TILE_TYPE.SCENEGRAPH:
            return this._make3DModelLayer(tileHeader);
          case TILE_TYPE.MESH:
            return this._makeSimpleMeshLayer(tileHeader, oldLayer);
          default:
            throw new Error("Tile3DLayer: Failed to render layer of type ".concat(tileHeader.content.type));
        }
      }
      _makePointCloudLayer(tileHeader, oldLayer) {
        const {
          attributes,
          pointCount,
          constantRGBA,
          cartographicOrigin,
          modelMatrix: modelMatrix2
        } = tileHeader.content;
        const {
          positions,
          normals,
          colors
        } = attributes;
        if (!positions) {
          return null;
        }
        const data = oldLayer && oldLayer.props.data || {
          header: {
            vertexCount: pointCount
          },
          attributes: {
            POSITION: positions,
            NORMAL: normals,
            COLOR_0: colors
          }
        };
        const {
          pointSize,
          getPointColor
        } = this.props;
        const SubLayerClass = this.getSubLayerClass("pointcloud", PointCloudLayer);
        return new SubLayerClass({
          pointSize
        }, this.getSubLayerProps({
          id: "pointcloud"
        }), {
          id: "".concat(this.id, "-pointcloud-").concat(tileHeader.id),
          tile: tileHeader,
          data,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getColor: constantRGBA || getPointColor,
          _offset: 0
        });
      }
      _make3DModelLayer(tileHeader) {
        const {
          gltf,
          instances,
          cartographicOrigin,
          modelMatrix: modelMatrix2
        } = tileHeader.content;
        const SubLayerClass = this.getSubLayerClass("scenegraph", ScenegraphLayer);
        return new SubLayerClass({
          _lighting: "pbr"
        }, this.getSubLayerProps({
          id: "scenegraph"
        }), {
          id: "".concat(this.id, "-scenegraph-").concat(tileHeader.id),
          tile: tileHeader,
          data: instances || SINGLE_DATA,
          scenegraph: gltf,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getTransformMatrix: (instance) => instance.modelMatrix,
          getPosition: [0, 0, 0],
          _offset: 0
        });
      }
      _makeSimpleMeshLayer(tileHeader, oldLayer) {
        const content = tileHeader.content;
        const {
          attributes,
          indices,
          modelMatrix: modelMatrix2,
          cartographicOrigin,
          coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,
          material,
          featureIds
        } = content;
        const {
          _getMeshColor
        } = this.props;
        const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
          drawMode: 4,
          attributes: getMeshGeometry(attributes),
          indices
        });
        const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
        return new SubLayerClass(this.getSubLayerProps({
          id: "mesh"
        }), {
          id: "".concat(this.id, "-mesh-").concat(tileHeader.id),
          tile: tileHeader,
          mesh: geometry,
          data: SINGLE_DATA,
          getColor: _getMeshColor(tileHeader),
          pbrMaterial: material,
          modelMatrix: modelMatrix2,
          coordinateOrigin: cartographicOrigin,
          coordinateSystem,
          featureIds,
          _offset: 0
        });
      }
      renderLayers() {
        const {
          tileset3d,
          layerMap
        } = this.state;
        if (!tileset3d) {
          return null;
        }
        return tileset3d.tiles.map((tile) => {
          const layerCache = layerMap[tile.id] = layerMap[tile.id] || {
            tile
          };
          let {
            layer
          } = layerCache;
          if (tile.selected) {
            if (!layer) {
              layer = this._getSubLayer(tile);
            } else if (layerCache.needsUpdate) {
              layer = this._getSubLayer(tile, layer);
              layerCache.needsUpdate = false;
            }
          }
          layerCache.layer = layer;
          return layer;
        }).filter(Boolean);
      }
    };
    _defineProperty(Tile3DLayer, "defaultProps", defaultProps28);
    _defineProperty(Tile3DLayer, "layerName", "Tile3DLayer");
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/lib/decode-quantized-mesh.js
function decodeZigZag(value) {
  return value >> 1 ^ -(value & 1);
}
function decodeHeader(dataView) {
  let position = 0;
  const header = {};
  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
    header[key] = getter.call(dataView, position, true);
    position += bytesCount;
  }
  return {
    header,
    headerEndPosition: position
  };
}
function decodeVertexData(dataView, headerEndPosition) {
  let position = headerEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = dataView.getUint32(position, true);
  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
  const elementArrayLength = vertexCount * bytesPerArrayElement;
  const uArrayStartPosition = position;
  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
  let u = 0;
  let v = 0;
  let height = 0;
  for (let i3 = 0; i3 < vertexCount; i3++) {
    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i3, true));
    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i3, true));
    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i3, true));
    vertexData[i3] = u;
    vertexData[i3 + vertexCount] = v;
    vertexData[i3 + vertexCount * 2] = height;
  }
  position += elementArrayLength * 3;
  return {
    vertexData,
    vertexDataEndPosition: position
  };
}
function decodeIndex(buffer, position, indicesCount, bytesPerIndex) {
  let encoded = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let indices;
  if (bytesPerIndex === 2) {
    indices = new Uint16Array(buffer, position, indicesCount);
  } else {
    indices = new Uint32Array(buffer, position, indicesCount);
  }
  if (!encoded) {
    return indices;
  }
  let highest = 0;
  for (let i3 = 0; i3 < indices.length; ++i3) {
    const code = indices[i3];
    indices[i3] = highest - code;
    if (code === 0) {
      ++highest;
    }
  }
  return indices;
}
function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
  let position = vertexDataEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  if (position % bytesPerIndex !== 0) {
    position += bytesPerIndex - position % bytesPerIndex;
  }
  const triangleCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const triangleIndicesCount = triangleCount * 3;
  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
  position += triangleIndicesCount * bytesPerIndex;
  return {
    triangleIndicesEndPosition: position,
    triangleIndices
  };
}
function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
  let position = triangleIndicesEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  const westVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
  position += westVertexCount * bytesPerIndex;
  const southVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
  position += southVertexCount * bytesPerIndex;
  const eastVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
  position += eastVertexCount * bytesPerIndex;
  const northVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
  position += northVertexCount * bytesPerIndex;
  return {
    edgeIndicesEndPosition: position,
    westIndices,
    southIndices,
    eastIndices,
    northIndices
  };
}
function decodeVertexNormalsExtension(extensionDataView) {
  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
}
function decodeWaterMaskExtension(extensionDataView) {
  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
}
function decodeExtensions2(dataView, indicesEndPosition) {
  const extensions = {};
  if (dataView.byteLength <= indicesEndPosition) {
    return {
      extensions,
      extensionsEndPosition: indicesEndPosition
    };
  }
  let position = indicesEndPosition;
  while (position < dataView.byteLength) {
    const extensionId = dataView.getUint8(position, true);
    position += Uint8Array.BYTES_PER_ELEMENT;
    const extensionLength = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const extensionView = new DataView(dataView.buffer, position, extensionLength);
    switch (extensionId) {
      case 1: {
        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
        break;
      }
      case 2: {
        extensions.waterMask = decodeWaterMaskExtension(extensionView);
        break;
      }
      default: {
      }
    }
    position += extensionLength;
  }
  return {
    extensions,
    extensionsEndPosition: position
  };
}
function decode9(data, userOptions) {
  const options = Object.assign({}, DEFAULT_OPTIONS3, userOptions);
  const view = new DataView(data);
  const {
    header,
    headerEndPosition
  } = decodeHeader(view);
  if (options.maxDecodingStep < DECODING_STEPS.vertices) {
    return {
      header
    };
  }
  const {
    vertexData,
    vertexDataEndPosition
  } = decodeVertexData(view, headerEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
    return {
      header,
      vertexData
    };
  }
  const {
    triangleIndices,
    triangleIndicesEndPosition
  } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
    return {
      header,
      vertexData,
      triangleIndices
    };
  }
  const {
    westIndices,
    southIndices,
    eastIndices,
    northIndices,
    edgeIndicesEndPosition
  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.extensions) {
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    };
  }
  const {
    extensions
  } = decodeExtensions2(view, edgeIndicesEndPosition);
  return {
    header,
    vertexData,
    triangleIndices,
    westIndices,
    northIndices,
    eastIndices,
    southIndices,
    extensions
  };
}
var QUANTIZED_MESH_HEADER, DECODING_STEPS, DEFAULT_OPTIONS3;
var init_decode_quantized_mesh = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/lib/decode-quantized-mesh.js"() {
    QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([["centerX", Float64Array.BYTES_PER_ELEMENT], ["centerY", Float64Array.BYTES_PER_ELEMENT], ["centerZ", Float64Array.BYTES_PER_ELEMENT], ["minHeight", Float32Array.BYTES_PER_ELEMENT], ["maxHeight", Float32Array.BYTES_PER_ELEMENT], ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]]);
    DECODING_STEPS = {
      header: 0,
      vertices: 1,
      triangleIndices: 2,
      edgeIndices: 3,
      extensions: 4
    };
    DEFAULT_OPTIONS3 = {
      maxDecodingStep: DECODING_STEPS.extensions
    };
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/lib/helpers/skirt.js
function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
  const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
  const newTriangles = new triangles.constructor(outsideEdges.length * 6);
  for (let i3 = 0; i3 < outsideEdges.length; i3++) {
    const edge = outsideEdges[i3];
    updateAttributesForNewEdge({
      edge,
      edgeIndex: i3,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    });
  }
  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
  const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
  return {
    attributes,
    triangles: resultTriangles
  };
}
function getOutsideEdgesFromTriangles(triangles) {
  const edges = [];
  for (let i3 = 0; i3 < triangles.length; i3 += 3) {
    edges.push([triangles[i3], triangles[i3 + 1]]);
    edges.push([triangles[i3 + 1], triangles[i3 + 2]]);
    edges.push([triangles[i3 + 2], triangles[i3]]);
  }
  edges.sort((a2, b) => Math.min(...a2) - Math.min(...b) || Math.max(...a2) - Math.max(...b));
  const outsideEdges = [];
  let index = 0;
  while (index < edges.length) {
    var _edges, _edges2;
    if (edges[index][0] === ((_edges = edges[index + 1]) === null || _edges === void 0 ? void 0 : _edges[1]) && edges[index][1] === ((_edges2 = edges[index + 1]) === null || _edges2 === void 0 ? void 0 : _edges2[0])) {
      index += 2;
    } else {
      outsideEdges.push(edges[index]);
      index++;
    }
  }
  return outsideEdges;
}
function getOutsideEdgesFromIndices(indices, position) {
  indices.westIndices.sort((a2, b) => position[3 * a2 + 1] - position[3 * b + 1]);
  indices.eastIndices.sort((a2, b) => position[3 * b + 1] - position[3 * a2 + 1]);
  indices.southIndices.sort((a2, b) => position[3 * b] - position[3 * a2]);
  indices.northIndices.sort((a2, b) => position[3 * a2] - position[3 * b]);
  const edges = [];
  for (const index in indices) {
    const indexGroup = indices[index];
    for (let i3 = 0; i3 < indexGroup.length - 1; i3++) {
      edges.push([indexGroup[i3], indexGroup[i3 + 1]]);
    }
  }
  return edges;
}
function updateAttributesForNewEdge(_ref) {
  let {
    edge,
    edgeIndex,
    attributes,
    skirtHeight,
    newPosition,
    newTexcoord0,
    newTriangles
  } = _ref;
  const positionsLength = attributes.POSITION.value.length;
  const vertex1Offset = edgeIndex * 2;
  const vertex2Offset = edgeIndex * 2 + 1;
  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
  const triangle1Offset = edgeIndex * 2 * 3;
  newTriangles[triangle1Offset] = edge[0];
  newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 2] = edge[1];
  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 4] = edge[0];
  newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
}
var init_skirt = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/lib/helpers/skirt.js"() {
    init_esm3();
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/lib/parse-quantized-mesh.js
function getMeshAttributes(vertexData, header, bounds) {
  const {
    minHeight,
    maxHeight
  } = header;
  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
  const xScale = maxX - minX;
  const yScale = maxY - minY;
  const zScale = maxHeight - minHeight;
  const nCoords = vertexData.length / 3;
  const positions = new Float32Array(nCoords * 3);
  const texCoords = new Float32Array(nCoords * 2);
  for (let i3 = 0; i3 < nCoords; i3++) {
    const x2 = vertexData[i3] / 32767;
    const y2 = vertexData[i3 + nCoords] / 32767;
    const z = vertexData[i3 + nCoords * 2] / 32767;
    positions[3 * i3 + 0] = x2 * xScale + minX;
    positions[3 * i3 + 1] = y2 * yScale + minY;
    positions[3 * i3 + 2] = z * zScale + minHeight;
    texCoords[2 * i3 + 0] = x2;
    texCoords[2 * i3 + 1] = y2;
  }
  return {
    POSITION: {
      value: positions,
      size: 3
    },
    TEXCOORD_0: {
      value: texCoords,
      size: 2
    }
  };
}
function getTileMesh(arrayBuffer, options) {
  if (!arrayBuffer) {
    return null;
  }
  const {
    bounds
  } = options;
  const {
    header,
    vertexData,
    triangleIndices: originalTriangleIndices,
    westIndices,
    northIndices,
    eastIndices,
    southIndices
  } = decode9(arrayBuffer, DECODING_STEPS.triangleIndices);
  let triangleIndices = originalTriangleIndices;
  let attributes = getMeshAttributes(vertexData, header, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (options.skirtHeight) {
    const {
      attributes: newAttributes,
      triangles: newTriangles
    } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    });
    attributes = newAttributes;
    triangleIndices = newTriangles;
  }
  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangleIndices.length,
      boundingBox
    },
    mode: 4,
    indices: {
      value: triangleIndices,
      size: 1
    },
    attributes
  };
}
function loadQuantizedMesh(arrayBuffer, options) {
  return getTileMesh(arrayBuffer, options["quantized-mesh"]);
}
var init_parse_quantized_mesh = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/lib/parse-quantized-mesh.js"() {
    init_esm19();
    init_decode_quantized_mesh();
    init_skirt();
  }
});

// node_modules/@mapbox/martini/index.js
var Martini, Tile;
var init_martini = __esm({
  "node_modules/@mapbox/martini/index.js"() {
    Martini = class {
      constructor(gridSize = 257) {
        this.gridSize = gridSize;
        const tileSize = gridSize - 1;
        if (tileSize & tileSize - 1)
          throw new Error(
            `Expected grid size to be 2^n+1, got ${gridSize}.`
          );
        this.numTriangles = tileSize * tileSize * 2 - 2;
        this.numParentTriangles = this.numTriangles - tileSize * tileSize;
        this.indices = new Uint32Array(this.gridSize * this.gridSize);
        this.coords = new Uint16Array(this.numTriangles * 4);
        for (let i3 = 0; i3 < this.numTriangles; i3++) {
          let id = i3 + 2;
          let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
          if (id & 1) {
            bx = by = cx = tileSize;
          } else {
            ax = ay = cy = tileSize;
          }
          while ((id >>= 1) > 1) {
            const mx = ax + bx >> 1;
            const my = ay + by >> 1;
            if (id & 1) {
              bx = ax;
              by = ay;
              ax = cx;
              ay = cy;
            } else {
              ax = bx;
              ay = by;
              bx = cx;
              by = cy;
            }
            cx = mx;
            cy = my;
          }
          const k = i3 * 4;
          this.coords[k + 0] = ax;
          this.coords[k + 1] = ay;
          this.coords[k + 2] = bx;
          this.coords[k + 3] = by;
        }
      }
      createTile(terrain) {
        return new Tile(terrain, this);
      }
    };
    Tile = class {
      constructor(terrain, martini) {
        const size = martini.gridSize;
        if (terrain.length !== size * size)
          throw new Error(
            `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
          );
        this.terrain = terrain;
        this.martini = martini;
        this.errors = new Float32Array(terrain.length);
        this.update();
      }
      update() {
        const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
        const { terrain, errors } = this;
        for (let i3 = numTriangles - 1; i3 >= 0; i3--) {
          const k = i3 * 4;
          const ax = coords[k + 0];
          const ay = coords[k + 1];
          const bx = coords[k + 2];
          const by = coords[k + 3];
          const mx = ax + bx >> 1;
          const my = ay + by >> 1;
          const cx = mx + my - ay;
          const cy = my + ax - mx;
          const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
          const middleIndex = my * size + mx;
          const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
          errors[middleIndex] = Math.max(errors[middleIndex], middleError);
          if (i3 < numParentTriangles) {
            const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
            const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
            errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
          }
        }
      }
      getMesh(maxError = 0) {
        const { gridSize: size, indices } = this.martini;
        const { errors } = this;
        let numVertices = 0;
        let numTriangles = 0;
        const max = size - 1;
        indices.fill(0);
        function countElements(ax, ay, bx, by, cx, cy) {
          const mx = ax + bx >> 1;
          const my = ay + by >> 1;
          if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
            countElements(cx, cy, ax, ay, mx, my);
            countElements(bx, by, cx, cy, mx, my);
          } else {
            indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
            indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
            indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
            numTriangles++;
          }
        }
        countElements(0, 0, max, max, max, 0);
        countElements(max, max, 0, 0, 0, max);
        const vertices = new Uint16Array(numVertices * 2);
        const triangles = new Uint32Array(numTriangles * 3);
        let triIndex = 0;
        function processTriangle(ax, ay, bx, by, cx, cy) {
          const mx = ax + bx >> 1;
          const my = ay + by >> 1;
          if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
            processTriangle(cx, cy, ax, ay, mx, my);
            processTriangle(bx, by, cx, cy, mx, my);
          } else {
            const a2 = indices[ay * size + ax] - 1;
            const b = indices[by * size + bx] - 1;
            const c2 = indices[cy * size + cx] - 1;
            vertices[2 * a2] = ax;
            vertices[2 * a2 + 1] = ay;
            vertices[2 * b] = bx;
            vertices[2 * b + 1] = by;
            vertices[2 * c2] = cx;
            vertices[2 * c2 + 1] = cy;
            triangles[triIndex++] = a2;
            triangles[triIndex++] = b;
            triangles[triIndex++] = c2;
          }
        }
        processTriangle(0, 0, max, max, max, 0);
        processTriangle(max, max, 0, 0, 0, max);
        return { vertices, triangles };
      }
    };
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/lib/delatin/index.js
function orient(ax, ay, bx, by, cx, cy) {
  return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
var Delatin;
var init_delatin = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/lib/delatin/index.js"() {
    Delatin = class {
      constructor(data, width) {
        let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : width;
        this.data = data;
        this.width = width;
        this.height = height;
        this.coords = [];
        this.triangles = [];
        this._halfedges = [];
        this._candidates = [];
        this._queueIndices = [];
        this._queue = [];
        this._errors = [];
        this._rms = [];
        this._pending = [];
        this._pendingLen = 0;
        this._rmsSum = 0;
        const x1 = width - 1;
        const y1 = height - 1;
        const p0 = this._addPoint(0, 0);
        const p1 = this._addPoint(x1, 0);
        const p2 = this._addPoint(0, y1);
        const p3 = this._addPoint(x1, y1);
        const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);
        this._addTriangle(p0, p3, p1, t0, -1, -1);
        this._flush();
      }
      run() {
        let maxError = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        while (this.getMaxError() > maxError) {
          this.refine();
        }
      }
      refine() {
        this._step();
        this._flush();
      }
      getMaxError() {
        return this._errors[0];
      }
      getRMSD() {
        return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
      }
      heightAt(x2, y2) {
        return this.data[this.width * y2 + x2];
      }
      _flush() {
        const coords = this.coords;
        for (let i3 = 0; i3 < this._pendingLen; i3++) {
          const t2 = this._pending[i3];
          const a2 = 2 * this.triangles[t2 * 3 + 0];
          const b = 2 * this.triangles[t2 * 3 + 1];
          const c2 = 2 * this.triangles[t2 * 3 + 2];
          this._findCandidate(coords[a2], coords[a2 + 1], coords[b], coords[b + 1], coords[c2], coords[c2 + 1], t2);
        }
        this._pendingLen = 0;
      }
      _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t2) {
        const minX = Math.min(p0x, p1x, p2x);
        const minY = Math.min(p0y, p1y, p2y);
        const maxX = Math.max(p0x, p1x, p2x);
        const maxY = Math.max(p0y, p1y, p2y);
        let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
        let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
        let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
        const a01 = p1y - p0y;
        const b01 = p0x - p1x;
        const a12 = p2y - p1y;
        const b12 = p1x - p2x;
        const a20 = p0y - p2y;
        const b20 = p2x - p0x;
        const a2 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
        const z0 = this.heightAt(p0x, p0y) / a2;
        const z1 = this.heightAt(p1x, p1y) / a2;
        const z2 = this.heightAt(p2x, p2y) / a2;
        let maxError = 0;
        let mx = 0;
        let my = 0;
        let rms = 0;
        for (let y2 = minY; y2 <= maxY; y2++) {
          let dx = 0;
          if (w00 < 0 && a12 !== 0) {
            dx = Math.max(dx, Math.floor(-w00 / a12));
          }
          if (w01 < 0 && a20 !== 0) {
            dx = Math.max(dx, Math.floor(-w01 / a20));
          }
          if (w02 < 0 && a01 !== 0) {
            dx = Math.max(dx, Math.floor(-w02 / a01));
          }
          let w0 = w00 + a12 * dx;
          let w1 = w01 + a20 * dx;
          let w2 = w02 + a01 * dx;
          let wasInside = false;
          for (let x2 = minX + dx; x2 <= maxX; x2++) {
            if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
              wasInside = true;
              const z = z0 * w0 + z1 * w1 + z2 * w2;
              const dz = Math.abs(z - this.heightAt(x2, y2));
              rms += dz * dz;
              if (dz > maxError) {
                maxError = dz;
                mx = x2;
                my = y2;
              }
            } else if (wasInside) {
              break;
            }
            w0 += a12;
            w1 += a20;
            w2 += a01;
          }
          w00 += b12;
          w01 += b20;
          w02 += b01;
        }
        if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
          maxError = 0;
        }
        this._candidates[2 * t2] = mx;
        this._candidates[2 * t2 + 1] = my;
        this._rms[t2] = rms;
        this._queuePush(t2, maxError, rms);
      }
      _step() {
        const t2 = this._queuePop();
        const e0 = t2 * 3 + 0;
        const e1 = t2 * 3 + 1;
        const e2 = t2 * 3 + 2;
        const p0 = this.triangles[e0];
        const p1 = this.triangles[e1];
        const p2 = this.triangles[e2];
        const ax = this.coords[2 * p0];
        const ay = this.coords[2 * p0 + 1];
        const bx = this.coords[2 * p1];
        const by = this.coords[2 * p1 + 1];
        const cx = this.coords[2 * p2];
        const cy = this.coords[2 * p2 + 1];
        const px = this._candidates[2 * t2];
        const py = this._candidates[2 * t2 + 1];
        const pn = this._addPoint(px, py);
        if (orient(ax, ay, bx, by, px, py) === 0) {
          this._handleCollinear(pn, e0);
        } else if (orient(bx, by, cx, cy, px, py) === 0) {
          this._handleCollinear(pn, e1);
        } else if (orient(cx, cy, ax, ay, px, py) === 0) {
          this._handleCollinear(pn, e2);
        } else {
          const h0 = this._halfedges[e0];
          const h1 = this._halfedges[e1];
          const h2 = this._halfedges[e2];
          const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
          const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);
          const t22 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);
          this._legalize(t0);
          this._legalize(t1);
          this._legalize(t22);
        }
      }
      _addPoint(x2, y2) {
        const i3 = this.coords.length >> 1;
        this.coords.push(x2, y2);
        return i3;
      }
      _addTriangle(a2, b, c2, ab, bc, ca) {
        let e2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.triangles.length;
        const t2 = e2 / 3;
        this.triangles[e2 + 0] = a2;
        this.triangles[e2 + 1] = b;
        this.triangles[e2 + 2] = c2;
        this._halfedges[e2 + 0] = ab;
        this._halfedges[e2 + 1] = bc;
        this._halfedges[e2 + 2] = ca;
        if (ab >= 0) {
          this._halfedges[ab] = e2 + 0;
        }
        if (bc >= 0) {
          this._halfedges[bc] = e2 + 1;
        }
        if (ca >= 0) {
          this._halfedges[ca] = e2 + 2;
        }
        this._candidates[2 * t2 + 0] = 0;
        this._candidates[2 * t2 + 1] = 0;
        this._queueIndices[t2] = -1;
        this._rms[t2] = 0;
        this._pending[this._pendingLen++] = t2;
        return e2;
      }
      _legalize(a2) {
        const b = this._halfedges[a2];
        if (b < 0) {
          return;
        }
        const a0 = a2 - a2 % 3;
        const b0 = b - b % 3;
        const al = a0 + (a2 + 1) % 3;
        const ar = a0 + (a2 + 2) % 3;
        const bl = b0 + (b + 2) % 3;
        const br = b0 + (b + 1) % 3;
        const p0 = this.triangles[ar];
        const pr = this.triangles[a2];
        const pl = this.triangles[al];
        const p1 = this.triangles[bl];
        const coords = this.coords;
        if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
          return;
        }
        const hal = this._halfedges[al];
        const har = this._halfedges[ar];
        const hbl = this._halfedges[bl];
        const hbr = this._halfedges[br];
        this._queueRemove(a0 / 3);
        this._queueRemove(b0 / 3);
        const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
        const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
        this._legalize(t0 + 1);
        this._legalize(t1 + 2);
      }
      _handleCollinear(pn, a2) {
        const a0 = a2 - a2 % 3;
        const al = a0 + (a2 + 1) % 3;
        const ar = a0 + (a2 + 2) % 3;
        const p0 = this.triangles[ar];
        const pr = this.triangles[a2];
        const pl = this.triangles[al];
        const hal = this._halfedges[al];
        const har = this._halfedges[ar];
        const b = this._halfedges[a2];
        if (b < 0) {
          const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
          const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
          this._legalize(t02 + 1);
          this._legalize(t12 + 2);
          return;
        }
        const b0 = b - b % 3;
        const bl = b0 + (b + 2) % 3;
        const br = b0 + (b + 1) % 3;
        const p1 = this.triangles[bl];
        const hbl = this._halfedges[bl];
        const hbr = this._halfedges[br];
        this._queueRemove(b0 / 3);
        const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
        const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
        const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
        const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);
        this._legalize(t0);
        this._legalize(t1);
        this._legalize(t2);
        this._legalize(t3);
      }
      _queuePush(t2, error, rms) {
        const i3 = this._queue.length;
        this._queueIndices[t2] = i3;
        this._queue.push(t2);
        this._errors.push(error);
        this._rmsSum += rms;
        this._queueUp(i3);
      }
      _queuePop() {
        const n2 = this._queue.length - 1;
        this._queueSwap(0, n2);
        this._queueDown(0, n2);
        return this._queuePopBack();
      }
      _queuePopBack() {
        const t2 = this._queue.pop();
        this._errors.pop();
        this._rmsSum -= this._rms[t2];
        this._queueIndices[t2] = -1;
        return t2;
      }
      _queueRemove(t2) {
        const i3 = this._queueIndices[t2];
        if (i3 < 0) {
          const it = this._pending.indexOf(t2);
          if (it !== -1) {
            this._pending[it] = this._pending[--this._pendingLen];
          } else {
            throw new Error("Broken triangulation (something went wrong).");
          }
          return;
        }
        const n2 = this._queue.length - 1;
        if (n2 !== i3) {
          this._queueSwap(i3, n2);
          if (!this._queueDown(i3, n2)) {
            this._queueUp(i3);
          }
        }
        this._queuePopBack();
      }
      _queueLess(i3, j) {
        return this._errors[i3] > this._errors[j];
      }
      _queueSwap(i3, j) {
        const pi = this._queue[i3];
        const pj = this._queue[j];
        this._queue[i3] = pj;
        this._queue[j] = pi;
        this._queueIndices[pi] = j;
        this._queueIndices[pj] = i3;
        const e2 = this._errors[i3];
        this._errors[i3] = this._errors[j];
        this._errors[j] = e2;
      }
      _queueUp(j0) {
        let j = j0;
        while (true) {
          const i3 = j - 1 >> 1;
          if (i3 === j || !this._queueLess(j, i3)) {
            break;
          }
          this._queueSwap(i3, j);
          j = i3;
        }
      }
      _queueDown(i0, n2) {
        let i3 = i0;
        while (true) {
          const j1 = 2 * i3 + 1;
          if (j1 >= n2 || j1 < 0) {
            break;
          }
          const j2 = j1 + 1;
          let j = j1;
          if (j2 < n2 && this._queueLess(j2, j1)) {
            j = j2;
          }
          if (!this._queueLess(j, i3)) {
            break;
          }
          this._queueSwap(i3, j);
          i3 = j;
        }
        return i3 > i0;
      }
    };
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/lib/parse-terrain.js
function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
  const {
    rScaler,
    bScaler,
    gScaler,
    offset
  } = elevationDecoder;
  const terrain = new Float32Array((width + 1) * (height + 1));
  for (let i3 = 0, y2 = 0; y2 < height; y2++) {
    for (let x2 = 0; x2 < width; x2++, i3++) {
      const k = i3 * 4;
      const r2 = imageData[k + 0];
      const g = imageData[k + 1];
      const b = imageData[k + 2];
      terrain[i3 + y2] = r2 * rScaler + g * gScaler + b * bScaler + offset;
    }
  }
  if (tesselator === "martini") {
    for (let i3 = (width + 1) * width, x2 = 0; x2 < width; x2++, i3++) {
      terrain[i3] = terrain[i3 - width - 1];
    }
    for (let i3 = height, y2 = 0; y2 < height + 1; y2++, i3 += height + 1) {
      terrain[i3] = terrain[i3 - 1];
    }
  }
  return terrain;
}
function getMeshAttributes2(vertices, terrain, width, height, bounds) {
  const gridSize = width + 1;
  const numOfVerticies = vertices.length / 2;
  const positions = new Float32Array(numOfVerticies * 3);
  const texCoords = new Float32Array(numOfVerticies * 2);
  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
  const xScale = (maxX - minX) / width;
  const yScale = (maxY - minY) / height;
  for (let i3 = 0; i3 < numOfVerticies; i3++) {
    const x2 = vertices[i3 * 2];
    const y2 = vertices[i3 * 2 + 1];
    const pixelIdx = y2 * gridSize + x2;
    positions[3 * i3 + 0] = x2 * xScale + minX;
    positions[3 * i3 + 1] = -y2 * yScale + maxY;
    positions[3 * i3 + 2] = terrain[pixelIdx];
    texCoords[2 * i3 + 0] = x2 / width;
    texCoords[2 * i3 + 1] = y2 / height;
  }
  return {
    POSITION: {
      value: positions,
      size: 3
    },
    TEXCOORD_0: {
      value: texCoords,
      size: 2
    }
  };
}
function getMesh(terrainImage, terrainOptions) {
  if (terrainImage === null) {
    return null;
  }
  const {
    meshMaxError,
    bounds,
    elevationDecoder
  } = terrainOptions;
  const {
    data,
    width,
    height
  } = terrainImage;
  let terrain;
  let mesh;
  switch (terrainOptions.tesselator) {
    case "martini":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      break;
    case "delatin":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      break;
    default:
      if (width === height && !(height & width - 1)) {
        terrain = getTerrain(data, width, height, elevationDecoder, "martini");
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      } else {
        terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      }
      break;
  }
  const {
    vertices
  } = mesh;
  let {
    triangles
  } = mesh;
  let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (terrainOptions.skirtHeight) {
    const {
      attributes: newAttributes,
      triangles: newTriangles
    } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
    attributes = newAttributes;
    triangles = newTriangles;
  }
  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangles.length,
      boundingBox
    },
    mode: 4,
    indices: {
      value: Uint32Array.from(triangles),
      size: 1
    },
    attributes
  };
}
function getMartiniTileMesh(meshMaxError, width, terrain) {
  const gridSize = width + 1;
  const martini = new Martini(gridSize);
  const tile = martini.createTile(terrain);
  const {
    vertices,
    triangles
  } = tile.getMesh(meshMaxError);
  return {
    vertices,
    triangles
  };
}
function getDelatinTileMesh(meshMaxError, width, height, terrain) {
  const tin = new Delatin(terrain, width + 1, height + 1);
  tin.run(meshMaxError);
  const {
    coords,
    triangles
  } = tin;
  const vertices = coords;
  return {
    vertices,
    triangles
  };
}
async function loadTerrain(arrayBuffer, options, context) {
  const loadImageOptions = {
    ...options,
    mimeType: "application/x.image",
    image: {
      ...options.image,
      type: "data"
    }
  };
  const image = await context.parse(arrayBuffer, loadImageOptions);
  return getMesh(image, options.terrain);
}
var init_parse_terrain = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/lib/parse-terrain.js"() {
    init_esm19();
    init_martini();
    init_delatin();
    init_skirt();
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/lib/utils/version.js
var VERSION9;
var init_version5 = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/lib/utils/version.js"() {
    VERSION9 = true ? "3.3.3" : "latest";
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/terrain-loader.js
var TerrainLoader;
var init_terrain_loader = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/terrain-loader.js"() {
    init_version5();
    TerrainLoader = {
      name: "Terrain",
      id: "terrain",
      module: "terrain",
      version: VERSION9,
      worker: true,
      extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
      mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
      options: {
        terrain: {
          tesselator: "auto",
          bounds: null,
          meshMaxError: 10,
          elevationDecoder: {
            rScaler: 1,
            gScaler: 0,
            bScaler: 0,
            offset: 0
          },
          skirtHeight: null
        }
      }
    };
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/quantized-mesh-loader.js
var QuantizedMeshLoader;
var init_quantized_mesh_loader = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/quantized-mesh-loader.js"() {
    init_version5();
    QuantizedMeshLoader = {
      name: "Quantized Mesh",
      id: "quantized-mesh",
      module: "terrain",
      version: VERSION9,
      worker: true,
      extensions: ["terrain"],
      mimeTypes: ["application/vnd.quantized-mesh"],
      options: {
        "quantized-mesh": {
          bounds: [0, 0, 1, 1],
          skirtHeight: null
        }
      }
    };
  }
});

// node_modules/@loaders.gl/terrain/dist/esm/index.js
var TerrainLoader2, QuantizedMeshLoader2;
var init_esm29 = __esm({
  "node_modules/@loaders.gl/terrain/dist/esm/index.js"() {
    init_parse_quantized_mesh();
    init_parse_terrain();
    init_terrain_loader();
    init_quantized_mesh_loader();
    TerrainLoader2 = {
      ...TerrainLoader,
      parse: loadTerrain
    };
    QuantizedMeshLoader2 = {
      ...QuantizedMeshLoader,
      parseSync: loadQuantizedMesh,
      parse: async (arrayBuffer, options) => loadQuantizedMesh(arrayBuffer, options)
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/terrain-layer/terrain-layer.js
function urlTemplateToUpdateTrigger(template) {
  if (Array.isArray(template)) {
    return template.join(";");
  }
  return template || "";
}
var DUMMY_DATA, defaultProps29, TerrainLayer;
var init_terrain_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/terrain-layer/terrain-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm24();
    init_esm13();
    init_esm29();
    init_tile_layer();
    init_tileset_2d2();
    DUMMY_DATA = [1];
    defaultProps29 = {
      ...TileLayer.defaultProps,
      elevationData: urlType,
      texture: {
        ...urlType,
        optional: true
      },
      meshMaxError: {
        type: "number",
        value: 4
      },
      bounds: {
        type: "array",
        value: null,
        optional: true,
        compare: true
      },
      color: {
        type: "color",
        value: [255, 255, 255]
      },
      elevationDecoder: {
        type: "object",
        value: {
          rScaler: 1,
          gScaler: 0,
          bScaler: 0,
          offset: 0
        }
      },
      workerUrl: "",
      wireframe: false,
      material: true,
      loaders: [TerrainLoader]
    };
    TerrainLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      updateState({
        props,
        oldProps
      }) {
        const elevationDataChanged = props.elevationData !== oldProps.elevationData;
        if (elevationDataChanged) {
          const {
            elevationData
          } = props;
          const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
          this.setState({
            isTiled
          });
        }
        const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
        if (!this.state.isTiled && shouldReload) {
          const terrain = this.loadTerrain(props);
          this.setState({
            terrain
          });
        }
        if (props.workerUrl) {
          log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
        }
      }
      loadTerrain({
        elevationData,
        bounds,
        elevationDecoder,
        meshMaxError,
        signal
      }) {
        var _loadOptions;
        if (!elevationData) {
          return null;
        }
        let loadOptions = this.getLoadOptions();
        loadOptions = {
          ...loadOptions,
          terrain: {
            skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
            ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.terrain,
            bounds,
            meshMaxError,
            elevationDecoder
          }
        };
        const {
          fetch: fetch2
        } = this.props;
        return fetch2(elevationData, {
          propName: "elevationData",
          layer: this,
          loadOptions,
          signal
        });
      }
      getTiledTerrainData(tile) {
        const {
          elevationData,
          fetch: fetch2,
          texture,
          elevationDecoder,
          meshMaxError
        } = this.props;
        const {
          viewport
        } = this.context;
        const dataUrl = getURLFromTemplate(elevationData, tile);
        const textureUrl = texture && getURLFromTemplate(texture, tile);
        const {
          signal
        } = tile;
        let bottomLeft = [0, 0];
        let topRight = [0, 0];
        if (viewport.isGeospatial) {
          const bbox = tile.bbox;
          bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
          topRight = viewport.projectFlat([bbox.east, bbox.north]);
        } else {
          const bbox = tile.bbox;
          bottomLeft = [bbox.left, bbox.bottom];
          topRight = [bbox.right, bbox.top];
        }
        const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
        const terrain = this.loadTerrain({
          elevationData: dataUrl,
          bounds,
          elevationDecoder,
          meshMaxError,
          signal
        });
        const surface = textureUrl ? fetch2(textureUrl, {
          propName: "texture",
          layer: this,
          loaders: [],
          signal
        }).catch((_2) => null) : Promise.resolve(null);
        return Promise.all([terrain, surface]);
      }
      renderSubLayers(props) {
        const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
        const {
          color,
          wireframe,
          material
        } = this.props;
        const {
          data
        } = props;
        if (!data) {
          return null;
        }
        const [mesh, texture] = data;
        return new SubLayerClass(props, {
          data: DUMMY_DATA,
          mesh,
          texture,
          _instanced: false,
          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
          getPosition: (d) => [0, 0, 0],
          getColor: color,
          wireframe,
          material
        });
      }
      onViewportLoad(tiles) {
        if (!tiles) {
          return;
        }
        const {
          zRange
        } = this.state;
        const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
          const bounds = arr[0].header.boundingBox;
          return bounds.map((bound) => bound[2]);
        });
        if (ranges.length === 0) {
          return;
        }
        const minZ = Math.min(...ranges.map((x2) => x2[0]));
        const maxZ = Math.max(...ranges.map((x2) => x2[1]));
        if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
          this.setState({
            zRange: [minZ, maxZ]
          });
        }
      }
      renderLayers() {
        const {
          color,
          material,
          elevationData,
          texture,
          wireframe,
          meshMaxError,
          elevationDecoder,
          tileSize,
          maxZoom,
          minZoom,
          extent,
          maxRequests,
          onTileLoad,
          onTileUnload,
          onTileError,
          maxCacheSize,
          maxCacheByteSize,
          refinementStrategy
        } = this.props;
        if (this.state.isTiled) {
          return new TileLayer(this.getSubLayerProps({
            id: "tiles"
          }), {
            getTileData: this.getTiledTerrainData.bind(this),
            renderSubLayers: this.renderSubLayers.bind(this),
            updateTriggers: {
              getTileData: {
                elevationData: urlTemplateToUpdateTrigger(elevationData),
                texture: urlTemplateToUpdateTrigger(texture),
                meshMaxError,
                elevationDecoder
              }
            },
            onViewportLoad: this.onViewportLoad.bind(this),
            zRange: this.state.zRange || null,
            tileSize,
            maxZoom,
            minZoom,
            extent,
            maxRequests,
            onTileLoad,
            onTileUnload,
            onTileError,
            maxCacheSize,
            maxCacheByteSize,
            refinementStrategy
          });
        }
        const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
        return new SubLayerClass(this.getSubLayerProps({
          id: "mesh"
        }), {
          data: DUMMY_DATA,
          mesh: this.state.terrain,
          texture,
          _instanced: false,
          getPosition: (d) => [0, 0, 0],
          getColor: color,
          material,
          wireframe
        });
      }
    };
    _defineProperty(TerrainLayer, "defaultProps", defaultProps29);
    _defineProperty(TerrainLayer, "layerName", "TerrainLayer");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js
var vs2, fs2, TARGET, inject, shader_module_default;
var init_shader_module = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js"() {
    init_esm13();
    vs2 = "\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n";
    fs2 = "\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n";
    TARGET = {
      source: 0,
      target: 1,
      custom: 2,
      source_target: 3
    };
    inject = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  "
    };
    shader_module_default = {
      name: "brushing",
      dependencies: [project_default],
      vs: vs2,
      fs: fs2,
      inject,
      getUniforms: (opts) => {
        if (!opts || !("viewport" in opts)) {
          return {};
        }
        const {
          brushingEnabled = true,
          brushingRadius = 1e4,
          brushingTarget = "source",
          mousePosition,
          viewport
        } = opts;
        return {
          brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
          brushing_radius: brushingRadius,
          brushing_target: TARGET[brushingTarget] || 0,
          brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
        };
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/brushing/brushing-extension.js
var defaultProps30, BrushingExtension;
var init_brushing_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/brushing-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_shader_module();
    defaultProps30 = {
      getBrushingTarget: {
        type: "accessor",
        value: [0, 0]
      },
      brushingTarget: "source",
      brushingEnabled: true,
      brushingRadius: 1e4
    };
    BrushingExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [shader_module_default]
        };
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.add({
            brushingTargets: {
              size: 2,
              accessor: "getBrushingTarget",
              shaderAttributes: {
                brushingTargets: {
                  divisor: 0
                },
                instanceBrushingTargets: {
                  divisor: 1
                }
              }
            }
          });
        }
        this.state.onMouseMove = () => {
          var _this$getCurrentLayer;
          (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.setNeedsRedraw();
        };
        if (context.deck) {
          context.deck.eventManager.on({
            pointermove: this.state.onMouseMove,
            pointerleave: this.state.onMouseMove
          });
        }
      }
      finalizeState(context, extension) {
        if (context.deck) {
          context.deck.eventManager.off({
            pointermove: this.state.onMouseMove,
            pointerleave: this.state.onMouseMove
          });
        }
      }
    };
    _defineProperty(BrushingExtension, "defaultProps", defaultProps30);
    _defineProperty(BrushingExtension, "extensionName", "BrushingExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js
function getUniforms(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const {
    filterRange = [-1, 1],
    filterEnabled = true,
    filterTransformSize = true,
    filterTransformColor = true
  } = opts;
  const filterSoftRange = opts.filterSoftRange || filterRange;
  return {
    ...Number.isFinite(filterRange[0]) ? {
      filter_min: filterRange[0],
      filter_softMin: filterSoftRange[0],
      filter_softMax: filterSoftRange[1],
      filter_max: filterRange[1]
    } : {
      filter_min: filterRange.map((r2) => r2[0]),
      filter_softMin: filterSoftRange.map((r2) => r2[0]),
      filter_softMax: filterSoftRange.map((r2) => r2[1]),
      filter_max: filterRange.map((r2) => r2[1])
    },
    filter_enabled: filterEnabled,
    filter_useSoftMargin: Boolean(opts.filterSoftRange),
    filter_transformSize: filterEnabled && filterTransformSize,
    filter_transformColor: filterEnabled && filterTransformColor
  };
}
function getUniforms64(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const uniforms = getUniforms(opts);
  if (Number.isFinite(uniforms.filter_min)) {
    const min64High = Math.fround(uniforms.filter_min);
    uniforms.filter_min -= min64High;
    uniforms.filter_softMin -= min64High;
    uniforms.filter_min64High = min64High;
    const max64High = Math.fround(uniforms.filter_max);
    uniforms.filter_max -= max64High;
    uniforms.filter_softMax -= max64High;
    uniforms.filter_max64High = max64High;
  } else {
    const min64High = uniforms.filter_min.map(Math.fround);
    uniforms.filter_min = uniforms.filter_min.map((x2, i3) => x2 - min64High[i3]);
    uniforms.filter_softMin = uniforms.filter_softMin.map((x2, i3) => x2 - min64High[i3]);
    uniforms.filter_min64High = min64High;
    const max64High = uniforms.filter_max.map(Math.fround);
    uniforms.filter_max = uniforms.filter_max.map((x2, i3) => x2 - max64High[i3]);
    uniforms.filter_softMax = uniforms.filter_softMax.map((x2, i3) => x2 - max64High[i3]);
    uniforms.filter_max64High = max64High;
  }
  return uniforms;
}
var vs3, fs3, inject2, shaderModule, shaderModule64;
var init_shader_module2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js"() {
    vs3 = "\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n";
    fs3 = "\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n";
    inject2 = {
      "vs:#main-start": "\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  ",
      "vs:#main-end": "\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  ",
      "vs:DECKGL_FILTER_SIZE": "\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  "
    };
    shaderModule = {
      name: "data-filter",
      vs: vs3,
      fs: fs3,
      inject: inject2,
      getUniforms
    };
    shaderModule64 = {
      name: "data-filter-fp64",
      vs: vs3,
      fs: fs3,
      inject: inject2,
      getUniforms: getUniforms64
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/aggregator.js
function supportsFloatTarget(gl) {
  return Boolean(gl.getExtension("EXT_float_blend") && (gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float")));
}
function getFramebuffer(gl, useFloatTarget) {
  if (useFloatTarget) {
    return new Framebuffer(gl, {
      width: 1,
      height: 1,
      attachments: {
        [36064]: new Texture2D(gl, {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126,
          mipmaps: false
        })
      }
    });
  }
  return new Framebuffer(gl, {
    width: 256,
    height: 64,
    depth: false
  });
}
function getModel(gl, shaderOptions, useFloatTarget) {
  shaderOptions.defines.NON_INSTANCED_MODEL = 1;
  if (useFloatTarget) {
    shaderOptions.defines.FLOAT_TARGET = 1;
  }
  return new Model(gl, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: false,
    drawMode: 0,
    vs: AGGREGATE_VS,
    fs: AGGREGATE_FS,
    ...shaderOptions
  });
}
var AGGREGATE_VS, AGGREGATE_FS, parameters;
var init_aggregator = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/aggregator.js"() {
    init_esm11();
    AGGREGATE_VS = "#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n";
    AGGREGATE_FS = "#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n";
    parameters = {
      blend: true,
      blendFunc: [1, 1, 1, 1],
      blendEquation: [32774, 32774],
      depthTest: false
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter-extension.js
var defaultProps31, DATA_TYPE_FROM_SIZE, DataFilterExtension;
var init_data_filter_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_shader_module2();
    init_aggregator();
    init_esm11();
    defaultProps31 = {
      getFilterValue: {
        type: "accessor",
        value: 0
      },
      onFilteredItemsChange: {
        type: "function",
        value: null,
        optional: true
      },
      filterEnabled: true,
      filterRange: [-1, 1],
      filterSoftRange: null,
      filterTransformSize: true,
      filterTransformColor: true
    };
    DATA_TYPE_FROM_SIZE = {
      1: "float",
      2: "vec2",
      3: "vec3",
      4: "vec4"
    };
    DataFilterExtension = class extends LayerExtension {
      constructor({
        filterSize = 1,
        fp64: fp642 = false,
        countItems = false
      } = {}) {
        if (!DATA_TYPE_FROM_SIZE[filterSize]) {
          throw new Error("filterSize out of range");
        }
        super({
          filterSize,
          fp64: fp642,
          countItems
        });
      }
      getShaders(extension) {
        const {
          filterSize,
          fp64: fp642
        } = extension.opts;
        return {
          modules: [fp642 ? shaderModule64 : shaderModule],
          defines: {
            DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
            DATAFILTER_DOUBLE: Boolean(fp642)
          }
        };
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.add({
            filterValues: {
              size: extension.opts.filterSize,
              type: extension.opts.fp64 ? 5130 : 5126,
              accessor: "getFilterValue",
              shaderAttributes: {
                filterValues: {
                  divisor: 0
                },
                instanceFilterValues: {
                  divisor: 1
                }
              }
            }
          });
        }
        const {
          gl
        } = this.context;
        if (attributeManager && extension.opts.countItems) {
          const useFloatTarget = supportsFloatTarget(gl);
          attributeManager.add({
            filterIndices: {
              size: useFloatTarget ? 1 : 2,
              vertexOffset: 1,
              type: 5121,
              normalized: true,
              accessor: (object, {
                index
              }) => {
                const i3 = object && object.__source ? object.__source.index : index;
                return useFloatTarget ? (i3 + 1) % 255 : [(i3 + 1) % 255, Math.floor(i3 / 255) % 255];
              },
              shaderAttributes: {
                filterPrevIndices: {
                  vertexOffset: 0
                },
                filterIndices: {
                  vertexOffset: 1
                }
              }
            }
          });
          const filterFBO = getFramebuffer(gl, useFloatTarget);
          const filterModel = getModel(gl, extension.getShaders.call(this, extension), useFloatTarget);
          this.setState({
            filterFBO,
            filterModel
          });
        }
      }
      updateState({
        props,
        oldProps
      }) {
        if (this.state.filterModel) {
          const attributeManager = this.getAttributeManager();
          const filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange;
          if (filterNeedsUpdate) {
            this.setState({
              filterNeedsUpdate
            });
          }
        }
      }
      draw(params, extension) {
        const {
          filterFBO,
          filterModel,
          filterNeedsUpdate
        } = this.state;
        const {
          onFilteredItemsChange
        } = this.props;
        if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
          const {
            attributes: {
              filterValues,
              filterIndices
            }
          } = this.getAttributeManager();
          filterModel.setVertexCount(this.getNumInstances());
          const {
            gl
          } = this.context;
          clear(gl, {
            framebuffer: filterFBO,
            color: [0, 0, 0, 0]
          });
          filterModel.updateModuleSettings(params.moduleParameters).setAttributes({
            ...filterValues.getShaderAttributes(),
            ...filterIndices && filterIndices.getShaderAttributes()
          }).draw({
            framebuffer: filterFBO,
            parameters: {
              ...parameters,
              viewport: [0, 0, filterFBO.width, filterFBO.height]
            }
          });
          const color = readPixelsToArray(filterFBO);
          let count = 0;
          for (let i3 = 0; i3 < color.length; i3++) {
            count += color[i3];
          }
          onFilteredItemsChange({
            id: this.id,
            count
          });
          this.state.filterNeedsUpdate = false;
        }
      }
      finalizeState() {
        const {
          filterFBO,
          filterModel
        } = this.state;
        if (filterFBO) {
          filterFBO.color.delete();
          filterFBO.delete();
          filterModel.delete();
        }
      }
    };
    _defineProperty(DataFilterExtension, "defaultProps", defaultProps31);
    _defineProperty(DataFilterExtension, "extensionName", "DataFilterExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js
var project64_glsl_default;
var init_project64_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js"() {
    project64_glsl_default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n";
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js
function getUniforms2(opts) {
  if (opts && "viewport" in opts) {
    const {
      viewProjectionMatrix,
      scale
    } = opts.viewport;
    return getMemoizedUniforms({
      viewProjectionMatrix,
      scale
    });
  }
  return {};
}
function calculateUniforms({
  viewProjectionMatrix,
  scale
}) {
  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  const scaleFP64 = fp64ify(scale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}
var fp64ify, fp64ifyMatrix4, project64_default, getMemoizedUniforms;
var init_project64 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js"() {
    init_esm9();
    init_esm13();
    init_project64_glsl();
    ({
      fp64ify,
      fp64ifyMatrix4
    } = fp64);
    project64_default = {
      name: "project64",
      dependencies: [project_default, fp64],
      vs: project64_glsl_default,
      getUniforms: getUniforms2
    };
    getMemoizedUniforms = memoize(calculateUniforms);
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/fp64-extension.js
var Fp64Extension;
var init_fp64_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/fp64-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_project64();
    Fp64Extension = class extends LayerExtension {
      getShaders() {
        const {
          coordinateSystem
        } = this.props;
        if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
          throw new Error("fp64: coordinateSystem must be LNGLAT");
        }
        return {
          modules: [project64_default]
        };
      }
    };
    _defineProperty(Fp64Extension, "extensionName", "Fp64Extension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js
var dashShaders, offsetShaders;
var init_shaders_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js"() {
    dashShaders = {
      inject: {
        "vs:#decl": "\nattribute vec2 instanceDashArrays;\nattribute float instanceDashOffsets;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n",
        "vs:#main-end": "\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n",
        "fs:#decl": "\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n",
        "fs:#main-start": "\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(clamp(vPathPosition.y, 0.0, vPathLength) + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (capType <= 0.5) {\n        if (!(dashGapPickable && picking_uActive)) {\n          discard;\n        }\n      } else {\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(dashGapPickable && picking_uActive)) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n"
      }
    };
    offsetShaders = {
      inject: {
        "vs:#decl": "\nattribute float instanceOffsets;\n",
        "vs:DECKGL_FILTER_SIZE": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n",
        "vCornerOffset = offsetVec;": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  vec2 offsetCenter = -instanceOffsets * (isCap ? perp : miterVec * miterSize) * 2.0;\n  vCornerOffset = vCornerOffset * offsetWidth - offsetCenter;\n",
        "fs:#main-start": "\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n"
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js
var defaultProps32, PathStyleExtension;
var init_path_style_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_shaders_glsl();
    init_vec3();
    defaultProps32 = {
      getDashArray: {
        type: "accessor",
        value: [0, 0]
      },
      getOffset: {
        type: "accessor",
        value: 0
      },
      dashJustified: false,
      dashGapPickable: false
    };
    PathStyleExtension = class extends LayerExtension {
      constructor({
        dash = false,
        offset = false,
        highPrecisionDash = false
      } = {}) {
        super({
          dash: dash || highPrecisionDash,
          offset,
          highPrecisionDash
        });
      }
      isEnabled(layer) {
        return "pathTesselator" in layer.state;
      }
      getShaders(extension) {
        if (!extension.isEnabled(this)) {
          return null;
        }
        let result = {};
        if (extension.opts.dash) {
          result = mergeShaders(result, dashShaders);
        }
        if (extension.opts.offset) {
          result = mergeShaders(result, offsetShaders);
        }
        return result;
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager || !extension.isEnabled(this)) {
          return;
        }
        if (extension.opts.dash) {
          attributeManager.addInstanced({
            instanceDashArrays: {
              size: 2,
              accessor: "getDashArray"
            }
          });
        }
        if (extension.opts.highPrecisionDash) {
          attributeManager.addInstanced({
            instanceDashOffsets: {
              size: 1,
              accessor: "getPath",
              transform: extension.getDashOffsets.bind(this)
            }
          });
        }
        if (extension.opts.offset) {
          attributeManager.addInstanced({
            instanceOffsets: {
              size: 1,
              accessor: "getOffset"
            }
          });
        }
      }
      updateState(params, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const uniforms = {};
        if (extension.opts.dash) {
          uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
          uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
        }
        this.state.model.setUniforms(uniforms);
      }
      getDashOffsets(path) {
        const result = [0];
        const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
        const isNested2 = Array.isArray(path[0]);
        const geometrySize = isNested2 ? path.length : path.length / positionSize;
        let p2;
        let prevP;
        for (let i3 = 0; i3 < geometrySize - 1; i3++) {
          p2 = isNested2 ? path[i3] : path.slice(i3 * positionSize, i3 * positionSize + positionSize);
          p2 = this.projectPosition(p2);
          if (i3 > 0) {
            result[i3] = result[i3 - 1] + dist(prevP, p2);
          }
          prevP = p2;
        }
        return result;
      }
    };
    _defineProperty(PathStyleExtension, "defaultProps", defaultProps32);
    _defineProperty(PathStyleExtension, "extensionName", "PathStyleExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js
function getPatternUniforms(opts, uniforms) {
  if (!opts) {
    return {};
  }
  if ("fillPatternTexture" in opts) {
    const {
      fillPatternTexture
    } = opts;
    return {
      fill_patternTexture: fillPatternTexture,
      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
    };
  }
  if ("viewport" in opts) {
    const {
      fillPatternMask = true,
      fillPatternEnabled = true
    } = opts;
    const {
      project_uCommonOrigin: coordinateOriginCommon
    } = uniforms;
    const coordinateOriginCommon64Low = [fp64LowPart(coordinateOriginCommon[0]), fp64LowPart(coordinateOriginCommon[1])];
    return {
      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
      fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,
      fill_patternMask: fillPatternMask,
      fill_patternEnabled: fillPatternEnabled
    };
  }
  return {};
}
var patternVs, patternFs, inject3, patternShaders;
var init_shaders_glsl2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js"() {
    init_esm13();
    patternVs = "\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\n";
    patternFs = "\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\nuniform vec2 fill_uvCoordinateOrigin64Low;\n\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n";
    inject3 = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    fill_uv = geometry.position.xy;\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\n      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n\n      vec4 patternColor = texture2D(fill_patternTexture, texCoords);\n      color.a *= patternColor.a;\n      if (!fill_patternMask) {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  "
    };
    patternShaders = {
      name: "fill-pattern",
      vs: patternVs,
      fs: patternFs,
      inject: inject3,
      dependencies: [project_default],
      getUniforms: getPatternUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style-extension.js
var defaultProps33, FillStyleExtension;
var init_fill_style_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_shaders_glsl2();
    defaultProps33 = {
      fillPatternEnabled: true,
      fillPatternAtlas: {
        type: "image",
        value: null,
        async: true,
        parameters: {
          [10241]: 9729
        }
      },
      fillPatternMapping: {
        type: "object",
        value: {},
        async: true
      },
      fillPatternMask: true,
      getFillPattern: {
        type: "accessor",
        value: (d) => d.pattern
      },
      getFillPatternScale: {
        type: "accessor",
        value: 1
      },
      getFillPatternOffset: {
        type: "accessor",
        value: [0, 0]
      }
    };
    FillStyleExtension = class extends LayerExtension {
      constructor({
        pattern = false
      } = {}) {
        super({
          pattern
        });
      }
      isEnabled(layer) {
        return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
      }
      getShaders(extension) {
        if (!extension.isEnabled(this)) {
          return null;
        }
        return {
          modules: [extension.opts.pattern && patternShaders].filter(Boolean)
        };
      }
      initializeState(context, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const attributeManager = this.getAttributeManager();
        if (extension.opts.pattern) {
          attributeManager.add({
            fillPatternFrames: {
              size: 4,
              accessor: "getFillPattern",
              transform: extension.getPatternFrame.bind(this),
              shaderAttributes: {
                fillPatternFrames: {
                  divisor: 0
                },
                instanceFillPatternFrames: {
                  divisor: 1
                }
              }
            },
            fillPatternScales: {
              size: 1,
              accessor: "getFillPatternScale",
              defaultValue: 1,
              shaderAttributes: {
                fillPatternScales: {
                  divisor: 0
                },
                instanceFillPatternScales: {
                  divisor: 1
                }
              }
            },
            fillPatternOffsets: {
              size: 2,
              accessor: "getFillPatternOffset",
              shaderAttributes: {
                fillPatternOffsets: {
                  divisor: 0
                },
                instanceFillPatternOffsets: {
                  divisor: 1
                }
              }
            }
          });
        }
        this.setState({
          emptyTexture: new Texture2D(this.context.gl, {
            data: new Uint8Array(4),
            width: 1,
            height: 1
          })
        });
      }
      updateState({
        props,
        oldProps
      }, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
          this.getAttributeManager().invalidate("getFillPattern");
        }
      }
      draw(params, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const {
          fillPatternAtlas
        } = this.props;
        this.setModuleParameters({
          fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
        });
      }
      finalizeState() {
        const {
          emptyTexture
        } = this.state;
        emptyTexture === null || emptyTexture === void 0 ? void 0 : emptyTexture.delete();
      }
      getPatternFrame(name10) {
        const {
          fillPatternMapping
        } = this.getCurrentLayer().props;
        const def = fillPatternMapping && fillPatternMapping[name10];
        return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
      }
    };
    _defineProperty(FillStyleExtension, "defaultProps", defaultProps33);
    _defineProperty(FillStyleExtension, "extensionName", "FillStyleExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/clip/clip-extension.js
var defaultProps34, shaderFunction, shaderModuleVs, injectionVs, shaderModuleFs, injectionFs, ClipExtension;
var init_clip_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/clip/clip-extension.js"() {
    init_defineProperty();
    init_esm13();
    defaultProps34 = {
      clipBounds: [0, 0, 1, 1],
      clipByInstance: void 0
    };
    shaderFunction = "\nuniform vec4 clip_bounds;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n";
    shaderModuleVs = {
      name: "clip-vs",
      vs: shaderFunction
    };
    injectionVs = {
      "vs:#decl": "\nvarying float clip_isVisible;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n",
      "fs:#decl": "\nvarying float clip_isVisible;\n",
      "fs:DECKGL_FILTER_COLOR": "\n  if (clip_isVisible < 0.5) discard;\n"
    };
    shaderModuleFs = {
      name: "clip-fs",
      fs: shaderFunction
    };
    injectionFs = {
      "vs:#decl": "\nvarying vec2 clip_commonPosition;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_commonPosition = geometry.position.xy;\n",
      "fs:#decl": "\nvarying vec2 clip_commonPosition;\n",
      "fs:DECKGL_FILTER_COLOR": "\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n"
    };
    ClipExtension = class extends LayerExtension {
      getShaders() {
        let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
        if (this.props.clipByInstance !== void 0) {
          clipByInstance = Boolean(this.props.clipByInstance);
        }
        this.state.clipByInstance = clipByInstance;
        return clipByInstance ? {
          modules: [shaderModuleVs],
          inject: injectionVs
        } : {
          modules: [shaderModuleFs],
          inject: injectionFs
        };
      }
      draw({
        uniforms
      }) {
        const {
          clipBounds
        } = this.props;
        if (this.state.clipByInstance) {
          uniforms.clip_bounds = clipBounds;
        } else {
          const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
          const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
          uniforms.clip_bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];
        }
      }
    };
    _defineProperty(ClipExtension, "defaultProps", defaultProps34);
    _defineProperty(ClipExtension, "extensionName", "ClipExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/shader-module.js
var vs4, inject4, getCollisionUniforms, shader_module_default2;
var init_shader_module3 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/shader-module.js"() {
    init_esm13();
    vs4 = "\n#ifdef NON_INSTANCED_MODEL\nattribute float collisionPriorities;\n#else\nattribute float instanceCollisionPriorities;\n#endif\n\nuniform sampler2D collision_texture;\nuniform bool collision_sort;\nuniform bool collision_enabled;\n\nvec2 collision_getCoords(vec4 position) {\n  vec4 collision_clipspace = project_common_position_to_clipspace(position);\n  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\n\nfloat collision_match(vec2 tex, vec3 pickingColor) {\n  vec4 collision_pickingColor = texture2D(collision_texture, tex);\n  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\n  float e = 0.001;\n  return step(delta, e);\n}\n\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\n  if (!collision_enabled) {\n    return 1.0;\n  }\n\n  // Visibility test, sample area of 5x5 pixels in order to fade in/out.\n  // Due to the locality, the lookups will be cached\n  // This reduces the flicker present when objects are shown/hidden\n  const int N = 2;\n  float accumulator = 0.0;\n  vec2 step = vec2(1.0 / project_uViewportSize);\n\n  const float floatN = float(N);\n  vec2 delta = -floatN * step;\n  for(int i = -N; i <= N; i++) {\n    delta.x = -step.x * floatN;\n    for(int j = -N; j <= N; j++) {\n      accumulator += collision_match(texCoords + delta, pickingColor);\n      delta.x += step.x;\n    }\n    delta.y += step.y;\n  }\n\n  float W = 2.0 * floatN + 1.0;\n  return pow(accumulator / (W * W), 2.2);\n}\n";
    inject4 = {
      "vs:#decl": "\n  float collision_fade = 1.0;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  if (collision_sort) {\n    #ifdef NON_INSTANCED_MODEL\n    float collisionPriority = collisionPriorities;\n    #else\n    float collisionPriority = instanceCollisionPriorities;\n    #endif\n    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000\n  }\n\n  if (collision_enabled) {\n    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n    vec2 collision_texCoords = collision_getCoords(collision_common_position);\n    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\n    if (collision_fade < 0.0001) {\n      // Position outside clip space bounds to discard\n      position = vec4(0.0, 0.0, 2.0, 1.0);\n    }\n  }\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n  color.a *= collision_fade;\n  "
    };
    getCollisionUniforms = (opts, uniforms) => {
      if (!opts || !("dummyCollisionMap" in opts)) {
        return {};
      }
      const {
        collisionFBO,
        drawToCollisionMap,
        dummyCollisionMap
      } = opts;
      return {
        collision_sort: Boolean(drawToCollisionMap),
        collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO : dummyCollisionMap
      };
    };
    shader_module_default2 = {
      name: "collision",
      dependencies: [project_default],
      vs: vs4,
      inject: inject4,
      getUniforms: getCollisionUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-pass.js
var CollisionFilterPass;
var init_collision_filter_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-pass.js"() {
    init_esm11();
    init_esm13();
    CollisionFilterPass = class extends LayersPass {
      renderCollisionMap(target, options) {
        const gl = this.gl;
        const padding = 1;
        return withParameters(gl, {
          scissorTest: true,
          scissor: [padding, padding, target.width - 2 * padding, target.height - 2 * padding],
          clearColor: [0, 0, 0, 0],
          blend: false,
          depthTest: true,
          depthRange: [0, 1]
        }, () => this.render({
          ...options,
          target,
          pass: "collision"
        }));
      }
      getModuleParameters() {
        return {
          drawToCollisionMap: true,
          pickingActive: 1,
          pickingAttribute: false,
          lightSources: {}
        };
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-pass.js
var MaskPass;
var init_mask_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-pass.js"() {
    init_defineProperty();
    init_esm11();
    init_esm13();
    MaskPass = class extends LayersPass {
      constructor(gl, props) {
        super(gl, props);
        _defineProperty(this, "maskMap", void 0);
        _defineProperty(this, "fbo", void 0);
        const {
          mapSize = 2048
        } = props;
        this.maskMap = new Texture2D(gl, {
          width: mapSize,
          height: mapSize,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.fbo = new Framebuffer(gl, {
          id: "maskmap",
          width: mapSize,
          height: mapSize,
          attachments: {
            [36064]: this.maskMap
          }
        });
      }
      render(options) {
        const gl = this.gl;
        const colorMask = [false, false, false, false];
        colorMask[options.channel] = true;
        return withParameters(gl, {
          clearColor: [255, 255, 255, 255],
          blend: true,
          blendFunc: [0, 1],
          blendEquation: 32778,
          colorMask,
          depthTest: false
        }, () => super.render({
          ...options,
          target: this.fbo,
          pass: "mask"
        }));
      }
      shouldDrawLayer(layer) {
        return layer.props.operation.includes("mask");
      }
      delete() {
        this.fbo.delete();
        this.maskMap.delete();
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js
function joinLayerBounds(layers, viewport) {
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (const layer of layers) {
    const layerBounds = layer.getBounds();
    if (layerBounds) {
      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {
        viewport,
        autoOffset: false
      });
      const topRightCommon = layer.projectPosition(layerBounds[1], {
        viewport,
        autoOffset: false
      });
      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
      bounds[2] = Math.max(bounds[2], topRightCommon[0]);
      bounds[3] = Math.max(bounds[3], topRightCommon[1]);
    }
  }
  if (Number.isFinite(bounds[0])) {
    return bounds;
  }
  return null;
}
function makeViewport(opts) {
  const {
    bounds,
    viewport,
    border = 0
  } = opts;
  const {
    isGeospatial
  } = viewport;
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }
  const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);
  let {
    width,
    height,
    zoom
  } = opts;
  if (zoom === void 0) {
    width = width - border * 2;
    height = height - border * 2;
    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    zoom = Math.min(Math.log2(scale), 20);
  } else if (!width || !height) {
    const scale = 2 ** zoom;
    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);
    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);
    const maxSize = MAX_VIEWPORT_SIZE - border * 2;
    if (width > maxSize || height > maxSize) {
      const r2 = maxSize / Math.max(width, height);
      width = Math.round(width * r2);
      height = Math.round(height * r2);
      zoom += Math.log2(r2);
    }
  }
  return isGeospatial ? new WebMercatorViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    longitude: centerWorld[0],
    latitude: centerWorld[1],
    zoom,
    orthographic: true
  }) : new OrthographicViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    target: centerWorld,
    zoom,
    flipY: false
  });
}
function getViewportBounds(viewport, zRange) {
  let viewportBoundsWorld;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({
      z: minZ
    });
    const bounds1 = viewport.getBounds({
      z: maxZ
    });
    viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  } else {
    viewportBoundsWorld = viewport.getBounds();
  }
  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
  return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];
}
function getRenderBounds(layerBounds, viewport, zRange) {
  if (!layerBounds) {
    return [0, 0, 1, 1];
  }
  const viewportBounds = getViewportBounds(viewport, zRange);
  const paddedBounds = doubleBounds(viewportBounds);
  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
    return layerBounds;
  }
  return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];
}
function doubleBounds(bounds) {
  const dx = bounds[2] - bounds[0];
  const dy = bounds[3] - bounds[1];
  const centerX = (bounds[0] + bounds[2]) / 2;
  const centerY = (bounds[1] + bounds[3]) / 2;
  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
}
var MAX_VIEWPORT_SIZE;
var init_projection_utils = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js"() {
    init_esm13();
    MAX_VIEWPORT_SIZE = 2048;
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js
var MaskEffect;
var init_mask_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    init_esm8();
    init_mask_pass();
    init_projection_utils();
    MaskEffect = class {
      constructor() {
        _defineProperty(this, "id", "mask-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "order", 0);
        _defineProperty(this, "dummyMaskMap", void 0);
        _defineProperty(this, "channels", []);
        _defineProperty(this, "masks", null);
        _defineProperty(this, "maskPass", void 0);
        _defineProperty(this, "maskMap", void 0);
        _defineProperty(this, "lastViewport", void 0);
      }
      preRender(gl, {
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        isPicking
      }) {
        let didRender = false;
        if (!this.dummyMaskMap) {
          this.dummyMaskMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        if (isPicking) {
          return {
            didRender
          };
        }
        const maskLayers = layers.filter((l2) => l2.props.visible && l2.props.operation.includes("mask"));
        if (maskLayers.length === 0) {
          this.masks = null;
          this.channels.length = 0;
          return {
            didRender
          };
        }
        this.masks = {};
        if (!this.maskPass) {
          this.maskPass = new MaskPass(gl, {
            id: "default-mask"
          });
          this.maskMap = this.maskPass.maskMap;
        }
        const channelMap = this._sortMaskChannels(maskLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
        if (viewport.resolution !== void 0) {
          log_default.warn("MaskExtension is not supported in GlobeView")();
          return {
            didRender
          };
        }
        for (const maskId in channelMap) {
          const result = this._renderChannel(channelMap[maskId], {
            layerFilter,
            onViewportActive,
            views,
            viewport,
            viewportChanged
          });
          didRender || (didRender = result);
        }
        return {
          didRender
        };
      }
      _renderChannel(channelInfo, {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      }) {
        let didRender = false;
        const oldChannelInfo = this.channels[channelInfo.index];
        if (!oldChannelInfo) {
          return didRender;
        }
        const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i3) => layer !== oldChannelInfo.layers[i3] || layer.props.transitions) || channelInfo.layerBounds.some((b, i3) => b !== oldChannelInfo.layerBounds[i3]);
        channelInfo.bounds = oldChannelInfo.bounds;
        channelInfo.maskBounds = oldChannelInfo.maskBounds;
        this.channels[channelInfo.index] = channelInfo;
        if (maskChanged || viewportChanged) {
          this.lastViewport = viewport;
          const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
          channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
          if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
            const {
              maskPass,
              maskMap
            } = this;
            const maskViewport = layerBounds && makeViewport({
              bounds: channelInfo.bounds,
              viewport,
              width: maskMap.width,
              height: maskMap.height,
              border: 1
            });
            channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
            maskPass.render({
              pass: "mask",
              channel: channelInfo.index,
              layers: channelInfo.layers,
              layerFilter,
              viewports: maskViewport ? [maskViewport] : [],
              onViewportActive,
              views,
              moduleParameters: {
                devicePixelRatio: 1
              }
            });
            didRender = true;
          }
        }
        this.masks[channelInfo.id] = {
          index: channelInfo.index,
          bounds: channelInfo.maskBounds,
          coordinateOrigin: channelInfo.coordinateOrigin,
          coordinateSystem: channelInfo.coordinateSystem
        };
        return didRender;
      }
      _sortMaskChannels(maskLayers) {
        const channelMap = {};
        let channelCount = 0;
        for (const layer of maskLayers) {
          const {
            id
          } = layer.root;
          let channelInfo = channelMap[id];
          if (!channelInfo) {
            if (++channelCount > 4) {
              log_default.warn("Too many mask layers. The max supported is 4")();
              continue;
            }
            channelInfo = {
              id,
              index: this.channels.findIndex((c2) => (c2 === null || c2 === void 0 ? void 0 : c2.id) === id),
              layers: [],
              layerBounds: [],
              coordinateOrigin: layer.root.props.coordinateOrigin,
              coordinateSystem: layer.root.props.coordinateSystem
            };
            channelMap[id] = channelInfo;
          }
          channelInfo.layers.push(layer);
          channelInfo.layerBounds.push(layer.getBounds());
        }
        for (let i3 = 0; i3 < 4; i3++) {
          const channelInfo = this.channels[i3];
          if (!channelInfo || !(channelInfo.id in channelMap)) {
            this.channels[i3] = null;
          }
        }
        for (const maskId in channelMap) {
          const channelInfo = channelMap[maskId];
          if (channelInfo.index < 0) {
            channelInfo.index = this.channels.findIndex((c2) => !c2);
            this.channels[channelInfo.index] = channelInfo;
          }
        }
        return channelMap;
      }
      getModuleParameters() {
        return {
          maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
          maskChannels: this.masks
        };
      }
      cleanup() {
        if (this.dummyMaskMap) {
          this.dummyMaskMap.delete();
          this.dummyMaskMap = void 0;
        }
        if (this.maskPass) {
          this.maskPass.delete();
          this.maskPass = void 0;
          this.maskMap = void 0;
        }
        this.lastViewport = void 0;
        this.masks = null;
        this.channels.length = 0;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-effect.js
var DOWNSCALE, CollisionFilterEffect;
var init_collision_filter_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-effect.js"() {
    init_defineProperty();
    init_esm11();
    init_esm8();
    init_esm13();
    init_collision_filter_pass();
    init_mask_effect();
    DOWNSCALE = 2;
    CollisionFilterEffect = class {
      constructor() {
        _defineProperty(this, "id", "collision-filter-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "order", 1);
        _defineProperty(this, "channels", {});
        _defineProperty(this, "collisionFilterPass", void 0);
        _defineProperty(this, "collisionFBOs", {});
        _defineProperty(this, "dummyCollisionMap", void 0);
        _defineProperty(this, "lastViewport", void 0);
      }
      preRender(gl, {
        effects: allEffects,
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        isPicking,
        preRenderStats = {}
      }) {
        var _preRenderStats$mask;
        if (!this.dummyCollisionMap) {
          this.dummyCollisionMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        if (isPicking) {
          return;
        }
        const collisionLayers = layers.filter(({
          props: {
            visible,
            collisionEnabled
          }
        }) => visible && collisionEnabled);
        if (collisionLayers.length === 0) {
          this.channels = {};
          return;
        }
        if (!this.collisionFilterPass) {
          this.collisionFilterPass = new CollisionFilterPass(gl, {
            id: "default-collision-filter"
          });
        }
        const effects = allEffects === null || allEffects === void 0 ? void 0 : allEffects.filter((e2) => e2.constructor === MaskEffect);
        const maskEffectRendered = (_preRenderStats$mask = preRenderStats["mask-effect"]) === null || _preRenderStats$mask === void 0 ? void 0 : _preRenderStats$mask.didRender;
        const channels = this._groupByCollisionGroup(gl, collisionLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
        for (const collisionGroup in channels) {
          const collisionFBO = this.collisionFBOs[collisionGroup];
          const renderInfo = channels[collisionGroup];
          collisionFBO.resize({
            width: gl.canvas.width / DOWNSCALE,
            height: gl.canvas.height / DOWNSCALE
          });
          this._render(renderInfo, {
            effects,
            layerFilter,
            onViewportActive,
            views,
            viewport,
            viewportChanged
          });
        }
      }
      _render(renderInfo, {
        effects,
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      }) {
        const {
          collisionGroup
        } = renderInfo;
        const oldRenderInfo = this.channels[collisionGroup];
        if (!oldRenderInfo) {
          return;
        }
        const needsRender = viewportChanged || renderInfo === oldRenderInfo || !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || renderInfo.layerBounds.some((b, i3) => !equals(b, oldRenderInfo.layerBounds[i3])) || renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || renderInfo.layers.some((layer) => layer.props.transitions);
        this.channels[collisionGroup] = renderInfo;
        if (needsRender) {
          this.lastViewport = viewport;
          const collisionFBO = this.collisionFBOs[collisionGroup];
          this.collisionFilterPass.renderCollisionMap(collisionFBO, {
            pass: "collision-filter",
            isPicking: true,
            layers: renderInfo.layers,
            effects,
            layerFilter,
            viewports: viewport ? [viewport] : [],
            onViewportActive,
            views,
            moduleParameters: {
              dummyCollisionMap: this.dummyCollisionMap,
              devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE
            }
          });
        }
      }
      _groupByCollisionGroup(gl, collisionLayers) {
        const channelMap = {};
        for (const layer of collisionLayers) {
          const {
            collisionGroup
          } = layer.props;
          let channelInfo = channelMap[collisionGroup];
          if (!channelInfo) {
            channelInfo = {
              collisionGroup,
              layers: [],
              layerBounds: [],
              allLayersLoaded: true
            };
            channelMap[collisionGroup] = channelInfo;
          }
          channelInfo.layers.push(layer);
          channelInfo.layerBounds.push(layer.getBounds());
          if (!layer.isLoaded) {
            channelInfo.allLayersLoaded = false;
          }
        }
        for (const collisionGroup of Object.keys(channelMap)) {
          if (!this.collisionFBOs[collisionGroup]) {
            this.createFBO(gl, collisionGroup);
          }
          if (!this.channels[collisionGroup]) {
            this.channels[collisionGroup] = channelMap[collisionGroup];
          }
        }
        for (const collisionGroup of Object.keys(this.collisionFBOs)) {
          if (!channelMap[collisionGroup]) {
            this.destroyFBO(collisionGroup);
          }
        }
        return channelMap;
      }
      getModuleParameters(layer) {
        const {
          collisionGroup
        } = layer.props;
        const {
          collisionFBOs,
          dummyCollisionMap
        } = this;
        return {
          collisionFBO: collisionFBOs[collisionGroup],
          dummyCollisionMap
        };
      }
      cleanup() {
        if (this.dummyCollisionMap) {
          this.dummyCollisionMap.delete();
          this.dummyCollisionMap = void 0;
        }
        this.channels = {};
        for (const collisionGroup of Object.keys(this.collisionFBOs)) {
          this.destroyFBO(collisionGroup);
        }
        this.collisionFBOs = {};
        this.lastViewport = void 0;
      }
      createFBO(gl, collisionGroup) {
        const {
          width,
          height
        } = gl.canvas;
        const collisionMap = new Texture2D(gl, {
          width,
          height,
          parameters: {
            [10241]: 9728,
            [10240]: 9728,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        const depthBuffer = new Renderbuffer(gl, {
          format: 33189,
          width,
          height
        });
        this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {
          id: "Collision-".concat(collisionGroup),
          width,
          height,
          attachments: {
            [36064]: collisionMap,
            [36096]: depthBuffer
          }
        });
      }
      destroyFBO(collisionGroup) {
        const fbo = this.collisionFBOs[collisionGroup];
        for (const attachment of Object.values(fbo.attachments)) {
          attachment.delete();
        }
        fbo.delete();
        delete this.collisionFBOs[collisionGroup];
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-extension.js
var defaultProps35, CollisionFilterExtension;
var init_collision_filter_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_shader_module3();
    init_collision_filter_effect();
    defaultProps35 = {
      getCollisionPriority: {
        type: "accessor",
        value: 0
      },
      collisionEnabled: true,
      collisionGroup: {
        type: "string",
        value: "default"
      },
      collisionTestProps: {}
    };
    CollisionFilterExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [shader_module_default2]
        };
      }
      draw({
        uniforms,
        context,
        moduleParameters
      }) {
        const {
          collisionEnabled
        } = this.props;
        const {
          collisionFBO,
          drawToCollisionMap
        } = moduleParameters;
        const enabled = collisionEnabled && Boolean(collisionFBO);
        uniforms.collision_enabled = enabled;
        if (drawToCollisionMap) {
          this.props = this.clone(this.props.collisionTestProps).props;
        }
      }
      initializeState(context, extension) {
        var _this$context$deck;
        if (this.getAttributeManager() === null) {
          return;
        }
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new CollisionFilterEffect());
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
          collisionPriorities: {
            size: 1,
            accessor: "getCollisionPriority",
            shaderAttributes: {
              collisionPriorities: {
                divisor: 0
              },
              instanceCollisionPriorities: {
                divisor: 1
              }
            }
          }
        });
      }
      getNeedsPickingBuffer() {
        return this.props.collisionEnabled;
      }
    };
    _defineProperty(CollisionFilterExtension, "defaultProps", defaultProps35);
    _defineProperty(CollisionFilterExtension, "extensionName", "CollisionFilterExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/shader-module.js
var vs5, fs4, inject5, getMaskUniforms, shader_module_default3;
var init_shader_module4 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/shader-module.js"() {
    init_esm13();
    vs5 = "\nuniform vec4 mask_bounds;\nuniform bool mask_maskByInstance;\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);\n}\n";
    fs4 = "\nuniform sampler2D mask_texture;\nuniform int mask_channel;\nuniform bool mask_enabled;\nuniform bool mask_inverted;\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask_enabled) {\n    return true;\n  }\n  vec4 maskColor = texture2D(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask_channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask_channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask_channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask_channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask_inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n";
    inject5 = {
      "vs:#decl": "\nvarying vec2 mask_texCoords;\n",
      "vs:#main-end": "\n   vec4 mask_common_position;\n   if (mask_maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n",
      "fs:#decl": "\nvarying vec2 mask_texCoords;\n",
      "fs:#main-start": "\n  if (mask_enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // gl_FragColor = vec4(mask_texCoords, 0.0, 1.0);\n    gl_FragColor = texture2D(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n"
    };
    getMaskUniforms = (opts) => {
      if (opts && "maskMap" in opts) {
        return {
          mask_texture: opts.maskMap
        };
      }
      return {};
    };
    shader_module_default3 = {
      name: "mask",
      dependencies: [project_default],
      vs: vs5,
      fs: fs4,
      inject: inject5,
      getUniforms: getMaskUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-extension.js
var defaultProps36, MaskExtension;
var init_mask_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_shader_module4();
    init_mask_effect();
    defaultProps36 = {
      maskId: "",
      maskByInstance: void 0,
      maskInverted: false
    };
    MaskExtension = class extends LayerExtension {
      initializeState() {
        var _this$context$deck;
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new MaskEffect());
      }
      getShaders() {
        let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
        if (this.props.maskByInstance !== void 0) {
          maskByInstance = Boolean(this.props.maskByInstance);
        }
        this.state.maskByInstance = maskByInstance;
        return {
          modules: [shader_module_default3]
        };
      }
      draw({
        uniforms,
        context,
        moduleParameters
      }) {
        uniforms.mask_maskByInstance = this.state.maskByInstance;
        const {
          maskId,
          maskInverted
        } = this.props;
        const {
          maskChannels
        } = moduleParameters;
        const {
          viewport
        } = context;
        if (maskChannels && maskChannels[maskId]) {
          const {
            index,
            bounds,
            coordinateOrigin: fromCoordinateOrigin
          } = maskChannels[maskId];
          let {
            coordinateSystem: fromCoordinateSystem
          } = maskChannels[maskId];
          uniforms.mask_enabled = true;
          uniforms.mask_channel = index;
          uniforms.mask_inverted = maskInverted;
          if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
            fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
          }
          const opts = {
            modelMatrix: null,
            fromCoordinateOrigin,
            fromCoordinateSystem
          };
          const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
          const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
          uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];
        } else {
          if (maskId) {
            log_default.warn("Could not find a mask layer with id: ".concat(maskId))();
          }
          uniforms.mask_enabled = false;
        }
      }
    };
    _defineProperty(MaskExtension, "defaultProps", defaultProps36);
    _defineProperty(MaskExtension, "extensionName", "MaskExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/shader-module.js
var TERRAIN_MODE, TERRAIN_MODE_CONSTANTS, terrainModule;
var init_shader_module5 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/shader-module.js"() {
    init_esm13();
    TERRAIN_MODE = {
      NONE: 0,
      WRITE_HEIGHT_MAP: 1,
      USE_HEIGHT_MAP: 2,
      USE_COVER: 3,
      USE_COVER_ONLY: 4,
      SKIP: 5
    };
    TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => "const float TERRAIN_MODE_".concat(key, " = ").concat(TERRAIN_MODE[key], ".0;")).join("\n");
    terrainModule = {
      name: "terrain",
      dependencies: [project_default],
      inject: {
        "vs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
        "vs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n",
        "vs:DECKGL_FILTER_GL_POSITION": "\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture2D(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    ",
        "fs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
        "fs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    ",
        "fs:DECKGL_FILTER_COLOR": "\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  vec4 pixel = texture2D(terrain_map, texCoords);\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    "
      },
      getUniforms: (opts = {}, uniforms) => {
        if ("dummyHeightMap" in opts) {
          const {
            drawToTerrainHeightMap,
            heightMap,
            heightMapBounds,
            dummyHeightMap,
            terrainCover,
            useTerrainHeightMap,
            terrainSkipRender
          } = opts;
          const {
            project_uCommonOrigin
          } = uniforms;
          let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
          let sampler = dummyHeightMap;
          let bounds = null;
          if (drawToTerrainHeightMap) {
            mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
            bounds = heightMapBounds;
          } else if (useTerrainHeightMap && heightMap) {
            mode = TERRAIN_MODE.USE_HEIGHT_MAP;
            sampler = heightMap;
            bounds = heightMapBounds;
          } else if (terrainCover) {
            const isPicking = opts.pickingActive;
            sampler = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
            if (isPicking) {
              mode = TERRAIN_MODE.SKIP;
            }
            if (sampler) {
              mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
              bounds = terrainCover.bounds;
            } else {
              sampler = dummyHeightMap;
            }
          }
          return {
            terrain_mode: mode,
            terrain_map: sampler,
            terrain_bounds: bounds ? [bounds[0] - project_uCommonOrigin[0], bounds[1] - project_uCommonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]
          };
        }
        return null;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/utils.js
function createRenderTarget(gl, opts) {
  return new Framebuffer(gl, {
    id: opts.id,
    attachments: {
      [36064]: new Texture2D(gl, {
        ...opts.float && {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126
        },
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      })
    }
  });
}
var init_utils6 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/utils.js"() {
    init_esm11();
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-cover.js
function getIntersectingLayers(sourceTile, layers) {
  return layers.filter((layer) => {
    const tile = getTile(layer);
    if (tile) {
      return intersect2(sourceTile.boundingBox, tile.boundingBox);
    }
    return true;
  });
}
function getTile(layer) {
  while (layer) {
    const {
      tile
    } = layer.props;
    if (tile) {
      return tile;
    }
    layer = layer.parent;
  }
  return null;
}
function intersect2(b1, b2) {
  if (b1 && b2) {
    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
  }
  return false;
}
var TerrainCover;
var init_terrain_cover = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-cover.js"() {
    init_defineProperty();
    init_utils6();
    init_projection_utils();
    TerrainCover = class {
      constructor(targetLayer) {
        _defineProperty(this, "isDirty", true);
        _defineProperty(this, "targetLayer", void 0);
        _defineProperty(this, "renderViewport", null);
        _defineProperty(this, "bounds", null);
        _defineProperty(this, "fbo", void 0);
        _defineProperty(this, "pickingFbo", void 0);
        _defineProperty(this, "layers", []);
        _defineProperty(this, "tile", void 0);
        _defineProperty(this, "targetBounds", null);
        _defineProperty(this, "targetBoundsCommon", null);
        this.targetLayer = targetLayer;
        this.tile = getTile(targetLayer);
      }
      get id() {
        return this.targetLayer.id;
      }
      get isActive() {
        return Boolean(this.targetLayer.getCurrentLayer());
      }
      shouldUpdate({
        targetLayer,
        viewport,
        layers,
        layerNeedsRedraw
      }) {
        if (targetLayer) {
          this.targetLayer = targetLayer;
        }
        const sizeChanged = viewport ? this._updateViewport(viewport) : false;
        let layersChanged = layers ? this._updateLayers(layers) : false;
        if (layerNeedsRedraw) {
          for (const id of this.layers) {
            if (layerNeedsRedraw[id]) {
              layersChanged = true;
              break;
            }
          }
        }
        return layersChanged || sizeChanged;
      }
      _updateLayers(layers) {
        let needsRedraw = false;
        layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
        if (layers.length !== this.layers.length) {
          needsRedraw = true;
        } else {
          for (let i3 = 0; i3 < layers.length; i3++) {
            const id = layers[i3].id;
            if (id !== this.layers[i3]) {
              needsRedraw = true;
              break;
            }
          }
        }
        if (needsRedraw) {
          this.layers = layers.map((layer) => layer.id);
        }
        return needsRedraw;
      }
      _updateViewport(viewport) {
        const targetLayer = this.targetLayer;
        let shouldRedraw = false;
        if (this.tile && "boundingBox" in this.tile) {
          if (!this.targetBounds) {
            shouldRedraw = true;
            this.targetBounds = this.tile.boundingBox;
            const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
            const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
            this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];
          }
        } else if (this.targetBounds !== targetLayer.getBounds()) {
          shouldRedraw = true;
          this.targetBounds = targetLayer.getBounds();
          this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
        }
        if (!this.targetBoundsCommon) {
          return false;
        }
        const newZoom = Math.ceil(viewport.zoom + 0.5);
        if (this.tile) {
          this.bounds = this.targetBoundsCommon;
        } else {
          var _this$renderViewport;
          const oldZoom = (_this$renderViewport = this.renderViewport) === null || _this$renderViewport === void 0 ? void 0 : _this$renderViewport.zoom;
          shouldRedraw = shouldRedraw || newZoom !== oldZoom;
          const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
          const oldBounds = this.bounds;
          shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x2, i3) => x2 !== oldBounds[i3]);
          this.bounds = newBounds;
        }
        if (shouldRedraw) {
          this.renderViewport = makeViewport({
            bounds: this.bounds,
            zoom: newZoom,
            viewport
          });
        }
        return shouldRedraw;
      }
      getRenderFramebuffer() {
        if (!this.renderViewport || this.layers.length === 0) {
          return null;
        }
        if (!this.fbo) {
          this.fbo = createRenderTarget(this.targetLayer.context.gl, {
            id: this.id
          });
        }
        return this.fbo;
      }
      getPickingFramebuffer() {
        if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
          return null;
        }
        if (!this.pickingFbo) {
          this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {
            id: "".concat(this.id, "-picking")
          });
        }
        return this.pickingFbo;
      }
      filterLayers(layers) {
        return layers.filter(({
          id
        }) => this.layers.includes(id));
      }
      delete() {
        const {
          fbo,
          pickingFbo
        } = this;
        if (fbo) {
          fbo.texture.delete();
          fbo.delete();
        }
        if (pickingFbo) {
          pickingFbo.texture.delete();
          pickingFbo.delete();
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-pass.js
var TerrainPass;
var init_terrain_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-pass.js"() {
    init_esm11();
    init_esm13();
    TerrainPass = class extends LayersPass {
      getRenderableLayers(viewport, opts) {
        const {
          layers
        } = opts;
        const result = [];
        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
        for (let i3 = 0; i3 < layers.length; i3++) {
          const layer = layers[i3];
          if (!layer.isComposite && drawParamsByIndex[i3].shouldDrawLayer) {
            result.push(layer);
          }
        }
        return result;
      }
      renderHeightMap(heightMap, opts) {
        const target = heightMap.getRenderFramebuffer();
        const viewport = heightMap.renderViewport;
        if (!target || !viewport) {
          return;
        }
        target.resize(viewport);
        withParameters(this.gl, {
          clearColor: [0, 0, 0, 0],
          blend: true,
          blendFunc: [1, 1],
          blendEquation: 32776,
          depthTest: false
        }, () => this.render({
          ...opts,
          target,
          pass: "terrain-height-map",
          layers: opts.layers,
          viewports: [viewport],
          effects: []
        }));
      }
      renderTerrainCover(terrainCover, opts) {
        const target = terrainCover.getRenderFramebuffer();
        const viewport = terrainCover.renderViewport;
        if (!target || !viewport) {
          return;
        }
        const layers = terrainCover.filterLayers(opts.layers);
        target.resize(viewport);
        withParameters(this.gl, {
          depthTest: false
        }, () => this.render({
          ...opts,
          target,
          pass: "terrain-cover-".concat(terrainCover.id),
          layers,
          effects: [],
          viewports: [viewport]
        }));
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-picking-pass.js
var TerrainPickingPass;
var init_terrain_picking_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-picking-pass.js"() {
    init_defineProperty();
    init_esm13();
    init_esm11();
    TerrainPickingPass = class extends PickLayersPass {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "drawParameters", {});
      }
      getRenderableLayers(viewport, opts) {
        const {
          layers
        } = opts;
        const result = [];
        this.drawParameters = {};
        this._resetColorEncoder(opts.pickZ);
        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
        for (let i3 = 0; i3 < layers.length; i3++) {
          const layer = layers[i3];
          if (!layer.isComposite && drawParamsByIndex[i3].shouldDrawLayer) {
            result.push(layer);
            this.drawParameters[layer.id] = drawParamsByIndex[i3].layerParameters;
          }
        }
        return result;
      }
      renderTerrainCover(terrainCover, opts) {
        const target = terrainCover.getPickingFramebuffer();
        const viewport = terrainCover.renderViewport;
        if (!target || !viewport) {
          return;
        }
        const layers = terrainCover.filterLayers(opts.layers);
        const terrainLayer = terrainCover.targetLayer;
        if (terrainLayer.props.pickable) {
          layers.unshift(terrainLayer);
        }
        target.resize(viewport);
        withParameters(this.gl, {
          depthTest: false
        }, () => this.render({
          ...opts,
          pickingFBO: target,
          pass: "terrain-cover-picking-".concat(terrainCover.id),
          layers,
          effects: [],
          viewports: [viewport],
          cullRect: void 0,
          deviceRect: viewport,
          pickZ: false
        }));
      }
      getLayerParameters(layer, layerIndex, viewport) {
        if (this.drawParameters[layer.id]) {
          return this.drawParameters[layer.id];
        }
        const parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
        parameters2.blend = true;
        return parameters2;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/height-map-builder.js
var MAP_MAX_SIZE, HeightMapBuilder;
var init_height_map_builder = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/height-map-builder.js"() {
    init_defineProperty();
    init_esm11();
    init_projection_utils();
    init_utils6();
    MAP_MAX_SIZE = 2048;
    HeightMapBuilder = class {
      static isSupported(gl) {
        return Framebuffer.isSupported(gl, {
          colorBufferFloat: true
        });
      }
      constructor(gl) {
        _defineProperty(this, "renderViewport", null);
        _defineProperty(this, "bounds", null);
        _defineProperty(this, "fbo", void 0);
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "layers", []);
        _defineProperty(this, "layersBounds", []);
        _defineProperty(this, "layersBoundsCommon", null);
        _defineProperty(this, "lastViewport", null);
        this.gl = gl;
      }
      getRenderFramebuffer() {
        if (!this.renderViewport) {
          return null;
        }
        if (!this.fbo) {
          this.fbo = createRenderTarget(this.gl, {
            id: "height-map",
            float: true
          });
        }
        return this.fbo;
      }
      shouldUpdate({
        layers,
        viewport
      }) {
        const layersChanged = layers.length !== this.layers.length || layers.some((layer, i3) => layer !== this.layers[i3] || layer.props.transitions || layer.getBounds() !== this.layersBounds[i3]);
        if (layersChanged) {
          this.layers = layers;
          this.layersBounds = layers.map((layer) => layer.getBounds());
          this.layersBoundsCommon = joinLayerBounds(layers, viewport);
        }
        const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
        if (!this.layersBoundsCommon) {
          this.renderViewport = null;
        } else if (layersChanged || viewportChanged) {
          const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
          if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
            this.renderViewport = null;
            return false;
          }
          this.bounds = bounds;
          this.lastViewport = viewport;
          const scale = viewport.scale;
          const pixelWidth = (bounds[2] - bounds[0]) * scale;
          const pixelHeight = (bounds[3] - bounds[1]) * scale;
          this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
            bounds: [viewport.center[0] - 1, viewport.center[1] - 1, viewport.center[0] + 1, viewport.center[1] + 1],
            zoom: viewport.zoom,
            width: Math.min(pixelWidth, MAP_MAX_SIZE),
            height: Math.min(pixelHeight, MAP_MAX_SIZE),
            viewport
          }) : null;
          return true;
        }
        return false;
      }
      delete() {
        if (this.fbo) {
          this.fbo.color.delete();
          this.fbo.delete();
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-effect.js
var TerrainEffect;
var init_terrain_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-effect.js"() {
    init_defineProperty();
    init_esm11();
    init_esm13();
    init_shader_module5();
    init_terrain_cover();
    init_terrain_pass();
    init_terrain_picking_pass();
    init_height_map_builder();
    TerrainEffect = class {
      constructor() {
        _defineProperty(this, "id", "terrain-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "isPicking", false);
        _defineProperty(this, "isDrapingEnabled", false);
        _defineProperty(this, "dummyHeightMap", void 0);
        _defineProperty(this, "heightMap", void 0);
        _defineProperty(this, "terrainPass", void 0);
        _defineProperty(this, "terrainPickingPass", void 0);
        _defineProperty(this, "terrainCovers", /* @__PURE__ */ new Map());
      }
      initialize(gl) {
        this.dummyHeightMap = new Texture2D(gl, {
          width: 1,
          height: 1,
          data: new Uint8Array([0, 0, 0, 0])
        });
        this.terrainPass = new TerrainPass(gl, {
          id: "terrain"
        });
        this.terrainPickingPass = new TerrainPickingPass(gl, {
          id: "terrain-picking"
        });
        if (HeightMapBuilder.isSupported(gl)) {
          this.heightMap = new HeightMapBuilder(gl);
        } else {
          log_default.warn("Terrain offset mode is not supported by this browser")();
        }
        ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);
      }
      preRender(gl, opts) {
        if (!this.dummyHeightMap) {
          this.initialize(gl);
          for (const layer of opts.layers) {
            if (layer.props.operation.includes("terrain")) {
              layer.setChangeFlags({
                extensionsChanged: true
              });
            }
          }
        }
        if (opts.pickZ) {
          this.isDrapingEnabled = false;
          return;
        }
        const {
          viewports,
          isPicking = false
        } = opts;
        this.isPicking = isPicking;
        this.isDrapingEnabled = true;
        const viewport = viewports[0];
        const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
        const terrainLayers = layers.filter((l2) => l2.props.operation.includes("terrain"));
        if (terrainLayers.length === 0) {
          return;
        }
        if (!isPicking) {
          const offsetLayers = layers.filter((l2) => l2.state.terrainDrawMode === "offset");
          if (offsetLayers.length > 0) {
            this._updateHeightMap(terrainLayers, viewport, opts);
          }
        }
        const drapeLayers = layers.filter((l2) => l2.state.terrainDrawMode === "drape");
        this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
      }
      getModuleParameters(layer) {
        var _this$heightMap, _this$heightMap2;
        const {
          terrainDrawMode
        } = layer.state;
        return {
          heightMap: (_this$heightMap = this.heightMap) === null || _this$heightMap === void 0 ? void 0 : _this$heightMap.getRenderFramebuffer(),
          heightMapBounds: (_this$heightMap2 = this.heightMap) === null || _this$heightMap2 === void 0 ? void 0 : _this$heightMap2.bounds,
          dummyHeightMap: this.dummyHeightMap,
          terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
          useTerrainHeightMap: terrainDrawMode === "offset",
          terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
        };
      }
      cleanup() {
        if (this.dummyHeightMap) {
          this.dummyHeightMap.delete();
          this.dummyHeightMap = void 0;
        }
        if (this.heightMap) {
          this.heightMap.delete();
          this.heightMap = void 0;
        }
        for (const terrainCover of this.terrainCovers.values()) {
          terrainCover.delete();
        }
        this.terrainCovers.clear();
      }
      _updateHeightMap(terrainLayers, viewport, opts) {
        if (!this.heightMap) {
          return;
        }
        const shouldUpdate = this.heightMap.shouldUpdate({
          layers: terrainLayers,
          viewport
        });
        if (!shouldUpdate) {
          return;
        }
        this.terrainPass.renderHeightMap(this.heightMap, {
          ...opts,
          layers: terrainLayers,
          moduleParameters: {
            heightMapBounds: this.heightMap.bounds,
            dummyHeightMap: this.dummyHeightMap,
            devicePixelRatio: 1,
            drawToTerrainHeightMap: true
          }
        });
      }
      _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
        const layerNeedsRedraw = {};
        for (const layer of drapeLayers) {
          if (layer.state.terrainCoverNeedsRedraw) {
            layerNeedsRedraw[layer.id] = true;
            layer.state.terrainCoverNeedsRedraw = false;
          }
        }
        for (const terrainCover of this.terrainCovers.values()) {
          terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({
            layerNeedsRedraw
          });
        }
        for (const layer of terrainLayers) {
          this._updateTerrainCover(layer, drapeLayers, viewport, opts);
        }
        if (!this.isPicking) {
          this._pruneTerrainCovers();
        }
      }
      _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
        const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
        let terrainCover = this.terrainCovers.get(terrainLayer.id);
        if (!terrainCover) {
          terrainCover = new TerrainCover(terrainLayer);
          this.terrainCovers.set(terrainLayer.id, terrainCover);
        }
        try {
          const isDirty = terrainCover.shouldUpdate({
            targetLayer: terrainLayer,
            viewport,
            layers: drapeLayers
          });
          if (this.isPicking || terrainCover.isDirty || isDirty) {
            renderPass.renderTerrainCover(terrainCover, {
              ...opts,
              layers: drapeLayers,
              moduleParameters: {
                dummyHeightMap: this.dummyHeightMap,
                terrainSkipRender: false,
                devicePixelRatio: 1
              }
            });
            terrainCover.isDirty = false;
          }
        } catch (err) {
          terrainLayer.raiseError(err, "Error rendering terrain cover ".concat(terrainCover.id));
        }
      }
      _pruneTerrainCovers() {
        const idsToRemove = [];
        for (const [id, terrainCover] of this.terrainCovers) {
          if (!terrainCover.isActive) {
            idsToRemove.push(id);
          }
        }
        for (const id of idsToRemove) {
          this.terrainCovers.delete(id);
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js
var defaultProps37, TerrainExtension;
var init_terrain_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js"() {
    init_defineProperty();
    init_esm13();
    init_terrain_effect();
    init_shader_module5();
    defaultProps37 = {
      terrainDrawMode: void 0
    };
    TerrainExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [terrainModule]
        };
      }
      initializeState() {
        var _this$context$deck;
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new TerrainEffect());
      }
      updateState(params) {
        const {
          props,
          oldProps
        } = params;
        if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && props.extruded === oldProps.extruded) {
          return;
        }
        let {
          terrainDrawMode
        } = props;
        if (!terrainDrawMode) {
          var _this$getAttributeMan;
          const is3d = this.props.extruded;
          const attributes = (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.attributes;
          const hasAnchor = attributes && "instancePositions" in attributes;
          terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
        }
        this.setState({
          terrainDrawMode
        });
      }
      onNeedsRedraw() {
        const state = this.state;
        if (state.terrainDrawMode === "drape") {
          state.terrainCoverNeedsRedraw = true;
        }
      }
    };
    _defineProperty(TerrainExtension, "defaultProps", defaultProps37);
    _defineProperty(TerrainExtension, "extensionName", "TerrainExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/index.js
var init_esm30 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/index.js"() {
    init_brushing_extension();
    init_data_filter_extension();
    init_fp64_extension();
    init_path_style_extension();
    init_fill_style_extension();
    init_clip_extension();
    init_collision_filter_extension();
    init_mask_extension();
    init_terrain_extension();
    init_project64();
  }
});

// node_modules/@loaders.gl/gis/dist/esm/lib/flat-geojson-to-binary.js
function flatGeojsonToBinary(features, geometryInfo, options) {
  const propArrayTypes = extractNumericPropTypes(features);
  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
  return fillArrays(features, {
    propArrayTypes,
    ...geometryInfo
  }, {
    numericPropKeys: options && options.numericPropKeys || numericPropKeys,
    PositionDataType: options ? options.PositionDataType : Float32Array
  });
}
function extractNumericPropTypes(features) {
  const propArrayTypes = {};
  for (const feature of features) {
    if (feature.properties) {
      for (const key in feature.properties) {
        const val2 = feature.properties[key];
        propArrayTypes[key] = deduceArrayType(val2, propArrayTypes[key]);
      }
    }
  }
  return propArrayTypes;
}
function fillArrays(features, geometryInfo, options) {
  const {
    pointPositionsCount,
    pointFeaturesCount,
    linePositionsCount,
    linePathsCount,
    lineFeaturesCount,
    polygonPositionsCount,
    polygonObjectsCount,
    polygonRingsCount,
    polygonFeaturesCount,
    propArrayTypes,
    coordLength
  } = geometryInfo;
  const {
    numericPropKeys = [],
    PositionDataType = Float32Array
  } = options;
  const hasGlobalId = features[0] && "id" in features[0];
  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    type: "Point",
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const lines = {
    type: "LineString",
    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const polygons = {
    type: "Polygon",
    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    triangles: [],
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      const T = propArrayTypes[propName];
      object.numericProps[propName] = new T(object.positions.length / coordLength);
    }
  }
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };
  for (const feature of features) {
    const geometry = feature.geometry;
    const properties = feature.properties || {};
    switch (geometry.type) {
      case "Point":
        handlePoint(geometry, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          points.fields.push({
            id: feature.id
          });
        }
        indexMap.pointFeature++;
        break;
      case "LineString":
        handleLineString(geometry, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          lines.fields.push({
            id: feature.id
          });
        }
        indexMap.lineFeature++;
        break;
      case "Polygon":
        handlePolygon(geometry, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          polygons.fields.push({
            id: feature.id
          });
        }
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error("Invalid geometry type");
    }
    indexMap.feature++;
  }
  return makeAccessorObjects(points, lines, polygons, coordLength);
}
function handlePoint(geometry, points, indexMap, coordLength, properties) {
  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  indexMap.pointPosition += nPositions;
}
function handleLineString(geometry, lines, indexMap, coordLength, properties) {
  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
  for (let i3 = 0, il = geometry.indices.length; i3 < il; ++i3) {
    const start = geometry.indices[i3];
    const end = i3 === il - 1 ? geometry.data.length : geometry.indices[i3 + 1];
    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
    indexMap.linePosition += (end - start) / coordLength;
  }
}
function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  for (let l2 = 0, ll = geometry.indices.length; l2 < ll; ++l2) {
    const startPosition = indexMap.polygonPosition;
    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
    const areas = geometry.areas[l2];
    const indices = geometry.indices[l2];
    const nextIndices = geometry.indices[l2 + 1];
    for (let i3 = 0, il = indices.length; i3 < il; ++i3) {
      const start = indices[i3];
      const end = i3 === il - 1 ? nextIndices === void 0 ? geometry.data.length : nextIndices[0] : indices[i3 + 1];
      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
      indexMap.polygonPosition += (end - start) / coordLength;
    }
    const endPosition = indexMap.polygonPosition;
    triangulatePolygon(polygons, areas, indices, {
      startPosition,
      endPosition,
      coordLength
    });
  }
}
function triangulatePolygon(polygons, areas, indices, _ref) {
  let {
    startPosition,
    endPosition,
    coordLength
  } = _ref;
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.subarray(start, end);
  const offset = indices[0];
  const holes = indices.slice(1).map((n2) => (n2 - offset) / coordLength);
  const triangles = earcut(polygonPositions, holes, coordLength, areas);
  for (let t2 = 0, tl = triangles.length; t2 < tl; ++t2) {
    polygons.triangles.push(startPosition + triangles[t2]);
  }
}
function wrapProps(obj, size) {
  const returnObj = {};
  for (const key in obj) {
    returnObj[key] = {
      value: obj[key],
      size
    };
  }
  return returnObj;
}
function makeAccessorObjects(points, lines, polygons, coordLength) {
  return {
    points: {
      ...points,
      positions: {
        value: points.positions,
        size: coordLength
      },
      globalFeatureIds: {
        value: points.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: points.featureIds,
        size: 1
      },
      numericProps: wrapProps(points.numericProps, 1)
    },
    lines: {
      ...lines,
      positions: {
        value: lines.positions,
        size: coordLength
      },
      pathIndices: {
        value: lines.pathIndices,
        size: 1
      },
      globalFeatureIds: {
        value: lines.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: lines.featureIds,
        size: 1
      },
      numericProps: wrapProps(lines.numericProps, 1)
    },
    polygons: {
      ...polygons,
      positions: {
        value: polygons.positions,
        size: coordLength
      },
      polygonIndices: {
        value: polygons.polygonIndices,
        size: 1
      },
      primitivePolygonIndices: {
        value: polygons.primitivePolygonIndices,
        size: 1
      },
      triangles: {
        value: new Uint32Array(polygons.triangles),
        size: 1
      },
      globalFeatureIds: {
        value: polygons.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: polygons.featureIds,
        size: 1
      },
      numericProps: wrapProps(polygons.numericProps, 1)
    }
  };
}
function fillNumericProperties(object, properties, index, length3) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      const value = properties[numericPropName];
      object.numericProps[numericPropName].fill(value, index, index + length3);
    }
  }
}
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}
function deduceArrayType(x2, constructor) {
  if (constructor === Array || !Number.isFinite(x2)) {
    return Array;
  }
  return constructor === Float64Array || Math.fround(x2) !== x2 ? Float64Array : Float32Array;
}
var init_flat_geojson_to_binary = __esm({
  "node_modules/@loaders.gl/gis/dist/esm/lib/flat-geojson-to-binary.js"() {
    init_esm14();
  }
});

// node_modules/@loaders.gl/gis/dist/esm/lib/extract-geometry-info.js
var init_extract_geometry_info = __esm({
  "node_modules/@loaders.gl/gis/dist/esm/lib/extract-geometry-info.js"() {
  }
});

// node_modules/@loaders.gl/gis/dist/esm/lib/geojson-to-flat-geojson.js
var init_geojson_to_flat_geojson = __esm({
  "node_modules/@loaders.gl/gis/dist/esm/lib/geojson-to-flat-geojson.js"() {
    init_esm14();
  }
});

// node_modules/@loaders.gl/gis/dist/esm/lib/geojson-to-binary.js
var init_geojson_to_binary = __esm({
  "node_modules/@loaders.gl/gis/dist/esm/lib/geojson-to-binary.js"() {
    init_extract_geometry_info();
    init_geojson_to_flat_geojson();
    init_flat_geojson_to_binary();
  }
});

// node_modules/@loaders.gl/gis/dist/esm/lib/binary-to-geojson.js
function binaryToGeojson(data, options) {
  const globalFeatureId = options === null || options === void 0 ? void 0 : options.globalFeatureId;
  if (globalFeatureId !== void 0) {
    return getSingleFeature(data, globalFeatureId);
  }
  return parseFeatures(data, options === null || options === void 0 ? void 0 : options.type);
}
function getSingleFeature(data, globalFeatureId) {
  const dataArray = normalizeInput(data);
  for (const data2 of dataArray) {
    let lastIndex = 0;
    let lastValue = data2.featureIds.value[0];
    for (let i3 = 0; i3 < data2.featureIds.value.length; i3++) {
      const currValue = data2.featureIds.value[i3];
      if (currValue === lastValue) {
        continue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, i3);
      }
      lastIndex = i3;
      lastValue = currValue;
    }
    if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
      return parseFeature(data2, lastIndex, data2.featureIds.value.length);
    }
  }
  throw new Error("featureId:".concat(globalFeatureId, " not found"));
}
function parseFeatures(data, type) {
  const dataArray = normalizeInput(data, type);
  return parseFeatureCollection(dataArray);
}
function binaryToGeometry(data, startIndex, endIndex) {
  switch (data.type) {
    case "Point":
      return pointToGeoJson(data, startIndex, endIndex);
    case "LineString":
      return lineStringToGeoJson(data, startIndex, endIndex);
    case "Polygon":
      return polygonToGeoJson(data, startIndex, endIndex);
    default:
      const unexpectedInput = data;
      throw new Error("Unsupported geometry type: ".concat(unexpectedInput === null || unexpectedInput === void 0 ? void 0 : unexpectedInput.type));
  }
}
function normalizeInput(data, type) {
  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);
  if (!isHeterogeneousType) {
    data.type = type || parseType(data);
    return [data];
  }
  const features = [];
  if (data.points) {
    data.points.type = "Point";
    features.push(data.points);
  }
  if (data.lines) {
    data.lines.type = "LineString";
    features.push(data.lines);
  }
  if (data.polygons) {
    data.polygons.type = "Polygon";
    features.push(data.polygons);
  }
  return features;
}
function parseFeatureCollection(dataArray) {
  const features = [];
  for (const data of dataArray) {
    if (data.featureIds.value.length === 0) {
      continue;
    }
    let lastIndex = 0;
    let lastValue = data.featureIds.value[0];
    for (let i3 = 0; i3 < data.featureIds.value.length; i3++) {
      const currValue = data.featureIds.value[i3];
      if (currValue === lastValue) {
        continue;
      }
      features.push(parseFeature(data, lastIndex, i3));
      lastIndex = i3;
      lastValue = currValue;
    }
    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
  }
  return features;
}
function parseFeature(data, startIndex, endIndex) {
  const geometry = binaryToGeometry(data, startIndex, endIndex);
  const properties = parseProperties(data, startIndex, endIndex);
  const fields = parseFields(data, startIndex, endIndex);
  return {
    type: "Feature",
    geometry,
    properties,
    ...fields
  };
}
function parseFields(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let endIndex = arguments.length > 2 ? arguments[2] : void 0;
  return data.fields && data.fields[data.featureIds.value[startIndex]];
}
function parseProperties(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let endIndex = arguments.length > 2 ? arguments[2] : void 0;
  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
  for (const key in data.numericProps) {
    properties[key] = data.numericProps[key].value[startIndex];
  }
  return properties;
}
function polygonToGeoJson(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
  let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
  const {
    positions
  } = data;
  const polygonIndices = data.polygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const multi = polygonIndices.length > 2;
  if (!multi) {
    const coordinates2 = [];
    for (let i3 = 0; i3 < primitivePolygonIndices.length - 1; i3++) {
      const startRingIndex = primitivePolygonIndices[i3];
      const endRingIndex = primitivePolygonIndices[i3 + 1];
      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
      coordinates2.push(ringCoordinates);
    }
    return {
      type: "Polygon",
      coordinates: coordinates2
    };
  }
  const coordinates = [];
  for (let i3 = 0; i3 < polygonIndices.length - 1; i3++) {
    const startPolygonIndex = polygonIndices[i3];
    const endPolygonIndex = polygonIndices[i3 + 1];
    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
    coordinates.push(polygonCoordinates);
  }
  return {
    type: "MultiPolygon",
    coordinates
  };
}
function lineStringToGeoJson(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
  let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
  const {
    positions
  } = data;
  const pathIndices = data.pathIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const multi = pathIndices.length > 2;
  if (!multi) {
    const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
    return {
      type: "LineString",
      coordinates: coordinates2
    };
  }
  const coordinates = [];
  for (let i3 = 0; i3 < pathIndices.length - 1; i3++) {
    const ringCoordinates = ringToGeoJson(positions, pathIndices[i3], pathIndices[i3 + 1]);
    coordinates.push(ringCoordinates);
  }
  return {
    type: "MultiLineString",
    coordinates
  };
}
function pointToGeoJson(data, startIndex, endIndex) {
  const {
    positions
  } = data;
  const coordinates = ringToGeoJson(positions, startIndex, endIndex);
  const multi = coordinates.length > 1;
  if (multi) {
    return {
      type: "MultiPoint",
      coordinates
    };
  }
  return {
    type: "Point",
    coordinates: coordinates[0]
  };
}
function ringToGeoJson(positions, startIndex, endIndex) {
  startIndex = startIndex || 0;
  endIndex = endIndex || positions.value.length / positions.size;
  const ringCoordinates = [];
  for (let j = startIndex; j < endIndex; j++) {
    const coord = Array();
    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
      coord.push(Number(positions.value[k]));
    }
    ringCoordinates.push(coord);
  }
  return ringCoordinates;
}
function parseType(data) {
  if (data.pathIndices) {
    return "LineString";
  }
  if (data.polygonIndices) {
    return "Polygon";
  }
  return "Point";
}
var init_binary_to_geojson = __esm({
  "node_modules/@loaders.gl/gis/dist/esm/lib/binary-to-geojson.js"() {
  }
});

// node_modules/@loaders.gl/gis/dist/esm/lib/transform.js
var init_transform = __esm({
  "node_modules/@loaders.gl/gis/dist/esm/lib/transform.js"() {
  }
});

// node_modules/@loaders.gl/gis/dist/esm/index.js
var init_esm31 = __esm({
  "node_modules/@loaders.gl/gis/dist/esm/index.js"() {
    init_flat_geojson_to_binary();
    init_geojson_to_binary();
    init_geojson_to_flat_geojson();
    init_binary_to_geojson();
    init_transform();
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i3 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s2 = buffer[offset + i3];
      i3 += d;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i3 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i3] = m & 255, i3 += d, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i3] = e2 & 255, i3 += d, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i3 - d] |= s2 * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val2 = this.readVarint(), tag = val2 >> 3, startPos = this.pos;
          this.type = val2 & 7;
          readField(tag, result, this);
          if (this.pos === startPos)
            this.skip(val2);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val2 = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      readSFixed32: function() {
        var val2 = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readSFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readFloat: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val2;
      },
      readDouble: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val2;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val2, b;
        b = buf[this.pos++];
        val2 = b & 127;
        if (b < 128)
          return val2;
        b = buf[this.pos++];
        val2 |= (b & 127) << 7;
        if (b < 128)
          return val2;
        b = buf[this.pos++];
        val2 |= (b & 127) << 14;
        if (b < 128)
          return val2;
        b = buf[this.pos++];
        val2 |= (b & 127) << 21;
        if (b < 128)
          return val2;
        b = buf[this.pos];
        val2 |= (b & 15) << 28;
        return readVarintRemainder(val2, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val2) {
        var type = val2 & 7;
        if (type === Pbf.Varint)
          while (this.buf[this.pos++] > 127) {
          }
        else if (type === Pbf.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32)
          this.pos += 4;
        else if (type === Pbf.Fixed64)
          this.pos += 8;
        else
          throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min) {
        var length3 = this.length || 16;
        while (length3 < this.pos + min)
          length3 *= 2;
        if (length3 !== this.length) {
          var buf = new Uint8Array(length3);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length3;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val2) {
        val2 = +val2 || 0;
        if (val2 > 268435455 || val2 < 0) {
          writeBigVarint(val2, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val2 & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = val2 >>> 7 & 127;
      },
      writeSVarint: function(val2) {
        this.writeVarint(val2 < 0 ? -val2 * 2 - 1 : val2 * 2);
      },
      writeBoolean: function(val2) {
        this.writeVarint(Boolean(val2));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val2) {
        this.realloc(4);
        ieee754.write(this.buf, val2, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val2) {
        this.realloc(8);
        ieee754.write(this.buf, val2, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i3 = 0; i3 < len; i3++)
          this.buf[this.pos++] = buffer[i3];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val2);
      },
      writeSFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val2);
      },
      writeFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val2);
      },
      writeSFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val2);
      },
      writeVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val2);
      },
      writeSVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val2);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val2);
      },
      writeDoubleField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val2);
      },
      writeBooleanField: function(tag, val2) {
        this.writeVarintField(tag, Boolean(val2));
      }
    };
    function readVarintRemainder(l2, s2, p2) {
      var buf = p2.buf, h, b;
      b = buf[p2.pos++];
      h = (b & 112) >> 4;
      if (b < 128)
        return toNum(l2, h, s2);
      b = buf[p2.pos++];
      h |= (b & 127) << 3;
      if (b < 128)
        return toNum(l2, h, s2);
      b = buf[p2.pos++];
      h |= (b & 127) << 10;
      if (b < 128)
        return toNum(l2, h, s2);
      b = buf[p2.pos++];
      h |= (b & 127) << 17;
      if (b < 128)
        return toNum(l2, h, s2);
      b = buf[p2.pos++];
      h |= (b & 127) << 24;
      if (b < 128)
        return toNum(l2, h, s2);
      b = buf[p2.pos++];
      h |= (b & 1) << 31;
      if (b < 128)
        return toNum(l2, h, s2);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val2, pbf) {
      var low, high;
      if (val2 >= 0) {
        low = val2 % 4294967296 | 0;
        high = val2 / 4294967296 | 0;
      } else {
        low = ~(-val2 % 4294967296);
        high = ~(-val2 / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val2 >= 18446744073709552e3 || val2 < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i3 = pbf.pos - 1; i3 >= startPos; i3--)
        pbf.buf[i3 + extraLen] = pbf.buf[i3];
    }
    function writePackedVarint(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeVarint(arr[i3]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeSVarint(arr[i3]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeFloat(arr[i3]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeDouble(arr[i3]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeBoolean(arr[i3]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeFixed32(arr[i3]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeSFixed32(arr[i3]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeFixed64(arr[i3]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeSFixed64(arr[i3]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val2, pos) {
      buf[pos] = val2;
      buf[pos + 1] = val2 >>> 8;
      buf[pos + 2] = val2 >>> 16;
      buf[pos + 3] = val2 >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i3 = pos;
      while (i3 < end) {
        var b0 = buf[i3];
        var c2 = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i3 + bytesPerSequence > end)
          break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c2 = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i3 + 1];
          if ((b1 & 192) === 128) {
            c2 = (b0 & 31) << 6 | b1 & 63;
            if (c2 <= 127) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i3 + 1];
          b2 = buf[i3 + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i3 + 1];
          b2 = buf[i3 + 2];
          b3 = buf[i3 + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c2 <= 65535 || c2 >= 1114112) {
              c2 = null;
            }
          }
        }
        if (c2 === null) {
          c2 = 65533;
          bytesPerSequence = 1;
        } else if (c2 > 65535) {
          c2 -= 65536;
          str += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
          c2 = 56320 | c2 & 1023;
        }
        str += String.fromCharCode(c2);
        i3 += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i3 = 0, c2, lead; i3 < str.length; i3++) {
        c2 = str.charCodeAt(i3);
        if (c2 > 55295 && c2 < 57344) {
          if (lead) {
            if (c2 < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c2;
              continue;
            } else {
              c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c2 > 56319 || i3 + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c2;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c2 < 128) {
          buf[pos++] = c2;
        } else {
          if (c2 < 2048) {
            buf[pos++] = c2 >> 6 | 192;
          } else {
            if (c2 < 65536) {
              buf[pos++] = c2 >> 12 | 224;
            } else {
              buf[pos++] = c2 >> 18 | 240;
              buf[pos++] = c2 >> 12 & 63 | 128;
            }
            buf[pos++] = c2 >> 6 & 63 | 128;
          }
          buf[pos++] = c2 & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/helpers/mapbox-util-functions.js
function classifyRings(rings) {
  const len = rings.length;
  if (len <= 1)
    return [rings];
  const polygons = [];
  let polygon;
  let ccw;
  for (let i3 = 0; i3 < len; i3++) {
    const area2 = signedArea(rings[i3]);
    if (area2 === 0)
      continue;
    if (ccw === void 0)
      ccw = area2 < 0;
    if (ccw === area2 < 0) {
      if (polygon)
        polygons.push(polygon);
      polygon = [rings[i3]];
    } else if (polygon)
      polygon.push(rings[i3]);
  }
  if (polygon)
    polygons.push(polygon);
  return polygons;
}
function signedArea(ring) {
  let sum = 0;
  for (let i3 = 0, j = ring.length - 1, p1, p2; i3 < ring.length; j = i3++) {
    p1 = ring[i3];
    p2 = ring[j];
    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
  }
  return sum;
}
function readFeature(tag, feature, pbf) {
  if (feature && pbf) {
    if (tag === 1)
      feature.id = pbf.readVarint();
    else if (tag === 2)
      readTag(pbf, feature);
    else if (tag === 3)
      feature.type = pbf.readVarint();
    else if (tag === 4)
      feature._geometry = pbf.pos;
  }
}
function readTag(pbf, feature) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature._keys[pbf.readVarint()];
    const value = feature._values[pbf.readVarint()];
    feature.properties[key] = value;
  }
}
var init_mapbox_util_functions = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/helpers/mapbox-util-functions.js"() {
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-feature.js
var VectorTileFeature;
var init_vector_tile_feature = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-feature.js"() {
    init_defineProperty();
    init_mapbox_util_functions();
    VectorTileFeature = class {
      static get types() {
        return ["Unknown", "Point", "LineString", "Polygon"];
      }
      constructor(pbf, end, extent, keys, values) {
        _defineProperty(this, "properties", void 0);
        _defineProperty(this, "extent", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "_pbf", void 0);
        _defineProperty(this, "_geometry", void 0);
        _defineProperty(this, "_keys", void 0);
        _defineProperty(this, "_values", void 0);
        this.properties = {};
        this.extent = extent;
        this.type = 0;
        this.id = null;
        this._pbf = pbf;
        this._geometry = -1;
        this._keys = keys;
        this._values = values;
        pbf.readFields(readFeature, this, end);
      }
      loadGeometry() {
        const pbf = this._pbf;
        pbf.pos = this._geometry;
        const end = pbf.readVarint() + pbf.pos;
        let cmd2 = 1;
        let length3 = 0;
        let x2 = 0;
        let y2 = 0;
        const lines = [];
        let line;
        while (pbf.pos < end) {
          if (length3 <= 0) {
            const cmdLen2 = pbf.readVarint();
            cmd2 = cmdLen2 & 7;
            length3 = cmdLen2 >> 3;
          }
          length3--;
          if (cmd2 === 1 || cmd2 === 2) {
            x2 += pbf.readSVarint();
            y2 += pbf.readSVarint();
            if (cmd2 === 1) {
              if (line)
                lines.push(line);
              line = [];
            }
            if (line)
              line.push([x2, y2]);
          } else if (cmd2 === 7) {
            if (line) {
              line.push(line[0].slice());
            }
          } else {
            throw new Error("unknown command ".concat(cmd2));
          }
        }
        if (line)
          lines.push(line);
        return lines;
      }
      bbox() {
        const pbf = this._pbf;
        pbf.pos = this._geometry;
        const end = pbf.readVarint() + pbf.pos;
        let cmd2 = 1;
        let length3 = 0;
        let x2 = 0;
        let y2 = 0;
        let x1 = Infinity;
        let x22 = -Infinity;
        let y1 = Infinity;
        let y22 = -Infinity;
        while (pbf.pos < end) {
          if (length3 <= 0) {
            const cmdLen2 = pbf.readVarint();
            cmd2 = cmdLen2 & 7;
            length3 = cmdLen2 >> 3;
          }
          length3--;
          if (cmd2 === 1 || cmd2 === 2) {
            x2 += pbf.readSVarint();
            y2 += pbf.readSVarint();
            if (x2 < x1)
              x1 = x2;
            if (x2 > x22)
              x22 = x2;
            if (y2 < y1)
              y1 = y2;
            if (y2 > y22)
              y22 = y2;
          } else if (cmd2 !== 7) {
            throw new Error("unknown command ".concat(cmd2));
          }
        }
        return [x1, y1, x22, y22];
      }
      _toGeoJSON(transform2) {
        let coords = this.loadGeometry();
        let type = VectorTileFeature.types[this.type];
        let i3;
        let j;
        switch (this.type) {
          case 1:
            const points = [];
            for (i3 = 0; i3 < coords.length; i3++) {
              points[i3] = coords[i3][0];
            }
            coords = points;
            transform2(coords, this);
            break;
          case 2:
            for (i3 = 0; i3 < coords.length; i3++) {
              transform2(coords[i3], this);
            }
            break;
          case 3:
            coords = classifyRings(coords);
            for (i3 = 0; i3 < coords.length; i3++) {
              for (j = 0; j < coords[i3].length; j++) {
                transform2(coords[i3][j], this);
              }
            }
            break;
        }
        if (coords.length === 1) {
          coords = coords[0];
        } else {
          type = "Multi".concat(type);
        }
        const result = {
          type: "Feature",
          geometry: {
            type,
            coordinates: coords
          },
          properties: this.properties
        };
        if (this.id !== null) {
          result.id = this.id;
        }
        return result;
      }
      toGeoJSON(options) {
        if (typeof options === "function") {
          return this._toGeoJSON(options);
        }
        const {
          x: x2,
          y: y2,
          z
        } = options;
        const size = this.extent * Math.pow(2, z);
        const x0 = this.extent * x2;
        const y0 = this.extent * y2;
        function project2(line) {
          for (let j = 0; j < line.length; j++) {
            const p2 = line[j];
            p2[0] = (p2[0] + x0) * 360 / size - 180;
            const y22 = 180 - (p2[1] + y0) * 360 / size;
            p2[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
          }
        }
        return this._toGeoJSON(project2);
      }
    };
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-layer.js
function readLayer(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage(pbf));
  }
}
function readValueMessage(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}
var VectorTileLayer;
var init_vector_tile_layer = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-layer.js"() {
    init_defineProperty();
    init_vector_tile_feature();
    VectorTileLayer = class {
      constructor(pbf, end) {
        _defineProperty(this, "version", void 0);
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "extent", void 0);
        _defineProperty(this, "length", void 0);
        _defineProperty(this, "_pbf", void 0);
        _defineProperty(this, "_keys", void 0);
        _defineProperty(this, "_values", void 0);
        _defineProperty(this, "_features", void 0);
        this.version = 1;
        this.name = "";
        this.extent = 4096;
        this.length = 0;
        this._pbf = pbf;
        this._keys = [];
        this._values = [];
        this._features = [];
        pbf.readFields(readLayer, this, end);
        this.length = this._features.length;
      }
      feature(i3) {
        if (i3 < 0 || i3 >= this._features.length) {
          throw new Error("feature index out of bounds");
        }
        this._pbf.pos = this._features[i3];
        const end = this._pbf.readVarint() + this._pbf.pos;
        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
      }
    };
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile.js
function readTile(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}
var VectorTile;
var init_vector_tile = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile.js"() {
    init_defineProperty();
    init_vector_tile_layer();
    VectorTile = class {
      constructor(pbf, end) {
        _defineProperty(this, "layers", void 0);
        this.layers = pbf.readFields(readTile, {}, end);
      }
    };
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/helpers/binary-util-functions.js
function classifyRings2(geom) {
  const len = geom.indices.length;
  const type = "Polygon";
  if (len <= 1) {
    return {
      type,
      data: geom.data,
      areas: [[getPolygonSignedArea(geom.data)]],
      indices: [geom.indices]
    };
  }
  const areas = [];
  const polygons = [];
  let ringAreas = [];
  let polygon = [];
  let ccw;
  let offset = 0;
  for (let endIndex, i3 = 0, startIndex; i3 < len; i3++) {
    startIndex = geom.indices[i3] - offset;
    endIndex = geom.indices[i3 + 1] - offset || geom.data.length;
    const shape = geom.data.slice(startIndex, endIndex);
    const area2 = getPolygonSignedArea(shape);
    if (area2 === 0) {
      const before = geom.data.slice(0, startIndex);
      const after = geom.data.slice(endIndex);
      geom.data = before.concat(after);
      offset += endIndex - startIndex;
      continue;
    }
    if (ccw === void 0)
      ccw = area2 < 0;
    if (ccw === area2 < 0) {
      if (polygon.length) {
        areas.push(ringAreas);
        polygons.push(polygon);
      }
      polygon = [startIndex];
      ringAreas = [area2];
    } else {
      ringAreas.push(area2);
      polygon.push(startIndex);
    }
  }
  if (ringAreas)
    areas.push(ringAreas);
  if (polygon.length)
    polygons.push(polygon);
  return {
    type,
    areas,
    indices: polygons,
    data: geom.data
  };
}
function project(data, x0, y0, size) {
  for (let j = 0, jl = data.length; j < jl; j += 2) {
    data[j] = (data[j] + x0) * 360 / size - 180;
    const y2 = 180 - (data[j + 1] + y0) * 360 / size;
    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function readFeature2(tag, feature, pbf) {
  if (feature && pbf) {
    if (tag === 1)
      feature.id = pbf.readVarint();
    else if (tag === 2)
      readTag2(pbf, feature);
    else if (tag === 3)
      feature.type = pbf.readVarint();
    else if (tag === 4)
      feature._geometry = pbf.pos;
  }
}
function readTag2(pbf, feature) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature._keys[pbf.readVarint()];
    const value = feature._values[pbf.readVarint()];
    feature.properties[key] = value;
  }
}
var init_binary_util_functions = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/helpers/binary-util-functions.js"() {
    init_esm14();
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-feature.js
var endPos, cmd, cmdLen, length2, x, y, i2, VectorTileFeature2;
var init_vector_tile_feature2 = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-feature.js"() {
    init_defineProperty();
    init_binary_util_functions();
    VectorTileFeature2 = class {
      constructor(pbf, end, extent, keys, values, geometryInfo) {
        _defineProperty(this, "properties", void 0);
        _defineProperty(this, "extent", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "_pbf", void 0);
        _defineProperty(this, "_geometry", void 0);
        _defineProperty(this, "_keys", void 0);
        _defineProperty(this, "_values", void 0);
        _defineProperty(this, "_geometryInfo", void 0);
        this.properties = {};
        this.extent = extent;
        this.type = 0;
        this.id = null;
        this._pbf = pbf;
        this._geometry = -1;
        this._keys = keys;
        this._values = values;
        this._geometryInfo = geometryInfo;
        pbf.readFields(readFeature2, this, end);
      }
      loadGeometry() {
        const pbf = this._pbf;
        pbf.pos = this._geometry;
        endPos = pbf.readVarint() + pbf.pos;
        cmd = 1;
        length2 = 0;
        x = 0;
        y = 0;
        i2 = 0;
        const indices = [];
        const data = [];
        while (pbf.pos < endPos) {
          if (length2 <= 0) {
            cmdLen = pbf.readVarint();
            cmd = cmdLen & 7;
            length2 = cmdLen >> 3;
          }
          length2--;
          if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (cmd === 1) {
              indices.push(i2);
            }
            data.push(x, y);
            i2 += 2;
          } else if (cmd === 7) {
            if (i2 > 0) {
              const start = indices[indices.length - 1];
              data.push(data[start], data[start + 1]);
              i2 += 2;
            }
          } else {
            throw new Error("unknown command ".concat(cmd));
          }
        }
        return {
          data,
          indices
        };
      }
      _toBinaryCoordinates(transform2) {
        const geom = this.loadGeometry();
        let geometry;
        transform2(geom.data, this);
        const coordLength = 2;
        switch (this.type) {
          case 1:
            this._geometryInfo.pointFeaturesCount++;
            this._geometryInfo.pointPositionsCount += geom.indices.length;
            geometry = {
              type: "Point",
              ...geom
            };
            break;
          case 2:
            this._geometryInfo.lineFeaturesCount++;
            this._geometryInfo.linePathsCount += geom.indices.length;
            this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
            geometry = {
              type: "LineString",
              ...geom
            };
            break;
          case 3:
            geometry = classifyRings2(geom);
            this._geometryInfo.polygonFeaturesCount++;
            this._geometryInfo.polygonObjectsCount += geometry.indices.length;
            for (const indices of geometry.indices) {
              this._geometryInfo.polygonRingsCount += indices.length;
            }
            this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
            break;
          default:
            throw new Error("Invalid geometry type: ".concat(this.type));
        }
        const result = {
          type: "Feature",
          geometry,
          properties: this.properties
        };
        if (this.id !== null) {
          result.id = this.id;
        }
        return result;
      }
      toBinaryCoordinates(options) {
        if (typeof options === "function") {
          return this._toBinaryCoordinates(options);
        }
        const {
          x: x2,
          y: y2,
          z
        } = options;
        const size = this.extent * Math.pow(2, z);
        const x0 = this.extent * x2;
        const y0 = this.extent * y2;
        return this._toBinaryCoordinates((data) => project(data, x0, y0, size));
      }
    };
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-layer.js
function readLayer2(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage2(pbf));
  }
}
function readValueMessage2(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}
var VectorTileLayer2;
var init_vector_tile_layer2 = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-layer.js"() {
    init_defineProperty();
    init_vector_tile_feature2();
    VectorTileLayer2 = class {
      constructor(pbf, end) {
        _defineProperty(this, "version", void 0);
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "extent", void 0);
        _defineProperty(this, "length", void 0);
        _defineProperty(this, "_pbf", void 0);
        _defineProperty(this, "_keys", void 0);
        _defineProperty(this, "_values", void 0);
        _defineProperty(this, "_features", void 0);
        this.version = 1;
        this.name = "";
        this.extent = 4096;
        this.length = 0;
        this._pbf = pbf;
        this._keys = [];
        this._values = [];
        this._features = [];
        pbf.readFields(readLayer2, this, end);
        this.length = this._features.length;
      }
      feature(i3, geometryInfo) {
        if (i3 < 0 || i3 >= this._features.length) {
          throw new Error("feature index out of bounds");
        }
        this._pbf.pos = this._features[i3];
        const end = this._pbf.readVarint() + this._pbf.pos;
        return new VectorTileFeature2(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
      }
    };
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile.js
function readTile2(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer2(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}
var VectorTile2;
var init_vector_tile2 = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile.js"() {
    init_defineProperty();
    init_vector_tile_layer2();
    VectorTile2 = class {
      constructor(pbf, end) {
        _defineProperty(this, "layers", void 0);
        this.layers = pbf.readFields(readTile2, {}, end);
      }
    };
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js
function parseMVT(arrayBuffer, options) {
  var _options$gis, _options$mvt;
  const mvtOptions = normalizeOptions(options);
  const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$mvt = options.mvt) === null || _options$mvt === void 0 ? void 0 : _options$mvt.shape);
  switch (shape) {
    case "columnar-table":
      return {
        shape: "columnar-table",
        data: parseToBinary(arrayBuffer, mvtOptions)
      };
    case "geojson-row-table": {
      const table = {
        shape: "geojson-row-table",
        data: parseToGeojson(arrayBuffer, mvtOptions)
      };
      return table;
    }
    case "geojson":
      return parseToGeojson(arrayBuffer, mvtOptions);
    case "binary-geometry":
      return parseToBinary(arrayBuffer, mvtOptions);
    case "binary":
      return parseToBinary(arrayBuffer, mvtOptions);
    default:
      throw new Error(shape);
  }
}
function parseToBinary(arrayBuffer, options) {
  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
  binaryData.byteLength = arrayBuffer.byteLength;
  return binaryData;
}
function parseToFlatGeoJson(arrayBuffer, options) {
  const features = [];
  const geometryInfo = {
    coordLength: 2,
    pointPositionsCount: 0,
    pointFeaturesCount: 0,
    linePositionsCount: 0,
    linePathsCount: 0,
    lineFeaturesCount: 0,
    polygonPositionsCount: 0,
    polygonObjectsCount: 0,
    polygonRingsCount: 0,
    polygonFeaturesCount: 0
  };
  if (arrayBuffer.byteLength <= 0) {
    return [features, geometryInfo];
  }
  const tile = new VectorTile2(new import_pbf.default(arrayBuffer));
  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
      const vectorTileFeature = vectorTileLayer.feature(i3, geometryInfo);
      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return [features, geometryInfo];
}
function parseToGeojson(arrayBuffer, options) {
  if (arrayBuffer.byteLength <= 0) {
    return [];
  }
  const features = [];
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
      const vectorTileFeature = vectorTileLayer.feature(i3);
      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return features;
}
function normalizeOptions(options) {
  var _options$mvt2;
  if (!(options !== null && options !== void 0 && options.mvt)) {
    throw new Error("mvt options required");
  }
  const wgs84Coordinates = ((_options$mvt2 = options.mvt) === null || _options$mvt2 === void 0 ? void 0 : _options$mvt2.coordinates) === "wgs84";
  const {
    tileIndex
  } = options.mvt;
  const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
  if (wgs84Coordinates && !hasTileIndex) {
    throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
  }
  return options.mvt;
}
function getDecodedFeature(feature, options, layerName) {
  const decodedFeature = feature.toGeoJSON(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates);
  if (options.layerProperty) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function getDecodedFeatureBinary(feature, options, layerName) {
  const decodedFeature = feature.toBinaryCoordinates(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary);
  if (options.layerProperty && decodedFeature.properties) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function transformToLocalCoordinates(line, feature) {
  const {
    extent
  } = feature;
  for (let i3 = 0; i3 < line.length; i3++) {
    const p2 = line[i3];
    p2[0] /= extent;
    p2[1] /= extent;
  }
}
function transformToLocalCoordinatesBinary(data, feature) {
  const {
    extent
  } = feature;
  for (let i3 = 0, il = data.length; i3 < il; ++i3) {
    data[i3] /= extent;
  }
}
var import_pbf;
var init_parse_mvt = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js"() {
    init_esm31();
    import_pbf = __toESM(require_pbf());
    init_vector_tile();
    init_vector_tile2();
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/mvt-loader.js
var VERSION10, DEFAULT_MVT_LOADER_OPTIONS, MVTWorkerLoader, MVTLoader;
var init_mvt_loader = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/mvt-loader.js"() {
    init_parse_mvt();
    VERSION10 = true ? "3.3.3" : "latest";
    DEFAULT_MVT_LOADER_OPTIONS = {
      mvt: {
        shape: "geojson",
        coordinates: "local",
        layerProperty: "layerName",
        layers: void 0,
        tileIndex: null
      }
    };
    MVTWorkerLoader = {
      name: "Mapbox Vector Tile",
      id: "mvt",
      module: "mvt",
      version: VERSION10,
      extensions: ["mvt", "pbf"],
      mimeTypes: [
        "application/vnd.mapbox-vector-tile",
        "application/x-protobuf"
      ],
      worker: true,
      category: "geometry",
      options: DEFAULT_MVT_LOADER_OPTIONS
    };
    MVTLoader = {
      ...MVTWorkerLoader,
      parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
      parseSync: parseMVT,
      binary: true
    };
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/simplify.js
var init_simplify = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/simplify.js"() {
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/feature.js
var init_feature = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/feature.js"() {
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/convert.js
var init_convert = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/convert.js"() {
    init_simplify();
    init_feature();
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/clip.js
var init_clip = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/clip.js"() {
    init_defineProperty();
    init_feature();
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/wrap.js
var init_wrap = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/wrap.js"() {
    init_defineProperty();
    init_clip();
    init_feature();
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/transform.js
var init_transform2 = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/transform.js"() {
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/tile.js
var init_tile = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/tile.js"() {
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/geojson-tiler.js
var init_geojson_tiler = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/lib/geojson-tiler/geojson-tiler.js"() {
    init_defineProperty();
    init_convert();
    init_clip();
    init_wrap();
    init_transform2();
    init_tile();
  }
});

// node_modules/@loaders.gl/mvt/dist/esm/index.js
var init_esm32 = __esm({
  "node_modules/@loaders.gl/mvt/dist/esm/index.js"() {
    init_mvt_loader();
    init_geojson_tiler();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/coordinate-transform.js
function Point([pointX, pointY], [nw, se], viewport) {
  const x2 = lerp(nw[0], se[0], pointX);
  const y2 = lerp(nw[1], se[1], pointY);
  return viewport.unprojectFlat([x2, y2]);
}
function getPoints(geometry, bbox, viewport) {
  return geometry.map((g) => Point(g, bbox, viewport));
}
function MultiPoint(multiPoint, bbox, viewport) {
  return getPoints(multiPoint, bbox, viewport);
}
function LineString(line, bbox, viewport) {
  return getPoints(line, bbox, viewport);
}
function MultiLineString(multiLineString, bbox, viewport) {
  return multiLineString.map((lineString) => LineString(lineString, bbox, viewport));
}
function Polygon2(polygon, bbox, viewport) {
  return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
}
function MultiPolygon(multiPolygon, bbox, viewport) {
  return multiPolygon.map((polygon) => Polygon2(polygon, bbox, viewport));
}
function transform(geometry, bbox, viewport) {
  const nw = viewport.projectFlat([bbox.west, bbox.north]);
  const se = viewport.projectFlat([bbox.east, bbox.south]);
  const projectedBbox = [nw, se];
  return {
    ...geometry,
    coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
  };
}
var availableTransformations;
var init_coordinate_transform = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/coordinate-transform.js"() {
    init_esm8();
    availableTransformations = {
      Point,
      MultiPoint,
      LineString,
      MultiLineString,
      Polygon: Polygon2,
      MultiPolygon
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/find-index-binary.js
function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
  for (const gt of GEOM_TYPES) {
    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
    if (index >= 0) {
      return index;
    }
  }
  return -1;
}
function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
  const featureIds = geomData.featureIds.value;
  if (!featureIds.length) {
    return -1;
  }
  let startFeatureIndex = 0;
  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
  if (layerName) {
    const layerRange = getLayerRange(geomData, layerName);
    if (layerRange) {
      startFeatureIndex = layerRange[0];
      endFeatureIndex = layerRange[1] + 1;
    } else {
      return -1;
    }
  }
  let featureIndex = -1;
  if (uniqueIdProperty in geomData.numericProps) {
    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x2, i3) => x2 === featureId && featureIds[i3] >= startFeatureIndex && featureIds[i3] < endFeatureIndex);
    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
  } else if (uniqueIdProperty) {
    featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
  } else if (geomData.fields) {
    featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
  }
  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
}
function getLayerRange(geomData, layerName) {
  if (!geomData.__layers) {
    const layerNames = {};
    const {
      properties
    } = geomData;
    for (let i3 = 0; i3 < properties.length; i3++) {
      const {
        layerName: key
      } = properties[i3];
      if (!key) {
      } else if (layerNames[key]) {
        layerNames[key][1] = i3;
      } else {
        layerNames[key] = [i3, i3];
      }
    }
    geomData.__layers = layerNames;
  }
  return geomData.__layers[layerName];
}
function getGlobalFeatureId(geomData, featureIndex) {
  if (!geomData.__ids) {
    const result = [];
    const featureIds = geomData.featureIds.value;
    const globalFeatureIds = geomData.globalFeatureIds.value;
    for (let i3 = 0; i3 < featureIds.length; i3++) {
      result[featureIds[i3]] = globalFeatureIds[i3];
    }
    geomData.__ids = result;
  }
  return geomData.__ids[featureIndex];
}
function findIndex(array, predicate, startIndex, endIndex) {
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    if (predicate(array[i3], i3)) {
      return i3;
    }
  }
  return -1;
}
var GEOM_TYPES;
var init_find_index_binary = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/find-index-binary.js"() {
    GEOM_TYPES = ["points", "lines", "polygons"];
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js
function getFeatureUniqueId(feature, uniqueIdProperty) {
  if (feature.properties && uniqueIdProperty) {
    return feature.properties[uniqueIdProperty];
  }
  if ("id" in feature) {
    return feature.id;
  }
  return void 0;
}
function getFeatureLayerName(feature) {
  var _feature$properties;
  return ((_feature$properties = feature.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.layerName) || null;
}
function isFeatureIdDefined(value) {
  return value !== void 0 && value !== null && value !== "";
}
function transformTileCoordsToWGS84(object, bbox, viewport) {
  const feature = {
    ...object,
    geometry: {
      type: object.geometry.type
    }
  };
  Object.defineProperty(feature.geometry, "coordinates", {
    get: () => {
      const wgs84Geom = transform(object.geometry, bbox, viewport);
      return wgs84Geom.coordinates;
    }
  });
  return feature;
}
var WORLD_SIZE, defaultProps38, MVTLayer;
var init_mvt_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm15();
    init_esm30();
    init_esm8();
    init_esm32();
    init_esm31();
    init_coordinate_transform();
    init_find_index_binary();
    init_tile_layer();
    init_tileset_2d2();
    WORLD_SIZE = 512;
    defaultProps38 = {
      ...GeoJsonLayer.defaultProps,
      data: urlType,
      onDataLoad: {
        type: "function",
        value: null,
        optional: true,
        compare: false
      },
      uniqueIdProperty: "",
      highlightedFeatureId: null,
      loaders: [MVTWorkerLoader],
      binary: true
    };
    MVTLayer = class extends TileLayer {
      initializeState() {
        super.initializeState();
        const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
        this.setState({
          binary,
          data: null,
          tileJSON: null
        });
      }
      get isLoaded() {
        return this.state && this.state.data && this.state.tileset && super.isLoaded;
      }
      updateState({
        props,
        oldProps,
        context,
        changeFlags
      }) {
        var _this$state;
        if (changeFlags.dataChanged) {
          this._updateTileData();
        }
        if ((_this$state = this.state) !== null && _this$state !== void 0 && _this$state.data) {
          super.updateState({
            props,
            oldProps,
            context,
            changeFlags
          });
          this._setWGS84PropertyForTiles();
        }
        const {
          highlightColor
        } = props;
        if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
          this.setState({
            highlightColor
          });
        }
      }
      async _updateTileData() {
        let data = this.props.data;
        let tileJSON = null;
        if (typeof data === "string" && !isURLTemplate(data)) {
          const {
            onDataLoad,
            fetch: fetch2
          } = this.props;
          this.setState({
            data: null,
            tileJSON: null
          });
          try {
            tileJSON = await fetch2(data, {
              propName: "data",
              layer: this,
              loaders: []
            });
          } catch (error) {
            this.raiseError(error, "loading TileJSON");
            data = null;
          }
          if (onDataLoad) {
            onDataLoad(tileJSON, {
              propName: "data",
              layer: this
            });
          }
        } else if (data.tilejson) {
          tileJSON = data;
        }
        if (tileJSON) {
          data = tileJSON.tiles;
        }
        this.setState({
          data,
          tileJSON
        });
      }
      _getTilesetOptions() {
        const opts = super._getTilesetOptions();
        const tileJSON = this.state.tileJSON;
        const {
          minZoom,
          maxZoom
        } = this.props;
        if (tileJSON) {
          if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
            opts.minZoom = tileJSON.minzoom;
          }
          if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
            opts.maxZoom = tileJSON.maxzoom;
          }
        }
        return opts;
      }
      renderLayers() {
        var _this$state2;
        if (!((_this$state2 = this.state) !== null && _this$state2 !== void 0 && _this$state2.data))
          return null;
        return super.renderLayers();
      }
      getTileData(loadProps) {
        var _loadOptions;
        const {
          data,
          binary
        } = this.state;
        const {
          index,
          signal
        } = loadProps;
        const url = getURLFromTemplate(data, loadProps);
        if (!url) {
          return Promise.reject("Invalid URL");
        }
        let loadOptions = this.getLoadOptions();
        const {
          fetch: fetch2
        } = this.props;
        loadOptions = {
          ...loadOptions,
          mimeType: "application/x-protobuf",
          mvt: {
            ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.mvt,
            coordinates: this.context.viewport.resolution ? "wgs84" : "local",
            tileIndex: index
          },
          gis: binary ? {
            format: "binary"
          } : {}
        };
        return fetch2(url, {
          propName: "data",
          layer: this,
          loadOptions,
          signal
        });
      }
      renderSubLayers(props) {
        const {
          x: x2,
          y: y2,
          z
        } = props.tile.index;
        const worldScale = Math.pow(2, z);
        const xScale = WORLD_SIZE / worldScale;
        const yScale = -xScale;
        const xOffset = WORLD_SIZE * x2 / worldScale;
        const yOffset = WORLD_SIZE * (1 - y2 / worldScale);
        const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
        props.autoHighlight = false;
        if (!this.context.viewport.resolution) {
          props.modelMatrix = modelMatrix2;
          props.coordinateOrigin = [xOffset, yOffset, 0];
          props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
          props.extensions = [...props.extensions || [], new ClipExtension()];
        }
        const subLayers = super.renderSubLayers(props);
        if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {
          log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
        }
        return subLayers;
      }
      _updateAutoHighlight(info) {
        const {
          uniqueIdProperty
        } = this.props;
        const {
          hoveredFeatureId,
          hoveredFeatureLayerName
        } = this.state;
        const hoveredFeature = info.object;
        let newHoveredFeatureId;
        let newHoveredFeatureLayerName;
        if (hoveredFeature) {
          newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
          newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
        }
        let {
          highlightColor
        } = this.props;
        if (typeof highlightColor === "function") {
          highlightColor = highlightColor(info);
        }
        if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
          this.setState({
            highlightColor,
            hoveredFeatureId: newHoveredFeatureId,
            hoveredFeatureLayerName: newHoveredFeatureLayerName
          });
        }
      }
      getPickingInfo(params) {
        const info = super.getPickingInfo(params);
        const isWGS842 = Boolean(this.context.viewport.resolution);
        if (this.state.binary && info.index !== -1) {
          const {
            data
          } = params.sourceLayer.props;
          info.object = binaryToGeojson(data, {
            globalFeatureId: info.index
          });
        }
        if (info.object && !isWGS842) {
          info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);
        }
        return info;
      }
      getSubLayerPropsByTile(tile) {
        return {
          highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
          highlightColor: this.state.highlightColor
        };
      }
      getHighlightedObjectIndex(tile) {
        const {
          hoveredFeatureId,
          hoveredFeatureLayerName,
          binary
        } = this.state;
        const {
          uniqueIdProperty,
          highlightedFeatureId
        } = this.props;
        const data = tile.content;
        const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
        const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
        if (!isFeatureIdPresent) {
          return -1;
        }
        const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
        if (Array.isArray(data)) {
          return data.findIndex((feature) => {
            const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;
            const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;
            return isMatchingId && isMatchingLayer;
          });
        } else if (data && binary) {
          return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
        }
        return -1;
      }
      _pickObjects(maxObjects) {
        const {
          deck,
          viewport
        } = this.context;
        const width = viewport.width;
        const height = viewport.height;
        const x2 = viewport.x;
        const y2 = viewport.y;
        const layerIds = [this.id];
        return deck.pickObjects({
          x: x2,
          y: y2,
          width,
          height,
          layerIds,
          maxObjects
        });
      }
      getRenderedFeatures(maxFeatures = null) {
        const features = this._pickObjects(maxFeatures);
        const featureCache = /* @__PURE__ */ new Set();
        const renderedFeatures = [];
        for (const f2 of features) {
          const featureId = getFeatureUniqueId(f2.object, this.props.uniqueIdProperty);
          if (featureId === void 0) {
            renderedFeatures.push(f2.object);
          } else if (!featureCache.has(featureId)) {
            featureCache.add(featureId);
            renderedFeatures.push(f2.object);
          }
        }
        return renderedFeatures;
      }
      _setWGS84PropertyForTiles() {
        const propName = "dataInWGS84";
        const tileset = this.state.tileset;
        tileset.selectedTiles.forEach((tile) => {
          if (!tile.hasOwnProperty(propName)) {
            Object.defineProperty(tile, propName, {
              get: () => {
                if (!tile.content) {
                  return null;
                }
                if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
                  return [];
                }
                const {
                  bbox
                } = tile;
                if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
                  const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
                  tile._contentWGS84 = content.map((feature) => transformTileCoordsToWGS84(feature, bbox, this.context.viewport));
                }
                return tile._contentWGS84;
              }
            });
          }
        });
      }
    };
    _defineProperty(MVTLayer, "layerName", "MVTLayer");
    _defineProperty(MVTLayer, "defaultProps", defaultProps38);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-utils.js
function getGeohashBounds(geohash) {
  let isLon = true;
  let maxLat = MAX_LAT;
  let minLat = MIN_LAT;
  let maxLon = MAX_LON;
  let minLon = MIN_LON;
  let mid;
  let hashValue = 0;
  for (let i3 = 0, l2 = geohash.length; i3 < l2; i3++) {
    const code = geohash[i3].toLowerCase();
    hashValue = BASE32_CODES_DICT[code];
    for (let bits = 4; bits >= 0; bits--) {
      const bit = hashValue >> bits & 1;
      if (isLon) {
        mid = (maxLon + minLon) / 2;
        if (bit === 1) {
          minLon = mid;
        } else {
          maxLon = mid;
        }
      } else {
        mid = (maxLat + minLat) / 2;
        if (bit === 1) {
          minLat = mid;
        } else {
          maxLat = mid;
        }
      }
      isLon = !isLon;
    }
  }
  return [minLat, minLon, maxLat, maxLon];
}
function getGeohashPolygon(geohash) {
  const [s2, w, n2, e2] = getGeohashBounds(geohash);
  return [e2, n2, e2, s2, w, s2, w, n2, e2, n2];
}
var BASE32_CODES, BASE32_CODES_DICT, MIN_LAT, MAX_LAT, MIN_LON, MAX_LON;
var init_geohash_utils = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-utils.js"() {
    BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
    BASE32_CODES_DICT = {};
    for (let i3 = 0; i3 < BASE32_CODES.length; i3++) {
      BASE32_CODES_DICT[BASE32_CODES.charAt(i3)] = i3;
    }
    MIN_LAT = -90;
    MAX_LAT = 90;
    MIN_LON = -180;
    MAX_LON = 180;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-layer.js
var defaultProps39, GeohashLayer;
var init_geohash_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-layer.js"() {
    init_defineProperty();
    init_GeoCellLayer();
    init_geohash_utils();
    defaultProps39 = {
      getGeohash: {
        type: "accessor",
        value: (d) => d.geohash
      }
    };
    GeohashLayer = class extends GeoCellLayer {
      indexToBounds() {
        const {
          data,
          getGeohash
        } = this.props;
        return {
          data,
          _normalize: false,
          positionFormat: "XY",
          getPolygon: (x2, objectInfo) => getGeohashPolygon(getGeohash(x2, objectInfo))
        };
      }
    };
    _defineProperty(GeohashLayer, "layerName", "GeohashLayer");
    _defineProperty(GeohashLayer, "defaultProps", defaultProps39);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  GeohashLayer: () => GeohashLayer,
  GreatCircleLayer: () => GreatCircleLayer,
  H3ClusterLayer: () => H3ClusterLayer,
  H3HexagonLayer: () => H3HexagonLayer,
  MVTLayer: () => MVTLayer,
  QuadkeyLayer: () => QuadkeyLayer,
  S2Layer: () => S2Layer,
  TerrainLayer: () => TerrainLayer,
  Tile3DLayer: () => Tile3DLayer,
  TileLayer: () => TileLayer,
  TripsLayer: () => TripsLayer,
  _GeoCellLayer: () => GeoCellLayer,
  _Tile2DHeader: () => Tile2DHeader,
  _Tileset2D: () => Tileset2D,
  _WMSLayer: () => WMSLayer,
  _getURLFromTemplate: () => getURLFromTemplate
});
var init_esm33 = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/index.js"() {
    init_wms_layer();
    init_great_circle_layer();
    init_s2_layer();
    init_quadkey_layer();
    init_tile_layer();
    init_trips_layer();
    init_h3_cluster_layer();
    init_h3_hexagon_layer();
    init_tile_3d_layer();
    init_terrain_layer();
    init_mvt_layer();
    init_geohash_layer();
    init_GeoCellLayer();
    init_tileset_2d2();
    init_tileset_2d2();
    init_tileset_2d2();
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-h3-cluster-layer.js
var require_editable_h3_cluster_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-h3-cluster-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _geoLayers = (init_esm33(), __toCommonJS(esm_exports5));
    var _editModes = require_dist_es6();
    var _h3Js = (init_h3_js_es(), __toCommonJS(h3_js_es_exports));
    var _constants = require_constants();
    var _editableGeojsonLayer = _interopRequireDefault(require_editable_geojson_layer());
    var _editableLayer = _interopRequireDefault(require_editable_layer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3] != null ? arguments[i3] : {};
        if (i3 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DEFAULT_EDIT_MODE = _editModes.ViewMode;
    var DEFAULT_H3_RESOLUTION = 9;
    var EMPTY_FEATURE_COLLECTION = {
      type: "FeatureCollection",
      features: []
    };
    var defaultProps40 = _objectSpread({
      mode: DEFAULT_EDIT_MODE
    }, _editableGeojsonLayer["default"].defaultProps, {
      // h3 layer
      data: [],
      selectedIndexes: [],
      filled: false,
      stroked: true,
      lineWidthScale: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,
      lineWidthMinPixels: 1,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      lineWidthUnits: "pixels",
      getHexagons: function getHexagons(d) {
        return d.hexIds;
      },
      getEditedCluster: function getEditedCluster(updatedHexagons, existingCluster) {
        if (existingCluster) {
          return _objectSpread({}, existingCluster, {
            hexIds: updatedHexagons
          });
        }
        return {
          hexIds: updatedHexagons
        };
      },
      resolution: DEFAULT_H3_RESOLUTION
    });
    var EditableH3ClusterLayer = function(_EditableLayer) {
      _inherits(EditableH3ClusterLayer2, _EditableLayer);
      var _super = _createSuper(EditableH3ClusterLayer2);
      function EditableH3ClusterLayer2() {
        _classCallCheck(this, EditableH3ClusterLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditableH3ClusterLayer2, [{
        key: "initializeState",
        value: function initializeState() {
          _get(_getPrototypeOf(EditableH3ClusterLayer2.prototype), "initializeState", this).call(this);
          this.setState({
            tentativeHexagonIDs: []
          });
        }
        // convert array of (lng, lat) coords to cluster of hexes
      }, {
        key: "getDerivedHexagonIDs",
        value: function getDerivedHexagonIDs(coords) {
          return (0, _h3Js.polyfill)(coords, this.props.resolution, true);
        }
        // convert pair of (lng, lat) coords into single hex
      }, {
        key: "getDerivedHexagonID",
        value: function getDerivedHexagonID(coords) {
          return (0, _h3Js.geoToH3)(coords[1], coords[0], this.props.resolution);
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          var _this = this;
          var layers = [new _editableGeojsonLayer["default"](this.getSubLayerProps({
            id: "editable-geojson",
            mode: this.props.mode,
            data: EMPTY_FEATURE_COLLECTION,
            selectedFeatureIndexes: [],
            onEdit: function onEdit(editAction) {
              var editType = editAction.editType, editContext = editAction.editContext;
              switch (editType) {
                case "updateTentativeFeature":
                  if (editContext.feature.geometry.type === "Polygon") {
                    var coords = editContext.feature.geometry.coordinates;
                    var hexIDs = _this.getDerivedHexagonIDs(coords);
                    _this.setState({
                      tentativeHexagonIDs: hexIDs
                    });
                  } else if (editContext.feature.geometry.type === "Point") {
                    var _coords = editContext.feature.geometry.coordinates;
                    var hexID = _this.getDerivedHexagonID(_coords);
                    _this.setState({
                      tentativeHexagonIDs: [hexID]
                    });
                  }
                  break;
                case "addFeature":
                  var _updatedData = _toConsumableArray(_this.props.data);
                  var modeConfig = _this.props.modeConfig;
                  if (!modeConfig || !modeConfig.booleanOperation) {
                    _updatedData.push(_this.props.getEditedCluster(_this.state.tentativeHexagonIDs, null));
                  } else if (_this.props.selectedIndexes.length !== 1) {
                    console.warn("booleanOperation only supported for single cluster selection");
                  } else {
                    var finalHexagonIDs;
                    var committedHexagonIDs = new Set(_this.getSelectedHexIDs());
                    var tentativeHexagonIDs = new Set(_this.state.tentativeHexagonIDs);
                    switch (modeConfig.booleanOperation) {
                      case "union":
                      default:
                        finalHexagonIDs = _toConsumableArray(new Set([].concat(_toConsumableArray(committedHexagonIDs), _toConsumableArray(tentativeHexagonIDs))));
                        break;
                      case "intersection":
                        finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function(hexID2) {
                          return tentativeHexagonIDs.has(hexID2);
                        });
                        break;
                      case "difference":
                        finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function(hexID2) {
                          return !tentativeHexagonIDs.has(hexID2);
                        });
                        break;
                    }
                    var selectedIndex = _this.props.selectedIndexes[0];
                    var _existingCluster = _this.props.data[selectedIndex];
                    _updatedData[selectedIndex] = _this.props.getEditedCluster(finalHexagonIDs, _existingCluster);
                  }
                  _this.setState({
                    tentativeHexagonIDs: []
                  });
                  _this.props.onEdit({
                    updatedData: _updatedData
                  });
                  break;
                default:
                  break;
              }
            }
          })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({
            id: "hexagons",
            data: this.props.data,
            getHexagons: this.props.getHexagons
          })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({
            id: "tentative-hexagons",
            data: [{
              hexIds: this.state.tentativeHexagonIDs
            }],
            getHexagons: function getHexagons(d) {
              return d.hexIds;
            }
          }))];
          return layers;
        }
        // because data is an array of hexagon data, we take the cumulative of all selected indexes,
        // using props.getHexagons to support multiple data types
      }, {
        key: "getSelectedHexIDs",
        value: function getSelectedHexIDs() {
          var _this2 = this;
          var cumulativeHexIDs = [];
          this.props.selectedIndexes.forEach(function(index) {
            var selectedCluster = _this2.props.data[index];
            var hexIDs = _this2.props.getHexagons(selectedCluster);
            cumulativeHexIDs = cumulativeHexIDs.concat(hexIDs);
          });
          return cumulativeHexIDs;
        }
      }, {
        key: "getCursor",
        value: function getCursor(_ref) {
          var isDragging = _ref.isDragging;
          var _ref2 = this.state || {}, cursor = _ref2.cursor;
          if (!cursor) {
            cursor = isDragging ? "grabbing" : "grab";
          }
          return cursor;
        }
      }]);
      return EditableH3ClusterLayer2;
    }(_editableLayer["default"]);
    exports["default"] = EditableH3ClusterLayer;
    _defineProperty2(EditableH3ClusterLayer, "layerName", "EditableH3ClusterLayer");
    _defineProperty2(EditableH3ClusterLayer, "defaultProps", defaultProps40);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/selection-layer.js
var require_selection_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/selection-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.SELECTION_TYPE = void 0;
    var _core = (init_esm13(), __toCommonJS(esm_exports2));
    var _layers = (init_esm15(), __toCommonJS(esm_exports3));
    var _helpers = require_js();
    var _buffer = _interopRequireDefault(require_js6());
    var _difference = _interopRequireDefault(require_js2());
    var _editModes = require_dist_es6();
    var _editableGeojsonLayer = _interopRequireDefault(require_editable_geojson_layer());
    var _MODE_MAP;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3] != null ? arguments[i3] : {};
        if (i3 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _slicedToArray(arr, i3) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i3) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i3 && _arr.length === i3)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var SELECTION_TYPE = {
      NONE: null,
      RECTANGLE: "rectangle",
      POLYGON: "polygon"
    };
    exports.SELECTION_TYPE = SELECTION_TYPE;
    var MODE_MAP = (_MODE_MAP = {}, _defineProperty2(_MODE_MAP, SELECTION_TYPE.RECTANGLE, _editModes.DrawRectangleMode), _defineProperty2(_MODE_MAP, SELECTION_TYPE.POLYGON, _editModes.DrawPolygonMode), _MODE_MAP);
    var MODE_CONFIG_MAP = _defineProperty2({}, SELECTION_TYPE.RECTANGLE, {
      dragToDraw: true
    });
    var defaultProps40 = {
      selectionType: SELECTION_TYPE.RECTANGLE,
      layerIds: [],
      onSelect: function onSelect() {
      }
    };
    var EMPTY_DATA = {
      type: "FeatureCollection",
      features: []
    };
    var EXPANSION_KM = 50;
    var LAYER_ID_GEOJSON = "selection-geojson";
    var LAYER_ID_BLOCKER = "selection-blocker";
    var PASS_THROUGH_PROPS = ["lineWidthScale", "lineWidthMinPixels", "lineWidthMaxPixels", "lineWidthUnits", "lineJointRounded", "lineCapRounded", "lineMiterLimit", "pointRadiusScale", "pointRadiusMinPixels", "pointRadiusMaxPixels", "lineDashJustified", "getLineColor", "getFillColor", "getRadius", "getLineWidth", "getLineDashArray", "getTentativeLineDashArray", "getTentativeLineColor", "getTentativeFillColor", "getTentativeLineWidth"];
    var SelectionLayer = function(_CompositeLayer) {
      _inherits(SelectionLayer2, _CompositeLayer);
      var _super = _createSuper(SelectionLayer2);
      function SelectionLayer2() {
        _classCallCheck(this, SelectionLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(SelectionLayer2, [{
        key: "_selectRectangleObjects",
        value: function _selectRectangleObjects(coordinates) {
          var _this$props = this.props, layerIds = _this$props.layerIds, onSelect = _this$props.onSelect;
          var _this$context$viewpor = this.context.viewport.project(coordinates[0][0]), _this$context$viewpor2 = _slicedToArray(_this$context$viewpor, 2), x1 = _this$context$viewpor2[0], y1 = _this$context$viewpor2[1];
          var _this$context$viewpor3 = this.context.viewport.project(coordinates[0][2]), _this$context$viewpor4 = _slicedToArray(_this$context$viewpor3, 2), x2 = _this$context$viewpor4[0], y2 = _this$context$viewpor4[1];
          var pickingInfos = this.context.deck.pickObjects({
            x: Math.min(x1, x2),
            y: Math.min(y1, y2),
            width: Math.abs(x2 - x1),
            height: Math.abs(y2 - y1),
            layerIds
          });
          onSelect({
            pickingInfos
          });
        }
      }, {
        key: "_selectPolygonObjects",
        value: function _selectPolygonObjects(coordinates) {
          var _this = this;
          var _this$props2 = this.props, layerIds = _this$props2.layerIds, onSelect = _this$props2.onSelect;
          var mousePoints = coordinates[0].map(function(c2) {
            return _this.context.viewport.project(c2);
          });
          var allX = mousePoints.map(function(mousePoint) {
            return mousePoint[0];
          });
          var allY = mousePoints.map(function(mousePoint) {
            return mousePoint[1];
          });
          var x2 = Math.min.apply(Math, _toConsumableArray(allX));
          var y2 = Math.min.apply(Math, _toConsumableArray(allY));
          var maxX = Math.max.apply(Math, _toConsumableArray(allX));
          var maxY = Math.max.apply(Math, _toConsumableArray(allY));
          var landPointsPoly = (0, _helpers.polygon)(coordinates);
          var bigBuffer = (0, _buffer["default"])(landPointsPoly, EXPANSION_KM);
          var bigPolygon;
          try {
            bigPolygon = (0, _difference["default"])(bigBuffer, landPointsPoly);
          } catch (e2) {
            console.log("turfDifference() error", e2);
            return;
          }
          this.setState({
            pendingPolygonSelection: {
              bigPolygon
            }
          });
          var blockerId = "".concat(this.props.id, "-").concat(LAYER_ID_BLOCKER);
          setTimeout(function() {
            var pickingInfos = _this.context.deck.pickObjects({
              x: x2,
              y: y2,
              width: maxX - x2,
              height: maxY - y2,
              layerIds: [blockerId].concat(_toConsumableArray(layerIds))
            });
            onSelect({
              pickingInfos: pickingInfos.filter(function(item) {
                return item.layer.id !== _this.props.id;
              })
            });
          }, 250);
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          var _this2 = this;
          var pendingPolygonSelection = this.state.pendingPolygonSelection;
          var mode = MODE_MAP[this.props.selectionType] || _editModes.ViewMode;
          var modeConfig = MODE_CONFIG_MAP[this.props.selectionType];
          var inheritedProps = {};
          PASS_THROUGH_PROPS.forEach(function(p2) {
            if (_this2.props[p2] !== void 0)
              inheritedProps[p2] = _this2.props[p2];
          });
          var layers = [new _editableGeojsonLayer["default"](this.getSubLayerProps(_objectSpread({
            id: LAYER_ID_GEOJSON,
            pickable: true,
            mode,
            modeConfig,
            selectedFeatureIndexes: [],
            data: EMPTY_DATA,
            onEdit: function onEdit(_ref) {
              var updatedData = _ref.updatedData, editType = _ref.editType;
              if (editType === "addFeature") {
                var coordinates = updatedData.features[0].geometry.coordinates;
                if (_this2.props.selectionType === SELECTION_TYPE.RECTANGLE) {
                  _this2._selectRectangleObjects(coordinates);
                } else if (_this2.props.selectionType === SELECTION_TYPE.POLYGON) {
                  _this2._selectPolygonObjects(coordinates);
                }
              }
            }
          }, inheritedProps)))];
          if (pendingPolygonSelection) {
            var bigPolygon = pendingPolygonSelection.bigPolygon;
            layers.push(
              // @ts-ignore
              new _layers.PolygonLayer(
                // @ts-ignore
                this.getSubLayerProps({
                  id: LAYER_ID_BLOCKER,
                  pickable: true,
                  stroked: false,
                  opacity: 1,
                  data: [bigPolygon],
                  getLineColor: function getLineColor(obj) {
                    return [0, 0, 0, 1];
                  },
                  getFillColor: function getFillColor(obj) {
                    return [0, 0, 0, 1];
                  },
                  getPolygon: function getPolygon(o2) {
                    return o2.geometry.coordinates;
                  }
                })
              )
            );
          }
          return layers;
        }
      }, {
        key: "shouldUpdateState",
        value: function shouldUpdateState(_ref2) {
          var _ref2$changeFlags = _ref2.changeFlags, stateChanged = _ref2$changeFlags.stateChanged, propsOrDataChanged = _ref2$changeFlags.propsOrDataChanged;
          return stateChanged || propsOrDataChanged;
        }
      }]);
      return SelectionLayer2;
    }(_core.CompositeLayer);
    exports["default"] = SelectionLayer;
    _defineProperty2(SelectionLayer, "layerName", "SelectionLayer");
    _defineProperty2(SelectionLayer, "defaultProps", defaultProps40);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/elevated-edit-handle-layer.js
var require_elevated_edit_handle_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/elevated-edit-handle-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm13(), __toCommonJS(esm_exports2));
    var _layers = (init_esm15(), __toCommonJS(esm_exports3));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defaultProps40 = {};
    var ElevatedEditHandleLayer = function(_CompositeLayer) {
      _inherits(ElevatedEditHandleLayer2, _CompositeLayer);
      var _super = _createSuper(ElevatedEditHandleLayer2);
      function ElevatedEditHandleLayer2() {
        _classCallCheck(this, ElevatedEditHandleLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(ElevatedEditHandleLayer2, [{
        key: "renderLayers",
        value: function renderLayers() {
          var handles = new _layers.ScatterplotLayer(Object.assign({}, this.props, {
            id: "".concat(this.props.id, "-ScatterplotLayer"),
            data: this.props.data
          }));
          var lines = new _layers.LineLayer(Object.assign({}, this.props, {
            id: "".concat(this.props.id, "-LineLayer"),
            data: this.props.data,
            pickable: false,
            getSourcePosition: function getSourcePosition(_ref) {
              var position = _ref.position;
              return [position[0], position[1], 0];
            },
            getTargetPosition: function getTargetPosition(_ref2) {
              var position = _ref2.position;
              return [position[0], position[1], position[2] || 0];
            },
            getColor: [150, 150, 150, 200],
            getStrokeWidth: 3
          }));
          return [handles, lines];
        }
      }]);
      return ElevatedEditHandleLayer2;
    }(_core.CompositeLayer);
    exports["default"] = ElevatedEditHandleLayer;
    _defineProperty2(ElevatedEditHandleLayer, "layerName", "ElevatedEditHandleLayer");
    _defineProperty2(ElevatedEditHandleLayer, "defaultProps", defaultProps40);
  }
});

// node_modules/@luma.gl/constants/dist/esm/index.js
var esm_exports6 = {};
__export(esm_exports6, {
  default: () => esm_default
});
var esm_default;
var init_esm34 = __esm({
  "node_modules/@luma.gl/constants/dist/esm/index.js"() {
    esm_default = {
      DEPTH_BUFFER_BIT: 256,
      STENCIL_BUFFER_BIT: 1024,
      COLOR_BUFFER_BIT: 16384,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      ZERO: 0,
      ONE: 1,
      SRC_COLOR: 768,
      ONE_MINUS_SRC_COLOR: 769,
      SRC_ALPHA: 770,
      ONE_MINUS_SRC_ALPHA: 771,
      DST_ALPHA: 772,
      ONE_MINUS_DST_ALPHA: 773,
      DST_COLOR: 774,
      ONE_MINUS_DST_COLOR: 775,
      SRC_ALPHA_SATURATE: 776,
      CONSTANT_COLOR: 32769,
      ONE_MINUS_CONSTANT_COLOR: 32770,
      CONSTANT_ALPHA: 32771,
      ONE_MINUS_CONSTANT_ALPHA: 32772,
      FUNC_ADD: 32774,
      FUNC_SUBTRACT: 32778,
      FUNC_REVERSE_SUBTRACT: 32779,
      BLEND_EQUATION: 32777,
      BLEND_EQUATION_RGB: 32777,
      BLEND_EQUATION_ALPHA: 34877,
      BLEND_DST_RGB: 32968,
      BLEND_SRC_RGB: 32969,
      BLEND_DST_ALPHA: 32970,
      BLEND_SRC_ALPHA: 32971,
      BLEND_COLOR: 32773,
      ARRAY_BUFFER_BINDING: 34964,
      ELEMENT_ARRAY_BUFFER_BINDING: 34965,
      LINE_WIDTH: 2849,
      ALIASED_POINT_SIZE_RANGE: 33901,
      ALIASED_LINE_WIDTH_RANGE: 33902,
      CULL_FACE_MODE: 2885,
      FRONT_FACE: 2886,
      DEPTH_RANGE: 2928,
      DEPTH_WRITEMASK: 2930,
      DEPTH_CLEAR_VALUE: 2931,
      DEPTH_FUNC: 2932,
      STENCIL_CLEAR_VALUE: 2961,
      STENCIL_FUNC: 2962,
      STENCIL_FAIL: 2964,
      STENCIL_PASS_DEPTH_FAIL: 2965,
      STENCIL_PASS_DEPTH_PASS: 2966,
      STENCIL_REF: 2967,
      STENCIL_VALUE_MASK: 2963,
      STENCIL_WRITEMASK: 2968,
      STENCIL_BACK_FUNC: 34816,
      STENCIL_BACK_FAIL: 34817,
      STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
      STENCIL_BACK_PASS_DEPTH_PASS: 34819,
      STENCIL_BACK_REF: 36003,
      STENCIL_BACK_VALUE_MASK: 36004,
      STENCIL_BACK_WRITEMASK: 36005,
      VIEWPORT: 2978,
      SCISSOR_BOX: 3088,
      COLOR_CLEAR_VALUE: 3106,
      COLOR_WRITEMASK: 3107,
      UNPACK_ALIGNMENT: 3317,
      PACK_ALIGNMENT: 3333,
      MAX_TEXTURE_SIZE: 3379,
      MAX_VIEWPORT_DIMS: 3386,
      SUBPIXEL_BITS: 3408,
      RED_BITS: 3410,
      GREEN_BITS: 3411,
      BLUE_BITS: 3412,
      ALPHA_BITS: 3413,
      DEPTH_BITS: 3414,
      STENCIL_BITS: 3415,
      POLYGON_OFFSET_UNITS: 10752,
      POLYGON_OFFSET_FACTOR: 32824,
      TEXTURE_BINDING_2D: 32873,
      SAMPLE_BUFFERS: 32936,
      SAMPLES: 32937,
      SAMPLE_COVERAGE_VALUE: 32938,
      SAMPLE_COVERAGE_INVERT: 32939,
      COMPRESSED_TEXTURE_FORMATS: 34467,
      VENDOR: 7936,
      RENDERER: 7937,
      VERSION: 7938,
      IMPLEMENTATION_COLOR_READ_TYPE: 35738,
      IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
      BROWSER_DEFAULT_WEBGL: 37444,
      STATIC_DRAW: 35044,
      STREAM_DRAW: 35040,
      DYNAMIC_DRAW: 35048,
      ARRAY_BUFFER: 34962,
      ELEMENT_ARRAY_BUFFER: 34963,
      BUFFER_SIZE: 34660,
      BUFFER_USAGE: 34661,
      CURRENT_VERTEX_ATTRIB: 34342,
      VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
      VERTEX_ATTRIB_ARRAY_SIZE: 34339,
      VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
      VERTEX_ATTRIB_ARRAY_TYPE: 34341,
      VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
      VERTEX_ATTRIB_ARRAY_POINTER: 34373,
      VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
      CULL_FACE: 2884,
      FRONT: 1028,
      BACK: 1029,
      FRONT_AND_BACK: 1032,
      BLEND: 3042,
      DEPTH_TEST: 2929,
      DITHER: 3024,
      POLYGON_OFFSET_FILL: 32823,
      SAMPLE_ALPHA_TO_COVERAGE: 32926,
      SAMPLE_COVERAGE: 32928,
      SCISSOR_TEST: 3089,
      STENCIL_TEST: 2960,
      NO_ERROR: 0,
      INVALID_ENUM: 1280,
      INVALID_VALUE: 1281,
      INVALID_OPERATION: 1282,
      OUT_OF_MEMORY: 1285,
      CONTEXT_LOST_WEBGL: 37442,
      CW: 2304,
      CCW: 2305,
      DONT_CARE: 4352,
      FASTEST: 4353,
      NICEST: 4354,
      GENERATE_MIPMAP_HINT: 33170,
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      INT: 5124,
      UNSIGNED_INT: 5125,
      FLOAT: 5126,
      DOUBLE: 5130,
      DEPTH_COMPONENT: 6402,
      ALPHA: 6406,
      RGB: 6407,
      RGBA: 6408,
      LUMINANCE: 6409,
      LUMINANCE_ALPHA: 6410,
      UNSIGNED_SHORT_4_4_4_4: 32819,
      UNSIGNED_SHORT_5_5_5_1: 32820,
      UNSIGNED_SHORT_5_6_5: 33635,
      FRAGMENT_SHADER: 35632,
      VERTEX_SHADER: 35633,
      COMPILE_STATUS: 35713,
      DELETE_STATUS: 35712,
      LINK_STATUS: 35714,
      VALIDATE_STATUS: 35715,
      ATTACHED_SHADERS: 35717,
      ACTIVE_ATTRIBUTES: 35721,
      ACTIVE_UNIFORMS: 35718,
      MAX_VERTEX_ATTRIBS: 34921,
      MAX_VERTEX_UNIFORM_VECTORS: 36347,
      MAX_VARYING_VECTORS: 36348,
      MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
      MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
      MAX_TEXTURE_IMAGE_UNITS: 34930,
      MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
      SHADER_TYPE: 35663,
      SHADING_LANGUAGE_VERSION: 35724,
      CURRENT_PROGRAM: 35725,
      NEVER: 512,
      ALWAYS: 519,
      LESS: 513,
      EQUAL: 514,
      LEQUAL: 515,
      GREATER: 516,
      GEQUAL: 518,
      NOTEQUAL: 517,
      KEEP: 7680,
      REPLACE: 7681,
      INCR: 7682,
      DECR: 7683,
      INVERT: 5386,
      INCR_WRAP: 34055,
      DECR_WRAP: 34056,
      NEAREST: 9728,
      LINEAR: 9729,
      NEAREST_MIPMAP_NEAREST: 9984,
      LINEAR_MIPMAP_NEAREST: 9985,
      NEAREST_MIPMAP_LINEAR: 9986,
      LINEAR_MIPMAP_LINEAR: 9987,
      TEXTURE_MAG_FILTER: 10240,
      TEXTURE_MIN_FILTER: 10241,
      TEXTURE_WRAP_S: 10242,
      TEXTURE_WRAP_T: 10243,
      TEXTURE_2D: 3553,
      TEXTURE: 5890,
      TEXTURE_CUBE_MAP: 34067,
      TEXTURE_BINDING_CUBE_MAP: 34068,
      TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
      TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
      TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
      TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
      TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
      TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
      MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
      TEXTURE0: 33984,
      ACTIVE_TEXTURE: 34016,
      REPEAT: 10497,
      CLAMP_TO_EDGE: 33071,
      MIRRORED_REPEAT: 33648,
      TEXTURE_WIDTH: 4096,
      TEXTURE_HEIGHT: 4097,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      INT_VEC2: 35667,
      INT_VEC3: 35668,
      INT_VEC4: 35669,
      BOOL: 35670,
      BOOL_VEC2: 35671,
      BOOL_VEC3: 35672,
      BOOL_VEC4: 35673,
      FLOAT_MAT2: 35674,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      SAMPLER_2D: 35678,
      SAMPLER_CUBE: 35680,
      LOW_FLOAT: 36336,
      MEDIUM_FLOAT: 36337,
      HIGH_FLOAT: 36338,
      LOW_INT: 36339,
      MEDIUM_INT: 36340,
      HIGH_INT: 36341,
      FRAMEBUFFER: 36160,
      RENDERBUFFER: 36161,
      RGBA4: 32854,
      RGB5_A1: 32855,
      RGB565: 36194,
      DEPTH_COMPONENT16: 33189,
      STENCIL_INDEX: 6401,
      STENCIL_INDEX8: 36168,
      DEPTH_STENCIL: 34041,
      RENDERBUFFER_WIDTH: 36162,
      RENDERBUFFER_HEIGHT: 36163,
      RENDERBUFFER_INTERNAL_FORMAT: 36164,
      RENDERBUFFER_RED_SIZE: 36176,
      RENDERBUFFER_GREEN_SIZE: 36177,
      RENDERBUFFER_BLUE_SIZE: 36178,
      RENDERBUFFER_ALPHA_SIZE: 36179,
      RENDERBUFFER_DEPTH_SIZE: 36180,
      RENDERBUFFER_STENCIL_SIZE: 36181,
      FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
      FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
      FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
      FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
      COLOR_ATTACHMENT0: 36064,
      DEPTH_ATTACHMENT: 36096,
      STENCIL_ATTACHMENT: 36128,
      DEPTH_STENCIL_ATTACHMENT: 33306,
      NONE: 0,
      FRAMEBUFFER_COMPLETE: 36053,
      FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
      FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
      FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
      FRAMEBUFFER_UNSUPPORTED: 36061,
      FRAMEBUFFER_BINDING: 36006,
      RENDERBUFFER_BINDING: 36007,
      READ_FRAMEBUFFER: 36008,
      DRAW_FRAMEBUFFER: 36009,
      MAX_RENDERBUFFER_SIZE: 34024,
      INVALID_FRAMEBUFFER_OPERATION: 1286,
      UNPACK_FLIP_Y_WEBGL: 37440,
      UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
      UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
      READ_BUFFER: 3074,
      UNPACK_ROW_LENGTH: 3314,
      UNPACK_SKIP_ROWS: 3315,
      UNPACK_SKIP_PIXELS: 3316,
      PACK_ROW_LENGTH: 3330,
      PACK_SKIP_ROWS: 3331,
      PACK_SKIP_PIXELS: 3332,
      TEXTURE_BINDING_3D: 32874,
      UNPACK_SKIP_IMAGES: 32877,
      UNPACK_IMAGE_HEIGHT: 32878,
      MAX_3D_TEXTURE_SIZE: 32883,
      MAX_ELEMENTS_VERTICES: 33e3,
      MAX_ELEMENTS_INDICES: 33001,
      MAX_TEXTURE_LOD_BIAS: 34045,
      MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
      MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
      MAX_ARRAY_TEXTURE_LAYERS: 35071,
      MIN_PROGRAM_TEXEL_OFFSET: 35076,
      MAX_PROGRAM_TEXEL_OFFSET: 35077,
      MAX_VARYING_COMPONENTS: 35659,
      FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
      RASTERIZER_DISCARD: 35977,
      VERTEX_ARRAY_BINDING: 34229,
      MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
      MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
      MAX_SERVER_WAIT_TIMEOUT: 37137,
      MAX_ELEMENT_INDEX: 36203,
      RED: 6403,
      RGB8: 32849,
      RGBA8: 32856,
      RGB10_A2: 32857,
      TEXTURE_3D: 32879,
      TEXTURE_WRAP_R: 32882,
      TEXTURE_MIN_LOD: 33082,
      TEXTURE_MAX_LOD: 33083,
      TEXTURE_BASE_LEVEL: 33084,
      TEXTURE_MAX_LEVEL: 33085,
      TEXTURE_COMPARE_MODE: 34892,
      TEXTURE_COMPARE_FUNC: 34893,
      SRGB: 35904,
      SRGB8: 35905,
      SRGB8_ALPHA8: 35907,
      COMPARE_REF_TO_TEXTURE: 34894,
      RGBA32F: 34836,
      RGB32F: 34837,
      RGBA16F: 34842,
      RGB16F: 34843,
      TEXTURE_2D_ARRAY: 35866,
      TEXTURE_BINDING_2D_ARRAY: 35869,
      R11F_G11F_B10F: 35898,
      RGB9_E5: 35901,
      RGBA32UI: 36208,
      RGB32UI: 36209,
      RGBA16UI: 36214,
      RGB16UI: 36215,
      RGBA8UI: 36220,
      RGB8UI: 36221,
      RGBA32I: 36226,
      RGB32I: 36227,
      RGBA16I: 36232,
      RGB16I: 36233,
      RGBA8I: 36238,
      RGB8I: 36239,
      RED_INTEGER: 36244,
      RGB_INTEGER: 36248,
      RGBA_INTEGER: 36249,
      R8: 33321,
      RG8: 33323,
      R16F: 33325,
      R32F: 33326,
      RG16F: 33327,
      RG32F: 33328,
      R8I: 33329,
      R8UI: 33330,
      R16I: 33331,
      R16UI: 33332,
      R32I: 33333,
      R32UI: 33334,
      RG8I: 33335,
      RG8UI: 33336,
      RG16I: 33337,
      RG16UI: 33338,
      RG32I: 33339,
      RG32UI: 33340,
      R8_SNORM: 36756,
      RG8_SNORM: 36757,
      RGB8_SNORM: 36758,
      RGBA8_SNORM: 36759,
      RGB10_A2UI: 36975,
      TEXTURE_IMMUTABLE_FORMAT: 37167,
      TEXTURE_IMMUTABLE_LEVELS: 33503,
      UNSIGNED_INT_2_10_10_10_REV: 33640,
      UNSIGNED_INT_10F_11F_11F_REV: 35899,
      UNSIGNED_INT_5_9_9_9_REV: 35902,
      FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
      UNSIGNED_INT_24_8: 34042,
      HALF_FLOAT: 5131,
      RG: 33319,
      RG_INTEGER: 33320,
      INT_2_10_10_10_REV: 36255,
      CURRENT_QUERY: 34917,
      QUERY_RESULT: 34918,
      QUERY_RESULT_AVAILABLE: 34919,
      ANY_SAMPLES_PASSED: 35887,
      ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
      MAX_DRAW_BUFFERS: 34852,
      DRAW_BUFFER0: 34853,
      DRAW_BUFFER1: 34854,
      DRAW_BUFFER2: 34855,
      DRAW_BUFFER3: 34856,
      DRAW_BUFFER4: 34857,
      DRAW_BUFFER5: 34858,
      DRAW_BUFFER6: 34859,
      DRAW_BUFFER7: 34860,
      DRAW_BUFFER8: 34861,
      DRAW_BUFFER9: 34862,
      DRAW_BUFFER10: 34863,
      DRAW_BUFFER11: 34864,
      DRAW_BUFFER12: 34865,
      DRAW_BUFFER13: 34866,
      DRAW_BUFFER14: 34867,
      DRAW_BUFFER15: 34868,
      MAX_COLOR_ATTACHMENTS: 36063,
      COLOR_ATTACHMENT1: 36065,
      COLOR_ATTACHMENT2: 36066,
      COLOR_ATTACHMENT3: 36067,
      COLOR_ATTACHMENT4: 36068,
      COLOR_ATTACHMENT5: 36069,
      COLOR_ATTACHMENT6: 36070,
      COLOR_ATTACHMENT7: 36071,
      COLOR_ATTACHMENT8: 36072,
      COLOR_ATTACHMENT9: 36073,
      COLOR_ATTACHMENT10: 36074,
      COLOR_ATTACHMENT11: 36075,
      COLOR_ATTACHMENT12: 36076,
      COLOR_ATTACHMENT13: 36077,
      COLOR_ATTACHMENT14: 36078,
      COLOR_ATTACHMENT15: 36079,
      SAMPLER_3D: 35679,
      SAMPLER_2D_SHADOW: 35682,
      SAMPLER_2D_ARRAY: 36289,
      SAMPLER_2D_ARRAY_SHADOW: 36292,
      SAMPLER_CUBE_SHADOW: 36293,
      INT_SAMPLER_2D: 36298,
      INT_SAMPLER_3D: 36299,
      INT_SAMPLER_CUBE: 36300,
      INT_SAMPLER_2D_ARRAY: 36303,
      UNSIGNED_INT_SAMPLER_2D: 36306,
      UNSIGNED_INT_SAMPLER_3D: 36307,
      UNSIGNED_INT_SAMPLER_CUBE: 36308,
      UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
      MAX_SAMPLES: 36183,
      SAMPLER_BINDING: 35097,
      PIXEL_PACK_BUFFER: 35051,
      PIXEL_UNPACK_BUFFER: 35052,
      PIXEL_PACK_BUFFER_BINDING: 35053,
      PIXEL_UNPACK_BUFFER_BINDING: 35055,
      COPY_READ_BUFFER: 36662,
      COPY_WRITE_BUFFER: 36663,
      COPY_READ_BUFFER_BINDING: 36662,
      COPY_WRITE_BUFFER_BINDING: 36663,
      FLOAT_MAT2x3: 35685,
      FLOAT_MAT2x4: 35686,
      FLOAT_MAT3x2: 35687,
      FLOAT_MAT3x4: 35688,
      FLOAT_MAT4x2: 35689,
      FLOAT_MAT4x3: 35690,
      UNSIGNED_INT_VEC2: 36294,
      UNSIGNED_INT_VEC3: 36295,
      UNSIGNED_INT_VEC4: 36296,
      UNSIGNED_NORMALIZED: 35863,
      SIGNED_NORMALIZED: 36764,
      VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
      VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
      TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
      MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
      TRANSFORM_FEEDBACK_VARYINGS: 35971,
      TRANSFORM_FEEDBACK_BUFFER_START: 35972,
      TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
      TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
      MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
      MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
      INTERLEAVED_ATTRIBS: 35980,
      SEPARATE_ATTRIBS: 35981,
      TRANSFORM_FEEDBACK_BUFFER: 35982,
      TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
      TRANSFORM_FEEDBACK: 36386,
      TRANSFORM_FEEDBACK_PAUSED: 36387,
      TRANSFORM_FEEDBACK_ACTIVE: 36388,
      TRANSFORM_FEEDBACK_BINDING: 36389,
      FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
      FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
      FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
      FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
      FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
      FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
      FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
      FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
      FRAMEBUFFER_DEFAULT: 33304,
      DEPTH24_STENCIL8: 35056,
      DRAW_FRAMEBUFFER_BINDING: 36006,
      READ_FRAMEBUFFER_BINDING: 36010,
      RENDERBUFFER_SAMPLES: 36011,
      FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
      FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
      UNIFORM_BUFFER: 35345,
      UNIFORM_BUFFER_BINDING: 35368,
      UNIFORM_BUFFER_START: 35369,
      UNIFORM_BUFFER_SIZE: 35370,
      MAX_VERTEX_UNIFORM_BLOCKS: 35371,
      MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
      MAX_COMBINED_UNIFORM_BLOCKS: 35374,
      MAX_UNIFORM_BUFFER_BINDINGS: 35375,
      MAX_UNIFORM_BLOCK_SIZE: 35376,
      MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
      MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
      UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
      ACTIVE_UNIFORM_BLOCKS: 35382,
      UNIFORM_TYPE: 35383,
      UNIFORM_SIZE: 35384,
      UNIFORM_BLOCK_INDEX: 35386,
      UNIFORM_OFFSET: 35387,
      UNIFORM_ARRAY_STRIDE: 35388,
      UNIFORM_MATRIX_STRIDE: 35389,
      UNIFORM_IS_ROW_MAJOR: 35390,
      UNIFORM_BLOCK_BINDING: 35391,
      UNIFORM_BLOCK_DATA_SIZE: 35392,
      UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
      UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
      UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
      UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
      OBJECT_TYPE: 37138,
      SYNC_CONDITION: 37139,
      SYNC_STATUS: 37140,
      SYNC_FLAGS: 37141,
      SYNC_FENCE: 37142,
      SYNC_GPU_COMMANDS_COMPLETE: 37143,
      UNSIGNALED: 37144,
      SIGNALED: 37145,
      ALREADY_SIGNALED: 37146,
      TIMEOUT_EXPIRED: 37147,
      CONDITION_SATISFIED: 37148,
      WAIT_FAILED: 37149,
      SYNC_FLUSH_COMMANDS_BIT: 1,
      COLOR: 6144,
      DEPTH: 6145,
      STENCIL: 6146,
      MIN: 32775,
      MAX: 32776,
      DEPTH_COMPONENT24: 33190,
      STREAM_READ: 35041,
      STREAM_COPY: 35042,
      STATIC_READ: 35045,
      STATIC_COPY: 35046,
      DYNAMIC_READ: 35049,
      DYNAMIC_COPY: 35050,
      DEPTH_COMPONENT32F: 36012,
      DEPTH32F_STENCIL8: 36013,
      INVALID_INDEX: 4294967295,
      TIMEOUT_IGNORED: -1,
      MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447,
      VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
      UNMASKED_VENDOR_WEBGL: 37445,
      UNMASKED_RENDERER_WEBGL: 37446,
      MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
      TEXTURE_MAX_ANISOTROPY_EXT: 34046,
      COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
      COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
      COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
      COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
      COMPRESSED_R11_EAC: 37488,
      COMPRESSED_SIGNED_R11_EAC: 37489,
      COMPRESSED_RG11_EAC: 37490,
      COMPRESSED_SIGNED_RG11_EAC: 37491,
      COMPRESSED_RGB8_ETC2: 37492,
      COMPRESSED_RGBA8_ETC2_EAC: 37493,
      COMPRESSED_SRGB8_ETC2: 37494,
      COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
      COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
      COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
      COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
      COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
      COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
      COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
      COMPRESSED_RGB_ETC1_WEBGL: 36196,
      COMPRESSED_RGB_ATC_WEBGL: 35986,
      COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35986,
      COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
      UNSIGNED_INT_24_8_WEBGL: 34042,
      HALF_FLOAT_OES: 36193,
      RGBA32F_EXT: 34836,
      RGB32F_EXT: 34837,
      FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297,
      UNSIGNED_NORMALIZED_EXT: 35863,
      MIN_EXT: 32775,
      MAX_EXT: 32776,
      SRGB_EXT: 35904,
      SRGB_ALPHA_EXT: 35906,
      SRGB8_ALPHA8_EXT: 35907,
      FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296,
      FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723,
      COLOR_ATTACHMENT0_WEBGL: 36064,
      COLOR_ATTACHMENT1_WEBGL: 36065,
      COLOR_ATTACHMENT2_WEBGL: 36066,
      COLOR_ATTACHMENT3_WEBGL: 36067,
      COLOR_ATTACHMENT4_WEBGL: 36068,
      COLOR_ATTACHMENT5_WEBGL: 36069,
      COLOR_ATTACHMENT6_WEBGL: 36070,
      COLOR_ATTACHMENT7_WEBGL: 36071,
      COLOR_ATTACHMENT8_WEBGL: 36072,
      COLOR_ATTACHMENT9_WEBGL: 36073,
      COLOR_ATTACHMENT10_WEBGL: 36074,
      COLOR_ATTACHMENT11_WEBGL: 36075,
      COLOR_ATTACHMENT12_WEBGL: 36076,
      COLOR_ATTACHMENT13_WEBGL: 36077,
      COLOR_ATTACHMENT14_WEBGL: 36078,
      COLOR_ATTACHMENT15_WEBGL: 36079,
      DRAW_BUFFER0_WEBGL: 34853,
      DRAW_BUFFER1_WEBGL: 34854,
      DRAW_BUFFER2_WEBGL: 34855,
      DRAW_BUFFER3_WEBGL: 34856,
      DRAW_BUFFER4_WEBGL: 34857,
      DRAW_BUFFER5_WEBGL: 34858,
      DRAW_BUFFER6_WEBGL: 34859,
      DRAW_BUFFER7_WEBGL: 34860,
      DRAW_BUFFER8_WEBGL: 34861,
      DRAW_BUFFER9_WEBGL: 34862,
      DRAW_BUFFER10_WEBGL: 34863,
      DRAW_BUFFER11_WEBGL: 34864,
      DRAW_BUFFER12_WEBGL: 34865,
      DRAW_BUFFER13_WEBGL: 34866,
      DRAW_BUFFER14_WEBGL: 34867,
      DRAW_BUFFER15_WEBGL: 34868,
      MAX_COLOR_ATTACHMENTS_WEBGL: 36063,
      MAX_DRAW_BUFFERS_WEBGL: 34852,
      VERTEX_ARRAY_BINDING_OES: 34229,
      QUERY_COUNTER_BITS_EXT: 34916,
      CURRENT_QUERY_EXT: 34917,
      QUERY_RESULT_EXT: 34918,
      QUERY_RESULT_AVAILABLE_EXT: 34919,
      TIME_ELAPSED_EXT: 35007,
      TIMESTAMP_EXT: 36392,
      GPU_DISJOINT_EXT: 36795
    };
  }
});

// node_modules/@nebula.gl/layers/dist-es6/shaderlib/outline/outline.js
var require_outline = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/shaderlib/outline/outline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var INITIAL_STATE = {
      outlineEnabled: false,
      outlineRenderShadowmap: false,
      outlineShadowmap: null
    };
    function getUniforms3() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_STATE, outlineEnabled = _ref.outlineEnabled, outlineRenderShadowmap = _ref.outlineRenderShadowmap, outlineShadowmap = _ref.outlineShadowmap;
      var uniforms = {};
      if (outlineEnabled !== void 0) {
        uniforms.outline_uEnabled = outlineEnabled;
      }
      if (outlineRenderShadowmap !== void 0) {
        uniforms.outline_uRenderOutlines = outlineRenderShadowmap;
      }
      if (outlineShadowmap !== void 0) {
        uniforms.outline_uShadowmap = outlineShadowmap;
      }
      return uniforms;
    }
    var vs6 = "attribute float instanceZLevel;\nvarying float outline_vzLevel;\nvarying vec4 outline_vPosition;\n\n// Set the z level for the outline shadowmap rendering\nvoid outline_setZLevel(float zLevel) {\n  outline_vzLevel = zLevel;\n}\n\n// Store an adjusted position for texture2DProj\nvoid outline_setUV(vec4 position) {\n  // mat4(\n  //   0.5, 0.0, 0.0, 0.0,\n  //   0.0, 0.5, 0.0, 0.0,\n  //   0.0, 0.0, 0.5, 0.0,\n  //   0.5, 0.5, 0.5, 1.0\n  // ) * position;\n  outline_vPosition = vec4(position.xyz * 0.5 + position.w * 0.5, position.w);\n}\n";
    var fs5 = "uniform bool outline_uEnabled;\nuniform bool outline_uRenderOutlines;\nuniform sampler2D outline_uShadowmap;\n\nvarying float outline_vzLevel;\n// varying vec2 outline_vUV;\nvarying vec4 outline_vPosition;\n\nconst float OUTLINE_Z_LEVEL_ERROR = 0.01;\n\n// Return a darker color in shadowmap\nvec4 outline_filterShadowColor(vec4 color) {\n  return vec4(outline_vzLevel / 255., outline_vzLevel / 255., outline_vzLevel / 255., 1.);\n}\n\n// Return a darker color if in shadowmap\nvec4 outline_filterDarkenColor(vec4 color) {\n  if (outline_uEnabled) {\n    float maxZLevel;\n    if (outline_vPosition.q > 0.0) {\n      maxZLevel = texture2DProj(outline_uShadowmap, outline_vPosition).r * 255.;\n    } else {\n      discard;\n    }\n    if (maxZLevel < outline_vzLevel + OUTLINE_Z_LEVEL_ERROR) {\n      vec4(color.rgb * 0.5, color.a);\n    } else {\n      discard;\n    }\n  }\n  return color;\n}\n\n// if enabled and rendering outlines - Render depth to shadowmap\n// if enabled and rendering colors - Return a darker color if in shadowmap\n// if disabled, just return color\nvec4 outline_filterColor(vec4 color) {\n  if (outline_uEnabled) {\n    return outline_uRenderOutlines ?\n      outline_filterShadowColor(color) :\n      outline_filterDarkenColor(color);\n  }\n  return color;\n}\n";
    var _default = {
      name: "outline",
      vs: vs6,
      fs: fs5,
      getUniforms: getUniforms3
    };
    exports["default"] = _default;
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-outline-layer/path-outline-layer.js
var require_path_outline_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-outline-layer/path-outline-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _layers = (init_esm15(), __toCommonJS(esm_exports3));
    var _constants = _interopRequireDefault((init_esm34(), __toCommonJS(esm_exports6)));
    var _core = (init_esm11(), __toCommonJS(esm_exports));
    var _outline = _interopRequireDefault(require_outline());
    var _constants2 = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function injectShaderCode(_ref) {
      var source = _ref.source, _ref$code = _ref.code, code = _ref$code === void 0 ? "" : _ref$code;
      var INJECT_CODE = /}[^{}]*$/;
      return source.replace(INJECT_CODE, code.concat("\n}\n"));
    }
    var VS_CODE = "  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n";
    var FS_CODE = "  gl_FragColor = outline_filterColor(gl_FragColor);\n";
    var defaultProps40 = {
      getZLevel: function getZLevel() {
        return 0;
      }
    };
    var PathOutlineLayer = function(_PathLayer) {
      _inherits(PathOutlineLayer2, _PathLayer);
      var _super = _createSuper(PathOutlineLayer2);
      function PathOutlineLayer2() {
        _classCallCheck(this, PathOutlineLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(PathOutlineLayer2, [{
        key: "getShaders",
        // Override getShaders to inject the outline module
        value: function getShaders() {
          var shaders = _get(_getPrototypeOf(PathOutlineLayer2.prototype), "getShaders", this).call(this);
          return Object.assign({}, shaders, {
            modules: shaders.modules.concat([_outline["default"]]),
            vs: injectShaderCode({
              source: shaders.vs,
              code: VS_CODE
            }),
            fs: injectShaderCode({
              source: shaders.fs,
              code: FS_CODE
            })
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState(context) {
          _get(_getPrototypeOf(PathOutlineLayer2.prototype), "initializeState", this).call(this, context);
          this.setState({
            outlineFramebuffer: new _core.Framebuffer(context.gl),
            dummyTexture: new _core.Texture2D(context.gl)
          });
          this.state.attributeManager.addInstanced({
            instanceZLevel: {
              size: 1,
              type: _constants["default"].UNSIGNED_BYTE,
              accessor: "getZLevel"
            }
          });
        }
        // Override draw to add render module
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var _ref2$moduleParameter = _ref2.moduleParameters, moduleParameters = _ref2$moduleParameter === void 0 ? {} : _ref2$moduleParameter, parameters2 = _ref2.parameters, uniforms = _ref2.uniforms, context = _ref2.context;
          var _this$props = this.props, jointRounded = _this$props.jointRounded, capRounded = _this$props.capRounded, billboard = _this$props.billboard, miterLimit = _this$props.miterLimit, widthUnits = _this$props.widthUnits, widthScale = _this$props.widthScale, widthMinPixels = _this$props.widthMinPixels, widthMaxPixels = _this$props.widthMaxPixels;
          uniforms = Object.assign({}, uniforms, {
            jointType: Number(jointRounded),
            capType: Number(capRounded),
            billboard,
            widthUnits: _constants2.UNIT[widthUnits],
            widthScale,
            miterLimit,
            widthMinPixels,
            widthMaxPixels
          });
          var _this$state = this.state, outlineFramebuffer = _this$state.outlineFramebuffer, dummyTexture = _this$state.dummyTexture;
          outlineFramebuffer.resize();
          outlineFramebuffer.clear({
            color: true,
            depth: true
          });
          this.state.model.updateModuleSettings({
            outlineEnabled: true,
            outlineRenderShadowmap: true,
            outlineShadowmap: dummyTexture
          });
          this.state.model.draw({
            uniforms: Object.assign({}, uniforms, {
              jointType: 0,
              widthScale: this.props.widthScale * 1.3
            }),
            parameters: {
              depthTest: false,
              // Biggest value needs to go into buffer
              blendEquation: _constants["default"].MAX
            },
            framebuffer: outlineFramebuffer
          });
          this.state.model.updateModuleSettings({
            outlineEnabled: true,
            outlineRenderShadowmap: false,
            outlineShadowmap: outlineFramebuffer
          });
          this.state.model.draw({
            uniforms: Object.assign({}, uniforms, {
              jointType: Number(jointRounded),
              capType: Number(capRounded),
              widthScale: this.props.widthScale
            }),
            parameters: {
              depthTest: false
            }
          });
        }
      }]);
      return PathOutlineLayer2;
    }(_layers.PathLayer);
    exports["default"] = PathOutlineLayer;
    _defineProperty2(PathOutlineLayer, "layerName", "PathOutlineLayer");
    _defineProperty2(PathOutlineLayer, "defaultProps", defaultProps40);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/arrow-2d-geometry.js
var require_arrow_2d_geometry = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/arrow-2d-geometry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm11(), __toCommonJS(esm_exports));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Arrow2DGeometry = function(_Geometry) {
      _inherits(Arrow2DGeometry2, _Geometry);
      var _super = _createSuper(Arrow2DGeometry2);
      function Arrow2DGeometry2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Arrow2DGeometry2);
        return _super.call(this, Object.assign({}, opts, {
          attributes: getArrowAttributes(opts)
        }));
      }
      return Arrow2DGeometry2;
    }(_core.Geometry);
    exports["default"] = Arrow2DGeometry;
    function getArrowAttributes(_ref) {
      var _ref$length = _ref.length, length3 = _ref$length === void 0 ? 1 : _ref$length, _ref$headSize = _ref.headSize, headSize = _ref$headSize === void 0 ? 0.2 : _ref$headSize, _ref$tailWidth = _ref.tailWidth, tailWidth = _ref$tailWidth === void 0 ? 0.05 : _ref$tailWidth, _ref$tailStart = _ref.tailStart, tailStart = _ref$tailStart === void 0 ? 0.05 : _ref$tailStart;
      var texCoords = [
        // HEAD
        0.5,
        1,
        0,
        0.5 - headSize / 2,
        1 - headSize,
        0,
        0.5 + headSize / 2,
        1 - headSize,
        0,
        0.5 - tailWidth / 2,
        tailStart,
        0,
        0.5 + tailWidth / 2,
        1 - headSize,
        0,
        0.5 + tailWidth / 2,
        tailStart,
        0,
        0.5 - tailWidth / 2,
        tailStart,
        0,
        0.5 - tailWidth / 2,
        1 - headSize,
        0,
        0.5 + tailWidth / 2,
        1 - headSize,
        0
      ];
      var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
      var positions = new Array(texCoords.length);
      for (var i3 = 0; i3 < texCoords.length / 3; i3++) {
        var i32 = i3 * 3;
        positions[i32 + 0] = (texCoords[i32 + 0] - 0.5) * length3;
        positions[i32 + 1] = (texCoords[i32 + 1] - 0.5) * length3;
        positions[i32 + 2] = 0;
      }
      return {
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        texCoords: new Float32Array(texCoords)
      };
    }
  }
});

// node_modules/math.gl/dist/esm/index.js
var esm_exports7 = {};
__export(esm_exports7, {
  Euler: () => Euler,
  Matrix3: () => Matrix3,
  Matrix4: () => Matrix4,
  Pose: () => Pose,
  Quaternion: () => Quaternion,
  SphericalCoordinates: () => SphericalCoordinates,
  Vector2: () => Vector2,
  Vector3: () => Vector3,
  Vector4: () => Vector4,
  _Euler: () => Euler,
  _MathUtils: () => math_utils_default,
  _Pose: () => Pose,
  _SphericalCoordinates: () => SphericalCoordinates,
  acos: () => acos,
  asin: () => asin,
  assert: () => assert4,
  atan: () => atan,
  clamp: () => clamp,
  clone: () => clone,
  config: () => config,
  configure: () => configure,
  cos: () => cos,
  degrees: () => degrees,
  equals: () => equals,
  exactEquals: () => exactEquals,
  formatValue: () => formatValue,
  isArray: () => isArray,
  lerp: () => lerp,
  radians: () => radians,
  sin: () => sin,
  tan: () => tan,
  toDegrees: () => toDegrees,
  toRadians: () => toRadians,
  withEpsilon: () => withEpsilon
});
var init_esm35 = __esm({
  "node_modules/math.gl/dist/esm/index.js"() {
    init_esm8();
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/create-path-markers.js
var require_create_path_markers = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/create-path-markers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = createPathMarkers;
    var _math = (init_esm35(), __toCommonJS(esm_exports7));
    function _createForOfIteratorHelper(o2) {
      if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
        if (Array.isArray(o2) || (o2 = _unsupportedIterableToArray(o2))) {
          var i3 = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i3 >= o2.length)
              return { done: true };
            return { done: false, value: o2[i3++] };
          }, e: function e2(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s2() {
        it = o2[Symbol.iterator]();
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f2() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function getLineLength(vPoints) {
      var lineLength = 0;
      for (var i3 = 0; i3 < vPoints.length - 1; i3++) {
        lineLength += vPoints[i3].distance(vPoints[i3 + 1]);
      }
      return lineLength;
    }
    var DEFAULT_COLOR12 = [0, 0, 0, 255];
    var DEFAULT_DIRECTION = {
      forward: true,
      backward: false
    };
    function createPathMarkers(_ref) {
      var data = _ref.data, _ref$getPath = _ref.getPath, getPath = _ref$getPath === void 0 ? function(x2) {
        return x2.path;
      } : _ref$getPath, _ref$getDirection = _ref.getDirection, getDirection = _ref$getDirection === void 0 ? function(x2) {
        return x2.direction;
      } : _ref$getDirection, _ref$getColor = _ref.getColor, getColor = _ref$getColor === void 0 ? function(x2) {
        return DEFAULT_COLOR12;
      } : _ref$getColor, _ref$getMarkerPercent = _ref.getMarkerPercentages, getMarkerPercentages = _ref$getMarkerPercent === void 0 ? function(x2, info) {
        return [0.5];
      } : _ref$getMarkerPercent, projectFlat = _ref.projectFlat;
      var markers = [];
      var _iterator = _createForOfIteratorHelper(data), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var object = _step.value;
          var path = getPath(object);
          var direction = getDirection(object) || DEFAULT_DIRECTION;
          var color = getColor(object);
          var vPoints = path.map(function(p2) {
            return new _math.Vector2(p2);
          });
          var vPointsReverse = vPoints.slice(0).reverse();
          var lineLength = getLineLength(vPoints);
          var percentages = getMarkerPercentages(object, {
            lineLength
          });
          var _iterator2 = _createForOfIteratorHelper(percentages), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var percentage = _step2.value;
              if (direction.forward) {
                var marker2 = createMarkerAlongPath({
                  path: vPoints,
                  percentage,
                  lineLength,
                  color,
                  object,
                  projectFlat
                });
                markers.push(marker2);
              }
              if (direction.backward) {
                var _marker = createMarkerAlongPath({
                  path: vPointsReverse,
                  percentage,
                  lineLength,
                  color,
                  object,
                  projectFlat
                });
                markers.push(_marker);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return markers;
    }
    function createMarkerAlongPath(_ref2) {
      var path = _ref2.path, percentage = _ref2.percentage, lineLength = _ref2.lineLength, color = _ref2.color, object = _ref2.object, projectFlat = _ref2.projectFlat;
      var distanceAlong = lineLength * percentage;
      var currentDistance = 0;
      var previousDistance = 0;
      var i3 = 0;
      for (i3 = 0; i3 < path.length - 1; i3++) {
        currentDistance += path[i3].distance(path[i3 + 1]);
        if (currentDistance > distanceAlong) {
          break;
        }
        previousDistance = currentDistance;
      }
      if (i3 === path.length - 1) {
        i3 -= 1;
      }
      var vDirection = path[i3 + 1].clone().subtract(path[i3]).normalize();
      var along = distanceAlong - previousDistance;
      var vCenter = vDirection.clone().multiply(new _math.Vector2(along, along)).add(path[i3]);
      var vDirection2 = new _math.Vector2(projectFlat(path[i3 + 1])).subtract(projectFlat(path[i3]));
      var angle = vDirection2.verticalAngle() * 180 / Math.PI;
      return {
        position: [vCenter.x, vCenter.y, 0],
        angle,
        color,
        object
      };
    }
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/polyline.js
var require_polyline = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/polyline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getClosestPointOnLine = getClosestPointOnLine;
    exports.getClosestPointOnPolyline = getClosestPointOnPolyline;
    var _math = (init_esm35(), __toCommonJS(esm_exports7));
    function getClosestPointOnLine(_ref) {
      var p2 = _ref.p, p1 = _ref.p1, p22 = _ref.p2, _ref$clampToLine = _ref.clampToLine, clampToLine = _ref$clampToLine === void 0 ? true : _ref$clampToLine;
      var lineVector = new _math.Vector3(p22).subtract(p1);
      var pointVector = new _math.Vector3(p2).subtract(p1);
      var dotProduct = lineVector.dot(pointVector);
      if (clampToLine) {
        dotProduct = (0, _math.clamp)(dotProduct, 0, 1);
      }
      return lineVector.lerp(dotProduct);
    }
    function getClosestPointOnPolyline(_ref2) {
      var p2 = _ref2.p, points = _ref2.points;
      p2 = new _math.Vector3(p2);
      var pClosest = null;
      var distanceSquared = Infinity;
      var index = -1;
      for (var i3 = 0; i3 < points.length - 1; ++i3) {
        var p1 = points[i3];
        var p22 = points[i3 + 1];
        var pClosestOnLine = getClosestPointOnLine({
          p: p2,
          p1,
          p2: p22
        });
        var distanceToLineSquared = p2.distanceSquared(pClosestOnLine);
        if (distanceToLineSquared < distanceSquared) {
          distanceSquared = distanceToLineSquared;
          pClosest = pClosestOnLine;
          index = i3;
        }
      }
      return {
        point: pClosest,
        index,
        p1: points[index],
        p2: points[index + 1],
        distanceSquared,
        distance: Math.sqrt(distanceSquared)
      };
    }
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/path-marker-layer.js
var require_path_marker_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/path-marker-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm13(), __toCommonJS(esm_exports2));
    var _layers = (init_esm15(), __toCommonJS(esm_exports3));
    var _meshLayers = (init_esm24(), __toCommonJS(esm_exports4));
    var _pathOutlineLayer = _interopRequireDefault(require_path_outline_layer());
    var _arrow2dGeometry = _interopRequireDefault(require_arrow_2d_geometry());
    var _createPathMarkers = _interopRequireDefault(require_create_path_markers());
    var _polyline = require_polyline();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _slicedToArray(arr, i3) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i3) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i3 && _arr.length === i3)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DISTANCE_FOR_MULTI_ARROWS = 0.1;
    var ARROW_HEAD_SIZE = 0.2;
    var ARROW_TAIL_WIDTH = 0.05;
    var DEFAULT_MARKER_LAYER = _meshLayers.SimpleMeshLayer;
    var DEFAULT_MARKER_LAYER_PROPS = {
      mesh: new _arrow2dGeometry["default"]({
        headSize: ARROW_HEAD_SIZE,
        tailWidth: ARROW_TAIL_WIDTH
      })
    };
    var defaultProps40 = Object.assign({}, _pathOutlineLayer["default"].defaultProps, {
      MarkerLayer: DEFAULT_MARKER_LAYER,
      markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,
      sizeScale: 100,
      fp64: false,
      highlightIndex: -1,
      highlightPoint: null,
      getPath: function getPath(x2) {
        return x2.path;
      },
      getColor: function getColor(x2) {
        return x2.color;
      },
      getMarkerColor: function getMarkerColor(x2) {
        return [0, 0, 0, 255];
      },
      getDirection: function getDirection(x2) {
        return x2.direction;
      },
      getMarkerPercentages: function getMarkerPercentages(object, _ref) {
        var lineLength = _ref.lineLength;
        return lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5];
      }
    });
    var PathMarkerLayer = function(_CompositeLayer) {
      _inherits(PathMarkerLayer2, _CompositeLayer);
      var _super = _createSuper(PathMarkerLayer2);
      function PathMarkerLayer2() {
        _classCallCheck(this, PathMarkerLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(PathMarkerLayer2, [{
        key: "initializeState",
        value: function initializeState() {
          this.state = {
            markers: [],
            mesh: new _arrow2dGeometry["default"]({
              headSize: ARROW_HEAD_SIZE,
              tailWidth: ARROW_TAIL_WIDTH
            }),
            closestPoint: null
          };
        }
        // @ts-ignore
      }, {
        key: "projectFlat",
        value: function projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {
          if (coordinateSystem === _core.COORDINATE_SYSTEM.METER_OFFSETS) {
            var _viewport$metersToLng = viewport.metersToLngLatDelta(xyz), _viewport$metersToLng2 = _slicedToArray(_viewport$metersToLng, 2), dx = _viewport$metersToLng2[0], dy = _viewport$metersToLng2[1];
            var _coordinateOrigin = _slicedToArray(coordinateOrigin, 2), _x = _coordinateOrigin[0], y2 = _coordinateOrigin[1];
            return viewport.projectFlat([_x + dx, dy + y2]);
          } else if (coordinateSystem === _core.COORDINATE_SYSTEM.LNGLAT_OFFSETS) {
            var _xyz = _slicedToArray(xyz, 2), _dx = _xyz[0], _dy = _xyz[1];
            var _coordinateOrigin2 = _slicedToArray(coordinateOrigin, 2), _x2 = _coordinateOrigin2[0], _y = _coordinateOrigin2[1];
            return viewport.projectFlat([_x2 + _dx, _dy + _y]);
          }
          return viewport.projectFlat(xyz);
        }
      }, {
        key: "updateState",
        value: function updateState(_ref2) {
          var _this = this;
          var props = _ref2.props, oldProps = _ref2.oldProps, changeFlags = _ref2.changeFlags;
          if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {
            var _this$props = this.props, data = _this$props.data, getPath = _this$props.getPath, getDirection = _this$props.getDirection, getMarkerColor = _this$props.getMarkerColor, getMarkerPercentages = _this$props.getMarkerPercentages, coordinateSystem = _this$props.coordinateSystem, coordinateOrigin = _this$props.coordinateOrigin;
            var viewport = this.context.viewport;
            var projectFlat = function projectFlat2(o2) {
              return _this.projectFlat(o2, viewport, coordinateSystem, coordinateOrigin);
            };
            this.state.markers = (0, _createPathMarkers["default"])({
              data,
              getPath,
              getDirection,
              getColor: getMarkerColor,
              getMarkerPercentages,
              projectFlat
            });
            this._recalculateClosestPoint();
          }
          if (changeFlags.propsChanged) {
            if (props.point !== oldProps.point) {
              this._recalculateClosestPoint();
            }
          }
        }
      }, {
        key: "_recalculateClosestPoint",
        value: function _recalculateClosestPoint() {
          var _this$props2 = this.props, highlightPoint = _this$props2.highlightPoint, highlightIndex = _this$props2.highlightIndex;
          if (highlightPoint && highlightIndex >= 0) {
            var object = this.props.data[highlightIndex];
            var points = this.props.getPath(object);
            var _getClosestPointOnPol = (0, _polyline.getClosestPointOnPolyline)({
              points,
              p: highlightPoint
            }), point = _getClosestPointOnPol.point;
            this.state.closestPoints = [{
              position: point
            }];
          } else {
            this.state.closestPoints = [];
          }
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(_ref3) {
          var info = _ref3.info;
          return Object.assign(info, {
            // override object with picked feature
            object: info.object && info.object.path || info.object
          });
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          return [new _pathOutlineLayer["default"](
            this.props,
            // @ts-ignore
            this.getSubLayerProps({
              id: "paths",
              // Note: data has to be passed explicitly like this to avoid being empty
              data: this.props.data
            })
          ), new this.props.MarkerLayer(this.getSubLayerProps(Object.assign({}, this.props.markerLayerProps, {
            id: "markers",
            data: this.state.markers,
            getOrientation: function getOrientation(x2) {
              return [0, -x2.angle, 0];
            },
            getColor: function getColor(x2) {
              return x2.color;
            },
            sizeScale: this.props.sizeScale,
            fp64: this.props.fp64,
            pickable: false,
            parameters: {
              blend: false,
              depthTest: false
            }
          }))), this.state.closestPoints && new _layers.ScatterplotLayer({
            id: "".concat(this.props.id, "-highlight"),
            data: this.state.closestPoints,
            // @ts-ignore
            fp64: this.props.fp64
          })];
        }
      }]);
      return PathMarkerLayer2;
    }(_core.CompositeLayer);
    exports["default"] = PathMarkerLayer;
    _defineProperty2(PathMarkerLayer, "layerName", "PathMarkerLayer");
    _defineProperty2(PathMarkerLayer, "defaultProps", defaultProps40);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/junction-scatterplot-layer.js
var require_junction_scatterplot_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/junction-scatterplot-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm13(), __toCommonJS(esm_exports2));
    var _layers = (init_esm15(), __toCommonJS(esm_exports3));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3] != null ? arguments[i3] : {};
        if (i3 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var JunctionScatterplotLayer = function(_CompositeLayer) {
      _inherits(JunctionScatterplotLayer2, _CompositeLayer);
      var _super = _createSuper(JunctionScatterplotLayer2);
      function JunctionScatterplotLayer2() {
        _classCallCheck(this, JunctionScatterplotLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(JunctionScatterplotLayer2, [{
        key: "renderLayers",
        value: function renderLayers() {
          var _this$props = this.props, id = _this$props.id, getFillColor = _this$props.getFillColor, getStrokeColor = _this$props.getStrokeColor, getInnerRadius = _this$props.getInnerRadius, updateTriggers = _this$props.updateTriggers;
          return [
            // the full circles
            new _layers.ScatterplotLayer(_objectSpread({}, this.props, {
              id: "".concat(id, "-full"),
              data: this.props.data,
              getLineColor: getStrokeColor,
              updateTriggers: _objectSpread({}, updateTriggers, {
                getStrokeColor: updateTriggers.getStrokeColor
              })
            })),
            // the inner part
            new _layers.ScatterplotLayer(_objectSpread({}, this.props, {
              id: "".concat(id, "-inner"),
              data: this.props.data,
              getFillColor,
              getRadius: getInnerRadius,
              pickable: false,
              updateTriggers: _objectSpread({}, updateTriggers, {
                getFillColor: updateTriggers.getFillColor,
                getRadius: updateTriggers.getInnerRadius
              })
            }))
          ];
        }
      }]);
      return JunctionScatterplotLayer2;
    }(_core.CompositeLayer);
    exports["default"] = JunctionScatterplotLayer;
    _defineProperty2(JunctionScatterplotLayer, "layerName", "JunctionScatterplotLayer");
    _defineProperty2(JunctionScatterplotLayer, "defaultProps", _objectSpread({}, _layers.ScatterplotLayer.defaultProps, {
      getFillColor: function getFillColor(d) {
        return [0, 0, 0, 255];
      },
      getStrokeColor: function getStrokeColor(d) {
        return [255, 255, 255, 255];
      },
      getInnerRadius: function getInnerRadius(d) {
        return 1;
      }
    }));
  }
});

// node_modules/@nebula.gl/layers/dist-es6/index.js
var require_dist_es62 = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ArrowStyles", {
      enumerable: true,
      get: function get() {
        return _style.ArrowStyles;
      }
    });
    Object.defineProperty(exports, "DEFAULT_ARROWS", {
      enumerable: true,
      get: function get() {
        return _style.DEFAULT_ARROWS;
      }
    });
    Object.defineProperty(exports, "MAX_ARROWS", {
      enumerable: true,
      get: function get() {
        return _style.MAX_ARROWS;
      }
    });
    Object.defineProperty(exports, "EditableGeoJsonLayer", {
      enumerable: true,
      get: function get() {
        return _editableGeojsonLayer["default"];
      }
    });
    Object.defineProperty(exports, "EditableH3ClusterLayer", {
      enumerable: true,
      get: function get() {
        return _editableH3ClusterLayer["default"];
      }
    });
    Object.defineProperty(exports, "SelectionLayer", {
      enumerable: true,
      get: function get() {
        return _selectionLayer["default"];
      }
    });
    Object.defineProperty(exports, "ElevatedEditHandleLayer", {
      enumerable: true,
      get: function get() {
        return _elevatedEditHandleLayer["default"];
      }
    });
    Object.defineProperty(exports, "PathOutlineLayer", {
      enumerable: true,
      get: function get() {
        return _pathOutlineLayer["default"];
      }
    });
    Object.defineProperty(exports, "PathMarkerLayer", {
      enumerable: true,
      get: function get() {
        return _pathMarkerLayer["default"];
      }
    });
    Object.defineProperty(exports, "JunctionScatterplotLayer", {
      enumerable: true,
      get: function get() {
        return _junctionScatterplotLayer["default"];
      }
    });
    Object.defineProperty(exports, "toDeckColor", {
      enumerable: true,
      get: function get() {
        return _utils.toDeckColor;
      }
    });
    var _style = require_style();
    var _editableGeojsonLayer = _interopRequireDefault(require_editable_geojson_layer());
    var _editableH3ClusterLayer = _interopRequireDefault(require_editable_h3_cluster_layer());
    var _selectionLayer = _interopRequireDefault(require_selection_layer());
    var _elevatedEditHandleLayer = _interopRequireDefault(require_elevated_edit_handle_layer());
    var _pathOutlineLayer = _interopRequireDefault(require_path_outline_layer());
    var _pathMarkerLayer = _interopRequireDefault(require_path_marker_layer());
    var _junctionScatterplotLayer = _interopRequireDefault(require_junction_scatterplot_layer());
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});
export default require_dist_es62();
/*! Bundled license information:

long/dist/long.js:
  (**
   * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/long.js for details
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=@nebula__gl_layers.js.map
