import {
  init_module,
  module_exports,
  require_dist_es6,
  require_js as require_js2,
  require_js2 as require_js3,
  require_js3 as require_js4,
  require_js4 as require_js5,
  require_js5 as require_js6
} from "./chunk-BLDV6D67.js";
import {
  AxisAlignedBoundingBox,
  CullingVolume,
  GLTFLoader,
  GLTFMaterialParser,
  ImageSource,
  MVTWorkerLoader,
  Plane,
  ScenegraphNode,
  TILE_TYPE,
  TerrainLoader,
  Tiles3DLoader,
  Tileset3D,
  binaryToGeojson,
  createGLTFObjects,
  createImageSource,
  edgeLength,
  geoToH3,
  getMeshBoundingBox,
  h3Distance,
  h3GetResolution,
  h3IsPentagon,
  h3SetToMultiPolygon,
  h3ToGeo,
  h3ToGeoBoundary,
  h3_js_es_exports,
  init_esm as init_esm10,
  init_esm10 as init_esm19,
  init_esm2 as init_esm11,
  init_esm3 as init_esm12,
  init_esm4 as init_esm13,
  init_esm5 as init_esm14,
  init_esm6 as init_esm15,
  init_esm7 as init_esm16,
  init_esm8 as init_esm17,
  init_esm9 as init_esm18,
  init_h3_js_es,
  makeOrientedBoundingBoxFromPoints,
  require_long
} from "./chunk-S7436LWQ.js";
import "./chunk-V276CUMH.js";
import {
  ArcLayer,
  BitmapLayer,
  ColumnLayer,
  GeoJsonLayer,
  PathLayer,
  PointCloudLayer,
  PolygonLayer,
  esm_exports as esm_exports3,
  init_esm2 as init_esm9
} from "./chunk-55BK76KH.js";
import {
  require_js
} from "./chunk-EXNR5W7M.js";
import "./chunk-GED75EK3.js";
import {
  COORDINATE_SYSTEM,
  CompositeLayer,
  Euler,
  FEATURES,
  Framebuffer,
  Geometry,
  GlobeViewport,
  Layer,
  LayerExtension,
  LayersPass,
  Matrix3,
  Matrix4,
  Model,
  OrthographicViewport,
  PickLayersPass,
  Pose,
  ProgramManager,
  Quaternion,
  Renderbuffer,
  RequestScheduler,
  SphericalCoordinates,
  Texture2D,
  Vector2,
  Vector3,
  Vector4,
  WebMercatorViewport,
  acos,
  asin,
  assert3 as assert,
  atan,
  clamp,
  clear,
  clone,
  config,
  configure,
  cos,
  createIterable,
  cssToDeviceRatio,
  deepEqual,
  degrees,
  equals,
  esm_exports,
  esm_exports2,
  exactEquals,
  flatten,
  formatValue,
  fp64,
  fp64LowPart,
  hasFeature,
  init_esm10 as init_esm4,
  init_esm11 as init_esm5,
  init_esm13 as init_esm6,
  init_esm16 as init_esm8,
  init_esm3 as init_esm,
  init_esm6 as init_esm2,
  init_esm9 as init_esm3,
  isArray,
  isWebGL2,
  lerp,
  load,
  log_default,
  math_utils_default,
  memoize,
  mergeShaders,
  pbr,
  phongLighting,
  picking_default,
  project32_default,
  project_default,
  radians,
  readPixelsToArray,
  sin,
  tan,
  toDegrees,
  toRadians,
  withEpsilon,
  withParameters
} from "./chunk-HOJWP2GR.js";
import {
  _defineProperty,
  dist,
  init_defineProperty,
  init_esm as init_esm7,
  init_vec3,
  lngLatToWorld,
  worldToLngLat
} from "./chunk-YAGFDRXW.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@nebula.gl/layers/dist-es6/style.js
var require_style = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/style.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MAX_ARROWS = exports.DEFAULT_ARROWS = exports.ArrowStyles = void 0;
    var ArrowStyles = {
      NONE: 0,
      FORWARD: 1,
      BACKWARD: 2,
      BOTH: 3
    };
    exports.ArrowStyles = ArrowStyles;
    var DEFAULT_ARROWS = 1;
    exports.DEFAULT_ARROWS = DEFAULT_ARROWS;
    var MAX_ARROWS = 3;
    exports.MAX_ARROWS = MAX_ARROWS;
  }
});

// node_modules/@nebula.gl/layers/dist-es6/constants.js
var require_constants = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UNIT = exports.PROJECTED_PIXEL_SIZE_MULTIPLIER = void 0;
    var PROJECTED_PIXEL_SIZE_MULTIPLIER = 2 / 3;
    exports.PROJECTED_PIXEL_SIZE_MULTIPLIER = PROJECTED_PIXEL_SIZE_MULTIPLIER;
    var UNIT = {
      common: 0,
      meters: 1,
      pixels: 2
    };
    exports.UNIT = UNIT;
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-layer.js
var require_editable_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm8(), __toCommonJS(esm_exports2));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var EVENT_TYPES = ["anyclick", "pointermove", "panstart", "panmove", "panend", "keyup"];
    var EditableLayer = function(_CompositeLayer) {
      _inherits(EditableLayer2, _CompositeLayer);
      var _super = _createSuper(EditableLayer2);
      function EditableLayer2() {
        _classCallCheck(this, EditableLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditableLayer2, [{
        key: "onLayerClick",
        // Overridable interaction event handlers
        value: function onLayerClick(event) {
        }
      }, {
        key: "onStartDragging",
        value: function onStartDragging(event) {
        }
      }, {
        key: "onStopDragging",
        value: function onStopDragging(event) {
        }
      }, {
        key: "onDragging",
        value: function onDragging(event) {
        }
      }, {
        key: "onPointerMove",
        value: function onPointerMove(event) {
        }
      }, {
        key: "onLayerKeyUp",
        value: function onLayerKeyUp(event) {
        }
        // default implementation - do nothing;
        // TODO: implement onCancelDragging (e.g. drag off screen)
      }, {
        key: "initializeState",
        value: function initializeState() {
          this.setState({
            _editableLayerState: {
              // Picked objects at the time the pointer went down
              pointerDownPicks: null,
              // Screen coordinates where the pointer went down
              pointerDownScreenCoords: null,
              // Ground coordinates where the pointer went down
              pointerDownMapCoords: null,
              // Keep track of the mjolnir.js event handler so it can be deregistered
              eventHandler: this._forwardEventToCurrentLayer.bind(this)
            }
          });
          this._addEventHandlers();
        }
      }, {
        key: "finalizeState",
        value: function finalizeState() {
          this._removeEventHandlers();
        }
      }, {
        key: "_addEventHandlers",
        value: function _addEventHandlers() {
          var eventManager = this.context.deck.eventManager;
          var eventHandler = this.state._editableLayerState.eventHandler;
          var _iterator = _createForOfIteratorHelper(EVENT_TYPES), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var eventType = _step.value;
              eventManager.on(eventType, eventHandler, {
                // give nebula a higher priority so that it can stop propagation to deck.gl's map panning handlers
                priority: 100
              });
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          var eventManager = this.context.deck.eventManager;
          var eventHandler = this.state._editableLayerState.eventHandler;
          var _iterator2 = _createForOfIteratorHelper(EVENT_TYPES), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var eventType = _step2.value;
              eventManager.off(eventType, eventHandler);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        // A new layer instance is created on every render, so forward the event to the current layer
        // This means that the first layer instance will stick around to be the event listener, but will forward the event
        // to the latest layer instance.
      }, {
        key: "_forwardEventToCurrentLayer",
        value: function _forwardEventToCurrentLayer(event) {
          var currentLayer = this.getCurrentLayer();
          var func = currentLayer["_on".concat(event.type)].bind(currentLayer);
          if (!func) {
            console.warn("no handler for mjolnir.js event ".concat(event.type));
            return;
          }
          func(event);
        }
      }, {
        key: "_onanyclick",
        value: function _onanyclick(_ref) {
          var srcEvent = _ref.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var picks = this.getPicks(screenCoords);
          this.onLayerClick({
            mapCoords,
            // @ts-ignore
            screenCoords,
            picks,
            sourceEvent: srcEvent
          });
        }
      }, {
        key: "_onkeyup",
        value: function _onkeyup(_ref2) {
          var srcEvent = _ref2.srcEvent;
          this.onLayerKeyUp(srcEvent);
        }
      }, {
        key: "_onpanstart",
        value: function _onpanstart(event) {
          var screenCoords = this.getScreenCoords(event.srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var picks = this.getPicks(screenCoords);
          this.setState({
            _editableLayerState: _objectSpread({}, this.state._editableLayerState, {
              pointerDownScreenCoords: screenCoords,
              pointerDownMapCoords: mapCoords,
              pointerDownPicks: picks
            })
          });
          this.onStartDragging({
            picks,
            // @ts-ignore
            screenCoords,
            // @ts-ignore
            mapCoords,
            // @ts-ignore
            pointerDownScreenCoords: screenCoords,
            pointerDownMapCoords: mapCoords,
            cancelPan: event.stopImmediatePropagation,
            sourceEvent: event.srcEvent
          });
        }
      }, {
        key: "_onpanmove",
        value: function _onpanmove(event) {
          var srcEvent = event.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var _this$state$_editable = this.state._editableLayerState, pointerDownPicks = _this$state$_editable.pointerDownPicks, pointerDownScreenCoords = _this$state$_editable.pointerDownScreenCoords, pointerDownMapCoords = _this$state$_editable.pointerDownMapCoords;
          var picks = this.getPicks(screenCoords);
          this.onDragging({
            // @ts-ignore
            screenCoords,
            mapCoords,
            picks,
            pointerDownPicks,
            pointerDownScreenCoords,
            pointerDownMapCoords,
            sourceEvent: srcEvent,
            cancelPan: event.stopImmediatePropagation
            // another (hacky) approach for cancelling map panning
            // const controller = this.context.deck.viewManager.controllers[
            //   Object.keys(this.context.deck.viewManager.controllers)[0]
            // ];
            // controller._state.isDragging = false;
          });
        }
      }, {
        key: "_onpanend",
        value: function _onpanend(_ref3) {
          var srcEvent = _ref3.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var _this$state$_editable2 = this.state._editableLayerState, pointerDownPicks = _this$state$_editable2.pointerDownPicks, pointerDownScreenCoords = _this$state$_editable2.pointerDownScreenCoords, pointerDownMapCoords = _this$state$_editable2.pointerDownMapCoords;
          var picks = this.getPicks(screenCoords);
          this.onStopDragging({
            picks,
            // @ts-ignore
            screenCoords,
            mapCoords,
            pointerDownPicks,
            pointerDownScreenCoords,
            pointerDownMapCoords,
            sourceEvent: srcEvent
          });
          this.setState({
            _editableLayerState: _objectSpread({}, this.state._editableLayerState, {
              pointerDownScreenCoords: null,
              pointerDownMapCoords: null,
              pointerDownPicks: null
            })
          });
        }
      }, {
        key: "_onpointermove",
        value: function _onpointermove(event) {
          var srcEvent = event.srcEvent;
          var screenCoords = this.getScreenCoords(srcEvent);
          var mapCoords = this.getMapCoords(screenCoords);
          var _this$state$_editable3 = this.state._editableLayerState, pointerDownPicks = _this$state$_editable3.pointerDownPicks, pointerDownScreenCoords = _this$state$_editable3.pointerDownScreenCoords, pointerDownMapCoords = _this$state$_editable3.pointerDownMapCoords;
          var picks = this.getPicks(screenCoords);
          this.onPointerMove({
            // @ts-ignore
            screenCoords,
            mapCoords,
            picks,
            pointerDownPicks,
            pointerDownScreenCoords,
            pointerDownMapCoords,
            sourceEvent: srcEvent
          });
        }
      }, {
        key: "getPicks",
        value: function getPicks(screenCoords) {
          return this.context.deck.pickMultipleObjects({
            x: screenCoords[0],
            y: screenCoords[1],
            layerIds: [this.props.id],
            radius: this.props.pickingRadius,
            depth: this.props.pickingDepth
          });
        }
      }, {
        key: "getScreenCoords",
        value: function getScreenCoords(pointerEvent) {
          return [pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().left, pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().top];
        }
      }, {
        key: "getMapCoords",
        value: function getMapCoords(screenCoords) {
          return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);
        }
      }]);
      return EditableLayer2;
    }(_core.CompositeLayer);
    exports["default"] = EditableLayer;
    _defineProperty2(EditableLayer, "layerName", "EditableLayer");
  }
});

// node_modules/@nebula.gl/layers/dist-es6/utils.js
var require_utils = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toDeckColor = toDeckColor;
    exports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;
    exports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;
    exports.distance2d = distance2d;
    exports.mix = mix;
    exports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;
    exports.insertBefore = insertBefore;
    var _destination = _interopRequireDefault(require_js3());
    var _bearing = _interopRequireDefault(require_js4());
    var _pointToLineDistance = _interopRequireDefault(require_js5());
    var _helpers = require_js();
    var _viewportMercatorProject = _interopRequireDefault((init_module(), __toCommonJS(module_exports)));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function toDeckColor(color) {
      var defaultColor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [255, 0, 0, 255];
      if (!Array.isArray(color)) {
        return defaultColor;
      }
      return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];
    }
    function recursivelyTraverseNestedArrays(array, prefix, fn) {
      if (!Array.isArray(array[0])) {
        return true;
      }
      for (var i = 0; i < array.length; i++) {
        if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {
          fn(array, prefix);
          break;
        }
      }
      return false;
    }
    function generatePointsParallelToLinePoints(p1, p2, groundCoords) {
      var lineString = {
        type: "LineString",
        coordinates: [p1, p2]
      };
      var pt = (0, _helpers.point)(groundCoords);
      var ddistance = (0, _pointToLineDistance["default"])(pt, lineString);
      var lineBearing = (0, _bearing["default"])(p1, p2);
      var isPointToLeftOfLine = (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]);
      var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;
      var p3 = (0, _destination["default"])(p2, ddistance, orthogonalBearing);
      var p4 = (0, _destination["default"])(p1, ddistance, orthogonalBearing);
      return [p3.geometry.coordinates, p4.geometry.coordinates];
    }
    function distance2d(x1, y1, x2, y2) {
      var dx = x1 - x2;
      var dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function mix(a, b, ratio) {
      return b * ratio + a * (1 - ratio);
    }
    function nearestPointOnProjectedLine(line, inPoint, viewport) {
      var wmViewport = new _viewportMercatorProject["default"](viewport);
      var coordinates = line.geometry.coordinates;
      var projectedCoords = coordinates.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 3), x3 = _ref2[0], y3 = _ref2[1], _ref2$ = _ref2[2], z = _ref2$ === void 0 ? 0 : _ref2$;
        return wmViewport.project([x3, y3, z]);
      });
      var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates), _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2), x = _wmViewport$project2[0], y = _wmViewport$project2[1];
      var minDistance = Infinity;
      var minPointInfo = {};
      projectedCoords.forEach(function(_ref3, index2) {
        var _ref4 = _slicedToArray(_ref3, 2), x22 = _ref4[0], y22 = _ref4[1];
        if (index2 === 0) {
          return;
        }
        var _projectedCoords = _slicedToArray(projectedCoords[index2 - 1], 2), x12 = _projectedCoords[0], y12 = _projectedCoords[1];
        var A = y12 - y22;
        var B = x22 - x12;
        var C = x12 * y22 - x22 * y12;
        var div = A * A + B * B;
        var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);
        if (distance < minDistance) {
          minDistance = distance;
          minPointInfo = {
            index: index2,
            x0: (B * (B * x - A * y) - A * C) / div,
            y0: (A * (-B * x + A * y) - B * C) / div
          };
        }
      });
      var _minPointInfo = minPointInfo, index = _minPointInfo.index, x0 = _minPointInfo.x0, y0 = _minPointInfo.y0;
      var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3), x1 = _projectedCoords2[0], y1 = _projectedCoords2[1], _projectedCoords2$ = _projectedCoords2[2], z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;
      var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3), x2 = _projectedCoords$inde[0], y2 = _projectedCoords$inde[1], _projectedCoords$inde2 = _projectedCoords$inde[2], z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2;
      var lineLength = distance2d(x1, y1, x2, y2);
      var startToPointLength = distance2d(x1, y1, x0, y0);
      var ratio = startToPointLength / lineLength;
      var z0 = mix(z1, z2, ratio);
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: wmViewport.unproject([x0, y0, z0])
        },
        properties: {
          // TODO: calculate the distance in proper units
          dist: minDistance,
          index: index - 1
        }
      };
    }
    function insertBefore(base, insertBefore2, toInsert) {
      var at = base.indexOf(insertBefore2);
      if (at < 0) {
        return base;
      }
      return base.slice(0, at) + toInsert + base.slice(at);
    }
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-path-layer.js
var require_editable_path_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-path-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _layers = (init_esm9(), __toCommonJS(esm_exports3));
    var _utils = require_utils();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defaultProps25 = _objectSpread({}, _layers.PathLayer.defaultProps, {
      pickingLineWidthExtraPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      }
    });
    var EditablePathLayer = function(_PathLayer) {
      _inherits(EditablePathLayer2, _PathLayer);
      var _super = _createSuper(EditablePathLayer2);
      function EditablePathLayer2() {
        _classCallCheck(this, EditablePathLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditablePathLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          var _shaders$inject;
          var shaders = _get(_getPrototypeOf(EditablePathLayer2.prototype), "getShaders", this).call(this);
          shaders.vs = (0, _utils.insertBefore)(shaders.vs, "vec3 width;", "\n       if(picking_uActive){\n        widthPixels.xy += pickingLineWidthExtraPixels;\n       }\n      ");
          return _objectSpread({}, shaders, {
            inject: _objectSpread({}, shaders.inject || {}, {
              "vs:#decl": (((_shaders$inject = shaders.inject) === null || _shaders$inject === void 0 ? void 0 : _shaders$inject["vs:#decl"]) || "").concat("uniform float pickingLineWidthExtraPixels;")
            })
          });
        }
      }, {
        key: "draw",
        value: function draw(props) {
          _get(_getPrototypeOf(EditablePathLayer2.prototype), "draw", this).call(this, _objectSpread({}, props, {
            uniforms: _objectSpread({}, props.uniforms, {
              pickingLineWidthExtraPixels: this.props.pickingLineWidthExtraPixels
            })
          }));
        }
      }]);
      return EditablePathLayer2;
    }(_layers.PathLayer);
    exports["default"] = EditablePathLayer;
    EditablePathLayer.defaultProps = defaultProps25;
    EditablePathLayer.layerName = "EditablePathLayer";
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-geojson-layer.js
var require_editable_geojson_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-geojson-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _layers = (init_esm9(), __toCommonJS(esm_exports3));
    var _editModes = require_dist_es6();
    var _constants = require_constants();
    var _editableLayer = _interopRequireDefault(require_editable_layer());
    var _editablePathLayer = _interopRequireDefault(require_editable_path_layer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DEFAULT_LINE_COLOR = [0, 0, 0, 153];
    var DEFAULT_FILL_COLOR = [0, 0, 0, 144];
    var DEFAULT_SELECTED_LINE_COLOR = [0, 0, 0, 255];
    var DEFAULT_SELECTED_FILL_COLOR = [0, 0, 144, 144];
    var DEFAULT_TENTATIVE_LINE_COLOR = [144, 144, 144, 255];
    var DEFAULT_TENTATIVE_FILL_COLOR = [144, 144, 144, 144];
    var DEFAULT_EDITING_EXISTING_POINT_COLOR = [192, 0, 0, 255];
    var DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0, 0, 0, 128];
    var DEFAULT_EDITING_SNAP_POINT_COLOR = [124, 0, 192, 255];
    var DEFAULT_EDITING_POINT_OUTLINE_COLOR = [255, 255, 255, 255];
    var DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;
    var DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;
    var DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;
    var DEFAULT_TOOLTIP_FONT_SIZE = 32 * _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER;
    var DEFAULT_EDIT_MODE = _editModes.DrawPolygonMode;
    function guideAccessor(accessor) {
      if (!accessor || typeof accessor !== "function") {
        return accessor;
      }
      return function(guideMaybeWrapped) {
        return accessor(unwrapGuide(guideMaybeWrapped));
      };
    }
    function unwrapGuide(guideMaybeWrapped) {
      if (guideMaybeWrapped.__source) {
        return guideMaybeWrapped.__source.object;
      } else if (guideMaybeWrapped.sourceFeature) {
        return guideMaybeWrapped.sourceFeature.feature;
      }
      return guideMaybeWrapped;
    }
    function getEditHandleColor(handle) {
      switch (handle.properties.editHandleType) {
        case "existing":
          return DEFAULT_EDITING_EXISTING_POINT_COLOR;
        case "snap-source":
          return DEFAULT_EDITING_SNAP_POINT_COLOR;
        case "intermediate":
        default:
          return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;
      }
    }
    function getEditHandleOutlineColor(handle) {
      return DEFAULT_EDITING_POINT_OUTLINE_COLOR;
    }
    function getEditHandleRadius(handle) {
      switch (handle.properties.editHandleType) {
        case "existing":
          return DEFAULT_EDITING_EXISTING_POINT_RADIUS;
        case "snap":
          return DEFAULT_EDITING_SNAP_POINT_RADIUS;
        case "intermediate":
        default:
          return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;
      }
    }
    var defaultProps25 = {
      mode: DEFAULT_EDIT_MODE,
      // Edit and interaction events
      onEdit: function onEdit() {
      },
      pickable: true,
      pickingRadius: 10,
      pickingDepth: 5,
      fp64: false,
      filled: true,
      stroked: true,
      lineWidthScale: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,
      lineWidthMinPixels: 1,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      pickingLineWidthExtraPixels: 0,
      lineWidthUnits: "pixels",
      lineJointRounded: false,
      lineCapRounded: false,
      lineMiterLimit: 4,
      pointRadiusScale: 1,
      pointRadiusMinPixels: 2,
      pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,
      getLineColor: function getLineColor(feature, isSelected, mode) {
        return isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR;
      },
      getFillColor: function getFillColor(feature, isSelected, mode) {
        return isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR;
      },
      getRadius: function getRadius(f) {
        return f && f.properties && f.properties.radius || f && f.properties && f.properties.size || 1;
      },
      getLineWidth: function getLineWidth(f) {
        return f && f.properties && f.properties.lineWidth || 3;
      },
      // Tentative feature rendering
      getTentativeLineColor: function getTentativeLineColor(f) {
        return DEFAULT_TENTATIVE_LINE_COLOR;
      },
      getTentativeFillColor: function getTentativeFillColor(f) {
        return DEFAULT_TENTATIVE_FILL_COLOR;
      },
      getTentativeLineWidth: function getTentativeLineWidth(f) {
        return f && f.properties && f.properties.lineWidth || 3;
      },
      editHandleType: "point",
      // point handles
      editHandlePointRadiusScale: 1,
      editHandlePointOutline: true,
      editHandlePointStrokeWidth: 2,
      editHandlePointRadiusUnits: "pixels",
      editHandlePointRadiusMinPixels: 4,
      editHandlePointRadiusMaxPixels: 8,
      getEditHandlePointColor: getEditHandleColor,
      getEditHandlePointOutlineColor: getEditHandleOutlineColor,
      getEditHandlePointRadius: getEditHandleRadius,
      // icon handles
      editHandleIconAtlas: null,
      editHandleIconMapping: null,
      editHandleIconSizeScale: 1,
      editHandleIconSizeUnits: "pixels",
      getEditHandleIcon: function getEditHandleIcon(handle) {
        return handle.properties.editHandleType;
      },
      getEditHandleIconSize: 10,
      getEditHandleIconColor: getEditHandleColor,
      getEditHandleIconAngle: 0,
      // misc
      billboard: true
    };
    var modeNameMapping = {
      view: _editModes.ViewMode,
      // Alter modes
      modify: _editModes.ModifyMode,
      translate: new _editModes.SnappableMode(new _editModes.TranslateMode()),
      transform: new _editModes.SnappableMode(new _editModes.TransformMode()),
      scale: _editModes.ScaleMode,
      rotate: _editModes.RotateMode,
      duplicate: _editModes.DuplicateMode,
      split: _editModes.SplitPolygonMode,
      extrude: _editModes.ExtrudeMode,
      elevation: _editModes.ElevationMode,
      // Draw modes
      drawPoint: _editModes.DrawPointMode,
      drawLineString: _editModes.DrawLineStringMode,
      drawPolygon: _editModes.DrawPolygonMode,
      drawRectangle: _editModes.DrawRectangleMode,
      drawSquare: _editModes.DrawSquareMode,
      drawRectangleFromCenter: _editModes.DrawRectangleFromCenterMode,
      drawSquareFromCenter: _editModes.DrawSquareFromCenterMode,
      drawCircleFromCenter: _editModes.DrawCircleFromCenterMode,
      drawCircleByBoundingBox: _editModes.DrawCircleByDiameterMode,
      drawEllipseByBoundingBox: _editModes.DrawEllipseByBoundingBoxMode,
      drawRectangleUsing3Points: _editModes.DrawRectangleUsingThreePointsMode,
      drawEllipseUsing3Points: _editModes.DrawEllipseUsingThreePointsMode,
      draw90DegreePolygon: _editModes.Draw90DegreePolygonMode,
      drawPolygonByDragging: _editModes.DrawPolygonByDraggingMode
    };
    var EditableGeoJsonLayer = function(_EditableLayer) {
      _inherits(EditableGeoJsonLayer2, _EditableLayer);
      var _super = _createSuper(EditableGeoJsonLayer2);
      function EditableGeoJsonLayer2() {
        _classCallCheck(this, EditableGeoJsonLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditableGeoJsonLayer2, [{
        key: "renderLayers",
        // setState: ($Shape<State>) => void;
        value: function renderLayers() {
          var subLayerProps = this.getSubLayerProps({
            id: "geojson",
            // Proxy most GeoJsonLayer props as-is
            data: this.props.data,
            fp64: this.props.fp64,
            filled: this.props.filled,
            stroked: this.props.stroked,
            lineWidthScale: this.props.lineWidthScale,
            lineWidthMinPixels: this.props.lineWidthMinPixels,
            lineWidthMaxPixels: this.props.lineWidthMaxPixels,
            lineWidthUnits: this.props.lineWidthUnits,
            lineJointRounded: this.props.lineJointRounded,
            lineCapRounded: this.props.lineCapRounded,
            lineMiterLimit: this.props.lineMiterLimit,
            pointRadiusScale: this.props.pointRadiusScale,
            pointRadiusMinPixels: this.props.pointRadiusMinPixels,
            pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,
            getLineColor: this.selectionAwareAccessor(this.props.getLineColor),
            getFillColor: this.selectionAwareAccessor(this.props.getFillColor),
            getPointRadius: this.selectionAwareAccessor(this.props.getRadius),
            getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),
            _subLayerProps: {
              linestrings: {
                billboard: this.props.billboard,
                updateTriggers: {
                  // required to update dashed array attribute
                  all: [this.props.selectedFeatureIndexes, this.props.mode]
                }
              },
              "polygons-stroke": {
                billboard: this.props.billboard,
                pickingLineWidthExtraPixels: this.props.pickingLineWidthExtraPixels,
                type: _editablePathLayer["default"],
                updateTriggers: {
                  // required to update dashed array attribute
                  all: [this.props.selectedFeatureIndexes, this.props.mode]
                }
              }
            },
            updateTriggers: {
              getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],
              getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],
              getPointRadius: [this.props.selectedFeatureIndexes, this.props.mode],
              getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode]
            }
          });
          var layers = [new _layers.GeoJsonLayer(subLayerProps)];
          layers = layers.concat(this.createGuidesLayers(), this.createTooltipsLayers());
          return layers;
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          _get(_getPrototypeOf(EditableGeoJsonLayer2.prototype), "initializeState", this).call(this);
          this.setState({
            selectedFeatures: [],
            editHandles: []
          });
        }
        // TODO: is this the best way to properly update state from an outside event handler?
      }, {
        key: "shouldUpdateState",
        value: function shouldUpdateState(opts) {
          return _get(_getPrototypeOf(EditableGeoJsonLayer2.prototype), "shouldUpdateState", this).call(this, opts) || opts.changeFlags.stateChanged;
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags, context = _ref.context;
          _get(_getPrototypeOf(EditableGeoJsonLayer2.prototype), "updateState", this).call(this, {
            oldProps,
            props,
            changeFlags,
            context
          });
          if (changeFlags.propsOrDataChanged) {
            var modePropChanged = Object.keys(oldProps).length === 0 || props.mode !== oldProps.mode;
            if (modePropChanged) {
              var _mode;
              if (typeof props.mode === "function") {
                var ModeConstructor = props.mode;
                _mode = new ModeConstructor();
              } else if (typeof props.mode === "string") {
                _mode = modeNameMapping[props.mode];
                console.warn("Deprecated use of passing `mode` as a string. Pass the mode's class constructor instead.");
              } else {
                _mode = props.mode;
              }
              if (!_mode) {
                console.warn("No mode configured for ".concat(String(props.mode)));
                _mode = new DEFAULT_EDIT_MODE();
              }
              if (_mode !== this.state.mode) {
                this.setState({
                  mode: _mode,
                  cursor: null
                });
              }
            }
          }
          var selectedFeatures = [];
          if (Array.isArray(props.selectedFeatureIndexes)) {
            selectedFeatures = props.selectedFeatureIndexes.map(function(elem) {
              return props.data.features[elem];
            });
          }
          this.setState({
            selectedFeatures
          });
        }
      }, {
        key: "getModeProps",
        value: function getModeProps(props) {
          var _this = this;
          return {
            modeConfig: props.modeConfig,
            data: props.data,
            selectedIndexes: props.selectedFeatureIndexes,
            lastPointerMoveEvent: this.state.lastPointerMoveEvent,
            cursor: this.state.cursor,
            onEdit: function onEdit(editAction) {
              _this.setNeedsUpdate();
              props.onEdit(editAction);
            },
            onUpdateCursor: function onUpdateCursor(cursor) {
              _this.setState({
                cursor
              });
            }
          };
        }
      }, {
        key: "selectionAwareAccessor",
        value: function selectionAwareAccessor(accessor) {
          var _this2 = this;
          if (typeof accessor !== "function") {
            return accessor;
          }
          return function(feature) {
            return accessor(feature, _this2.isFeatureSelected(feature), _this2.props.mode);
          };
        }
      }, {
        key: "isFeatureSelected",
        value: function isFeatureSelected(feature) {
          if (!this.props.data || !this.props.selectedFeatureIndexes) {
            return false;
          }
          if (!this.props.selectedFeatureIndexes.length) {
            return false;
          }
          var featureIndex = this.props.data.features.indexOf(feature);
          return this.props.selectedFeatureIndexes.includes(featureIndex);
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(_ref2) {
          var info = _ref2.info, sourceLayer = _ref2.sourceLayer;
          if (sourceLayer.id.endsWith("guides")) {
            info.isGuide = true;
          }
          return info;
        }
      }, {
        key: "_updateAutoHighlight",
        value: function _updateAutoHighlight(info) {
          if (info === null || info === void 0 ? void 0 : info.sourceLayer) {
            if (info.isGuide) {
              var _iterator = _createForOfIteratorHelper(info.sourceLayer.getSubLayers()), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var layer = _step.value;
                  layer.updateAutoHighlight(info);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            } else {
              info.sourceLayer.updateAutoHighlight(info);
            }
          }
        }
      }, {
        key: "createGuidesLayers",
        value: function createGuidesLayers() {
          var mode = this.getActiveMode();
          var guides = mode.getGuides(this.getModeProps(this.props));
          if (!guides || !guides.features.length) {
            return [];
          }
          var subLayerProps = {
            linestrings: {
              billboard: this.props.billboard,
              autoHighlight: false
            },
            "polygons-fill": {
              autoHighlight: false
            },
            "polygons-stroke": {
              billboard: this.props.billboard
            }
          };
          if (this.props.editHandleType === "icon") {
            subLayerProps["points-icon"] = {
              type: _layers.IconLayer,
              iconAtlas: this.props.editHandleIconAtlas,
              iconMapping: this.props.editHandleIconMapping,
              sizeUnits: this.props.editHandleIconSizeUnits,
              sizeScale: this.props.editHandleIconSizeScale,
              getIcon: guideAccessor(this.props.getEditHandleIcon),
              getSize: guideAccessor(this.props.getEditHandleIconSize),
              getColor: guideAccessor(this.props.getEditHandleIconColor),
              getAngle: guideAccessor(this.props.getEditHandleIconAngle)
            };
          } else {
            subLayerProps["points-circle"] = {
              type: _layers.ScatterplotLayer,
              radiusScale: this.props.editHandlePointRadiusScale,
              stroked: this.props.editHandlePointOutline,
              getLineWidth: this.props.editHandlePointStrokeWidth,
              radiusUnits: this.props.editHandlePointRadiusUnits,
              radiusMinPixels: this.props.editHandlePointRadiusMinPixels,
              radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,
              getRadius: guideAccessor(this.props.getEditHandlePointRadius),
              getFillColor: guideAccessor(this.props.getEditHandlePointColor),
              getLineColor: guideAccessor(this.props.getEditHandlePointOutlineColor)
            };
          }
          var layer = new _layers.GeoJsonLayer(this.getSubLayerProps({
            id: "guides",
            data: guides,
            fp64: this.props.fp64,
            _subLayerProps: subLayerProps,
            lineWidthScale: this.props.lineWidthScale,
            lineWidthMinPixels: this.props.lineWidthMinPixels,
            lineWidthMaxPixels: this.props.lineWidthMaxPixels,
            lineWidthUnits: this.props.lineWidthUnits,
            lineJointRounded: this.props.lineJointRounded,
            lineCapRounded: this.props.lineCapRounded,
            lineMiterLimit: this.props.lineMiterLimit,
            getLineColor: guideAccessor(this.props.getTentativeLineColor),
            getLineWidth: guideAccessor(this.props.getTentativeLineWidth),
            getFillColor: guideAccessor(this.props.getTentativeFillColor),
            pointType: this.props.editHandleType === "icon" ? "icon" : "circle",
            iconAtlas: this.props.editHandleIconAtlas
          }));
          return [layer];
        }
      }, {
        key: "createTooltipsLayers",
        value: function createTooltipsLayers() {
          var mode = this.getActiveMode();
          var tooltips = mode.getTooltips(this.getModeProps(this.props));
          var layer = new _layers.TextLayer(_objectSpread({
            getSize: DEFAULT_TOOLTIP_FONT_SIZE
          }, this.getSubLayerProps({
            id: "tooltips",
            data: tooltips
          })));
          return [layer];
        }
      }, {
        key: "onLayerClick",
        value: function onLayerClick(event) {
          this.getActiveMode().handleClick(event, this.getModeProps(this.props));
        }
      }, {
        key: "onLayerKeyUp",
        value: function onLayerKeyUp(event) {
          this.getActiveMode().handleKeyUp(event, this.getModeProps(this.props));
        }
      }, {
        key: "onStartDragging",
        value: function onStartDragging(event) {
          this.getActiveMode().handleStartDragging(event, this.getModeProps(this.props));
        }
      }, {
        key: "onDragging",
        value: function onDragging(event) {
          this.getActiveMode().handleDragging(event, this.getModeProps(this.props));
        }
      }, {
        key: "onStopDragging",
        value: function onStopDragging(event) {
          this.getActiveMode().handleStopDragging(event, this.getModeProps(this.props));
        }
      }, {
        key: "onPointerMove",
        value: function onPointerMove(event) {
          this.setState({
            lastPointerMoveEvent: event
          });
          this.getActiveMode().handlePointerMove(event, this.getModeProps(this.props));
        }
      }, {
        key: "getCursor",
        value: function getCursor(_ref3) {
          var isDragging = _ref3.isDragging;
          if (this.state === null || this.state === void 0) {
            return null;
          }
          var cursor = this.state.cursor;
          if (!cursor) {
            cursor = isDragging ? "grabbing" : "grab";
          }
          return cursor;
        }
      }, {
        key: "getActiveMode",
        value: function getActiveMode() {
          return this.state.mode;
        }
      }]);
      return EditableGeoJsonLayer2;
    }(_editableLayer["default"]);
    exports["default"] = EditableGeoJsonLayer;
    _defineProperty2(EditableGeoJsonLayer, "layerName", "EditableGeoJsonLayer");
    _defineProperty2(EditableGeoJsonLayer, "defaultProps", defaultProps25);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/utils.js
function WGS84ToPseudoMercator(coord) {
  const mercator = lngLatToWorld(coord);
  mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  return mercator;
}
var HALF_EARTH_CIRCUMFERENCE;
var init_utils = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/utils.js"() {
    init_esm7();
    HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/wms-layer.js
var defaultProps, WMSLayer;
var init_wms_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/wms-layer.js"() {
    init_defineProperty();
    init_esm8();
    init_esm9();
    init_esm10();
    init_utils();
    defaultProps = {
      id: "imagery-layer",
      data: "",
      serviceType: "auto",
      srs: "auto",
      layers: {
        type: "array",
        compare: true,
        value: []
      },
      onMetadataLoad: {
        type: "function",
        value: () => {
        }
      },
      onMetadataLoadError: {
        type: "function",
        value: console.error
      },
      onImageLoadStart: {
        type: "function",
        value: () => {
        }
      },
      onImageLoad: {
        type: "function",
        value: () => {
        }
      },
      onImageLoadError: {
        type: "function",
        compare: false,
        value: (requestId, error) => console.error(error, requestId)
      }
    };
    WMSLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      get isLoaded() {
        return Boolean(this.state) && this.state.loadCounter === 0 && super.isLoaded;
      }
      shouldUpdateState() {
        return true;
      }
      initializeState() {
        this.state._nextRequestId = 0;
        this.state.lastRequestId = -1;
        this.state.loadCounter = 0;
      }
      updateState({
        changeFlags,
        props,
        oldProps
      }) {
        const {
          viewport
        } = this.context;
        if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
          this.state.imageSource = this._createImageSource(props);
          this._loadMetadata();
          this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
        } else if (!deepEqual(props.layers, oldProps.layers, 1)) {
          this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
        } else if (changeFlags.viewportChanged) {
          this.debounce(() => this.loadImage(viewport, "viewport changed"));
        }
      }
      finalizeState() {
      }
      renderLayers() {
        const {
          bounds,
          image,
          lastRequestParameters
        } = this.state;
        return image && new BitmapLayer({
          ...this.getSubLayerProps({
            id: "bitmap"
          }),
          _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
          bounds,
          image
        });
      }
      async getFeatureInfoText(x, y) {
        const {
          lastRequestParameters
        } = this.state;
        if (lastRequestParameters) {
          var _this$state$imageSour, _this$state$imageSour2;
          const featureInfo = await ((_this$state$imageSour = (_this$state$imageSour2 = this.state.imageSource).getFeatureInfoText) === null || _this$state$imageSour === void 0 ? void 0 : _this$state$imageSour.call(_this$state$imageSour2, {
            ...lastRequestParameters,
            query_layers: lastRequestParameters.layers,
            x,
            y,
            info_format: "application/vnd.ogc.gml"
          }));
          return featureInfo;
        }
        return "";
      }
      _createImageSource(props) {
        if (props.data instanceof ImageSource) {
          return props.data;
        }
        if (typeof props.data === "string") {
          return createImageSource({
            url: props.data,
            loadOptions: props.loadOptions,
            type: props.serviceType
          });
        }
        throw new Error("invalid image source in props.data");
      }
      async _loadMetadata() {
        const {
          imageSource
        } = this.state;
        try {
          this.state.loadCounter++;
          const metadata = await imageSource.getMetadata();
          if (this.state.imageSource === imageSource) {
            var _this$getCurrentLayer;
            (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onMetadataLoad(metadata);
          }
        } catch (error) {
          var _this$getCurrentLayer2;
          (_this$getCurrentLayer2 = this.getCurrentLayer()) === null || _this$getCurrentLayer2 === void 0 ? void 0 : _this$getCurrentLayer2.props.onMetadataLoadError(error);
        } finally {
          this.state.loadCounter--;
        }
      }
      async loadImage(viewport, reason) {
        const {
          layers,
          serviceType
        } = this.props;
        if (serviceType === "wms" && layers.length === 0) {
          return;
        }
        const bounds = viewport.getBounds();
        const {
          width,
          height
        } = viewport;
        const requestId = this.getRequestId();
        let {
          srs
        } = this.props;
        if (srs === "auto") {
          srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
        }
        const requestParams = {
          width,
          height,
          bbox: bounds,
          layers,
          srs
        };
        if (srs === "EPSG:3857") {
          const [minX, minY] = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
          const [maxX, maxY] = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
          requestParams.bbox = [minX, minY, maxX, maxY];
        }
        try {
          this.state.loadCounter++;
          this.props.onImageLoadStart(requestId);
          const image = await this.state.imageSource.getImage(requestParams);
          if (this.state.lastRequestId < requestId) {
            var _this$getCurrentLayer3;
            (_this$getCurrentLayer3 = this.getCurrentLayer()) === null || _this$getCurrentLayer3 === void 0 ? void 0 : _this$getCurrentLayer3.props.onImageLoad(requestId);
            this.setState({
              image,
              bounds,
              lastRequestParameters: requestParams,
              lastRequestId: requestId
            });
          }
        } catch (error) {
          var _this$getCurrentLayer4;
          this.raiseError(error, "Load image");
          (_this$getCurrentLayer4 = this.getCurrentLayer()) === null || _this$getCurrentLayer4 === void 0 ? void 0 : _this$getCurrentLayer4.props.onImageLoadError(requestId, error);
        } finally {
          this.state.loadCounter--;
        }
      }
      getRequestId() {
        return this.state._nextRequestId++;
      }
      debounce(fn, ms = 500) {
        clearTimeout(this.state._timeoutId);
        this.state._timeoutId = setTimeout(() => fn(), ms);
      }
    };
    _defineProperty(WMSLayer, "layerName", "WMSLayer");
    _defineProperty(WMSLayer, "defaultProps", defaultProps);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/great-circle-layer/great-circle-layer.js
var defaultProps2, GreatCircleLayer;
var init_great_circle_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/great-circle-layer/great-circle-layer.js"() {
    init_defineProperty();
    init_esm9();
    defaultProps2 = {
      getHeight: {
        type: "accessor",
        value: 0
      },
      greatCircle: true
    };
    GreatCircleLayer = class extends ArcLayer {
    };
    _defineProperty(GreatCircleLayer, "layerName", "GreatCircleLayer");
    _defineProperty(GreatCircleLayer, "defaultProps", defaultProps2);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/geo-cell-layer/GeoCellLayer.js
var defaultProps3, GeoCellLayer;
var init_GeoCellLayer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/geo-cell-layer/GeoCellLayer.js"() {
    init_defineProperty();
    init_esm8();
    init_esm9();
    defaultProps3 = {
      ...PolygonLayer.defaultProps
    };
    GeoCellLayer = class extends CompositeLayer {
      indexToBounds() {
        return null;
      }
      renderLayers() {
        const {
          elevationScale,
          extruded,
          wireframe,
          filled,
          stroked,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          lineJointRounded,
          lineMiterLimit,
          lineDashJustified,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        } = this.props;
        const {
          updateTriggers,
          material,
          transitions
        } = this.props;
        const CellLayer = this.getSubLayerClass("cell", PolygonLayer);
        return new CellLayer({
          filled,
          wireframe,
          extruded,
          elevationScale,
          stroked,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          lineJointRounded,
          lineMiterLimit,
          lineDashJustified,
          material,
          transitions,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        }, this.getSubLayerProps({
          id: "cell",
          updateTriggers: updateTriggers && {
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor,
            getLineWidth: updateTriggers.getLineWidth
          }
        }), this.indexToBounds());
      }
    };
    _defineProperty(GeoCellLayer, "layerName", "GeoCellLayer");
    _defineProperty(GeoCellLayer, "defaultProps", defaultProps3);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-geometry.js
function IJToST(ij, order, offsets) {
  const maxSize = 1 << order;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV(st) {
  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
}
function FaceUVToXYZ(face, [u, v]) {
  switch (face) {
    case 0:
      return [1, u, v];
    case 1:
      return [-u, 1, v];
    case 2:
      return [-u, -v, 1];
    case 3:
      return [-1, -v, -u];
    case 4:
      return [v, -1, -u];
    case 5:
      return [v, u, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat([x, y, z]) {
  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
  const lng = Math.atan2(y, x);
  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
}
function toHilbertQuadkey(idS) {
  let bin = import_long.default.fromString(idS, true, 10).toString(2);
  while (bin.length < FACE_BITS + POS_BITS) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
  let posS = import_long.default.fromString(posB, true, 2).toString(4);
  while (posS.length < levelN) {
    posS = "0" + posS;
  }
  return "".concat(faceS, "/").concat(posS);
}
function rotateAndFlipQuadrant(n, point, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point[0] = n - 1 - point[0];
      point[1] = n - 1 - point[1];
    }
    const x = point[0];
    point[0] = point[1];
    point[1] = x;
  }
}
function FromHilbertQuadKey(hilbertQuadkey) {
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  const point = [0, 0];
  let level;
  for (let i = maxLevel - 1; i >= 0; i--) {
    level = maxLevel - i;
    const bit = position[i];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val = Math.pow(2, level - 1);
    rotateAndFlipQuadrant(val, point, rx, ry);
    point[0] += val * rx;
    point[1] += val * ry;
  }
  if (face % 2 === 1) {
    const t = point[0];
    point[0] = point[1];
    point[1] = t;
  }
  return {
    face,
    ij: point,
    level
  };
}
var import_long, FACE_BITS, MAX_LEVEL, POS_BITS, RADIAN_TO_DEGREE;
var init_s2_geometry = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-geometry.js"() {
    import_long = __toESM(require_long());
    FACE_BITS = 3;
    MAX_LEVEL = 30;
    POS_BITS = 2 * MAX_LEVEL + 1;
    RADIAN_TO_DEGREE = 180 / Math.PI;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-utils.js
function getIdFromToken(token) {
  const paddedToken = token.padEnd(16, "0");
  return import_long2.default.fromString(paddedToken, 16);
}
function getGeoBounds({
  face,
  ij,
  level
}) {
  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i = 0; i < 4; i++) {
    const offset = offsets[i].slice(0);
    const nextOffset = offsets[i + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST(ij, level, offset);
      const uv = STToUV(st);
      const xyz = FaceUVToXYZ(face, uv);
      const lngLat = XYZToLngLat(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}
function getS2QuadKey(token) {
  if (typeof token === "string") {
    if (token.indexOf("/") > 0) {
      return token;
    }
    token = getIdFromToken(token);
  }
  return toHilbertQuadkey(token.toString());
}
function getS2Polygon(token) {
  const key = getS2QuadKey(token);
  const s2cell = FromHilbertQuadKey(key);
  return getGeoBounds(s2cell);
}
var import_long2, MAX_RESOLUTION;
var init_s2_utils = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-utils.js"() {
    init_s2_geometry();
    import_long2 = __toESM(require_long());
    MAX_RESOLUTION = 100;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-layer.js
var defaultProps4, S2Layer;
var init_s2_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-layer.js"() {
    init_defineProperty();
    init_GeoCellLayer();
    init_s2_utils();
    defaultProps4 = {
      getS2Token: {
        type: "accessor",
        value: (d) => d.token
      }
    };
    S2Layer = class extends GeoCellLayer {
      indexToBounds() {
        const {
          data,
          getS2Token
        } = this.props;
        return {
          data,
          _normalize: false,
          positionFormat: "XY",
          getPolygon: (x, objectInfo) => getS2Polygon(getS2Token(x, objectInfo))
        };
      }
    };
    _defineProperty(S2Layer, "layerName", "S2Layer");
    _defineProperty(S2Layer, "defaultProps", defaultProps4);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-utils.js
function quadkeyToWorldBounds(quadkey) {
  let x = 0;
  let y = 0;
  let mask = 1 << quadkey.length;
  const scale = mask / TILE_SIZE;
  for (let i = 0; i < quadkey.length; i++) {
    mask >>= 1;
    const q = parseInt(quadkey[i]);
    if (q % 2)
      x |= mask;
    if (q > 1)
      y |= mask;
  }
  return [[x / scale, TILE_SIZE - y / scale], [(x + 0.99) / scale, TILE_SIZE - (y + 0.99) / scale]];
}
function getQuadkeyPolygon(quadkey) {
  const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey);
  const [w, n] = worldToLngLat(topLeft);
  const [e, s] = worldToLngLat(bottomRight);
  return [e, n, e, s, w, s, w, n, e, n];
}
var TILE_SIZE;
var init_quadkey_utils = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-utils.js"() {
    init_esm7();
    TILE_SIZE = 512;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-layer.js
var defaultProps5, QuadkeyLayer;
var init_quadkey_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-layer.js"() {
    init_defineProperty();
    init_GeoCellLayer();
    init_quadkey_utils();
    defaultProps5 = {
      getQuadkey: {
        type: "accessor",
        value: (d) => d.quadkey
      }
    };
    QuadkeyLayer = class extends GeoCellLayer {
      indexToBounds() {
        const {
          data,
          getQuadkey
        } = this.props;
        return {
          data,
          _normalize: false,
          positionFormat: "XY",
          getPolygon: (x, objectInfo) => getQuadkeyPolygon(getQuadkey(x, objectInfo))
        };
      }
    };
    _defineProperty(QuadkeyLayer, "layerName", "QuadkeyLayer");
    _defineProperty(QuadkeyLayer, "defaultProps", defaultProps5);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-header.js
var Tile2DHeader;
var init_tile_2d_header = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-header.js"() {
    init_defineProperty();
    Tile2DHeader = class {
      constructor(index) {
        _defineProperty(this, "index", void 0);
        _defineProperty(this, "isVisible", void 0);
        _defineProperty(this, "isSelected", void 0);
        _defineProperty(this, "parent", void 0);
        _defineProperty(this, "children", void 0);
        _defineProperty(this, "content", void 0);
        _defineProperty(this, "state", void 0);
        _defineProperty(this, "layers", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "zoom", void 0);
        _defineProperty(this, "userData", void 0);
        _defineProperty(this, "boundingBox", void 0);
        _defineProperty(this, "_abortController", void 0);
        _defineProperty(this, "_loader", void 0);
        _defineProperty(this, "_loaderId", void 0);
        _defineProperty(this, "_isLoaded", void 0);
        _defineProperty(this, "_isCancelled", void 0);
        _defineProperty(this, "_needsReload", void 0);
        _defineProperty(this, "_bbox", void 0);
        this.index = index;
        this.isVisible = false;
        this.isSelected = false;
        this.parent = null;
        this.children = [];
        this.content = null;
        this._loader = void 0;
        this._abortController = null;
        this._loaderId = 0;
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
      }
      get bbox() {
        return this._bbox;
      }
      set bbox(value) {
        if (this._bbox)
          return;
        this._bbox = value;
        if ("west" in value) {
          this.boundingBox = [[value.west, value.south], [value.east, value.north]];
        } else {
          this.boundingBox = [[value.left, value.top], [value.right, value.bottom]];
        }
      }
      get data() {
        return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
      }
      get isLoaded() {
        return this._isLoaded && !this._needsReload;
      }
      get isLoading() {
        return Boolean(this._loader) && !this._isCancelled;
      }
      get needsReload() {
        return this._needsReload || this._isCancelled;
      }
      get byteLength() {
        const result = this.content ? this.content.byteLength : 0;
        if (!Number.isFinite(result)) {
          console.error("byteLength not defined in tile data");
        }
        return result;
      }
      async _loadData({
        getData,
        requestScheduler,
        onLoad,
        onError
      }) {
        const {
          index,
          id,
          bbox,
          userData,
          zoom
        } = this;
        const loaderId = this._loaderId;
        this._abortController = new AbortController();
        const {
          signal
        } = this._abortController;
        const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
          return tile.isSelected ? 1 : -1;
        });
        if (!requestToken) {
          this._isCancelled = true;
          return;
        }
        if (this._isCancelled) {
          requestToken.done();
          return;
        }
        let tileData = null;
        let error;
        try {
          tileData = await getData({
            index,
            id,
            bbox,
            userData,
            zoom,
            signal
          });
        } catch (err) {
          error = err || true;
        } finally {
          requestToken.done();
        }
        if (loaderId !== this._loaderId) {
          return;
        }
        this._loader = void 0;
        this.content = tileData;
        if (this._isCancelled && !tileData) {
          this._isLoaded = false;
          return;
        }
        this._isLoaded = true;
        this._isCancelled = false;
        if (error) {
          onError(error, this);
        } else {
          onLoad(this);
        }
      }
      loadData(opts) {
        this._isLoaded = false;
        this._isCancelled = false;
        this._needsReload = false;
        this._loaderId++;
        this._loader = this._loadData(opts);
        return this._loader;
      }
      setNeedsReload() {
        if (this.isLoading) {
          this.abort();
          this._loader = void 0;
        }
        this._needsReload = true;
      }
      abort() {
        var _this$_abortControlle;
        if (this.isLoaded) {
          return;
        }
        this._isCancelled = true;
        (_this$_abortControlle = this._abortController) === null || _this$_abortControlle === void 0 ? void 0 : _this$_abortControlle.abort();
      }
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-traversal.js
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
  const project = viewport instanceof GlobeViewport && viewport.resolution ? viewport.projectPosition : null;
  const planes = Object.values(viewport.getFrustumPlanes()).map(({
    normal,
    distance
  }) => new Plane(normal.clone().negate(), distance));
  const cullingVolume = new CullingVolume(planes);
  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
  const minZ = viewport instanceof WebMercatorViewport && viewport.pitch <= 60 ? maxZ : 0;
  if (bounds) {
    const [minLng, minLat, maxLng, maxLat] = bounds;
    const topLeft = lngLatToWorld([minLng, maxLat]);
    const bottomRight = lngLatToWorld([maxLng, minLat]);
    bounds = [topLeft[0], TILE_SIZE2 - topLeft[1], bottomRight[0], TILE_SIZE2 - bottomRight[1]];
  }
  const root = new OSMNode(0, 0, 0);
  const traversalParams = {
    viewport,
    project,
    cullingVolume,
    elevationBounds: [elevationMin, elevationMax],
    minZ,
    maxZ,
    bounds,
    offset: 0
  };
  root.update(traversalParams);
  if (viewport instanceof WebMercatorViewport && viewport.subViewports && viewport.subViewports.length > 1) {
    traversalParams.offset = -1;
    while (root.update(traversalParams)) {
      if (--traversalParams.offset < -MAX_MAPS) {
        break;
      }
    }
    traversalParams.offset = 1;
    while (root.update(traversalParams)) {
      if (++traversalParams.offset > MAX_MAPS) {
        break;
      }
    }
  }
  return root.getSelected();
}
var TILE_SIZE2, MAX_MAPS, REF_POINTS_5, REF_POINTS_9, REF_POINTS_11, OSMNode;
var init_tile_2d_traversal = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-traversal.js"() {
    init_defineProperty();
    init_esm8();
    init_esm11();
    init_esm7();
    init_utils2();
    TILE_SIZE2 = 512;
    MAX_MAPS = 3;
    REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];
    REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);
    REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);
    OSMNode = class {
      constructor(x, y, z) {
        _defineProperty(this, "x", void 0);
        _defineProperty(this, "y", void 0);
        _defineProperty(this, "z", void 0);
        _defineProperty(this, "childVisible", void 0);
        _defineProperty(this, "selected", void 0);
        _defineProperty(this, "_children", void 0);
        this.x = x;
        this.y = y;
        this.z = z;
      }
      get children() {
        if (!this._children) {
          const x = this.x * 2;
          const y = this.y * 2;
          const z = this.z + 1;
          this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];
        }
        return this._children;
      }
      update(params) {
        const {
          viewport,
          cullingVolume,
          elevationBounds,
          minZ,
          maxZ,
          bounds,
          offset,
          project
        } = params;
        const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);
        if (bounds && !this.insideBounds(bounds)) {
          return false;
        }
        const isInside = cullingVolume.computeVisibility(boundingVolume);
        if (isInside < 0) {
          return false;
        }
        if (!this.childVisible) {
          let {
            z
          } = this;
          if (z < maxZ && z >= minZ) {
            const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
            z += Math.floor(Math.log2(distance));
          }
          if (z >= maxZ) {
            this.selected = true;
            return true;
          }
        }
        this.selected = false;
        this.childVisible = true;
        for (const child of this.children) {
          child.update(params);
        }
        return true;
      }
      getSelected(result = []) {
        if (this.selected) {
          result.push(this);
        }
        if (this._children) {
          for (const node of this._children) {
            node.getSelected(result);
          }
        }
        return result;
      }
      insideBounds([minX, minY, maxX, maxY]) {
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE2 / scale;
        return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
      }
      getBoundingVolume(zRange, worldOffset, project) {
        if (project) {
          const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
          const refPointPositions = [];
          for (const p of refPoints) {
            const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);
            lngLat[2] = zRange[0];
            refPointPositions.push(project(lngLat));
            if (zRange[0] !== zRange[1]) {
              lngLat[2] = zRange[1];
              refPointPositions.push(project(lngLat));
            }
          }
          return makeOrientedBoundingBoxFromPoints(refPointPositions);
        }
        const scale = Math.pow(2, this.z);
        const extent = TILE_SIZE2 / scale;
        const originX = this.x * extent + worldOffset * TILE_SIZE2;
        const originY = TILE_SIZE2 - (this.y + 1) * extent;
        return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
      }
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/utils.js
function transformBox(bbox, modelMatrix2) {
  const transformedCoords = [modelMatrix2.transformAsPoint([bbox[0], bbox[1]]), modelMatrix2.transformAsPoint([bbox[2], bbox[1]]), modelMatrix2.transformAsPoint([bbox[0], bbox[3]]), modelMatrix2.transformAsPoint([bbox[2], bbox[3]])];
  const transformedBox = [Math.min(...transformedCoords.map((i) => i[0])), Math.min(...transformedCoords.map((i) => i[1])), Math.max(...transformedCoords.map((i) => i[0])), Math.max(...transformedCoords.map((i) => i[1]))];
  return transformedBox;
}
function stringHash(s) {
  return Math.abs(s.split("").reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
  if (!template || !template.length) {
    return null;
  }
  const {
    index,
    id
  } = tile;
  if (Array.isArray(template)) {
    const i = stringHash(id) % template.length;
    template = template[i];
  }
  let url = template;
  for (const key of Object.keys(index)) {
    const regex = new RegExp("{".concat(key, "}"), "g");
    url = url.replace(regex, String(index[key]));
  }
  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
  }
  return url;
}
function getBoundingBox(viewport, zRange, extent) {
  let bounds;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({
      z: minZ
    });
    const bounds1 = viewport.getBounds({
      z: maxZ
    });
    bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  } else {
    bounds = viewport.getBounds();
  }
  if (!viewport.isGeospatial) {
    return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];
  }
  return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];
}
function getCullBounds({
  viewport,
  z = 0,
  cullRect
}) {
  const subViewports = viewport.subViewports || [viewport];
  return subViewports.map((v) => getCullBoundsInViewport(v, z, cullRect));
}
function getCullBoundsInViewport(viewport, z, cullRect) {
  if (!Array.isArray(z)) {
    const x = cullRect.x - viewport.x;
    const y = cullRect.y - viewport.y;
    const {
      width,
      height
    } = cullRect;
    const unprojectOption = {
      targetZ: z
    };
    const topLeft = viewport.unproject([x, y], unprojectOption);
    const topRight = viewport.unproject([x + width, y], unprojectOption);
    const bottomLeft = viewport.unproject([x, y + height], unprojectOption);
    const bottomRight = viewport.unproject([x + width, y + height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }
  const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
  const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
  return [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
}
function getIndexingCoords(bbox, scale, modelMatrixInverse) {
  if (modelMatrixInverse) {
    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i) => i * scale / TILE_SIZE3);
    return transformedTileIndex;
  }
  return bbox.map((i) => i * scale / TILE_SIZE3);
}
function getScale(z, tileSize) {
  return Math.pow(2, z) * TILE_SIZE3 / tileSize;
}
function osmTile2lngLat(x, y, z) {
  const scale = getScale(z, TILE_SIZE3);
  const lng = x / scale * 360 - 180;
  const n = Math.PI - 2 * Math.PI * y / scale;
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lng, lat];
}
function tile2XY(x, y, z, tileSize) {
  const scale = getScale(z, tileSize);
  return [x / scale * TILE_SIZE3, y / scale * TILE_SIZE3];
}
function tileToBoundingBox(viewport, x, y, z, tileSize = TILE_SIZE3) {
  if (viewport.isGeospatial) {
    const [west, north] = osmTile2lngLat(x, y, z);
    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);
    return {
      west,
      north,
      east,
      south
    };
  }
  const [left, top] = tile2XY(x, y, z, tileSize);
  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);
  return {
    left,
    top,
    right,
    bottom
  };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
  const bbox = getBoundingBox(viewport, null, extent);
  const scale = getScale(z, tileSize);
  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);
  const indices = [];
  for (let x = Math.floor(minX); x < maxX; x++) {
    for (let y = Math.floor(minY); y < maxY; y++) {
      indices.push({
        x,
        y,
        z
      });
    }
  }
  return indices;
}
function getTileIndices({
  viewport,
  maxZoom,
  minZoom,
  zRange,
  extent,
  tileSize = TILE_SIZE3,
  modelMatrix: modelMatrix2,
  modelMatrixInverse,
  zoomOffset = 0
}) {
  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE3 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
  if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
    if (!extent) {
      return [];
    }
    z = minZoom;
  }
  if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  let transformedExtent = extent;
  if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
    transformedExtent = transformBox(extent, modelMatrix2);
  }
  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);
}
function isGeoBoundingBox(v) {
  return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
}
var TILE_SIZE3, DEFAULT_EXTENT, urlType;
var init_utils2 = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/utils.js"() {
    init_tile_2d_traversal();
    TILE_SIZE3 = 512;
    DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
    urlType = {
      type: "object",
      value: null,
      validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
      equal: (value1, value2) => {
        if (value1 === value2) {
          return true;
        }
        if (!Array.isArray(value1) || !Array.isArray(value2)) {
          return false;
        }
        const len = value1.length;
        if (len !== value2.length) {
          return false;
        }
        for (let i = 0; i < len; i++) {
          if (value1[i] !== value2[i]) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/memoize.js
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a)) {
    const len = a.length;
    if (!b || b.length !== len) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var init_memoize = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/memoize.js"() {
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tileset-2d.js
function updateTileStateDefault(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  }
  for (const tile of allTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
  }
}
function updateTileStateReplace(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected) {
      getPlaceholderInAncestors(tile);
    }
  }
  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
  for (const tile of sortedTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
      for (const child of tile.children) {
        child.state = TILE_STATE_VISITED;
      }
    } else if (tile.isSelected) {
      getPlaceholderInChildren(tile);
    }
  }
}
function getPlaceholderInAncestors(startTile) {
  let tile = startTile;
  while (tile) {
    if (tile.isLoaded || tile.content) {
      tile.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  for (const child of tile.children) {
    if (child.isLoaded || child.content) {
      child.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  }
}
var TILE_STATE_VISITED, TILE_STATE_VISIBLE, STRATEGY_NEVER, STRATEGY_REPLACE, STRATEGY_DEFAULT, DEFAULT_CACHE_SCALE, STRATEGIES, DEFAULT_TILESET2D_PROPS, Tileset2D;
var init_tileset_2d = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tileset-2d.js"() {
    init_defineProperty();
    init_esm();
    init_esm4();
    init_tile_2d_header();
    init_utils2();
    init_memoize();
    TILE_STATE_VISITED = 1;
    TILE_STATE_VISIBLE = 2;
    STRATEGY_NEVER = "never";
    STRATEGY_REPLACE = "no-overlap";
    STRATEGY_DEFAULT = "best-available";
    DEFAULT_CACHE_SCALE = 5;
    STRATEGIES = {
      [STRATEGY_DEFAULT]: updateTileStateDefault,
      [STRATEGY_REPLACE]: updateTileStateReplace,
      [STRATEGY_NEVER]: () => {
      }
    };
    DEFAULT_TILESET2D_PROPS = {
      extent: null,
      tileSize: 512,
      maxZoom: null,
      minZoom: null,
      maxCacheSize: null,
      maxCacheByteSize: null,
      refinementStrategy: "best-available",
      zRange: null,
      maxRequests: 6,
      zoomOffset: 0,
      onTileLoad: () => {
      },
      onTileUnload: () => {
      },
      onTileError: () => {
      }
    };
    Tileset2D = class {
      constructor(opts) {
        _defineProperty(this, "opts", void 0);
        _defineProperty(this, "_requestScheduler", void 0);
        _defineProperty(this, "_cache", void 0);
        _defineProperty(this, "_dirty", void 0);
        _defineProperty(this, "_tiles", void 0);
        _defineProperty(this, "_cacheByteSize", void 0);
        _defineProperty(this, "_viewport", void 0);
        _defineProperty(this, "_zRange", void 0);
        _defineProperty(this, "_selectedTiles", void 0);
        _defineProperty(this, "_frameNumber", void 0);
        _defineProperty(this, "_modelMatrix", void 0);
        _defineProperty(this, "_modelMatrixInverse", void 0);
        _defineProperty(this, "_maxZoom", void 0);
        _defineProperty(this, "_minZoom", void 0);
        _defineProperty(this, "onTileLoad", void 0);
        _defineProperty(this, "_getCullBounds", memoize2(getCullBounds));
        this.opts = {
          ...DEFAULT_TILESET2D_PROPS,
          ...opts
        };
        this.onTileLoad = (tile) => {
          var _this$opts$onTileLoad, _this$opts;
          (_this$opts$onTileLoad = (_this$opts = this.opts).onTileLoad) === null || _this$opts$onTileLoad === void 0 ? void 0 : _this$opts$onTileLoad.call(_this$opts, tile);
          if (this.opts.maxCacheByteSize) {
            this._cacheByteSize += tile.byteLength;
            this._resizeCache();
          }
        };
        this._requestScheduler = new RequestScheduler({
          maxRequests: opts.maxRequests,
          throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)
        });
        this._cache = /* @__PURE__ */ new Map();
        this._tiles = [];
        this._dirty = false;
        this._cacheByteSize = 0;
        this._viewport = null;
        this._selectedTiles = null;
        this._frameNumber = 0;
        this._modelMatrix = new Matrix4();
        this._modelMatrixInverse = new Matrix4();
        this.setOptions(opts);
      }
      get tiles() {
        return this._tiles;
      }
      get selectedTiles() {
        return this._selectedTiles;
      }
      get isLoaded() {
        return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
      }
      get needsReload() {
        return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
      }
      setOptions(opts) {
        Object.assign(this.opts, opts);
        if (Number.isFinite(opts.maxZoom)) {
          this._maxZoom = Math.floor(opts.maxZoom);
        }
        if (Number.isFinite(opts.minZoom)) {
          this._minZoom = Math.ceil(opts.minZoom);
        }
      }
      finalize() {
        for (const tile of this._cache.values()) {
          if (tile.isLoading) {
            tile.abort();
          }
        }
        this._cache.clear();
        this._tiles = [];
        this._selectedTiles = null;
      }
      reloadAll() {
        for (const id of this._cache.keys()) {
          const tile = this._cache.get(id);
          if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
            this._cache.delete(id);
          } else {
            tile.setNeedsReload();
          }
        }
      }
      update(viewport, {
        zRange,
        modelMatrix: modelMatrix2
      } = {}) {
        const modelMatrixAsMatrix4 = new Matrix4(modelMatrix2);
        const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
        if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
          if (isModelMatrixNew) {
            this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
            this._modelMatrix = modelMatrixAsMatrix4;
          }
          this._viewport = viewport;
          this._zRange = zRange;
          const tileIndices = this.getTileIndices({
            viewport,
            maxZoom: this._maxZoom,
            minZoom: this._minZoom,
            zRange,
            modelMatrix: this._modelMatrix,
            modelMatrixInverse: this._modelMatrixInverse
          });
          this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
          if (this._dirty) {
            this._rebuildTree();
          }
        } else if (this.needsReload) {
          this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
        }
        const changed = this.updateTileStates();
        this._pruneRequests();
        if (this._dirty) {
          this._resizeCache();
        }
        if (changed) {
          this._frameNumber++;
        }
        return this._frameNumber;
      }
      isTileVisible(tile, cullRect) {
        if (!tile.isVisible) {
          return false;
        }
        if (cullRect && this._viewport) {
          const boundsArr = this._getCullBounds({
            viewport: this._viewport,
            z: this._zRange,
            cullRect
          });
          const {
            bbox
          } = tile;
          for (const [minX, minY, maxX, maxY] of boundsArr) {
            let overlaps;
            if ("west" in bbox) {
              overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
            } else {
              const y0 = Math.min(bbox.top, bbox.bottom);
              const y1 = Math.max(bbox.top, bbox.bottom);
              overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
            }
            if (overlaps) {
              return true;
            }
          }
          return false;
        }
        return true;
      }
      getTileIndices({
        viewport,
        maxZoom,
        minZoom,
        zRange,
        modelMatrix: modelMatrix2,
        modelMatrixInverse
      }) {
        const {
          tileSize,
          extent,
          zoomOffset
        } = this.opts;
        return getTileIndices({
          viewport,
          maxZoom,
          minZoom,
          zRange,
          tileSize,
          extent,
          modelMatrix: modelMatrix2,
          modelMatrixInverse,
          zoomOffset
        });
      }
      getTileId(index) {
        return "".concat(index.x, "-").concat(index.y, "-").concat(index.z);
      }
      getTileZoom(index) {
        return index.z;
      }
      getTileMetadata(index) {
        const {
          tileSize
        } = this.opts;
        return {
          bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)
        };
      }
      getParentIndex(index) {
        const x = Math.floor(index.x / 2);
        const y = Math.floor(index.y / 2);
        const z = index.z - 1;
        return {
          x,
          y,
          z
        };
      }
      updateTileStates() {
        const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
        const visibilities = new Array(this._cache.size);
        let i = 0;
        for (const tile of this._cache.values()) {
          visibilities[i++] = tile.isVisible;
          tile.isSelected = false;
          tile.isVisible = false;
        }
        for (const tile of this._selectedTiles) {
          tile.isSelected = true;
          tile.isVisible = true;
        }
        (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
        i = 0;
        for (const tile of this._cache.values()) {
          if (visibilities[i++] !== tile.isVisible) {
            return true;
          }
        }
        return false;
      }
      _pruneRequests() {
        const {
          maxRequests = 0
        } = this.opts;
        const abortCandidates = [];
        let ongoingRequestCount = 0;
        for (const tile of this._cache.values()) {
          if (tile.isLoading) {
            ongoingRequestCount++;
            if (!tile.isSelected && !tile.isVisible) {
              abortCandidates.push(tile);
            }
          }
        }
        while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
          const tile = abortCandidates.shift();
          tile.abort();
          ongoingRequestCount--;
        }
      }
      _rebuildTree() {
        const {
          _cache
        } = this;
        for (const tile of _cache.values()) {
          tile.parent = null;
          if (tile.children) {
            tile.children.length = 0;
          }
        }
        for (const tile of _cache.values()) {
          const parent = this._getNearestAncestor(tile);
          tile.parent = parent;
          if (parent !== null && parent !== void 0 && parent.children) {
            parent.children.push(tile);
          }
        }
      }
      _resizeCache() {
        const {
          _cache,
          opts
        } = this;
        const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
        const maxCacheByteSize = opts.maxCacheByteSize || Infinity;
        const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
        if (overflown) {
          for (const [id, tile] of _cache) {
            if (!tile.isVisible && !tile.isSelected) {
              var _this$opts$onTileUnlo, _this$opts2;
              this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
              _cache.delete(id);
              (_this$opts$onTileUnlo = (_this$opts2 = this.opts).onTileUnload) === null || _this$opts$onTileUnlo === void 0 ? void 0 : _this$opts$onTileUnlo.call(_this$opts2, tile);
            }
            if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
              break;
            }
          }
          this._rebuildTree();
          this._dirty = true;
        }
        if (this._dirty) {
          this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
          this._dirty = false;
        }
      }
      _getTile(index, create) {
        const id = this.getTileId(index);
        let tile = this._cache.get(id);
        let needsReload = false;
        if (!tile && create) {
          tile = new Tile2DHeader(index);
          Object.assign(tile, this.getTileMetadata(tile.index));
          Object.assign(tile, {
            id,
            zoom: this.getTileZoom(tile.index)
          });
          needsReload = true;
          this._cache.set(id, tile);
          this._dirty = true;
        } else if (tile && tile.needsReload) {
          needsReload = true;
        }
        if (tile && needsReload) {
          tile.loadData({
            getData: this.opts.getTileData,
            requestScheduler: this._requestScheduler,
            onLoad: this.onTileLoad,
            onError: this.opts.onTileError
          });
        }
        return tile;
      }
      _getNearestAncestor(tile) {
        const {
          _minZoom = 0
        } = this;
        let index = tile.index;
        while (this.getTileZoom(index) > _minZoom) {
          index = this.getParentIndex(index);
          const parent = this._getTile(index);
          if (parent) {
            return parent;
          }
        }
        return null;
      }
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/index.js
var init_tileset_2d2 = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/index.js"() {
    init_tileset_2d();
    init_tile_2d_header();
    init_utils2();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-layer.js
var defaultProps6, TileLayer;
var init_tile_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-layer.js"() {
    init_defineProperty();
    init_esm8();
    init_esm9();
    init_tileset_2d2();
    init_tileset_2d2();
    defaultProps6 = {
      TilesetClass: Tileset2D,
      data: {
        type: "data",
        value: []
      },
      dataComparator: urlType.equal,
      renderSubLayers: {
        type: "function",
        value: (props) => new GeoJsonLayer(props)
      },
      getTileData: {
        type: "function",
        optional: true,
        value: null
      },
      onViewportLoad: {
        type: "function",
        optional: true,
        value: null
      },
      onTileLoad: {
        type: "function",
        value: (tile) => {
        }
      },
      onTileUnload: {
        type: "function",
        value: (tile) => {
        }
      },
      onTileError: {
        type: "function",
        value: (err) => console.error(err)
      },
      extent: {
        type: "array",
        optional: true,
        value: null,
        compare: true
      },
      tileSize: 512,
      maxZoom: null,
      minZoom: 0,
      maxCacheSize: null,
      maxCacheByteSize: null,
      refinementStrategy: STRATEGY_DEFAULT,
      zRange: null,
      maxRequests: 6,
      zoomOffset: 0
    };
    TileLayer = class extends CompositeLayer {
      initializeState() {
        this.state = {
          tileset: null,
          isLoaded: false
        };
      }
      finalizeState() {
        var _this$state, _this$state$tileset;
        (_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$tileset = _this$state.tileset) === null || _this$state$tileset === void 0 ? void 0 : _this$state$tileset.finalize();
      }
      get isLoaded() {
        var _this$state2, _this$state2$tileset;
        return (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : (_this$state2$tileset = _this$state2.tileset) === null || _this$state2$tileset === void 0 ? void 0 : _this$state2$tileset.selectedTiles.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded));
      }
      shouldUpdateState({
        changeFlags
      }) {
        return changeFlags.somethingChanged;
      }
      updateState({
        changeFlags
      }) {
        let {
          tileset
        } = this.state;
        const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
        const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
        if (!tileset) {
          tileset = new this.props.TilesetClass(this._getTilesetOptions());
          this.setState({
            tileset
          });
        } else if (propsChanged) {
          tileset.setOptions(this._getTilesetOptions());
          if (dataChanged) {
            tileset.reloadAll();
          } else {
            this.state.tileset.tiles.forEach((tile) => {
              tile.layers = null;
            });
          }
        }
        this._updateTileset();
      }
      _getTilesetOptions() {
        const {
          tileSize,
          maxCacheSize,
          maxCacheByteSize,
          refinementStrategy,
          extent,
          maxZoom,
          minZoom,
          maxRequests,
          zoomOffset
        } = this.props;
        return {
          maxCacheSize,
          maxCacheByteSize,
          maxZoom,
          minZoom,
          tileSize,
          refinementStrategy,
          extent,
          maxRequests,
          zoomOffset,
          getTileData: this.getTileData.bind(this),
          onTileLoad: this._onTileLoad.bind(this),
          onTileError: this._onTileError.bind(this),
          onTileUnload: this._onTileUnload.bind(this)
        };
      }
      _updateTileset() {
        const {
          tileset
        } = this.state;
        const {
          zRange,
          modelMatrix: modelMatrix2
        } = this.props;
        const frameNumber = tileset.update(this.context.viewport, {
          zRange,
          modelMatrix: modelMatrix2
        });
        const {
          isLoaded
        } = tileset;
        const loadingStateChanged = this.state.isLoaded !== isLoaded;
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (isLoaded && (loadingStateChanged || tilesetChanged)) {
          this._onViewportLoad();
        }
        if (tilesetChanged) {
          this.setState({
            frameNumber
          });
        }
        this.state.isLoaded = isLoaded;
      }
      _onViewportLoad() {
        const {
          tileset
        } = this.state;
        const {
          onViewportLoad
        } = this.props;
        if (onViewportLoad) {
          onViewportLoad(tileset.selectedTiles);
        }
      }
      _onTileLoad(tile) {
        this.props.onTileLoad(tile);
        tile.layers = null;
        this.setNeedsUpdate();
      }
      _onTileError(error, tile) {
        this.props.onTileError(error);
        tile.layers = null;
        this.setNeedsUpdate();
      }
      _onTileUnload(tile) {
        this.props.onTileUnload(tile);
      }
      getTileData(tile) {
        const {
          data,
          getTileData,
          fetch
        } = this.props;
        const {
          signal
        } = tile;
        tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
        if (getTileData) {
          return getTileData(tile);
        }
        if (fetch && tile.url) {
          return fetch(tile.url, {
            propName: "data",
            layer: this,
            signal
          });
        }
        return null;
      }
      renderSubLayers(props) {
        return this.props.renderSubLayers(props);
      }
      getSubLayerPropsByTile(tile) {
        return null;
      }
      getPickingInfo({
        info,
        sourceLayer
      }) {
        const sourceTile = sourceLayer.props.tile;
        if (info.picked) {
          info.tile = sourceTile;
        }
        info.sourceTile = sourceTile;
        return info;
      }
      _updateAutoHighlight(info) {
        const sourceTile = info.sourceTile;
        if (sourceTile && sourceTile.layers) {
          for (const layer of sourceTile.layers) {
            layer.updateAutoHighlight(info);
          }
        }
      }
      renderLayers() {
        return this.state.tileset.tiles.map((tile) => {
          const subLayerProps = this.getSubLayerPropsByTile(tile);
          if (!tile.isLoaded && !tile.content) {
          } else if (!tile.layers) {
            const layers = this.renderSubLayers({
              ...this.props,
              id: "".concat(this.id, "-").concat(tile.id),
              data: tile.content,
              _offset: 0,
              tile
            });
            tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
              tile,
              ...subLayerProps
            }));
          } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
            tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
          }
          return tile.layers;
        });
      }
      filterSubLayer({
        layer,
        cullRect
      }) {
        const {
          tile
        } = layer.props;
        return this.state.tileset.isTileVisible(tile, cullRect);
      }
    };
    _defineProperty(TileLayer, "defaultProps", defaultProps6);
    _defineProperty(TileLayer, "layerName", "TileLayer");
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/trips-layer/trips-layer.js
var defaultProps7, TripsLayer;
var init_trips_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/trips-layer/trips-layer.js"() {
    init_defineProperty();
    init_esm9();
    defaultProps7 = {
      fadeTrail: true,
      trailLength: {
        type: "number",
        value: 120,
        min: 0
      },
      currentTime: {
        type: "number",
        value: 0,
        min: 0
      },
      getTimestamps: {
        type: "accessor",
        value: (d) => d.timestamps
      }
    };
    TripsLayer = class extends PathLayer {
      getShaders() {
        const shaders = super.getShaders();
        shaders.inject = {
          "vs:#decl": "uniform float trailLength;\nattribute float instanceTimestamps;\nattribute float instanceNextTimestamps;\nvarying float vTime;\n",
          "vs:#main-end": "vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;\n",
          "fs:#decl": "uniform bool fadeTrail;\nuniform float trailLength;\nuniform float currentTime;\nvarying float vTime;\n",
          "fs:#main-start": "if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {\n  discard;\n}\n",
          "fs:DECKGL_FILTER_COLOR": "if(fadeTrail) {\n  color.a *= 1.0 - (currentTime - vTime) / trailLength;\n}\n"
        };
        return shaders;
      }
      initializeState() {
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          timestamps: {
            size: 1,
            accessor: "getTimestamps",
            shaderAttributes: {
              instanceTimestamps: {
                vertexOffset: 0
              },
              instanceNextTimestamps: {
                vertexOffset: 1
              }
            }
          }
        });
      }
      draw(params) {
        const {
          fadeTrail,
          trailLength,
          currentTime
        } = this.props;
        params.uniforms = {
          ...params.uniforms,
          fadeTrail,
          trailLength,
          currentTime
        };
        super.draw(params);
      }
    };
    _defineProperty(TripsLayer, "layerName", "TripsLayer");
    _defineProperty(TripsLayer, "defaultProps", defaultProps7);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-hexagon-layer.js
function normalizeLongitudes(vertices, refLng) {
  refLng = refLng === void 0 ? vertices[0][0] : refLng;
  for (const pt of vertices) {
    const deltaLng = pt[0] - refLng;
    if (deltaLng > 180) {
      pt[0] -= 360;
    } else if (deltaLng < -180) {
      pt[0] += 360;
    }
  }
}
function scalePolygon(hexId, vertices, factor) {
  const [lat, lng] = h3ToGeo(hexId);
  const actualCount = vertices.length;
  normalizeLongitudes(vertices, lng);
  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
  for (let i = 0; i < vertexCount; i++) {
    vertices[i][0] = lerp(lng, vertices[i][0], factor);
    vertices[i][1] = lerp(lat, vertices[i][1], factor);
  }
}
function getHexagonCentroid(getHexagon, object, objectInfo) {
  const hexagonId = getHexagon(object, objectInfo);
  const [lat, lng] = h3ToGeo(hexagonId);
  return [lng, lat];
}
function h3ToPolygon(hexId, coverage = 1) {
  const vertices = h3ToGeoBoundary(hexId, true);
  if (coverage !== 1) {
    scalePolygon(hexId, vertices, coverage);
  } else {
    normalizeLongitudes(vertices);
  }
  return vertices;
}
function flattenPolygon(vertices) {
  const positions = new Float64Array(vertices.length * 2);
  let i = 0;
  for (const pt of vertices) {
    positions[i++] = pt[0];
    positions[i++] = pt[1];
  }
  return positions;
}
function mergeTriggers(getHexagon, coverage) {
  let trigger;
  if (getHexagon === void 0 || getHexagon === null) {
    trigger = coverage;
  } else if (typeof getHexagon === "object") {
    trigger = {
      ...getHexagon,
      coverage
    };
  } else {
    trigger = {
      getHexagon,
      coverage
    };
  }
  return trigger;
}
var UPDATE_THRESHOLD_KM, defaultProps8, H3HexagonLayer;
var init_h3_hexagon_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-hexagon-layer.js"() {
    init_defineProperty();
    init_h3_js_es();
    init_esm4();
    init_esm8();
    init_esm9();
    UPDATE_THRESHOLD_KM = 10;
    defaultProps8 = {
      ...PolygonLayer.defaultProps,
      highPrecision: "auto",
      coverage: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
      },
      centerHexagon: null,
      getHexagon: {
        type: "accessor",
        value: (x) => x.hexagon
      },
      extruded: true
    };
    H3HexagonLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      initializeState() {
        H3HexagonLayer._checkH3Lib();
        this.state = {
          edgeLengthKM: 0,
          resolution: -1
        };
      }
      shouldUpdateState({
        changeFlags
      }) {
        return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
      }
      updateState({
        props,
        changeFlags
      }) {
        if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
          const dataProps = this._calculateH3DataProps();
          this.setState(dataProps);
        }
        this._updateVertices(this.context.viewport);
      }
      _calculateH3DataProps() {
        let resolution = -1;
        let hasPentagon = false;
        let hasMultipleRes = false;
        const {
          iterable,
          objectInfo
        } = createIterable(this.props.data);
        for (const object of iterable) {
          objectInfo.index++;
          const hexId = this.props.getHexagon(object, objectInfo);
          const hexResolution = h3GetResolution(hexId);
          if (resolution < 0) {
            resolution = hexResolution;
            if (!this.props.highPrecision)
              break;
          } else if (resolution !== hexResolution) {
            hasMultipleRes = true;
            break;
          }
          if (h3IsPentagon(hexId)) {
            hasPentagon = true;
            break;
          }
        }
        return {
          resolution,
          edgeLengthKM: resolution >= 0 ? edgeLength(resolution, "km") : 0,
          hasMultipleRes,
          hasPentagon
        };
      }
      _shouldUseHighPrecision() {
        if (this.props.highPrecision === "auto") {
          const {
            resolution,
            hasPentagon,
            hasMultipleRes
          } = this.state;
          const {
            viewport
          } = this.context;
          return Boolean(viewport === null || viewport === void 0 ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
        }
        return this.props.highPrecision;
      }
      _updateVertices(viewport) {
        if (this._shouldUseHighPrecision()) {
          return;
        }
        const {
          resolution,
          edgeLengthKM,
          centerHex
        } = this.state;
        if (resolution < 0) {
          return;
        }
        const hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);
        if (centerHex === hex) {
          return;
        }
        if (centerHex) {
          const distance = h3Distance(centerHex, hex);
          if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {
            return;
          }
        }
        const {
          unitsPerMeter
        } = viewport.distanceScales;
        let vertices = h3ToPolygon(hex);
        const [centerLat, centerLng] = h3ToGeo(hex);
        const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
        vertices = vertices.map((p) => {
          const worldPosition = viewport.projectFlat(p);
          return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];
        });
        this.setState({
          centerHex: hex,
          vertices
        });
      }
      renderLayers() {
        return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
      }
      _getForwardProps() {
        const {
          elevationScale,
          material,
          coverage,
          extruded,
          wireframe,
          stroked,
          filled,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          getFillColor,
          getElevation,
          getLineColor,
          getLineWidth,
          transitions,
          updateTriggers
        } = this.props;
        return {
          elevationScale,
          extruded,
          coverage,
          wireframe,
          stroked,
          filled,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          material,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth,
          transitions,
          updateTriggers: {
            getFillColor: updateTriggers.getFillColor,
            getElevation: updateTriggers.getElevation,
            getLineColor: updateTriggers.getLineColor,
            getLineWidth: updateTriggers.getLineWidth
          }
        };
      }
      _renderPolygonLayer() {
        const {
          data,
          getHexagon,
          updateTriggers,
          coverage
        } = this.props;
        const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", PolygonLayer);
        const forwardProps = this._getForwardProps();
        forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
        return new SubLayerClass(forwardProps, this.getSubLayerProps({
          id: "hexagon-cell-hifi",
          updateTriggers: forwardProps.updateTriggers
        }), {
          data,
          _normalize: false,
          _windingOrder: "CCW",
          positionFormat: "XY",
          getPolygon: (object, objectInfo) => {
            const hexagonId = getHexagon(object, objectInfo);
            return flattenPolygon(h3ToPolygon(hexagonId, coverage));
          }
        });
      }
      _renderColumnLayer() {
        const {
          data,
          getHexagon,
          updateTriggers
        } = this.props;
        const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
        const forwardProps = this._getForwardProps();
        forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;
        return new SubLayerClass(forwardProps, this.getSubLayerProps({
          id: "hexagon-cell",
          flatShading: true,
          updateTriggers: forwardProps.updateTriggers
        }), {
          data,
          diskResolution: 6,
          radius: 1,
          vertices: this.state.vertices,
          getPosition: getHexagonCentroid.bind(null, getHexagon)
        });
      }
    };
    _defineProperty(H3HexagonLayer, "defaultProps", defaultProps8);
    _defineProperty(H3HexagonLayer, "layerName", "H3HexagonLayer");
    _defineProperty(H3HexagonLayer, "_checkH3Lib", () => {
    });
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-cluster-layer.js
var defaultProps9, H3ClusterLayer;
var init_h3_cluster_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-cluster-layer.js"() {
    init_defineProperty();
    init_h3_js_es();
    init_esm8();
    init_h3_hexagon_layer();
    init_GeoCellLayer();
    defaultProps9 = {
      getHexagons: {
        type: "accessor",
        value: (d) => d.hexagons
      }
    };
    H3ClusterLayer = class extends GeoCellLayer {
      initializeState() {
        H3HexagonLayer._checkH3Lib();
      }
      updateState({
        props,
        changeFlags
      }) {
        if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
          const {
            data,
            getHexagons
          } = props;
          const polygons = [];
          const {
            iterable,
            objectInfo
          } = createIterable(data);
          for (const object of iterable) {
            objectInfo.index++;
            const hexagons = getHexagons(object, objectInfo);
            const multiPolygon = h3SetToMultiPolygon(hexagons, true);
            for (const polygon of multiPolygon) {
              polygons.push(this.getSubLayerRow({
                polygon
              }, object, objectInfo.index));
            }
          }
          this.setState({
            polygons
          });
        }
      }
      indexToBounds() {
        const {
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        } = this.props;
        return {
          data: this.state.polygons,
          getPolygon: (d) => d.polygon,
          getElevation: this.getSubLayerAccessor(getElevation),
          getFillColor: this.getSubLayerAccessor(getFillColor),
          getLineColor: this.getSubLayerAccessor(getLineColor),
          getLineWidth: this.getSubLayerAccessor(getLineWidth)
        };
      }
    };
    _defineProperty(H3ClusterLayer, "layerName", "H3ClusterLayer");
    _defineProperty(H3ClusterLayer, "defaultProps", defaultProps9);
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/utils/matrix.js
function calculateTransformMatrix(targetMatrix, orientation, scale) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;
  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);
  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);
  const scx = scale[0];
  const scy = scale[1];
  const scz = scale[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}
function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
}
var RADIAN_PER_DEGREE, modelMatrix, valueArray, MATRIX_ATTRIBUTES;
var init_matrix = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/utils/matrix.js"() {
    init_esm8();
    RADIAN_PER_DEGREE = Math.PI / 180;
    modelMatrix = new Float32Array(16);
    valueArray = new Float32Array(12);
    MATRIX_ATTRIBUTES = {
      size: 12,
      accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
      shaderAttributes: {
        instanceModelMatrix__LOCATION_0: {
          size: 3,
          elementOffset: 0
        },
        instanceModelMatrix__LOCATION_1: {
          size: 3,
          elementOffset: 3
        },
        instanceModelMatrix__LOCATION_2: {
          size: 3,
          elementOffset: 6
        },
        instanceTranslation: {
          size: 3,
          elementOffset: 9
        }
      },
      update(attribute, {
        startRow,
        endRow
      }) {
        const {
          data,
          getOrientation,
          getScale: getScale2,
          getTranslation,
          getTransformMatrix
        } = this.props;
        const arrayMatrix = Array.isArray(getTransformMatrix);
        const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
        const constantScale = Array.isArray(getScale2);
        const constantOrientation = Array.isArray(getOrientation);
        const constantTranslation = Array.isArray(getTranslation);
        const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
        if (hasMatrix) {
          attribute.constant = constantMatrix;
        } else {
          attribute.constant = constantOrientation && constantScale && constantTranslation;
        }
        const instanceModelMatrixData = attribute.value;
        if (attribute.constant) {
          let matrix;
          if (hasMatrix) {
            modelMatrix.set(getTransformMatrix);
            matrix = getExtendedMat3FromMat4(modelMatrix);
          } else {
            matrix = valueArray;
            const orientation = getOrientation;
            const scale = getScale2;
            calculateTransformMatrix(matrix, orientation, scale);
            matrix.set(getTranslation, 9);
          }
          attribute.value = new Float32Array(matrix);
        } else {
          let i = startRow * attribute.size;
          const {
            iterable,
            objectInfo
          } = createIterable(data, startRow, endRow);
          for (const object of iterable) {
            objectInfo.index++;
            let matrix;
            if (hasMatrix) {
              modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
              matrix = getExtendedMat3FromMat4(modelMatrix);
            } else {
              matrix = valueArray;
              const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
              const scale = constantScale ? getScale2 : getScale2(object, objectInfo);
              calculateTransformMatrix(matrix, orientation, scale);
              matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
            }
            instanceModelMatrixData[i++] = matrix[0];
            instanceModelMatrixData[i++] = matrix[1];
            instanceModelMatrixData[i++] = matrix[2];
            instanceModelMatrixData[i++] = matrix[3];
            instanceModelMatrixData[i++] = matrix[4];
            instanceModelMatrixData[i++] = matrix[5];
            instanceModelMatrixData[i++] = matrix[6];
            instanceModelMatrixData[i++] = matrix[7];
            instanceModelMatrixData[i++] = matrix[8];
            instanceModelMatrixData[i++] = matrix[9];
            instanceModelMatrixData[i++] = matrix[10];
            instanceModelMatrixData[i++] = matrix[11];
          }
        }
      }
    };
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js
var simple_mesh_layer_vertex_glsl_default;
var init_simple_mesh_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js"() {
    simple_mesh_layer_vertex_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n\n  if (composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js
var simple_mesh_layer_fragment_glsl_default;
var init_simple_mesh_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js"() {
    simple_mesh_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n}\n";
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer.js
function validateGeometryAttributes(attributes, useMeshColors) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  const useColorAttribute = hasColorAttribute && useMeshColors;
  if (!useColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }
  log_default.assert(attributes.positions || attributes.POSITION, 'no "postions" or "POSITION" attribute in mesh');
}
function getGeometry(data, useMeshColors) {
  if (data.attributes) {
    validateGeometryAttributes(data.attributes, useMeshColors);
    if (data instanceof Geometry) {
      return data;
    } else {
      return new Geometry(data);
    }
  } else if (data.positions || data.POSITION) {
    validateGeometryAttributes(data, useMeshColors);
    return new Geometry({
      attributes: data
    });
  }
  throw Error("Invalid mesh");
}
var DEFAULT_COLOR, defaultProps10, SimpleMeshLayer;
var init_simple_mesh_layer = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer.js"() {
    init_defineProperty();
    init_esm8();
    init_esm6();
    init_esm3();
    init_matrix();
    init_simple_mesh_layer_vertex_glsl();
    init_simple_mesh_layer_fragment_glsl();
    init_esm12();
    DEFAULT_COLOR = [0, 0, 0, 255];
    defaultProps10 = {
      mesh: {
        type: "object",
        value: null,
        async: true
      },
      texture: {
        type: "image",
        value: null,
        async: true
      },
      sizeScale: {
        type: "number",
        value: 1,
        min: 0
      },
      _useMeshColors: {
        type: "boolean",
        value: false
      },
      _instanced: true,
      wireframe: false,
      material: true,
      getPosition: {
        type: "accessor",
        value: (x) => x.position
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR
      },
      getOrientation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getScale: {
        type: "accessor",
        value: [1, 1, 1]
      },
      getTranslation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getTransformMatrix: {
        type: "accessor",
        value: []
      },
      textureParameters: {
        type: "object",
        ignore: true
      }
    };
    SimpleMeshLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        const transpileToGLSL100 = !isWebGL2(this.context.gl);
        const defines = {};
        if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {
          defines.DERIVATIVES_AVAILABLE = 1;
        }
        return super.getShaders({
          vs: simple_mesh_layer_vertex_glsl_default,
          fs: simple_mesh_layer_fragment_glsl_default,
          modules: [project32_default, phongLighting, picking_default],
          transpileToGLSL100,
          defines
        });
      }
      getBounds() {
        var _mesh$header;
        if (this.props._instanced) {
          return super.getBounds();
        }
        let result = this.state.positionBounds;
        if (result) {
          return result;
        }
        const {
          mesh
        } = this.props;
        if (!mesh) {
          return null;
        }
        result = (_mesh$header = mesh.header) === null || _mesh$header === void 0 ? void 0 : _mesh$header.boundingBox;
        if (!result) {
          const {
            attributes
          } = getGeometry(mesh, this.props._useMeshColors);
          attributes.POSITION = attributes.POSITION || attributes.positions;
          result = getMeshBoundingBox(attributes);
        }
        this.state.positionBounds = result;
        return result;
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instancePositions: {
            transition: true,
            type: 5130,
            fp64: this.use64bitPositions(),
            size: 3,
            accessor: "getPosition"
          },
          instanceColors: {
            type: 5121,
            transition: true,
            size: this.props.colorFormat.length,
            normalized: true,
            accessor: "getColor",
            defaultValue: [0, 0, 0, 255]
          },
          instanceModelMatrix: MATRIX_ATTRIBUTES
        });
        this.setState({
          emptyTexture: new Texture2D(this.context.gl, {
            data: new Uint8Array(4),
            width: 1,
            height: 1
          })
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps,
          changeFlags
        } = params;
        if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
          var _this$state$model;
          this.state.positionBounds = null;
          (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
          if (props.mesh) {
            this.state.model = this.getModel(props.mesh);
            const attributes = props.mesh.attributes || props.mesh;
            this.setState({
              hasNormals: Boolean(attributes.NORMAL || attributes.normals)
            });
          }
          this.getAttributeManager().invalidateAll();
        }
        if (props.texture !== oldProps.texture) {
          this.setTexture(props.texture);
        }
        if (this.state.model) {
          this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
        }
      }
      finalizeState(context) {
        super.finalizeState(context);
        this.state.emptyTexture.delete();
      }
      draw({
        uniforms
      }) {
        if (!this.state.model) {
          return;
        }
        const {
          viewport
        } = this.context;
        const {
          sizeScale,
          coordinateSystem,
          _instanced
        } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
          sizeScale,
          composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
          flatShading: !this.state.hasNormals
        }).draw();
      }
      getModel(mesh) {
        const model = new Model(this.context.gl, {
          ...this.getShaders(),
          id: this.props.id,
          geometry: getGeometry(mesh, this.props._useMeshColors),
          isInstanced: true
        });
        const {
          texture
        } = this.props;
        const {
          emptyTexture
        } = this.state;
        model.setUniforms({
          sampler: texture || emptyTexture,
          hasTexture: Boolean(texture)
        });
        return model;
      }
      setTexture(texture) {
        const {
          emptyTexture,
          model
        } = this.state;
        if (model) {
          model.setUniforms({
            sampler: texture || emptyTexture,
            hasTexture: Boolean(texture)
          });
        }
      }
    };
    _defineProperty(SimpleMeshLayer, "defaultProps", defaultProps10);
    _defineProperty(SimpleMeshLayer, "layerName", "SimpleMeshLayer");
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/gltf-utils.js
async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];
  gltfObjects.scenes.forEach((scene) => {
    scene.traverse((model) => {
      Object.values(model.model.getUniforms()).forEach((uniform) => {
        if (uniform.loaded === false) {
          remaining.push(uniform);
        }
      });
    });
  });
  return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
}
async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise((resolve) => requestAnimationFrame(resolve));
  }
}
var init_gltf_utils = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/gltf-utils.js"() {
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-vertex.glsl.js
var scenegraph_layer_vertex_glsl_default;
var init_scenegraph_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-vertex.glsl.js"() {
    scenegraph_layer_vertex_glsl_default = "#version 300 es\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec4 POSITION;\n\n#ifdef HAS_UV\n  in vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    in vec4 NORMAL;\n  #endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(sizeScale);\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-fragment.glsl.js
var scenegraph_layer_fragment_glsl_default;
var init_scenegraph_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-fragment.glsl.js"() {
    scenegraph_layer_fragment_glsl_default = "#version 300 es\nuniform float opacity;\nin vec4 vColor;\n\nout vec4 fragmentColor;\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  fragmentColor.a *= opacity;\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer.js
var DEFAULT_COLOR2, defaultProps11, ScenegraphLayer;
var init_scenegraph_layer = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer.js"() {
    init_defineProperty();
    init_esm8();
    init_esm6();
    init_esm5();
    init_esm13();
    init_esm14();
    init_gltf_utils();
    init_matrix();
    init_scenegraph_layer_vertex_glsl();
    init_scenegraph_layer_fragment_glsl();
    DEFAULT_COLOR2 = [255, 255, 255, 255];
    defaultProps11 = {
      scenegraph: {
        type: "object",
        value: null,
        async: true
      },
      getScene: (gltf) => {
        if (gltf && gltf.scenes) {
          return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
        }
        return gltf;
      },
      getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
      _animations: null,
      sizeScale: {
        type: "number",
        value: 1,
        min: 0
      },
      sizeMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      sizeMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      getPosition: {
        type: "accessor",
        value: (x) => x.position
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR2
      },
      _lighting: "flat",
      _imageBasedLightingEnvironment: null,
      getOrientation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getScale: {
        type: "accessor",
        value: [1, 1, 1]
      },
      getTranslation: {
        type: "accessor",
        value: [0, 0, 0]
      },
      getTransformMatrix: {
        type: "accessor",
        value: []
      },
      loaders: [GLTFLoader]
    };
    ScenegraphLayer = class extends Layer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      getShaders() {
        const modules = [project32_default, picking_default];
        if (this.props._lighting === "pbr") {
          modules.push(pbr);
        }
        return {
          vs: scenegraph_layer_vertex_glsl_default,
          fs: scenegraph_layer_fragment_glsl_default,
          modules
        };
      }
      initializeState() {
        const attributeManager = this.getAttributeManager();
        attributeManager.addInstanced({
          instancePositions: {
            size: 3,
            type: 5130,
            fp64: this.use64bitPositions(),
            accessor: "getPosition",
            transition: true
          },
          instanceColors: {
            type: 5121,
            size: this.props.colorFormat.length,
            accessor: "getColor",
            normalized: true,
            defaultValue: DEFAULT_COLOR2,
            transition: true
          },
          instanceModelMatrix: MATRIX_ATTRIBUTES
        });
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps
        } = params;
        if (props.scenegraph !== oldProps.scenegraph) {
          this._updateScenegraph();
        } else if (props._animations !== oldProps._animations) {
          this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
        }
      }
      finalizeState(context) {
        super.finalizeState(context);
        this._deleteScenegraph();
      }
      _updateScenegraph() {
        const props = this.props;
        const {
          gl
        } = this.context;
        let scenegraphData = null;
        if (props.scenegraph instanceof ScenegraphNode) {
          scenegraphData = {
            scenes: [props.scenegraph]
          };
        } else if (props.scenegraph && !props.scenegraph.gltf) {
          const gltf = props.scenegraph;
          const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());
          scenegraphData = {
            gltf,
            ...gltfObjects
          };
          waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw());
        } else if (props.scenegraph) {
          log_default.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")();
          scenegraphData = props.scenegraph;
        }
        const options = {
          layer: this,
          gl
        };
        const scenegraph = props.getScene(scenegraphData, options);
        const animator = props.getAnimator(scenegraphData, options);
        if (scenegraph instanceof ScenegraphNode) {
          this._deleteScenegraph();
          this._applyAllAttributes(scenegraph);
          this._applyAnimationsProp(scenegraph, animator, props._animations);
          this.setState({
            scenegraph,
            animator
          });
        } else if (scenegraph !== null) {
          log_default.warn("invalid scenegraph:", scenegraph)();
        }
      }
      _applyAllAttributes(scenegraph) {
        if (this.state.attributesAvailable) {
          const allAttributes = this.getAttributeManager().getAttributes();
          scenegraph.traverse((model) => {
            this._setModelAttributes(model.model, allAttributes);
          });
        }
      }
      _applyAnimationsProp(scenegraph, animator, animationsProp) {
        if (!scenegraph || !animator || !animationsProp) {
          return;
        }
        const animations = animator.getAnimations();
        Object.keys(animationsProp).sort().forEach((key) => {
          const value = animationsProp[key];
          if (key === "*") {
            animations.forEach((animation) => {
              Object.assign(animation, value);
            });
          } else if (Number.isFinite(Number(key))) {
            const number = Number(key);
            if (number >= 0 && number < animations.length) {
              Object.assign(animations[number], value);
            } else {
              log_default.warn("animation ".concat(key, " not found"))();
            }
          } else {
            const findResult = animations.find(({
              name
            }) => name === key);
            if (findResult) {
              Object.assign(findResult, value);
            } else {
              log_default.warn("animation ".concat(key, " not found"))();
            }
          }
        });
      }
      _deleteScenegraph() {
        const {
          scenegraph
        } = this.state;
        if (scenegraph instanceof ScenegraphNode) {
          scenegraph.delete();
        }
      }
      _getModelOptions() {
        const {
          _imageBasedLightingEnvironment
        } = this.props;
        let env = null;
        if (_imageBasedLightingEnvironment) {
          if (typeof _imageBasedLightingEnvironment === "function") {
            env = _imageBasedLightingEnvironment({
              gl: this.context.gl,
              layer: this
            });
          } else {
            env = _imageBasedLightingEnvironment;
          }
        }
        return {
          gl: this.context.gl,
          waitForFullLoad: true,
          imageBasedLightingEnvironment: env,
          modelOptions: {
            isInstanced: true,
            transpileToGLSL100: !isWebGL2(this.context.gl),
            ...this.getShaders()
          },
          useTangents: false
        };
      }
      updateAttributes(changedAttributes) {
        this.setState({
          attributesAvailable: true
        });
        if (!this.state.scenegraph)
          return;
        this.state.scenegraph.traverse((model) => {
          this._setModelAttributes(model.model, changedAttributes);
        });
      }
      draw({
        moduleParameters = null,
        parameters: parameters2 = {},
        context
      }) {
        if (!this.state.scenegraph)
          return;
        if (this.props._animations && this.state.animator) {
          this.state.animator.animate(context.timeline.getTime());
          this.setNeedsRedraw();
        }
        const {
          viewport
        } = this.context;
        const {
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          opacity,
          coordinateSystem
        } = this.props;
        const numInstances = this.getNumInstances();
        this.state.scenegraph.traverse((model, {
          worldMatrix
        }) => {
          model.model.setInstanceCount(numInstances);
          model.updateModuleSettings(moduleParameters);
          model.draw({
            parameters: parameters2,
            uniforms: {
              sizeScale,
              opacity,
              sizeMinPixels,
              sizeMaxPixels,
              composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
              sceneModelMatrix: worldMatrix,
              u_Camera: model.model.getUniforms().project_uCameraPosition
            }
          });
        });
      }
    };
    _defineProperty(ScenegraphLayer, "defaultProps", defaultProps11);
    _defineProperty(ScenegraphLayer, "layerName", "ScenegraphLayer");
  }
});

// node_modules/@deck.gl/mesh-layers/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  ScenegraphLayer: () => ScenegraphLayer,
  SimpleMeshLayer: () => SimpleMeshLayer
});
var init_esm20 = __esm({
  "node_modules/@deck.gl/mesh-layers/dist/esm/index.js"() {
    init_simple_mesh_layer();
    init_scenegraph_layer();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-vertex.glsl.js
var mesh_layer_vertex_glsl_default;
var init_mesh_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-vertex.glsl.js"() {
    mesh_layer_vertex_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nuniform bool pickFeatureIds;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec4 uvRegions;\nin vec3 featureIdsPickingColors;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvec2 applyUVRegion(vec2 uv) {\n  #ifdef HAS_UV_REGIONS\n    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;\n  #else\n    return uv;\n  #endif\n}\n\nvoid main(void) {\n  vec2 uv = applyUVRegion(texCoords);\n  geometry.uv = uv;\n\n  if (pickFeatureIds) {\n    geometry.pickingColor = featureIdsPickingColors;\n  } else {\n    geometry.pickingColor = instancePickingColors;\n  }\n\n  vTexCoord = uv;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale;\n  vec3 projectedPosition = project_position(positions);\n  position_commonspace = vec4(projectedPosition, 1.0);\n  gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n  geometry.position = position_commonspace;\n  normals_commonspace = project_normal(instanceModelMatrix * normals);\n  geometry.normal = normals_commonspace;\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = uv;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-fragment.glsl.js
var mesh_layer_fragment_glsl_default;
var init_mesh_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-fragment.glsl.js"() {
    mesh_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  \n#ifdef MODULE_PBR\n\n  fragColor = vColor * pbr_filterColor(vec4(0));\n  geometry.uv = pbr_vUV;\n  fragColor.a *= opacity;\n\n#else\n\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n\n#endif\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer.js
function validateGeometryAttributes2(attributes) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!hasColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }
}
var defaultProps12, MeshLayer;
var init_mesh_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer.js"() {
    init_defineProperty();
    init_esm13();
    init_esm6();
    init_esm20();
    init_mesh_layer_vertex_glsl();
    init_mesh_layer_fragment_glsl();
    defaultProps12 = {
      pbrMaterial: {
        type: "object",
        value: null
      },
      featureIds: {
        type: "array",
        value: null,
        optional: true
      }
    };
    MeshLayer = class extends SimpleMeshLayer {
      getShaders() {
        const shaders = super.getShaders();
        const modules = shaders.modules;
        modules.push(pbr);
        return {
          ...shaders,
          vs: mesh_layer_vertex_glsl_default,
          fs: mesh_layer_fragment_glsl_default
        };
      }
      initializeState() {
        const {
          featureIds
        } = this.props;
        super.initializeState();
        const attributeManager = this.getAttributeManager();
        if (featureIds) {
          attributeManager.add({
            featureIdsPickingColors: {
              type: 5121,
              size: 3,
              noAlloc: true,
              update: this.calculateFeatureIdsPickingColors
            }
          });
        }
      }
      updateState(params) {
        super.updateState(params);
        const {
          props,
          oldProps
        } = params;
        if (props.pbrMaterial !== oldProps.pbrMaterial) {
          this.updatePbrMaterialUniforms(props.pbrMaterial);
        }
      }
      draw(opts) {
        const {
          featureIds
        } = this.props;
        if (!this.state.model) {
          return;
        }
        this.state.model.setUniforms({
          u_Camera: this.state.model.getUniforms().project_uCameraPosition,
          pickFeatureIds: Boolean(featureIds)
        });
        super.draw(opts);
      }
      getModel(mesh) {
        const {
          id,
          pbrMaterial
        } = this.props;
        const materialParser = this.parseMaterial(pbrMaterial, mesh);
        this.setState({
          materialParser
        });
        const shaders = this.getShaders();
        validateGeometryAttributes2(mesh.attributes);
        const model = new Model(this.context.gl, {
          ...this.getShaders(),
          id,
          geometry: mesh,
          defines: {
            ...shaders.defines,
            ...materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines,
            HAS_UV_REGIONS: mesh.attributes.uvRegions
          },
          parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,
          isInstanced: true
        });
        return model;
      }
      updatePbrMaterialUniforms(pbrMaterial) {
        const {
          model
        } = this.state;
        if (model) {
          const {
            mesh
          } = this.props;
          const materialParser = this.parseMaterial(pbrMaterial, mesh);
          this.setState({
            materialParser
          });
          model.setUniforms(materialParser.uniforms);
        }
      }
      parseMaterial(pbrMaterial, mesh) {
        var _this$state$materialP;
        const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);
        (_this$state$materialP = this.state.materialParser) === null || _this$state$materialP === void 0 ? void 0 : _this$state$materialP.delete();
        return new GLTFMaterialParser(this.context.gl, {
          attributes: {
            NORMAL: mesh.attributes.normals,
            TEXCOORD_0: mesh.attributes.texCoords
          },
          material: {
            unlit,
            ...pbrMaterial
          },
          pbrDebug: false,
          imageBasedLightingEnvironment: null,
          lights: true,
          useTangents: false
        });
      }
      calculateFeatureIdsPickingColors(attribute) {
        const featureIds = this.props.featureIds;
        const value = new Uint8ClampedArray(featureIds.length * attribute.size);
        const pickingColor = [];
        for (let index = 0; index < featureIds.length; index++) {
          this.encodePickingColor(featureIds[index], pickingColor);
          value[index * 3] = pickingColor[0];
          value[index * 3 + 1] = pickingColor[1];
          value[index * 3 + 2] = pickingColor[2];
        }
        attribute.value = value;
      }
      finalizeState(context) {
        var _this$state$materialP2;
        super.finalizeState(context);
        (_this$state$materialP2 = this.state.materialParser) === null || _this$state$materialP2 === void 0 ? void 0 : _this$state$materialP2.delete();
        this.setState({
          materialParser: null
        });
      }
    };
    _defineProperty(MeshLayer, "layerName", "MeshLayer");
    _defineProperty(MeshLayer, "defaultProps", defaultProps12);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js
function getMeshGeometry(contentAttributes) {
  const attributes = {};
  attributes.positions = {
    ...contentAttributes.positions,
    value: new Float32Array(contentAttributes.positions.value)
  };
  if (contentAttributes.normals) {
    attributes.normals = contentAttributes.normals;
  }
  if (contentAttributes.texCoords) {
    attributes.texCoords = contentAttributes.texCoords;
  }
  if (contentAttributes.colors) {
    attributes.colors = contentAttributes.colors;
  }
  if (contentAttributes.uvRegions) {
    attributes.uvRegions = contentAttributes.uvRegions;
  }
  return attributes;
}
var SINGLE_DATA, defaultProps13, Tile3DLayer;
var init_tile_3d_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js"() {
    init_defineProperty();
    init_esm6();
    init_esm8();
    init_esm9();
    init_esm20();
    init_mesh_layer();
    init_esm2();
    init_esm15();
    init_esm16();
    SINGLE_DATA = [0];
    defaultProps13 = {
      getPointColor: {
        type: "accessor",
        value: [0, 0, 0, 255]
      },
      pointSize: 1,
      data: "",
      loader: Tiles3DLoader,
      onTilesetLoad: {
        type: "function",
        value: (tileset3d) => {
        }
      },
      onTileLoad: {
        type: "function",
        value: (tileHeader) => {
        }
      },
      onTileUnload: {
        type: "function",
        value: (tileHeader) => {
        }
      },
      onTileError: {
        type: "function",
        value: (tile, message, url) => {
        }
      },
      _getMeshColor: {
        type: "function",
        value: (tileHeader) => [255, 255, 255]
      }
    };
    Tile3DLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      initializeState() {
        if ("onTileLoadFail" in this.props) {
          log_default.removed("onTileLoadFail", "onTileError")();
        }
        this.state = {
          layerMap: {},
          tileset3d: null,
          activeViewports: {},
          lastUpdatedViewports: null
        };
      }
      get isLoaded() {
        const {
          tileset3d
        } = this.state;
        return tileset3d !== null && tileset3d.isLoaded();
      }
      shouldUpdateState({
        changeFlags
      }) {
        return changeFlags.somethingChanged;
      }
      updateState({
        props,
        oldProps,
        changeFlags
      }) {
        if (props.data && props.data !== oldProps.data) {
          this._loadTileset(props.data);
        }
        if (changeFlags.viewportChanged) {
          const {
            activeViewports
          } = this.state;
          const viewportsNumber = Object.keys(activeViewports).length;
          if (viewportsNumber) {
            this._updateTileset(activeViewports);
            this.state.lastUpdatedViewports = activeViewports;
            this.state.activeViewports = {};
          }
        }
        if (changeFlags.propsChanged) {
          const {
            layerMap
          } = this.state;
          for (const key in layerMap) {
            layerMap[key].needsUpdate = true;
          }
        }
      }
      activateViewport(viewport) {
        const {
          activeViewports,
          lastUpdatedViewports
        } = this.state;
        this.internalState.viewport = viewport;
        activeViewports[viewport.id] = viewport;
        const lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];
        if (!lastViewport || !viewport.equals(lastViewport)) {
          this.setChangeFlags({
            viewportChanged: true
          });
          this.setNeedsUpdate();
        }
      }
      getPickingInfo({
        info,
        sourceLayer
      }) {
        const sourceTile = sourceLayer && sourceLayer.props.tile;
        if (info.picked) {
          info.object = sourceTile;
        }
        info.sourceTile = sourceTile;
        return info;
      }
      filterSubLayer({
        layer,
        viewport
      }) {
        const {
          tile
        } = layer.props;
        const {
          id: viewportId
        } = viewport;
        return tile.selected && tile.viewportIds.includes(viewportId);
      }
      _updateAutoHighlight(info) {
        const sourceTile = info.sourceTile;
        const layerCache = this.state.layerMap[sourceTile === null || sourceTile === void 0 ? void 0 : sourceTile.id];
        if (layerCache && layerCache.layer) {
          layerCache.layer.updateAutoHighlight(info);
        }
      }
      async _loadTileset(tilesetUrl) {
        const {
          loadOptions = {}
        } = this.props;
        let loader = this.props.loader || this.props.loaders;
        if (Array.isArray(loader)) {
          loader = loader[0];
        }
        const options = {
          loadOptions: {
            ...loadOptions
          }
        };
        if (loader.preload) {
          const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
          if (preloadOptions.headers) {
            options.loadOptions.fetch = {
              ...options.loadOptions.fetch,
              headers: preloadOptions.headers
            };
          }
          Object.assign(options, preloadOptions);
        }
        const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);
        const tileset3d = new Tileset3D(tilesetJson, {
          onTileLoad: this._onTileLoad.bind(this),
          onTileUnload: this._onTileUnload.bind(this),
          onTileError: this.props.onTileError,
          ...options
        });
        this.setState({
          tileset3d,
          layerMap: {}
        });
        this._updateTileset(this.state.activeViewports);
        this.props.onTilesetLoad(tileset3d);
      }
      _onTileLoad(tileHeader) {
        const {
          lastUpdatedViewports
        } = this.state;
        this.props.onTileLoad(tileHeader);
        this._updateTileset(lastUpdatedViewports);
        this.setNeedsUpdate();
      }
      _onTileUnload(tileHeader) {
        delete this.state.layerMap[tileHeader.id];
        this.props.onTileUnload(tileHeader);
      }
      _updateTileset(viewports) {
        if (!viewports) {
          return;
        }
        const {
          tileset3d
        } = this.state;
        const {
          timeline
        } = this.context;
        const viewportsNumber = Object.keys(viewports).length;
        if (!timeline || !viewportsNumber || !tileset3d) {
          return;
        }
        tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
          const tilesetChanged = this.state.frameNumber !== frameNumber;
          if (tilesetChanged) {
            this.setState({
              frameNumber
            });
          }
        });
      }
      _getSubLayer(tileHeader, oldLayer) {
        if (!tileHeader.content) {
          return null;
        }
        switch (tileHeader.type) {
          case TILE_TYPE.POINTCLOUD:
            return this._makePointCloudLayer(tileHeader, oldLayer);
          case TILE_TYPE.SCENEGRAPH:
            return this._make3DModelLayer(tileHeader);
          case TILE_TYPE.MESH:
            return this._makeSimpleMeshLayer(tileHeader, oldLayer);
          default:
            throw new Error("Tile3DLayer: Failed to render layer of type ".concat(tileHeader.content.type));
        }
      }
      _makePointCloudLayer(tileHeader, oldLayer) {
        const {
          attributes,
          pointCount,
          constantRGBA,
          cartographicOrigin,
          modelMatrix: modelMatrix2
        } = tileHeader.content;
        const {
          positions,
          normals,
          colors
        } = attributes;
        if (!positions) {
          return null;
        }
        const data = oldLayer && oldLayer.props.data || {
          header: {
            vertexCount: pointCount
          },
          attributes: {
            POSITION: positions,
            NORMAL: normals,
            COLOR_0: colors
          }
        };
        const {
          pointSize,
          getPointColor
        } = this.props;
        const SubLayerClass = this.getSubLayerClass("pointcloud", PointCloudLayer);
        return new SubLayerClass({
          pointSize
        }, this.getSubLayerProps({
          id: "pointcloud"
        }), {
          id: "".concat(this.id, "-pointcloud-").concat(tileHeader.id),
          tile: tileHeader,
          data,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getColor: constantRGBA || getPointColor,
          _offset: 0
        });
      }
      _make3DModelLayer(tileHeader) {
        const {
          gltf,
          instances,
          cartographicOrigin,
          modelMatrix: modelMatrix2
        } = tileHeader.content;
        const SubLayerClass = this.getSubLayerClass("scenegraph", ScenegraphLayer);
        return new SubLayerClass({
          _lighting: "pbr"
        }, this.getSubLayerProps({
          id: "scenegraph"
        }), {
          id: "".concat(this.id, "-scenegraph-").concat(tileHeader.id),
          tile: tileHeader,
          data: instances || SINGLE_DATA,
          scenegraph: gltf,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getTransformMatrix: (instance) => instance.modelMatrix,
          getPosition: [0, 0, 0],
          _offset: 0
        });
      }
      _makeSimpleMeshLayer(tileHeader, oldLayer) {
        const content = tileHeader.content;
        const {
          attributes,
          indices,
          modelMatrix: modelMatrix2,
          cartographicOrigin,
          coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,
          material,
          featureIds
        } = content;
        const {
          _getMeshColor
        } = this.props;
        const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
          drawMode: 4,
          attributes: getMeshGeometry(attributes),
          indices
        });
        const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
        return new SubLayerClass(this.getSubLayerProps({
          id: "mesh"
        }), {
          id: "".concat(this.id, "-mesh-").concat(tileHeader.id),
          tile: tileHeader,
          mesh: geometry,
          data: SINGLE_DATA,
          getColor: _getMeshColor(tileHeader),
          pbrMaterial: material,
          modelMatrix: modelMatrix2,
          coordinateOrigin: cartographicOrigin,
          coordinateSystem,
          featureIds,
          _offset: 0
        });
      }
      renderLayers() {
        const {
          tileset3d,
          layerMap
        } = this.state;
        if (!tileset3d) {
          return null;
        }
        return tileset3d.tiles.map((tile) => {
          const layerCache = layerMap[tile.id] = layerMap[tile.id] || {
            tile
          };
          let {
            layer
          } = layerCache;
          if (tile.selected) {
            if (!layer) {
              layer = this._getSubLayer(tile);
            } else if (layerCache.needsUpdate) {
              layer = this._getSubLayer(tile, layer);
              layerCache.needsUpdate = false;
            }
          }
          layerCache.layer = layer;
          return layer;
        }).filter(Boolean);
      }
    };
    _defineProperty(Tile3DLayer, "defaultProps", defaultProps13);
    _defineProperty(Tile3DLayer, "layerName", "Tile3DLayer");
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/terrain-layer/terrain-layer.js
function urlTemplateToUpdateTrigger(template) {
  if (Array.isArray(template)) {
    return template.join(";");
  }
  return template || "";
}
var DUMMY_DATA, defaultProps14, TerrainLayer;
var init_terrain_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/terrain-layer/terrain-layer.js"() {
    init_defineProperty();
    init_esm8();
    init_esm20();
    init_esm8();
    init_esm17();
    init_tile_layer();
    init_tileset_2d2();
    DUMMY_DATA = [1];
    defaultProps14 = {
      ...TileLayer.defaultProps,
      elevationData: urlType,
      texture: {
        ...urlType,
        optional: true
      },
      meshMaxError: {
        type: "number",
        value: 4
      },
      bounds: {
        type: "array",
        value: null,
        optional: true,
        compare: true
      },
      color: {
        type: "color",
        value: [255, 255, 255]
      },
      elevationDecoder: {
        type: "object",
        value: {
          rScaler: 1,
          gScaler: 0,
          bScaler: 0,
          offset: 0
        }
      },
      workerUrl: "",
      wireframe: false,
      material: true,
      loaders: [TerrainLoader]
    };
    TerrainLayer = class extends CompositeLayer {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "state", void 0);
      }
      updateState({
        props,
        oldProps
      }) {
        const elevationDataChanged = props.elevationData !== oldProps.elevationData;
        if (elevationDataChanged) {
          const {
            elevationData
          } = props;
          const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
          this.setState({
            isTiled
          });
        }
        const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
        if (!this.state.isTiled && shouldReload) {
          const terrain = this.loadTerrain(props);
          this.setState({
            terrain
          });
        }
        if (props.workerUrl) {
          log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
        }
      }
      loadTerrain({
        elevationData,
        bounds,
        elevationDecoder,
        meshMaxError,
        signal
      }) {
        var _loadOptions;
        if (!elevationData) {
          return null;
        }
        let loadOptions = this.getLoadOptions();
        loadOptions = {
          ...loadOptions,
          terrain: {
            skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
            ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.terrain,
            bounds,
            meshMaxError,
            elevationDecoder
          }
        };
        const {
          fetch
        } = this.props;
        return fetch(elevationData, {
          propName: "elevationData",
          layer: this,
          loadOptions,
          signal
        });
      }
      getTiledTerrainData(tile) {
        const {
          elevationData,
          fetch,
          texture,
          elevationDecoder,
          meshMaxError
        } = this.props;
        const {
          viewport
        } = this.context;
        const dataUrl = getURLFromTemplate(elevationData, tile);
        const textureUrl = texture && getURLFromTemplate(texture, tile);
        const {
          signal
        } = tile;
        let bottomLeft = [0, 0];
        let topRight = [0, 0];
        if (viewport.isGeospatial) {
          const bbox = tile.bbox;
          bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
          topRight = viewport.projectFlat([bbox.east, bbox.north]);
        } else {
          const bbox = tile.bbox;
          bottomLeft = [bbox.left, bbox.bottom];
          topRight = [bbox.right, bbox.top];
        }
        const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
        const terrain = this.loadTerrain({
          elevationData: dataUrl,
          bounds,
          elevationDecoder,
          meshMaxError,
          signal
        });
        const surface = textureUrl ? fetch(textureUrl, {
          propName: "texture",
          layer: this,
          loaders: [],
          signal
        }).catch((_) => null) : Promise.resolve(null);
        return Promise.all([terrain, surface]);
      }
      renderSubLayers(props) {
        const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
        const {
          color,
          wireframe,
          material
        } = this.props;
        const {
          data
        } = props;
        if (!data) {
          return null;
        }
        const [mesh, texture] = data;
        return new SubLayerClass(props, {
          data: DUMMY_DATA,
          mesh,
          texture,
          _instanced: false,
          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
          getPosition: (d) => [0, 0, 0],
          getColor: color,
          wireframe,
          material
        });
      }
      onViewportLoad(tiles) {
        if (!tiles) {
          return;
        }
        const {
          zRange
        } = this.state;
        const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
          const bounds = arr[0].header.boundingBox;
          return bounds.map((bound) => bound[2]);
        });
        if (ranges.length === 0) {
          return;
        }
        const minZ = Math.min(...ranges.map((x) => x[0]));
        const maxZ = Math.max(...ranges.map((x) => x[1]));
        if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
          this.setState({
            zRange: [minZ, maxZ]
          });
        }
      }
      renderLayers() {
        const {
          color,
          material,
          elevationData,
          texture,
          wireframe,
          meshMaxError,
          elevationDecoder,
          tileSize,
          maxZoom,
          minZoom,
          extent,
          maxRequests,
          onTileLoad,
          onTileUnload,
          onTileError,
          maxCacheSize,
          maxCacheByteSize,
          refinementStrategy
        } = this.props;
        if (this.state.isTiled) {
          return new TileLayer(this.getSubLayerProps({
            id: "tiles"
          }), {
            getTileData: this.getTiledTerrainData.bind(this),
            renderSubLayers: this.renderSubLayers.bind(this),
            updateTriggers: {
              getTileData: {
                elevationData: urlTemplateToUpdateTrigger(elevationData),
                texture: urlTemplateToUpdateTrigger(texture),
                meshMaxError,
                elevationDecoder
              }
            },
            onViewportLoad: this.onViewportLoad.bind(this),
            zRange: this.state.zRange || null,
            tileSize,
            maxZoom,
            minZoom,
            extent,
            maxRequests,
            onTileLoad,
            onTileUnload,
            onTileError,
            maxCacheSize,
            maxCacheByteSize,
            refinementStrategy
          });
        }
        const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
        return new SubLayerClass(this.getSubLayerProps({
          id: "mesh"
        }), {
          data: DUMMY_DATA,
          mesh: this.state.terrain,
          texture,
          _instanced: false,
          getPosition: (d) => [0, 0, 0],
          getColor: color,
          material,
          wireframe
        });
      }
    };
    _defineProperty(TerrainLayer, "defaultProps", defaultProps14);
    _defineProperty(TerrainLayer, "layerName", "TerrainLayer");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js
var vs, fs, TARGET, inject, shader_module_default;
var init_shader_module = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js"() {
    init_esm8();
    vs = "\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n";
    fs = "\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n";
    TARGET = {
      source: 0,
      target: 1,
      custom: 2,
      source_target: 3
    };
    inject = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  "
    };
    shader_module_default = {
      name: "brushing",
      dependencies: [project_default],
      vs,
      fs,
      inject,
      getUniforms: (opts) => {
        if (!opts || !("viewport" in opts)) {
          return {};
        }
        const {
          brushingEnabled = true,
          brushingRadius = 1e4,
          brushingTarget = "source",
          mousePosition,
          viewport
        } = opts;
        return {
          brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
          brushing_radius: brushingRadius,
          brushing_target: TARGET[brushingTarget] || 0,
          brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
        };
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/brushing/brushing-extension.js
var defaultProps15, BrushingExtension;
var init_brushing_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/brushing-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_shader_module();
    defaultProps15 = {
      getBrushingTarget: {
        type: "accessor",
        value: [0, 0]
      },
      brushingTarget: "source",
      brushingEnabled: true,
      brushingRadius: 1e4
    };
    BrushingExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [shader_module_default]
        };
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.add({
            brushingTargets: {
              size: 2,
              accessor: "getBrushingTarget",
              shaderAttributes: {
                brushingTargets: {
                  divisor: 0
                },
                instanceBrushingTargets: {
                  divisor: 1
                }
              }
            }
          });
        }
        this.state.onMouseMove = () => {
          var _this$getCurrentLayer;
          (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.setNeedsRedraw();
        };
        if (context.deck) {
          context.deck.eventManager.on({
            pointermove: this.state.onMouseMove,
            pointerleave: this.state.onMouseMove
          });
        }
      }
      finalizeState(context, extension) {
        if (context.deck) {
          context.deck.eventManager.off({
            pointermove: this.state.onMouseMove,
            pointerleave: this.state.onMouseMove
          });
        }
      }
    };
    _defineProperty(BrushingExtension, "defaultProps", defaultProps15);
    _defineProperty(BrushingExtension, "extensionName", "BrushingExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js
function getUniforms(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const {
    filterRange = [-1, 1],
    filterEnabled = true,
    filterTransformSize = true,
    filterTransformColor = true
  } = opts;
  const filterSoftRange = opts.filterSoftRange || filterRange;
  return {
    ...Number.isFinite(filterRange[0]) ? {
      filter_min: filterRange[0],
      filter_softMin: filterSoftRange[0],
      filter_softMax: filterSoftRange[1],
      filter_max: filterRange[1]
    } : {
      filter_min: filterRange.map((r) => r[0]),
      filter_softMin: filterSoftRange.map((r) => r[0]),
      filter_softMax: filterSoftRange.map((r) => r[1]),
      filter_max: filterRange.map((r) => r[1])
    },
    filter_enabled: filterEnabled,
    filter_useSoftMargin: Boolean(opts.filterSoftRange),
    filter_transformSize: filterEnabled && filterTransformSize,
    filter_transformColor: filterEnabled && filterTransformColor
  };
}
function getUniforms64(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const uniforms = getUniforms(opts);
  if (Number.isFinite(uniforms.filter_min)) {
    const min64High = Math.fround(uniforms.filter_min);
    uniforms.filter_min -= min64High;
    uniforms.filter_softMin -= min64High;
    uniforms.filter_min64High = min64High;
    const max64High = Math.fround(uniforms.filter_max);
    uniforms.filter_max -= max64High;
    uniforms.filter_softMax -= max64High;
    uniforms.filter_max64High = max64High;
  } else {
    const min64High = uniforms.filter_min.map(Math.fround);
    uniforms.filter_min = uniforms.filter_min.map((x, i) => x - min64High[i]);
    uniforms.filter_softMin = uniforms.filter_softMin.map((x, i) => x - min64High[i]);
    uniforms.filter_min64High = min64High;
    const max64High = uniforms.filter_max.map(Math.fround);
    uniforms.filter_max = uniforms.filter_max.map((x, i) => x - max64High[i]);
    uniforms.filter_softMax = uniforms.filter_softMax.map((x, i) => x - max64High[i]);
    uniforms.filter_max64High = max64High;
  }
  return uniforms;
}
var vs2, fs2, inject2, shaderModule, shaderModule64;
var init_shader_module2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js"() {
    vs2 = "\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n";
    fs2 = "\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n";
    inject2 = {
      "vs:#main-start": "\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  ",
      "vs:#main-end": "\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  ",
      "vs:DECKGL_FILTER_SIZE": "\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  "
    };
    shaderModule = {
      name: "data-filter",
      vs: vs2,
      fs: fs2,
      inject: inject2,
      getUniforms
    };
    shaderModule64 = {
      name: "data-filter-fp64",
      vs: vs2,
      fs: fs2,
      inject: inject2,
      getUniforms: getUniforms64
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/aggregator.js
function supportsFloatTarget(gl) {
  return Boolean(gl.getExtension("EXT_float_blend") && (gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float")));
}
function getFramebuffer(gl, useFloatTarget) {
  if (useFloatTarget) {
    return new Framebuffer(gl, {
      width: 1,
      height: 1,
      attachments: {
        [36064]: new Texture2D(gl, {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126,
          mipmaps: false
        })
      }
    });
  }
  return new Framebuffer(gl, {
    width: 256,
    height: 64,
    depth: false
  });
}
function getModel(gl, shaderOptions, useFloatTarget) {
  shaderOptions.defines.NON_INSTANCED_MODEL = 1;
  if (useFloatTarget) {
    shaderOptions.defines.FLOAT_TARGET = 1;
  }
  return new Model(gl, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: false,
    drawMode: 0,
    vs: AGGREGATE_VS,
    fs: AGGREGATE_FS,
    ...shaderOptions
  });
}
var AGGREGATE_VS, AGGREGATE_FS, parameters;
var init_aggregator = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/aggregator.js"() {
    init_esm6();
    AGGREGATE_VS = "#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n";
    AGGREGATE_FS = "#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n";
    parameters = {
      blend: true,
      blendFunc: [1, 1, 1, 1],
      blendEquation: [32774, 32774],
      depthTest: false
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter-extension.js
var defaultProps16, DATA_TYPE_FROM_SIZE, DataFilterExtension;
var init_data_filter_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_shader_module2();
    init_aggregator();
    init_esm6();
    defaultProps16 = {
      getFilterValue: {
        type: "accessor",
        value: 0
      },
      onFilteredItemsChange: {
        type: "function",
        value: null,
        optional: true
      },
      filterEnabled: true,
      filterRange: [-1, 1],
      filterSoftRange: null,
      filterTransformSize: true,
      filterTransformColor: true
    };
    DATA_TYPE_FROM_SIZE = {
      1: "float",
      2: "vec2",
      3: "vec3",
      4: "vec4"
    };
    DataFilterExtension = class extends LayerExtension {
      constructor({
        filterSize = 1,
        fp64: fp642 = false,
        countItems = false
      } = {}) {
        if (!DATA_TYPE_FROM_SIZE[filterSize]) {
          throw new Error("filterSize out of range");
        }
        super({
          filterSize,
          fp64: fp642,
          countItems
        });
      }
      getShaders(extension) {
        const {
          filterSize,
          fp64: fp642
        } = extension.opts;
        return {
          modules: [fp642 ? shaderModule64 : shaderModule],
          defines: {
            DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
            DATAFILTER_DOUBLE: Boolean(fp642)
          }
        };
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) {
          attributeManager.add({
            filterValues: {
              size: extension.opts.filterSize,
              type: extension.opts.fp64 ? 5130 : 5126,
              accessor: "getFilterValue",
              shaderAttributes: {
                filterValues: {
                  divisor: 0
                },
                instanceFilterValues: {
                  divisor: 1
                }
              }
            }
          });
        }
        const {
          gl
        } = this.context;
        if (attributeManager && extension.opts.countItems) {
          const useFloatTarget = supportsFloatTarget(gl);
          attributeManager.add({
            filterIndices: {
              size: useFloatTarget ? 1 : 2,
              vertexOffset: 1,
              type: 5121,
              normalized: true,
              accessor: (object, {
                index
              }) => {
                const i = object && object.__source ? object.__source.index : index;
                return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];
              },
              shaderAttributes: {
                filterPrevIndices: {
                  vertexOffset: 0
                },
                filterIndices: {
                  vertexOffset: 1
                }
              }
            }
          });
          const filterFBO = getFramebuffer(gl, useFloatTarget);
          const filterModel = getModel(gl, extension.getShaders.call(this, extension), useFloatTarget);
          this.setState({
            filterFBO,
            filterModel
          });
        }
      }
      updateState({
        props,
        oldProps
      }) {
        if (this.state.filterModel) {
          const attributeManager = this.getAttributeManager();
          const filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange;
          if (filterNeedsUpdate) {
            this.setState({
              filterNeedsUpdate
            });
          }
        }
      }
      draw(params, extension) {
        const {
          filterFBO,
          filterModel,
          filterNeedsUpdate
        } = this.state;
        const {
          onFilteredItemsChange
        } = this.props;
        if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
          const {
            attributes: {
              filterValues,
              filterIndices
            }
          } = this.getAttributeManager();
          filterModel.setVertexCount(this.getNumInstances());
          const {
            gl
          } = this.context;
          clear(gl, {
            framebuffer: filterFBO,
            color: [0, 0, 0, 0]
          });
          filterModel.updateModuleSettings(params.moduleParameters).setAttributes({
            ...filterValues.getShaderAttributes(),
            ...filterIndices && filterIndices.getShaderAttributes()
          }).draw({
            framebuffer: filterFBO,
            parameters: {
              ...parameters,
              viewport: [0, 0, filterFBO.width, filterFBO.height]
            }
          });
          const color = readPixelsToArray(filterFBO);
          let count = 0;
          for (let i = 0; i < color.length; i++) {
            count += color[i];
          }
          onFilteredItemsChange({
            id: this.id,
            count
          });
          this.state.filterNeedsUpdate = false;
        }
      }
      finalizeState() {
        const {
          filterFBO,
          filterModel
        } = this.state;
        if (filterFBO) {
          filterFBO.color.delete();
          filterFBO.delete();
          filterModel.delete();
        }
      }
    };
    _defineProperty(DataFilterExtension, "defaultProps", defaultProps16);
    _defineProperty(DataFilterExtension, "extensionName", "DataFilterExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js
var project64_glsl_default;
var init_project64_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js"() {
    project64_glsl_default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n";
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js
function getUniforms2(opts) {
  if (opts && "viewport" in opts) {
    const {
      viewProjectionMatrix,
      scale
    } = opts.viewport;
    return getMemoizedUniforms({
      viewProjectionMatrix,
      scale
    });
  }
  return {};
}
function calculateUniforms({
  viewProjectionMatrix,
  scale
}) {
  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  const scaleFP64 = fp64ify(scale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}
var fp64ify, fp64ifyMatrix4, project64_default, getMemoizedUniforms;
var init_project64 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js"() {
    init_esm5();
    init_esm8();
    init_project64_glsl();
    ({
      fp64ify,
      fp64ifyMatrix4
    } = fp64);
    project64_default = {
      name: "project64",
      dependencies: [project_default, fp64],
      vs: project64_glsl_default,
      getUniforms: getUniforms2
    };
    getMemoizedUniforms = memoize(calculateUniforms);
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/fp64-extension.js
var Fp64Extension;
var init_fp64_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/fp64-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_project64();
    Fp64Extension = class extends LayerExtension {
      getShaders() {
        const {
          coordinateSystem
        } = this.props;
        if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
          throw new Error("fp64: coordinateSystem must be LNGLAT");
        }
        return {
          modules: [project64_default]
        };
      }
    };
    _defineProperty(Fp64Extension, "extensionName", "Fp64Extension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js
var dashShaders, offsetShaders;
var init_shaders_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js"() {
    dashShaders = {
      inject: {
        "vs:#decl": "\nattribute vec2 instanceDashArrays;\nattribute float instanceDashOffsets;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n",
        "vs:#main-end": "\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n",
        "fs:#decl": "\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n",
        "fs:#main-start": "\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(clamp(vPathPosition.y, 0.0, vPathLength) + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (capType <= 0.5) {\n        if (!(dashGapPickable && picking_uActive)) {\n          discard;\n        }\n      } else {\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(dashGapPickable && picking_uActive)) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n"
      }
    };
    offsetShaders = {
      inject: {
        "vs:#decl": "\nattribute float instanceOffsets;\n",
        "vs:DECKGL_FILTER_SIZE": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n",
        "vCornerOffset = offsetVec;": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  vec2 offsetCenter = -instanceOffsets * (isCap ? perp : miterVec * miterSize) * 2.0;\n  vCornerOffset = vCornerOffset * offsetWidth - offsetCenter;\n",
        "fs:#main-start": "\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n"
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js
var defaultProps17, PathStyleExtension;
var init_path_style_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_shaders_glsl();
    init_vec3();
    defaultProps17 = {
      getDashArray: {
        type: "accessor",
        value: [0, 0]
      },
      getOffset: {
        type: "accessor",
        value: 0
      },
      dashJustified: false,
      dashGapPickable: false
    };
    PathStyleExtension = class extends LayerExtension {
      constructor({
        dash = false,
        offset = false,
        highPrecisionDash = false
      } = {}) {
        super({
          dash: dash || highPrecisionDash,
          offset,
          highPrecisionDash
        });
      }
      isEnabled(layer) {
        return "pathTesselator" in layer.state;
      }
      getShaders(extension) {
        if (!extension.isEnabled(this)) {
          return null;
        }
        let result = {};
        if (extension.opts.dash) {
          result = mergeShaders(result, dashShaders);
        }
        if (extension.opts.offset) {
          result = mergeShaders(result, offsetShaders);
        }
        return result;
      }
      initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager || !extension.isEnabled(this)) {
          return;
        }
        if (extension.opts.dash) {
          attributeManager.addInstanced({
            instanceDashArrays: {
              size: 2,
              accessor: "getDashArray"
            }
          });
        }
        if (extension.opts.highPrecisionDash) {
          attributeManager.addInstanced({
            instanceDashOffsets: {
              size: 1,
              accessor: "getPath",
              transform: extension.getDashOffsets.bind(this)
            }
          });
        }
        if (extension.opts.offset) {
          attributeManager.addInstanced({
            instanceOffsets: {
              size: 1,
              accessor: "getOffset"
            }
          });
        }
      }
      updateState(params, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const uniforms = {};
        if (extension.opts.dash) {
          uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
          uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
        }
        this.state.model.setUniforms(uniforms);
      }
      getDashOffsets(path) {
        const result = [0];
        const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
        const isNested = Array.isArray(path[0]);
        const geometrySize = isNested ? path.length : path.length / positionSize;
        let p;
        let prevP;
        for (let i = 0; i < geometrySize - 1; i++) {
          p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);
          p = this.projectPosition(p);
          if (i > 0) {
            result[i] = result[i - 1] + dist(prevP, p);
          }
          prevP = p;
        }
        return result;
      }
    };
    _defineProperty(PathStyleExtension, "defaultProps", defaultProps17);
    _defineProperty(PathStyleExtension, "extensionName", "PathStyleExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js
function getPatternUniforms(opts, uniforms) {
  if (!opts) {
    return {};
  }
  if ("fillPatternTexture" in opts) {
    const {
      fillPatternTexture
    } = opts;
    return {
      fill_patternTexture: fillPatternTexture,
      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
    };
  }
  if ("viewport" in opts) {
    const {
      fillPatternMask = true,
      fillPatternEnabled = true
    } = opts;
    const {
      project_uCommonOrigin: coordinateOriginCommon
    } = uniforms;
    const coordinateOriginCommon64Low = [fp64LowPart(coordinateOriginCommon[0]), fp64LowPart(coordinateOriginCommon[1])];
    return {
      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
      fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,
      fill_patternMask: fillPatternMask,
      fill_patternEnabled: fillPatternEnabled
    };
  }
  return {};
}
var patternVs, patternFs, inject3, patternShaders;
var init_shaders_glsl2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js"() {
    init_esm8();
    patternVs = "\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\n";
    patternFs = "\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\nuniform vec2 fill_uvCoordinateOrigin64Low;\n\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n";
    inject3 = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    fill_uv = geometry.position.xy;\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\n      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n\n      vec4 patternColor = texture2D(fill_patternTexture, texCoords);\n      color.a *= patternColor.a;\n      if (!fill_patternMask) {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  "
    };
    patternShaders = {
      name: "fill-pattern",
      vs: patternVs,
      fs: patternFs,
      inject: inject3,
      dependencies: [project_default],
      getUniforms: getPatternUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style-extension.js
var defaultProps18, FillStyleExtension;
var init_fill_style_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_esm6();
    init_shaders_glsl2();
    defaultProps18 = {
      fillPatternEnabled: true,
      fillPatternAtlas: {
        type: "image",
        value: null,
        async: true,
        parameters: {
          [10241]: 9729
        }
      },
      fillPatternMapping: {
        type: "object",
        value: {},
        async: true
      },
      fillPatternMask: true,
      getFillPattern: {
        type: "accessor",
        value: (d) => d.pattern
      },
      getFillPatternScale: {
        type: "accessor",
        value: 1
      },
      getFillPatternOffset: {
        type: "accessor",
        value: [0, 0]
      }
    };
    FillStyleExtension = class extends LayerExtension {
      constructor({
        pattern = false
      } = {}) {
        super({
          pattern
        });
      }
      isEnabled(layer) {
        return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
      }
      getShaders(extension) {
        if (!extension.isEnabled(this)) {
          return null;
        }
        return {
          modules: [extension.opts.pattern && patternShaders].filter(Boolean)
        };
      }
      initializeState(context, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const attributeManager = this.getAttributeManager();
        if (extension.opts.pattern) {
          attributeManager.add({
            fillPatternFrames: {
              size: 4,
              accessor: "getFillPattern",
              transform: extension.getPatternFrame.bind(this),
              shaderAttributes: {
                fillPatternFrames: {
                  divisor: 0
                },
                instanceFillPatternFrames: {
                  divisor: 1
                }
              }
            },
            fillPatternScales: {
              size: 1,
              accessor: "getFillPatternScale",
              defaultValue: 1,
              shaderAttributes: {
                fillPatternScales: {
                  divisor: 0
                },
                instanceFillPatternScales: {
                  divisor: 1
                }
              }
            },
            fillPatternOffsets: {
              size: 2,
              accessor: "getFillPatternOffset",
              shaderAttributes: {
                fillPatternOffsets: {
                  divisor: 0
                },
                instanceFillPatternOffsets: {
                  divisor: 1
                }
              }
            }
          });
        }
        this.setState({
          emptyTexture: new Texture2D(this.context.gl, {
            data: new Uint8Array(4),
            width: 1,
            height: 1
          })
        });
      }
      updateState({
        props,
        oldProps
      }, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
          this.getAttributeManager().invalidate("getFillPattern");
        }
      }
      draw(params, extension) {
        if (!extension.isEnabled(this)) {
          return;
        }
        const {
          fillPatternAtlas
        } = this.props;
        this.setModuleParameters({
          fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
        });
      }
      finalizeState() {
        const {
          emptyTexture
        } = this.state;
        emptyTexture === null || emptyTexture === void 0 ? void 0 : emptyTexture.delete();
      }
      getPatternFrame(name) {
        const {
          fillPatternMapping
        } = this.getCurrentLayer().props;
        const def = fillPatternMapping && fillPatternMapping[name];
        return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
      }
    };
    _defineProperty(FillStyleExtension, "defaultProps", defaultProps18);
    _defineProperty(FillStyleExtension, "extensionName", "FillStyleExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/clip/clip-extension.js
var defaultProps19, shaderFunction, shaderModuleVs, injectionVs, shaderModuleFs, injectionFs, ClipExtension;
var init_clip_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/clip/clip-extension.js"() {
    init_defineProperty();
    init_esm8();
    defaultProps19 = {
      clipBounds: [0, 0, 1, 1],
      clipByInstance: void 0
    };
    shaderFunction = "\nuniform vec4 clip_bounds;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n";
    shaderModuleVs = {
      name: "clip-vs",
      vs: shaderFunction
    };
    injectionVs = {
      "vs:#decl": "\nvarying float clip_isVisible;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n",
      "fs:#decl": "\nvarying float clip_isVisible;\n",
      "fs:DECKGL_FILTER_COLOR": "\n  if (clip_isVisible < 0.5) discard;\n"
    };
    shaderModuleFs = {
      name: "clip-fs",
      fs: shaderFunction
    };
    injectionFs = {
      "vs:#decl": "\nvarying vec2 clip_commonPosition;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_commonPosition = geometry.position.xy;\n",
      "fs:#decl": "\nvarying vec2 clip_commonPosition;\n",
      "fs:DECKGL_FILTER_COLOR": "\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n"
    };
    ClipExtension = class extends LayerExtension {
      getShaders() {
        let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
        if (this.props.clipByInstance !== void 0) {
          clipByInstance = Boolean(this.props.clipByInstance);
        }
        this.state.clipByInstance = clipByInstance;
        return clipByInstance ? {
          modules: [shaderModuleVs],
          inject: injectionVs
        } : {
          modules: [shaderModuleFs],
          inject: injectionFs
        };
      }
      draw({
        uniforms
      }) {
        const {
          clipBounds
        } = this.props;
        if (this.state.clipByInstance) {
          uniforms.clip_bounds = clipBounds;
        } else {
          const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
          const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
          uniforms.clip_bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];
        }
      }
    };
    _defineProperty(ClipExtension, "defaultProps", defaultProps19);
    _defineProperty(ClipExtension, "extensionName", "ClipExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/shader-module.js
var vs3, inject4, getCollisionUniforms, shader_module_default2;
var init_shader_module3 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/shader-module.js"() {
    init_esm8();
    vs3 = "\n#ifdef NON_INSTANCED_MODEL\nattribute float collisionPriorities;\n#else\nattribute float instanceCollisionPriorities;\n#endif\n\nuniform sampler2D collision_texture;\nuniform bool collision_sort;\nuniform bool collision_enabled;\n\nvec2 collision_getCoords(vec4 position) {\n  vec4 collision_clipspace = project_common_position_to_clipspace(position);\n  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\n\nfloat collision_match(vec2 tex, vec3 pickingColor) {\n  vec4 collision_pickingColor = texture2D(collision_texture, tex);\n  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\n  float e = 0.001;\n  return step(delta, e);\n}\n\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\n  if (!collision_enabled) {\n    return 1.0;\n  }\n\n  // Visibility test, sample area of 5x5 pixels in order to fade in/out.\n  // Due to the locality, the lookups will be cached\n  // This reduces the flicker present when objects are shown/hidden\n  const int N = 2;\n  float accumulator = 0.0;\n  vec2 step = vec2(1.0 / project_uViewportSize);\n\n  const float floatN = float(N);\n  vec2 delta = -floatN * step;\n  for(int i = -N; i <= N; i++) {\n    delta.x = -step.x * floatN;\n    for(int j = -N; j <= N; j++) {\n      accumulator += collision_match(texCoords + delta, pickingColor);\n      delta.x += step.x;\n    }\n    delta.y += step.y;\n  }\n\n  float W = 2.0 * floatN + 1.0;\n  return pow(accumulator / (W * W), 2.2);\n}\n";
    inject4 = {
      "vs:#decl": "\n  float collision_fade = 1.0;\n",
      "vs:DECKGL_FILTER_GL_POSITION": "\n  if (collision_sort) {\n    #ifdef NON_INSTANCED_MODEL\n    float collisionPriority = collisionPriorities;\n    #else\n    float collisionPriority = instanceCollisionPriorities;\n    #endif\n    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000\n  }\n\n  if (collision_enabled) {\n    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n    vec2 collision_texCoords = collision_getCoords(collision_common_position);\n    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\n    if (collision_fade < 0.0001) {\n      // Position outside clip space bounds to discard\n      position = vec4(0.0, 0.0, 2.0, 1.0);\n    }\n  }\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n  color.a *= collision_fade;\n  "
    };
    getCollisionUniforms = (opts, uniforms) => {
      if (!opts || !("dummyCollisionMap" in opts)) {
        return {};
      }
      const {
        collisionFBO,
        drawToCollisionMap,
        dummyCollisionMap
      } = opts;
      return {
        collision_sort: Boolean(drawToCollisionMap),
        collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO : dummyCollisionMap
      };
    };
    shader_module_default2 = {
      name: "collision",
      dependencies: [project_default],
      vs: vs3,
      inject: inject4,
      getUniforms: getCollisionUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-pass.js
var CollisionFilterPass;
var init_collision_filter_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-pass.js"() {
    init_esm6();
    init_esm8();
    CollisionFilterPass = class extends LayersPass {
      renderCollisionMap(target, options) {
        const gl = this.gl;
        const padding = 1;
        return withParameters(gl, {
          scissorTest: true,
          scissor: [padding, padding, target.width - 2 * padding, target.height - 2 * padding],
          clearColor: [0, 0, 0, 0],
          blend: false,
          depthTest: true,
          depthRange: [0, 1]
        }, () => this.render({
          ...options,
          target,
          pass: "collision"
        }));
      }
      getModuleParameters() {
        return {
          drawToCollisionMap: true,
          pickingActive: 1,
          pickingAttribute: false,
          lightSources: {}
        };
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-pass.js
var MaskPass;
var init_mask_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-pass.js"() {
    init_defineProperty();
    init_esm6();
    init_esm8();
    MaskPass = class extends LayersPass {
      constructor(gl, props) {
        super(gl, props);
        _defineProperty(this, "maskMap", void 0);
        _defineProperty(this, "fbo", void 0);
        const {
          mapSize = 2048
        } = props;
        this.maskMap = new Texture2D(gl, {
          width: mapSize,
          height: mapSize,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.fbo = new Framebuffer(gl, {
          id: "maskmap",
          width: mapSize,
          height: mapSize,
          attachments: {
            [36064]: this.maskMap
          }
        });
      }
      render(options) {
        const gl = this.gl;
        const colorMask = [false, false, false, false];
        colorMask[options.channel] = true;
        return withParameters(gl, {
          clearColor: [255, 255, 255, 255],
          blend: true,
          blendFunc: [0, 1],
          blendEquation: 32778,
          colorMask,
          depthTest: false
        }, () => super.render({
          ...options,
          target: this.fbo,
          pass: "mask"
        }));
      }
      shouldDrawLayer(layer) {
        return layer.props.operation.includes("mask");
      }
      delete() {
        this.fbo.delete();
        this.maskMap.delete();
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js
function joinLayerBounds(layers, viewport) {
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (const layer of layers) {
    const layerBounds = layer.getBounds();
    if (layerBounds) {
      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {
        viewport,
        autoOffset: false
      });
      const topRightCommon = layer.projectPosition(layerBounds[1], {
        viewport,
        autoOffset: false
      });
      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
      bounds[2] = Math.max(bounds[2], topRightCommon[0]);
      bounds[3] = Math.max(bounds[3], topRightCommon[1]);
    }
  }
  if (Number.isFinite(bounds[0])) {
    return bounds;
  }
  return null;
}
function makeViewport(opts) {
  const {
    bounds,
    viewport,
    border = 0
  } = opts;
  const {
    isGeospatial
  } = viewport;
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }
  const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);
  let {
    width,
    height,
    zoom
  } = opts;
  if (zoom === void 0) {
    width = width - border * 2;
    height = height - border * 2;
    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    zoom = Math.min(Math.log2(scale), 20);
  } else if (!width || !height) {
    const scale = 2 ** zoom;
    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);
    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);
    const maxSize = MAX_VIEWPORT_SIZE - border * 2;
    if (width > maxSize || height > maxSize) {
      const r = maxSize / Math.max(width, height);
      width = Math.round(width * r);
      height = Math.round(height * r);
      zoom += Math.log2(r);
    }
  }
  return isGeospatial ? new WebMercatorViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    longitude: centerWorld[0],
    latitude: centerWorld[1],
    zoom,
    orthographic: true
  }) : new OrthographicViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    target: centerWorld,
    zoom,
    flipY: false
  });
}
function getViewportBounds(viewport, zRange) {
  let viewportBoundsWorld;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({
      z: minZ
    });
    const bounds1 = viewport.getBounds({
      z: maxZ
    });
    viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  } else {
    viewportBoundsWorld = viewport.getBounds();
  }
  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
  return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];
}
function getRenderBounds(layerBounds, viewport, zRange) {
  if (!layerBounds) {
    return [0, 0, 1, 1];
  }
  const viewportBounds = getViewportBounds(viewport, zRange);
  const paddedBounds = doubleBounds(viewportBounds);
  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
    return layerBounds;
  }
  return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];
}
function doubleBounds(bounds) {
  const dx = bounds[2] - bounds[0];
  const dy = bounds[3] - bounds[1];
  const centerX = (bounds[0] + bounds[2]) / 2;
  const centerY = (bounds[1] + bounds[3]) / 2;
  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
}
var MAX_VIEWPORT_SIZE;
var init_projection_utils = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js"() {
    init_esm8();
    MAX_VIEWPORT_SIZE = 2048;
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js
var MaskEffect;
var init_mask_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js"() {
    init_defineProperty();
    init_esm8();
    init_esm6();
    init_esm4();
    init_mask_pass();
    init_projection_utils();
    MaskEffect = class {
      constructor() {
        _defineProperty(this, "id", "mask-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "order", 0);
        _defineProperty(this, "dummyMaskMap", void 0);
        _defineProperty(this, "channels", []);
        _defineProperty(this, "masks", null);
        _defineProperty(this, "maskPass", void 0);
        _defineProperty(this, "maskMap", void 0);
        _defineProperty(this, "lastViewport", void 0);
      }
      preRender(gl, {
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        isPicking
      }) {
        let didRender = false;
        if (!this.dummyMaskMap) {
          this.dummyMaskMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        if (isPicking) {
          return {
            didRender
          };
        }
        const maskLayers = layers.filter((l) => l.props.visible && l.props.operation.includes("mask"));
        if (maskLayers.length === 0) {
          this.masks = null;
          this.channels.length = 0;
          return {
            didRender
          };
        }
        this.masks = {};
        if (!this.maskPass) {
          this.maskPass = new MaskPass(gl, {
            id: "default-mask"
          });
          this.maskMap = this.maskPass.maskMap;
        }
        const channelMap = this._sortMaskChannels(maskLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
        if (viewport.resolution !== void 0) {
          log_default.warn("MaskExtension is not supported in GlobeView")();
          return {
            didRender
          };
        }
        for (const maskId in channelMap) {
          const result = this._renderChannel(channelMap[maskId], {
            layerFilter,
            onViewportActive,
            views,
            viewport,
            viewportChanged
          });
          didRender || (didRender = result);
        }
        return {
          didRender
        };
      }
      _renderChannel(channelInfo, {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      }) {
        let didRender = false;
        const oldChannelInfo = this.channels[channelInfo.index];
        if (!oldChannelInfo) {
          return didRender;
        }
        const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) => layer !== oldChannelInfo.layers[i] || layer.props.transitions) || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);
        channelInfo.bounds = oldChannelInfo.bounds;
        channelInfo.maskBounds = oldChannelInfo.maskBounds;
        this.channels[channelInfo.index] = channelInfo;
        if (maskChanged || viewportChanged) {
          this.lastViewport = viewport;
          const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
          channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
          if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
            const {
              maskPass,
              maskMap
            } = this;
            const maskViewport = layerBounds && makeViewport({
              bounds: channelInfo.bounds,
              viewport,
              width: maskMap.width,
              height: maskMap.height,
              border: 1
            });
            channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
            maskPass.render({
              pass: "mask",
              channel: channelInfo.index,
              layers: channelInfo.layers,
              layerFilter,
              viewports: maskViewport ? [maskViewport] : [],
              onViewportActive,
              views,
              moduleParameters: {
                devicePixelRatio: 1
              }
            });
            didRender = true;
          }
        }
        this.masks[channelInfo.id] = {
          index: channelInfo.index,
          bounds: channelInfo.maskBounds,
          coordinateOrigin: channelInfo.coordinateOrigin,
          coordinateSystem: channelInfo.coordinateSystem
        };
        return didRender;
      }
      _sortMaskChannels(maskLayers) {
        const channelMap = {};
        let channelCount = 0;
        for (const layer of maskLayers) {
          const {
            id
          } = layer.root;
          let channelInfo = channelMap[id];
          if (!channelInfo) {
            if (++channelCount > 4) {
              log_default.warn("Too many mask layers. The max supported is 4")();
              continue;
            }
            channelInfo = {
              id,
              index: this.channels.findIndex((c) => (c === null || c === void 0 ? void 0 : c.id) === id),
              layers: [],
              layerBounds: [],
              coordinateOrigin: layer.root.props.coordinateOrigin,
              coordinateSystem: layer.root.props.coordinateSystem
            };
            channelMap[id] = channelInfo;
          }
          channelInfo.layers.push(layer);
          channelInfo.layerBounds.push(layer.getBounds());
        }
        for (let i = 0; i < 4; i++) {
          const channelInfo = this.channels[i];
          if (!channelInfo || !(channelInfo.id in channelMap)) {
            this.channels[i] = null;
          }
        }
        for (const maskId in channelMap) {
          const channelInfo = channelMap[maskId];
          if (channelInfo.index < 0) {
            channelInfo.index = this.channels.findIndex((c) => !c);
            this.channels[channelInfo.index] = channelInfo;
          }
        }
        return channelMap;
      }
      getModuleParameters() {
        return {
          maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
          maskChannels: this.masks
        };
      }
      cleanup() {
        if (this.dummyMaskMap) {
          this.dummyMaskMap.delete();
          this.dummyMaskMap = void 0;
        }
        if (this.maskPass) {
          this.maskPass.delete();
          this.maskPass = void 0;
          this.maskMap = void 0;
        }
        this.lastViewport = void 0;
        this.masks = null;
        this.channels.length = 0;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-effect.js
var DOWNSCALE, CollisionFilterEffect;
var init_collision_filter_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-effect.js"() {
    init_defineProperty();
    init_esm6();
    init_esm4();
    init_esm8();
    init_collision_filter_pass();
    init_mask_effect();
    DOWNSCALE = 2;
    CollisionFilterEffect = class {
      constructor() {
        _defineProperty(this, "id", "collision-filter-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "order", 1);
        _defineProperty(this, "channels", {});
        _defineProperty(this, "collisionFilterPass", void 0);
        _defineProperty(this, "collisionFBOs", {});
        _defineProperty(this, "dummyCollisionMap", void 0);
        _defineProperty(this, "lastViewport", void 0);
      }
      preRender(gl, {
        effects: allEffects,
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        isPicking,
        preRenderStats = {}
      }) {
        var _preRenderStats$mask;
        if (!this.dummyCollisionMap) {
          this.dummyCollisionMap = new Texture2D(gl, {
            width: 1,
            height: 1
          });
        }
        if (isPicking) {
          return;
        }
        const collisionLayers = layers.filter(({
          props: {
            visible,
            collisionEnabled
          }
        }) => visible && collisionEnabled);
        if (collisionLayers.length === 0) {
          this.channels = {};
          return;
        }
        if (!this.collisionFilterPass) {
          this.collisionFilterPass = new CollisionFilterPass(gl, {
            id: "default-collision-filter"
          });
        }
        const effects = allEffects === null || allEffects === void 0 ? void 0 : allEffects.filter((e) => e.constructor === MaskEffect);
        const maskEffectRendered = (_preRenderStats$mask = preRenderStats["mask-effect"]) === null || _preRenderStats$mask === void 0 ? void 0 : _preRenderStats$mask.didRender;
        const channels = this._groupByCollisionGroup(gl, collisionLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
        for (const collisionGroup in channels) {
          const collisionFBO = this.collisionFBOs[collisionGroup];
          const renderInfo = channels[collisionGroup];
          collisionFBO.resize({
            width: gl.canvas.width / DOWNSCALE,
            height: gl.canvas.height / DOWNSCALE
          });
          this._render(renderInfo, {
            effects,
            layerFilter,
            onViewportActive,
            views,
            viewport,
            viewportChanged
          });
        }
      }
      _render(renderInfo, {
        effects,
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      }) {
        const {
          collisionGroup
        } = renderInfo;
        const oldRenderInfo = this.channels[collisionGroup];
        if (!oldRenderInfo) {
          return;
        }
        const needsRender = viewportChanged || renderInfo === oldRenderInfo || !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) || renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || renderInfo.layers.some((layer) => layer.props.transitions);
        this.channels[collisionGroup] = renderInfo;
        if (needsRender) {
          this.lastViewport = viewport;
          const collisionFBO = this.collisionFBOs[collisionGroup];
          this.collisionFilterPass.renderCollisionMap(collisionFBO, {
            pass: "collision-filter",
            isPicking: true,
            layers: renderInfo.layers,
            effects,
            layerFilter,
            viewports: viewport ? [viewport] : [],
            onViewportActive,
            views,
            moduleParameters: {
              dummyCollisionMap: this.dummyCollisionMap,
              devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE
            }
          });
        }
      }
      _groupByCollisionGroup(gl, collisionLayers) {
        const channelMap = {};
        for (const layer of collisionLayers) {
          const {
            collisionGroup
          } = layer.props;
          let channelInfo = channelMap[collisionGroup];
          if (!channelInfo) {
            channelInfo = {
              collisionGroup,
              layers: [],
              layerBounds: [],
              allLayersLoaded: true
            };
            channelMap[collisionGroup] = channelInfo;
          }
          channelInfo.layers.push(layer);
          channelInfo.layerBounds.push(layer.getBounds());
          if (!layer.isLoaded) {
            channelInfo.allLayersLoaded = false;
          }
        }
        for (const collisionGroup of Object.keys(channelMap)) {
          if (!this.collisionFBOs[collisionGroup]) {
            this.createFBO(gl, collisionGroup);
          }
          if (!this.channels[collisionGroup]) {
            this.channels[collisionGroup] = channelMap[collisionGroup];
          }
        }
        for (const collisionGroup of Object.keys(this.collisionFBOs)) {
          if (!channelMap[collisionGroup]) {
            this.destroyFBO(collisionGroup);
          }
        }
        return channelMap;
      }
      getModuleParameters(layer) {
        const {
          collisionGroup
        } = layer.props;
        const {
          collisionFBOs,
          dummyCollisionMap
        } = this;
        return {
          collisionFBO: collisionFBOs[collisionGroup],
          dummyCollisionMap
        };
      }
      cleanup() {
        if (this.dummyCollisionMap) {
          this.dummyCollisionMap.delete();
          this.dummyCollisionMap = void 0;
        }
        this.channels = {};
        for (const collisionGroup of Object.keys(this.collisionFBOs)) {
          this.destroyFBO(collisionGroup);
        }
        this.collisionFBOs = {};
        this.lastViewport = void 0;
      }
      createFBO(gl, collisionGroup) {
        const {
          width,
          height
        } = gl.canvas;
        const collisionMap = new Texture2D(gl, {
          width,
          height,
          parameters: {
            [10241]: 9728,
            [10240]: 9728,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        const depthBuffer = new Renderbuffer(gl, {
          format: 33189,
          width,
          height
        });
        this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {
          id: "Collision-".concat(collisionGroup),
          width,
          height,
          attachments: {
            [36064]: collisionMap,
            [36096]: depthBuffer
          }
        });
      }
      destroyFBO(collisionGroup) {
        const fbo = this.collisionFBOs[collisionGroup];
        for (const attachment of Object.values(fbo.attachments)) {
          attachment.delete();
        }
        fbo.delete();
        delete this.collisionFBOs[collisionGroup];
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-extension.js
var defaultProps20, CollisionFilterExtension;
var init_collision_filter_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_shader_module3();
    init_collision_filter_effect();
    defaultProps20 = {
      getCollisionPriority: {
        type: "accessor",
        value: 0
      },
      collisionEnabled: true,
      collisionGroup: {
        type: "string",
        value: "default"
      },
      collisionTestProps: {}
    };
    CollisionFilterExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [shader_module_default2]
        };
      }
      draw({
        uniforms,
        context,
        moduleParameters
      }) {
        const {
          collisionEnabled
        } = this.props;
        const {
          collisionFBO,
          drawToCollisionMap
        } = moduleParameters;
        const enabled = collisionEnabled && Boolean(collisionFBO);
        uniforms.collision_enabled = enabled;
        if (drawToCollisionMap) {
          this.props = this.clone(this.props.collisionTestProps).props;
        }
      }
      initializeState(context, extension) {
        var _this$context$deck;
        if (this.getAttributeManager() === null) {
          return;
        }
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new CollisionFilterEffect());
        const attributeManager = this.getAttributeManager();
        attributeManager.add({
          collisionPriorities: {
            size: 1,
            accessor: "getCollisionPriority",
            shaderAttributes: {
              collisionPriorities: {
                divisor: 0
              },
              instanceCollisionPriorities: {
                divisor: 1
              }
            }
          }
        });
      }
      getNeedsPickingBuffer() {
        return this.props.collisionEnabled;
      }
    };
    _defineProperty(CollisionFilterExtension, "defaultProps", defaultProps20);
    _defineProperty(CollisionFilterExtension, "extensionName", "CollisionFilterExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/shader-module.js
var vs4, fs3, inject5, getMaskUniforms, shader_module_default3;
var init_shader_module4 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/shader-module.js"() {
    init_esm8();
    vs4 = "\nuniform vec4 mask_bounds;\nuniform bool mask_maskByInstance;\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);\n}\n";
    fs3 = "\nuniform sampler2D mask_texture;\nuniform int mask_channel;\nuniform bool mask_enabled;\nuniform bool mask_inverted;\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask_enabled) {\n    return true;\n  }\n  vec4 maskColor = texture2D(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask_channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask_channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask_channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask_channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask_inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n";
    inject5 = {
      "vs:#decl": "\nvarying vec2 mask_texCoords;\n",
      "vs:#main-end": "\n   vec4 mask_common_position;\n   if (mask_maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n",
      "fs:#decl": "\nvarying vec2 mask_texCoords;\n",
      "fs:#main-start": "\n  if (mask_enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // gl_FragColor = vec4(mask_texCoords, 0.0, 1.0);\n    gl_FragColor = texture2D(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n"
    };
    getMaskUniforms = (opts) => {
      if (opts && "maskMap" in opts) {
        return {
          mask_texture: opts.maskMap
        };
      }
      return {};
    };
    shader_module_default3 = {
      name: "mask",
      dependencies: [project_default],
      vs: vs4,
      fs: fs3,
      inject: inject5,
      getUniforms: getMaskUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-extension.js
var defaultProps21, MaskExtension;
var init_mask_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/mask/mask-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_shader_module4();
    init_mask_effect();
    defaultProps21 = {
      maskId: "",
      maskByInstance: void 0,
      maskInverted: false
    };
    MaskExtension = class extends LayerExtension {
      initializeState() {
        var _this$context$deck;
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new MaskEffect());
      }
      getShaders() {
        let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
        if (this.props.maskByInstance !== void 0) {
          maskByInstance = Boolean(this.props.maskByInstance);
        }
        this.state.maskByInstance = maskByInstance;
        return {
          modules: [shader_module_default3]
        };
      }
      draw({
        uniforms,
        context,
        moduleParameters
      }) {
        uniforms.mask_maskByInstance = this.state.maskByInstance;
        const {
          maskId,
          maskInverted
        } = this.props;
        const {
          maskChannels
        } = moduleParameters;
        const {
          viewport
        } = context;
        if (maskChannels && maskChannels[maskId]) {
          const {
            index,
            bounds,
            coordinateOrigin: fromCoordinateOrigin
          } = maskChannels[maskId];
          let {
            coordinateSystem: fromCoordinateSystem
          } = maskChannels[maskId];
          uniforms.mask_enabled = true;
          uniforms.mask_channel = index;
          uniforms.mask_inverted = maskInverted;
          if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
            fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
          }
          const opts = {
            modelMatrix: null,
            fromCoordinateOrigin,
            fromCoordinateSystem
          };
          const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
          const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
          uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];
        } else {
          if (maskId) {
            log_default.warn("Could not find a mask layer with id: ".concat(maskId))();
          }
          uniforms.mask_enabled = false;
        }
      }
    };
    _defineProperty(MaskExtension, "defaultProps", defaultProps21);
    _defineProperty(MaskExtension, "extensionName", "MaskExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/shader-module.js
var TERRAIN_MODE, TERRAIN_MODE_CONSTANTS, terrainModule;
var init_shader_module5 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/shader-module.js"() {
    init_esm8();
    TERRAIN_MODE = {
      NONE: 0,
      WRITE_HEIGHT_MAP: 1,
      USE_HEIGHT_MAP: 2,
      USE_COVER: 3,
      USE_COVER_ONLY: 4,
      SKIP: 5
    };
    TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => "const float TERRAIN_MODE_".concat(key, " = ").concat(TERRAIN_MODE[key], ".0;")).join("\n");
    terrainModule = {
      name: "terrain",
      dependencies: [project_default],
      inject: {
        "vs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
        "vs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n",
        "vs:DECKGL_FILTER_GL_POSITION": "\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture2D(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    ",
        "fs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
        "fs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    ",
        "fs:DECKGL_FILTER_COLOR": "\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  vec4 pixel = texture2D(terrain_map, texCoords);\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    "
      },
      getUniforms: (opts = {}, uniforms) => {
        if ("dummyHeightMap" in opts) {
          const {
            drawToTerrainHeightMap,
            heightMap,
            heightMapBounds,
            dummyHeightMap,
            terrainCover,
            useTerrainHeightMap,
            terrainSkipRender
          } = opts;
          const {
            project_uCommonOrigin
          } = uniforms;
          let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
          let sampler = dummyHeightMap;
          let bounds = null;
          if (drawToTerrainHeightMap) {
            mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
            bounds = heightMapBounds;
          } else if (useTerrainHeightMap && heightMap) {
            mode = TERRAIN_MODE.USE_HEIGHT_MAP;
            sampler = heightMap;
            bounds = heightMapBounds;
          } else if (terrainCover) {
            const isPicking = opts.pickingActive;
            sampler = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
            if (isPicking) {
              mode = TERRAIN_MODE.SKIP;
            }
            if (sampler) {
              mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
              bounds = terrainCover.bounds;
            } else {
              sampler = dummyHeightMap;
            }
          }
          return {
            terrain_mode: mode,
            terrain_map: sampler,
            terrain_bounds: bounds ? [bounds[0] - project_uCommonOrigin[0], bounds[1] - project_uCommonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]
          };
        }
        return null;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/utils.js
function createRenderTarget(gl, opts) {
  return new Framebuffer(gl, {
    id: opts.id,
    attachments: {
      [36064]: new Texture2D(gl, {
        ...opts.float && {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126
        },
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      })
    }
  });
}
var init_utils3 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/utils.js"() {
    init_esm6();
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-cover.js
function getIntersectingLayers(sourceTile, layers) {
  return layers.filter((layer) => {
    const tile = getTile(layer);
    if (tile) {
      return intersect(sourceTile.boundingBox, tile.boundingBox);
    }
    return true;
  });
}
function getTile(layer) {
  while (layer) {
    const {
      tile
    } = layer.props;
    if (tile) {
      return tile;
    }
    layer = layer.parent;
  }
  return null;
}
function intersect(b1, b2) {
  if (b1 && b2) {
    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
  }
  return false;
}
var TerrainCover;
var init_terrain_cover = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-cover.js"() {
    init_defineProperty();
    init_utils3();
    init_projection_utils();
    TerrainCover = class {
      constructor(targetLayer) {
        _defineProperty(this, "isDirty", true);
        _defineProperty(this, "targetLayer", void 0);
        _defineProperty(this, "renderViewport", null);
        _defineProperty(this, "bounds", null);
        _defineProperty(this, "fbo", void 0);
        _defineProperty(this, "pickingFbo", void 0);
        _defineProperty(this, "layers", []);
        _defineProperty(this, "tile", void 0);
        _defineProperty(this, "targetBounds", null);
        _defineProperty(this, "targetBoundsCommon", null);
        this.targetLayer = targetLayer;
        this.tile = getTile(targetLayer);
      }
      get id() {
        return this.targetLayer.id;
      }
      get isActive() {
        return Boolean(this.targetLayer.getCurrentLayer());
      }
      shouldUpdate({
        targetLayer,
        viewport,
        layers,
        layerNeedsRedraw
      }) {
        if (targetLayer) {
          this.targetLayer = targetLayer;
        }
        const sizeChanged = viewport ? this._updateViewport(viewport) : false;
        let layersChanged = layers ? this._updateLayers(layers) : false;
        if (layerNeedsRedraw) {
          for (const id of this.layers) {
            if (layerNeedsRedraw[id]) {
              layersChanged = true;
              break;
            }
          }
        }
        return layersChanged || sizeChanged;
      }
      _updateLayers(layers) {
        let needsRedraw = false;
        layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
        if (layers.length !== this.layers.length) {
          needsRedraw = true;
        } else {
          for (let i = 0; i < layers.length; i++) {
            const id = layers[i].id;
            if (id !== this.layers[i]) {
              needsRedraw = true;
              break;
            }
          }
        }
        if (needsRedraw) {
          this.layers = layers.map((layer) => layer.id);
        }
        return needsRedraw;
      }
      _updateViewport(viewport) {
        const targetLayer = this.targetLayer;
        let shouldRedraw = false;
        if (this.tile && "boundingBox" in this.tile) {
          if (!this.targetBounds) {
            shouldRedraw = true;
            this.targetBounds = this.tile.boundingBox;
            const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
            const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
            this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];
          }
        } else if (this.targetBounds !== targetLayer.getBounds()) {
          shouldRedraw = true;
          this.targetBounds = targetLayer.getBounds();
          this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
        }
        if (!this.targetBoundsCommon) {
          return false;
        }
        const newZoom = Math.ceil(viewport.zoom + 0.5);
        if (this.tile) {
          this.bounds = this.targetBoundsCommon;
        } else {
          var _this$renderViewport;
          const oldZoom = (_this$renderViewport = this.renderViewport) === null || _this$renderViewport === void 0 ? void 0 : _this$renderViewport.zoom;
          shouldRedraw = shouldRedraw || newZoom !== oldZoom;
          const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
          const oldBounds = this.bounds;
          shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);
          this.bounds = newBounds;
        }
        if (shouldRedraw) {
          this.renderViewport = makeViewport({
            bounds: this.bounds,
            zoom: newZoom,
            viewport
          });
        }
        return shouldRedraw;
      }
      getRenderFramebuffer() {
        if (!this.renderViewport || this.layers.length === 0) {
          return null;
        }
        if (!this.fbo) {
          this.fbo = createRenderTarget(this.targetLayer.context.gl, {
            id: this.id
          });
        }
        return this.fbo;
      }
      getPickingFramebuffer() {
        if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
          return null;
        }
        if (!this.pickingFbo) {
          this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {
            id: "".concat(this.id, "-picking")
          });
        }
        return this.pickingFbo;
      }
      filterLayers(layers) {
        return layers.filter(({
          id
        }) => this.layers.includes(id));
      }
      delete() {
        const {
          fbo,
          pickingFbo
        } = this;
        if (fbo) {
          fbo.texture.delete();
          fbo.delete();
        }
        if (pickingFbo) {
          pickingFbo.texture.delete();
          pickingFbo.delete();
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-pass.js
var TerrainPass;
var init_terrain_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-pass.js"() {
    init_esm6();
    init_esm8();
    TerrainPass = class extends LayersPass {
      getRenderableLayers(viewport, opts) {
        const {
          layers
        } = opts;
        const result = [];
        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
        for (let i = 0; i < layers.length; i++) {
          const layer = layers[i];
          if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
            result.push(layer);
          }
        }
        return result;
      }
      renderHeightMap(heightMap, opts) {
        const target = heightMap.getRenderFramebuffer();
        const viewport = heightMap.renderViewport;
        if (!target || !viewport) {
          return;
        }
        target.resize(viewport);
        withParameters(this.gl, {
          clearColor: [0, 0, 0, 0],
          blend: true,
          blendFunc: [1, 1],
          blendEquation: 32776,
          depthTest: false
        }, () => this.render({
          ...opts,
          target,
          pass: "terrain-height-map",
          layers: opts.layers,
          viewports: [viewport],
          effects: []
        }));
      }
      renderTerrainCover(terrainCover, opts) {
        const target = terrainCover.getRenderFramebuffer();
        const viewport = terrainCover.renderViewport;
        if (!target || !viewport) {
          return;
        }
        const layers = terrainCover.filterLayers(opts.layers);
        target.resize(viewport);
        withParameters(this.gl, {
          depthTest: false
        }, () => this.render({
          ...opts,
          target,
          pass: "terrain-cover-".concat(terrainCover.id),
          layers,
          effects: [],
          viewports: [viewport]
        }));
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-picking-pass.js
var TerrainPickingPass;
var init_terrain_picking_pass = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-picking-pass.js"() {
    init_defineProperty();
    init_esm8();
    init_esm6();
    TerrainPickingPass = class extends PickLayersPass {
      constructor(...args) {
        super(...args);
        _defineProperty(this, "drawParameters", {});
      }
      getRenderableLayers(viewport, opts) {
        const {
          layers
        } = opts;
        const result = [];
        this.drawParameters = {};
        this._resetColorEncoder(opts.pickZ);
        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
        for (let i = 0; i < layers.length; i++) {
          const layer = layers[i];
          if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
            result.push(layer);
            this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;
          }
        }
        return result;
      }
      renderTerrainCover(terrainCover, opts) {
        const target = terrainCover.getPickingFramebuffer();
        const viewport = terrainCover.renderViewport;
        if (!target || !viewport) {
          return;
        }
        const layers = terrainCover.filterLayers(opts.layers);
        const terrainLayer = terrainCover.targetLayer;
        if (terrainLayer.props.pickable) {
          layers.unshift(terrainLayer);
        }
        target.resize(viewport);
        withParameters(this.gl, {
          depthTest: false
        }, () => this.render({
          ...opts,
          pickingFBO: target,
          pass: "terrain-cover-picking-".concat(terrainCover.id),
          layers,
          effects: [],
          viewports: [viewport],
          cullRect: void 0,
          deviceRect: viewport,
          pickZ: false
        }));
      }
      getLayerParameters(layer, layerIndex, viewport) {
        if (this.drawParameters[layer.id]) {
          return this.drawParameters[layer.id];
        }
        const parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
        parameters2.blend = true;
        return parameters2;
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/height-map-builder.js
var MAP_MAX_SIZE, HeightMapBuilder;
var init_height_map_builder = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/height-map-builder.js"() {
    init_defineProperty();
    init_esm6();
    init_projection_utils();
    init_utils3();
    MAP_MAX_SIZE = 2048;
    HeightMapBuilder = class {
      static isSupported(gl) {
        return Framebuffer.isSupported(gl, {
          colorBufferFloat: true
        });
      }
      constructor(gl) {
        _defineProperty(this, "renderViewport", null);
        _defineProperty(this, "bounds", null);
        _defineProperty(this, "fbo", void 0);
        _defineProperty(this, "gl", void 0);
        _defineProperty(this, "layers", []);
        _defineProperty(this, "layersBounds", []);
        _defineProperty(this, "layersBoundsCommon", null);
        _defineProperty(this, "lastViewport", null);
        this.gl = gl;
      }
      getRenderFramebuffer() {
        if (!this.renderViewport) {
          return null;
        }
        if (!this.fbo) {
          this.fbo = createRenderTarget(this.gl, {
            id: "height-map",
            float: true
          });
        }
        return this.fbo;
      }
      shouldUpdate({
        layers,
        viewport
      }) {
        const layersChanged = layers.length !== this.layers.length || layers.some((layer, i) => layer !== this.layers[i] || layer.props.transitions || layer.getBounds() !== this.layersBounds[i]);
        if (layersChanged) {
          this.layers = layers;
          this.layersBounds = layers.map((layer) => layer.getBounds());
          this.layersBoundsCommon = joinLayerBounds(layers, viewport);
        }
        const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
        if (!this.layersBoundsCommon) {
          this.renderViewport = null;
        } else if (layersChanged || viewportChanged) {
          const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
          if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
            this.renderViewport = null;
            return false;
          }
          this.bounds = bounds;
          this.lastViewport = viewport;
          const scale = viewport.scale;
          const pixelWidth = (bounds[2] - bounds[0]) * scale;
          const pixelHeight = (bounds[3] - bounds[1]) * scale;
          this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
            bounds: [viewport.center[0] - 1, viewport.center[1] - 1, viewport.center[0] + 1, viewport.center[1] + 1],
            zoom: viewport.zoom,
            width: Math.min(pixelWidth, MAP_MAX_SIZE),
            height: Math.min(pixelHeight, MAP_MAX_SIZE),
            viewport
          }) : null;
          return true;
        }
        return false;
      }
      delete() {
        if (this.fbo) {
          this.fbo.color.delete();
          this.fbo.delete();
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-effect.js
var TerrainEffect;
var init_terrain_effect = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-effect.js"() {
    init_defineProperty();
    init_esm6();
    init_esm8();
    init_shader_module5();
    init_terrain_cover();
    init_terrain_pass();
    init_terrain_picking_pass();
    init_height_map_builder();
    TerrainEffect = class {
      constructor() {
        _defineProperty(this, "id", "terrain-effect");
        _defineProperty(this, "props", null);
        _defineProperty(this, "useInPicking", true);
        _defineProperty(this, "isPicking", false);
        _defineProperty(this, "isDrapingEnabled", false);
        _defineProperty(this, "dummyHeightMap", void 0);
        _defineProperty(this, "heightMap", void 0);
        _defineProperty(this, "terrainPass", void 0);
        _defineProperty(this, "terrainPickingPass", void 0);
        _defineProperty(this, "terrainCovers", /* @__PURE__ */ new Map());
      }
      initialize(gl) {
        this.dummyHeightMap = new Texture2D(gl, {
          width: 1,
          height: 1,
          data: new Uint8Array([0, 0, 0, 0])
        });
        this.terrainPass = new TerrainPass(gl, {
          id: "terrain"
        });
        this.terrainPickingPass = new TerrainPickingPass(gl, {
          id: "terrain-picking"
        });
        if (HeightMapBuilder.isSupported(gl)) {
          this.heightMap = new HeightMapBuilder(gl);
        } else {
          log_default.warn("Terrain offset mode is not supported by this browser")();
        }
        ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);
      }
      preRender(gl, opts) {
        if (!this.dummyHeightMap) {
          this.initialize(gl);
          for (const layer of opts.layers) {
            if (layer.props.operation.includes("terrain")) {
              layer.setChangeFlags({
                extensionsChanged: true
              });
            }
          }
        }
        if (opts.pickZ) {
          this.isDrapingEnabled = false;
          return;
        }
        const {
          viewports,
          isPicking = false
        } = opts;
        this.isPicking = isPicking;
        this.isDrapingEnabled = true;
        const viewport = viewports[0];
        const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
        const terrainLayers = layers.filter((l) => l.props.operation.includes("terrain"));
        if (terrainLayers.length === 0) {
          return;
        }
        if (!isPicking) {
          const offsetLayers = layers.filter((l) => l.state.terrainDrawMode === "offset");
          if (offsetLayers.length > 0) {
            this._updateHeightMap(terrainLayers, viewport, opts);
          }
        }
        const drapeLayers = layers.filter((l) => l.state.terrainDrawMode === "drape");
        this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
      }
      getModuleParameters(layer) {
        var _this$heightMap, _this$heightMap2;
        const {
          terrainDrawMode
        } = layer.state;
        return {
          heightMap: (_this$heightMap = this.heightMap) === null || _this$heightMap === void 0 ? void 0 : _this$heightMap.getRenderFramebuffer(),
          heightMapBounds: (_this$heightMap2 = this.heightMap) === null || _this$heightMap2 === void 0 ? void 0 : _this$heightMap2.bounds,
          dummyHeightMap: this.dummyHeightMap,
          terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
          useTerrainHeightMap: terrainDrawMode === "offset",
          terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
        };
      }
      cleanup() {
        if (this.dummyHeightMap) {
          this.dummyHeightMap.delete();
          this.dummyHeightMap = void 0;
        }
        if (this.heightMap) {
          this.heightMap.delete();
          this.heightMap = void 0;
        }
        for (const terrainCover of this.terrainCovers.values()) {
          terrainCover.delete();
        }
        this.terrainCovers.clear();
      }
      _updateHeightMap(terrainLayers, viewport, opts) {
        if (!this.heightMap) {
          return;
        }
        const shouldUpdate = this.heightMap.shouldUpdate({
          layers: terrainLayers,
          viewport
        });
        if (!shouldUpdate) {
          return;
        }
        this.terrainPass.renderHeightMap(this.heightMap, {
          ...opts,
          layers: terrainLayers,
          moduleParameters: {
            heightMapBounds: this.heightMap.bounds,
            dummyHeightMap: this.dummyHeightMap,
            devicePixelRatio: 1,
            drawToTerrainHeightMap: true
          }
        });
      }
      _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
        const layerNeedsRedraw = {};
        for (const layer of drapeLayers) {
          if (layer.state.terrainCoverNeedsRedraw) {
            layerNeedsRedraw[layer.id] = true;
            layer.state.terrainCoverNeedsRedraw = false;
          }
        }
        for (const terrainCover of this.terrainCovers.values()) {
          terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({
            layerNeedsRedraw
          });
        }
        for (const layer of terrainLayers) {
          this._updateTerrainCover(layer, drapeLayers, viewport, opts);
        }
        if (!this.isPicking) {
          this._pruneTerrainCovers();
        }
      }
      _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
        const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
        let terrainCover = this.terrainCovers.get(terrainLayer.id);
        if (!terrainCover) {
          terrainCover = new TerrainCover(terrainLayer);
          this.terrainCovers.set(terrainLayer.id, terrainCover);
        }
        try {
          const isDirty = terrainCover.shouldUpdate({
            targetLayer: terrainLayer,
            viewport,
            layers: drapeLayers
          });
          if (this.isPicking || terrainCover.isDirty || isDirty) {
            renderPass.renderTerrainCover(terrainCover, {
              ...opts,
              layers: drapeLayers,
              moduleParameters: {
                dummyHeightMap: this.dummyHeightMap,
                terrainSkipRender: false,
                devicePixelRatio: 1
              }
            });
            terrainCover.isDirty = false;
          }
        } catch (err) {
          terrainLayer.raiseError(err, "Error rendering terrain cover ".concat(terrainCover.id));
        }
      }
      _pruneTerrainCovers() {
        const idsToRemove = [];
        for (const [id, terrainCover] of this.terrainCovers) {
          if (!terrainCover.isActive) {
            idsToRemove.push(id);
          }
        }
        for (const id of idsToRemove) {
          this.terrainCovers.delete(id);
        }
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js
var defaultProps22, TerrainExtension;
var init_terrain_extension = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js"() {
    init_defineProperty();
    init_esm8();
    init_terrain_effect();
    init_shader_module5();
    defaultProps22 = {
      terrainDrawMode: void 0
    };
    TerrainExtension = class extends LayerExtension {
      getShaders() {
        return {
          modules: [terrainModule]
        };
      }
      initializeState() {
        var _this$context$deck;
        (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new TerrainEffect());
      }
      updateState(params) {
        const {
          props,
          oldProps
        } = params;
        if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && props.extruded === oldProps.extruded) {
          return;
        }
        let {
          terrainDrawMode
        } = props;
        if (!terrainDrawMode) {
          var _this$getAttributeMan;
          const is3d = this.props.extruded;
          const attributes = (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.attributes;
          const hasAnchor = attributes && "instancePositions" in attributes;
          terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
        }
        this.setState({
          terrainDrawMode
        });
      }
      onNeedsRedraw() {
        const state = this.state;
        if (state.terrainDrawMode === "drape") {
          state.terrainCoverNeedsRedraw = true;
        }
      }
    };
    _defineProperty(TerrainExtension, "defaultProps", defaultProps22);
    _defineProperty(TerrainExtension, "extensionName", "TerrainExtension");
  }
});

// node_modules/@deck.gl/extensions/dist/esm/index.js
var init_esm21 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/index.js"() {
    init_brushing_extension();
    init_data_filter_extension();
    init_fp64_extension();
    init_path_style_extension();
    init_fill_style_extension();
    init_clip_extension();
    init_collision_filter_extension();
    init_mask_extension();
    init_terrain_extension();
    init_project64();
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/coordinate-transform.js
function Point([pointX, pointY], [nw, se], viewport) {
  const x = lerp(nw[0], se[0], pointX);
  const y = lerp(nw[1], se[1], pointY);
  return viewport.unprojectFlat([x, y]);
}
function getPoints(geometry, bbox, viewport) {
  return geometry.map((g) => Point(g, bbox, viewport));
}
function MultiPoint(multiPoint, bbox, viewport) {
  return getPoints(multiPoint, bbox, viewport);
}
function LineString(line, bbox, viewport) {
  return getPoints(line, bbox, viewport);
}
function MultiLineString(multiLineString, bbox, viewport) {
  return multiLineString.map((lineString) => LineString(lineString, bbox, viewport));
}
function Polygon(polygon, bbox, viewport) {
  return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
}
function MultiPolygon(multiPolygon, bbox, viewport) {
  return multiPolygon.map((polygon) => Polygon(polygon, bbox, viewport));
}
function transform(geometry, bbox, viewport) {
  const nw = viewport.projectFlat([bbox.west, bbox.north]);
  const se = viewport.projectFlat([bbox.east, bbox.south]);
  const projectedBbox = [nw, se];
  return {
    ...geometry,
    coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
  };
}
var availableTransformations;
var init_coordinate_transform = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/coordinate-transform.js"() {
    init_esm4();
    availableTransformations = {
      Point,
      MultiPoint,
      LineString,
      MultiLineString,
      Polygon,
      MultiPolygon
    };
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/find-index-binary.js
function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
  for (const gt of GEOM_TYPES) {
    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
    if (index >= 0) {
      return index;
    }
  }
  return -1;
}
function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
  const featureIds = geomData.featureIds.value;
  if (!featureIds.length) {
    return -1;
  }
  let startFeatureIndex = 0;
  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
  if (layerName) {
    const layerRange = getLayerRange(geomData, layerName);
    if (layerRange) {
      startFeatureIndex = layerRange[0];
      endFeatureIndex = layerRange[1] + 1;
    } else {
      return -1;
    }
  }
  let featureIndex = -1;
  if (uniqueIdProperty in geomData.numericProps) {
    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i) => x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);
    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
  } else if (uniqueIdProperty) {
    featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
  } else if (geomData.fields) {
    featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
  }
  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
}
function getLayerRange(geomData, layerName) {
  if (!geomData.__layers) {
    const layerNames = {};
    const {
      properties
    } = geomData;
    for (let i = 0; i < properties.length; i++) {
      const {
        layerName: key
      } = properties[i];
      if (!key) {
      } else if (layerNames[key]) {
        layerNames[key][1] = i;
      } else {
        layerNames[key] = [i, i];
      }
    }
    geomData.__layers = layerNames;
  }
  return geomData.__layers[layerName];
}
function getGlobalFeatureId(geomData, featureIndex) {
  if (!geomData.__ids) {
    const result = [];
    const featureIds = geomData.featureIds.value;
    const globalFeatureIds = geomData.globalFeatureIds.value;
    for (let i = 0; i < featureIds.length; i++) {
      result[featureIds[i]] = globalFeatureIds[i];
    }
    geomData.__ids = result;
  }
  return geomData.__ids[featureIndex];
}
function findIndex(array, predicate, startIndex, endIndex) {
  for (let i = startIndex; i < endIndex; i++) {
    if (predicate(array[i], i)) {
      return i;
    }
  }
  return -1;
}
var GEOM_TYPES;
var init_find_index_binary = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/find-index-binary.js"() {
    GEOM_TYPES = ["points", "lines", "polygons"];
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js
function getFeatureUniqueId(feature, uniqueIdProperty) {
  if (feature.properties && uniqueIdProperty) {
    return feature.properties[uniqueIdProperty];
  }
  if ("id" in feature) {
    return feature.id;
  }
  return void 0;
}
function getFeatureLayerName(feature) {
  var _feature$properties;
  return ((_feature$properties = feature.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.layerName) || null;
}
function isFeatureIdDefined(value) {
  return value !== void 0 && value !== null && value !== "";
}
function transformTileCoordsToWGS84(object, bbox, viewport) {
  const feature = {
    ...object,
    geometry: {
      type: object.geometry.type
    }
  };
  Object.defineProperty(feature.geometry, "coordinates", {
    get: () => {
      const wgs84Geom = transform(object.geometry, bbox, viewport);
      return wgs84Geom.coordinates;
    }
  });
  return feature;
}
var WORLD_SIZE, defaultProps23, MVTLayer;
var init_mvt_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js"() {
    init_defineProperty();
    init_esm8();
    init_esm9();
    init_esm21();
    init_esm4();
    init_esm19();
    init_esm18();
    init_coordinate_transform();
    init_find_index_binary();
    init_tile_layer();
    init_tileset_2d2();
    WORLD_SIZE = 512;
    defaultProps23 = {
      ...GeoJsonLayer.defaultProps,
      data: urlType,
      onDataLoad: {
        type: "function",
        value: null,
        optional: true,
        compare: false
      },
      uniqueIdProperty: "",
      highlightedFeatureId: null,
      loaders: [MVTWorkerLoader],
      binary: true
    };
    MVTLayer = class extends TileLayer {
      initializeState() {
        super.initializeState();
        const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
        this.setState({
          binary,
          data: null,
          tileJSON: null
        });
      }
      get isLoaded() {
        return this.state && this.state.data && this.state.tileset && super.isLoaded;
      }
      updateState({
        props,
        oldProps,
        context,
        changeFlags
      }) {
        var _this$state;
        if (changeFlags.dataChanged) {
          this._updateTileData();
        }
        if ((_this$state = this.state) !== null && _this$state !== void 0 && _this$state.data) {
          super.updateState({
            props,
            oldProps,
            context,
            changeFlags
          });
          this._setWGS84PropertyForTiles();
        }
        const {
          highlightColor
        } = props;
        if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
          this.setState({
            highlightColor
          });
        }
      }
      async _updateTileData() {
        let data = this.props.data;
        let tileJSON = null;
        if (typeof data === "string" && !isURLTemplate(data)) {
          const {
            onDataLoad,
            fetch
          } = this.props;
          this.setState({
            data: null,
            tileJSON: null
          });
          try {
            tileJSON = await fetch(data, {
              propName: "data",
              layer: this,
              loaders: []
            });
          } catch (error) {
            this.raiseError(error, "loading TileJSON");
            data = null;
          }
          if (onDataLoad) {
            onDataLoad(tileJSON, {
              propName: "data",
              layer: this
            });
          }
        } else if (data.tilejson) {
          tileJSON = data;
        }
        if (tileJSON) {
          data = tileJSON.tiles;
        }
        this.setState({
          data,
          tileJSON
        });
      }
      _getTilesetOptions() {
        const opts = super._getTilesetOptions();
        const tileJSON = this.state.tileJSON;
        const {
          minZoom,
          maxZoom
        } = this.props;
        if (tileJSON) {
          if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
            opts.minZoom = tileJSON.minzoom;
          }
          if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
            opts.maxZoom = tileJSON.maxzoom;
          }
        }
        return opts;
      }
      renderLayers() {
        var _this$state2;
        if (!((_this$state2 = this.state) !== null && _this$state2 !== void 0 && _this$state2.data))
          return null;
        return super.renderLayers();
      }
      getTileData(loadProps) {
        var _loadOptions;
        const {
          data,
          binary
        } = this.state;
        const {
          index,
          signal
        } = loadProps;
        const url = getURLFromTemplate(data, loadProps);
        if (!url) {
          return Promise.reject("Invalid URL");
        }
        let loadOptions = this.getLoadOptions();
        const {
          fetch
        } = this.props;
        loadOptions = {
          ...loadOptions,
          mimeType: "application/x-protobuf",
          mvt: {
            ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.mvt,
            coordinates: this.context.viewport.resolution ? "wgs84" : "local",
            tileIndex: index
          },
          gis: binary ? {
            format: "binary"
          } : {}
        };
        return fetch(url, {
          propName: "data",
          layer: this,
          loadOptions,
          signal
        });
      }
      renderSubLayers(props) {
        const {
          x,
          y,
          z
        } = props.tile.index;
        const worldScale = Math.pow(2, z);
        const xScale = WORLD_SIZE / worldScale;
        const yScale = -xScale;
        const xOffset = WORLD_SIZE * x / worldScale;
        const yOffset = WORLD_SIZE * (1 - y / worldScale);
        const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
        props.autoHighlight = false;
        if (!this.context.viewport.resolution) {
          props.modelMatrix = modelMatrix2;
          props.coordinateOrigin = [xOffset, yOffset, 0];
          props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
          props.extensions = [...props.extensions || [], new ClipExtension()];
        }
        const subLayers = super.renderSubLayers(props);
        if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {
          log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
        }
        return subLayers;
      }
      _updateAutoHighlight(info) {
        const {
          uniqueIdProperty
        } = this.props;
        const {
          hoveredFeatureId,
          hoveredFeatureLayerName
        } = this.state;
        const hoveredFeature = info.object;
        let newHoveredFeatureId;
        let newHoveredFeatureLayerName;
        if (hoveredFeature) {
          newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
          newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
        }
        let {
          highlightColor
        } = this.props;
        if (typeof highlightColor === "function") {
          highlightColor = highlightColor(info);
        }
        if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
          this.setState({
            highlightColor,
            hoveredFeatureId: newHoveredFeatureId,
            hoveredFeatureLayerName: newHoveredFeatureLayerName
          });
        }
      }
      getPickingInfo(params) {
        const info = super.getPickingInfo(params);
        const isWGS84 = Boolean(this.context.viewport.resolution);
        if (this.state.binary && info.index !== -1) {
          const {
            data
          } = params.sourceLayer.props;
          info.object = binaryToGeojson(data, {
            globalFeatureId: info.index
          });
        }
        if (info.object && !isWGS84) {
          info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);
        }
        return info;
      }
      getSubLayerPropsByTile(tile) {
        return {
          highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
          highlightColor: this.state.highlightColor
        };
      }
      getHighlightedObjectIndex(tile) {
        const {
          hoveredFeatureId,
          hoveredFeatureLayerName,
          binary
        } = this.state;
        const {
          uniqueIdProperty,
          highlightedFeatureId
        } = this.props;
        const data = tile.content;
        const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
        const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
        if (!isFeatureIdPresent) {
          return -1;
        }
        const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
        if (Array.isArray(data)) {
          return data.findIndex((feature) => {
            const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;
            const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;
            return isMatchingId && isMatchingLayer;
          });
        } else if (data && binary) {
          return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
        }
        return -1;
      }
      _pickObjects(maxObjects) {
        const {
          deck,
          viewport
        } = this.context;
        const width = viewport.width;
        const height = viewport.height;
        const x = viewport.x;
        const y = viewport.y;
        const layerIds = [this.id];
        return deck.pickObjects({
          x,
          y,
          width,
          height,
          layerIds,
          maxObjects
        });
      }
      getRenderedFeatures(maxFeatures = null) {
        const features = this._pickObjects(maxFeatures);
        const featureCache = /* @__PURE__ */ new Set();
        const renderedFeatures = [];
        for (const f of features) {
          const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);
          if (featureId === void 0) {
            renderedFeatures.push(f.object);
          } else if (!featureCache.has(featureId)) {
            featureCache.add(featureId);
            renderedFeatures.push(f.object);
          }
        }
        return renderedFeatures;
      }
      _setWGS84PropertyForTiles() {
        const propName = "dataInWGS84";
        const tileset = this.state.tileset;
        tileset.selectedTiles.forEach((tile) => {
          if (!tile.hasOwnProperty(propName)) {
            Object.defineProperty(tile, propName, {
              get: () => {
                if (!tile.content) {
                  return null;
                }
                if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
                  return [];
                }
                const {
                  bbox
                } = tile;
                if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
                  const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
                  tile._contentWGS84 = content.map((feature) => transformTileCoordsToWGS84(feature, bbox, this.context.viewport));
                }
                return tile._contentWGS84;
              }
            });
          }
        });
      }
    };
    _defineProperty(MVTLayer, "layerName", "MVTLayer");
    _defineProperty(MVTLayer, "defaultProps", defaultProps23);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-utils.js
function getGeohashBounds(geohash) {
  let isLon = true;
  let maxLat = MAX_LAT;
  let minLat = MIN_LAT;
  let maxLon = MAX_LON;
  let minLon = MIN_LON;
  let mid;
  let hashValue = 0;
  for (let i = 0, l = geohash.length; i < l; i++) {
    const code = geohash[i].toLowerCase();
    hashValue = BASE32_CODES_DICT[code];
    for (let bits = 4; bits >= 0; bits--) {
      const bit = hashValue >> bits & 1;
      if (isLon) {
        mid = (maxLon + minLon) / 2;
        if (bit === 1) {
          minLon = mid;
        } else {
          maxLon = mid;
        }
      } else {
        mid = (maxLat + minLat) / 2;
        if (bit === 1) {
          minLat = mid;
        } else {
          maxLat = mid;
        }
      }
      isLon = !isLon;
    }
  }
  return [minLat, minLon, maxLat, maxLon];
}
function getGeohashPolygon(geohash) {
  const [s, w, n, e] = getGeohashBounds(geohash);
  return [e, n, e, s, w, s, w, n, e, n];
}
var BASE32_CODES, BASE32_CODES_DICT, MIN_LAT, MAX_LAT, MIN_LON, MAX_LON;
var init_geohash_utils = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-utils.js"() {
    BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
    BASE32_CODES_DICT = {};
    for (let i = 0; i < BASE32_CODES.length; i++) {
      BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;
    }
    MIN_LAT = -90;
    MAX_LAT = 90;
    MIN_LON = -180;
    MAX_LON = 180;
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-layer.js
var defaultProps24, GeohashLayer;
var init_geohash_layer = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-layer.js"() {
    init_defineProperty();
    init_GeoCellLayer();
    init_geohash_utils();
    defaultProps24 = {
      getGeohash: {
        type: "accessor",
        value: (d) => d.geohash
      }
    };
    GeohashLayer = class extends GeoCellLayer {
      indexToBounds() {
        const {
          data,
          getGeohash
        } = this.props;
        return {
          data,
          _normalize: false,
          positionFormat: "XY",
          getPolygon: (x, objectInfo) => getGeohashPolygon(getGeohash(x, objectInfo))
        };
      }
    };
    _defineProperty(GeohashLayer, "layerName", "GeohashLayer");
    _defineProperty(GeohashLayer, "defaultProps", defaultProps24);
  }
});

// node_modules/@deck.gl/geo-layers/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  GeohashLayer: () => GeohashLayer,
  GreatCircleLayer: () => GreatCircleLayer,
  H3ClusterLayer: () => H3ClusterLayer,
  H3HexagonLayer: () => H3HexagonLayer,
  MVTLayer: () => MVTLayer,
  QuadkeyLayer: () => QuadkeyLayer,
  S2Layer: () => S2Layer,
  TerrainLayer: () => TerrainLayer,
  Tile3DLayer: () => Tile3DLayer,
  TileLayer: () => TileLayer,
  TripsLayer: () => TripsLayer,
  _GeoCellLayer: () => GeoCellLayer,
  _Tile2DHeader: () => Tile2DHeader,
  _Tileset2D: () => Tileset2D,
  _WMSLayer: () => WMSLayer,
  _getURLFromTemplate: () => getURLFromTemplate
});
var init_esm22 = __esm({
  "node_modules/@deck.gl/geo-layers/dist/esm/index.js"() {
    init_wms_layer();
    init_great_circle_layer();
    init_s2_layer();
    init_quadkey_layer();
    init_tile_layer();
    init_trips_layer();
    init_h3_cluster_layer();
    init_h3_hexagon_layer();
    init_tile_3d_layer();
    init_terrain_layer();
    init_mvt_layer();
    init_geohash_layer();
    init_GeoCellLayer();
    init_tileset_2d2();
    init_tileset_2d2();
    init_tileset_2d2();
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/editable-h3-cluster-layer.js
var require_editable_h3_cluster_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/editable-h3-cluster-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _geoLayers = (init_esm22(), __toCommonJS(esm_exports5));
    var _editModes = require_dist_es6();
    var _h3Js = (init_h3_js_es(), __toCommonJS(h3_js_es_exports));
    var _constants = require_constants();
    var _editableGeojsonLayer = _interopRequireDefault(require_editable_geojson_layer());
    var _editableLayer = _interopRequireDefault(require_editable_layer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DEFAULT_EDIT_MODE = _editModes.ViewMode;
    var DEFAULT_H3_RESOLUTION = 9;
    var EMPTY_FEATURE_COLLECTION = {
      type: "FeatureCollection",
      features: []
    };
    var defaultProps25 = _objectSpread({
      mode: DEFAULT_EDIT_MODE
    }, _editableGeojsonLayer["default"].defaultProps, {
      // h3 layer
      data: [],
      selectedIndexes: [],
      filled: false,
      stroked: true,
      lineWidthScale: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,
      lineWidthMinPixels: 1,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      lineWidthUnits: "pixels",
      getHexagons: function getHexagons(d) {
        return d.hexIds;
      },
      getEditedCluster: function getEditedCluster(updatedHexagons, existingCluster) {
        if (existingCluster) {
          return _objectSpread({}, existingCluster, {
            hexIds: updatedHexagons
          });
        }
        return {
          hexIds: updatedHexagons
        };
      },
      resolution: DEFAULT_H3_RESOLUTION
    });
    var EditableH3ClusterLayer = function(_EditableLayer) {
      _inherits(EditableH3ClusterLayer2, _EditableLayer);
      var _super = _createSuper(EditableH3ClusterLayer2);
      function EditableH3ClusterLayer2() {
        _classCallCheck(this, EditableH3ClusterLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(EditableH3ClusterLayer2, [{
        key: "initializeState",
        value: function initializeState() {
          _get(_getPrototypeOf(EditableH3ClusterLayer2.prototype), "initializeState", this).call(this);
          this.setState({
            tentativeHexagonIDs: []
          });
        }
        // convert array of (lng, lat) coords to cluster of hexes
      }, {
        key: "getDerivedHexagonIDs",
        value: function getDerivedHexagonIDs(coords) {
          return (0, _h3Js.polyfill)(coords, this.props.resolution, true);
        }
        // convert pair of (lng, lat) coords into single hex
      }, {
        key: "getDerivedHexagonID",
        value: function getDerivedHexagonID(coords) {
          return (0, _h3Js.geoToH3)(coords[1], coords[0], this.props.resolution);
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          var _this = this;
          var layers = [new _editableGeojsonLayer["default"](this.getSubLayerProps({
            id: "editable-geojson",
            mode: this.props.mode,
            data: EMPTY_FEATURE_COLLECTION,
            selectedFeatureIndexes: [],
            onEdit: function onEdit(editAction) {
              var editType = editAction.editType, editContext = editAction.editContext;
              switch (editType) {
                case "updateTentativeFeature":
                  if (editContext.feature.geometry.type === "Polygon") {
                    var coords = editContext.feature.geometry.coordinates;
                    var hexIDs = _this.getDerivedHexagonIDs(coords);
                    _this.setState({
                      tentativeHexagonIDs: hexIDs
                    });
                  } else if (editContext.feature.geometry.type === "Point") {
                    var _coords = editContext.feature.geometry.coordinates;
                    var hexID = _this.getDerivedHexagonID(_coords);
                    _this.setState({
                      tentativeHexagonIDs: [hexID]
                    });
                  }
                  break;
                case "addFeature":
                  var _updatedData = _toConsumableArray(_this.props.data);
                  var modeConfig = _this.props.modeConfig;
                  if (!modeConfig || !modeConfig.booleanOperation) {
                    _updatedData.push(_this.props.getEditedCluster(_this.state.tentativeHexagonIDs, null));
                  } else if (_this.props.selectedIndexes.length !== 1) {
                    console.warn("booleanOperation only supported for single cluster selection");
                  } else {
                    var finalHexagonIDs;
                    var committedHexagonIDs = new Set(_this.getSelectedHexIDs());
                    var tentativeHexagonIDs = new Set(_this.state.tentativeHexagonIDs);
                    switch (modeConfig.booleanOperation) {
                      case "union":
                      default:
                        finalHexagonIDs = _toConsumableArray(new Set([].concat(_toConsumableArray(committedHexagonIDs), _toConsumableArray(tentativeHexagonIDs))));
                        break;
                      case "intersection":
                        finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function(hexID2) {
                          return tentativeHexagonIDs.has(hexID2);
                        });
                        break;
                      case "difference":
                        finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function(hexID2) {
                          return !tentativeHexagonIDs.has(hexID2);
                        });
                        break;
                    }
                    var selectedIndex = _this.props.selectedIndexes[0];
                    var _existingCluster = _this.props.data[selectedIndex];
                    _updatedData[selectedIndex] = _this.props.getEditedCluster(finalHexagonIDs, _existingCluster);
                  }
                  _this.setState({
                    tentativeHexagonIDs: []
                  });
                  _this.props.onEdit({
                    updatedData: _updatedData
                  });
                  break;
                default:
                  break;
              }
            }
          })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({
            id: "hexagons",
            data: this.props.data,
            getHexagons: this.props.getHexagons
          })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({
            id: "tentative-hexagons",
            data: [{
              hexIds: this.state.tentativeHexagonIDs
            }],
            getHexagons: function getHexagons(d) {
              return d.hexIds;
            }
          }))];
          return layers;
        }
        // because data is an array of hexagon data, we take the cumulative of all selected indexes,
        // using props.getHexagons to support multiple data types
      }, {
        key: "getSelectedHexIDs",
        value: function getSelectedHexIDs() {
          var _this2 = this;
          var cumulativeHexIDs = [];
          this.props.selectedIndexes.forEach(function(index) {
            var selectedCluster = _this2.props.data[index];
            var hexIDs = _this2.props.getHexagons(selectedCluster);
            cumulativeHexIDs = cumulativeHexIDs.concat(hexIDs);
          });
          return cumulativeHexIDs;
        }
      }, {
        key: "getCursor",
        value: function getCursor(_ref) {
          var isDragging = _ref.isDragging;
          var _ref2 = this.state || {}, cursor = _ref2.cursor;
          if (!cursor) {
            cursor = isDragging ? "grabbing" : "grab";
          }
          return cursor;
        }
      }]);
      return EditableH3ClusterLayer2;
    }(_editableLayer["default"]);
    exports["default"] = EditableH3ClusterLayer;
    _defineProperty2(EditableH3ClusterLayer, "layerName", "EditableH3ClusterLayer");
    _defineProperty2(EditableH3ClusterLayer, "defaultProps", defaultProps25);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/selection-layer.js
var require_selection_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/selection-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.SELECTION_TYPE = void 0;
    var _core = (init_esm8(), __toCommonJS(esm_exports2));
    var _layers = (init_esm9(), __toCommonJS(esm_exports3));
    var _helpers = require_js();
    var _buffer = _interopRequireDefault(require_js6());
    var _difference = _interopRequireDefault(require_js2());
    var _editModes = require_dist_es6();
    var _editableGeojsonLayer = _interopRequireDefault(require_editable_geojson_layer());
    var _MODE_MAP;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var SELECTION_TYPE = {
      NONE: null,
      RECTANGLE: "rectangle",
      POLYGON: "polygon"
    };
    exports.SELECTION_TYPE = SELECTION_TYPE;
    var MODE_MAP = (_MODE_MAP = {}, _defineProperty2(_MODE_MAP, SELECTION_TYPE.RECTANGLE, _editModes.DrawRectangleMode), _defineProperty2(_MODE_MAP, SELECTION_TYPE.POLYGON, _editModes.DrawPolygonMode), _MODE_MAP);
    var MODE_CONFIG_MAP = _defineProperty2({}, SELECTION_TYPE.RECTANGLE, {
      dragToDraw: true
    });
    var defaultProps25 = {
      selectionType: SELECTION_TYPE.RECTANGLE,
      layerIds: [],
      onSelect: function onSelect() {
      }
    };
    var EMPTY_DATA = {
      type: "FeatureCollection",
      features: []
    };
    var EXPANSION_KM = 50;
    var LAYER_ID_GEOJSON = "selection-geojson";
    var LAYER_ID_BLOCKER = "selection-blocker";
    var PASS_THROUGH_PROPS = ["lineWidthScale", "lineWidthMinPixels", "lineWidthMaxPixels", "lineWidthUnits", "lineJointRounded", "lineCapRounded", "lineMiterLimit", "pointRadiusScale", "pointRadiusMinPixels", "pointRadiusMaxPixels", "lineDashJustified", "getLineColor", "getFillColor", "getRadius", "getLineWidth", "getLineDashArray", "getTentativeLineDashArray", "getTentativeLineColor", "getTentativeFillColor", "getTentativeLineWidth"];
    var SelectionLayer = function(_CompositeLayer) {
      _inherits(SelectionLayer2, _CompositeLayer);
      var _super = _createSuper(SelectionLayer2);
      function SelectionLayer2() {
        _classCallCheck(this, SelectionLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(SelectionLayer2, [{
        key: "_selectRectangleObjects",
        value: function _selectRectangleObjects(coordinates) {
          var _this$props = this.props, layerIds = _this$props.layerIds, onSelect = _this$props.onSelect;
          var _this$context$viewpor = this.context.viewport.project(coordinates[0][0]), _this$context$viewpor2 = _slicedToArray(_this$context$viewpor, 2), x1 = _this$context$viewpor2[0], y1 = _this$context$viewpor2[1];
          var _this$context$viewpor3 = this.context.viewport.project(coordinates[0][2]), _this$context$viewpor4 = _slicedToArray(_this$context$viewpor3, 2), x2 = _this$context$viewpor4[0], y2 = _this$context$viewpor4[1];
          var pickingInfos = this.context.deck.pickObjects({
            x: Math.min(x1, x2),
            y: Math.min(y1, y2),
            width: Math.abs(x2 - x1),
            height: Math.abs(y2 - y1),
            layerIds
          });
          onSelect({
            pickingInfos
          });
        }
      }, {
        key: "_selectPolygonObjects",
        value: function _selectPolygonObjects(coordinates) {
          var _this = this;
          var _this$props2 = this.props, layerIds = _this$props2.layerIds, onSelect = _this$props2.onSelect;
          var mousePoints = coordinates[0].map(function(c) {
            return _this.context.viewport.project(c);
          });
          var allX = mousePoints.map(function(mousePoint) {
            return mousePoint[0];
          });
          var allY = mousePoints.map(function(mousePoint) {
            return mousePoint[1];
          });
          var x = Math.min.apply(Math, _toConsumableArray(allX));
          var y = Math.min.apply(Math, _toConsumableArray(allY));
          var maxX = Math.max.apply(Math, _toConsumableArray(allX));
          var maxY = Math.max.apply(Math, _toConsumableArray(allY));
          var landPointsPoly = (0, _helpers.polygon)(coordinates);
          var bigBuffer = (0, _buffer["default"])(landPointsPoly, EXPANSION_KM);
          var bigPolygon;
          try {
            bigPolygon = (0, _difference["default"])(bigBuffer, landPointsPoly);
          } catch (e) {
            console.log("turfDifference() error", e);
            return;
          }
          this.setState({
            pendingPolygonSelection: {
              bigPolygon
            }
          });
          var blockerId = "".concat(this.props.id, "-").concat(LAYER_ID_BLOCKER);
          setTimeout(function() {
            var pickingInfos = _this.context.deck.pickObjects({
              x,
              y,
              width: maxX - x,
              height: maxY - y,
              layerIds: [blockerId].concat(_toConsumableArray(layerIds))
            });
            onSelect({
              pickingInfos: pickingInfos.filter(function(item) {
                return item.layer.id !== _this.props.id;
              })
            });
          }, 250);
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          var _this2 = this;
          var pendingPolygonSelection = this.state.pendingPolygonSelection;
          var mode = MODE_MAP[this.props.selectionType] || _editModes.ViewMode;
          var modeConfig = MODE_CONFIG_MAP[this.props.selectionType];
          var inheritedProps = {};
          PASS_THROUGH_PROPS.forEach(function(p) {
            if (_this2.props[p] !== void 0)
              inheritedProps[p] = _this2.props[p];
          });
          var layers = [new _editableGeojsonLayer["default"](this.getSubLayerProps(_objectSpread({
            id: LAYER_ID_GEOJSON,
            pickable: true,
            mode,
            modeConfig,
            selectedFeatureIndexes: [],
            data: EMPTY_DATA,
            onEdit: function onEdit(_ref) {
              var updatedData = _ref.updatedData, editType = _ref.editType;
              if (editType === "addFeature") {
                var coordinates = updatedData.features[0].geometry.coordinates;
                if (_this2.props.selectionType === SELECTION_TYPE.RECTANGLE) {
                  _this2._selectRectangleObjects(coordinates);
                } else if (_this2.props.selectionType === SELECTION_TYPE.POLYGON) {
                  _this2._selectPolygonObjects(coordinates);
                }
              }
            }
          }, inheritedProps)))];
          if (pendingPolygonSelection) {
            var bigPolygon = pendingPolygonSelection.bigPolygon;
            layers.push(
              // @ts-ignore
              new _layers.PolygonLayer(
                // @ts-ignore
                this.getSubLayerProps({
                  id: LAYER_ID_BLOCKER,
                  pickable: true,
                  stroked: false,
                  opacity: 1,
                  data: [bigPolygon],
                  getLineColor: function getLineColor(obj) {
                    return [0, 0, 0, 1];
                  },
                  getFillColor: function getFillColor(obj) {
                    return [0, 0, 0, 1];
                  },
                  getPolygon: function getPolygon(o) {
                    return o.geometry.coordinates;
                  }
                })
              )
            );
          }
          return layers;
        }
      }, {
        key: "shouldUpdateState",
        value: function shouldUpdateState(_ref2) {
          var _ref2$changeFlags = _ref2.changeFlags, stateChanged = _ref2$changeFlags.stateChanged, propsOrDataChanged = _ref2$changeFlags.propsOrDataChanged;
          return stateChanged || propsOrDataChanged;
        }
      }]);
      return SelectionLayer2;
    }(_core.CompositeLayer);
    exports["default"] = SelectionLayer;
    _defineProperty2(SelectionLayer, "layerName", "SelectionLayer");
    _defineProperty2(SelectionLayer, "defaultProps", defaultProps25);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/elevated-edit-handle-layer.js
var require_elevated_edit_handle_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/elevated-edit-handle-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm8(), __toCommonJS(esm_exports2));
    var _layers = (init_esm9(), __toCommonJS(esm_exports3));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defaultProps25 = {};
    var ElevatedEditHandleLayer = function(_CompositeLayer) {
      _inherits(ElevatedEditHandleLayer2, _CompositeLayer);
      var _super = _createSuper(ElevatedEditHandleLayer2);
      function ElevatedEditHandleLayer2() {
        _classCallCheck(this, ElevatedEditHandleLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(ElevatedEditHandleLayer2, [{
        key: "renderLayers",
        value: function renderLayers() {
          var handles = new _layers.ScatterplotLayer(Object.assign({}, this.props, {
            id: "".concat(this.props.id, "-ScatterplotLayer"),
            data: this.props.data
          }));
          var lines = new _layers.LineLayer(Object.assign({}, this.props, {
            id: "".concat(this.props.id, "-LineLayer"),
            data: this.props.data,
            pickable: false,
            getSourcePosition: function getSourcePosition(_ref) {
              var position = _ref.position;
              return [position[0], position[1], 0];
            },
            getTargetPosition: function getTargetPosition(_ref2) {
              var position = _ref2.position;
              return [position[0], position[1], position[2] || 0];
            },
            getColor: [150, 150, 150, 200],
            getStrokeWidth: 3
          }));
          return [handles, lines];
        }
      }]);
      return ElevatedEditHandleLayer2;
    }(_core.CompositeLayer);
    exports["default"] = ElevatedEditHandleLayer;
    _defineProperty2(ElevatedEditHandleLayer, "layerName", "ElevatedEditHandleLayer");
    _defineProperty2(ElevatedEditHandleLayer, "defaultProps", defaultProps25);
  }
});

// node_modules/@luma.gl/constants/dist/esm/index.js
var esm_exports6 = {};
__export(esm_exports6, {
  default: () => esm_default
});
var esm_default;
var init_esm23 = __esm({
  "node_modules/@luma.gl/constants/dist/esm/index.js"() {
    esm_default = {
      DEPTH_BUFFER_BIT: 256,
      STENCIL_BUFFER_BIT: 1024,
      COLOR_BUFFER_BIT: 16384,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      ZERO: 0,
      ONE: 1,
      SRC_COLOR: 768,
      ONE_MINUS_SRC_COLOR: 769,
      SRC_ALPHA: 770,
      ONE_MINUS_SRC_ALPHA: 771,
      DST_ALPHA: 772,
      ONE_MINUS_DST_ALPHA: 773,
      DST_COLOR: 774,
      ONE_MINUS_DST_COLOR: 775,
      SRC_ALPHA_SATURATE: 776,
      CONSTANT_COLOR: 32769,
      ONE_MINUS_CONSTANT_COLOR: 32770,
      CONSTANT_ALPHA: 32771,
      ONE_MINUS_CONSTANT_ALPHA: 32772,
      FUNC_ADD: 32774,
      FUNC_SUBTRACT: 32778,
      FUNC_REVERSE_SUBTRACT: 32779,
      BLEND_EQUATION: 32777,
      BLEND_EQUATION_RGB: 32777,
      BLEND_EQUATION_ALPHA: 34877,
      BLEND_DST_RGB: 32968,
      BLEND_SRC_RGB: 32969,
      BLEND_DST_ALPHA: 32970,
      BLEND_SRC_ALPHA: 32971,
      BLEND_COLOR: 32773,
      ARRAY_BUFFER_BINDING: 34964,
      ELEMENT_ARRAY_BUFFER_BINDING: 34965,
      LINE_WIDTH: 2849,
      ALIASED_POINT_SIZE_RANGE: 33901,
      ALIASED_LINE_WIDTH_RANGE: 33902,
      CULL_FACE_MODE: 2885,
      FRONT_FACE: 2886,
      DEPTH_RANGE: 2928,
      DEPTH_WRITEMASK: 2930,
      DEPTH_CLEAR_VALUE: 2931,
      DEPTH_FUNC: 2932,
      STENCIL_CLEAR_VALUE: 2961,
      STENCIL_FUNC: 2962,
      STENCIL_FAIL: 2964,
      STENCIL_PASS_DEPTH_FAIL: 2965,
      STENCIL_PASS_DEPTH_PASS: 2966,
      STENCIL_REF: 2967,
      STENCIL_VALUE_MASK: 2963,
      STENCIL_WRITEMASK: 2968,
      STENCIL_BACK_FUNC: 34816,
      STENCIL_BACK_FAIL: 34817,
      STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
      STENCIL_BACK_PASS_DEPTH_PASS: 34819,
      STENCIL_BACK_REF: 36003,
      STENCIL_BACK_VALUE_MASK: 36004,
      STENCIL_BACK_WRITEMASK: 36005,
      VIEWPORT: 2978,
      SCISSOR_BOX: 3088,
      COLOR_CLEAR_VALUE: 3106,
      COLOR_WRITEMASK: 3107,
      UNPACK_ALIGNMENT: 3317,
      PACK_ALIGNMENT: 3333,
      MAX_TEXTURE_SIZE: 3379,
      MAX_VIEWPORT_DIMS: 3386,
      SUBPIXEL_BITS: 3408,
      RED_BITS: 3410,
      GREEN_BITS: 3411,
      BLUE_BITS: 3412,
      ALPHA_BITS: 3413,
      DEPTH_BITS: 3414,
      STENCIL_BITS: 3415,
      POLYGON_OFFSET_UNITS: 10752,
      POLYGON_OFFSET_FACTOR: 32824,
      TEXTURE_BINDING_2D: 32873,
      SAMPLE_BUFFERS: 32936,
      SAMPLES: 32937,
      SAMPLE_COVERAGE_VALUE: 32938,
      SAMPLE_COVERAGE_INVERT: 32939,
      COMPRESSED_TEXTURE_FORMATS: 34467,
      VENDOR: 7936,
      RENDERER: 7937,
      VERSION: 7938,
      IMPLEMENTATION_COLOR_READ_TYPE: 35738,
      IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
      BROWSER_DEFAULT_WEBGL: 37444,
      STATIC_DRAW: 35044,
      STREAM_DRAW: 35040,
      DYNAMIC_DRAW: 35048,
      ARRAY_BUFFER: 34962,
      ELEMENT_ARRAY_BUFFER: 34963,
      BUFFER_SIZE: 34660,
      BUFFER_USAGE: 34661,
      CURRENT_VERTEX_ATTRIB: 34342,
      VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
      VERTEX_ATTRIB_ARRAY_SIZE: 34339,
      VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
      VERTEX_ATTRIB_ARRAY_TYPE: 34341,
      VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
      VERTEX_ATTRIB_ARRAY_POINTER: 34373,
      VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
      CULL_FACE: 2884,
      FRONT: 1028,
      BACK: 1029,
      FRONT_AND_BACK: 1032,
      BLEND: 3042,
      DEPTH_TEST: 2929,
      DITHER: 3024,
      POLYGON_OFFSET_FILL: 32823,
      SAMPLE_ALPHA_TO_COVERAGE: 32926,
      SAMPLE_COVERAGE: 32928,
      SCISSOR_TEST: 3089,
      STENCIL_TEST: 2960,
      NO_ERROR: 0,
      INVALID_ENUM: 1280,
      INVALID_VALUE: 1281,
      INVALID_OPERATION: 1282,
      OUT_OF_MEMORY: 1285,
      CONTEXT_LOST_WEBGL: 37442,
      CW: 2304,
      CCW: 2305,
      DONT_CARE: 4352,
      FASTEST: 4353,
      NICEST: 4354,
      GENERATE_MIPMAP_HINT: 33170,
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      INT: 5124,
      UNSIGNED_INT: 5125,
      FLOAT: 5126,
      DOUBLE: 5130,
      DEPTH_COMPONENT: 6402,
      ALPHA: 6406,
      RGB: 6407,
      RGBA: 6408,
      LUMINANCE: 6409,
      LUMINANCE_ALPHA: 6410,
      UNSIGNED_SHORT_4_4_4_4: 32819,
      UNSIGNED_SHORT_5_5_5_1: 32820,
      UNSIGNED_SHORT_5_6_5: 33635,
      FRAGMENT_SHADER: 35632,
      VERTEX_SHADER: 35633,
      COMPILE_STATUS: 35713,
      DELETE_STATUS: 35712,
      LINK_STATUS: 35714,
      VALIDATE_STATUS: 35715,
      ATTACHED_SHADERS: 35717,
      ACTIVE_ATTRIBUTES: 35721,
      ACTIVE_UNIFORMS: 35718,
      MAX_VERTEX_ATTRIBS: 34921,
      MAX_VERTEX_UNIFORM_VECTORS: 36347,
      MAX_VARYING_VECTORS: 36348,
      MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
      MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
      MAX_TEXTURE_IMAGE_UNITS: 34930,
      MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
      SHADER_TYPE: 35663,
      SHADING_LANGUAGE_VERSION: 35724,
      CURRENT_PROGRAM: 35725,
      NEVER: 512,
      ALWAYS: 519,
      LESS: 513,
      EQUAL: 514,
      LEQUAL: 515,
      GREATER: 516,
      GEQUAL: 518,
      NOTEQUAL: 517,
      KEEP: 7680,
      REPLACE: 7681,
      INCR: 7682,
      DECR: 7683,
      INVERT: 5386,
      INCR_WRAP: 34055,
      DECR_WRAP: 34056,
      NEAREST: 9728,
      LINEAR: 9729,
      NEAREST_MIPMAP_NEAREST: 9984,
      LINEAR_MIPMAP_NEAREST: 9985,
      NEAREST_MIPMAP_LINEAR: 9986,
      LINEAR_MIPMAP_LINEAR: 9987,
      TEXTURE_MAG_FILTER: 10240,
      TEXTURE_MIN_FILTER: 10241,
      TEXTURE_WRAP_S: 10242,
      TEXTURE_WRAP_T: 10243,
      TEXTURE_2D: 3553,
      TEXTURE: 5890,
      TEXTURE_CUBE_MAP: 34067,
      TEXTURE_BINDING_CUBE_MAP: 34068,
      TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
      TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
      TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
      TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
      TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
      TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
      MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
      TEXTURE0: 33984,
      ACTIVE_TEXTURE: 34016,
      REPEAT: 10497,
      CLAMP_TO_EDGE: 33071,
      MIRRORED_REPEAT: 33648,
      TEXTURE_WIDTH: 4096,
      TEXTURE_HEIGHT: 4097,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      INT_VEC2: 35667,
      INT_VEC3: 35668,
      INT_VEC4: 35669,
      BOOL: 35670,
      BOOL_VEC2: 35671,
      BOOL_VEC3: 35672,
      BOOL_VEC4: 35673,
      FLOAT_MAT2: 35674,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      SAMPLER_2D: 35678,
      SAMPLER_CUBE: 35680,
      LOW_FLOAT: 36336,
      MEDIUM_FLOAT: 36337,
      HIGH_FLOAT: 36338,
      LOW_INT: 36339,
      MEDIUM_INT: 36340,
      HIGH_INT: 36341,
      FRAMEBUFFER: 36160,
      RENDERBUFFER: 36161,
      RGBA4: 32854,
      RGB5_A1: 32855,
      RGB565: 36194,
      DEPTH_COMPONENT16: 33189,
      STENCIL_INDEX: 6401,
      STENCIL_INDEX8: 36168,
      DEPTH_STENCIL: 34041,
      RENDERBUFFER_WIDTH: 36162,
      RENDERBUFFER_HEIGHT: 36163,
      RENDERBUFFER_INTERNAL_FORMAT: 36164,
      RENDERBUFFER_RED_SIZE: 36176,
      RENDERBUFFER_GREEN_SIZE: 36177,
      RENDERBUFFER_BLUE_SIZE: 36178,
      RENDERBUFFER_ALPHA_SIZE: 36179,
      RENDERBUFFER_DEPTH_SIZE: 36180,
      RENDERBUFFER_STENCIL_SIZE: 36181,
      FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
      FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
      FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
      FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
      COLOR_ATTACHMENT0: 36064,
      DEPTH_ATTACHMENT: 36096,
      STENCIL_ATTACHMENT: 36128,
      DEPTH_STENCIL_ATTACHMENT: 33306,
      NONE: 0,
      FRAMEBUFFER_COMPLETE: 36053,
      FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
      FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
      FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
      FRAMEBUFFER_UNSUPPORTED: 36061,
      FRAMEBUFFER_BINDING: 36006,
      RENDERBUFFER_BINDING: 36007,
      READ_FRAMEBUFFER: 36008,
      DRAW_FRAMEBUFFER: 36009,
      MAX_RENDERBUFFER_SIZE: 34024,
      INVALID_FRAMEBUFFER_OPERATION: 1286,
      UNPACK_FLIP_Y_WEBGL: 37440,
      UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
      UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
      READ_BUFFER: 3074,
      UNPACK_ROW_LENGTH: 3314,
      UNPACK_SKIP_ROWS: 3315,
      UNPACK_SKIP_PIXELS: 3316,
      PACK_ROW_LENGTH: 3330,
      PACK_SKIP_ROWS: 3331,
      PACK_SKIP_PIXELS: 3332,
      TEXTURE_BINDING_3D: 32874,
      UNPACK_SKIP_IMAGES: 32877,
      UNPACK_IMAGE_HEIGHT: 32878,
      MAX_3D_TEXTURE_SIZE: 32883,
      MAX_ELEMENTS_VERTICES: 33e3,
      MAX_ELEMENTS_INDICES: 33001,
      MAX_TEXTURE_LOD_BIAS: 34045,
      MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
      MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
      MAX_ARRAY_TEXTURE_LAYERS: 35071,
      MIN_PROGRAM_TEXEL_OFFSET: 35076,
      MAX_PROGRAM_TEXEL_OFFSET: 35077,
      MAX_VARYING_COMPONENTS: 35659,
      FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
      RASTERIZER_DISCARD: 35977,
      VERTEX_ARRAY_BINDING: 34229,
      MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
      MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
      MAX_SERVER_WAIT_TIMEOUT: 37137,
      MAX_ELEMENT_INDEX: 36203,
      RED: 6403,
      RGB8: 32849,
      RGBA8: 32856,
      RGB10_A2: 32857,
      TEXTURE_3D: 32879,
      TEXTURE_WRAP_R: 32882,
      TEXTURE_MIN_LOD: 33082,
      TEXTURE_MAX_LOD: 33083,
      TEXTURE_BASE_LEVEL: 33084,
      TEXTURE_MAX_LEVEL: 33085,
      TEXTURE_COMPARE_MODE: 34892,
      TEXTURE_COMPARE_FUNC: 34893,
      SRGB: 35904,
      SRGB8: 35905,
      SRGB8_ALPHA8: 35907,
      COMPARE_REF_TO_TEXTURE: 34894,
      RGBA32F: 34836,
      RGB32F: 34837,
      RGBA16F: 34842,
      RGB16F: 34843,
      TEXTURE_2D_ARRAY: 35866,
      TEXTURE_BINDING_2D_ARRAY: 35869,
      R11F_G11F_B10F: 35898,
      RGB9_E5: 35901,
      RGBA32UI: 36208,
      RGB32UI: 36209,
      RGBA16UI: 36214,
      RGB16UI: 36215,
      RGBA8UI: 36220,
      RGB8UI: 36221,
      RGBA32I: 36226,
      RGB32I: 36227,
      RGBA16I: 36232,
      RGB16I: 36233,
      RGBA8I: 36238,
      RGB8I: 36239,
      RED_INTEGER: 36244,
      RGB_INTEGER: 36248,
      RGBA_INTEGER: 36249,
      R8: 33321,
      RG8: 33323,
      R16F: 33325,
      R32F: 33326,
      RG16F: 33327,
      RG32F: 33328,
      R8I: 33329,
      R8UI: 33330,
      R16I: 33331,
      R16UI: 33332,
      R32I: 33333,
      R32UI: 33334,
      RG8I: 33335,
      RG8UI: 33336,
      RG16I: 33337,
      RG16UI: 33338,
      RG32I: 33339,
      RG32UI: 33340,
      R8_SNORM: 36756,
      RG8_SNORM: 36757,
      RGB8_SNORM: 36758,
      RGBA8_SNORM: 36759,
      RGB10_A2UI: 36975,
      TEXTURE_IMMUTABLE_FORMAT: 37167,
      TEXTURE_IMMUTABLE_LEVELS: 33503,
      UNSIGNED_INT_2_10_10_10_REV: 33640,
      UNSIGNED_INT_10F_11F_11F_REV: 35899,
      UNSIGNED_INT_5_9_9_9_REV: 35902,
      FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
      UNSIGNED_INT_24_8: 34042,
      HALF_FLOAT: 5131,
      RG: 33319,
      RG_INTEGER: 33320,
      INT_2_10_10_10_REV: 36255,
      CURRENT_QUERY: 34917,
      QUERY_RESULT: 34918,
      QUERY_RESULT_AVAILABLE: 34919,
      ANY_SAMPLES_PASSED: 35887,
      ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
      MAX_DRAW_BUFFERS: 34852,
      DRAW_BUFFER0: 34853,
      DRAW_BUFFER1: 34854,
      DRAW_BUFFER2: 34855,
      DRAW_BUFFER3: 34856,
      DRAW_BUFFER4: 34857,
      DRAW_BUFFER5: 34858,
      DRAW_BUFFER6: 34859,
      DRAW_BUFFER7: 34860,
      DRAW_BUFFER8: 34861,
      DRAW_BUFFER9: 34862,
      DRAW_BUFFER10: 34863,
      DRAW_BUFFER11: 34864,
      DRAW_BUFFER12: 34865,
      DRAW_BUFFER13: 34866,
      DRAW_BUFFER14: 34867,
      DRAW_BUFFER15: 34868,
      MAX_COLOR_ATTACHMENTS: 36063,
      COLOR_ATTACHMENT1: 36065,
      COLOR_ATTACHMENT2: 36066,
      COLOR_ATTACHMENT3: 36067,
      COLOR_ATTACHMENT4: 36068,
      COLOR_ATTACHMENT5: 36069,
      COLOR_ATTACHMENT6: 36070,
      COLOR_ATTACHMENT7: 36071,
      COLOR_ATTACHMENT8: 36072,
      COLOR_ATTACHMENT9: 36073,
      COLOR_ATTACHMENT10: 36074,
      COLOR_ATTACHMENT11: 36075,
      COLOR_ATTACHMENT12: 36076,
      COLOR_ATTACHMENT13: 36077,
      COLOR_ATTACHMENT14: 36078,
      COLOR_ATTACHMENT15: 36079,
      SAMPLER_3D: 35679,
      SAMPLER_2D_SHADOW: 35682,
      SAMPLER_2D_ARRAY: 36289,
      SAMPLER_2D_ARRAY_SHADOW: 36292,
      SAMPLER_CUBE_SHADOW: 36293,
      INT_SAMPLER_2D: 36298,
      INT_SAMPLER_3D: 36299,
      INT_SAMPLER_CUBE: 36300,
      INT_SAMPLER_2D_ARRAY: 36303,
      UNSIGNED_INT_SAMPLER_2D: 36306,
      UNSIGNED_INT_SAMPLER_3D: 36307,
      UNSIGNED_INT_SAMPLER_CUBE: 36308,
      UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
      MAX_SAMPLES: 36183,
      SAMPLER_BINDING: 35097,
      PIXEL_PACK_BUFFER: 35051,
      PIXEL_UNPACK_BUFFER: 35052,
      PIXEL_PACK_BUFFER_BINDING: 35053,
      PIXEL_UNPACK_BUFFER_BINDING: 35055,
      COPY_READ_BUFFER: 36662,
      COPY_WRITE_BUFFER: 36663,
      COPY_READ_BUFFER_BINDING: 36662,
      COPY_WRITE_BUFFER_BINDING: 36663,
      FLOAT_MAT2x3: 35685,
      FLOAT_MAT2x4: 35686,
      FLOAT_MAT3x2: 35687,
      FLOAT_MAT3x4: 35688,
      FLOAT_MAT4x2: 35689,
      FLOAT_MAT4x3: 35690,
      UNSIGNED_INT_VEC2: 36294,
      UNSIGNED_INT_VEC3: 36295,
      UNSIGNED_INT_VEC4: 36296,
      UNSIGNED_NORMALIZED: 35863,
      SIGNED_NORMALIZED: 36764,
      VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
      VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
      TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
      MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
      TRANSFORM_FEEDBACK_VARYINGS: 35971,
      TRANSFORM_FEEDBACK_BUFFER_START: 35972,
      TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
      TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
      MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
      MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
      INTERLEAVED_ATTRIBS: 35980,
      SEPARATE_ATTRIBS: 35981,
      TRANSFORM_FEEDBACK_BUFFER: 35982,
      TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
      TRANSFORM_FEEDBACK: 36386,
      TRANSFORM_FEEDBACK_PAUSED: 36387,
      TRANSFORM_FEEDBACK_ACTIVE: 36388,
      TRANSFORM_FEEDBACK_BINDING: 36389,
      FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
      FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
      FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
      FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
      FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
      FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
      FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
      FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
      FRAMEBUFFER_DEFAULT: 33304,
      DEPTH24_STENCIL8: 35056,
      DRAW_FRAMEBUFFER_BINDING: 36006,
      READ_FRAMEBUFFER_BINDING: 36010,
      RENDERBUFFER_SAMPLES: 36011,
      FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
      FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
      UNIFORM_BUFFER: 35345,
      UNIFORM_BUFFER_BINDING: 35368,
      UNIFORM_BUFFER_START: 35369,
      UNIFORM_BUFFER_SIZE: 35370,
      MAX_VERTEX_UNIFORM_BLOCKS: 35371,
      MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
      MAX_COMBINED_UNIFORM_BLOCKS: 35374,
      MAX_UNIFORM_BUFFER_BINDINGS: 35375,
      MAX_UNIFORM_BLOCK_SIZE: 35376,
      MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
      MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
      UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
      ACTIVE_UNIFORM_BLOCKS: 35382,
      UNIFORM_TYPE: 35383,
      UNIFORM_SIZE: 35384,
      UNIFORM_BLOCK_INDEX: 35386,
      UNIFORM_OFFSET: 35387,
      UNIFORM_ARRAY_STRIDE: 35388,
      UNIFORM_MATRIX_STRIDE: 35389,
      UNIFORM_IS_ROW_MAJOR: 35390,
      UNIFORM_BLOCK_BINDING: 35391,
      UNIFORM_BLOCK_DATA_SIZE: 35392,
      UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
      UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
      UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
      UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
      OBJECT_TYPE: 37138,
      SYNC_CONDITION: 37139,
      SYNC_STATUS: 37140,
      SYNC_FLAGS: 37141,
      SYNC_FENCE: 37142,
      SYNC_GPU_COMMANDS_COMPLETE: 37143,
      UNSIGNALED: 37144,
      SIGNALED: 37145,
      ALREADY_SIGNALED: 37146,
      TIMEOUT_EXPIRED: 37147,
      CONDITION_SATISFIED: 37148,
      WAIT_FAILED: 37149,
      SYNC_FLUSH_COMMANDS_BIT: 1,
      COLOR: 6144,
      DEPTH: 6145,
      STENCIL: 6146,
      MIN: 32775,
      MAX: 32776,
      DEPTH_COMPONENT24: 33190,
      STREAM_READ: 35041,
      STREAM_COPY: 35042,
      STATIC_READ: 35045,
      STATIC_COPY: 35046,
      DYNAMIC_READ: 35049,
      DYNAMIC_COPY: 35050,
      DEPTH_COMPONENT32F: 36012,
      DEPTH32F_STENCIL8: 36013,
      INVALID_INDEX: 4294967295,
      TIMEOUT_IGNORED: -1,
      MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447,
      VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
      UNMASKED_VENDOR_WEBGL: 37445,
      UNMASKED_RENDERER_WEBGL: 37446,
      MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
      TEXTURE_MAX_ANISOTROPY_EXT: 34046,
      COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
      COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
      COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
      COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
      COMPRESSED_R11_EAC: 37488,
      COMPRESSED_SIGNED_R11_EAC: 37489,
      COMPRESSED_RG11_EAC: 37490,
      COMPRESSED_SIGNED_RG11_EAC: 37491,
      COMPRESSED_RGB8_ETC2: 37492,
      COMPRESSED_RGBA8_ETC2_EAC: 37493,
      COMPRESSED_SRGB8_ETC2: 37494,
      COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
      COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
      COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
      COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
      COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
      COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
      COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
      COMPRESSED_RGB_ETC1_WEBGL: 36196,
      COMPRESSED_RGB_ATC_WEBGL: 35986,
      COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35986,
      COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
      UNSIGNED_INT_24_8_WEBGL: 34042,
      HALF_FLOAT_OES: 36193,
      RGBA32F_EXT: 34836,
      RGB32F_EXT: 34837,
      FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297,
      UNSIGNED_NORMALIZED_EXT: 35863,
      MIN_EXT: 32775,
      MAX_EXT: 32776,
      SRGB_EXT: 35904,
      SRGB_ALPHA_EXT: 35906,
      SRGB8_ALPHA8_EXT: 35907,
      FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296,
      FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723,
      COLOR_ATTACHMENT0_WEBGL: 36064,
      COLOR_ATTACHMENT1_WEBGL: 36065,
      COLOR_ATTACHMENT2_WEBGL: 36066,
      COLOR_ATTACHMENT3_WEBGL: 36067,
      COLOR_ATTACHMENT4_WEBGL: 36068,
      COLOR_ATTACHMENT5_WEBGL: 36069,
      COLOR_ATTACHMENT6_WEBGL: 36070,
      COLOR_ATTACHMENT7_WEBGL: 36071,
      COLOR_ATTACHMENT8_WEBGL: 36072,
      COLOR_ATTACHMENT9_WEBGL: 36073,
      COLOR_ATTACHMENT10_WEBGL: 36074,
      COLOR_ATTACHMENT11_WEBGL: 36075,
      COLOR_ATTACHMENT12_WEBGL: 36076,
      COLOR_ATTACHMENT13_WEBGL: 36077,
      COLOR_ATTACHMENT14_WEBGL: 36078,
      COLOR_ATTACHMENT15_WEBGL: 36079,
      DRAW_BUFFER0_WEBGL: 34853,
      DRAW_BUFFER1_WEBGL: 34854,
      DRAW_BUFFER2_WEBGL: 34855,
      DRAW_BUFFER3_WEBGL: 34856,
      DRAW_BUFFER4_WEBGL: 34857,
      DRAW_BUFFER5_WEBGL: 34858,
      DRAW_BUFFER6_WEBGL: 34859,
      DRAW_BUFFER7_WEBGL: 34860,
      DRAW_BUFFER8_WEBGL: 34861,
      DRAW_BUFFER9_WEBGL: 34862,
      DRAW_BUFFER10_WEBGL: 34863,
      DRAW_BUFFER11_WEBGL: 34864,
      DRAW_BUFFER12_WEBGL: 34865,
      DRAW_BUFFER13_WEBGL: 34866,
      DRAW_BUFFER14_WEBGL: 34867,
      DRAW_BUFFER15_WEBGL: 34868,
      MAX_COLOR_ATTACHMENTS_WEBGL: 36063,
      MAX_DRAW_BUFFERS_WEBGL: 34852,
      VERTEX_ARRAY_BINDING_OES: 34229,
      QUERY_COUNTER_BITS_EXT: 34916,
      CURRENT_QUERY_EXT: 34917,
      QUERY_RESULT_EXT: 34918,
      QUERY_RESULT_AVAILABLE_EXT: 34919,
      TIME_ELAPSED_EXT: 35007,
      TIMESTAMP_EXT: 36392,
      GPU_DISJOINT_EXT: 36795
    };
  }
});

// node_modules/@nebula.gl/layers/dist-es6/shaderlib/outline/outline.js
var require_outline = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/shaderlib/outline/outline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var INITIAL_STATE = {
      outlineEnabled: false,
      outlineRenderShadowmap: false,
      outlineShadowmap: null
    };
    function getUniforms3() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_STATE, outlineEnabled = _ref.outlineEnabled, outlineRenderShadowmap = _ref.outlineRenderShadowmap, outlineShadowmap = _ref.outlineShadowmap;
      var uniforms = {};
      if (outlineEnabled !== void 0) {
        uniforms.outline_uEnabled = outlineEnabled;
      }
      if (outlineRenderShadowmap !== void 0) {
        uniforms.outline_uRenderOutlines = outlineRenderShadowmap;
      }
      if (outlineShadowmap !== void 0) {
        uniforms.outline_uShadowmap = outlineShadowmap;
      }
      return uniforms;
    }
    var vs5 = "attribute float instanceZLevel;\nvarying float outline_vzLevel;\nvarying vec4 outline_vPosition;\n\n// Set the z level for the outline shadowmap rendering\nvoid outline_setZLevel(float zLevel) {\n  outline_vzLevel = zLevel;\n}\n\n// Store an adjusted position for texture2DProj\nvoid outline_setUV(vec4 position) {\n  // mat4(\n  //   0.5, 0.0, 0.0, 0.0,\n  //   0.0, 0.5, 0.0, 0.0,\n  //   0.0, 0.0, 0.5, 0.0,\n  //   0.5, 0.5, 0.5, 1.0\n  // ) * position;\n  outline_vPosition = vec4(position.xyz * 0.5 + position.w * 0.5, position.w);\n}\n";
    var fs4 = "uniform bool outline_uEnabled;\nuniform bool outline_uRenderOutlines;\nuniform sampler2D outline_uShadowmap;\n\nvarying float outline_vzLevel;\n// varying vec2 outline_vUV;\nvarying vec4 outline_vPosition;\n\nconst float OUTLINE_Z_LEVEL_ERROR = 0.01;\n\n// Return a darker color in shadowmap\nvec4 outline_filterShadowColor(vec4 color) {\n  return vec4(outline_vzLevel / 255., outline_vzLevel / 255., outline_vzLevel / 255., 1.);\n}\n\n// Return a darker color if in shadowmap\nvec4 outline_filterDarkenColor(vec4 color) {\n  if (outline_uEnabled) {\n    float maxZLevel;\n    if (outline_vPosition.q > 0.0) {\n      maxZLevel = texture2DProj(outline_uShadowmap, outline_vPosition).r * 255.;\n    } else {\n      discard;\n    }\n    if (maxZLevel < outline_vzLevel + OUTLINE_Z_LEVEL_ERROR) {\n      vec4(color.rgb * 0.5, color.a);\n    } else {\n      discard;\n    }\n  }\n  return color;\n}\n\n// if enabled and rendering outlines - Render depth to shadowmap\n// if enabled and rendering colors - Return a darker color if in shadowmap\n// if disabled, just return color\nvec4 outline_filterColor(vec4 color) {\n  if (outline_uEnabled) {\n    return outline_uRenderOutlines ?\n      outline_filterShadowColor(color) :\n      outline_filterDarkenColor(color);\n  }\n  return color;\n}\n";
    var _default = {
      name: "outline",
      vs: vs5,
      fs: fs4,
      getUniforms: getUniforms3
    };
    exports["default"] = _default;
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-outline-layer/path-outline-layer.js
var require_path_outline_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-outline-layer/path-outline-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _layers = (init_esm9(), __toCommonJS(esm_exports3));
    var _constants = _interopRequireDefault((init_esm23(), __toCommonJS(esm_exports6)));
    var _core = (init_esm6(), __toCommonJS(esm_exports));
    var _outline = _interopRequireDefault(require_outline());
    var _constants2 = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function injectShaderCode(_ref) {
      var source = _ref.source, _ref$code = _ref.code, code = _ref$code === void 0 ? "" : _ref$code;
      var INJECT_CODE = /}[^{}]*$/;
      return source.replace(INJECT_CODE, code.concat("\n}\n"));
    }
    var VS_CODE = "  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n";
    var FS_CODE = "  gl_FragColor = outline_filterColor(gl_FragColor);\n";
    var defaultProps25 = {
      getZLevel: function getZLevel() {
        return 0;
      }
    };
    var PathOutlineLayer = function(_PathLayer) {
      _inherits(PathOutlineLayer2, _PathLayer);
      var _super = _createSuper(PathOutlineLayer2);
      function PathOutlineLayer2() {
        _classCallCheck(this, PathOutlineLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(PathOutlineLayer2, [{
        key: "getShaders",
        // Override getShaders to inject the outline module
        value: function getShaders() {
          var shaders = _get(_getPrototypeOf(PathOutlineLayer2.prototype), "getShaders", this).call(this);
          return Object.assign({}, shaders, {
            modules: shaders.modules.concat([_outline["default"]]),
            vs: injectShaderCode({
              source: shaders.vs,
              code: VS_CODE
            }),
            fs: injectShaderCode({
              source: shaders.fs,
              code: FS_CODE
            })
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState(context) {
          _get(_getPrototypeOf(PathOutlineLayer2.prototype), "initializeState", this).call(this, context);
          this.setState({
            outlineFramebuffer: new _core.Framebuffer(context.gl),
            dummyTexture: new _core.Texture2D(context.gl)
          });
          this.state.attributeManager.addInstanced({
            instanceZLevel: {
              size: 1,
              type: _constants["default"].UNSIGNED_BYTE,
              accessor: "getZLevel"
            }
          });
        }
        // Override draw to add render module
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var _ref2$moduleParameter = _ref2.moduleParameters, moduleParameters = _ref2$moduleParameter === void 0 ? {} : _ref2$moduleParameter, parameters2 = _ref2.parameters, uniforms = _ref2.uniforms, context = _ref2.context;
          var _this$props = this.props, jointRounded = _this$props.jointRounded, capRounded = _this$props.capRounded, billboard = _this$props.billboard, miterLimit = _this$props.miterLimit, widthUnits = _this$props.widthUnits, widthScale = _this$props.widthScale, widthMinPixels = _this$props.widthMinPixels, widthMaxPixels = _this$props.widthMaxPixels;
          uniforms = Object.assign({}, uniforms, {
            jointType: Number(jointRounded),
            capType: Number(capRounded),
            billboard,
            widthUnits: _constants2.UNIT[widthUnits],
            widthScale,
            miterLimit,
            widthMinPixels,
            widthMaxPixels
          });
          var _this$state = this.state, outlineFramebuffer = _this$state.outlineFramebuffer, dummyTexture = _this$state.dummyTexture;
          outlineFramebuffer.resize();
          outlineFramebuffer.clear({
            color: true,
            depth: true
          });
          this.state.model.updateModuleSettings({
            outlineEnabled: true,
            outlineRenderShadowmap: true,
            outlineShadowmap: dummyTexture
          });
          this.state.model.draw({
            uniforms: Object.assign({}, uniforms, {
              jointType: 0,
              widthScale: this.props.widthScale * 1.3
            }),
            parameters: {
              depthTest: false,
              // Biggest value needs to go into buffer
              blendEquation: _constants["default"].MAX
            },
            framebuffer: outlineFramebuffer
          });
          this.state.model.updateModuleSettings({
            outlineEnabled: true,
            outlineRenderShadowmap: false,
            outlineShadowmap: outlineFramebuffer
          });
          this.state.model.draw({
            uniforms: Object.assign({}, uniforms, {
              jointType: Number(jointRounded),
              capType: Number(capRounded),
              widthScale: this.props.widthScale
            }),
            parameters: {
              depthTest: false
            }
          });
        }
      }]);
      return PathOutlineLayer2;
    }(_layers.PathLayer);
    exports["default"] = PathOutlineLayer;
    _defineProperty2(PathOutlineLayer, "layerName", "PathOutlineLayer");
    _defineProperty2(PathOutlineLayer, "defaultProps", defaultProps25);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/arrow-2d-geometry.js
var require_arrow_2d_geometry = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/arrow-2d-geometry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm6(), __toCommonJS(esm_exports));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Arrow2DGeometry = function(_Geometry) {
      _inherits(Arrow2DGeometry2, _Geometry);
      var _super = _createSuper(Arrow2DGeometry2);
      function Arrow2DGeometry2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Arrow2DGeometry2);
        return _super.call(this, Object.assign({}, opts, {
          attributes: getArrowAttributes(opts)
        }));
      }
      return Arrow2DGeometry2;
    }(_core.Geometry);
    exports["default"] = Arrow2DGeometry;
    function getArrowAttributes(_ref) {
      var _ref$length = _ref.length, length = _ref$length === void 0 ? 1 : _ref$length, _ref$headSize = _ref.headSize, headSize = _ref$headSize === void 0 ? 0.2 : _ref$headSize, _ref$tailWidth = _ref.tailWidth, tailWidth = _ref$tailWidth === void 0 ? 0.05 : _ref$tailWidth, _ref$tailStart = _ref.tailStart, tailStart = _ref$tailStart === void 0 ? 0.05 : _ref$tailStart;
      var texCoords = [
        // HEAD
        0.5,
        1,
        0,
        0.5 - headSize / 2,
        1 - headSize,
        0,
        0.5 + headSize / 2,
        1 - headSize,
        0,
        0.5 - tailWidth / 2,
        tailStart,
        0,
        0.5 + tailWidth / 2,
        1 - headSize,
        0,
        0.5 + tailWidth / 2,
        tailStart,
        0,
        0.5 - tailWidth / 2,
        tailStart,
        0,
        0.5 - tailWidth / 2,
        1 - headSize,
        0,
        0.5 + tailWidth / 2,
        1 - headSize,
        0
      ];
      var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
      var positions = new Array(texCoords.length);
      for (var i = 0; i < texCoords.length / 3; i++) {
        var i3 = i * 3;
        positions[i3 + 0] = (texCoords[i3 + 0] - 0.5) * length;
        positions[i3 + 1] = (texCoords[i3 + 1] - 0.5) * length;
        positions[i3 + 2] = 0;
      }
      return {
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        texCoords: new Float32Array(texCoords)
      };
    }
  }
});

// node_modules/math.gl/dist/esm/index.js
var esm_exports7 = {};
__export(esm_exports7, {
  Euler: () => Euler,
  Matrix3: () => Matrix3,
  Matrix4: () => Matrix4,
  Pose: () => Pose,
  Quaternion: () => Quaternion,
  SphericalCoordinates: () => SphericalCoordinates,
  Vector2: () => Vector2,
  Vector3: () => Vector3,
  Vector4: () => Vector4,
  _Euler: () => Euler,
  _MathUtils: () => math_utils_default,
  _Pose: () => Pose,
  _SphericalCoordinates: () => SphericalCoordinates,
  acos: () => acos,
  asin: () => asin,
  assert: () => assert,
  atan: () => atan,
  clamp: () => clamp,
  clone: () => clone,
  config: () => config,
  configure: () => configure,
  cos: () => cos,
  degrees: () => degrees,
  equals: () => equals,
  exactEquals: () => exactEquals,
  formatValue: () => formatValue,
  isArray: () => isArray,
  lerp: () => lerp,
  radians: () => radians,
  sin: () => sin,
  tan: () => tan,
  toDegrees: () => toDegrees,
  toRadians: () => toRadians,
  withEpsilon: () => withEpsilon
});
var init_esm24 = __esm({
  "node_modules/math.gl/dist/esm/index.js"() {
    init_esm4();
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/create-path-markers.js
var require_create_path_markers = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/create-path-markers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = createPathMarkers;
    var _math = (init_esm24(), __toCommonJS(esm_exports7));
    function _createForOfIteratorHelper(o) {
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var it, normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function getLineLength(vPoints) {
      var lineLength = 0;
      for (var i = 0; i < vPoints.length - 1; i++) {
        lineLength += vPoints[i].distance(vPoints[i + 1]);
      }
      return lineLength;
    }
    var DEFAULT_COLOR3 = [0, 0, 0, 255];
    var DEFAULT_DIRECTION = {
      forward: true,
      backward: false
    };
    function createPathMarkers(_ref) {
      var data = _ref.data, _ref$getPath = _ref.getPath, getPath = _ref$getPath === void 0 ? function(x) {
        return x.path;
      } : _ref$getPath, _ref$getDirection = _ref.getDirection, getDirection = _ref$getDirection === void 0 ? function(x) {
        return x.direction;
      } : _ref$getDirection, _ref$getColor = _ref.getColor, getColor = _ref$getColor === void 0 ? function(x) {
        return DEFAULT_COLOR3;
      } : _ref$getColor, _ref$getMarkerPercent = _ref.getMarkerPercentages, getMarkerPercentages = _ref$getMarkerPercent === void 0 ? function(x, info) {
        return [0.5];
      } : _ref$getMarkerPercent, projectFlat = _ref.projectFlat;
      var markers = [];
      var _iterator = _createForOfIteratorHelper(data), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var object = _step.value;
          var path = getPath(object);
          var direction = getDirection(object) || DEFAULT_DIRECTION;
          var color = getColor(object);
          var vPoints = path.map(function(p) {
            return new _math.Vector2(p);
          });
          var vPointsReverse = vPoints.slice(0).reverse();
          var lineLength = getLineLength(vPoints);
          var percentages = getMarkerPercentages(object, {
            lineLength
          });
          var _iterator2 = _createForOfIteratorHelper(percentages), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var percentage = _step2.value;
              if (direction.forward) {
                var marker = createMarkerAlongPath({
                  path: vPoints,
                  percentage,
                  lineLength,
                  color,
                  object,
                  projectFlat
                });
                markers.push(marker);
              }
              if (direction.backward) {
                var _marker = createMarkerAlongPath({
                  path: vPointsReverse,
                  percentage,
                  lineLength,
                  color,
                  object,
                  projectFlat
                });
                markers.push(_marker);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return markers;
    }
    function createMarkerAlongPath(_ref2) {
      var path = _ref2.path, percentage = _ref2.percentage, lineLength = _ref2.lineLength, color = _ref2.color, object = _ref2.object, projectFlat = _ref2.projectFlat;
      var distanceAlong = lineLength * percentage;
      var currentDistance = 0;
      var previousDistance = 0;
      var i = 0;
      for (i = 0; i < path.length - 1; i++) {
        currentDistance += path[i].distance(path[i + 1]);
        if (currentDistance > distanceAlong) {
          break;
        }
        previousDistance = currentDistance;
      }
      if (i === path.length - 1) {
        i -= 1;
      }
      var vDirection = path[i + 1].clone().subtract(path[i]).normalize();
      var along = distanceAlong - previousDistance;
      var vCenter = vDirection.clone().multiply(new _math.Vector2(along, along)).add(path[i]);
      var vDirection2 = new _math.Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));
      var angle = vDirection2.verticalAngle() * 180 / Math.PI;
      return {
        position: [vCenter.x, vCenter.y, 0],
        angle,
        color,
        object
      };
    }
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/polyline.js
var require_polyline = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/polyline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getClosestPointOnLine = getClosestPointOnLine;
    exports.getClosestPointOnPolyline = getClosestPointOnPolyline;
    var _math = (init_esm24(), __toCommonJS(esm_exports7));
    function getClosestPointOnLine(_ref) {
      var p = _ref.p, p1 = _ref.p1, p2 = _ref.p2, _ref$clampToLine = _ref.clampToLine, clampToLine = _ref$clampToLine === void 0 ? true : _ref$clampToLine;
      var lineVector = new _math.Vector3(p2).subtract(p1);
      var pointVector = new _math.Vector3(p).subtract(p1);
      var dotProduct = lineVector.dot(pointVector);
      if (clampToLine) {
        dotProduct = (0, _math.clamp)(dotProduct, 0, 1);
      }
      return lineVector.lerp(dotProduct);
    }
    function getClosestPointOnPolyline(_ref2) {
      var p = _ref2.p, points = _ref2.points;
      p = new _math.Vector3(p);
      var pClosest = null;
      var distanceSquared = Infinity;
      var index = -1;
      for (var i = 0; i < points.length - 1; ++i) {
        var p1 = points[i];
        var p2 = points[i + 1];
        var pClosestOnLine = getClosestPointOnLine({
          p,
          p1,
          p2
        });
        var distanceToLineSquared = p.distanceSquared(pClosestOnLine);
        if (distanceToLineSquared < distanceSquared) {
          distanceSquared = distanceToLineSquared;
          pClosest = pClosestOnLine;
          index = i;
        }
      }
      return {
        point: pClosest,
        index,
        p1: points[index],
        p2: points[index + 1],
        distanceSquared,
        distance: Math.sqrt(distanceSquared)
      };
    }
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/path-marker-layer.js
var require_path_marker_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/path-marker-layer/path-marker-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm8(), __toCommonJS(esm_exports2));
    var _layers = (init_esm9(), __toCommonJS(esm_exports3));
    var _meshLayers = (init_esm20(), __toCommonJS(esm_exports4));
    var _pathOutlineLayer = _interopRequireDefault(require_path_outline_layer());
    var _arrow2dGeometry = _interopRequireDefault(require_arrow_2d_geometry());
    var _createPathMarkers = _interopRequireDefault(require_create_path_markers());
    var _polyline = require_polyline();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DISTANCE_FOR_MULTI_ARROWS = 0.1;
    var ARROW_HEAD_SIZE = 0.2;
    var ARROW_TAIL_WIDTH = 0.05;
    var DEFAULT_MARKER_LAYER = _meshLayers.SimpleMeshLayer;
    var DEFAULT_MARKER_LAYER_PROPS = {
      mesh: new _arrow2dGeometry["default"]({
        headSize: ARROW_HEAD_SIZE,
        tailWidth: ARROW_TAIL_WIDTH
      })
    };
    var defaultProps25 = Object.assign({}, _pathOutlineLayer["default"].defaultProps, {
      MarkerLayer: DEFAULT_MARKER_LAYER,
      markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,
      sizeScale: 100,
      fp64: false,
      highlightIndex: -1,
      highlightPoint: null,
      getPath: function getPath(x) {
        return x.path;
      },
      getColor: function getColor(x) {
        return x.color;
      },
      getMarkerColor: function getMarkerColor(x) {
        return [0, 0, 0, 255];
      },
      getDirection: function getDirection(x) {
        return x.direction;
      },
      getMarkerPercentages: function getMarkerPercentages(object, _ref) {
        var lineLength = _ref.lineLength;
        return lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5];
      }
    });
    var PathMarkerLayer = function(_CompositeLayer) {
      _inherits(PathMarkerLayer2, _CompositeLayer);
      var _super = _createSuper(PathMarkerLayer2);
      function PathMarkerLayer2() {
        _classCallCheck(this, PathMarkerLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(PathMarkerLayer2, [{
        key: "initializeState",
        value: function initializeState() {
          this.state = {
            markers: [],
            mesh: new _arrow2dGeometry["default"]({
              headSize: ARROW_HEAD_SIZE,
              tailWidth: ARROW_TAIL_WIDTH
            }),
            closestPoint: null
          };
        }
        // @ts-ignore
      }, {
        key: "projectFlat",
        value: function projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {
          if (coordinateSystem === _core.COORDINATE_SYSTEM.METER_OFFSETS) {
            var _viewport$metersToLng = viewport.metersToLngLatDelta(xyz), _viewport$metersToLng2 = _slicedToArray(_viewport$metersToLng, 2), dx = _viewport$metersToLng2[0], dy = _viewport$metersToLng2[1];
            var _coordinateOrigin = _slicedToArray(coordinateOrigin, 2), _x = _coordinateOrigin[0], y = _coordinateOrigin[1];
            return viewport.projectFlat([_x + dx, dy + y]);
          } else if (coordinateSystem === _core.COORDINATE_SYSTEM.LNGLAT_OFFSETS) {
            var _xyz = _slicedToArray(xyz, 2), _dx = _xyz[0], _dy = _xyz[1];
            var _coordinateOrigin2 = _slicedToArray(coordinateOrigin, 2), _x2 = _coordinateOrigin2[0], _y = _coordinateOrigin2[1];
            return viewport.projectFlat([_x2 + _dx, _dy + _y]);
          }
          return viewport.projectFlat(xyz);
        }
      }, {
        key: "updateState",
        value: function updateState(_ref2) {
          var _this = this;
          var props = _ref2.props, oldProps = _ref2.oldProps, changeFlags = _ref2.changeFlags;
          if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {
            var _this$props = this.props, data = _this$props.data, getPath = _this$props.getPath, getDirection = _this$props.getDirection, getMarkerColor = _this$props.getMarkerColor, getMarkerPercentages = _this$props.getMarkerPercentages, coordinateSystem = _this$props.coordinateSystem, coordinateOrigin = _this$props.coordinateOrigin;
            var viewport = this.context.viewport;
            var projectFlat = function projectFlat2(o) {
              return _this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);
            };
            this.state.markers = (0, _createPathMarkers["default"])({
              data,
              getPath,
              getDirection,
              getColor: getMarkerColor,
              getMarkerPercentages,
              projectFlat
            });
            this._recalculateClosestPoint();
          }
          if (changeFlags.propsChanged) {
            if (props.point !== oldProps.point) {
              this._recalculateClosestPoint();
            }
          }
        }
      }, {
        key: "_recalculateClosestPoint",
        value: function _recalculateClosestPoint() {
          var _this$props2 = this.props, highlightPoint = _this$props2.highlightPoint, highlightIndex = _this$props2.highlightIndex;
          if (highlightPoint && highlightIndex >= 0) {
            var object = this.props.data[highlightIndex];
            var points = this.props.getPath(object);
            var _getClosestPointOnPol = (0, _polyline.getClosestPointOnPolyline)({
              points,
              p: highlightPoint
            }), point = _getClosestPointOnPol.point;
            this.state.closestPoints = [{
              position: point
            }];
          } else {
            this.state.closestPoints = [];
          }
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(_ref3) {
          var info = _ref3.info;
          return Object.assign(info, {
            // override object with picked feature
            object: info.object && info.object.path || info.object
          });
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          return [new _pathOutlineLayer["default"](
            this.props,
            // @ts-ignore
            this.getSubLayerProps({
              id: "paths",
              // Note: data has to be passed explicitly like this to avoid being empty
              data: this.props.data
            })
          ), new this.props.MarkerLayer(this.getSubLayerProps(Object.assign({}, this.props.markerLayerProps, {
            id: "markers",
            data: this.state.markers,
            getOrientation: function getOrientation(x) {
              return [0, -x.angle, 0];
            },
            getColor: function getColor(x) {
              return x.color;
            },
            sizeScale: this.props.sizeScale,
            fp64: this.props.fp64,
            pickable: false,
            parameters: {
              blend: false,
              depthTest: false
            }
          }))), this.state.closestPoints && new _layers.ScatterplotLayer({
            id: "".concat(this.props.id, "-highlight"),
            data: this.state.closestPoints,
            // @ts-ignore
            fp64: this.props.fp64
          })];
        }
      }]);
      return PathMarkerLayer2;
    }(_core.CompositeLayer);
    exports["default"] = PathMarkerLayer;
    _defineProperty2(PathMarkerLayer, "layerName", "PathMarkerLayer");
    _defineProperty2(PathMarkerLayer, "defaultProps", defaultProps25);
  }
});

// node_modules/@nebula.gl/layers/dist-es6/layers/junction-scatterplot-layer.js
var require_junction_scatterplot_layer = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/layers/junction-scatterplot-layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _core = (init_esm8(), __toCommonJS(esm_exports2));
    var _layers = (init_esm9(), __toCommonJS(esm_exports3));
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var JunctionScatterplotLayer = function(_CompositeLayer) {
      _inherits(JunctionScatterplotLayer2, _CompositeLayer);
      var _super = _createSuper(JunctionScatterplotLayer2);
      function JunctionScatterplotLayer2() {
        _classCallCheck(this, JunctionScatterplotLayer2);
        return _super.apply(this, arguments);
      }
      _createClass(JunctionScatterplotLayer2, [{
        key: "renderLayers",
        value: function renderLayers() {
          var _this$props = this.props, id = _this$props.id, getFillColor = _this$props.getFillColor, getStrokeColor = _this$props.getStrokeColor, getInnerRadius = _this$props.getInnerRadius, updateTriggers = _this$props.updateTriggers;
          return [
            // the full circles
            new _layers.ScatterplotLayer(_objectSpread({}, this.props, {
              id: "".concat(id, "-full"),
              data: this.props.data,
              getLineColor: getStrokeColor,
              updateTriggers: _objectSpread({}, updateTriggers, {
                getStrokeColor: updateTriggers.getStrokeColor
              })
            })),
            // the inner part
            new _layers.ScatterplotLayer(_objectSpread({}, this.props, {
              id: "".concat(id, "-inner"),
              data: this.props.data,
              getFillColor,
              getRadius: getInnerRadius,
              pickable: false,
              updateTriggers: _objectSpread({}, updateTriggers, {
                getFillColor: updateTriggers.getFillColor,
                getRadius: updateTriggers.getInnerRadius
              })
            }))
          ];
        }
      }]);
      return JunctionScatterplotLayer2;
    }(_core.CompositeLayer);
    exports["default"] = JunctionScatterplotLayer;
    _defineProperty2(JunctionScatterplotLayer, "layerName", "JunctionScatterplotLayer");
    _defineProperty2(JunctionScatterplotLayer, "defaultProps", _objectSpread({}, _layers.ScatterplotLayer.defaultProps, {
      getFillColor: function getFillColor(d) {
        return [0, 0, 0, 255];
      },
      getStrokeColor: function getStrokeColor(d) {
        return [255, 255, 255, 255];
      },
      getInnerRadius: function getInnerRadius(d) {
        return 1;
      }
    }));
  }
});

// node_modules/@nebula.gl/layers/dist-es6/index.js
var require_dist_es62 = __commonJS({
  "node_modules/@nebula.gl/layers/dist-es6/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ArrowStyles", {
      enumerable: true,
      get: function get() {
        return _style.ArrowStyles;
      }
    });
    Object.defineProperty(exports, "DEFAULT_ARROWS", {
      enumerable: true,
      get: function get() {
        return _style.DEFAULT_ARROWS;
      }
    });
    Object.defineProperty(exports, "MAX_ARROWS", {
      enumerable: true,
      get: function get() {
        return _style.MAX_ARROWS;
      }
    });
    Object.defineProperty(exports, "EditableGeoJsonLayer", {
      enumerable: true,
      get: function get() {
        return _editableGeojsonLayer["default"];
      }
    });
    Object.defineProperty(exports, "EditableH3ClusterLayer", {
      enumerable: true,
      get: function get() {
        return _editableH3ClusterLayer["default"];
      }
    });
    Object.defineProperty(exports, "SelectionLayer", {
      enumerable: true,
      get: function get() {
        return _selectionLayer["default"];
      }
    });
    Object.defineProperty(exports, "ElevatedEditHandleLayer", {
      enumerable: true,
      get: function get() {
        return _elevatedEditHandleLayer["default"];
      }
    });
    Object.defineProperty(exports, "PathOutlineLayer", {
      enumerable: true,
      get: function get() {
        return _pathOutlineLayer["default"];
      }
    });
    Object.defineProperty(exports, "PathMarkerLayer", {
      enumerable: true,
      get: function get() {
        return _pathMarkerLayer["default"];
      }
    });
    Object.defineProperty(exports, "JunctionScatterplotLayer", {
      enumerable: true,
      get: function get() {
        return _junctionScatterplotLayer["default"];
      }
    });
    Object.defineProperty(exports, "toDeckColor", {
      enumerable: true,
      get: function get() {
        return _utils.toDeckColor;
      }
    });
    var _style = require_style();
    var _editableGeojsonLayer = _interopRequireDefault(require_editable_geojson_layer());
    var _editableH3ClusterLayer = _interopRequireDefault(require_editable_h3_cluster_layer());
    var _selectionLayer = _interopRequireDefault(require_selection_layer());
    var _elevatedEditHandleLayer = _interopRequireDefault(require_elevated_edit_handle_layer());
    var _pathOutlineLayer = _interopRequireDefault(require_path_outline_layer());
    var _pathMarkerLayer = _interopRequireDefault(require_path_marker_layer());
    var _junctionScatterplotLayer = _interopRequireDefault(require_junction_scatterplot_layer());
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});
export default require_dist_es62();
//# sourceMappingURL=@nebula__gl_layers.js.map
